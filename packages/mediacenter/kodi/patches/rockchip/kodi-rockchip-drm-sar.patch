--- a/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp	2019-06-22 17:16:22.000000000 +0000
+++ b/xbmc/cores/VideoPlayer/DVDCodecs/Video/DVDVideoCodecDRMPRIME.cpp	2019-08-20 18:35:02.639290285 +0000
@@ -1,304 +1,355 @@
-/*
- *  Copyright (C) 2017-2018 Team Kodi
- *  This file is part of Kodi - https://kodi.tv
- *
- *  SPDX-License-Identifier: GPL-2.0-or-later
- *  See LICENSES/README.md for more information.
- */
-
-#include "DVDVideoCodecDRMPRIME.h"
-
-#include "ServiceBroker.h"
-#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
-#include "cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h"
-#include "settings/Settings.h"
-#include "settings/SettingsComponent.h"
-#include "settings/lib/Setting.h"
-#include "threads/SingleLock.h"
-#include "utils/log.h"
-#include "windowing/gbm/WinSystemGbm.h"
-
-extern "C" {
-#include <libavcodec/avcodec.h>
-#include <libavutil/pixdesc.h>
-}
-
-using namespace KODI::WINDOWING::GBM;
-
-CDVDVideoCodecDRMPRIME::CDVDVideoCodecDRMPRIME(CProcessInfo& processInfo)
-  : CDVDVideoCodec(processInfo)
-{
-  m_pFrame = av_frame_alloc();
-  m_videoBufferPool = std::make_shared<CVideoBufferPoolDRMPRIME>();
-}
-
-CDVDVideoCodecDRMPRIME::~CDVDVideoCodecDRMPRIME()
-{
-  av_frame_free(&m_pFrame);
-  avcodec_free_context(&m_pCodecContext);
-}
-
-CDVDVideoCodec* CDVDVideoCodecDRMPRIME::Create(CProcessInfo& processInfo)
-{
-  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEPRIMEDECODER))
-    return new CDVDVideoCodecDRMPRIME(processInfo);
-  return nullptr;
-}
-
-void CDVDVideoCodecDRMPRIME::Register()
-{
-  CServiceBroker::GetSettingsComponent()->GetSettings()->GetSetting(CSettings::SETTING_VIDEOPLAYER_USEPRIMEDECODER)->SetVisible(true);
-  CDVDFactoryCodec::RegisterHWVideoCodec("drm_prime", CDVDVideoCodecDRMPRIME::Create);
-}
-
-static const AVCodecHWConfig* FindHWConfig(const AVCodec* codec)
-{
-  const AVCodecHWConfig* config = nullptr;
-  for (int n = 0; (config = avcodec_get_hw_config(codec, n)); n++)
-  {
-    if (config->pix_fmt != AV_PIX_FMT_DRM_PRIME)
-      continue;
-
-    if ((config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX) &&
-        config->device_type == AV_HWDEVICE_TYPE_DRM)
-      return config;
-
-    if ((config->methods & AV_CODEC_HW_CONFIG_METHOD_INTERNAL))
-      return config;
-  }
-
-  return nullptr;
-}
-
-static const AVCodec* FindDecoder(CDVDStreamInfo& hints)
-{
-  const AVCodec* codec = nullptr;
-  void *i = 0;
-
-  while ((codec = av_codec_iterate(&i)))
-  {
-    if (!av_codec_is_decoder(codec))
-      continue;
-    if (codec->id != hints.codec)
-      continue;
-
-    const AVCodecHWConfig* config = FindHWConfig(codec);
-    if (config)
-      return codec;
-  }
-
-  return nullptr;
-}
-
-enum AVPixelFormat CDVDVideoCodecDRMPRIME::GetFormat(struct AVCodecContext* avctx, const enum AVPixelFormat* fmt)
-{
-  for (int n = 0; fmt[n] != AV_PIX_FMT_NONE; n++)
-  {
-    if (fmt[n] == AV_PIX_FMT_DRM_PRIME)
-    {
-      CDVDVideoCodecDRMPRIME* ctx = static_cast<CDVDVideoCodecDRMPRIME*>(avctx->opaque);
-      ctx->UpdateProcessInfo(avctx, fmt[n]);
-      return fmt[n];
-    }
-  }
-
-  return AV_PIX_FMT_NONE;
-}
-
-bool CDVDVideoCodecDRMPRIME::Open(CDVDStreamInfo& hints, CDVDCodecOptions& options)
-{
-  const AVCodec* pCodec = FindDecoder(hints);
-  if (!pCodec)
-  {
-    CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::%s - unable to find decoder for codec %d", __FUNCTION__, hints.codec);
-    return false;
-  }
-
-  CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - using decoder %s", __FUNCTION__, pCodec->long_name ? pCodec->long_name : pCodec->name);
-
-  m_pCodecContext = avcodec_alloc_context3(pCodec);
-  if (!m_pCodecContext)
-    return false;
-
-  const AVCodecHWConfig* pConfig = FindHWConfig(pCodec);
-  if (pConfig &&
-      (pConfig->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX) &&
-      pConfig->device_type == AV_HWDEVICE_TYPE_DRM)
-  {
-    CWinSystemGbm* winSystem = dynamic_cast<CWinSystemGbm*>(CServiceBroker::GetWinSystem());
-    if (av_hwdevice_ctx_create(&m_pCodecContext->hw_device_ctx, AV_HWDEVICE_TYPE_DRM, drmGetDeviceNameFromFd2(winSystem->GetDrm()->GetFileDescriptor()), nullptr, 0) < 0)
-    {
-      CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - unable to create hwdevice context", __FUNCTION__);
-      avcodec_free_context(&m_pCodecContext);
-      return false;
-    }
-  }
-
-  m_pCodecContext->pix_fmt = AV_PIX_FMT_DRM_PRIME;
-  m_pCodecContext->opaque = static_cast<void*>(this);
-  m_pCodecContext->get_format = GetFormat;
-  m_pCodecContext->codec_tag = hints.codec_tag;
-  m_pCodecContext->coded_width = hints.width;
-  m_pCodecContext->coded_height = hints.height;
-  m_pCodecContext->bits_per_coded_sample = hints.bitsperpixel;
-  m_pCodecContext->time_base.num = 1;
-  m_pCodecContext->time_base.den = DVD_TIME_BASE;
-
-  if (hints.extradata && hints.extrasize > 0)
-  {
-    m_pCodecContext->extradata_size = hints.extrasize;
-    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + AV_INPUT_BUFFER_PADDING_SIZE);
-    memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
-  }
-
-  if (avcodec_open2(m_pCodecContext, pCodec, nullptr) < 0)
-  {
-    CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - unable to open codec", __FUNCTION__);
-    avcodec_free_context(&m_pCodecContext);
-    return false;
-  }
-
-  UpdateProcessInfo(m_pCodecContext, m_pCodecContext->pix_fmt);
-  m_processInfo.SetVideoDeintMethod("none");
-  m_processInfo.SetVideoDAR(hints.aspect);
-
-  return true;
-}
-
-void CDVDVideoCodecDRMPRIME::UpdateProcessInfo(struct AVCodecContext* avctx, const enum AVPixelFormat pix_fmt)
-{
-  const char* pixFmtName = av_get_pix_fmt_name(pix_fmt);
-  m_processInfo.SetVideoPixelFormat(pixFmtName ? pixFmtName : "");
-  m_processInfo.SetVideoDimensions(avctx->coded_width, avctx->coded_height);
-
-  if (avctx->codec && avctx->codec->name)
-    m_name = std::string("ff-") + avctx->codec->name;
-  else
-    m_name = "ffmpeg";
-
-  m_processInfo.SetVideoDecoderName(m_name, pix_fmt == AV_PIX_FMT_DRM_PRIME);
-}
-
-bool CDVDVideoCodecDRMPRIME::AddData(const DemuxPacket& packet)
-{
-  if (!m_pCodecContext)
-    return true;
-
-  AVPacket avpkt;
-  av_init_packet(&avpkt);
-  avpkt.data = packet.pData;
-  avpkt.size = packet.iSize;
-  avpkt.dts = (packet.dts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : static_cast<int64_t>(packet.dts / DVD_TIME_BASE * AV_TIME_BASE);
-  avpkt.pts = (packet.pts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : static_cast<int64_t>(packet.pts / DVD_TIME_BASE * AV_TIME_BASE);
-  avpkt.side_data = static_cast<AVPacketSideData*>(packet.pSideData);
-  avpkt.side_data_elems = packet.iSideDataElems;
-
-  int ret = avcodec_send_packet(m_pCodecContext, &avpkt);
-  if (ret == AVERROR(EAGAIN))
-    return false;
-  else if (ret == AVERROR_EOF)
-    return true;
-  else if (ret)
-  {
-    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::%s - send packet failed, ret:%d", __FUNCTION__, ret);
-    return false;
-  }
-
-  return true;
-}
-
-void CDVDVideoCodecDRMPRIME::Reset()
-{
-  if (!m_pCodecContext)
-    return;
-
-  avcodec_flush_buffers(m_pCodecContext);
-  av_frame_unref(m_pFrame);
-  m_codecControlFlags = 0;
-}
-
-void CDVDVideoCodecDRMPRIME::Drain()
-{
-  AVPacket avpkt;
-  av_init_packet(&avpkt);
-  avpkt.data = nullptr;
-  avpkt.size = 0;
-  avcodec_send_packet(m_pCodecContext, &avpkt);
-}
-
-void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
-{
-  pVideoPicture->iWidth = m_pFrame->width;
-  pVideoPicture->iHeight = m_pFrame->height;
-
-  double aspect_ratio = 0;
-  AVRational pixel_aspect = m_pFrame->sample_aspect_ratio;
-  if (pixel_aspect.num)
-    aspect_ratio = av_q2d(pixel_aspect) * pVideoPicture->iWidth / pVideoPicture->iHeight;
-
-  if (aspect_ratio <= 0.0)
-    aspect_ratio = (float)pVideoPicture->iWidth / (float)pVideoPicture->iHeight;
-
-  pVideoPicture->iDisplayWidth = ((int)lrint(pVideoPicture->iHeight * aspect_ratio)) & -3;
-  pVideoPicture->iDisplayHeight = pVideoPicture->iHeight;
-  if (pVideoPicture->iDisplayWidth > pVideoPicture->iWidth)
-  {
-    pVideoPicture->iDisplayWidth = pVideoPicture->iWidth;
-    pVideoPicture->iDisplayHeight = ((int)lrint(pVideoPicture->iWidth / aspect_ratio)) & -3;
-  }
-
-  pVideoPicture->color_range = m_pFrame->color_range == AVCOL_RANGE_JPEG ? 1 : 0;
-  pVideoPicture->color_primaries = m_pFrame->color_primaries;
-  pVideoPicture->color_transfer = m_pFrame->color_trc;
-  pVideoPicture->color_space = m_pFrame->colorspace;
-
-  pVideoPicture->iRepeatPicture = 0;
-  pVideoPicture->iFlags = 0;
-  pVideoPicture->iFlags |= m_pFrame->interlaced_frame ? DVP_FLAG_INTERLACED : 0;
-  pVideoPicture->iFlags |= m_pFrame->top_field_first ? DVP_FLAG_TOP_FIELD_FIRST: 0;
-  pVideoPicture->iFlags |= m_pFrame->data[0] ? 0 : DVP_FLAG_DROPPED;
-
-  int64_t pts = m_pFrame->pts;
-  if (pts == AV_NOPTS_VALUE)
-    pts = m_pFrame->best_effort_timestamp;
-  pVideoPicture->pts = (pts == AV_NOPTS_VALUE) ? DVD_NOPTS_VALUE : (double)pts * DVD_TIME_BASE / AV_TIME_BASE;
-  pVideoPicture->dts = DVD_NOPTS_VALUE;
-}
-
-CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideoPicture)
-{
-  if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
-    Drain();
-
-  int ret = avcodec_receive_frame(m_pCodecContext, m_pFrame);
-  if (ret == AVERROR(EAGAIN))
-    return VC_BUFFER;
-  else if (ret == AVERROR_EOF)
-    return VC_EOF;
-  else if (ret)
-  {
-    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::%s - receive frame failed, ret:%d", __FUNCTION__, ret);
-    return VC_ERROR;
-  }
-
-  if (pVideoPicture->videoBuffer)
-    pVideoPicture->videoBuffer->Release();
-  pVideoPicture->videoBuffer = nullptr;
-
-  SetPictureParams(pVideoPicture);
-
-  if (m_pFrame->format == AV_PIX_FMT_DRM_PRIME)
-  {
-    CVideoBufferDRMPRIME* buffer = dynamic_cast<CVideoBufferDRMPRIME*>(m_videoBufferPool->Get());
-    buffer->SetRef(m_pFrame);
-    pVideoPicture->videoBuffer = buffer;
-  }
-
-  if (!pVideoPicture->videoBuffer)
-  {
-    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - videoBuffer:nullptr format:{}", __FUNCTION__, av_get_pix_fmt_name(static_cast<AVPixelFormat>(m_pFrame->format)));
-    return VC_ERROR;
-  }
-
-  return VC_PICTURE;
-}
+/*
+ *  Copyright (C) 2017-2018 Team Kodi
+ *  This file is part of Kodi - https://kodi.tv
+ *
+ *  SPDX-License-Identifier: GPL-2.0-or-later
+ *  See LICENSES/README.md for more information.
+ */
+
+#include "DVDVideoCodecDRMPRIME.h"
+
+#include "ServiceBroker.h"
+#include "cores/VideoPlayer/DVDCodecs/DVDFactoryCodec.h"
+#include "cores/VideoPlayer/Process/gbm/VideoBufferDRMPRIME.h"
+#include "settings/Settings.h"
+#include "settings/SettingsComponent.h"
+#include "settings/lib/Setting.h"
+#include "threads/SingleLock.h"
+#include "utils/BitstreamConverter.h"
+#include "utils/log.h"
+#include "windowing/gbm/WinSystemGbm.h"
+
+extern "C" {
+#include <libavcodec/avcodec.h>
+#include <libavutil/pixdesc.h>
+}
+
+using namespace KODI::WINDOWING::GBM;
+
+CDVDVideoCodecDRMPRIME::CDVDVideoCodecDRMPRIME(CProcessInfo& processInfo)
+  : CDVDVideoCodec(processInfo)
+  , m_h264_sequence(NULL)
+{
+  m_pFrame = av_frame_alloc();
+  m_videoBufferPool = std::make_shared<CVideoBufferPoolDRMPRIME>();
+}
+
+CDVDVideoCodecDRMPRIME::~CDVDVideoCodecDRMPRIME()
+{
+  av_frame_free(&m_pFrame);
+  avcodec_free_context(&m_pCodecContext);
+  Dispose();
+}
+
+CDVDVideoCodec* CDVDVideoCodecDRMPRIME::Create(CProcessInfo& processInfo)
+{
+  if (CServiceBroker::GetSettingsComponent()->GetSettings()->GetBool(CSettings::SETTING_VIDEOPLAYER_USEPRIMEDECODER))
+    return new CDVDVideoCodecDRMPRIME(processInfo);
+  return nullptr;
+}
+
+void CDVDVideoCodecDRMPRIME::Register()
+{
+  CServiceBroker::GetSettingsComponent()->GetSettings()->GetSetting(CSettings::SETTING_VIDEOPLAYER_USEPRIMEDECODER)->SetVisible(true);
+  CDVDFactoryCodec::RegisterHWVideoCodec("drm_prime", CDVDVideoCodecDRMPRIME::Create);
+}
+
+static const AVCodecHWConfig* FindHWConfig(const AVCodec* codec)
+{
+  const AVCodecHWConfig* config = nullptr;
+  for (int n = 0; (config = avcodec_get_hw_config(codec, n)); n++)
+  {
+    if (config->pix_fmt != AV_PIX_FMT_DRM_PRIME)
+      continue;
+
+    if ((config->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX) &&
+        config->device_type == AV_HWDEVICE_TYPE_DRM)
+      return config;
+
+    if ((config->methods & AV_CODEC_HW_CONFIG_METHOD_INTERNAL))
+      return config;
+  }
+
+  return nullptr;
+}
+
+static const AVCodec* FindDecoder(CDVDStreamInfo& hints)
+{
+  const AVCodec* codec = nullptr;
+  void *i = 0;
+
+  while ((codec = av_codec_iterate(&i)))
+  {
+    if (!av_codec_is_decoder(codec))
+      continue;
+    if (codec->id != hints.codec)
+      continue;
+
+    const AVCodecHWConfig* config = FindHWConfig(codec);
+    if (config)
+      return codec;
+  }
+
+  return nullptr;
+}
+
+enum AVPixelFormat CDVDVideoCodecDRMPRIME::GetFormat(struct AVCodecContext* avctx, const enum AVPixelFormat* fmt)
+{
+  for (int n = 0; fmt[n] != AV_PIX_FMT_NONE; n++)
+  {
+    if (fmt[n] == AV_PIX_FMT_DRM_PRIME)
+    {
+      CDVDVideoCodecDRMPRIME* ctx = static_cast<CDVDVideoCodecDRMPRIME*>(avctx->opaque);
+      ctx->UpdateProcessInfo(avctx, fmt[n]);
+      return fmt[n];
+    }
+  }
+
+  return AV_PIX_FMT_NONE;
+}
+
+bool CDVDVideoCodecDRMPRIME::Open(CDVDStreamInfo& hints, CDVDCodecOptions& options)
+{
+  const AVCodec* pCodec = FindDecoder(hints);
+  if (!pCodec)
+  {
+    CLog::Log(LOGDEBUG, "CDVDVideoCodecDRMPRIME::%s - unable to find decoder for codec %d", __FUNCTION__, hints.codec);
+    return false;
+  }
+
+  CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - using decoder %s", __FUNCTION__, pCodec->long_name ? pCodec->long_name : pCodec->name);
+  
+  m_hints = hints;
+  
+  if (m_hints.aspect == 0.0f && m_hints.codec == AV_CODEC_ID_H264)
+      {
+        m_h264_sequence_pts = 0;
+        m_h264_sequence = new h264_sequence;
+        m_h264_sequence->width  = m_hints.width;
+        m_h264_sequence->height = m_hints.height;
+        m_h264_sequence->ratio  = m_hints.aspect;
+      }
+
+  m_pCodecContext = avcodec_alloc_context3(pCodec);
+  if (!m_pCodecContext)
+    return false;
+
+  const AVCodecHWConfig* pConfig = FindHWConfig(pCodec);
+  if (pConfig &&
+      (pConfig->methods & AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX) &&
+      pConfig->device_type == AV_HWDEVICE_TYPE_DRM)
+  {
+    CWinSystemGbm* winSystem = dynamic_cast<CWinSystemGbm*>(CServiceBroker::GetWinSystem());
+    if (av_hwdevice_ctx_create(&m_pCodecContext->hw_device_ctx, AV_HWDEVICE_TYPE_DRM, drmGetDeviceNameFromFd2(winSystem->GetDrm()->GetFileDescriptor()), nullptr, 0) < 0)
+    {
+      CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - unable to create hwdevice context", __FUNCTION__);
+      avcodec_free_context(&m_pCodecContext);
+      return false;
+    }
+  }
+
+  m_pCodecContext->pix_fmt = AV_PIX_FMT_DRM_PRIME;
+  m_pCodecContext->opaque = static_cast<void*>(this);
+  m_pCodecContext->get_format = GetFormat;
+  m_pCodecContext->codec_tag = hints.codec_tag;
+  m_pCodecContext->coded_width = hints.width;
+  m_pCodecContext->coded_height = hints.height;
+  m_pCodecContext->bits_per_coded_sample = hints.bitsperpixel;
+  m_pCodecContext->time_base.num = 1;
+  m_pCodecContext->time_base.den = DVD_TIME_BASE;
+
+  if (hints.extradata && hints.extrasize > 0)
+  {
+    m_pCodecContext->extradata_size = hints.extrasize;
+    m_pCodecContext->extradata = (uint8_t*)av_mallocz(hints.extrasize + AV_INPUT_BUFFER_PADDING_SIZE);
+    memcpy(m_pCodecContext->extradata, hints.extradata, hints.extrasize);
+  }
+
+  if (avcodec_open2(m_pCodecContext, pCodec, nullptr) < 0)
+  {
+    CLog::Log(LOGNOTICE, "CDVDVideoCodecDRMPRIME::%s - unable to open codec", __FUNCTION__);
+    avcodec_free_context(&m_pCodecContext);
+    return false;
+  }
+
+  UpdateProcessInfo(m_pCodecContext, m_pCodecContext->pix_fmt);
+  m_processInfo.SetVideoDeintMethod("none");
+
+  return true;
+}
+
+void CDVDVideoCodecDRMPRIME::UpdateProcessInfo(struct AVCodecContext* avctx, const enum AVPixelFormat pix_fmt)
+{
+  const char* pixFmtName = av_get_pix_fmt_name(pix_fmt);
+  m_processInfo.SetVideoPixelFormat(pixFmtName ? pixFmtName : "");
+  m_processInfo.SetVideoDimensions(avctx->coded_width, avctx->coded_height);
+
+  if (avctx->codec && avctx->codec->name)
+    m_name = std::string("ff-") + avctx->codec->name;
+  else
+    m_name = "ffmpeg";
+
+  m_processInfo.SetVideoDecoderName(m_name, pix_fmt == AV_PIX_FMT_DRM_PRIME);
+}
+
+bool CDVDVideoCodecDRMPRIME::AddData(const DemuxPacket& packet)
+{
+  if (!m_pCodecContext)
+    return true;
+
+  FrameRateTracking( packet.pData, packet.iSize, packet.dts, packet.pts);
+
+  AVPacket avpkt;
+  av_init_packet(&avpkt);
+  avpkt.data = packet.pData;
+  avpkt.size = packet.iSize;
+  avpkt.dts = (packet.dts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : static_cast<int64_t>(packet.dts / DVD_TIME_BASE * AV_TIME_BASE);
+  avpkt.pts = (packet.pts == DVD_NOPTS_VALUE) ? AV_NOPTS_VALUE : static_cast<int64_t>(packet.pts / DVD_TIME_BASE * AV_TIME_BASE);
+  avpkt.side_data = static_cast<AVPacketSideData*>(packet.pSideData);
+  avpkt.side_data_elems = packet.iSideDataElems;
+
+  int ret = avcodec_send_packet(m_pCodecContext, &avpkt);
+  if (ret == AVERROR(EAGAIN))
+    return false;
+  else if (ret == AVERROR_EOF)
+    return true;
+  else if (ret)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::%s - send packet failed, ret:%d", __FUNCTION__, ret);
+    return false;
+  }
+
+  return true;
+}
+
+void CDVDVideoCodecDRMPRIME::Reset()
+{
+  if (!m_pCodecContext)
+    return;
+
+  avcodec_flush_buffers(m_pCodecContext);
+  av_frame_unref(m_pFrame);
+  m_codecControlFlags = 0;
+}
+
+void CDVDVideoCodecDRMPRIME::Drain()
+{
+  AVPacket avpkt;
+  av_init_packet(&avpkt);
+  avpkt.data = nullptr;
+  avpkt.size = 0;
+  avcodec_send_packet(m_pCodecContext, &avpkt);
+}
+
+void CDVDVideoCodecDRMPRIME::SetPictureParams(VideoPicture* pVideoPicture)
+{
+  pVideoPicture->iWidth = m_pFrame->width;
+  pVideoPicture->iHeight = m_pFrame->height;
+
+  double aspect_ratio = 0;
+  AVRational pixel_aspect = m_pFrame->sample_aspect_ratio;
+  if (pixel_aspect.num)
+    aspect_ratio = av_q2d(pixel_aspect) * pVideoPicture->iWidth / pVideoPicture->iHeight;
+
+  if (aspect_ratio <= 0.0)
+    aspect_ratio = (float)pVideoPicture->iWidth / (float)pVideoPicture->iHeight;
+
+  if (m_h264_sequence)
+  {
+    m_aspect_ratio = m_h264_sequence->ratio;
+	 aspect_ratio = m_aspect_ratio;
+  }
+
+  m_processInfo.SetVideoDAR(static_cast<float>(aspect_ratio));
+  pVideoPicture->iDisplayWidth = ((int)lrint(pVideoPicture->iHeight * aspect_ratio)) & -3;
+  pVideoPicture->iDisplayHeight = pVideoPicture->iHeight;
+  if (pVideoPicture->iDisplayWidth > pVideoPicture->iWidth)
+  {
+    pVideoPicture->iDisplayWidth = pVideoPicture->iWidth;
+    pVideoPicture->iDisplayHeight = ((int)lrint(pVideoPicture->iWidth / aspect_ratio)) & -3;
+  }
+
+  pVideoPicture->color_range = m_pFrame->color_range == AVCOL_RANGE_JPEG ? 1 : 0;
+  pVideoPicture->color_primaries = m_pFrame->color_primaries;
+  pVideoPicture->color_transfer = m_pFrame->color_trc;
+  pVideoPicture->color_space = m_pFrame->colorspace;
+
+  pVideoPicture->iRepeatPicture = 0;
+  pVideoPicture->iFlags = 0;
+  pVideoPicture->iFlags |= m_pFrame->interlaced_frame ? DVP_FLAG_INTERLACED : 0;
+  pVideoPicture->iFlags |= m_pFrame->top_field_first ? DVP_FLAG_TOP_FIELD_FIRST: 0;
+  pVideoPicture->iFlags |= m_pFrame->data[0] ? 0 : DVP_FLAG_DROPPED;
+
+  int64_t pts = m_pFrame->pts;
+  if (pts == AV_NOPTS_VALUE)
+    pts = m_pFrame->best_effort_timestamp;
+  pVideoPicture->pts = (pts == AV_NOPTS_VALUE) ? DVD_NOPTS_VALUE : (double)pts * DVD_TIME_BASE / AV_TIME_BASE;
+  pVideoPicture->dts = DVD_NOPTS_VALUE;
+}
+
+CDVDVideoCodec::VCReturn CDVDVideoCodecDRMPRIME::GetPicture(VideoPicture* pVideoPicture)
+{
+  if (m_codecControlFlags & DVD_CODEC_CTRL_DRAIN)
+    Drain();
+
+  int ret = avcodec_receive_frame(m_pCodecContext, m_pFrame);
+  if (ret == AVERROR(EAGAIN))
+    return VC_BUFFER;
+  else if (ret == AVERROR_EOF)
+    return VC_EOF;
+  else if (ret)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::%s - receive frame failed, ret:%d", __FUNCTION__, ret);
+    return VC_ERROR;
+  }
+
+  if (pVideoPicture->videoBuffer)
+    pVideoPicture->videoBuffer->Release();
+  pVideoPicture->videoBuffer = nullptr;
+
+  SetPictureParams(pVideoPicture);
+
+  if (m_pFrame->format == AV_PIX_FMT_DRM_PRIME)
+  {
+    CVideoBufferDRMPRIME* buffer = dynamic_cast<CVideoBufferDRMPRIME*>(m_videoBufferPool->Get());
+    buffer->SetRef(m_pFrame);
+    pVideoPicture->videoBuffer = buffer;
+  }
+
+  if (!pVideoPicture->videoBuffer)
+  {
+    CLog::Log(LOGERROR, "CDVDVideoCodecDRMPRIME::{} - videoBuffer:nullptr format:{}", __FUNCTION__, av_get_pix_fmt_name(static_cast<AVPixelFormat>(m_pFrame->format)));
+    return VC_ERROR;
+  }
+
+  return VC_PICTURE;
+}
+
+void CDVDVideoCodecDRMPRIME::FrameRateTracking(uint8_t *pData, int iSize, double dts, double pts)
+{
+  // h264 aspect ratio handling
+  if (m_h264_sequence)
+  {
+    // probe demux for SPS NAL and decode aspect ratio
+    if (CBitstreamConverter::h264_sequence_header(pData, iSize, m_h264_sequence))
+    {
+      m_h264_sequence_pts = pts;
+      if (m_h264_sequence_pts == DVD_NOPTS_VALUE)
+          m_h264_sequence_pts = dts;
+
+      CLog::Log(LOGDEBUG, "detected h264 aspect ratio(%f)",
+        m_h264_sequence->ratio);
+      m_hints.width    = m_h264_sequence->width;
+      m_hints.height   = m_h264_sequence->height;
+      m_hints.aspect   = m_h264_sequence->ratio;
+    }
+  }
+}
+
+void CDVDVideoCodecDRMPRIME::Dispose(void)
+{
+
+  if (m_h264_sequence)
+    delete m_h264_sequence, m_h264_sequence = NULL;
+
+}
diff --git a/xbmc/utils/BitstreamConverter.cpp b/xbmc/utils/BitstreamConverter.cpp
index 978f294..d1f7cfb 100644
--- a/xbmc/utils/BitstreamConverter.cpp
+++ b/xbmc/utils/BitstreamConverter.cpp
@@ -176,6 +176,18 @@ static int nal_bs_read_ue(nal_bitstream *bs)
   return ((1 << i) - 1 + nal_bs_read(bs, i));
 }
 
+// read signed Exp-Golomb code
+static int nal_bs_read_se(nal_bitstream *bs)
+{
+  int i = 0;
+
+  i = nal_bs_read_ue (bs);
+  /* (-1)^(i+1) Ceil (i / 2) */
+  i = (i + 1) / 2 * (i & 1 ? 1 : -1);
+
+  return i;
+}
+
 static const uint8_t* avc_find_startcode_internal(const uint8_t *p, const uint8_t *end)
 {
   const uint8_t *a = p + 4 - ((intptr_t)p & 3);
@@ -1215,3 +1227,312 @@ bool CBitstreamConverter::mpeg2_sequence_header(const uint8_t *data, const uint3
   return changed;
 }
 
+bool CBitstreamConverter::h264_sequence_header(const uint8_t *data, const uint32_t size, h264_sequence *sequence)
+{
+    // parse nal units until SPS is found
+    // and return the width, height and aspect ratio if changed.
+    bool changed = false;
+
+    if (!data)
+        return changed;
+
+    const uint8_t *p = data;
+    const uint8_t *end = p + size;
+    const uint8_t *nal_start, *nal_end;
+
+    int profile_idc;
+    int chroma_format_idc = 1;
+    uint8_t pic_order_cnt_type;
+    uint8_t aspect_ratio_idc = 0;
+    uint8_t separate_colour_plane_flag = 0;
+    int8_t frame_mbs_only_flag = -1;
+    unsigned int pic_width, pic_width_cropped;
+    unsigned int pic_height, pic_height_cropped;
+    unsigned int frame_crop_right_offset = 0;
+    unsigned int frame_crop_bottom_offset = 0;
+    unsigned int sar_width = 0;
+    unsigned int sar_height = 0;
+    uint32_t unitsInTick = 0;
+    uint32_t timeScale = 0;
+
+    int lastScale;
+    int nextScale;
+    int deltaScale;
+
+    nal_start = avc_find_startcode(p, end);
+
+    while (nal_start < end)
+    {
+        while (!*(nal_start++));
+
+        nal_end = avc_find_startcode(nal_start, end);
+
+        if ((*nal_start & 0x1f) == 7) // SPS
+        {
+            nal_bitstream bs;
+            nal_bs_init(&bs, nal_start, end - nal_start);
+
+            nal_bs_read(&bs, 8); // NAL unit type
+
+            profile_idc = nal_bs_read(&bs, 8);  // profile_idc
+
+            nal_bs_read(&bs, 1);  // constraint_set0_flag
+            nal_bs_read(&bs, 1);  // constraint_set1_flag
+            nal_bs_read(&bs, 1);  // constraint_set2_flag
+            nal_bs_read(&bs, 1);  // constraint_set3_flag
+            nal_bs_read(&bs, 4);  // reserved
+            nal_bs_read(&bs, 8);  // level_idc
+            nal_bs_read_ue(&bs);  // sps_id
+
+            if (profile_idc == 100 || profile_idc == 110 || profile_idc == 122 ||
+                profile_idc == 244 || profile_idc == 44  || profile_idc == 83  ||
+                profile_idc == 86  || profile_idc == 118 || profile_idc == 128 )
+            {
+
+                chroma_format_idc = nal_bs_read_ue(&bs); // chroma_format_idc
+                // high_profile
+                if (chroma_format_idc == 3)
+                {
+                    separate_colour_plane_flag = nal_bs_read(&bs, 1); // separate_colour_plane_flag
+                }
+
+                nal_bs_read_ue(&bs); // bit_depth_luma_minus8
+                nal_bs_read_ue(&bs); // bit_depth_chroma_minus8
+                nal_bs_read(&bs, 1); // qpprime_y_zero_transform_bypass_flag
+
+                if (nal_bs_read (&bs, 1)) // seq_scaling_matrix_present_flag
+                {
+
+                    for (int idx = 0; idx < ((chroma_format_idc != 3) ? 8 : 12); ++idx)
+                    {
+                        if (nal_bs_read(&bs, 1)) // scaling list present
+                        {
+                            lastScale = nextScale = 8;
+                            int sl_n = ((idx < 6) ? 16 : 64);
+
+                            for(int sl_i = 0; sl_i < sl_n; ++sl_i)
+                            {
+                                if (nextScale != 0)
+                                {
+                                    deltaScale = nal_bs_read_se(&bs);
+                                    nextScale = (lastScale + deltaScale + 256) % 256;
+
+                                }
+                                lastScale = (nextScale == 0) ? lastScale : nextScale;
+                            }
+                        }
+                    }
+                }
+            }
+
+            nal_bs_read_ue(&bs); // log2_max_frame_num_minus4
+
+            pic_order_cnt_type = nal_bs_read_ue(&bs); // pic_order_cnt_type
+
+            if (pic_order_cnt_type == 0)
+                nal_bs_read_ue(&bs); //  log2_max_pic_order_cnt_lsb_minus4
+            else if (pic_order_cnt_type == 1)
+            {
+                nal_bs_read(&bs, 1); // delta_pic_order_always_zero_flag
+                nal_bs_read_se(&bs); // offset_for_non_ref_pic
+                nal_bs_read_se(&bs); // offset_for_top_to_bottom_field
+
+                unsigned int tmp, idx;
+                tmp =  nal_bs_read_ue(&bs);
+                for (idx = 0; idx < tmp; ++idx)
+                    nal_bs_read_se(&bs); // offset_for_ref_frame[i]
+            }
+
+            nal_bs_read_ue(&bs); // num_ref_frames
+            nal_bs_read(&bs, 1); // gaps_in_frame_num_allowed_flag
+
+            pic_width = (nal_bs_read_ue(&bs) + 1) * 16 ; // pic_width
+            pic_height = (nal_bs_read_ue(&bs) + 1) * 16; // pic_height
+
+            frame_mbs_only_flag = nal_bs_read(&bs, 1); // frame_mbs_only_flag
+            if (!frame_mbs_only_flag)
+            {
+                pic_height *= 2;
+                nal_bs_read(&bs, 1); // mb_adaptive_frame_field_flag
+            }
+
+            nal_bs_read(&bs, 1); // direct_8x8_inference_flag
+
+            if (nal_bs_read(&bs, 1)) // frame_cropping_flag
+            {
+                nal_bs_read_ue(&bs); // frame_crop_left_offset
+                frame_crop_right_offset = nal_bs_read_ue(&bs); // frame_crop_right_offset
+                nal_bs_read_ue(&bs); // frame_crop_top_offset
+                frame_crop_bottom_offset = nal_bs_read_ue(&bs); // frame_crop_bottom_offset
+            }
+
+            if (nal_bs_read(&bs, 1)) // vui_parameters_present_flag
+            {
+                if (nal_bs_read(&bs, 1)) //aspect_ratio_info_present_flag
+                {
+                    aspect_ratio_idc = nal_bs_read(&bs, 8); // aspect_ratio_idc
+
+                    if (aspect_ratio_idc == 255) // EXTENDED_SAR
+                    {
+                        sar_width  = nal_bs_read(&bs, 16);
+                        sar_height = nal_bs_read(&bs, 16);
+
+                    }
+                }
+
+                if (nal_bs_read(&bs, 1)) //overscan_info_present_flag
+                    nal_bs_read(&bs, 1); //overscan_appropriate_flag
+
+                if (nal_bs_read(&bs, 1))  //video_signal_type_present_flag
+                {
+                    nal_bs_read(&bs, 3); //video_format
+                    nal_bs_read(&bs, 1); //video_full_range_flag
+                    if (nal_bs_read(&bs, 1)) // colour_description_present_flag
+                    {
+                        nal_bs_read(&bs, 8); // colour_primaries
+                        nal_bs_read(&bs, 8); // transfer_characteristics
+                        nal_bs_read(&bs, 8); // matrix_coefficients
+                    }
+                }
+
+                if (nal_bs_read(&bs, 1)) //chroma_loc_info_present_flag
+                {
+                    nal_bs_read_ue(&bs); //chroma_sample_loc_type_top_field ue(v)
+                    nal_bs_read_ue(&bs); //chroma_sample_loc_type_bottom_field ue(v)
+                }
+
+                if (nal_bs_read(&bs, 1)) //timing_info_present_flag
+                {
+                    unitsInTick = nal_bs_read(&bs, 32); //num_units_in_tick
+                    timeScale = nal_bs_read(&bs, 32); //time_scale
+                    nal_bs_read(&bs, 1); // fixed rate
+                }
+            }
+
+            unsigned int ChromaArrayType, crop;
+            ChromaArrayType = separate_colour_plane_flag ? 0 : chroma_format_idc;
+
+            // cropped width
+            unsigned int CropUnitX, SubWidthC;
+            CropUnitX = 1;
+            SubWidthC = chroma_format_idc == 3 ? 1 : 2;
+            if (ChromaArrayType != 0)
+                CropUnitX = SubWidthC;
+            crop = CropUnitX * frame_crop_right_offset;
+            pic_width_cropped = pic_width - crop;
+
+            if (pic_width_cropped != sequence->width)
+            {
+                changed = true;
+                sequence->width = pic_width_cropped;
+            }
+
+            // cropped height
+            unsigned int CropUnitY, SubHeightC;
+            CropUnitY = 2 - frame_mbs_only_flag;
+            SubHeightC = chroma_format_idc <= 1 ? 2 : 1;
+            if (ChromaArrayType != 0)
+                CropUnitY *= SubHeightC;
+            crop = CropUnitY * frame_crop_bottom_offset;
+            pic_height_cropped = pic_height - crop;
+
+            if (pic_height_cropped != sequence->height)
+            {
+                changed = true;
+                sequence->height = pic_height_cropped;
+            }
+
+            // aspect ratio
+            float ratio = sequence->ratio;
+            if (pic_height_cropped)
+                ratio = pic_width_cropped / (double) pic_height_cropped;
+            switch (aspect_ratio_idc)
+            {
+                case 0:
+                    // Unspecified
+                    break;
+                case 1:
+                    // 1:1
+                    break;
+                case 2:
+                    // 12:11
+                    ratio *= 1.0909090909090908;
+                    break;
+                case 3:
+                    // 10:11
+                    ratio *= 0.90909090909090906;
+                    break;
+                case 4:
+                    // 16:11
+                    ratio *= 1.4545454545454546;
+                    break;
+                case 5:
+                    // 40:33
+                    ratio *= 1.2121212121212122;
+                    break;
+                case 6:
+                    // 24:11
+                    ratio *= 2.1818181818181817;
+                    break;
+                case 7:
+                    // 20:11
+                    ratio *= 1.8181818181818181;
+                    break;
+                case 8:
+                    // 32:11
+                    ratio *= 2.9090909090909092;
+                    break;
+                case 9:
+                    // 80:33
+                    ratio *= 2.4242424242424243;
+                    break;
+                case 10:
+                    // 18:11
+                    ratio *= 1.6363636363636365;
+                    break;
+                case 11:
+                    // 15:11
+                    ratio *= 1.3636363636363635;
+                    break;
+                case 12:
+                    // 64:33
+                    ratio *= 1.9393939393939394;
+                    break;
+                case 13:
+                    // 160:99
+                    ratio *= 1.6161616161616161;
+                    break;
+                case 14:
+                    // 4:3
+                    ratio *= 1.3333333333333333;
+                    break;
+                case 15:
+                    // 3:2
+                    ratio *= 1.5;
+                    break;
+                case 16:
+                    // 2:1
+                    ratio *= 2.0;
+                    break;
+                case 255:
+                    // EXTENDED_SAR
+                    if (sar_height)
+                        ratio *= sar_width / (double)sar_height;
+                    else
+                        ratio = 0.0;
+                    break;
+            } // switch
+            if (aspect_ratio_idc != sequence->ratio_info)
+            {
+                changed = true;
+                sequence->ratio = ratio;
+                sequence->ratio_info = aspect_ratio_idc;
+            }
+
+            break;
+        } // SPS
+        nal_start = nal_end;
+    }
+
+    return changed;
+}
diff --git a/xbmc/utils/BitstreamConverter.h b/xbmc/utils/BitstreamConverter.h
index 0fd2f08..994c51c 100644
--- a/xbmc/utils/BitstreamConverter.h
+++ b/xbmc/utils/BitstreamConverter.h
@@ -35,6 +35,14 @@ typedef struct mpeg2_sequence
   uint32_t  ratio_info;
 } mpeg2_sequence;
 
+typedef struct h264_sequence
+{
+  uint32_t  width;
+  uint32_t  height;
+  float     ratio;
+  uint32_t  ratio_info;
+} h264_sequence;
+
 typedef struct
 {
   int profile_idc;
@@ -98,6 +106,7 @@ public:
   bool              CanStartDecode() const;
 
   static bool       mpeg2_sequence_header(const uint8_t *data, const uint32_t size, mpeg2_sequence *sequence);
+  static bool       h264_sequence_header(const uint8_t *data, const uint32_t size, h264_sequence *sequence);
 
 protected:
   static int  avc_parse_nal_units(AVIOContext *pb, const uint8_t *buf_in, int size);
