From da4220869e18857561f771b83e0fcbda913c4070 Mon Sep 17 00:00:00 2001
From: MrFixIt2001 <mrfixit2001@gmail.com>
Date: Tue, 23 Jun 2020 13:54:56 -0400
Subject: [PATCH] VOP: fix invalid codepath for clocks There was an issue with
 enabling/disabling and preparing/unpreparing clocks. Correct the codepath.

---
 drivers/gpu/drm/rockchip/rockchip_drm_vop.c | 122 ++++++++++++++------
 1 file changed, 88 insertions(+), 34 deletions(-)

diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
index 48b24e644d..a8b029bc7e 100644
--- a/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
+++ b/drivers/gpu/drm/rockchip/rockchip_drm_vop.c
@@ -1325,36 +1325,81 @@ void rockchip_vop_crtc_fb_gamma_get(struct drm_crtc *crtc, u16 *red, u16 *green,
 	*blue = b * 0xffff / (lut_len - 1);
 }
 
-static int vop_core_clks_enable(struct vop *vop)
+static int vop_core_clks_prepare(struct vop *vop)
 {
 	int ret;
 
-	ret = clk_prepare_enable(vop->hclk);
+	ret = clk_prepare(vop->hclk);
 	if (ret < 0) {
-		dev_err(vop->dev, "failed to enable hclk - %d\n", ret);
+		dev_err(vop->dev, "failed to prepare hclk - %d\n", ret);
 		return ret;
 	}
 
-	ret = clk_prepare_enable(vop->aclk);
+	ret = clk_prepare(vop->aclk);
 	if (ret < 0) {
-		dev_err(vop->dev, "failed to enable aclk - %d\n", ret);
-		goto err_disable_hclk;
+		dev_err(vop->dev, "failed to prepare aclk - %d\n", ret);
+		goto err_hclk;
 	}
 
 	return 0;
 
-err_disable_hclk:
-	clk_disable_unprepare(vop->hclk);
+err_hclk:
+	clk_unprepare(vop->hclk);
 	return ret;
 }
 
-static void vop_core_clks_disable(struct vop *vop)
+static void vop_core_clks_disable(struct vop *vop, int action)
+{
+	// Action: 1=disable, 2=unprepare, 3=disable_unprepare
+	switch(action) {
+	case 1:
+		clk_disable(vop->aclk);
+		clk_disable(vop->hclk);
+		break;
+	case 2:
+		clk_unprepare(vop->aclk);
+		clk_unprepare(vop->hclk);
+		break;
+	case 3:
+		clk_disable_unprepare(vop->aclk);
+		clk_disable_unprepare(vop->hclk);
+	}
+}
+
+static int vop_core_clks_enable(struct vop *vop, bool prepare)
 {
-	clk_disable_unprepare(vop->aclk);
-	clk_disable_unprepare(vop->hclk);
+	int ret;
+
+	if (prepare) {
+		ret = vop_core_clks_prepare(vop);
+		if (ret < 0)
+			return ret;
+	}
+
+	ret = clk_enable(vop->hclk);
+	if (ret < 0) {
+		dev_err(vop->dev, "failed to enable hclk - %d\n", ret);
+		goto err_unprepare;
+	}
+
+	ret = clk_enable(vop->aclk);
+	if (ret < 0) {
+		dev_err(vop->dev, "failed to enable aclk - %d\n", ret);
+		goto err_disable_hclk;
+	}
+
+	return 0;
+
+err_disable_hclk:
+	clk_disable(vop->hclk);
+err_unprepare:
+	if (prepare)
+		vop_core_clks_disable(vop, 2);
+
+	return ret;
 }
 
-static void vop_power_enable(struct drm_crtc *crtc)
+static int vop_power_enable(struct drm_crtc *crtc)
 {
 	struct vop *vop = to_vop(crtc);
 	struct reset_control *ahb_rst;
@@ -1365,18 +1410,18 @@ static void vop_power_enable(struct drm_crtc *crtc)
 	ret = pm_runtime_get_sync(vop->dev);
 	if (ret < 0) {
 		dev_err(vop->dev, "failed to get pm runtime: %d\n", ret);
-		return;
+		return ret;
 	}
 
-	ret = vop_core_clks_enable(vop);
+	ret = clk_prepare(vop->dclk);
 	if (ret < 0) {
+		dev_err(vop->dev, "failed to prepare dclk - %d\n", ret);
 		goto err_put_pm_runtime;
 	}
 
-	ret = clk_prepare(vop->dclk);
+	ret = vop_core_clks_enable(vop, true);
 	if (ret < 0) {
-		dev_err(vop->dev, "failed to prepare dclk - %d\n", ret);
-		goto err_disable_core;
+		goto err_unprepare_dclk;
 	}
 
 	/*
@@ -1386,7 +1431,7 @@ static void vop_power_enable(struct drm_crtc *crtc)
 	if (IS_ERR(ahb_rst)) {
 		DRM_DEV_ERROR(vop->dev, "failed to get ahb reset\n");
 		ret = PTR_ERR(ahb_rst);
-		goto err_disable_dclk;
+		goto err_disable_unprepare_core;
 	}
 	reset_control_assert(ahb_rst);
 	usleep_range(10, 20);
@@ -1421,38 +1466,45 @@ static void vop_power_enable(struct drm_crtc *crtc)
 	if (IS_ERR(vop->dclk_rst)) {
 		DRM_DEV_ERROR(vop->dev, "failed to get dclk reset\n");
 		ret = PTR_ERR(vop->dclk_rst);
-		goto err_disable_dclk;
+		goto err_disable_unprepare_core;
 	}
 	reset_control_assert(vop->dclk_rst);
 	usleep_range(10, 20);
 	reset_control_deassert(vop->dclk_rst);
 
-	clk_disable(vop->hclk);
-	clk_disable(vop->aclk);
+	vop_core_clks_disable(vop, 1);
 
 	// Everything is configured - let's enable clocks!
 
-	ret = vop_core_clks_enable(vop);
+	ret = vop_core_clks_enable(vop, false);
 	if (ret < 0) {
-		goto err_disable_dclk;
+		goto err_unprepare_all;
 	}
 
 	ret = clk_enable(vop->dclk);
 	if (ret < 0) {
-		dev_err(vop->dev, "failed to prepare dclk - %d\n", ret);
-		goto err_disable_dclk;
+		dev_err(vop->dev, "failed to enable dclk - %d\n", ret);
+		goto err_disable_unprepare_core;
 	}
 
 	vop->is_enabled = true;
 
-	return;
+	return 0;
+
+err_unprepare_all:
+	vop_core_clks_disable(vop, 2);
+	goto err_unprepare_dclk;
+
+err_disable_unprepare_core:
+	vop_core_clks_disable(vop, 3);
+
+err_unprepare_dclk:
+	clk_unprepare(vop->dclk);
 
-err_disable_dclk:
-	clk_disable_unprepare(vop->dclk);
-err_disable_core:
-	vop_core_clks_disable(vop);
 err_put_pm_runtime:
 	pm_runtime_put_sync(vop->dev);
+
+	return ret;
 }
 
 static void vop_initial(struct drm_crtc *crtc)
@@ -1460,7 +1512,9 @@ static void vop_initial(struct drm_crtc *crtc)
 	struct vop *vop = to_vop(crtc);
 	int i;
 
-	vop_power_enable(crtc);
+	i = vop_power_enable(crtc);
+	if (i < 0)
+		return;
 
 	VOP_CTRL_SET(vop, axi_outstanding_max_num, 30);
 	VOP_CTRL_SET(vop, axi_max_outstanding_en, 1);
@@ -1530,7 +1584,7 @@ static void vop_crtc_disable(struct drm_crtc *crtc)
 
 	pm_runtime_put_sync(vop->dev);
 	clk_disable_unprepare(vop->dclk);
-	vop_core_clks_disable(vop);
+	vop_core_clks_disable(vop, 3);
 	vop_unlock(vop);
 
 	rockchip_clear_system_status(sys_status);
@@ -4047,7 +4101,7 @@ static irqreturn_t vop_isr(int irq, void *data)
 	if (!pm_runtime_get_if_in_use(vop->dev))
 		return IRQ_NONE;
 
-	if (vop_core_clks_enable(vop)) {
+	if (vop_core_clks_enable(vop, false)) {
 		DRM_DEV_ERROR_RATELIMITED(vop->dev, "couldn't enable clocks\n");
 		goto out;
 	}
@@ -4103,7 +4157,7 @@ static irqreturn_t vop_isr(int irq, void *data)
 		DRM_ERROR("Unknown VOP IRQs: %#02x\n", active_irqs);
 
 out_disable:
-	vop_core_clks_disable(vop);
+	vop_core_clks_disable(vop, 1);
 out:
 	pm_runtime_put(vop->dev);
 	return ret;

