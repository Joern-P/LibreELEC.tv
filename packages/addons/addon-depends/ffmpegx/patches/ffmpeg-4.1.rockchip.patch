From 7b677a25ac08940b78bf7d24908ae76757c60475 Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Mon, 29 Oct 2018 11:28:40 +0800
Subject: [PATCH 01/13] find_codec prefer hardware capability

Change-Id: Ib885af15b8942ea13cc1e944ab84ecb6b939ac70
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 libavcodec/allcodecs.c | 13 +++++++++----
 1 file changed, 9 insertions(+), 4 deletions(-)

diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 1b8144a2b70..a8fa898185b 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -853,7 +853,7 @@ static enum AVCodecID remap_deprecated_codec_id(enum AVCodecID id)
 
 static AVCodec *find_codec(enum AVCodecID id, int (*x)(const AVCodec *))
 {
-    const AVCodec *p, *experimental = NULL;
+    const AVCodec *p, *experimental = NULL, *first = NULL;
     void *i = 0;
 
     id = remap_deprecated_codec_id(id);
@@ -864,12 +864,17 @@ static AVCodec *find_codec(enum AVCodecID id, int (*x)(const AVCodec *))
         if (p->id == id) {
             if (p->capabilities & AV_CODEC_CAP_EXPERIMENTAL && !experimental) {
                 experimental = p;
-            } else
-                return (AVCodec*)p;
+            } else {
+                if (!first)
+                    first = p;
+                // prefer hardware
+                if (p->capabilities & AV_CODEC_CAP_HARDWARE)
+                    return (AVCodec*)p;
+            }
         }
     }
 
-    return (AVCodec*)experimental;
+    return first ? (AVCodec*)first : (AVCodec*)experimental;
 }
 
 AVCodec *avcodec_find_encoder(enum AVCodecID id)

From 1e68556c2a834bfd584070adee1aa981d8780b9a Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Mon, 29 Oct 2018 11:58:31 +0800
Subject: [PATCH 02/13] ffplay support display buffer with drm format

This patch disable the video filter to support display drm buffer.
If need video filter, we should duplicate a intermediate frame.

Change-Id: Ic50932841c5f86e928a0c0838844eaadb4d138c0
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 fftools/ffplay.c          | 76 +++++++++++++++++++++++++++++++++++----
 libavcodec/rkmppdec.c     |  1 +
 libavutil/hwcontext_drm.h |  6 ++++
 3 files changed, 77 insertions(+), 6 deletions(-)

diff --git a/fftools/ffplay.c b/fftools/ffplay.c
index ab1f9faccfb..a0be207eb84 100644
--- a/fftools/ffplay.c
+++ b/fftools/ffplay.c
@@ -28,6 +28,7 @@
 #include <math.h>
 #include <limits.h>
 #include <signal.h>
+#include <stdbool.h>
 #include <stdint.h>
 
 #include "libavutil/avstring.h"
@@ -60,6 +61,9 @@
 
 #include <assert.h>
 
+#include <drm_fourcc.h>
+#include "libavutil/hwcontext_drm.h"
+
 const char program_name[] = "ffplay";
 const int program_birth_year = 2003;
 
@@ -906,10 +910,46 @@ static void get_sdl_pix_fmt_and_blendmode(int format, Uint32 *sdl_pix_fmt, SDL_B
     }
 }
 
+static void get_avframe_info(AVFrame *frame,
+                             uint8_t *srcSlice[],
+                             int srcStride[]) {
+    if (frame->format != AV_PIX_FMT_DRM_PRIME) {
+        memcpy(srcSlice, frame->data, sizeof(frame->data));
+        memcpy(srcStride, frame->linesize, sizeof(frame->linesize));
+    } else {
+        AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor*)frame->data[0];
+        AVDRMLayerDescriptor *layer = &desc->layers[0];
+        memset(srcSlice, 0, sizeof(frame->data));
+        memset(srcStride, 0, sizeof(frame->linesize));
+        srcSlice[0] = (uint8_t*)desc->objects[0].ptr;
+        srcSlice[1] = srcSlice[0] + layer->planes[1].offset;
+        srcStride[0] = srcStride[1] = layer->planes[0].pitch;
+    }
+}
+
+static int get_avframe_format(AVFrame *frame) {
+    int av_format = frame->format;
+    if (av_format == AV_PIX_FMT_DRM_PRIME) {
+        AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor*)frame->data[0];
+        AVDRMLayerDescriptor *layer = &desc->layers[0];
+        switch (layer->format) {
+            case DRM_FORMAT_NV12: return AV_PIX_FMT_NV12;
+#ifdef DRM_FORMAT_NV12_10
+            case DRM_FORMAT_NV12_10: return AV_PIX_FMT_P010LE;
+#endif
+            default:
+                av_log(NULL, AV_LOG_FATAL, "Unknown DRM Format: %d\n",
+                       layer->format);
+        }
+    }
+    return av_format;
+}
+
 static int upload_texture(SDL_Texture **tex, AVFrame *frame, struct SwsContext **img_convert_ctx) {
     int ret = 0;
     Uint32 sdl_pix_fmt;
     SDL_BlendMode sdl_blendmode;
+    int av_format = get_avframe_format(frame);
     get_sdl_pix_fmt_and_blendmode(frame->format, &sdl_pix_fmt, &sdl_blendmode);
     if (realloc_texture(tex, sdl_pix_fmt == SDL_PIXELFORMAT_UNKNOWN ? SDL_PIXELFORMAT_ARGB8888 : sdl_pix_fmt, frame->width, frame->height, sdl_blendmode, 0) < 0)
         return -1;
@@ -917,13 +957,17 @@ static int upload_texture(SDL_Texture **tex, AVFrame *frame, struct SwsContext *
         case SDL_PIXELFORMAT_UNKNOWN:
             /* This should only happen if we are not using avfilter... */
             *img_convert_ctx = sws_getCachedContext(*img_convert_ctx,
-                frame->width, frame->height, frame->format, frame->width, frame->height,
+                frame->width, frame->height, av_format, frame->width, frame->height,
                 AV_PIX_FMT_BGRA, sws_flags, NULL, NULL, NULL);
             if (*img_convert_ctx != NULL) {
                 uint8_t *pixels[4];
                 int pitch[4];
                 if (!SDL_LockTexture(*tex, NULL, (void **)pixels, pitch)) {
-                    sws_scale(*img_convert_ctx, (const uint8_t * const *)frame->data, frame->linesize,
+                    uint8_t *srcSlice[AV_NUM_DATA_POINTERS] = { NULL };
+                    int srcStride[AV_NUM_DATA_POINTERS] = { 0 };
+
+                    get_avframe_info(frame, srcSlice, srcStride);
+                    sws_scale(*img_convert_ctx, (const uint8_t * const *)srcSlice, srcStride,
                               0, frame->height, pixels, pitch);
                     SDL_UnlockTexture(*tex);
                 }
@@ -2152,6 +2196,9 @@ static int video_thread(void *arg)
     }
 
     for (;;) {
+#if CONFIG_AVFILTER
+        bool support_avfilter;
+#endif
         ret = get_video_frame(is, frame);
         if (ret < 0)
             goto the_end;
@@ -2159,11 +2206,16 @@ static int video_thread(void *arg)
             continue;
 
 #if CONFIG_AVFILTER
-        if (   last_w != frame->width
+        // ffmpeg avfilter do not support drm fmt.
+        // As avfilter will modify pixels, duplicate a intermediate frame
+        // if wanna support avfilter for drm fmt.
+        support_avfilter = (frame->format != AV_PIX_FMT_DRM_PRIME);
+        if (support_avfilter
+            && (last_w != frame->width
             || last_h != frame->height
             || last_format != frame->format
             || last_serial != is->viddec.pkt_serial
-            || last_vfilter_idx != is->vfilter_idx) {
+            || last_vfilter_idx != is->vfilter_idx)) {
             av_log(NULL, AV_LOG_DEBUG,
                    "Video frame changed from size:%dx%d format:%s serial:%d to size:%dx%d format:%s serial:%d\n",
                    last_w, last_h,
@@ -2189,11 +2241,14 @@ static int video_thread(void *arg)
             frame_rate = av_buffersink_get_frame_rate(filt_out);
         }
 
+        if (support_avfilter) {
         ret = av_buffersrc_add_frame(filt_in, frame);
         if (ret < 0)
             goto the_end;
+        }
 
         while (ret >= 0) {
+            if (support_avfilter) {
             is->frame_last_returned_time = av_gettime_relative() / 1000000.0;
 
             ret = av_buffersink_get_frame_flags(filt_out, frame, 0);
@@ -2208,13 +2263,14 @@ static int video_thread(void *arg)
             if (fabs(is->frame_last_filter_delay) > AV_NOSYNC_THRESHOLD / 10.0)
                 is->frame_last_filter_delay = 0;
             tb = av_buffersink_get_time_base(filt_out);
+            }
 #endif
             duration = (frame_rate.num && frame_rate.den ? av_q2d((AVRational){frame_rate.den, frame_rate.num}) : 0);
             pts = (frame->pts == AV_NOPTS_VALUE) ? NAN : frame->pts * av_q2d(tb);
             ret = queue_picture(is, frame, pts, duration, frame->pkt_pos, is->viddec.pkt_serial);
             av_frame_unref(frame);
 #if CONFIG_AVFILTER
-            if (is->videoq.serial != is->viddec.pkt_serial)
+            if (!support_avfilter || is->videoq.serial != is->viddec.pkt_serial)
                 break;
         }
 #endif
@@ -2241,8 +2297,11 @@ static int subtitle_thread(void *arg)
         if (!(sp = frame_queue_peek_writable(&is->subpq)))
             return 0;
 
-        if ((got_subtitle = decoder_decode_frame(&is->subdec, NULL, &sp->sub)) < 0)
+        if ((got_subtitle = decoder_decode_frame(&is->subdec, NULL, &sp->sub)) < 0) {
+            av_log(NULL, AV_LOG_WARNING,
+                   "ffplay decode subtitle failed or finished\n");
             break;
+        }
 
         pts = 0;
 
@@ -2258,6 +2317,11 @@ static int subtitle_thread(void *arg)
             /* now we can update the picture count */
             frame_queue_push(&is->subpq);
         } else if (got_subtitle) {
+            if (arg) {
+                av_log(NULL, AV_LOG_WARNING,
+                       "ffplay only support graphics subtitle\n");
+                arg = NULL;
+            }
             avsubtitle_free(&sp->sub);
         }
     }
diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index 143d05bd517..b44861c85d8 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -421,6 +421,7 @@ static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
 
             desc->nb_objects = 1;
             desc->objects[0].fd = mpp_buffer_get_fd(buffer);
+            desc->objects[0].ptr = mpp_buffer_get_ptr(buffer);
             desc->objects[0].size = mpp_buffer_get_size(buffer);
 
             desc->nb_layers = 1;
diff --git a/libavutil/hwcontext_drm.h b/libavutil/hwcontext_drm.h
index 42709f215ef..4c40d15b091 100644
--- a/libavutil/hwcontext_drm.h
+++ b/libavutil/hwcontext_drm.h
@@ -50,6 +50,12 @@ typedef struct AVDRMObjectDescriptor {
      * DRM PRIME fd for the object.
      */
     int fd;
+
+    /**
+     * DRM PRIME mapped virtual ptr for above fd.
+     */
+    void *ptr;
+
     /**
      * Total size of the object.
      *

From c1641b882b220a111acaaeb7fed3c5aab5b2ba52 Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Wed, 31 Oct 2018 19:51:28 +0800
Subject: [PATCH 03/13] rkmppdec: fix do not send packet after flush

Change-Id: I6e2c250b05991ab23b770da509f90e938bbc1cb6
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 libavcodec/rkmppdec.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index b44861c85d8..e346b203149 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -474,6 +474,8 @@ static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
         return AVERROR_EOF;
     } else if (ret == MPP_ERR_TIMEOUT) {
         av_log(avctx, AV_LOG_DEBUG, "Timeout when trying to get a frame from MPP\n");
+    } else {
+        av_log(avctx, AV_LOG_DEBUG, "MPP decode_get_frame ret = %d\n", ret);
     }
 
     return AVERROR(EAGAIN);
@@ -545,6 +547,7 @@ static void rkmpp_flush(AVCodecContext *avctx)
     ret = decoder->mpi->reset(decoder->ctx);
     if (ret == MPP_OK) {
         decoder->first_packet = 1;
+        decoder->eos_reached = 0;
     } else
         av_log(avctx, AV_LOG_ERROR, "Failed to reset MPI (code = %d)\n", ret);
 }

From e52b71adc27688eb7b755c90681274e0c5bcdb91 Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Wed, 31 Oct 2018 16:53:23 +0800
Subject: [PATCH 04/13] add h264 rkmppenc

TODO: separate send_frame and receive packet if mpp api support well

Change-Id: Ib3586d5488551ca421cb81488d1b85602a862c14
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 configure              |   1 +
 libavcodec/Makefile    |   1 +
 libavcodec/allcodecs.c |   1 +
 libavcodec/rkmppenc.c  | 695 +++++++++++++++++++++++++++++++++++++++++
 4 files changed, 698 insertions(+)
 create mode 100644 libavcodec/rkmppenc.c

diff --git a/configure b/configure
index a9644e211be..66f2497507d 100755
--- a/configure
+++ b/configure
@@ -2956,6 +2956,7 @@ h264_qsv_decoder_select="h264_mp4toannexb_bsf h264_parser qsvdec"
 h264_qsv_encoder_select="qsvenc"
 h264_rkmpp_decoder_deps="rkmpp"
 h264_rkmpp_decoder_select="h264_mp4toannexb_bsf"
+h264_rkmpp_encoder_deps="rkmpp"
 h264_vaapi_encoder_select="cbs_h264 vaapi_encode"
 h264_v4l2m2m_decoder_deps="v4l2_m2m h264_v4l2_m2m"
 h264_v4l2m2m_decoder_select="h264_mp4toannexb_bsf"
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index 3e41497e348..cb17848ee22 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -356,6 +356,7 @@ OBJS-$(CONFIG_H264_OMX_ENCODER)        += omx.o
 OBJS-$(CONFIG_H264_QSV_DECODER)        += qsvdec_h2645.o
 OBJS-$(CONFIG_H264_QSV_ENCODER)        += qsvenc_h264.o
 OBJS-$(CONFIG_H264_RKMPP_DECODER)      += rkmppdec.o
+OBJS-$(CONFIG_H264_RKMPP_ENCODER)      += rkmppenc.o
 OBJS-$(CONFIG_H264_VAAPI_ENCODER)      += vaapi_encode_h264.o h264_levels.o
 OBJS-$(CONFIG_H264_VIDEOTOOLBOX_ENCODER) += videotoolboxenc.o
 OBJS-$(CONFIG_H264_V4L2M2M_DECODER)    += v4l2_m2m_dec.o
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index a8fa898185b..302272df12a 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -141,6 +141,7 @@ extern AVCodec ff_h264_mediacodec_decoder;
 extern AVCodec ff_h264_mmal_decoder;
 extern AVCodec ff_h264_qsv_decoder;
 extern AVCodec ff_h264_rkmpp_decoder;
+extern AVCodec ff_h264_rkmpp_encoder;
 extern AVCodec ff_hap_encoder;
 extern AVCodec ff_hap_decoder;
 extern AVCodec ff_hevc_decoder;
diff --git a/libavcodec/rkmppenc.c b/libavcodec/rkmppenc.c
new file mode 100644
index 00000000000..0ebb766c156
--- /dev/null
+++ b/libavcodec/rkmppenc.c
@@ -0,0 +1,695 @@
+/*
+ * RockChip MPP Video Encoder
+ * Copyright (c) 2018 hertz.wang@rock-chips.com
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <drm_fourcc.h>
+#include <pthread.h>
+#include <rockchip/mpp_buffer.h>
+#include <rockchip/rk_mpi.h>
+#include <time.h>
+#include <unistd.h>
+
+#include "avcodec.h"
+#include "hwaccel.h"
+#include "internal.h"
+#include "libavutil/avassert.h"
+#include "libavutil/buffer.h"
+#include "libavutil/frame.h"
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_drm.h"
+#include "libavutil/log.h"
+
+// copy from mpp/base/inc/mpp_packet_impl.h
+#define MPP_PACKET_FLAG_INTRA       (0x00000008)
+
+#define SEND_FRAME_TIMEOUT          100
+#define RECEIVE_PACKET_TIMEOUT      100
+
+typedef struct {
+    MppCtx ctx;
+    MppApi *mpi;
+
+    char eos_reached;
+} RKMPPEncoder;
+
+typedef struct {
+    AVClass *av_class;
+    AVBufferRef *encoder_ref;
+} RKMPPEncodeContext;
+
+typedef struct {
+    MppPacket packet;
+    AVBufferRef *encoder_ref;
+} RKMPPPacketContext;
+
+static MppCodingType rkmpp_get_codingtype(AVCodecContext *avctx)
+{
+    switch (avctx->codec_id) {
+    case AV_CODEC_ID_H264:          return MPP_VIDEO_CodingAVC;
+    default:                        return MPP_VIDEO_CodingUnused;
+    }
+}
+
+static MppFrameFormat rkmpp_get_mppformat(enum AVPixelFormat avformat)
+{
+    switch (avformat) {
+    case AV_PIX_FMT_NV12:           return MPP_FMT_YUV420SP;
+    case AV_PIX_FMT_YUV420P:        return MPP_FMT_YUV420P;
+    case AV_PIX_FMT_YUYV422:        return MPP_FMT_YUV422_YUYV;
+    case AV_PIX_FMT_UYVY422:        return MPP_FMT_YUV422_UYVY;
+#ifdef DRM_FORMAT_NV12_10
+    case AV_PIX_FMT_P010:           return MPP_FMT_YUV420SP_10BIT;
+#endif
+    default:                        return -1;
+    }
+}
+
+static int rkmpp_close_encoder(AVCodecContext *avctx)
+{
+    RKMPPEncodeContext *rk_context = avctx->priv_data;
+    av_buffer_unref(&rk_context->encoder_ref);
+    return 0;
+}
+
+static void rkmpp_release_encoder(void *opaque, uint8_t *data)
+{
+    RKMPPEncoder *encoder = (RKMPPEncoder *)data;
+
+    if (encoder->mpi) {
+        encoder->mpi->reset(encoder->ctx);
+        mpp_destroy(encoder->ctx);
+        encoder->ctx = NULL;
+    }
+
+    av_free(encoder);
+}
+
+static int rkmpp_preg_config(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                             MppEncPrepCfg *prep_cfg)
+{
+    int ret;
+
+    memset(prep_cfg, 0, sizeof(*prep_cfg));
+    prep_cfg->change        = MPP_ENC_PREP_CFG_CHANGE_INPUT |
+                              MPP_ENC_PREP_CFG_CHANGE_ROTATION |
+                              MPP_ENC_PREP_CFG_CHANGE_FORMAT;
+    prep_cfg->width         = avctx->width;
+    prep_cfg->height        = avctx->height;
+    prep_cfg->hor_stride    = avctx->width;
+    prep_cfg->ver_stride    = avctx->height;
+    prep_cfg->format        = rkmpp_get_mppformat(avctx->sw_pix_fmt);
+    prep_cfg->rotation      = MPP_ENC_ROT_0;
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_PREP_CFG, prep_cfg);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set prep cfg on MPI (code = %d).\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static int rkmpp_rc_config(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                           MppEncRcCfg *rc_cfg)
+{
+    int ret;
+    int fps;
+
+    memset(rc_cfg, 0, sizeof(*rc_cfg));
+    rc_cfg->change  = MPP_ENC_RC_CFG_CHANGE_ALL;
+    // TODO: set by AVOption
+    rc_cfg->rc_mode = MPP_ENC_RC_MODE_CBR;
+    rc_cfg->quality = MPP_ENC_RC_QUALITY_MEDIUM;
+
+    if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_CBR) {
+        /* constant bitrate has very small bps range of 1/16 bps */
+        rc_cfg->bps_target  = avctx->bit_rate;
+        rc_cfg->bps_max     = avctx->bit_rate * 17 / 16;
+        rc_cfg->bps_min     = avctx->bit_rate * 15 / 16;
+    } else if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_VBR) {
+        if (rc_cfg->quality == MPP_ENC_RC_QUALITY_CQP) {
+            /* constant QP does not have bps */
+            rc_cfg->bps_target  = -1;
+            rc_cfg->bps_max     = -1;
+            rc_cfg->bps_min     = -1;
+        } else {
+            /* variable bitrate has large bps range */
+            rc_cfg->bps_target  = avctx->bit_rate;
+            rc_cfg->bps_max     = avctx->bit_rate * 17 / 16;
+            rc_cfg->bps_min     = avctx->bit_rate * 1 / 16;
+        }
+    }
+
+    fps = avctx->time_base.den / avctx->time_base.num;
+    /* fix input / output frame rate */
+    rc_cfg->fps_in_flex     = 0;
+    rc_cfg->fps_in_num      = fps;
+    rc_cfg->fps_in_denorm   = 1;
+    rc_cfg->fps_out_flex    = 0;
+    rc_cfg->fps_out_num     = fps;
+    rc_cfg->fps_out_denorm  = 1;
+
+    rc_cfg->gop             = avctx->gop_size;
+    rc_cfg->skip_cnt        = 0;
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_RC_CFG, rc_cfg);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set rc cfg on MPI (code = %d).\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static int rkmpp_codec_config(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                              MppCodingType codectype, MppEncRcCfg *rc_cfg,
+                              MppEncCodecCfg *codec_cfg)
+{
+    int ret;
+
+    memset(codec_cfg, 0, sizeof(*codec_cfg));
+    codec_cfg->coding = codectype;
+    switch (codectype) {
+    case MPP_VIDEO_CodingAVC: {
+        int qp_min = avctx->qmin,
+            qp_max = avctx->qmax,
+            qp_step = avctx->max_qdiff;
+        int qp_init = 26;
+        codec_cfg->h264.change = MPP_ENC_H264_CFG_CHANGE_PROFILE |
+                                 MPP_ENC_H264_CFG_CHANGE_ENTROPY |
+                                 MPP_ENC_H264_CFG_CHANGE_TRANS_8x8 |
+                                 MPP_ENC_H264_CFG_CHANGE_QP_LIMIT;
+        /*
+         * H.264 profile_idc parameter
+         * Support: Baseline profile
+         *          Main profile
+         *          High profile
+         */
+        if (avctx->profile != FF_PROFILE_H264_BASELINE &&
+            avctx->profile != FF_PROFILE_H264_MAIN &&
+            avctx->profile != FF_PROFILE_H264_HIGH) {
+            av_log(avctx, AV_LOG_INFO, "Unsupport profile %d, force set to %d\n",
+                   avctx->profile, FF_PROFILE_H264_HIGH);
+            avctx->profile = FF_PROFILE_H264_HIGH;
+        }
+        codec_cfg->h264.profile = avctx->profile;
+
+        /*
+         * H.264 level_idc parameter
+         * 10 / 11 / 12 / 13    - qcif@15fps / cif@7.5fps / cif@15fps / cif@30fps
+         * 20 / 21 / 22         - cif@30fps / half-D1@@25fps / D1@12.5fps
+         * 30 / 31 / 32         - D1@25fps / 720p@30fps / 720p@60fps
+         * 40 / 41 / 42         - 1080p@30fps / 1080p@30fps / 1080p@60fps
+         * 50 / 51 / 52         - 4K@30fps
+         */
+        if (avctx->level == FF_LEVEL_UNKNOWN) {
+            av_log(avctx, AV_LOG_INFO, "Unsupport level %d, force set to %d\n",
+                   avctx->level, 51);
+            avctx->level = 51;
+        }
+        codec_cfg->h264.level               = avctx->level;
+        codec_cfg->h264.entropy_coding_mode =
+            (codec_cfg->h264.profile == FF_PROFILE_H264_HIGH) ? 1 : 0;
+        codec_cfg->h264.cabac_init_idc      = 0;
+        codec_cfg->h264.transform8x8_mode   = 1;
+
+        if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_CBR) {
+            /* constant bitrate do not limit qp range */
+            qp_max  = 48;
+            qp_min  = 4;
+            qp_step = 16;
+            qp_init = 0;
+        } else if (rc_cfg->rc_mode == MPP_ENC_RC_MODE_VBR) {
+            if (rc_cfg->quality == MPP_ENC_RC_QUALITY_CQP) {
+                /* constant QP mode qp is fixed */
+                qp_max   = qp_init;
+                qp_min   = qp_init;
+                qp_step  = 0;
+            } else {
+                /* variable bitrate has qp min limit */
+                qp_max   = 40;
+                qp_min   = 12;
+                qp_step  = 8;
+                qp_init  = 0;
+            }
+        }
+
+        codec_cfg->h264.qp_max      = qp_max;
+        codec_cfg->h264.qp_min      = qp_min;
+        codec_cfg->h264.qp_max_step = qp_step;
+        codec_cfg->h264.qp_init     = qp_init;
+    } break;
+    case MPP_VIDEO_CodingMJPEG:
+        codec_cfg->jpeg.change  = MPP_ENC_JPEG_CFG_CHANGE_QP;
+        codec_cfg->jpeg.quant   = 10; // 1 ~ 10
+        break;
+    default:
+        av_log(avctx, AV_LOG_ERROR, "TODO encoder coding type %d\n", codectype);
+        return AVERROR_UNKNOWN;
+    }
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_CODEC_CFG, codec_cfg);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set codec cfg on MPI (code = %d).\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+
+    return 0;
+}
+
+static int rkmpp_init_encoder(AVCodecContext *avctx)
+{
+    int ret;
+    MppCodingType codectype;
+    RKMPPEncodeContext *rk_context;
+    RKMPPEncoder *encoder;
+    MppEncPrepCfg prep_cfg;
+    MppEncRcCfg rc_cfg;
+    MppEncCodecCfg codec_cfg;
+    RK_S64 paramS64;
+    MppEncSeiMode sei_mode;
+    MppPacket packet = NULL;
+
+    rk_context = avctx->priv_data;
+    rk_context->encoder_ref = NULL;
+    codectype = rkmpp_get_codingtype(avctx);
+    if (codectype == MPP_VIDEO_CodingUnused) {
+        av_log(avctx, AV_LOG_ERROR, "Unsupport codec type (%d).\n", avctx->codec_id);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpp_check_support_format(MPP_CTX_ENC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Codec type (%d) unsupported by MPP\n", avctx->codec_id);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // create a encoder and a ref to it
+    encoder = av_mallocz(sizeof(RKMPPEncoder));
+    if (!encoder) {
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    rk_context->encoder_ref =
+        av_buffer_create((uint8_t *)encoder, sizeof(*encoder),
+                         rkmpp_release_encoder, NULL, AV_BUFFER_FLAG_READONLY);
+    if (!rk_context->encoder_ref) {
+        av_free(encoder);
+        ret = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "Initializing RKMPP encoder.\n");
+
+    // mpp init
+    ret = mpp_create(&encoder->ctx, &encoder->mpi);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to create MPP context (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpp_init(encoder->ctx, MPP_CTX_ENC, codectype);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to initialize MPP context (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // mpp setup
+    ret = rkmpp_preg_config(avctx, encoder, &prep_cfg);
+    if (ret)
+        goto fail;
+
+    ret = rkmpp_rc_config(avctx, encoder, &rc_cfg);
+    if (ret)
+        goto fail;
+
+    ret = rkmpp_codec_config(avctx, encoder, codectype, &rc_cfg, &codec_cfg);
+    if (ret)
+        goto fail;
+
+    sei_mode = MPP_ENC_SEI_MODE_ONE_FRAME;
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_SET_SEI_CFG, &sei_mode);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set sei cfg on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // TODO: osd if hardware support
+
+    paramS64 = SEND_FRAME_TIMEOUT;
+    ret = encoder->mpi->control(encoder->ctx, MPP_SET_INPUT_TIMEOUT, &paramS64);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set input timeout on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    paramS64 = RECEIVE_PACKET_TIMEOUT;
+    ret = encoder->mpi->control(encoder->ctx, MPP_SET_OUTPUT_TIMEOUT, &paramS64);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to set output timeout on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = encoder->mpi->control(encoder->ctx, MPP_ENC_GET_EXTRA_INFO, &packet);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to get extra info on MPI (code = %d).\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    if (packet) {
+        /* get and write sps/pps for H.264 */
+        void *ptr   = mpp_packet_get_pos(packet);
+        size_t len  = mpp_packet_get_length(packet);
+
+        if (avctx->extradata != NULL && avctx->extradata_size != len) {
+            av_free(avctx->extradata);
+            avctx->extradata = NULL;
+        }
+        if (!avctx->extradata)
+            avctx->extradata = av_malloc(len);
+        if (avctx->extradata == NULL) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        avctx->extradata_size = len;
+        memcpy(avctx->extradata, ptr, len);
+
+        packet = NULL;
+    }
+
+    av_log(avctx, AV_LOG_DEBUG, "RKMPP encoder initialized successfully.\n");
+
+    return 0;
+
+fail:
+    av_log(avctx, AV_LOG_ERROR, "Failed to initialize RKMPP encoder.\n");
+    rkmpp_close_encoder(avctx);
+    return ret;
+}
+
+static int rkmpp_queue_frame(AVCodecContext *avctx, RKMPPEncoder *encoder,
+                             const AVFrame *avframe, MppFrame *out_frame)
+{
+    int ret;
+    MppFrameFormat mppformat;
+    MppCtx ctx;
+    MppApi *mpi;
+    MppBuffer buffer = NULL;
+    MppBufferInfo info;
+    MppFrame frame = NULL;
+    MppTask task = NULL;
+
+    // check format
+    if (avframe) {
+        enum AVPixelFormat swformat;
+        if(avframe->format != AV_PIX_FMT_DRM_PRIME) {
+            av_log(avctx, AV_LOG_ERROR, "RKMPPEncoder only support fmt DRM\n");
+            return AVERROR(EINVAL);
+        }
+        swformat    = ((AVHWFramesContext*)avframe->hw_frames_ctx->data)->sw_format;
+        mppformat   = rkmpp_get_mppformat(swformat);
+        if (mppformat < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Unsupport av format %d\n", swformat);
+            return AVERROR(EINVAL);
+        }
+    }
+
+    ret = mpp_frame_init(&frame);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed init mpp frame on encoder (code = %d)\n", ret);
+        return AVERROR_UNKNOWN;
+    }
+    mpp_frame_set_eos(frame, encoder->eos_reached);
+
+    if (avframe) {
+        AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor*)avframe->data[0];
+        AVDRMLayerDescriptor *layer = &desc->layers[0];
+
+        mpp_frame_set_pts(frame, avframe->pts);
+        mpp_frame_set_dts(frame, avframe->pkt_dts);
+        mpp_frame_set_width(frame, avframe->width);
+        mpp_frame_set_height(frame, avframe->height);
+        if (mppformat == MPP_FMT_YUV422_YUYV || mppformat == MPP_FMT_YUV422_UYVY) {
+            mpp_frame_set_hor_stride(frame, 2 * layer->planes[0].pitch/* /bpp */);
+        } else {
+            // nv12 or yuv420p
+            mpp_frame_set_hor_stride(frame, layer->planes[0].pitch/* /bpp */);
+        }
+        if (layer->nb_planes > 1)
+            mpp_frame_set_ver_stride(frame,
+                layer->planes[1].offset / layer->planes[0].pitch);
+        else
+            mpp_frame_set_ver_stride(frame, avframe->height);
+        mpp_frame_set_fmt(frame, mppformat);
+
+        memset(&info, 0, sizeof(info));
+        info.type   = MPP_BUFFER_TYPE_ION;
+        info.size   = desc->objects[0].size;
+        info.fd     = desc->objects[0].fd;
+        info.ptr    = desc->objects[0].ptr;
+        ret = mpp_buffer_import(&buffer, &info);
+        if (ret != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to import buffer\n");
+            ret = AVERROR(EINVAL);
+            goto out;
+        }
+        mpp_frame_set_buffer(frame, buffer);
+    }
+
+    ctx = encoder->ctx;
+    mpi = encoder->mpi;
+    ret = mpi->poll(ctx, MPP_PORT_INPUT, MPP_POLL_BLOCK);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to poll task input (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto out;
+    }
+
+    ret = mpi->dequeue(ctx, MPP_PORT_INPUT, &task);
+    if (ret != MPP_OK || NULL == task) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to dequeue task input (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto out;
+    }
+
+    mpp_task_meta_set_frame (task, KEY_INPUT_FRAME, frame);
+    ret = mpi->enqueue(ctx, MPP_PORT_INPUT, task);
+    if (ret != MPP_OK) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to enqueue task input (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto out;
+    }
+    *out_frame = frame;
+    frame = NULL;
+
+out:
+    if (buffer)
+        mpp_buffer_put(buffer);
+    if (frame)
+        mpp_frame_deinit(&frame);
+    return 0;
+}
+
+static int rkmpp_send_frame(AVCodecContext *avctx, const AVFrame *frame,
+                            MppFrame *mpp_frame)
+{
+    int ret;
+    RKMPPEncodeContext *rk_context = avctx->priv_data;
+    RKMPPEncoder *encoder = (RKMPPEncoder *)rk_context->encoder_ref->data;
+
+    if (!frame) {
+        av_log(avctx, AV_LOG_DEBUG, "End of stream.\n");
+        encoder->eos_reached = 1;
+        ret = rkmpp_queue_frame(avctx, encoder, NULL, mpp_frame);
+        if (ret)
+            av_log(avctx, AV_LOG_ERROR, "Failed to send EOS to encoder (code = %d)\n", ret);
+        return ret;
+    }
+
+    ret = rkmpp_queue_frame(avctx, encoder, frame, mpp_frame);
+    if (ret && ret != AVERROR(EAGAIN))
+        av_log(avctx, AV_LOG_ERROR, "Failed to send frame to encoder (code = %d)\n", ret);
+
+    return ret;
+}
+
+static void rkmpp_release_packet(void *opaque, uint8_t *data)
+{
+    RKMPPPacketContext *pkt_ctx = (RKMPPPacketContext *)opaque;
+
+    mpp_packet_deinit(&pkt_ctx->packet);
+    av_buffer_unref(&pkt_ctx->encoder_ref);
+    av_free(pkt_ctx);
+}
+
+static int rkmpp_receive_packet(AVCodecContext *avctx, AVPacket *pkt,
+                                MppFrame *mpp_frame)
+{
+    int ret;
+    RKMPPEncodeContext *rk_context = avctx->priv_data;
+    RKMPPEncoder *encoder = (RKMPPEncoder *)rk_context->encoder_ref->data;
+    MppCtx ctx = encoder->ctx;
+    MppApi *mpi = encoder->mpi;
+    MppTask task = NULL;
+    MppPacket packet = NULL;
+
+    ret = mpi->poll(ctx, MPP_PORT_OUTPUT, MPP_POLL_BLOCK);
+    if (ret) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to poll task output (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    ret = mpi->dequeue(ctx, MPP_PORT_OUTPUT, &task);
+    if (ret || NULL == task) {
+        av_log(avctx, AV_LOG_ERROR, "Failed to dequeue task output (ret = %d)\n", ret);
+        ret = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    if (task) {
+        mpp_task_meta_get_packet(task, KEY_OUTPUT_PACKET, &packet);
+        ret = mpi->enqueue(ctx, MPP_PORT_OUTPUT, task);
+        if (ret != MPP_OK) {
+            av_log(avctx, AV_LOG_ERROR, "Failed to enqueue task output (ret = %d)\n", ret);
+            ret = AVERROR_UNKNOWN;
+            goto fail;
+        }
+    }
+
+    if (packet) {
+        RKMPPPacketContext *pkt_ctx;
+        RK_U32 flag;
+
+        if (mpp_packet_get_eos(packet)) {
+            av_log(avctx, AV_LOG_DEBUG, "Received a EOS packet.\n");
+            if (encoder->eos_reached) {
+                ret = AVERROR_EOF;
+                goto fail;
+            }
+        }
+        pkt_ctx = av_mallocz(sizeof(*pkt_ctx));
+        if (!pkt_ctx) {
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        pkt_ctx->packet = packet;
+        pkt_ctx->encoder_ref = av_buffer_ref(rk_context->encoder_ref);
+
+        // TODO: outside need fd from mppbuffer?
+        pkt->data = mpp_packet_get_data(packet);
+        pkt->size = mpp_packet_get_length(packet);
+        pkt->buf = av_buffer_create((uint8_t*)pkt->data, pkt->size,
+            rkmpp_release_packet, pkt_ctx, AV_BUFFER_FLAG_READONLY);
+        if (!pkt->buf) {
+            av_buffer_unref(&pkt_ctx->encoder_ref);
+            av_free(pkt_ctx);
+            ret = AVERROR(ENOMEM);
+            goto fail;
+        }
+        pkt->pts = mpp_packet_get_pts(packet);
+        pkt->dts = mpp_packet_get_dts(packet);
+        if (pkt->pts <= 0)
+            pkt->pts = pkt->dts;
+        if (pkt->dts <= 0)
+            pkt->dts = pkt->pts;
+        flag = mpp_packet_get_flag(packet);
+        if (flag & MPP_PACKET_FLAG_INTRA)
+            pkt->flags |= AV_PKT_FLAG_KEY;
+
+        packet = NULL;
+    }
+
+fail:
+    if (packet)
+        mpp_packet_deinit(&packet);
+    if (*mpp_frame) {
+        mpp_frame_deinit(mpp_frame);
+        *mpp_frame = NULL;
+    }
+    return ret;
+}
+
+static int rkmpp_encode_frame(AVCodecContext *avctx, AVPacket *pkt,
+                              const AVFrame *frame, int *got_packet)
+{
+    int ret;
+    MppFrame mpp_frame = NULL;
+
+    ret = rkmpp_send_frame(avctx, frame, &mpp_frame);
+    if (ret)
+        return ret;
+
+    ret = rkmpp_receive_packet(avctx, pkt, &mpp_frame);
+    av_assert0(mpp_frame == NULL);
+    if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
+        *got_packet = 0;
+    } else if (ret) {
+        return ret;
+    } else {
+        *got_packet = 1;
+    }
+
+    return 0;
+}
+
+static const AVCodecHWConfigInternal *rkmpp_hw_configs[] = {
+    HW_CONFIG_INTERNAL(DRM_PRIME),
+    NULL
+};
+
+#define RKMPP_ENC_CLASS(NAME) \
+    static const AVClass rkmpp_##NAME##_enc_class = { \
+        .class_name = "rkmpp_" #NAME "_enc", \
+        .version    = LIBAVUTIL_VERSION_INT, \
+    };
+
+// TODO: .send_frame .receive_packet
+#define RKMPP_ENC(NAME, ID, BSFS) \
+    RKMPP_ENC_CLASS(NAME) \
+    AVCodec ff_##NAME##_rkmpp_encoder = { \
+        .name           = #NAME "_rkmpp", \
+        .long_name      = NULL_IF_CONFIG_SMALL(#NAME " (rkmpp)"), \
+        .type           = AVMEDIA_TYPE_VIDEO, \
+        .id             = ID, \
+        .init           = rkmpp_init_encoder, \
+        .close          = rkmpp_close_encoder, \
+        .encode2        = rkmpp_encode_frame, \
+        .priv_data_size = sizeof(RKMPPEncodeContext), \
+        .priv_class     = &rkmpp_##NAME##_enc_class, \
+        .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_HARDWARE, \
+        .caps_internal  = FF_CODEC_CAP_INIT_CLEANUP, \
+        .pix_fmts       = (const enum AVPixelFormat[]) { AV_PIX_FMT_DRM_PRIME, \
+                                                         AV_PIX_FMT_NONE }, \
+        .hw_configs     = rkmpp_hw_configs, \
+        .bsfs           = BSFS, \
+        .wrapper_name   = "rkmpp", \
+    };
+
+RKMPP_ENC(h264, AV_CODEC_ID_H264, NULL)

From 513922ae934cb4a7d399e03a9420ecb211ca45aa Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Mon, 5 Nov 2018 20:56:00 +0800
Subject: [PATCH 05/13] hwcontext_drm: internal frame allocation

Change-Id: Iba12ba90f5395fb72cf39e96e266bb63daaec231
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 libavutil/hwcontext_drm.c | 317 +++++++++++++++++++++++++++++++++++++-
 libavutil/hwcontext_drm.h |  10 +-
 2 files changed, 320 insertions(+), 7 deletions(-)

diff --git a/libavutil/hwcontext_drm.c b/libavutil/hwcontext_drm.c
index 32cbde82ebf..29cfaff477d 100644
--- a/libavutil/hwcontext_drm.c
+++ b/libavutil/hwcontext_drm.c
@@ -16,11 +16,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
  */
 
+#define _GNU_SOURCE
 #include <fcntl.h>
 #include <sys/mman.h>
 #include <unistd.h>
 
-#include <drm.h>
+#include <drm_fourcc.h>
 #include <xf86drm.h>
 
 #include "avassert.h"
@@ -29,6 +30,100 @@
 #include "hwcontext_internal.h"
 #include "imgutils.h"
 
+/**
+ * Copy from libdrm_macros.h while is not exposed by libdrm,
+ * be replaced by #include "libdrm_macros.h" someday.
+ */
+
+/**
+ * Static (compile-time) assertion.
+ * Basically, use COND to dimension an array.  If COND is false/zero the
+ * array size will be -1 and we'll get a compilation error.
+ */
+#define STATIC_ASSERT(COND) \
+   do { \
+      (void) sizeof(char [1 - 2*!(COND)]); \
+   } while (0)
+
+#if defined(ANDROID) && !defined(__LP64__)
+#include <errno.h> /* for EINVAL */
+
+extern void *__mmap2(void *, size_t, int, int, int, size_t);
+
+static inline void *drm_mmap(void *addr, size_t length, int prot, int flags,
+                             int fd, loff_t offset)
+{
+   /* offset must be aligned to 4096 (not necessarily the page size) */
+   if (offset & 4095) {
+      errno = EINVAL;
+      return MAP_FAILED;
+   }
+
+   return __mmap2(addr, length, prot, flags, fd, (size_t) (offset >> 12));
+}
+
+#  define drm_munmap(addr, length) \
+              munmap(addr, length)
+
+#else
+
+/* assume large file support exists */
+#  define drm_mmap(addr, length, prot, flags, fd, offset) \
+              mmap(addr, length, prot, flags, fd, offset)
+
+static inline int drm_munmap(void *addr, size_t length)
+{
+   /* Copied from configure code generated by AC_SYS_LARGEFILE */
+#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + \
+                     (((off_t) 1 << 31) << 31))
+   STATIC_ASSERT(LARGE_OFF_T % 2147483629 == 721 &&
+                 LARGE_OFF_T % 2147483647 == 1);
+#undef LARGE_OFF_T
+
+   return munmap(addr, length);
+}
+#endif
+
+// default
+static int card_index = 0;
+
+static const struct {
+    enum AVPixelFormat pixfmt;
+    uint32_t drm_format;
+} supported_formats[] = {
+#ifdef DRM_FORMAT_R16
+    { AV_PIX_FMT_GRAY16LE,  DRM_FORMAT_R16,         },
+    { AV_PIX_FMT_GRAY16BE,  DRM_FORMAT_R16      | DRM_FORMAT_BIG_ENDIAN },
+#endif
+    { AV_PIX_FMT_BGR8,      DRM_FORMAT_BGR233,      },
+    { AV_PIX_FMT_RGB555LE,  DRM_FORMAT_XRGB1555,    },
+    { AV_PIX_FMT_RGB555BE,  DRM_FORMAT_XRGB1555 | DRM_FORMAT_BIG_ENDIAN },
+    { AV_PIX_FMT_BGR555LE,  DRM_FORMAT_XBGR1555,    },
+    { AV_PIX_FMT_BGR555BE,  DRM_FORMAT_XBGR1555 | DRM_FORMAT_BIG_ENDIAN },
+    { AV_PIX_FMT_RGB565LE,  DRM_FORMAT_RGB565,      },
+    { AV_PIX_FMT_RGB565BE,  DRM_FORMAT_RGB565   | DRM_FORMAT_BIG_ENDIAN },
+    { AV_PIX_FMT_BGR565LE,  DRM_FORMAT_BGR565,      },
+    { AV_PIX_FMT_BGR565BE,  DRM_FORMAT_BGR565   | DRM_FORMAT_BIG_ENDIAN },
+    { AV_PIX_FMT_RGB24,     DRM_FORMAT_RGB888,      },
+    { AV_PIX_FMT_BGR24,     DRM_FORMAT_BGR888,      },
+    { AV_PIX_FMT_0RGB,      DRM_FORMAT_BGRX8888,    },
+    { AV_PIX_FMT_0BGR,      DRM_FORMAT_RGBX8888,    },
+    { AV_PIX_FMT_RGB0,      DRM_FORMAT_XBGR8888,    },
+    { AV_PIX_FMT_BGR0,      DRM_FORMAT_XRGB8888,    },
+    { AV_PIX_FMT_ARGB,      DRM_FORMAT_BGRA8888,    },
+    { AV_PIX_FMT_ABGR,      DRM_FORMAT_RGBA8888,    },
+    { AV_PIX_FMT_RGBA,      DRM_FORMAT_ABGR8888,    },
+    { AV_PIX_FMT_BGRA,      DRM_FORMAT_ARGB8888,    },
+    { AV_PIX_FMT_YUYV422,   DRM_FORMAT_YUYV,        },
+    { AV_PIX_FMT_YVYU422,   DRM_FORMAT_YVYU,        },
+    { AV_PIX_FMT_UYVY422,   DRM_FORMAT_UYVY,        },
+    { AV_PIX_FMT_NV16,      DRM_FORMAT_NV16,        },
+    { AV_PIX_FMT_YUV422P,   DRM_FORMAT_YUV422,      },
+    { AV_PIX_FMT_NV21,      DRM_FORMAT_NV21,        },
+    { AV_PIX_FMT_NV12,      DRM_FORMAT_NV12,        },
+    { AV_PIX_FMT_P010,      DRM_FORMAT_NV12_10,     },
+    { AV_PIX_FMT_YUV420P,   DRM_FORMAT_YUV420,      },
+};
 
 static void drm_device_free(AVHWDeviceContext *hwdev)
 {
@@ -42,7 +137,14 @@ static int drm_device_create(AVHWDeviceContext *hwdev, const char *device,
 {
     AVDRMDeviceContext *hwctx = hwdev->hwctx;
     drmVersionPtr version;
+    char drm_dev[] = "/dev/dri/card0000";
+    uint64_t has_dumb;
 
+    if (!device) {
+        snprintf(drm_dev, sizeof(drm_dev), DRM_DEV_NAME, DRM_DIR_NAME,
+                 card_index);
+        device = drm_dev;
+    }
     hwctx->fd = open(device, O_RDWR);
     if (hwctx->fd < 0)
         return AVERROR(errno);
@@ -62,11 +164,219 @@ static int drm_device_create(AVHWDeviceContext *hwdev, const char *device,
 
     drmFreeVersion(version);
 
+    if (drmGetCap(hwctx->fd, DRM_CAP_DUMB_BUFFER, &has_dumb) < 0 ||
+        !has_dumb) {
+        av_log(hwdev, AV_LOG_ERROR, "drm device '%s' "
+               "does not support dumb buffers\n", device);
+        close(hwctx->fd);
+        return AVERROR(EINVAL);
+    }
+
     hwdev->free = &drm_device_free;
 
     return 0;
 }
 
+static int drm_frames_get_constraints(AVHWDeviceContext *hwdev,
+                                      const void *hwconfig,
+                                      AVHWFramesConstraints *constraints)
+{
+    int i;
+
+    constraints->min_width = 16;
+    constraints->min_height = 16;
+
+    constraints->valid_hw_formats =
+        av_malloc_array(2, sizeof(enum AVPixelFormat));
+    if (!constraints->valid_hw_formats)
+        return AVERROR(ENOMEM);
+    constraints->valid_hw_formats[0] = AV_PIX_FMT_DRM_PRIME;
+    constraints->valid_hw_formats[1] = AV_PIX_FMT_NONE;
+
+    constraints->valid_sw_formats =
+        av_malloc_array(FF_ARRAY_ELEMS(supported_formats) + 1,
+                        sizeof(enum AVPixelFormat));
+    if (!constraints->valid_sw_formats)
+        return AVERROR(ENOMEM);
+    for(i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        constraints->valid_sw_formats[i] = supported_formats[i].pixfmt;
+    constraints->valid_sw_formats[i] = AV_PIX_FMT_NONE;
+
+    return 0;
+}
+
+static void free_drm_frame_descriptor(AVDRMDeviceContext *hwctx,
+                                      AVDRMFrameDescriptor *desc)
+{
+    int i;
+    if (!desc)
+        return;
+
+    for (i = 0; i < desc->nb_objects; i++) {
+        AVDRMObjectDescriptor *object = &desc->objects[i];
+        if (object->ptr)
+            drm_munmap(object->ptr, object->size);
+        if (object->fd > 0) {
+            int ret;
+            uint32_t handle = 0;
+
+            ret = drmPrimeFDToHandle(hwctx->fd, object->fd, &handle);
+            if (ret)
+                av_log(NULL, AV_LOG_WARNING,
+                       "Failed to convert drm fd to handle: %m\n");
+            if (handle > 0) {
+                struct drm_mode_destroy_dumb data = {
+                    .handle = handle,
+                };
+                ret = drmIoctl(hwctx->fd, DRM_IOCTL_MODE_DESTROY_DUMB, &data);
+                if (ret)
+                    av_log(NULL, AV_LOG_WARNING,
+                           "Failed to free drm handle: %m\n");
+            }
+
+            ret = close(object->fd);
+            if (ret)
+                av_log(NULL, AV_LOG_WARNING,
+                       "Failed to close drm buffer fd = %d: %m\n", object->fd);
+        }
+    }
+
+    memset(desc, 0, sizeof(*desc));
+    av_free(desc);
+}
+
+static void drm_buffer_free(void *opaque, uint8_t *data)
+{
+    AVHWFramesContext *hwfc = opaque;
+    AVDRMDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor *)data;
+
+    free_drm_frame_descriptor(hwctx, desc);
+}
+
+static AVBufferRef *drm_pool_alloc(void *opaque, int size)
+{
+    int ret;
+    AVHWFramesContext *hwfc = opaque;
+    AVDRMDeviceContext *hwctx = hwfc->device_ctx->hwctx;
+    AVDRMFrameDescriptor *desc;
+    AVDRMLayerDescriptor *layer;
+    AVBufferRef *ref;
+
+    int i;
+    const AVPixFmtDescriptor *pixdesc = av_pix_fmt_desc_get(hwfc->sw_format);
+    struct drm_mode_create_dumb dmcb;
+    struct drm_mode_map_dumb dmmd;
+
+    desc = av_mallocz(sizeof(*desc));
+    if (!desc)
+        return NULL;
+
+    memset(&dmcb, 0, sizeof(struct drm_mode_create_dumb));
+    dmcb.bpp = av_get_bits_per_pixel(pixdesc);
+    dmcb.width  = FFALIGN(hwfc->width, 16);
+    dmcb.height = FFALIGN(hwfc->height, 16);
+    ret = drmIoctl(hwctx->fd, DRM_IOCTL_MODE_CREATE_DUMB, &dmcb);
+    if (ret < 0) {
+        av_log(hwfc, AV_LOG_ERROR,
+               "Failed to create dumb<w,h,bpp: %d,%d,%d>: %m.\n",
+               dmcb.width, dmcb.height, dmcb.bpp);
+        goto fail;
+    }
+    av_assert0(dmcb.size >= dmcb.width * dmcb.height * dmcb.bpp / 8);
+
+    desc->nb_objects = 1;
+    desc->nb_layers = 1;
+    ret = drmPrimeHandleToFD(hwctx->fd, dmcb.handle, DRM_CLOEXEC,
+                             &desc->objects[0].fd);
+    if (ret) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to convert handle to fd: %m\n");
+        goto fail;
+    }
+    memset(&dmmd, 0, sizeof(dmmd));
+    dmmd.handle = dmcb.handle;
+
+    ret = drmIoctl(hwctx->fd, DRM_IOCTL_MODE_MAP_DUMB, &dmmd);
+    if (ret) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to map dumb: %m\n");
+        goto fail;
+    }
+
+    // default read and write
+    desc->objects[0].ptr = drm_mmap(NULL, dmcb.size, PROT_READ | PROT_WRITE,
+                                    MAP_SHARED, hwctx->fd, dmmd.offset);
+    if (desc->objects[0].ptr == MAP_FAILED) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to drm_mmap: %m\n");
+        goto fail;
+    }
+
+    desc->objects[0].size = dmcb.size;
+
+    layer = &desc->layers[0];
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
+        if (supported_formats[i].pixfmt == hwfc->sw_format) {
+            layer->format = supported_formats[i].drm_format;
+            break;
+        }
+    }
+    layer->nb_planes = av_pix_fmt_count_planes(hwfc->sw_format);
+    layer->planes[0].object_index = 0;
+    layer->planes[0].offset = 0;
+    layer->planes[0].pitch =
+        av_image_get_linesize(hwfc->sw_format, hwfc->width, 0);
+
+    for (i = 1; i < layer->nb_planes; i++) {
+        layer->planes[i].object_index = 0;
+        layer->planes[i].offset = layer->planes[i-1].pitch * hwfc->height;
+        layer->planes[i].pitch =
+            av_image_get_linesize(hwfc->sw_format, hwfc->width, i);
+    }
+
+    ref = av_buffer_create((uint8_t*)desc, sizeof(*desc), drm_buffer_free,
+                           opaque, 0);
+    if (!ref) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to create drm buffer.\n");
+        goto fail;
+    }
+
+    return ref;
+
+fail:
+    free_drm_frame_descriptor(hwctx, desc);
+    return NULL;
+}
+
+static int drm_frames_init(AVHWFramesContext *hwfc)
+{
+    int i;
+    if (hwfc->pool) {
+        // has been set outside?
+        return 0;
+    }
+
+    for (i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++)
+        if (supported_formats[i].pixfmt == hwfc->sw_format)
+            break;
+    if (i >= FF_ARRAY_ELEMS(supported_formats)) {
+        av_log(hwfc, AV_LOG_ERROR, "Unsupported format: %s.\n",
+               av_get_pix_fmt_name(hwfc->sw_format));
+        return AVERROR(EINVAL);
+    }
+
+    hwfc->internal->pool_internal =
+        av_buffer_pool_init2(sizeof(AVDRMFrameDescriptor), hwfc, drm_pool_alloc,
+                             NULL);
+    if (!hwfc->internal->pool_internal) {
+        av_log(hwfc, AV_LOG_ERROR, "Failed to create drm buffer pool.\n");
+        return AVERROR(ENOMEM);
+    }
+
+    return 0;
+}
+
+static void drm_frames_uninit(AVHWFramesContext *hwfc av_unused)
+{}
+
 static int drm_get_buffer(AVHWFramesContext *hwfc, AVFrame *frame)
 {
     frame->buf[0] = av_buffer_pool_get(hwfc->pool);
@@ -275,8 +585,11 @@ const HWContextType ff_hwcontext_type_drm = {
 
     .device_create          = &drm_device_create,
 
-    .frames_get_buffer      = &drm_get_buffer,
+    .frames_get_constraints = &drm_frames_get_constraints,
 
+    .frames_get_buffer      = &drm_get_buffer,
+    .frames_init            = &drm_frames_init,
+    .frames_uninit          = &drm_frames_uninit,
     .transfer_get_formats   = &drm_transfer_get_formats,
     .transfer_data_to       = &drm_transfer_data_to,
     .transfer_data_from     = &drm_transfer_data_from,
diff --git a/libavutil/hwcontext_drm.h b/libavutil/hwcontext_drm.h
index 4c40d15b091..fe64f97078c 100644
--- a/libavutil/hwcontext_drm.h
+++ b/libavutil/hwcontext_drm.h
@@ -25,11 +25,6 @@
 /**
  * @file
  * API-specific header for AV_HWDEVICE_TYPE_DRM.
- *
- * Internal frame allocation is not currently supported - all frames
- * must be allocated by the user.  Thus AVHWFramesContext is always
- * NULL, though this may change if support for frame allocation is
- * added in future.
  */
 
 enum {
@@ -53,6 +48,8 @@ typedef struct AVDRMObjectDescriptor {
 
     /**
      * DRM PRIME mapped virtual ptr for above fd.
+     *
+     * The content of this buffer must be readonly when acting decoder's out buffer.
      */
     void *ptr;
 
@@ -147,10 +144,13 @@ typedef struct AVDRMFrameDescriptor {
     AVDRMObjectDescriptor objects[AV_DRM_MAX_PLANES];
     /**
      * Number of layers in the frame.
+     *
+     * Set by users if need more than 1.
      */
     int nb_layers;
     /**
      * Array of layers in the frame.
+     * NOTE: total planes of layers must not be more than AV_NUM_DATA_POINTERS.
      */
     AVDRMLayerDescriptor layers[AV_DRM_MAX_PLANES];
 } AVDRMFrameDescriptor;

From 2f239cf8988ceb37ab7d2d83b53636f9d13db8e1 Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Fri, 2 Nov 2018 19:15:55 +0800
Subject: [PATCH 06/13] v4l2: support queue drm buffers

Test Passed:
    ffmpeg -loglevel debug -video_size 1280*720 -pixel_format drm_prime:nv12
    -i /dev/video0 -vcodec h264_rkmpp -b 6000000 /userdata/out.mp4

TODO: drm_prime:mjpeg/h264

Change-Id: I92e1db3576162b81a041f3a61e54c213a35ea1f9
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 libavcodec/avcodec.h  |  15 +++
 libavcodec/avpacket.c |  16 +++
 libavcodec/rawdec.c   | 137 ++++++++++++++----------
 libavcodec/utils.c    |  30 ++++--
 libavdevice/v4l2.c    | 244 +++++++++++++++++++++++++++++++++++++++---
 5 files changed, 362 insertions(+), 80 deletions(-)

diff --git a/libavcodec/avcodec.h b/libavcodec/avcodec.h
index bee2234575c..ffafe796f40 100644
--- a/libavcodec/avcodec.h
+++ b/libavcodec/avcodec.h
@@ -1473,6 +1473,15 @@ typedef struct AVPacket {
     attribute_deprecated
     int64_t convergence_duration;
 #endif
+    /*
+     * 1. zero copying path for input device, such as camera grab.
+     *    AVPacket may be actually an AVFrame.
+     * 2. the API of hwaccel always handle AVFrame while contains the hw buffer
+     *    descriptor
+     *
+     * This is a reference to a hwaccel avframe.
+     */
+    AVFrame *hw_frame;
 } AVPacket;
 #define AV_PKT_FLAG_KEY     0x0001 ///< The packet contains a keyframe
 #define AV_PKT_FLAG_CORRUPT 0x0002 ///< The packet content is corrupted
@@ -3923,6 +3932,12 @@ typedef struct AVCodecParameters {
      */
     int format;
 
+    /**
+     * video only: the pixel format, the value corresponds to enum AVPixelFormat,
+     *             except the hw_accel pixel format.
+     */
+    int sw_format;
+
     /**
      * The average bitrate of the encoded data (in bits per second).
      */
diff --git a/libavcodec/avpacket.c b/libavcodec/avpacket.c
index e160ad30334..20fa2034654 100644
--- a/libavcodec/avpacket.c
+++ b/libavcodec/avpacket.c
@@ -46,6 +46,7 @@ FF_ENABLE_DEPRECATION_WARNINGS
     pkt->buf                  = NULL;
     pkt->side_data            = NULL;
     pkt->side_data_elems      = 0;
+    pkt->hw_frame             = NULL;
 }
 
 AVPacket *av_packet_alloc(void)
@@ -599,6 +600,7 @@ void av_packet_unref(AVPacket *pkt)
 {
     av_packet_free_side_data(pkt);
     av_buffer_unref(&pkt->buf);
+    av_frame_free(&pkt->hw_frame);
     av_init_packet(pkt);
     pkt->data = NULL;
     pkt->size = 0;
@@ -626,6 +628,20 @@ int av_packet_ref(AVPacket *dst, const AVPacket *src)
             ret = AVERROR(ENOMEM);
             goto fail;
         }
+        if (src->hw_frame) {
+            dst->hw_frame = av_frame_alloc();
+            if (!dst->hw_frame) {
+                av_buffer_unref(&dst->buf);
+                ret = AVERROR(ENOMEM);
+                goto fail;
+            }
+            ret = av_frame_ref(dst->hw_frame, src->hw_frame);
+            if (ret < 0) {
+                av_buffer_unref(&dst->buf);
+                av_frame_free(&dst->hw_frame);
+                goto fail;
+            }
+        }
         dst->data = src->data;
     }
 
diff --git a/libavcodec/rawdec.c b/libavcodec/rawdec.c
index 53f5b76e93e..d6f1f8164d5 100644
--- a/libavcodec/rawdec.c
+++ b/libavcodec/rawdec.c
@@ -73,37 +73,39 @@ static av_cold int raw_init_decoder(AVCodecContext *avctx)
 
     ff_bswapdsp_init(&context->bbdsp);
 
-    if (   avctx->codec_tag == MKTAG('r','a','w',' ')
-        || avctx->codec_tag == MKTAG('N','O','1','6'))
-        avctx->pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_mov,
-                                      avctx->bits_per_coded_sample);
-    else if (avctx->codec_tag == MKTAG('W', 'R', 'A', 'W'))
-        avctx->pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_avi,
-                                      avctx->bits_per_coded_sample);
-    else if (avctx->codec_tag && (avctx->codec_tag & 0xFFFFFF) != MKTAG('B','I','T', 0))
-        avctx->pix_fmt = avpriv_find_pix_fmt(ff_raw_pix_fmt_tags, avctx->codec_tag);
-    else if (avctx->pix_fmt == AV_PIX_FMT_NONE && avctx->bits_per_coded_sample)
-        avctx->pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_avi,
-                                      avctx->bits_per_coded_sample);
-
-    desc = av_pix_fmt_desc_get(avctx->pix_fmt);
-    if (!desc) {
-        av_log(avctx, AV_LOG_ERROR, "Invalid pixel format.\n");
-        return AVERROR(EINVAL);
-    }
+    if (!(avctx->codec_tag == MKTAG('I', 'G', 'N', 'R'))) {
+        if (   avctx->codec_tag == MKTAG('r','a','w',' ')
+            || avctx->codec_tag == MKTAG('N','O','1','6'))
+            avctx->pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_mov,
+                                        avctx->bits_per_coded_sample);
+        else if (avctx->codec_tag == MKTAG('W', 'R', 'A', 'W'))
+            avctx->pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_avi,
+                                        avctx->bits_per_coded_sample);
+        else if (avctx->codec_tag && (avctx->codec_tag & 0xFFFFFF) != MKTAG('B','I','T', 0))
+            avctx->pix_fmt = avpriv_find_pix_fmt(ff_raw_pix_fmt_tags, avctx->codec_tag);
+        else if (avctx->pix_fmt == AV_PIX_FMT_NONE && avctx->bits_per_coded_sample)
+            avctx->pix_fmt = avpriv_find_pix_fmt(avpriv_pix_fmt_bps_avi,
+                                        avctx->bits_per_coded_sample);
+
+        desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+        if (!desc) {
+            av_log(avctx, AV_LOG_ERROR, "Invalid pixel format.\n");
+            return AVERROR(EINVAL);
+        }
 
-    if (desc->flags & (AV_PIX_FMT_FLAG_PAL | FF_PSEUDOPAL)) {
-        context->palette = av_buffer_alloc(AVPALETTE_SIZE);
-        if (!context->palette)
-            return AVERROR(ENOMEM);
-#if FF_API_PSEUDOPAL
-        if (desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)
-            avpriv_set_systematic_pal2((uint32_t*)context->palette->data, avctx->pix_fmt);
-#endif
-        else {
-            memset(context->palette->data, 0, AVPALETTE_SIZE);
-            if (avctx->bits_per_coded_sample == 1)
-                memset(context->palette->data, 0xff, 4);
+        if (desc->flags & (AV_PIX_FMT_FLAG_PAL | FF_PSEUDOPAL)) {
+            context->palette = av_buffer_alloc(AVPALETTE_SIZE);
+            if (!context->palette)
+                return AVERROR(ENOMEM);
+    #if FF_API_PSEUDOPAL
+            if (desc->flags & AV_PIX_FMT_FLAG_PSEUDOPAL)
+                avpriv_set_systematic_pal2((uint32_t*)context->palette->data, avctx->pix_fmt);
+    #endif
+            else {
+                memset(context->palette->data, 0, AVPALETTE_SIZE);
+                if (avctx->bits_per_coded_sample == 1)
+                    memset(context->palette->data, 0xff, 4);
+            }
         }
     }
 
@@ -179,7 +181,7 @@ static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,
     int res, len;
     int need_copy;
 
-    AVFrame   *frame   = data;
+    AVFrame *frame = avpkt->hw_frame? avpkt->hw_frame : data;
 
     if (avctx->width <= 0) {
         av_log(avctx, AV_LOG_ERROR, "width is not set\n");
@@ -204,33 +206,35 @@ static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,
         return AVERROR_INVALIDDATA;
     }
 
-    desc = av_pix_fmt_desc_get(avctx->pix_fmt);
-
-    if ((avctx->bits_per_coded_sample == 8 || avctx->bits_per_coded_sample == 4 ||
-         avctx->bits_per_coded_sample == 2 || avctx->bits_per_coded_sample == 1 ||
-         (avctx->bits_per_coded_sample == 0 && (context->is_nut_pal8 || context->is_mono)) ) &&
-        (context->is_mono || context->is_pal8) &&
-        (!avctx->codec_tag || avctx->codec_tag == MKTAG('r','a','w',' ') ||
-                context->is_nut_mono || context->is_nut_pal8)) {
-        context->is_1_2_4_8_bpp = 1;
-        if (context->is_mono) {
-            int row_bytes = avctx->width / 8 + (avctx->width & 7 ? 1 : 0);
-            context->frame_size = av_image_get_buffer_size(avctx->pix_fmt,
-                                                           FFALIGN(row_bytes, 16) * 8,
-                                                           avctx->height, 1);
-        } else
-            context->frame_size = av_image_get_buffer_size(avctx->pix_fmt,
-                                                           FFALIGN(avctx->width, 16),
-                                                           avctx->height, 1);
-    } else {
-        context->is_lt_16bpp = av_get_bits_per_pixel(desc) == 16 && avctx->bits_per_coded_sample && avctx->bits_per_coded_sample < 16;
-        context->frame_size = av_image_get_buffer_size(avctx->pix_fmt, avctx->width,
-                                                       avctx->height, 1);
-    }
-    if (context->frame_size < 0)
-        return context->frame_size;
+    if (!avpkt->hw_frame) {
+        desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+
+        if ((avctx->bits_per_coded_sample == 8 || avctx->bits_per_coded_sample == 4 ||
+            avctx->bits_per_coded_sample == 2 || avctx->bits_per_coded_sample == 1 ||
+            (avctx->bits_per_coded_sample == 0 && (context->is_nut_pal8 || context->is_mono)) ) &&
+            (context->is_mono || context->is_pal8) &&
+            (!avctx->codec_tag || avctx->codec_tag == MKTAG('r','a','w',' ') ||
+                    context->is_nut_mono || context->is_nut_pal8)) {
+            context->is_1_2_4_8_bpp = 1;
+            if (context->is_mono) {
+                int row_bytes = avctx->width / 8 + (avctx->width & 7 ? 1 : 0);
+                context->frame_size = av_image_get_buffer_size(avctx->pix_fmt,
+                                                            FFALIGN(row_bytes, 16) * 8,
+                                                            avctx->height, 1);
+            } else
+                context->frame_size = av_image_get_buffer_size(avctx->pix_fmt,
+                                                            FFALIGN(avctx->width, 16),
+                                                            avctx->height, 1);
+        } else {
+            context->is_lt_16bpp = av_get_bits_per_pixel(desc) == 16 && avctx->bits_per_coded_sample && avctx->bits_per_coded_sample < 16;
+            context->frame_size = av_image_get_buffer_size(avctx->pix_fmt, avctx->width,
+                                                        avctx->height, 1);
+        }
+        if (context->frame_size < 0)
+            return context->frame_size;
 
-    need_copy = !avpkt->buf || context->is_1_2_4_8_bpp || context->is_yuv2 || context->is_lt_16bpp;
+        need_copy = !avpkt->buf || context->is_1_2_4_8_bpp || context->is_yuv2 || context->is_lt_16bpp;
+    }
 
     frame->pict_type        = AV_PICTURE_TYPE_I;
     frame->key_frame        = 1;
@@ -250,6 +254,24 @@ static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,
     if ((res = av_image_check_size(avctx->width, avctx->height, 0, avctx)) < 0)
         return res;
 
+    if (avpkt->hw_frame) {
+        AVFrame *out_frame = data;
+
+        res = av_frame_ref(out_frame, avpkt->hw_frame);
+        if (res)
+            return res;
+
+        out_frame->buf[1] = av_buffer_ref(avpkt->buf);
+        if (!out_frame->buf[1]) {
+            av_frame_unref(out_frame);
+            return AVERROR(ENOMEM);
+        }
+        if (context->flip)
+            flip(avctx, out_frame);
+        frame = out_frame;
+        goto out;
+    }
+
     if (need_copy)
         frame->buf[0] = av_buffer_alloc(FFMAX(context->frame_size, buf_size));
     else
@@ -474,6 +496,7 @@ static int raw_decode(AVCodecContext *avctx, void *data, int *got_frame,
         }
     }
 
+out:
     if (avctx->field_order > AV_FIELD_PROGRESSIVE) { /* we have interlaced material flagged in container */
         frame->interlaced_frame = 1;
         if (avctx->field_order == AV_FIELD_TT || avctx->field_order == AV_FIELD_TB)
diff --git a/libavcodec/utils.c b/libavcodec/utils.c
index 1661d48b906..9ead54bf1ac 100644
--- a/libavcodec/utils.c
+++ b/libavcodec/utils.c
@@ -1204,22 +1204,33 @@ void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
                  ", %d reference frame%s",
                  enc->refs, enc->refs > 1 ? "s" : "");
 
-    if (enc->codec_tag)
+    if (enc->codec_tag) {
+        unsigned int tag = enc->codec_tag;
+        if (enc->codec_tag == MKTAG('I', 'G', 'N', 'R') &&
+            enc->sw_pix_fmt != AV_PIX_FMT_NONE)
+            tag = avcodec_pix_fmt_to_codec_tag(enc->sw_pix_fmt);
         snprintf(buf + strlen(buf), buf_size - strlen(buf), " (%s / 0x%04X)",
-                 av_fourcc2str(enc->codec_tag), enc->codec_tag);
+                 av_fourcc2str(tag), tag);
+    }
 
     switch (enc->codec_type) {
     case AVMEDIA_TYPE_VIDEO:
         {
             char detail[256] = "(";
+            enum AVPixelFormat pix_fmt = enc->pix_fmt;
 
             av_strlcat(buf, separator, buf_size);
 
             snprintf(buf + strlen(buf), buf_size - strlen(buf),
-                 "%s", enc->pix_fmt == AV_PIX_FMT_NONE ? "none" :
-                     av_get_pix_fmt_name(enc->pix_fmt));
-            if (enc->bits_per_raw_sample && enc->pix_fmt != AV_PIX_FMT_NONE &&
-                enc->bits_per_raw_sample < av_pix_fmt_desc_get(enc->pix_fmt)->comp[0].depth)
+                 "%s", pix_fmt == AV_PIX_FMT_NONE ? "none" :
+                     av_get_pix_fmt_name(pix_fmt));
+            if (enc->sw_pix_fmt != AV_PIX_FMT_NONE) {
+                pix_fmt = enc->sw_pix_fmt;
+                snprintf(buf + strlen(buf), buf_size - strlen(buf),
+                 "(%s) ", av_get_pix_fmt_name(pix_fmt));
+            }
+            if (enc->bits_per_raw_sample && pix_fmt != AV_PIX_FMT_NONE &&
+                enc->bits_per_raw_sample < av_pix_fmt_desc_get(pix_fmt)->comp[0].depth)
                 av_strlcatf(detail, sizeof(detail), "%d bpc, ", enc->bits_per_raw_sample);
             if (enc->color_range != AVCOL_RANGE_UNSPECIFIED)
                 av_strlcatf(detail, sizeof(detail), "%s, ",
@@ -1978,6 +1989,7 @@ static void codec_parameters_reset(AVCodecParameters *par)
     par->codec_type          = AVMEDIA_TYPE_UNKNOWN;
     par->codec_id            = AV_CODEC_ID_NONE;
     par->format              = -1;
+    par->sw_format           = AV_PIX_FMT_NONE;
     par->field_order         = AV_FIELD_UNKNOWN;
     par->color_range         = AVCOL_RANGE_UNSPECIFIED;
     par->color_primaries     = AVCOL_PRI_UNSPECIFIED;
@@ -2046,6 +2058,7 @@ int avcodec_parameters_from_context(AVCodecParameters *par,
     switch (par->codec_type) {
     case AVMEDIA_TYPE_VIDEO:
         par->format              = codec->pix_fmt;
+        par->sw_format           = codec->sw_pix_fmt;
         par->width               = codec->width;
         par->height              = codec->height;
         par->field_order         = codec->field_order;
@@ -2101,6 +2114,7 @@ int avcodec_parameters_to_context(AVCodecContext *codec,
     switch (par->codec_type) {
     case AVMEDIA_TYPE_VIDEO:
         codec->pix_fmt                = par->format;
+        codec->sw_pix_fmt             = par->sw_format;
         codec->width                  = par->width;
         codec->height                 = par->height;
         codec->field_order            = par->field_order;
@@ -2197,7 +2211,9 @@ int64_t ff_guess_coded_bitrate(AVCodecContext *avctx)
         return 0;
 
     if (!bits_per_coded_sample) {
-        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);
+        enum AVPixelFormat pix_fmt = avctx->sw_pix_fmt == AV_PIX_FMT_NONE ?
+                                     avctx->pix_fmt : avctx->sw_pix_fmt;
+        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pix_fmt);
         bits_per_coded_sample = av_get_bits_per_pixel(desc);
     }
     bitrate = (int64_t)bits_per_coded_sample * avctx->width * avctx->height *
diff --git a/libavdevice/v4l2.c b/libavdevice/v4l2.c
index 10a0ff0dd61..d42abf5cda7 100644
--- a/libavdevice/v4l2.c
+++ b/libavdevice/v4l2.c
@@ -1,6 +1,7 @@
 /*
  * Copyright (c) 2000,2001 Fabrice Bellard
  * Copyright (c) 2006 Luca Abeni
+ * Copyright (c) 2018 Hertz Wang
  *
  * This file is part of FFmpeg.
  *
@@ -39,7 +40,11 @@
 #include <libv4l2.h>
 #endif
 
+#include "libavutil/hwcontext.h"
+#include "libavutil/hwcontext_drm.h"
+
 static const int desired_video_buffers = 256;
+static const int desired_drm_buffers = 4;
 
 #define V4L_ALLFORMATS  3
 #define V4L_RAWFORMATS  1
@@ -79,6 +84,8 @@ struct video_data {
     TimeFilter *timefilter;
     int64_t last_time_m;
 
+    enum v4l2_memory memory_type;
+
     int buffers;
     atomic_int buffers_queued;
     void **buf_start;
@@ -91,6 +98,12 @@ struct video_data {
     int list_standard;  /**< Set by a private option. */
     char *framerate;    /**< Set by a private option. */
 
+    enum AVPixelFormat av_format;
+    AVBufferRef *hw_frames_ref;
+    AVFrame **pixel_frames;
+    int (*stream_init)(AVFormatContext *ctx);
+    void (*stream_close)(struct video_data *s);
+
     int use_libv4l2;
     int (*open_f)(const char *file, int oflag, ...);
     int (*close_f)(int fd);
@@ -106,6 +119,9 @@ struct buff_data {
     int index;
 };
 
+static int mmap_init(AVFormatContext *ctx);
+static void mmap_close(struct video_data *s);
+
 static int device_open(AVFormatContext *ctx, const char* device_path)
 {
     struct video_data *s = ctx->priv_data;
@@ -135,6 +151,11 @@ static int device_open(AVFormatContext *ctx, const char* device_path)
         SET_WRAPPERS();
     }
 
+    // default MMAP
+    s->memory_type = V4L2_MEMORY_MMAP;
+    s->stream_init = mmap_init;
+    s->stream_close = mmap_close;
+
 #define v4l2_open   s->open_f
 #define v4l2_close  s->close_f
 #define v4l2_dup    s->dup_f
@@ -396,6 +417,111 @@ static int mmap_init(AVFormatContext *ctx)
     return 0;
 }
 
+static void free_pixel_frames(struct video_data *s) {
+    int i;
+
+    for (i = 0; i < s->buffers; i++) {
+        if (s->pixel_frames[i])
+            av_frame_free(&s->pixel_frames[i]);
+    }
+    av_freep(&s->pixel_frames);
+}
+
+static int drm_init(AVFormatContext *ctx)
+{
+    int i, res;
+    struct video_data *s = ctx->priv_data;
+    AVHWFramesContext *hwframes = (AVHWFramesContext*)s->hw_frames_ref->data;
+
+    struct v4l2_requestbuffers req = {
+        .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
+        .count  = desired_drm_buffers,
+        .memory = V4L2_MEMORY_DMABUF
+    };
+
+    if (v4l2_ioctl(s->fd, VIDIOC_REQBUFS, &req) < 0) {
+        res = AVERROR(errno);
+        av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_REQBUFS): %s\n", av_err2str(res));
+        return res;
+    }
+
+    s->memory_type = V4L2_MEMORY_DMABUF;
+
+    hwframes->format    = AV_PIX_FMT_DRM_PRIME;
+    if (s->av_format != AV_PIX_FMT_NONE)
+        hwframes->sw_format = s->av_format;
+    else
+        hwframes->sw_format = AV_PIX_FMT_BGR0; // jpeg or h264
+    hwframes->width     = s->width;
+    hwframes->height    = s->height;
+    hwframes->initial_pool_size = req.count;
+    res = av_hwframe_ctx_init(s->hw_frames_ref);
+    if (res < 0)
+        return res;
+
+    if (hwframes->initial_pool_size < 2) {
+        av_log(ctx, AV_LOG_ERROR, "Insufficient buffer memory\n");
+        return AVERROR(ENOMEM);
+    }
+
+    s->buffers = hwframes->initial_pool_size;
+    s->pixel_frames = av_mallocz_array(s->buffers, sizeof(AVFrame *));
+    if (!s->pixel_frames) {
+        av_log(ctx, AV_LOG_ERROR, "Cannot allocate pixel frame pointers\n");
+        return AVERROR(ENOMEM);
+    }
+    s->buf_start = av_malloc_array(s->buffers, sizeof(void *));
+    if (!s->buf_start) {
+        av_log(ctx, AV_LOG_ERROR, "Cannot allocate buffer pointers\n");
+        res = AVERROR(ENOMEM);
+        goto fail;
+    }
+    s->buf_len = av_malloc_array(s->buffers, sizeof(unsigned int));
+    if (!s->buf_len) {
+        av_log(ctx, AV_LOG_ERROR, "Cannot allocate buffer sizes\n");
+        res = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    for (i = 0; i < s->buffers; i++) {
+        AVDRMFrameDescriptor *desc;
+        AVDRMObjectDescriptor *object;
+
+        s->pixel_frames[i] = av_frame_alloc();
+        if (!s->pixel_frames[i]) {
+            res = AVERROR(ENOMEM);
+            goto fail;
+        }
+        res = av_hwframe_get_buffer(s->hw_frames_ref, s->pixel_frames[i], 0);
+        if (res < 0)
+            goto fail;
+
+        desc = (AVDRMFrameDescriptor*)s->pixel_frames[i]->data[0];
+        object = &desc->objects[0];
+        // pool always provide only one object, and mmapped userspace viraddr
+        av_assert0(desc->nb_objects == 1 && desc->objects[0].ptr);
+
+        s->buf_start[i] = object->ptr;
+        s->buf_len[i] = object->size;
+        if (s->frame_size > 0 && s->buf_len[i] < s->frame_size) {
+            av_log(ctx, AV_LOG_ERROR,
+                   "buf_len[%d] = %d < expected frame size %d\n",
+                   i, s->buf_len[i], s->frame_size);
+            return AVERROR(ENOMEM);
+        }
+    }
+
+    return 0;
+
+fail:
+    free_pixel_frames(s);
+    if (s->buf_start)
+        av_freep(&s->buf_start);
+    if (s->buf_len)
+        av_freep(&s->buf_len);
+    return res;
+}
+
 static int enqueue_buffer(struct video_data *s, struct v4l2_buffer *buf)
 {
     int res = 0;
@@ -410,16 +536,22 @@ static int enqueue_buffer(struct video_data *s, struct v4l2_buffer *buf)
     return res;
 }
 
-static void mmap_release_buffer(void *opaque, uint8_t *data)
+static void stream_release_buffer(void *opaque, uint8_t *data)
 {
     struct v4l2_buffer buf = { 0 };
     struct buff_data *buf_descriptor = opaque;
     struct video_data *s = buf_descriptor->s;
 
     buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-    buf.memory = V4L2_MEMORY_MMAP;
+    buf.memory = s->memory_type;
     buf.index = buf_descriptor->index;
     av_free(buf_descriptor);
+    if (s->hw_frames_ref) {
+        // V4L2_MEMORY_DMABUF
+        AVFrame *frame = s->pixel_frames[buf.index];
+        buf.m.fd = ((AVDRMFrameDescriptor*)frame->data[0])->objects[0].fd;
+        buf.length = s->buf_len[buf.index];
+    }
 
     enqueue_buffer(s, &buf);
 }
@@ -485,12 +617,12 @@ static int convert_timestamp(AVFormatContext *ctx, int64_t *ts)
     return 0;
 }
 
-static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
+static int stream_read_frame(AVFormatContext *ctx, AVPacket *pkt)
 {
     struct video_data *s = ctx->priv_data;
     struct v4l2_buffer buf = {
         .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
-        .memory = V4L2_MEMORY_MMAP
+        .memory = s->memory_type
     };
     struct timeval buf_ts;
     int res;
@@ -543,7 +675,8 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
     }
 
     /* Image is at s->buff_start[buf.index] */
-    if (atomic_load(&s->buffers_queued) == FFMAX(s->buffers / 8, 1)) {
+    if (s->memory_type == V4L2_MEMORY_MMAP &&
+        atomic_load(&s->buffers_queued) == FFMAX(s->buffers / 8, 1)) {
         /* when we start getting low on queued buffers, fall back on copying data */
         res = av_new_packet(pkt, buf.bytesused);
         if (res < 0) {
@@ -577,11 +710,27 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
         buf_descriptor->index = buf.index;
         buf_descriptor->s     = s;
 
-        pkt->buf = av_buffer_create(pkt->data, pkt->size, mmap_release_buffer,
+        if (s->hw_frames_ref) {
+            if (pkt->hw_frame) {
+                av_log(ctx, AV_LOG_WARNING, "Input packet is not a empty packet!\n");
+                av_frame_free(&pkt->hw_frame);
+            }
+            pkt->hw_frame = av_frame_alloc();
+            if (!pkt->hw_frame ||
+                av_frame_ref(pkt->hw_frame, s->pixel_frames[buf.index])) {
+                enqueue_buffer(s, &buf);
+                av_frame_free(&pkt->hw_frame);
+                av_freep(&buf_descriptor);
+                return AVERROR(ENOMEM);
+            }
+        }
+
+        pkt->buf = av_buffer_create(pkt->data, pkt->size, stream_release_buffer,
                                     buf_descriptor, 0);
         if (!pkt->buf) {
             av_log(ctx, AV_LOG_ERROR, "Failed to create a buffer\n");
             enqueue_buffer(s, &buf);
+            av_frame_free(&pkt->hw_frame);
             av_freep(&buf_descriptor);
             return AVERROR(ENOMEM);
         }
@@ -592,7 +741,7 @@ static int mmap_read_frame(AVFormatContext *ctx, AVPacket *pkt)
     return pkt->size;
 }
 
-static int mmap_start(AVFormatContext *ctx)
+static int stream_start(AVFormatContext *ctx)
 {
     struct video_data *s = ctx->priv_data;
     enum v4l2_buf_type type;
@@ -602,9 +751,16 @@ static int mmap_start(AVFormatContext *ctx)
         struct v4l2_buffer buf = {
             .type   = V4L2_BUF_TYPE_VIDEO_CAPTURE,
             .index  = i,
-            .memory = V4L2_MEMORY_MMAP
+            .memory = s->memory_type
         };
 
+        if (s->hw_frames_ref) {
+            // V4L2_MEMORY_DMABUF
+            AVFrame *frame = s->pixel_frames[i];
+            buf.m.fd = ((AVDRMFrameDescriptor*)frame->data[0])->objects[0].fd;
+            buf.length = s->buf_len[i];
+        }
+
         if (v4l2_ioctl(s->fd, VIDIOC_QBUF, &buf) < 0) {
             res = AVERROR(errno);
             av_log(ctx, AV_LOG_ERROR, "ioctl(VIDIOC_QBUF): %s\n",
@@ -642,6 +798,19 @@ static void mmap_close(struct video_data *s)
     av_freep(&s->buf_len);
 }
 
+static void drm_close(struct video_data *s)
+{
+    enum v4l2_buf_type type;
+
+    type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+    if (-1 == v4l2_ioctl(s->fd, VIDIOC_STREAMOFF, &type))
+        av_log(NULL, AV_LOG_FATAL, "V4L2 Could not steam off (errno = %d).\n",
+               errno);
+    free_pixel_frames(s);
+    av_freep(&s->buf_start);
+    av_freep(&s->buf_len);
+}
+
 static int v4l2_set_parameters(AVFormatContext *ctx)
 {
     struct video_data *s = ctx->priv_data;
@@ -887,8 +1056,37 @@ static int v4l2_read_header(AVFormatContext *ctx)
     avpriv_set_pts_info(st, 64, 1, 1000000); /* 64 bits pts in us */
 
     if (s->pixel_format) {
-        const AVCodecDescriptor *desc = avcodec_descriptor_get_by_name(s->pixel_format);
+        const AVCodecDescriptor *desc;
+        const char *ff_pix_fmt = NULL;
+
+        // drm_prime:ff_pix_fmt
+        if (av_strstart(s->pixel_format, "drm_prime:", &ff_pix_fmt)) {
+            // if set drm_prime, alloc drm buffer externally and queue to v4l2
+            AVBufferRef *hw_device_ref;
+            // libv4l2 has implicit format conversion,
+            // conflict to our intention of using drm external buffer
+            if (s->use_libv4l2) {
+                av_log(ctx, AV_LOG_WARNING,
+                    "use_libv4l2 conflict to pixel format drm_prime\n");
+                res = AVERROR_EXIT;
+                goto fail;
+            }
+            res = av_hwdevice_ctx_create(&hw_device_ref, AV_HWDEVICE_TYPE_DRM,
+                                         NULL, NULL, 0);
+            if (res < 0)
+                goto fail;
+            s->hw_frames_ref = av_hwframe_ctx_alloc(hw_device_ref);
+            av_buffer_unref(&hw_device_ref);
+            if (!s->hw_frames_ref) {
+                res = AVERROR(ENOMEM);
+                goto fail;
+            }
+            memmove(s->pixel_format, ff_pix_fmt, strlen(ff_pix_fmt) + 1);
+            s->stream_init = drm_init;
+            s->stream_close = drm_close;
+        }
 
+        desc = avcodec_descriptor_get_by_name(s->pixel_format);
         if (desc)
             ctx->video_codec_id = desc->id;
 
@@ -940,29 +1138,39 @@ static int v4l2_read_header(AVFormatContext *ctx)
     if ((res = v4l2_set_parameters(ctx)) < 0)
         goto fail;
 
+    s->av_format         =
     st->codecpar->format = ff_fmt_v4l2ff(desired_format, codec_id);
     if (st->codecpar->format != AV_PIX_FMT_NONE)
         s->frame_size = av_image_get_buffer_size(st->codecpar->format,
                                                  s->width, s->height, 1);
 
-    if ((res = mmap_init(ctx)) ||
-        (res = mmap_start(ctx)) < 0)
+    if ((res = s->stream_init(ctx)) ||
+        (res = stream_start(ctx)) < 0)
             goto fail;
 
     s->top_field_first = first_field(s);
 
     st->codecpar->codec_type = AVMEDIA_TYPE_VIDEO;
     st->codecpar->codec_id = codec_id;
-    if (codec_id == AV_CODEC_ID_RAWVIDEO)
+    if (codec_id == AV_CODEC_ID_RAWVIDEO) {
         st->codecpar->codec_tag =
             avcodec_pix_fmt_to_codec_tag(st->codecpar->format);
-    else if (codec_id == AV_CODEC_ID_H264) {
+    } else if (codec_id == AV_CODEC_ID_H264) {
         st->need_parsing = AVSTREAM_PARSE_FULL_ONCE;
     }
     if (desired_format == V4L2_PIX_FMT_YVU420)
         st->codecpar->codec_tag = MKTAG('Y', 'V', '1', '2');
     else if (desired_format == V4L2_PIX_FMT_YVU410)
         st->codecpar->codec_tag = MKTAG('Y', 'V', 'U', '9');
+
+    if (s->hw_frames_ref) {
+        // tag: ignore
+        st->codecpar->codec_tag = MKTAG('I', 'G', 'N', 'R');
+        st->codecpar->sw_format =
+        st->internal->avctx->sw_pix_fmt = st->codecpar->format;
+        st->codecpar->format = AV_PIX_FMT_DRM_PRIME;
+    }
+
     st->codecpar->width = s->width;
     st->codecpar->height = s->height;
     if (st->avg_frame_rate.den)
@@ -971,6 +1179,8 @@ static int v4l2_read_header(AVFormatContext *ctx)
     return 0;
 
 fail:
+    if (s->hw_frames_ref)
+        av_buffer_unref(&s->hw_frames_ref);
     v4l2_close(s->fd);
     return res;
 }
@@ -985,9 +1195,8 @@ FF_ENABLE_DEPRECATION_WARNINGS
 #endif
     int res;
 
-    if ((res = mmap_read_frame(ctx, pkt)) < 0) {
+    if ((res = stream_read_frame(ctx, pkt)) < 0)
         return res;
-    }
 
 #if FF_API_CODED_FRAME && FF_API_LAVF_AVCTX
 FF_DISABLE_DEPRECATION_WARNINGS
@@ -1009,7 +1218,10 @@ static int v4l2_read_close(AVFormatContext *ctx)
         av_log(ctx, AV_LOG_WARNING, "Some buffers are still owned by the caller on "
                "close.\n");
 
-    mmap_close(s);
+    s->stream_close(s);
+
+    if (s->hw_frames_ref)
+        av_buffer_unref(&s->hw_frames_ref);
 
     v4l2_close(s->fd);
     return 0;

From 8f6a6a665b39f76811f4f691e759fabd040b7391 Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Mon, 10 Jun 2019 10:43:02 +0800
Subject: [PATCH 07/13] fix replay may hold seconds after paused

Change-Id: Ic1f81acbff08d6c0e20752a82332a7718b575f64
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 fftools/ffplay.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/fftools/ffplay.c b/fftools/ffplay.c
index a0be207eb84..f9717e43a08 100644
--- a/fftools/ffplay.c
+++ b/fftools/ffplay.c
@@ -1533,7 +1533,7 @@ static void stream_seek(VideoState *is, int64_t pos, int64_t rel, int seek_by_by
 static void stream_toggle_pause(VideoState *is)
 {
     if (is->paused) {
-        is->frame_timer += av_gettime_relative() / 1000000.0 - is->vidclk.last_updated;
+        is->frame_timer += av_gettime_relative() / 1000000.0; // make play immediately
         if (is->read_pause_return != AVERROR(ENOSYS)) {
             is->vidclk.paused = 0;
         }

From 4f6ca8c4228f453d2f3267009792439ad47975ad Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Mon, 10 Jun 2019 16:39:11 +0800
Subject: [PATCH 08/13] As SDL2 support nv12, directly send nv12

Change-Id: I49ce83f65ac8564a60b2add3f6adcb11c4ca5183
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 fftools/ffplay.c | 54 ++++++++++++++++++++++++++++++++++--------------
 1 file changed, 38 insertions(+), 16 deletions(-)

diff --git a/fftools/ffplay.c b/fftools/ffplay.c
index f9717e43a08..84fd8b08de9 100644
--- a/fftools/ffplay.c
+++ b/fftools/ffplay.c
@@ -392,6 +392,7 @@ static const struct TextureFormatEntry {
     { AV_PIX_FMT_BGR32,          SDL_PIXELFORMAT_ABGR8888 },
     { AV_PIX_FMT_BGR32_1,        SDL_PIXELFORMAT_BGRA8888 },
     { AV_PIX_FMT_YUV420P,        SDL_PIXELFORMAT_IYUV },
+    { AV_PIX_FMT_NV12,           SDL_PIXELFORMAT_NV12 },
     { AV_PIX_FMT_YUYV422,        SDL_PIXELFORMAT_YUY2 },
     { AV_PIX_FMT_UYVY422,        SDL_PIXELFORMAT_UYVY },
     { AV_PIX_FMT_NONE,           SDL_PIXELFORMAT_UNKNOWN },
@@ -912,10 +913,14 @@ static void get_sdl_pix_fmt_and_blendmode(int format, Uint32 *sdl_pix_fmt, SDL_B
 
 static void get_avframe_info(AVFrame *frame,
                              uint8_t *srcSlice[],
-                             int srcStride[]) {
+                             int srcStride[],
+                             int *hStride,
+                             int *vStride) {
     if (frame->format != AV_PIX_FMT_DRM_PRIME) {
         memcpy(srcSlice, frame->data, sizeof(frame->data));
         memcpy(srcStride, frame->linesize, sizeof(frame->linesize));
+        *hStride = frame->width;
+        *vStride = frame->height;
     } else {
         AVDRMFrameDescriptor *desc = (AVDRMFrameDescriptor*)frame->data[0];
         AVDRMLayerDescriptor *layer = &desc->layers[0];
@@ -924,6 +929,8 @@ static void get_avframe_info(AVFrame *frame,
         srcSlice[0] = (uint8_t*)desc->objects[0].ptr;
         srcSlice[1] = srcSlice[0] + layer->planes[1].offset;
         srcStride[0] = srcStride[1] = layer->planes[0].pitch;
+        *hStride = layer->planes[0].pitch; // always nv12
+        *vStride = layer->planes[1].offset / layer->planes[0].pitch;
     }
 }
 
@@ -950,8 +957,13 @@ static int upload_texture(SDL_Texture **tex, AVFrame *frame, struct SwsContext *
     Uint32 sdl_pix_fmt;
     SDL_BlendMode sdl_blendmode;
     int av_format = get_avframe_format(frame);
-    get_sdl_pix_fmt_and_blendmode(frame->format, &sdl_pix_fmt, &sdl_blendmode);
-    if (realloc_texture(tex, sdl_pix_fmt == SDL_PIXELFORMAT_UNKNOWN ? SDL_PIXELFORMAT_ARGB8888 : sdl_pix_fmt, frame->width, frame->height, sdl_blendmode, 0) < 0)
+    uint8_t *srcSlice[AV_NUM_DATA_POINTERS] = { NULL };
+    int srcStride[AV_NUM_DATA_POINTERS] = { 0 };
+    int tex_w, tex_h;
+
+    get_avframe_info(frame, srcSlice, srcStride, &tex_w, &tex_h);
+    get_sdl_pix_fmt_and_blendmode(av_format, &sdl_pix_fmt, &sdl_blendmode);
+    if (realloc_texture(tex, sdl_pix_fmt == SDL_PIXELFORMAT_UNKNOWN ? SDL_PIXELFORMAT_ARGB8888 : sdl_pix_fmt, tex_w, tex_h, sdl_blendmode, 0) < 0)
         return -1;
     switch (sdl_pix_fmt) {
         case SDL_PIXELFORMAT_UNKNOWN:
@@ -960,14 +972,10 @@ static int upload_texture(SDL_Texture **tex, AVFrame *frame, struct SwsContext *
                 frame->width, frame->height, av_format, frame->width, frame->height,
                 AV_PIX_FMT_BGRA, sws_flags, NULL, NULL, NULL);
             if (*img_convert_ctx != NULL) {
-                uint8_t *pixels[4];
-                int pitch[4];
+                uint8_t *pixels[4] = { NULL };
+                int pitch[4] = { 0 };
                 if (!SDL_LockTexture(*tex, NULL, (void **)pixels, pitch)) {
-                    uint8_t *srcSlice[AV_NUM_DATA_POINTERS] = { NULL };
-                    int srcStride[AV_NUM_DATA_POINTERS] = { 0 };
-
-                    get_avframe_info(frame, srcSlice, srcStride);
-                    sws_scale(*img_convert_ctx, (const uint8_t * const *)srcSlice, srcStride,
+                    sws_scale(*img_convert_ctx, (const uint8_t * const *)frame->data, frame->linesize,
                               0, frame->height, pixels, pitch);
                     SDL_UnlockTexture(*tex);
                 }
@@ -976,6 +984,16 @@ static int upload_texture(SDL_Texture **tex, AVFrame *frame, struct SwsContext *
                 ret = -1;
             }
             break;
+        case SDL_PIXELFORMAT_NV12:
+            {
+                if (srcStride[0] > 0 && srcStride[1] > 0) {
+                    ret = SDL_UpdateTexture(*tex, NULL, srcSlice[0], srcStride[0]);
+                } else {
+                    av_log(NULL, AV_LOG_ERROR, "TODO: negative linesizes are not supported.\n");
+                    return -1;
+                }
+            }
+            break;
         case SDL_PIXELFORMAT_IYUV:
             if (frame->linesize[0] > 0 && frame->linesize[1] > 0 && frame->linesize[2] > 0) {
                 ret = SDL_UpdateYUVTexture(*tex, NULL, frame->data[0], frame->linesize[0],
@@ -1021,7 +1039,7 @@ static void video_image_display(VideoState *is)
 {
     Frame *vp;
     Frame *sp = NULL;
-    SDL_Rect rect;
+    SDL_Rect rect, src_rect;
 
     vp = frame_queue_peek_last(&is->pictq);
     if (is->subtitle_st) {
@@ -1071,6 +1089,10 @@ static void video_image_display(VideoState *is)
 
     calculate_display_rect(&rect, is->xleft, is->ytop, is->width, is->height, vp->width, vp->height, vp->sar);
 
+    src_rect.x = 0;
+    src_rect.y = 0;
+    src_rect.w = vp->frame->width;
+    src_rect.h = vp->frame->height;
     if (!vp->uploaded) {
         if (upload_texture(&is->vid_texture, vp->frame, &is->img_convert_ctx) < 0)
             return;
@@ -1079,7 +1101,7 @@ static void video_image_display(VideoState *is)
     }
 
     set_sdl_yuv_conversion_mode(vp->frame);
-    SDL_RenderCopyEx(renderer, is->vid_texture, NULL, &rect, 0, NULL, vp->flip_v ? SDL_FLIP_VERTICAL : 0);
+    SDL_RenderCopyEx(renderer, is->vid_texture, &src_rect, &rect, 0, NULL, vp->flip_v ? SDL_FLIP_VERTICAL : 0);
     set_sdl_yuv_conversion_mode(NULL);
     if (sp) {
 #if USE_ONEPASS_SUBTITLE_RENDER
@@ -1533,7 +1555,7 @@ static void stream_seek(VideoState *is, int64_t pos, int64_t rel, int seek_by_by
 static void stream_toggle_pause(VideoState *is)
 {
     if (is->paused) {
-        is->frame_timer += av_gettime_relative() / 1000000.0; // make play immediately
+        is->frame_timer = av_gettime_relative() / 1000000.0; // make play immediately
         if (is->read_pause_return != AVERROR(ENOSYS)) {
             is->vidclk.paused = 0;
         }
@@ -2241,14 +2263,14 @@ static int video_thread(void *arg)
             frame_rate = av_buffersink_get_frame_rate(filt_out);
         }
 
-        if (support_avfilter) {
+        if (filt_in) {
         ret = av_buffersrc_add_frame(filt_in, frame);
         if (ret < 0)
             goto the_end;
         }
 
         while (ret >= 0) {
-            if (support_avfilter) {
+            if (filt_out) {
             is->frame_last_returned_time = av_gettime_relative() / 1000000.0;
 
             ret = av_buffersink_get_frame_flags(filt_out, frame, 0);
@@ -2270,7 +2292,7 @@ static int video_thread(void *arg)
             ret = queue_picture(is, frame, pts, duration, frame->pkt_pos, is->viddec.pkt_serial);
             av_frame_unref(frame);
 #if CONFIG_AVFILTER
-            if (!support_avfilter || is->videoq.serial != is->viddec.pkt_serial)
+            if (!filt_out || is->videoq.serial != is->viddec.pkt_serial)
                 break;
         }
 #endif

From 226e514675a10e583d2af123b2b6960043da1dca Mon Sep 17 00:00:00 2001
From: Francis Fan <francis.fan@rock-chips.com>
Date: Wed, 12 Jun 2019 22:01:10 +0800
Subject: [PATCH 09/13] add ffmpeg compilation support

Change-Id: I74eac5a367904091fc7b30509dd7b21c2a1250e8
Signed-off-by: Francis Fan <francis.fan@rock-chips.com>
(cherry picked from commit 38986885a51a08b89b40419cb1c2263b82314155)
---
 Config.in   | 299 +++++++++++++++++++++++++++++++++
 ffmpeg.rvmk | 475 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 774 insertions(+)
 create mode 100644 Config.in
 create mode 100644 ffmpeg.rvmk

diff --git a/Config.in b/Config.in
new file mode 100644
index 00000000000..fa5d564c947
--- /dev/null
+++ b/Config.in
@@ -0,0 +1,299 @@
+menuconfig RV_TARGET_FFMPEG
+	bool "FFMPEG"
+	default n
+	help
+	  FFMPEG in rv is used as muxer/demuxer, audio codecs and hardware h264 codecs.
+
+if RV_TARGET_FFMPEG
+config RV_TARGET_FFMPEG_STATIC_LIB
+	bool "Build static lib"
+	default n
+
+config RV_TARGET_FFMPEG_FS_MANAGE
+	bool "Use fs manage interface"
+	default n
+	help
+	  file interface use libfs_manage
+
+config RV_TARGET_MPP_DECODER_LIMIT_BUFFER_NUM
+	string "the num of mpp decoder limited buffer"
+	default 0
+	help
+	  if 0, mpp decoder suppose that ion buffer can be used without concern.
+	  Set equal or greater than 4 if you need the mpp decoder limit buffer usage.
+
+config RV_TARGET_FFMPEG_GPL
+	bool "Enable GPL code"
+	default n
+	help
+	  allow use of GPL code, the resulting libs and binaries will be under GPL
+
+config RV_TARGET_FFMPEG_NONFREE
+	bool "Enable nonfree code"
+	default n
+	help
+	  allow use of nonfree code, the resulting libs and binaries
+	  will be unredistributable
+
+config RV_TARGET_FFMPEG_DISABLE_FFPLAY
+	bool "Disable ffplay"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_FFPORBE
+	bool "Disable ffprobe"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_COREIMAGE
+	bool "Disable core image"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_VALGRINDBACKTRACE
+	bool "Disable valgrind-backtrace"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_LOGGING
+	bool "Disable logging"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_BSFS
+	bool "Disable bsfs"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_MUXERS
+	bool "Disable all muxers"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_DEMUXERS
+	bool "Disable all demuxers"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_FILTERS
+	bool "Disable all filters"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_ENCODERS
+	bool "Disable all encoders"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_DECODERS
+	bool "Disable all decoders"
+	default n
+
+config RV_TARGET_FFMPEG_DEMUXER_H264
+	bool "Enable demuxer h264"
+	default n
+
+config RV_TARGET_FFMPEG_MUXER_AVI
+	bool "Enable muxer avi"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "avi"
+
+config RV_TARGET_FFMPEG_DEMUXER_AVI
+	bool "Enable demuxer avi"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "avi"
+
+config RV_TARGET_FFMPEG_MUXER_MPEGTS
+	bool "Enable muxer mpegts"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "ts"
+
+config RV_TARGET_FFMPEG_DEMUXER_MPEGTS
+	bool "Enable demuxer mpegts"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "ts"
+
+config RV_TARGET_FFMPEG_DEMUXER_MPEGPS
+	bool "Enable demuxer mpegps"
+	default n
+
+config RV_TARGET_FFMPEG_MUXER_RTP
+	bool "Enable muxer rtp"
+	default n
+
+config RV_TARGET_FFMPEG_MUXER_MP4
+	bool "Enable muxer mp4"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "mp4"
+
+config RV_TARGET_FFMPEG_MUXER_MOV
+	bool "Enable muxer mov"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "mov"
+
+config RV_TARGET_FFMPEG_DEMUXER_MOV_MP4
+	bool "Enable demuxer mov/mp4"
+	default y if RV_TARGET_MAIN_APP_RECORD_FORMAT = "mp4" || RV_TARGET_MAIN_APP_RECORD_FORMAT = "mov"
+
+config RV_TARGET_FFMPEG_MUXER_ADTS
+	bool "Enable muxer adts"
+	default n
+
+config RV_TARGET_FFMPEG_DEMUXER_AAC
+	bool "Enable demuxer aac"
+	default n
+
+config RV_TARGET_FFMPEG_MUXER_RTP_MPEGTS
+	bool "Enable muxer rtp_mpegts"
+	default n
+	select RV_TARGET_FFMPEG_MUXER_RTP
+	select RV_TARGET_FFMPEG_MUXER_MPEGTS
+
+config RV_TARGET_FFMPEG_MUXER_FLV
+	bool "Enable muxer flv"
+	default y if RV_TARGET_MAIN_APP_TS_PROTOCOL = "rtmp"
+	default n
+
+config RV_TARGET_FFMPEG_DEMUXER_RTSP
+	bool "Enable demuxer rtsp"
+	default n
+
+config RV_TARGET_FFMPEG_PROTOCOL_FILE
+	bool "Enable protocol file"
+	default y
+
+config RV_TARGET_FFMPEG_PROTOCOL_UDP
+	bool "Enable protocol udp"
+	default n
+
+config RV_TARGET_FFMPEG_PROTOCOL_TCP
+	bool "Enable protocol tcp"
+	default n
+
+config RV_TARGET_FFMPEG_PROTOCOL_RTP
+	bool "Enable protocol rtp"
+	default n
+
+config RV_TARGET_FFMPEG_LIBRTMP
+	bool "Enable protocol librtmp"
+	default y if RV_TARGET_LIBRTMP
+
+
+config RV_TARGET_FFMPEG_ENABLE_SMALL
+	bool "Enable small"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_FDKAAC
+	bool "Enable decoder:fdk_aac"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_AAC
+	bool "Enable decoder:aac"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_AACAT
+	bool "Enable decoder:aac_at"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_AACFIXED
+	bool "Enable decoder:aac_fixed"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_AACLATM
+	bool "Enable decoder:aac_latm"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_RKMPP
+	bool "Enable decoder:rk_mpp"
+	default n
+
+
+config RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM16
+	bool "Enable encoder:16 bit PCM"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM32
+	bool "Enable encoder:32 bit PCM"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_ENCODER_RKMPP
+	bool "Enable encoder:rk_mpp"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_MUXER_PCM32
+	bool "Enable muxer:32 bit PCM"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_MUXER_PCM16
+	bool "Enable muxer:16 bit PCM"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_MUXER_PCMALAW
+	bool "Enable muxer:pcm_alaw"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_MUXER_H264
+	bool "Enable muxer:h264"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCM32
+	bool "Enable demuxer:32 bit PCM"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCM16
+	bool "Enable demuxer:16 bit PCM"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCMALAW
+	bool "Enable demuxer:pcm_alaw"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MJPEG
+	bool "Enable demuxer:mjpeg"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MJPEG2000
+	bool "Enable demuxer:mjpeg2000"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPEGTSRAW
+	bool "Enable demuxer:mjpegtsraw"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPJPEG
+	bool "Enable demuxer:mpjpeg"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPL2
+	bool "Enable demuxer:mpl2"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_IPMOVIE
+	bool "Enable demuxer:ipmovie"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MLP
+	bool "Enable demuxer:mlp"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MLV
+	bool "Enable demuxer:mlv"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MM
+	bool "Enable demuxer:mm"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MMF
+	bool "Enable demuxer:mmf"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MOV
+	bool "Enable demuxer:mov"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MP3
+	bool "Enable demuxer:mp3"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPC
+	bool "Enable demuxer:mpc"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPC8
+	bool "Enable demuxer:mpc8"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_WAV
+	bool "Enable demuxer:wav"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_PARSER_H264
+	bool "Enable parser:h264"
+	default n
+
+endif
diff --git a/ffmpeg.rvmk b/ffmpeg.rvmk
new file mode 100644
index 00000000000..9ffe027067e
--- /dev/null
+++ b/ffmpeg.rvmk
@@ -0,0 +1,475 @@
+################################################################################
+#
+# ffmpeg
+#
+################################################################################
+
+FFMPEG_DEPENDENCIES = host-pkgconf mpp
+
+FFMPEG_CONF_ENV = PKG_CONFIG_LIBDIR="$(TARGET_DIR)/lib/pkgconfig"
+
+FFMPEG_TARGET_FILES = $(FFMPEG_PKGDIR)libavformat/libavformat.$(FFMPEG_TARGET_TYPE) \
+	$(FFMPEG_PKGDIR)libswresample/libswresample.$(FFMPEG_TARGET_TYPE) \
+	$(FFMPEG_PKGDIR)libavutil/libavutil.$(FFMPEG_TARGET_TYPE) \
+	$(FFMPEG_PKGDIR)libavcodec/libavcodec.$(FFMPEG_TARGET_TYPE)
+
+FFMPEG_CONF_OPTS = \
+	--prefix=$(TARGET_DIR) \
+	--pkg-config=$(PKG_CONFIG_HOST_BINARY) \
+	--pkgconfigdir=$(TARGET_DIR)/lib/pkgconfig \
+	--enable-cross-compile \
+	--disable-programs \
+	--disable-doc \
+	--disable-avdevice \
+	--disable-postproc \
+	--disable-swscale \
+	--disable-avfilter \
+	--disable-w32threads --disable-os2threads \
+	--disable-pixelutils \
+	--disable-everything \
+	--disable-hwaccels \
+	--disable-audiotoolbox \
+	--disable-iconv \
+	--disable-libxcb \
+	--disable-libxcb-shm \
+	--disable-libxcb-xfixes \
+	--disable-libxcb-shape \
+	--disable-schannel \
+	--disable-securetransport \
+	--disable-videotoolbox \
+	--disable-xlib \
+	--disable-asm \
+	--disable-zlib \
+	--cross-prefix=$(TARGET_CROSS) \
+	--target-os=linux \
+	--arch=armv7-a \
+	--disable-runtime-cpudetect \
+	--disable-htmlpages \
+	--disable-podpages \
+	--disable-txtpages
+
+FFMPEG_CONFIGURE_DEP_CONFIGS =
+
+FFMPEG_EXTRA_CFLAGS = -Wno-multichar
+
+ifneq ($(RV_ENABLE_DEBUG),n)
+FFMPEG_CONF_OPTS += --disable-debug
+endif
+
+ifeq ($(RV_OPTIMIZE_0),y)
+FFMPEG_CONF_OPTS += --disable-optimizations
+endif
+
+#ifeq ($(RV_STRIP_none),y)
+FFMPEG_CONF_OPTS += --disable-stripping
+#endif
+#FFMPEG_CONFIGURE_DEP_CONFIGS += RV_STRIP_none
+
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_FFPLAY),y)
+FFMPEG_CONF_OPTS += --disable-ffplay
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_FFPLAY
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_FFPORBE),y)
+FFMPEG_CONF_OPTS += --disable-ffprobe
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_FFPORBE
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_COREIMAGE),y)
+FFMPEG_CONF_OPTS += --disable-coreimage
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_COREIMAGE
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_VALGRINDBACKTRACE),y)
+FFMPEG_CONF_OPTS += --disable-valgrind-backtrace
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_VALGRINDBACKTRACE
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_LOGGING),y)
+FFMPEG_CONF_OPTS += --disable-logging
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_LOGGING
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_BSFS),y)
+FFMPEG_CONF_OPTS += --disable-bsfs
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_BSFS
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_MUXERS),y)
+FFMPEG_CONF_OPTS += --disable-muxers
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_MUXERS
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_DEMUXERS),y)
+FFMPEG_CONF_OPTS += --disable-demuxers
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_DEMUXERS
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_FILTERS),y)
+FFMPEG_CONF_OPTS += --disable-filters
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_FILTERS
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_ENCODERS),y)
+FFMPEG_CONF_OPTS += --disable-encoders
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_ENCODERS
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_DECODERS),y)
+FFMPEG_CONF_OPTS += --disable-decoders
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_DECODERS
+
+ifeq ($(BR2_ARM_CPU_HAS_VFPV2),y)
+FFMPEG_CONF_OPTS += --enable-vfp
+else
+FFMPEG_CONF_OPTS += --disable-vfp
+endif
+ifeq ($(BR2_ARM_CPU_HAS_NEON),y)
+FFMPEG_CONF_OPTS += --enable-neon
+FFMPEG_EXTRA_CFLAGS += -mfpu=neon
+endif
+
+ifeq ($(RV_TARGET_FFMPEG_STATIC_LIB),y)
+FFMPEG_CONF_OPTS += --enable-static --disable-shared
+FFMPEG_TARGET_TYPE=a
+else
+FFMPEG_CONF_OPTS += --enable-shared --disable-static --enable-pic
+FFMPEG_TARGET_TYPE=so
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_STATIC_LIB
+
+ifeq ($(RV_TARGET_FFMPEG_FS_MANAGE),y)
+FFMPEG_EXTRA_CFLAGS += -DFS_CACHE=1
+FFMPEG_DEPENDENCIES += libfs_manage
+else
+FFMPEG_EXTRA_CFLAGS += -DFS_CACHE=0
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_FS_MANAGE
+
+FFMPEG_EXTRA_CFLAGS += -DMPP_DECODER_LIMIT_BUFFER_NUM=$(call qstrip,$(RV_TARGET_MPP_DECODER_LIMIT_BUFFER_NUM))
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_MPP_DECODER_LIMIT_BUFFER_NUM
+
+ifeq ($(RV_TARGET_FFMPEG_GPL),y)
+FFMPEG_CONF_OPTS += --enable-gpl
+else
+FFMPEG_CONF_OPTS += --disable-gpl
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_GPL
+
+ifeq ($(RV_TARGET_FFMPEG_NONFREE),y)
+FFMPEG_CONF_OPTS += --enable-nonfree
+else
+FFMPEG_CONF_OPTS += --disable-nonfree
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_NONFREE
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_H264),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=h264
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_H264
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_AVI),y)
+FFMPEG_CONF_OPTS += --enable-muxer=avi
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_AVI
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_AVI),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=avi
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_AVI
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_MPEGTS),y)
+FFMPEG_CONF_OPTS += --enable-muxer=mpegts
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_MPEGTS
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_MPEGTS),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpegts
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_MPEGTS
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_MPEGPS),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpegps
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_MPEGPS
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_RTP),y)
+FFMPEG_CONF_OPTS += --enable-muxer=rtp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_RTP
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_MP4),y)
+FFMPEG_CONF_OPTS += --enable-muxer=mp4
+ifeq ($(RV_TARGET_GPS_MOVTEXT),y)
+FFMPEG_CONF_OPTS += --enable-encoder=movtext
+endif
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_MP4
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_MOV),y)
+FFMPEG_CONF_OPTS += --enable-muxer=mov
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_MOV
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_MOV_MP4),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mov
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_MOV_MP4
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_RTP_MPEGTS),y)
+FFMPEG_CONF_OPTS += --enable-muxer=rtp_mpegts
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_RTP_MPEGTS
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_FLV),y)
+FFMPEG_CONF_OPTS += --enable-muxer=flv
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_FLV
+
+ifeq ($(RV_TARGET_FFMPEG_MUXER_ADTS),y)
+FFMPEG_CONF_OPTS += --enable-muxer=adts
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_MUXER_ADTS
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_AAC),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=aac
+FFMPEG_CONF_OPTS += --enable-parser=aac --enable-parser=aac_latm
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_AAC
+
+ifeq ($(RV_TARGET_FFMPEG_DEMUXER_RTSP),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=rtsp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DEMUXER_RTSP
+
+ifeq ($(RV_TARGET_FFMPEG_PROTOCOL_FILE),y)
+FFMPEG_CONF_OPTS += --enable-protocol=file
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_PROTOCOL_FILE
+
+ifeq ($(RV_TARGET_FFMPEG_PROTOCOL_UDP),y)
+FFMPEG_CONF_OPTS += --enable-protocol=udp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_PROTOCOL_UDP
+
+ifeq ($(RV_TARGET_FFMPEG_PROTOCOL_TCP),y)
+FFMPEG_CONF_OPTS += --enable-protocol=tcp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_PROTOCOL_TCP
+
+ifeq ($(RV_TARGET_FFMPEG_PROTOCOL_RTP),y)
+FFMPEG_CONF_OPTS += --enable-protocol=rtp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_PROTOCOL_RTP
+
+ifeq ($(RV_TARGET_FFMPEG_LIBRTMP),y)
+FFMPEG_CONF_OPTS += --enable-protocol=librtmp --enable-librtmp
+FFMPEG_DEPENDENCIES += librtmp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_LIBRTMP
+
+################################################################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_SMALL),y)
+FFMPEG_CONF_OPTS += --enable-small
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_SMALL
+
+####################### DECODER ################################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_FDKAAC),y)
+FFMPEG_CONF_OPTS += --enable-decoder=libfdk_aac
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_FDKAAC
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_AAC),y)
+FFMPEG_CONF_OPTS += --enable-decoder=aac
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_AAC
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_AACAT),y)
+FFMPEG_CONF_OPTS += --enable-decoder=aac_at
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_AACAT
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_AACFIXED),y)
+FFMPEG_CONF_OPTS += --enable-decoder=aac_fixed
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_AACFIXED
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_AACLATM),y)
+FFMPEG_CONF_OPTS += --enable-decoder=aac_latm
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_AACLATM
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_RKMPP),y)
+FFMPEG_CONF_OPTS += --enable-decoder=h264_rkmpp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_RKMPP
+
+
+##################### ENCODER #######################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM16),y)
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_s16be
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_s16le
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_u16be
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_u16le
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM16
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM32),y)
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_s32be
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_s32le
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_u32be
+FFMPEG_CONF_OPTS += --enable-encoder=pcm_u32le
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM32
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_ENCODER_RKMPP),y)
+FFMPEG_CONF_OPTS += --enable-encoder=h264_rkmpp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_ENCODER_RKMPP
+
+################# MUXER ##########################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_MUXER_PCM32),y)
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_f32be
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_s32be
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_s32le
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_u32be
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_u32le
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_MUXER_PCM32
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_MUXER_PCM16),y)
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_s16be
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_s16le
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_u16be
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_u16le
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_MUXER_PCM16
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_MUXER_PCMALAW),y)
+FFMPEG_CONF_OPTS += --enable-muxer=pcm_alaw
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_MUXER_PCMALAW
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_MUXER_H264),y)
+FFMPEG_CONF_OPTS += --enable-muxer=h264
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_MUXER_H264
+
+########## DEMUXER ###############################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCM32),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_f32be
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_f32le
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_s32be
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_s32le
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_u32be
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_u32le
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCM32
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCM16),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_s16be
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_s16le
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_u16be
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_u16le
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCM16
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCMALAW),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=pcm_alaw
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_PCMALAW
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MJPEG),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mjpeg
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MJPEG
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MJPEG2000),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mjpeg_2000
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MJPEG2000
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPEGTSRAW),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpegtsraw
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPEGTSRAW
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPJPEG),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpjpeg
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPJPEG
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPL2),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpl2
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPL2
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_IPMOVIE),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=ipmovie
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_IPMOVIE
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MLP),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mlp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MLP
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MLV),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mlv
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MLV
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MM),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mm
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MM
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MMF),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mmf
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MMF
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MOV),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mov
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MOV
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MP3),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mp3
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MP3
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPC),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpc
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPC
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPC8),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpc8
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPC8
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_WAV),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=wav
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_WAV
+
+############# PARSER #######################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_PARSER_H264),y)
+FFMPEG_CONF_OPTS += --enable-parser=h264
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_PARSER_H264
+
+FFMPEG_CONF_OPTS += --extra-cflags="$(FFMPEG_EXTRA_CFLAGS)"
+
+$(eval $(rv-generic-configure))
+

From 3396f052277c2e85222011fb633a3d7634d25c1a Mon Sep 17 00:00:00 2001
From: Francis Fan <francis.fan@rock-chips.com>
Date: Tue, 2 Jul 2019 20:48:29 +0800
Subject: [PATCH 10/13] add ion type for hwcontext table

Change-Id: I609145796477221df5daa79f2a4771718c34794f
Signed-off-by: Francis Fan <francis.fan@rock-chips.com>
---
 libavutil/hwcontext.c     |  3 +++
 libavutil/hwcontext_ion.h | 37 +++++++++++++++++++++++++++++++++++++
 2 files changed, 40 insertions(+)
 create mode 100644 libavutil/hwcontext_ion.h

diff --git a/libavutil/hwcontext.c b/libavutil/hwcontext.c
index f1e404ab201..6caa74215f5 100644
--- a/libavutil/hwcontext.c
+++ b/libavutil/hwcontext.c
@@ -27,6 +27,7 @@
 #include "mem.h"
 #include "pixdesc.h"
 #include "pixfmt.h"
+#include "hwcontext_ion.h"
 
 static const HWContextType * const hw_table[] = {
 #if CONFIG_CUDA
@@ -37,6 +38,8 @@ static const HWContextType * const hw_table[] = {
 #endif
 #if CONFIG_LIBDRM
     &ff_hwcontext_type_drm,
+#elif CONFIG_ION
+    &ff_hwcontext_type_ion,
 #endif
 #if CONFIG_DXVA2
     &ff_hwcontext_type_dxva2,
diff --git a/libavutil/hwcontext_ion.h b/libavutil/hwcontext_ion.h
new file mode 100644
index 00000000000..5a5d98f18fa
--- /dev/null
+++ b/libavutil/hwcontext_ion.h
@@ -0,0 +1,37 @@
+/*
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVUTIL_HWCONTEXT_ION_H
+#define AVUTIL_HWCONTEXT_ION_H
+
+#include "hwcontext_internal.h"
+#include "pixfmt.h"
+
+const HWContextType ff_hwcontext_type_ion = {
+    .type                   = AV_HWDEVICE_TYPE_DRM,
+    .name                   = "ION",
+
+    .device_hwctx_size      = sizeof(int),
+
+    .pix_fmts = (const enum AVPixelFormat[]) {
+        AV_PIX_FMT_DRM_PRIME,
+        AV_PIX_FMT_NONE
+    },
+};
+
+#endif /* AVUTIL_HWCONTEXT_ION_H */

From 03582e4b7a73abe6556fb9786e48d0181a812e54 Mon Sep 17 00:00:00 2001
From: Francis Fan <francis.fan@rock-chips.com>
Date: Fri, 5 Jul 2019 16:24:56 +0800
Subject: [PATCH 11/13] rv1108: update ffmpeg config menu for rkffplay

Change-Id: If6bc9d6737f69c96c4fd44c56816e5c5aaf86513
Signed-off-by: Francis Fan <francis.fan@rock-chips.com>
---
 Config.in   | 105 +++++++++++++++++++++++++++++++++++++++++---
 configure   |   2 +-
 ffmpeg.rvmk | 122 ++++++++++++++++++++++++++++++++++++++++++++--------
 3 files changed, 203 insertions(+), 26 deletions(-)

diff --git a/Config.in b/Config.in
index fa5d564c947..8d07a08b756 100644
--- a/Config.in
+++ b/Config.in
@@ -35,14 +35,35 @@ config RV_TARGET_FFMPEG_NONFREE
 	  allow use of nonfree code, the resulting libs and binaries
 	  will be unredistributable
 
-config RV_TARGET_FFMPEG_DISABLE_FFPLAY
-	bool "Disable ffplay"
+config RV_TARGET_FFMPEG_ENABLE_ION
+	bool "Enable ion type for hwcontext table"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_VERSION3
+	bool "Enable version3"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_RKMPP
+	bool "Enable rkmpp"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_FFMPEG
+	bool "Disable ffmpeg"
 	default n
 
 config RV_TARGET_FFMPEG_DISABLE_FFPORBE
 	bool "Disable ffprobe"
 	default n
 
+config RV_TARGET_FFMPEG_DISABLE_FFPLAY
+	bool "Disable ffplay"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_SDL
+	bool "Enable sdl for ffplay"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_FFPLAY)
+	default y if (!RV_TARGET_FFMPEG_DISABLE_FFPLAY)
+
 config RV_TARGET_FFMPEG_DISABLE_COREIMAGE
 	bool "Disable core image"
 	default n
@@ -59,24 +80,54 @@ config RV_TARGET_FFMPEG_DISABLE_BSFS
 	bool "Disable bsfs"
 	default n
 
+config RV_TARGET_FFMPEG_DISABLE_EVERYTHING
+	bool "Disable everything"
+	default y
+
 config RV_TARGET_FFMPEG_DISABLE_MUXERS
 	bool "Disable all muxers"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_EVERYTHING)
 	default n
 
 config RV_TARGET_FFMPEG_DISABLE_DEMUXERS
 	bool "Disable all demuxers"
-	default n
-
-config RV_TARGET_FFMPEG_DISABLE_FILTERS
-	bool "Disable all filters"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_EVERYTHING)
 	default n
 
 config RV_TARGET_FFMPEG_DISABLE_ENCODERS
 	bool "Disable all encoders"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_EVERYTHING)
 	default n
 
 config RV_TARGET_FFMPEG_DISABLE_DECODERS
 	bool "Disable all decoders"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_EVERYTHING)
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_DEVICES
+	bool "Disable all devices"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_EVERYTHING)
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_FILTERS
+	bool "Disable all filters"
+	depends on (!RV_TARGET_FFMPEG_DISABLE_EVERYTHING)
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_AVDEVICES
+	bool "Disable all avdevices"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_AVFILTERS
+	bool "Disable all avfilters"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_SWSCALE
+	bool "Disable swscale"
+	default n
+
+config RV_TARGET_FFMPEG_DISABLE_SWRESAMPLE
+	bool "Disable swresample"
 	default n
 
 config RV_TARGET_FFMPEG_DEMUXER_H264
@@ -187,8 +238,29 @@ config RV_TARGET_FFMPEG_ENABLE_DECODER_AACLATM
 	bool "Enable decoder:aac_latm"
 	default n
 
+config RV_TARGET_FFMPEG_ENABLE_DECODER_AC3
+	bool "Enable decoder:ac3"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_MPEG4
+	bool "Enable decoder:mpeg4"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_H264
+	bool "Enable decoder:h264"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_ASS
+	bool "Enable decoder:ass"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DECODER_VORBIS
+	bool "Enable decoder:vorbis"
+	default n
+
 config RV_TARGET_FFMPEG_ENABLE_DECODER_RKMPP
 	bool "Enable decoder:rk_mpp"
+	depends on RV_TARGET_FFMPEG_ENABLE_RKMPP
 	default n
 
 
@@ -202,6 +274,7 @@ config RV_TARGET_FFMPEG_ENABLE_ENCODER_PCM32
 
 config RV_TARGET_FFMPEG_ENABLE_ENCODER_RKMPP
 	bool "Enable encoder:rk_mpp"
+	depends on RV_TARGET_FFMPEG_ENABLE_RKMPP
 	default n
 
 config RV_TARGET_FFMPEG_ENABLE_MUXER_PCM32
@@ -292,8 +365,28 @@ config RV_TARGET_FFMPEG_ENABLE_DEMUXER_WAV
 	bool "Enable demuxer:wav"
 	default n
 
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_AC3
+	bool "Enable demuxer:ac3"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPEGVIDEO
+	bool "Enable demuxer:mpegvideo"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_MATROSKA
+	bool "Enable demuxer:matroska"
+	default n
+
+config RV_TARGET_FFMPEG_ENABLE_DEMUXER_ASS
+	bool "Enable demuxer:ass"
+	default n
+
 config RV_TARGET_FFMPEG_ENABLE_PARSER_H264
 	bool "Enable parser:h264"
 	default n
 
+config RV_TARGET_FFMPEG_ENABLE_FILTER_ARESAMPLE
+	bool "Enable filter:aresample"
+	default n
+
 endif
diff --git a/configure b/configure
index 66f2497507d..b0630f69e01 100755
--- a/configure
+++ b/configure
@@ -6237,7 +6237,7 @@ enabled openssl           && { check_pkg_config openssl openssl openssl/ssl.h OP
 enabled rkmpp             && { require_pkg_config rkmpp rockchip_mpp  rockchip/rk_mpi.h mpp_create &&
                                require_pkg_config rockchip_mpp "rockchip_mpp >= 1.3.7" rockchip/rk_mpi.h mpp_create &&
                                { enabled libdrm ||
-                                 die "ERROR: rkmpp requires --enable-libdrm"; }
+                                 warn "WARNING: rkmpp requires --enable-libdrm"; }
                              }
 enabled vapoursynth       && require_pkg_config vapoursynth "vapoursynth-script >= 42" VSScript.h vsscript_init
 
diff --git a/ffmpeg.rvmk b/ffmpeg.rvmk
index 9ffe027067e..bd2b72938e7 100644
--- a/ffmpeg.rvmk
+++ b/ffmpeg.rvmk
@@ -18,28 +18,9 @@ FFMPEG_CONF_OPTS = \
 	--pkg-config=$(PKG_CONFIG_HOST_BINARY) \
 	--pkgconfigdir=$(TARGET_DIR)/lib/pkgconfig \
 	--enable-cross-compile \
-	--disable-programs \
 	--disable-doc \
-	--disable-avdevice \
 	--disable-postproc \
-	--disable-swscale \
-	--disable-avfilter \
 	--disable-w32threads --disable-os2threads \
-	--disable-pixelutils \
-	--disable-everything \
-	--disable-hwaccels \
-	--disable-audiotoolbox \
-	--disable-iconv \
-	--disable-libxcb \
-	--disable-libxcb-shm \
-	--disable-libxcb-xfixes \
-	--disable-libxcb-shape \
-	--disable-schannel \
-	--disable-securetransport \
-	--disable-videotoolbox \
-	--disable-xlib \
-	--disable-asm \
-	--disable-zlib \
 	--cross-prefix=$(TARGET_CROSS) \
 	--target-os=linux \
 	--arch=armv7-a \
@@ -76,6 +57,11 @@ FFMPEG_CONF_OPTS += --disable-ffprobe
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_FFPORBE
 
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_FFMPEG),y)
+FFMPEG_CONF_OPTS += --disable-ffmpeg
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_FFMPEG
+
 ifeq ($(RV_TARGET_FFMPEG_DISABLE_COREIMAGE),y)
 FFMPEG_CONF_OPTS += --disable-coreimage
 endif
@@ -96,6 +82,11 @@ FFMPEG_CONF_OPTS += --disable-bsfs
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_BSFS
 
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_EVERYTHING),y)
+FFMPEG_CONF_OPTS += --disable-everything
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_EVERYTHING
+
 ifeq ($(RV_TARGET_FFMPEG_DISABLE_MUXERS),y)
 FFMPEG_CONF_OPTS += --disable-muxers
 endif
@@ -111,6 +102,27 @@ FFMPEG_CONF_OPTS += --disable-filters
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_FILTERS
 
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_DEVICES),y)
+FFMPEG_CONF_OPTS += --disable-devices
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_DEVICES
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_AVDEVICES),y)
+FFMPEG_CONF_OPTS += --disable-avdevice
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_AVDEVICES
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_AVFILTERS),y)
+FFMPEG_CONF_OPTS += --disable-avfilter
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_AVFILTERS
+
+ifeq ($(RV_TARGET_FFMPEG_DISABLE_SWSCALE),y)
+FFMPEG_CONF_OPTS += --disable-swscale
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_DISABLE_SWSCALE
+
+
 ifeq ($(RV_TARGET_FFMPEG_DISABLE_ENCODERS),y)
 FFMPEG_CONF_OPTS += --disable-encoders
 endif
@@ -277,6 +289,26 @@ FFMPEG_CONF_OPTS += --enable-small
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_SMALL
 
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_ION),y)
+FFMPEG_CONF_OPTS += --extra-cflags="-DCONFIG_ION"
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_ION
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_SDL),y)
+FFMPEG_CONF_OPTS += --enable-sdl
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_SDL
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_VERSION3),y)
+FFMPEG_CONF_OPTS += --enable-version3
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_VERSION3
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_RKMPP),y)
+FFMPEG_CONF_OPTS += --enable-rkmpp
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_RKMPP
+
 ####################### DECODER ################################
 
 ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_FDKAAC),y)
@@ -309,6 +341,30 @@ FFMPEG_CONF_OPTS += --enable-decoder=h264_rkmpp
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_RKMPP
 
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_AC3),y)
+FFMPEG_CONF_OPTS += --enable-decoder=ac3
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_AC3
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_MPEG4),y)
+FFMPEG_CONF_OPTS += --enable-decoder=mpeg4
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_MPEG4
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_H264),y)
+FFMPEG_CONF_OPTS += --enable-decoder=h264
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_H264
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_ASS),y)
+FFMPEG_CONF_OPTS += --enable-decoder=ass
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_ASS
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DECODER_VORBIS),y)
+FFMPEG_CONF_OPTS += --enable-decoder=vorbis
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DECODER_VORBIS
 
 ##################### ENCODER #######################
 
@@ -462,6 +518,26 @@ FFMPEG_CONF_OPTS += --enable-demuxer=wav
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_WAV
 
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_AC3),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=ac3
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_AC3
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPEGVIDEO),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=mpegvideo
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MPEGVIDEO
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_MATROSKA),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=matroska
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_MATROSKA
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_DEMUXER_ASS),y)
+FFMPEG_CONF_OPTS += --enable-demuxer=ass
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_DEMUXER_ASS
+
 ############# PARSER #######################
 
 ifeq ($(RV_TARGET_FFMPEG_ENABLE_PARSER_H264),y)
@@ -469,6 +545,14 @@ FFMPEG_CONF_OPTS += --enable-parser=h264
 endif
 FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_PARSER_H264
 
+############# FILTER #######################
+
+ifeq ($(RV_TARGET_FFMPEG_ENABLE_FILTER_ARESAMPLE),y)
+FFMPEG_CONF_OPTS += --enable-filter=aresample
+endif
+FFMPEG_CONFIGURE_DEP_CONFIGS += RV_TARGET_FFMPEG_ENABLE_FILTER_ARESAMPLE
+
+
 FFMPEG_CONF_OPTS += --extra-cflags="$(FFMPEG_EXTRA_CFLAGS)"
 
 $(eval $(rv-generic-configure))

From e407570f71f801843ab0b39489d775da1f41a034 Mon Sep 17 00:00:00 2001
From: Francis Fan <francis.fan@rock-chips.com>
Date: Tue, 30 Jul 2019 08:10:17 +0000
Subject: [PATCH 12/13] rv1108: disable avfilter as defalut config

Change-Id: I734d89def877b6afb2fe5a43b930cad2197842a2
Signed-off-by: Francis Fan <francis.fan@rock-chips.com>
---
 Config.in | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/Config.in b/Config.in
index 8d07a08b756..b5e9ce77bb3 100644
--- a/Config.in
+++ b/Config.in
@@ -120,7 +120,7 @@ config RV_TARGET_FFMPEG_DISABLE_AVDEVICES
 
 config RV_TARGET_FFMPEG_DISABLE_AVFILTERS
 	bool "Disable all avfilters"
-	default n
+	default y
 
 config RV_TARGET_FFMPEG_DISABLE_SWSCALE
 	bool "Disable swscale"

From 7964b6e2afe273b4d4540446db2abea40601e12c Mon Sep 17 00:00:00 2001
From: Hertz Wang <wangh@rock-chips.com>
Date: Thu, 8 Aug 2019 01:27:57 +0000
Subject: [PATCH 13/13] add support DRM_FORMAT_NV12_10 in hwcontext_drm.c

Change-Id: Ic40eb163b672fa3b2686ff481f93d010da38a32b
Signed-off-by: Hertz Wang <wangh@rock-chips.com>
---
 libavcodec/rkmppdec.c     |  2 +-
 libavutil/hwcontext_drm.c | 30 ++++++++++++++++++++----------
 libavutil/hwcontext_drm.h |  4 ++++
 3 files changed, 25 insertions(+), 11 deletions(-)

diff --git a/libavcodec/rkmppdec.c b/libavcodec/rkmppdec.c
index e346b203149..093602a16bb 100644
--- a/libavcodec/rkmppdec.c
+++ b/libavcodec/rkmppdec.c
@@ -365,7 +365,7 @@ static int rkmpp_retrieve_frame(AVCodecContext *avctx, AVFrame *frame)
 
             hwframes = (AVHWFramesContext*)decoder->frames_ref->data;
             hwframes->format    = AV_PIX_FMT_DRM_PRIME;
-            hwframes->sw_format = drmformat == DRM_FORMAT_NV12 ? AV_PIX_FMT_NV12 : AV_PIX_FMT_NONE;
+            hwframes->sw_format = av_drm_get_pixfmt(drmformat);
             hwframes->width     = avctx->width;
             hwframes->height    = avctx->height;
             ret = av_hwframe_ctx_init(decoder->frames_ref);
diff --git a/libavutil/hwcontext_drm.c b/libavutil/hwcontext_drm.c
index 29cfaff477d..77b40598952 100644
--- a/libavutil/hwcontext_drm.c
+++ b/libavutil/hwcontext_drm.c
@@ -28,7 +28,6 @@
 #include "hwcontext.h"
 #include "hwcontext_drm.h"
 #include "hwcontext_internal.h"
-#include "imgutils.h"
 
 /**
  * Copy from libdrm_macros.h while is not exposed by libdrm,
@@ -91,6 +90,18 @@ static const struct {
     enum AVPixelFormat pixfmt;
     uint32_t drm_format;
 } supported_formats[] = {
+    { AV_PIX_FMT_NV12,      DRM_FORMAT_NV12,        },
+#ifdef DRM_FORMAT_NV12_10
+    { AV_PIX_FMT_P010LE,    DRM_FORMAT_NV12_10,     },
+    { AV_PIX_FMT_P010BE,    DRM_FORMAT_NV12_10  | DRM_FORMAT_BIG_ENDIAN },
+#endif
+    { AV_PIX_FMT_NV21,      DRM_FORMAT_NV21,        },
+    { AV_PIX_FMT_YUV420P,   DRM_FORMAT_YUV420,      },
+    { AV_PIX_FMT_YUYV422,   DRM_FORMAT_YUYV,        },
+    { AV_PIX_FMT_YVYU422,   DRM_FORMAT_YVYU,        },
+    { AV_PIX_FMT_UYVY422,   DRM_FORMAT_UYVY,        },
+    { AV_PIX_FMT_NV16,      DRM_FORMAT_NV16,        },
+    { AV_PIX_FMT_YUV422P,   DRM_FORMAT_YUV422,      },
 #ifdef DRM_FORMAT_R16
     { AV_PIX_FMT_GRAY16LE,  DRM_FORMAT_R16,         },
     { AV_PIX_FMT_GRAY16BE,  DRM_FORMAT_R16      | DRM_FORMAT_BIG_ENDIAN },
@@ -114,17 +125,16 @@ static const struct {
     { AV_PIX_FMT_ABGR,      DRM_FORMAT_RGBA8888,    },
     { AV_PIX_FMT_RGBA,      DRM_FORMAT_ABGR8888,    },
     { AV_PIX_FMT_BGRA,      DRM_FORMAT_ARGB8888,    },
-    { AV_PIX_FMT_YUYV422,   DRM_FORMAT_YUYV,        },
-    { AV_PIX_FMT_YVYU422,   DRM_FORMAT_YVYU,        },
-    { AV_PIX_FMT_UYVY422,   DRM_FORMAT_UYVY,        },
-    { AV_PIX_FMT_NV16,      DRM_FORMAT_NV16,        },
-    { AV_PIX_FMT_YUV422P,   DRM_FORMAT_YUV422,      },
-    { AV_PIX_FMT_NV21,      DRM_FORMAT_NV21,        },
-    { AV_PIX_FMT_NV12,      DRM_FORMAT_NV12,        },
-    { AV_PIX_FMT_P010,      DRM_FORMAT_NV12_10,     },
-    { AV_PIX_FMT_YUV420P,   DRM_FORMAT_YUV420,      },
 };
 
+enum AVPixelFormat av_drm_get_pixfmt(uint32_t drm_format) {
+    for (int i = 0; i < FF_ARRAY_ELEMS(supported_formats); i++) {
+        if (supported_formats[i].drm_format == drm_format)
+            return supported_formats[i].pixfmt;
+    }
+    return AV_PIX_FMT_NONE;
+}
+
 static void drm_device_free(AVHWDeviceContext *hwdev)
 {
     AVDRMDeviceContext *hwctx = hwdev->hwctx;
diff --git a/libavutil/hwcontext_drm.h b/libavutil/hwcontext_drm.h
index fe64f97078c..1bc642b8155 100644
--- a/libavutil/hwcontext_drm.h
+++ b/libavutil/hwcontext_drm.h
@@ -22,6 +22,8 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#include "imgutils.h"
+
 /**
  * @file
  * API-specific header for AV_HWDEVICE_TYPE_DRM.
@@ -172,4 +174,6 @@ typedef struct AVDRMDeviceContext {
     int fd;
 } AVDRMDeviceContext;
 
+enum AVPixelFormat av_drm_get_pixfmt(uint32_t drm_format);
+
 #endif /* AVUTIL_HWCONTEXT_DRM_H */
