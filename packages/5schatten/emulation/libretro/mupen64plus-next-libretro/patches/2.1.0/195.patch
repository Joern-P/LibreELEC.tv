From 2171d0866885ad820fdf1da96073e5025f648c89 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Thu, 30 Apr 2020 11:36:06 +0200
Subject: [PATCH 01/28] git subrepo clone --force --branch=rebase
 https://github.com/libretro/mupen64plus-core.git mupen64plus-core

subrepo:
  subdir:   "mupen64plus-core"
  merged:   "62dbd200"
upstream:
  origin:   "https://github.com/libretro/mupen64plus-core.git"
  branch:   "rebase"
  commit:   "62dbd200"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 mupen64plus-core/.gitattributes               |    1 +
 mupen64plus-core/.gitrepo                     |    6 +-
 mupen64plus-core/appveyor.yml                 |    4 +-
 mupen64plus-core/data/mupen64plus.ini         |   12 +-
 .../projects/msvc/mupen64plus-core.vcxproj    |   51 +-
 .../msvc/mupen64plus-core.vcxproj.filters     |    5 +-
 mupen64plus-core/projects/unix/Makefile       |    3 -
 mupen64plus-core/src/api/config.c             |   24 +-
 mupen64plus-core/src/device/cart/cart.c       |    4 +-
 mupen64plus-core/src/device/cart/cart.h       |    2 +
 mupen64plus-core/src/device/cart/cart_rom.c   |   18 +-
 mupen64plus-core/src/device/cart/cart_rom.h   |    6 +-
 .../src/device/dd/dd_controller.c             |   10 +-
 mupen64plus-core/src/device/device.c          |    1 +
 .../src/device/r4300/cached_interp.c          |   11 -
 .../src/device/r4300/cached_interp.h          |   11 +
 mupen64plus-core/src/device/r4300/idec.h      |    2 +-
 mupen64plus-core/src/device/r4300/interrupt.c |   34 +
 .../src/device/r4300/mips_instructions.def    |   62 +-
 .../src/device/r4300/pure_interp.c            |   28 +-
 mupen64plus-core/src/device/r4300/recomp.c    |   22 +-
 .../src/device/r4300/recomp_types.h           |    2 +-
 .../src/device/r4300/x86/dynarec.c            |   57 +-
 .../src/device/r4300/x86_64/dynarec.c         |   57 +-
 .../src/device/rcp/pi/pi_controller.c         |   29 +-
 .../src/device/rcp/pi/pi_controller.h         |   13 +
 mupen64plus-core/src/device/rcp/rdp/fb.c      |   10 +
 .../src/device/rcp/rdp/rdp_core.c             |    2 +
 mupen64plus-core/src/main/savestates.c        |    8 +-
 mupen64plus-core/src/main/workqueue.h         |    1 -
 mupen64plus-core/subprojects/xxhash/xxh3.h    | 1579 ++++++++++-----
 mupen64plus-core/subprojects/xxhash/xxhash.c  | 1110 ----------
 mupen64plus-core/subprojects/xxhash/xxhash.h  | 1796 +++++++++++++++--
 mupen64plus-core/tools/gen_asm_script.cmd     |   42 +
 34 files changed, 3011 insertions(+), 2012 deletions(-)
 delete mode 100644 mupen64plus-core/subprojects/xxhash/xxhash.c
 create mode 100644 mupen64plus-core/tools/gen_asm_script.cmd

diff --git a/mupen64plus-core/.gitattributes b/mupen64plus-core/.gitattributes
index f0537714..c5000eb8 100644
--- a/mupen64plus-core/.gitattributes
+++ b/mupen64plus-core/.gitattributes
@@ -26,6 +26,7 @@ RELEASE text
 *.ver text
 
 # windows specific text files
+*.cmd text eol=crlf
 *.sln text eol=crlf
 *.vcproj text eol=crlf
 *.vcxproj text eol=crlf
diff --git a/mupen64plus-core/.gitrepo b/mupen64plus-core/.gitrepo
index 1b7327ef..0e1ad4dc 100644
--- a/mupen64plus-core/.gitrepo
+++ b/mupen64plus-core/.gitrepo
@@ -5,8 +5,8 @@
 ;
 [subrepo]
 	remote = https://github.com/libretro/mupen64plus-core.git
-	branch = master
-	commit = e9939d26c3494ebb98f4eb81fbb704b7b4a80b39
-	parent = 81a58df0263c90b10b7fc11b6deee04d47e3aa40
+	branch = rebase
+	commit = 62dbd20030039bbf1aad36860df20ac54bfcfe27
+	parent = 083235485f6cab948f80e0d9cc1263a0562b0399
 	method = rebase
 	cmdver = 0.4.0
diff --git a/mupen64plus-core/appveyor.yml b/mupen64plus-core/appveyor.yml
index 1a62c0fa..3c6530e2 100644
--- a/mupen64plus-core/appveyor.yml
+++ b/mupen64plus-core/appveyor.yml
@@ -11,7 +11,7 @@ before_build:
   - git clone --depth 1 https://github.com/mupen64plus/mupen64plus-win32-deps.git ..\mupen64plus-win32-deps
 
 build_script:
-  - msbuild projects/msvc/mupen64plus-core.vcxproj /p:Configuration=%configuration%;Platform=%platform%
+  - msbuild projects\msvc\mupen64plus-core.vcxproj /p:Configuration=%configuration%;Platform=%platform%
 
 after_build:
   - ps: $env:rev1 = git describe --tags
@@ -21,7 +21,7 @@ after_build:
   - if "%rev3%" NEQ "Release" set rev3=NewDynarec
   - set filepkg=mupen64plus-core_v%rev1%_%rev2%-%rev3%
   - cd projects\msvc\%platform%\%configuration%
-  - 7z a -t7z ..\..\..\..\build\%filepkg%.7z mupen64plus.dll
+  - 7z a -t7z ..\..\..\..\build\%filepkg%.7z *.dll
 
 artifacts:
   - path: build\$(filepkg).7z
diff --git a/mupen64plus-core/data/mupen64plus.ini b/mupen64plus-core/data/mupen64plus.ini
index 75aabc11..c7518b04 100644
--- a/mupen64plus-core/data/mupen64plus.ini
+++ b/mupen64plus-core/data/mupen64plus.ini
@@ -1443,6 +1443,7 @@ RefMD5=A5EE8A6C34863E3D0EB8C06AE8668B30
 [3406A505C22BAC2F40D9BFC6FF08CF86]
 GoodName=BattleTanx (U) [!]
 CRC=6AA4DDE7 E3E2F4E7
+CountPerOp=3
 SaveType=None
 Mempak=Yes
 Players=4
@@ -1480,7 +1481,7 @@ Rumble=Yes
 [654557C316F901A2CA6F7F4B43343147]
 GoodName=BattleTanx - Global Assault (U) [!]
 CRC=75A4E247 6008963D
-CountPerOp=1
+CountPerOp=3
 Players=4
 SaveType=None
 Mempak=Yes
@@ -14619,6 +14620,7 @@ CRC=EAE6ACE2 020B4384
 Players=1
 SaveType=Eeprom 4KB
 Rumble=Yes
+CountPerOp=1
 
 [3CB88B934572E7520F35E5458798775B]
 GoodName=Star Wars Episode I - Battle for Naboo (U) [!]
@@ -14626,6 +14628,7 @@ CRC=3D02989B D4A381E2
 Players=1
 SaveType=Eeprom 4KB
 Rumble=Yes
+CountPerOp=1
 
 [B4724120C269A1DC86991D34B1561F3D]
 GoodName=Star Wars Episode I - Battle for Naboo (U) [b1]
@@ -15672,6 +15675,7 @@ Players=2
 SaveType=None
 Mempak=Yes
 Rumble=Yes
+CountPerOp=1
 
 [0072538EF925645DB310F8E23A480B89]
 GoodName=Top Gear Hyper Bike (E) [!]
@@ -15680,6 +15684,7 @@ Players=2
 SaveType=None
 Mempak=Yes
 Rumble=Yes
+CountPerOp=1
 
 [561B438F6E8240BEF1DAEB36AAE72675]
 GoodName=Top Gear Hyper Bike (E) [b1]
@@ -15693,6 +15698,7 @@ Players=2
 SaveType=None
 Mempak=Yes
 Rumble=Yes
+CountPerOp=1
 
 [7258F4AB367B025C95A4F476C461E717]
 GoodName=Top Gear Hyper Bike (U) [!]
@@ -15701,6 +15707,7 @@ Players=2
 SaveType=None
 Mempak=Yes
 Rumble=Yes
+CountPerOp=1
 
 [6C65A252F227AEF18DF2DD3CE04CC821]
 GoodName=Top Gear Overdrive (E) [!]
@@ -15708,6 +15715,7 @@ CRC=D09BA538 1C1A5489
 Players=4
 SaveType=Eeprom 4KB
 Rumble=Yes
+CountPerOp=1
 
 [11D6FFF288DE1BD61CCBD7CCA0C4A97B]
 GoodName=Top Gear Overdrive (E) [h1C]
@@ -15720,6 +15728,7 @@ CRC=0578F24F 9175BF17
 Players=4
 SaveType=Eeprom 4KB
 Rumble=Yes
+CountPerOp=1
 
 [8C0F46FEF9A6034FCF0B7D6952FFEC53]
 GoodName=Top Gear Overdrive (J) [b1]
@@ -15732,6 +15741,7 @@ CRC=D741CD80 ACA9B912
 Players=4
 SaveType=Eeprom 4KB
 Rumble=Yes
+CountPerOp=1
 
 [773FD446DA7F4E392907505053BF2A42]
 GoodName=Top Gear Overdrive (U) [o1]
diff --git a/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj b/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj
index c4cf0055..ec304915 100644
--- a/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj
+++ b/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj
@@ -371,7 +371,6 @@
     <ClCompile Include="..\..\subprojects\minizip\unzip.c" />
     <ClCompile Include="..\..\subprojects\minizip\zip.c" />
     <ClCompile Include="..\..\subprojects\oglft\OGLFT.cpp" />
-    <ClCompile Include="..\..\subprojects\xxhash\xxhash.c" />
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\api\callbacks.h" />
@@ -677,13 +676,13 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|x64'">false</ExcludedFromBuild>
       <FileType>Document</FileType>
-      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|x64'">$(IntDir)linkage_x64.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|x64'">$(IntDir)linkage_x64.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='ARM64_New_Dynarec_Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='ARM64_New_Dynarec_Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='ARM64_New_Dynarec_Debug|x64'">$(IntDir)linkage_x64.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='x64_New_Dynarec_Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='x64_New_Dynarec_Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x64.obj -f win64 -d WIN64 "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='x64_New_Dynarec_Debug|x64'">$(IntDir)linkage_x64.obj</Outputs>
     </CustomBuild>
     <None Include="..\..\src\device\r4300\new_dynarec\arm64\linkage_arm64.S">
@@ -729,13 +728,13 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|Win32'">false</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|x64'">true</ExcludedFromBuild>
       <FileType>Document</FileType>
-      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|Win32'">$(IntDir)linkage_x86.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|Win32'">$(IntDir)linkage_x86.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='ARM_New_Dynarec_Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='ARM_New_Dynarec_Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='ARM_New_Dynarec_Debug|Win32'">$(IntDir)linkage_x86.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='x86_New_Dynarec_Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='x86_New_Dynarec_Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)linkage_x86.obj -f win32 -d LEADING_UNDERSCORE "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='x86_New_Dynarec_Debug|Win32'">$(IntDir)linkage_x86.obj</Outputs>
     </CustomBuild>
     <CustomBuild Include="..\..\src\device\r4300\x86_64\dyna_start.asm">
@@ -752,9 +751,9 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='ARM_New_Dynarec_Debug|Win32'">true</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">true</ExcludedFromBuild>
       <FileType>Document</FileType>
-      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win64 -d WIN64 %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win64 -d WIN64 "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)dyna_start.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win64 -d WIN64 %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x64\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win64 -d WIN64 "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)dyna_start.obj</Outputs>
     </CustomBuild>
     <CustomBuild Include="..\..\src\device\r4300\x86\dyna_start.asm">
@@ -771,9 +770,9 @@
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">false</ExcludedFromBuild>
       <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
       <FileType>Document</FileType>
-      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win32 -d LEADING_UNDERSCORE %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win32 -d LEADING_UNDERSCORE "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">$(IntDir)dyna_start.obj</Outputs>
-      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win32 -d LEADING_UNDERSCORE %(FullPath)</Command>
+      <Command Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">"..\..\..\mupen64plus-win32-deps\nasm-2.14.02\x86\nasm.exe" -i ..\..\src\ -i ..\..\src\asm_defines\ -o $(IntDir)dyna_start.obj -f win32 -d LEADING_UNDERSCORE "%(FullPath)"</Command>
       <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">$(IntDir)dyna_start.obj</Outputs>
     </CustomBuild>
   </ItemGroup>
@@ -943,7 +942,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir)</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
@@ -961,7 +960,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "__x86_64__" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "__x86_64__"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|Win32'">
@@ -979,7 +978,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "NEW_DYNAREC=1" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "NEW_DYNAREC=1"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='x86_New_Dynarec_Debug|Win32'">
@@ -997,7 +996,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "NEW_DYNAREC=1" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "NEW_DYNAREC=1"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ARM_New_Dynarec_Debug|Win32'">
@@ -1015,7 +1014,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "NEW_DYNAREC=1" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "NEW_DYNAREC=1"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Debug|x64'">
@@ -1033,7 +1032,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='ARM64_New_Dynarec_Debug|x64'">
@@ -1051,7 +1050,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='x64_New_Dynarec_Debug|x64'">
@@ -1069,7 +1068,7 @@
       <SubSystem>Windows</SubSystem>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
@@ -1090,7 +1089,7 @@
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir)</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
@@ -1111,7 +1110,7 @@
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "__x86_64__" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "__x86_64__"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|Win32'">
@@ -1132,7 +1131,7 @@
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "NEW_DYNAREC=1" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "NEW_DYNAREC=1"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='New_Dynarec_Release|x64'">
@@ -1153,10 +1152,10 @@
       <EnableCOMDATFolding>true</EnableCOMDATFolding>
     </Link>
     <PreBuildEvent>
-      <Command>del ..\..\src\asm_defines\asm_defines_* &amp; cl /c /Fo$(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2" /I ..\..\src ..\..\src\asm_defines\asm_defines.c &amp; "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk $(IntDir)asm_defines.obj</Command>
+      <Command>..\..\tools\gen_asm_script.cmd $(IntDir) /D "__x86_64__" /D "NEW_DYNAREC=2"</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
-</Project>
+</Project>
\ No newline at end of file
diff --git a/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj.filters b/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj.filters
index 38dcc5a7..04e2a4ac 100644
--- a/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj.filters
+++ b/mupen64plus-core/projects/msvc/mupen64plus-core.vcxproj.filters
@@ -393,9 +393,6 @@
     <ClCompile Include="..\..\subprojects\oglft\OGLFT.cpp">
       <Filter>subprojects\oglft</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\subprojects\xxhash\xxhash.c">
-      <Filter>subprojects\xxhash</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\subprojects\minizip\ioapi.c">
       <Filter>subprojects\minizip</Filter>
     </ClCompile>
@@ -781,4 +778,4 @@
       <Filter>device\r4300\new_dynarec\x64</Filter>
     </CustomBuild>
   </ItemGroup>
-</Project>
\ No newline at end of file
+</Project>
diff --git a/mupen64plus-core/projects/unix/Makefile b/mupen64plus-core/projects/unix/Makefile
index 6fa33662..2c53f1b4 100755
--- a/mupen64plus-core/projects/unix/Makefile
+++ b/mupen64plus-core/projects/unix/Makefile
@@ -121,7 +121,6 @@ ifneq ("$(filter arm%,$(HOST_CPU))","")
         CFLAGS += -mfpu=vfp -mfloat-abi=softfp
       endif
     endif
-    $(warning Architecture "$(HOST_CPU)" not officially supported.)
   endif
 endif
 ifneq ("$(filter mips,$(HOST_CPU))","")
@@ -555,8 +554,6 @@ CFLAGS += -I$(SUBDIR)/md5
 
 
 # xxhash
-SOURCE += \
-    $(SUBDIR)/xxhash/xxhash.c
 CFLAGS += -I$(SUBDIR)/xxhash
 
 
diff --git a/mupen64plus-core/src/api/config.c b/mupen64plus-core/src/api/config.c
index ef16fc66..c169e5a1 100644
--- a/mupen64plus-core/src/api/config.c
+++ b/mupen64plus-core/src/api/config.c
@@ -1242,10 +1242,14 @@ EXPORT m64p_error CALL ConfigSetDefaultInt(m64p_handle ConfigSectionHandle, cons
     if (section->magic != SECTION_MAGIC)
         return M64ERR_INPUT_INVALID;
 
-    /* if this parameter already exists, then just return successfully */
+    /* if this parameter already exists, add help text if missing, then return successfully */
     var = find_section_var(section, ParamName);
     if (var != NULL)
+    {
+        if (ParamHelp != NULL && var->comment == NULL)
+            var->comment = strdup(ParamHelp);
         return M64ERR_SUCCESS;
+    }
 
     /* otherwise create a new config_var object and add it to this section */
     var = config_var_create(ParamName, ParamHelp);
@@ -1273,10 +1277,14 @@ EXPORT m64p_error CALL ConfigSetDefaultFloat(m64p_handle ConfigSectionHandle, co
     if (section->magic != SECTION_MAGIC)
         return M64ERR_INPUT_INVALID;
 
-    /* if this parameter already exists, then just return successfully */
+    /* if this parameter already exists, add help text if missing, then return successfully */
     var = find_section_var(section, ParamName);
     if (var != NULL)
+    {
+        if (ParamHelp != NULL && var->comment == NULL)
+            var->comment = strdup(ParamHelp);
         return M64ERR_SUCCESS;
+    }
 
     /* otherwise create a new config_var object and add it to this section */
     var = config_var_create(ParamName, ParamHelp);
@@ -1304,10 +1312,14 @@ EXPORT m64p_error CALL ConfigSetDefaultBool(m64p_handle ConfigSectionHandle, con
     if (section->magic != SECTION_MAGIC)
         return M64ERR_INPUT_INVALID;
 
-    /* if this parameter already exists, then just return successfully */
+    /* if this parameter already exists, add help text if missing, then return successfully */
     var = find_section_var(section, ParamName);
     if (var != NULL)
+    {
+        if (ParamHelp != NULL && var->comment == NULL)
+            var->comment = strdup(ParamHelp);
         return M64ERR_SUCCESS;
+    }
 
     /* otherwise create a new config_var object and add it to this section */
     var = config_var_create(ParamName, ParamHelp);
@@ -1335,10 +1347,14 @@ EXPORT m64p_error CALL ConfigSetDefaultString(m64p_handle ConfigSectionHandle, c
     if (section->magic != SECTION_MAGIC)
         return M64ERR_INPUT_INVALID;
 
-    /* if this parameter already exists, then just return successfully */
+    /* if this parameter already exists, add help text if missing, then return successfully */
     var = find_section_var(section, ParamName);
     if (var != NULL)
+    {
+        if (ParamHelp != NULL && var->comment == NULL)
+            var->comment = strdup(ParamHelp);
         return M64ERR_SUCCESS;
+    }
 
     /* otherwise create a new config_var object and add it to this section */
     var = config_var_create(ParamName, ParamHelp);
diff --git a/mupen64plus-core/src/device/cart/cart.c b/mupen64plus-core/src/device/cart/cart.c
index 5315ff0c..0b3321e7 100644
--- a/mupen64plus-core/src/device/cart/cart.c
+++ b/mupen64plus-core/src/device/cart/cart.c
@@ -100,6 +100,7 @@ void init_cart(struct cart* cart,
                /* cart ROM */
                uint8_t* rom, size_t rom_size,
                struct r4300_core* r4300,
+               struct pi_controller* pi,
                /* eeprom */
                uint16_t eeprom_type,
                void* eeprom_storage, const struct storage_backend_interface* ieeprom_storage,
@@ -115,7 +116,8 @@ void init_cart(struct cart* cart,
 
     init_cart_rom(&cart->cart_rom,
         rom, rom_size,
-        r4300);
+        r4300,
+        pi);
 
     init_eeprom(&cart->eeprom,
         eeprom_type, eeprom_storage, ieeprom_storage);
diff --git a/mupen64plus-core/src/device/cart/cart.h b/mupen64plus-core/src/device/cart/cart.h
index cf02b68c..3ccf3cee 100644
--- a/mupen64plus-core/src/device/cart/cart.h
+++ b/mupen64plus-core/src/device/cart/cart.h
@@ -34,6 +34,7 @@
 #include <stdint.h>
 
 struct r4300_core;
+struct pi_controller;
 struct clock_backend_interface;
 struct storage_backend_interface;
 
@@ -55,6 +56,7 @@ void init_cart(struct cart* cart,
                /* cart ROM */
                uint8_t* rom, size_t rom_size,
                struct r4300_core* r4300,
+               struct pi_controller* pi,
                /* eeprom */
                uint16_t eeprom_type,
                void* eeprom_storage, const struct storage_backend_interface* ieeprom_storage,
diff --git a/mupen64plus-core/src/device/cart/cart_rom.c b/mupen64plus-core/src/device/cart/cart_rom.c
index ffdb66aa..86657df1 100644
--- a/mupen64plus-core/src/device/cart/cart_rom.c
+++ b/mupen64plus-core/src/device/cart/cart_rom.c
@@ -27,6 +27,7 @@
 
 #include "device/memory/memory.h"
 #include "device/r4300/r4300_core.h"
+#include "device/rcp/pi/pi_controller.h"
 
 #define __STDC_FORMAT_MACROS
 #include <inttypes.h>
@@ -36,18 +37,19 @@
 
 void init_cart_rom(struct cart_rom* cart_rom,
                    uint8_t* rom, size_t rom_size,
-                   struct r4300_core* r4300)
+                   struct r4300_core* r4300,
+                   struct pi_controller* pi)
 {
     cart_rom->rom = rom;
     cart_rom->rom_size = rom_size;
 
     cart_rom->r4300 = r4300;
+    cart_rom->pi = pi;
 }
 
 void poweron_cart_rom(struct cart_rom* cart_rom)
 {
     cart_rom->last_write = 0;
-    cart_rom->rom_written = 0;
 }
 
 
@@ -56,10 +58,9 @@ void read_cart_rom(void* opaque, uint32_t address, uint32_t* value)
     struct cart_rom* cart_rom = (struct cart_rom*)opaque;
     uint32_t addr = rom_address(address);
 
-    if (cart_rom->rom_written)
+    if (cart_rom->pi->regs[PI_STATUS_REG] & PI_STATUS_IO_BUSY)
     {
         *value = cart_rom->last_write;
-        cart_rom->rom_written = 0;
     }
     else
     {
@@ -71,7 +72,14 @@ void write_cart_rom(void* opaque, uint32_t address, uint32_t value, uint32_t mas
 {
     struct cart_rom* cart_rom = (struct cart_rom*)opaque;
     cart_rom->last_write = value & mask;
-    cart_rom->rom_written = 1;
+
+    if (!validate_pi_request(cart_rom->pi))
+        return;
+
+    /* Mark IO as busy */
+    cart_rom->pi->regs[PI_STATUS_REG] |= PI_STATUS_IO_BUSY;
+    cp0_update_count(cart_rom->r4300);
+    add_interrupt_event(&cart_rom->r4300->cp0, PI_INT, 0x1000);
 }
 
 unsigned int cart_rom_dma_read(void* opaque, const uint8_t* dram, uint32_t dram_addr, uint32_t cart_addr, uint32_t length)
diff --git a/mupen64plus-core/src/device/cart/cart_rom.h b/mupen64plus-core/src/device/cart/cart_rom.h
index 6b0396f8..2bba5a30 100644
--- a/mupen64plus-core/src/device/cart/cart_rom.h
+++ b/mupen64plus-core/src/device/cart/cart_rom.h
@@ -28,6 +28,7 @@
 #include "osal/preproc.h"
 
 struct r4300_core;
+struct pi_controller;
 
 struct cart_rom
 {
@@ -35,9 +36,9 @@ struct cart_rom
     size_t rom_size;
 
     uint32_t last_write;
-    uint32_t rom_written;
 
     struct r4300_core* r4300;
+    struct pi_controller* pi;
 };
 
 static osal_inline uint32_t rom_address(uint32_t address)
@@ -47,7 +48,8 @@ static osal_inline uint32_t rom_address(uint32_t address)
 
 void init_cart_rom(struct cart_rom* cart_rom,
                    uint8_t* rom, size_t rom_size,
-                   struct r4300_core* r4300);
+                   struct r4300_core* r4300,
+                   struct pi_controller* pi);
 
 void poweron_cart_rom(struct cart_rom* cart_rom);
 
diff --git a/mupen64plus-core/src/device/dd/dd_controller.c b/mupen64plus-core/src/device/dd/dd_controller.c
index b1623724..b940b441 100644
--- a/mupen64plus-core/src/device/dd/dd_controller.c
+++ b/mupen64plus-core/src/device/dd/dd_controller.c
@@ -623,14 +623,14 @@ unsigned int dd_dom_dma_read(void* opaque, const uint8_t* dram, uint32_t dram_ad
     else {
         DebugMessage(M64MSG_ERROR, "Unknown DD dma read dram=%08x  cart=%08x length=%08x",
             dram_addr, cart_addr, length);
-        return (length * 63) / 25;
+        return (length * 63) / 50;
     }
 
     for (i = 0; i < length; ++i) {
         mem[(cart_addr + i) ^ S8] = dram[(dram_addr + i) ^ S8];
     }
 
-    return (length * 63) / 25;
+    return (length * 63) / 50;
 }
 
 unsigned int dd_dom_dma_write(void* opaque, uint8_t* dram, uint32_t dram_addr, uint32_t cart_addr, uint32_t length)
@@ -658,16 +658,16 @@ unsigned int dd_dom_dma_write(void* opaque, uint8_t* dram, uint32_t dram_addr, u
             DebugMessage(M64MSG_ERROR, "Unknown DD dma write dram=%08x  cart=%08x length=%08x",
                 dram_addr, cart_addr, length);
 
-            return (length * 63) / 25;
+            return (length * 63) / 50;
         }
 
-        cycles = (length * 63) / 25;
+        cycles = (length * 63) / 50;
     }
     else {
         /* DD ROM */
         cart_addr = (cart_addr - MM_DD_ROM);
         mem = (const uint8_t*)dd->rom;
-        cycles = (length * 63) / 25;
+        cycles = (length * 63) / 50;
     }
 
     for (i = 0; i < length; ++i) {
diff --git a/mupen64plus-core/src/device/device.c b/mupen64plus-core/src/device/device.c
index a6c3c70b..5fd3fd41 100644
--- a/mupen64plus-core/src/device/device.c
+++ b/mupen64plus-core/src/device/device.c
@@ -207,6 +207,7 @@ void init_device(struct device* dev,
             af_rtc_clock, iaf_rtc_clock,
             (uint8_t*)mem_base_u32(base, MM_CART_ROM), rom_size,
             &dev->r4300,
+            &dev->pi,
             eeprom_type, eeprom_storage, ieeprom_storage,
             flashram_type, flashram_storage, iflashram_storage,
             (const uint8_t*)dev->rdram.dram,
diff --git a/mupen64plus-core/src/device/r4300/cached_interp.c b/mupen64plus-core/src/device/r4300/cached_interp.c
index 3137e39a..9c685eb7 100644
--- a/mupen64plus-core/src/device/r4300/cached_interp.c
+++ b/mupen64plus-core/src/device/r4300/cached_interp.c
@@ -297,17 +297,6 @@ void cached_interp_NOTCOMPILED2(void)
 #define cached_interp_SCD         cached_interp_NI
 #define cached_interp_SDC2        cached_interp_NI
 #define cached_interp_SWC2        cached_interp_NI
-#define cached_interp_TEQI        cached_interp_NI
-#define cached_interp_TGE         cached_interp_NI
-#define cached_interp_TGEI        cached_interp_NI
-#define cached_interp_TGEIU       cached_interp_NI
-#define cached_interp_TGEU        cached_interp_NI
-#define cached_interp_TLT         cached_interp_NI
-#define cached_interp_TLTI        cached_interp_NI
-#define cached_interp_TLTIU       cached_interp_NI
-#define cached_interp_TLTU        cached_interp_NI
-#define cached_interp_TNE         cached_interp_NI
-#define cached_interp_TNEI        cached_interp_NI
 #define cached_interp_JR_IDLE     cached_interp_NI
 #define cached_interp_JALR_IDLE   cached_interp_NI
 #define cached_interp_CP1_ABS     cached_interp_RESERVED
diff --git a/mupen64plus-core/src/device/r4300/cached_interp.h b/mupen64plus-core/src/device/r4300/cached_interp.h
index b2f2f9cc..21a55f12 100644
--- a/mupen64plus-core/src/device/r4300/cached_interp.h
+++ b/mupen64plus-core/src/device/r4300/cached_interp.h
@@ -205,7 +205,18 @@ void cached_interp_CACHE(void);
 void cached_interp_ERET(void);
 void cached_interp_SYNC(void);
 void cached_interp_SYSCALL(void);
+void cached_interp_TGE(void);
+void cached_interp_TGEU(void);
+void cached_interp_TGEI(void);
+void cached_interp_TGEIU(void);
+void cached_interp_TLT(void);
+void cached_interp_TLTU(void);
+void cached_interp_TLTI(void);
+void cached_interp_TLTIU(void);
 void cached_interp_TEQ(void);
+void cached_interp_TEQI(void);
+void cached_interp_TNE(void);
+void cached_interp_TNEI(void);
 void cached_interp_TLBP(void);
 void cached_interp_TLBR(void);
 void cached_interp_TLBWR(void);
diff --git a/mupen64plus-core/src/device/r4300/idec.h b/mupen64plus-core/src/device/r4300/idec.h
index 60a6b006..ddbded5e 100644
--- a/mupen64plus-core/src/device/r4300/idec.h
+++ b/mupen64plus-core/src/device/r4300/idec.h
@@ -82,6 +82,6 @@ size_t idec_u53(uint32_t iw, uint8_t u53, uint8_t* u5);
 
 #define IDEC_U53(r4300, iw, u53, u5) (void*)(((char*)(r4300)) + idec_u53((iw), (u53), (u5)))
 
-const char* g_r4300_opcodes[R4300_OPCODES_COUNT];
+extern const char* g_r4300_opcodes[R4300_OPCODES_COUNT];
 
 #endif
diff --git a/mupen64plus-core/src/device/r4300/interrupt.c b/mupen64plus-core/src/device/r4300/interrupt.c
index af9f8246..b99aa534 100644
--- a/mupen64plus-core/src/device/r4300/interrupt.c
+++ b/mupen64plus-core/src/device/r4300/interrupt.c
@@ -479,6 +479,20 @@ void reset_hard_handler(void* opaque)
     struct device* dev = (struct device*)opaque;
     struct r4300_core* r4300 = &dev->r4300;
 
+#ifndef NEW_DYNAREC
+#if defined(__x86_64__)
+    long long save_rsp = r4300->recomp.save_rsp;
+    long long save_rip = r4300->recomp.save_rip;
+#else
+    long save_ebp = r4300->recomp.save_ebp;
+    long save_ebx = r4300->recomp.save_ebx;
+    long save_esi = r4300->recomp.save_esi;
+    long save_edi = r4300->recomp.save_edi;
+    long save_esp = r4300->recomp.save_esp;
+    long save_eip = r4300->recomp.save_eip;
+#endif
+#endif
+
     poweron_device(dev);
 
     pif_bootrom_hle_execute(r4300);
@@ -487,6 +501,26 @@ void reset_hard_handler(void* opaque)
     *r4300_cp0_cycle_count(&r4300->cp0) = 0;
     init_interrupt(&r4300->cp0);
     invalidate_r4300_cached_code(r4300, 0, 0);
+    *r4300_pc_struct(r4300) = &r4300->interp_PC;
+    if (r4300->emumode >= 2)
+    {
+#ifdef NEW_DYNAREC
+        new_dynarec_cleanup();
+        new_dynarec_init();
+#else
+#if defined(__x86_64__)
+        r4300->recomp.save_rsp = save_rsp;
+        r4300->recomp.save_rip = save_rip;
+#else
+        r4300->recomp.save_ebp = save_ebp;
+        r4300->recomp.save_ebx = save_ebx;
+        r4300->recomp.save_esi = save_esi;
+        r4300->recomp.save_edi = save_edi;
+        r4300->recomp.save_esp = save_esp;
+        r4300->recomp.save_eip = save_eip;
+#endif
+#endif
+    }
     generic_jump_to(r4300, r4300->cp0.last_addr);
 }
 
diff --git a/mupen64plus-core/src/device/r4300/mips_instructions.def b/mupen64plus-core/src/device/r4300/mips_instructions.def
index c1299a8c..16e988fc 100644
--- a/mupen64plus-core/src/device/r4300/mips_instructions.def
+++ b/mupen64plus-core/src/device/r4300/mips_instructions.def
@@ -58,7 +58,7 @@
 #include "device/rdram/rdram.h"
 #include "osal/preproc.h"
 
-#include <xxhash.h>
+#include <xxh3.h>
 
 #include <inttypes.h>
 #include <stdint.h>
@@ -999,18 +999,38 @@ DECLARE_INSTRUCTION(SYSCALL)
     exception_general(r4300);
 }
 
-/* Exception instructions */
-
-DECLARE_INSTRUCTION(TEQ)
-{
-    DECLARE_R4300
-    if (rrs == rrt)
-    {
-        DebugMessage(M64MSG_ERROR, "trap exception in TEQ");
-        *r4300_stop(r4300)=1;
-    }
-    ADD_TO_PC(1);
-}
+/* Trap instructions */
+
+#define DECLARE_TRAP(name, cond) \
+DECLARE_INSTRUCTION(name) \
+{ \
+    DECLARE_R4300 \
+    uint32_t* cp0_regs = r4300_cp0_regs(&r4300->cp0); \
+    if (cond) \
+    { \
+        cp0_regs[CP0_CAUSE_REG] = CP0_CAUSE_EXCCODE_TR; \
+        exception_general(r4300); \
+    } \
+    else \
+    { \
+        ADD_TO_PC(1); \
+    } \
+}
+
+DECLARE_TRAP(TGE, rrs >= rrt)
+DECLARE_TRAP(TGEU, (uint64_t) rrs >= (uint64_t) rrt)
+DECLARE_TRAP(TGEI, rrs >= (int64_t)iimmediate)
+DECLARE_TRAP(TGEIU, (uint64_t)rrs >= (uint64_t)(int64_t)iimmediate)
+DECLARE_TRAP(TLT, rrs < rrt)
+DECLARE_TRAP(TLTU, (uint64_t) rrs < (uint64_t) rrt)
+DECLARE_TRAP(TLTI, rrs < (int64_t)iimmediate)
+DECLARE_TRAP(TLTIU, (uint64_t)rrs < (uint64_t)(int64_t)iimmediate)
+DECLARE_TRAP(TEQ, rrs == rrt)
+DECLARE_TRAP(TEQI, rrs == (int64_t)iimmediate)
+DECLARE_TRAP(TNE, rrs != rrt)
+DECLARE_TRAP(TNEI, rrs != (int64_t)iimmediate)
+
+#undef DECLARE_TRAP
 
 /* TLB instructions */
 
@@ -1076,7 +1096,7 @@ static void TLBWrite(struct r4300_core* r4300, unsigned int idx)
                 }
                 if (!r4300->cached_interp.invalid_code[i])
                 {
-                    r4300->cached_interp.blocks[i]->xxhash = XXH32(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000, 0);
+                    r4300->cached_interp.blocks[i]->xxhash = XXH3_64bits(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000);
                     r4300->cached_interp.invalid_code[i] = 1;
                 }
                 else if (r4300->cached_interp.blocks[i])
@@ -1095,7 +1115,7 @@ static void TLBWrite(struct r4300_core* r4300, unsigned int idx)
                 }
                 if (!r4300->cached_interp.invalid_code[i])
                 {
-                    r4300->cached_interp.blocks[i]->xxhash = XXH32(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000, 0);
+                    r4300->cached_interp.blocks[i]->xxhash = XXH3_64bits(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000);
                     r4300->cached_interp.invalid_code[i] = 1;
                 }
                 else if (r4300->cached_interp.blocks[i])
@@ -1144,7 +1164,7 @@ static void TLBWrite(struct r4300_core* r4300, unsigned int idx)
             {
                 if(r4300->cached_interp.blocks[i] && r4300->cached_interp.blocks[i]->xxhash)
                 {
-                    if(r4300->cached_interp.blocks[i]->xxhash == XXH32(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000, 0)) {
+                    if(r4300->cached_interp.blocks[i]->xxhash == XXH3_64bits(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000)) {
                         r4300->cached_interp.invalid_code[i] = 0;
                     }
                 }
@@ -1157,7 +1177,7 @@ static void TLBWrite(struct r4300_core* r4300, unsigned int idx)
             {
                 if(r4300->cached_interp.blocks[i] && r4300->cached_interp.blocks[i]->xxhash)
                 {
-                    if(r4300->cached_interp.blocks[i]->xxhash == XXH32(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000, 0)) {
+                    if(r4300->cached_interp.blocks[i]->xxhash == XXH3_64bits(&r4300->rdram->dram[(r4300->cp0.tlb.LUT_r[i]&0x7FF000)/4], 0x1000)) {
                         r4300->cached_interp.invalid_code[i] = 0;
                     }
                 }
@@ -1284,12 +1304,8 @@ DECLARE_INSTRUCTION(MTC0)
         ADD_TO_PC(-1);
         break;
     case CP0_CAUSE_REG:
-        if (rrt32 != 0)
-        {
-            DebugMessage(M64MSG_ERROR, "MTC0 instruction trying to write Cause register with non-0 value");
-            *r4300_stop(r4300) = 1;
-        }
-        else { cp0_regs[CP0_CAUSE_REG] = rrt32; }
+        cp0_regs[CP0_CAUSE_REG] &= ~(CP0_CAUSE_IP0 | CP0_CAUSE_IP1);
+        cp0_regs[CP0_CAUSE_REG] |= rrt32 & (CP0_CAUSE_IP0 | CP0_CAUSE_IP1);
         break;
     case CP0_EPC_REG:
         cp0_regs[CP0_EPC_REG] = rrt32;
diff --git a/mupen64plus-core/src/device/r4300/pure_interp.c b/mupen64plus-core/src/device/r4300/pure_interp.c
index 2175d244..c7b71c4d 100644
--- a/mupen64plus-core/src/device/r4300/pure_interp.c
+++ b/mupen64plus-core/src/device/r4300/pure_interp.c
@@ -294,16 +294,12 @@ void InterpretOpcode(struct r4300_core* r4300)
 			if (RD_OF(op) != 0) DSUBU(r4300, op);
 			else                NOP(r4300, 0);
 			break;
-		case 48: /* SPECIAL opcode 48: TGE (Not implemented) */
-		case 49: /* SPECIAL opcode 49: TGEU (Not implemented) */
-		case 50: /* SPECIAL opcode 50: TLT (Not implemented) */
-		case 51: /* SPECIAL opcode 51: TLTU (Not implemented) */
-			NI(r4300, op);
-			break;
+		case 48: TGE(r4300, op); break;
+		case 49: TGEU(r4300, op); break;
+		case 50: TLT(r4300, op); break;
+		case 51: TLTU(r4300, op); break;
 		case 52: TEQ(r4300, op); break;
-		case 54: /* SPECIAL opcode 54: TNE (Not implemented) */
-			NI(r4300, op);
-			break;
+		case 54: TNE(r4300, op); break;
 		case 56: /* SPECIAL opcode 56: DSLL */
 			if (RD_OF(op) != 0) DSLL(r4300, op);
 			else                NOP(r4300, 0);
@@ -352,14 +348,12 @@ void InterpretOpcode(struct r4300_core* r4300)
 			if (IS_RELATIVE_IDLE_LOOP(r4300, op, *r4300_pc(r4300))) BGEZL_IDLE(r4300, op);
 			else                                             BGEZL(r4300, op);
 			break;
-		case 8: /* REGIMM opcode 8: TGEI (Not implemented) */
-		case 9: /* REGIMM opcode 9: TGEIU (Not implemented) */
-		case 10: /* REGIMM opcode 10: TLTI (Not implemented) */
-		case 11: /* REGIMM opcode 11: TLTIU (Not implemented) */
-		case 12: /* REGIMM opcode 12: TEQI (Not implemented) */
-		case 14: /* REGIMM opcode 14: TNEI (Not implemented) */
-			NI(r4300, op);
-			break;
+		case 8: TGEI(r4300, op); break;
+		case 9: TGEIU(r4300, op); break;
+		case 10: TLTI(r4300, op); break;
+		case 11: TLTIU(r4300, op); break;
+		case 12: TEQI(r4300, op); break;
+		case 14: TNEI(r4300, op); break;
 		case 16: /* REGIMM opcode 16: BLTZAL */
 			if (IS_RELATIVE_IDLE_LOOP(r4300, op, *r4300_pc(r4300))) BLTZAL_IDLE(r4300, op);
 			else                                             BLTZAL(r4300, op);
diff --git a/mupen64plus-core/src/device/r4300/recomp.c b/mupen64plus-core/src/device/r4300/recomp.c
index e56579dc..cd5be0c4 100644
--- a/mupen64plus-core/src/device/r4300/recomp.c
+++ b/mupen64plus-core/src/device/r4300/recomp.c
@@ -301,7 +301,18 @@ void gen_SWR(struct r4300_core* r4300);
 void gen_SW(struct r4300_core* r4300);
 void gen_SYNC(struct r4300_core* r4300);
 void gen_SYSCALL(struct r4300_core* r4300);
+void gen_TGE(struct r4300_core* r4300);
+void gen_TGEU(struct r4300_core* r4300);
+void gen_TGEI(struct r4300_core* r4300);
+void gen_TGEIU(struct r4300_core* r4300);
+void gen_TLT(struct r4300_core* r4300);
+void gen_TLTU(struct r4300_core* r4300);
+void gen_TLTI(struct r4300_core* r4300);
+void gen_TLTIU(struct r4300_core* r4300);
 void gen_TEQ(struct r4300_core* r4300);
+void gen_TEQI(struct r4300_core* r4300);
+void gen_TNE(struct r4300_core* r4300);
+void gen_TNEI(struct r4300_core* r4300);
 void gen_TLBP(struct r4300_core* r4300);
 void gen_TLBR(struct r4300_core* r4300);
 void gen_TLBWI(struct r4300_core* r4300);
@@ -426,17 +437,6 @@ static void gen_CP1_CVT_S(struct r4300_core* r4300)
 #define gen_SCD        genni
 #define gen_SDC2       genni
 #define gen_SWC2       genni
-#define gen_TEQI       genni
-#define gen_TGE        genni
-#define gen_TGEI       genni
-#define gen_TGEIU      genni
-#define gen_TGEU       genni
-#define gen_TLT        genni
-#define gen_TLTI       genni
-#define gen_TLTIU      genni
-#define gen_TLTU       genni
-#define gen_TNE        genni
-#define gen_TNEI       genni
 
 #define X(op) gen_##op
 static void (*const recomp_funcs[R4300_OPCODES_COUNT])(struct r4300_core* r4300) =
diff --git a/mupen64plus-core/src/device/r4300/recomp_types.h b/mupen64plus-core/src/device/r4300/recomp_types.h
index 0b9b20bc..3318782c 100644
--- a/mupen64plus-core/src/device/r4300/recomp_types.h
+++ b/mupen64plus-core/src/device/r4300/recomp_types.h
@@ -88,7 +88,7 @@ struct precomp_block
     int jumps_number;
     void *riprel_table;
     int riprel_number;
-    unsigned int xxhash;
+    uint64_t xxhash;
 };
 
 #endif /* M64P_DEVICE_R4300_RECOMP_TYPES_H */
diff --git a/mupen64plus-core/src/device/r4300/x86/dynarec.c b/mupen64plus-core/src/device/r4300/x86/dynarec.c
index 52fec7c3..d14f7631 100644
--- a/mupen64plus-core/src/device/r4300/x86/dynarec.c
+++ b/mupen64plus-core/src/device/r4300/x86/dynarec.c
@@ -4015,13 +4015,68 @@ void gen_SYSCALL(struct r4300_core* r4300)
 #endif
 }
 
-/* Exception instructions */
+/* Trap instructions */
+
+void gen_TGE(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TGE, 0);
+}
+
+void gen_TGEU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TGEU, 0);
+}
+
+void gen_TGEI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TGEI, 0);
+}
+
+void gen_TGEIU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TGEIU, 0);
+}
+
+void gen_TLT(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TLT, 0);
+}
+
+void gen_TLTU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TLTU, 0);
+}
+
+void gen_TLTI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TLTI, 0);
+}
+
+void gen_TLTIU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TLTIU, 0);
+}
 
 void gen_TEQ(struct r4300_core* r4300)
 {
     gencallinterp(r4300, (unsigned int)cached_interp_TEQ, 0);
 }
 
+void gen_TEQI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TEQI, 0);
+}
+
+void gen_TNE(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TNE, 0);
+}
+
+void gen_TNEI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned int)cached_interp_TNEI, 0);
+}
+
 /* TLB instructions */
 
 void gen_TLBP(struct r4300_core* r4300)
diff --git a/mupen64plus-core/src/device/r4300/x86_64/dynarec.c b/mupen64plus-core/src/device/r4300/x86_64/dynarec.c
index 8000daf5..1d445d97 100644
--- a/mupen64plus-core/src/device/r4300/x86_64/dynarec.c
+++ b/mupen64plus-core/src/device/r4300/x86_64/dynarec.c
@@ -4182,7 +4182,47 @@ void gen_SYSCALL(struct r4300_core* r4300)
 #endif
 }
 
-/* Exception instructions */
+/* Trap instructions */
+
+void gen_TGE(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TGE, 0);
+}
+
+void gen_TGEU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TGEU, 0);
+}
+
+void gen_TGEI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TGEI, 0);
+}
+
+void gen_TGEIU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TGEIU, 0);
+}
+
+void gen_TLT(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TLT, 0);
+}
+
+void gen_TLTU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TLTU, 0);
+}
+
+void gen_TLTI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TLTI, 0);
+}
+
+void gen_TLTIU(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TLTIU, 0);
+}
 
 void gen_TEQ(struct r4300_core* r4300)
 {
@@ -4192,6 +4232,21 @@ void gen_TEQ(struct r4300_core* r4300)
     gencallinterp(r4300, (unsigned long long)cached_interp_TEQ, 0);
 }
 
+void gen_TEQI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TEQI, 0);
+}
+
+void gen_TNE(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TNE, 0);
+}
+
+void gen_TNEI(struct r4300_core* r4300)
+{
+    gencallinterp(r4300, (unsigned long long)cached_interp_TNEI, 0);
+}
+
 /* TLB instructions */
 
 void gen_TLBP(struct r4300_core* r4300)
diff --git a/mupen64plus-core/src/device/rcp/pi/pi_controller.c b/mupen64plus-core/src/device/rcp/pi/pi_controller.c
index 0fdb615c..86660074 100644
--- a/mupen64plus-core/src/device/rcp/pi/pi_controller.c
+++ b/mupen64plus-core/src/device/rcp/pi/pi_controller.c
@@ -38,23 +38,23 @@
 #define __STDC_FORMAT_MACROS
 #include <inttypes.h>
 
-enum
+int validate_pi_request(struct pi_controller* pi)
 {
-    /* PI_STATUS - read */
-    PI_STATUS_DMA_BUSY  = 0x01,
-    PI_STATUS_IO_BUSY   = 0x02,
-    PI_STATUS_ERROR     = 0x04,
-
-    /* PI_STATUS - write */
-    PI_STATUS_RESET     = 0x01,
-    PI_STATUS_CLR_INTR  = 0x02
-};
+    if (pi->regs[PI_STATUS_REG] & (PI_STATUS_DMA_BUSY | PI_STATUS_IO_BUSY)) {
+        pi->regs[PI_STATUS_REG] |= PI_STATUS_ERROR;
+        return 0;
+    }
 
+    return 1;
+}
 
 static void dma_pi_read(struct pi_controller* pi)
 {
+    if (!validate_pi_request(pi))
+        return;
+
     uint32_t cart_addr = pi->regs[PI_CART_ADDR_REG] & ~UINT32_C(1);
-    uint32_t dram_addr = pi->regs[PI_DRAM_ADDR_REG];
+    uint32_t dram_addr = pi->regs[PI_DRAM_ADDR_REG] & 0xffffff;
     uint32_t length = (pi->regs[PI_RD_LEN_REG] & UINT32_C(0x00fffffe)) + 2;
     const uint8_t* dram = (uint8_t*)pi->ri->rdram->dram;
 
@@ -82,8 +82,11 @@ static void dma_pi_read(struct pi_controller* pi)
 
 static void dma_pi_write(struct pi_controller* pi)
 {
+    if (!validate_pi_request(pi))
+        return;
+
     uint32_t cart_addr = pi->regs[PI_CART_ADDR_REG] & ~UINT32_C(1);
-    uint32_t dram_addr = pi->regs[PI_DRAM_ADDR_REG];
+    uint32_t dram_addr = pi->regs[PI_DRAM_ADDR_REG] & 0xffffff;
     uint32_t length = (pi->regs[PI_WR_LEN_REG] & UINT32_C(0x00fffffe)) + 2;
     uint8_t* dram = (uint8_t*)pi->ri->rdram->dram;
 
@@ -189,7 +192,7 @@ void write_pi_regs(void* opaque, uint32_t address, uint32_t value, uint32_t mask
 void pi_end_of_dma_event(void* opaque)
 {
     struct pi_controller* pi = (struct pi_controller*)opaque;
-    pi->regs[PI_STATUS_REG] &= ~PI_STATUS_DMA_BUSY;
+    pi->regs[PI_STATUS_REG] &= ~(PI_STATUS_DMA_BUSY | PI_STATUS_IO_BUSY);
 
     if (pi->dd != NULL) {
         if ((pi->regs[PI_CART_ADDR_REG] == MM_DD_C2S_BUFFER) ||
diff --git a/mupen64plus-core/src/device/rcp/pi/pi_controller.h b/mupen64plus-core/src/device/rcp/pi/pi_controller.h
index 5ab28332..bff869ce 100644
--- a/mupen64plus-core/src/device/rcp/pi/pi_controller.h
+++ b/mupen64plus-core/src/device/rcp/pi/pi_controller.h
@@ -51,6 +51,18 @@ enum pi_registers
     PI_REGS_COUNT
 };
 
+enum
+{
+    /* PI_STATUS - read */
+    PI_STATUS_DMA_BUSY  = 0x01,
+    PI_STATUS_IO_BUSY   = 0x02,
+    PI_STATUS_ERROR     = 0x04,
+
+    /* PI_STATUS - write */
+    PI_STATUS_RESET     = 0x01,
+    PI_STATUS_CLR_INTR  = 0x02
+};
+
 struct pi_dma_handler
 {
     unsigned int (*dma_read)(void* opaque, const uint8_t* dram, uint32_t dram_addr, uint32_t cart_addr, uint32_t length);
@@ -93,5 +105,6 @@ void read_pi_regs(void* opaque, uint32_t address, uint32_t* value);
 void write_pi_regs(void* opaque, uint32_t address, uint32_t value, uint32_t mask);
 
 void pi_end_of_dma_event(void* opaque);
+int validate_pi_request(struct pi_controller* pi);
 
 #endif
diff --git a/mupen64plus-core/src/device/rcp/rdp/fb.c b/mupen64plus-core/src/device/rcp/rdp/fb.c
index 32d190df..1215f69a 100644
--- a/mupen64plus-core/src/device/rcp/rdp/fb.c
+++ b/mupen64plus-core/src/device/rcp/rdp/fb.c
@@ -162,6 +162,16 @@ void write_rdram_fb(void* opaque, uint32_t address, uint32_t value, uint32_t mas
         size = 2;
         break;
 
+    case 0xffffff00:
+        addr += (0 ^ Sh16);
+        size = 3;
+        break;
+
+    case 0x00ffffff:
+        addr += (1 ^ Sh16);
+        size = 3;
+        break;
+
     case 0xffffffff:
         addr += 0;
         size = 4;
diff --git a/mupen64plus-core/src/device/rcp/rdp/rdp_core.c b/mupen64plus-core/src/device/rcp/rdp/rdp_core.c
index 0f9d32be..f091801b 100644
--- a/mupen64plus-core/src/device/rcp/rdp/rdp_core.c
+++ b/mupen64plus-core/src/device/rcp/rdp/rdp_core.c
@@ -114,7 +114,9 @@ void write_dpc_regs(void* opaque, uint32_t address, uint32_t value, uint32_t mas
         dp->dpc_regs[DPC_CURRENT_REG] = dp->dpc_regs[DPC_START_REG];
         break;
     case DPC_END_REG:
+        unprotect_framebuffers(&dp->fb);
         gfx.processRDPList();
+        protect_framebuffers(&dp->fb);
         signal_rcp_interrupt(dp->mi, MI_INTR_DP);
         break;
     }
diff --git a/mupen64plus-core/src/main/savestates.c b/mupen64plus-core/src/main/savestates.c
index 5983e7a3..9d43176d 100644
--- a/mupen64plus-core/src/main/savestates.c
+++ b/mupen64plus-core/src/main/savestates.c
@@ -584,7 +584,7 @@ int savestates_load_m64p(struct device* dev, const void *data)
 
         /* extra cart_rom state */
         dev->cart.cart_rom.last_write = GETDATA(curr, uint32_t);
-        dev->cart.cart_rom.rom_written = GETDATA(curr, uint32_t);
+        curr += 4; /* used to be cart_rom.rom_written */
 
         /* extra sp state */
         curr += 4; /* here there used to be rsp_task_locked */
@@ -724,7 +724,7 @@ int savestates_load_m64p(struct device* dev, const void *data)
 
         /* extra cart_rom state */
         dev->cart.cart_rom.last_write = GETDATA(curr, uint32_t);
-        dev->cart.cart_rom.rom_written = GETDATA(curr, uint32_t);
+        curr +=4; /* used to be cart_rom.rom_written */
 
         /* extra sp state */
         curr += 4; /* here there used to be rsp_task_locked */
@@ -919,7 +919,6 @@ int savestates_load_m64p(struct device* dev, const void *data)
 
         /* extra cart_rom state */
         dev->cart.cart_rom.last_write = 0;
-        dev->cart.cart_rom.rom_written = 0;
 
         /* extra af-rtc state */
         dev->cart.af_rtc.control = 0x200;
@@ -1199,7 +1198,6 @@ static int savestates_load_pj64(struct device* dev,
 
     /* extra cart_rom state */
     dev->cart.cart_rom.last_write = 0;
-    dev->cart.cart_rom.rom_written = 0;
 
     // ri_register
     dev->ri.regs[RI_MODE_REG]         = GETDATA(curr, uint32_t);
@@ -1831,7 +1829,7 @@ int savestates_save_m64p(const struct device* dev, void *data)
     PUTDATA(curr, uint32_t, dev->ai.delayed_carry);
 
     PUTDATA(curr, uint32_t, dev->cart.cart_rom.last_write);
-    PUTDATA(curr, uint32_t, dev->cart.cart_rom.rom_written);
+    PUTDATA(curr, uint32_t, 0); /* used to be cart_rom.rom_written */
 
     PUTDATA(curr, uint32_t, 0); /* here there used to be rsp_task_locked */
 
diff --git a/mupen64plus-core/src/main/workqueue.h b/mupen64plus-core/src/main/workqueue.h
index d5093a53..2af257a4 100644
--- a/mupen64plus-core/src/main/workqueue.h
+++ b/mupen64plus-core/src/main/workqueue.h
@@ -27,7 +27,6 @@
 
 struct work_struct;
 
-struct work_struct *work;
 typedef void (*work_func_t)(struct work_struct *work);
 struct work_struct {
     work_func_t func;
diff --git a/mupen64plus-core/subprojects/xxhash/xxh3.h b/mupen64plus-core/subprojects/xxhash/xxh3.h
index b3a82958..9e3e88ad 100644
--- a/mupen64plus-core/subprojects/xxhash/xxh3.h
+++ b/mupen64plus-core/subprojects/xxhash/xxh3.h
@@ -1,50 +1,54 @@
 /*
-   xxHash - Extremely Fast Hash algorithm
-   Development source file for `xxh3`
-   Copyright (C) 2019-present, Yann Collet.
-
-   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are
-   met:
-
-       * Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
-       * Redistributions in binary form must reproduce the above
-   copyright notice, this list of conditions and the following disclaimer
-   in the documentation and/or other materials provided with the
-   distribution.
-
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-   You can contact the author at :
-   - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
-
-/* Note :
-   This file is separated for development purposes.
-   It will be integrated into `xxhash.c` when development phase is complete.
-*/
-
-#ifndef XXH3_H
-#define XXH3_H
+ * xxHash - Extremely Fast Hash algorithm
+ * Development source file for `xxh3`
+ * Copyright (C) 2019-present, Yann Collet
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
 
+/*
+ * Note: This file is separated for development purposes.
+ * It will be integrated into `xxhash.h` when development stage is completed.
+ *
+ * Credit: most of the work on vectorial and asm variants comes from @easyaspi314
+ */
 
-/* ===   Dependencies   === */
+#ifndef XXH3_H_1397135465
+#define XXH3_H_1397135465
 
-#undef XXH_INLINE_ALL   /* in case it's already defined */
-#define XXH_INLINE_ALL
+/* ===   Dependencies   === */
+#ifndef XXHASH_H_5627135585666179
+/* special: when including `xxh3.h` directly, turn on XXH_INLINE_ALL */
+#  undef XXH_INLINE_ALL   /* avoid redefinition */
+#  define XXH_INLINE_ALL
+#endif
 #include "xxhash.h"
 
 
@@ -53,10 +57,20 @@
 #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* >= C99 */
 #  define XXH_RESTRICT   restrict
 #else
-/* note : it might be useful to define __restrict or __restrict__ for some C++ compilers */
+/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */
 #  define XXH_RESTRICT   /* disable */
 #endif
 
+#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
+  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
+  || defined(__clang__)
+#    define XXH_likely(x) __builtin_expect(x, 1)
+#    define XXH_unlikely(x) __builtin_expect(x, 0)
+#else
+#    define XXH_likely(x) (x)
+#    define XXH_unlikely(x) (x)
+#endif
+
 #if defined(__GNUC__)
 #  if defined(__AVX2__)
 #    include <immintrin.h>
@@ -72,17 +86,50 @@
 #endif
 
 /*
- * Sanity check.
+ * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
+ * remaining a true 64-bit/128-bit hash function.
+ *
+ * This is done by prioritizing a subset of 64-bit operations that can be
+ * emulated without too many steps on the average 32-bit machine.
+ *
+ * For example, these two lines seem similar, and run equally fast on 64-bit:
  *
- * XXH3 only requires these features to be efficient:
+ *   xxh_u64 x;
+ *   x ^= (x >> 47); // good
+ *   x ^= (x >> 13); // bad
+ *
+ * However, to a 32-bit machine, there is a major difference.
+ *
+ * x ^= (x >> 47) looks like this:
+ *
+ *   x.lo ^= (x.hi >> (47 - 32));
+ *
+ * while x ^= (x >> 13) looks like this:
+ *
+ *   // note: funnel shifts are not usually cheap.
+ *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
+ *   x.hi ^= (x.hi >> 13);
+ *
+ * The first one is significantly faster than the second, simply because the
+ * shift is larger than 32. This means:
+ *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
+ *    32 bits in the shift.
+ *  - The shift result will always fit in the lower 32 bits, and therefore,
+ *    we can ignore the upper 32 bits in the xor.
+ *
+ * Thanks to this optimization, XXH3 only requires these features to be efficient:
  *
  *  - Usable unaligned access
  *  - A 32-bit or 64-bit ALU
  *      - If 32-bit, a decent ADC instruction
  *  - A 32 or 64-bit multiply with a 64-bit result
+ *  - For the 128-bit variant, a decent byteswap helps short inputs.
+ *
+ * The first two are already required by XXH32, and almost all 32-bit and 64-bit
+ * platforms which can run XXH32 can run XXH3 efficiently.
  *
- * Almost all 32-bit and 64-bit targets meet this, except for Thumb-1, the
- * classic 16-bit only subset of ARM's instruction set.
+ * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
+ * notable exception.
  *
  * First of all, Thumb-1 lacks support for the UMULL instruction which
  * performs the important long multiply. This means numerous __aeabi_lmul
@@ -93,14 +140,16 @@
  * Lo registers, and this shuffling results in thousands more MOVs than A32.
  *
  * A32 and T32 don't have this limitation. They can access all 14 registers,
- * do a 32->64 multiply with UMULL, and the flexible operand is helpful too.
+ * do a 32->64 multiply with UMULL, and the flexible operand allowing free
+ * shifts is helpful, too.
  *
- * If compiling Thumb-1 for a target which supports ARM instructions, we
- * will give a warning.
+ * Therefore, we do a quick sanity check.
  *
- * Usually, if this happens, it is because of an accident and you probably
- * need to specify -march, as you probably meant to compileh for a newer
- * architecture.
+ * If compiling Thumb-1 for a target which supports ARM instructions, we will
+ * emit a warning, as it is not a "sane" platform to compile for.
+ *
+ * Usually, if this happens, it is because of an accident and you probably need
+ * to specify -march, as you likely meant to compile for a newer architecture.
  */
 #if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
 #   warning "XXH3 is highly inefficient without ARM or Thumb-2."
@@ -109,11 +158,11 @@
 /* ==========================================
  * Vectorization detection
  * ========================================== */
-#define XXH_SCALAR 0
-#define XXH_SSE2   1
-#define XXH_AVX2   2
-#define XXH_NEON   3
-#define XXH_VSX    4
+#define XXH_SCALAR 0 /* Portable scalar version */
+#define XXH_SSE2   1 /* SSE2 for Pentium 4 and all x86_64 */
+#define XXH_AVX2   2 /* AVX2 for Haswell and Bulldozer */
+#define XXH_NEON   3 /* NEON for most ARMv7-A and all AArch64 */
+#define XXH_VSX    4 /* VSX and ZVector for POWER8/z13 */
 
 #ifndef XXH_VECTOR    /* can be defined on command line */
 #  if defined(__AVX2__)
@@ -125,47 +174,186 @@
   && (defined(__LITTLE_ENDIAN__) /* We only support little endian NEON */ \
     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
 #    define XXH_VECTOR XXH_NEON
-#  elif defined(__PPC64__) && defined(__POWER8_VECTOR__) && defined(__GNUC__)
+#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
+     || (defined(__s390x__) && defined(__VEC__)) \
+     && defined(__GNUC__) /* TODO: IBM XL */
 #    define XXH_VECTOR XXH_VSX
 #  else
 #    define XXH_VECTOR XXH_SCALAR
 #  endif
 #endif
 
-/* control alignment of accumulator,
- * for compatibility with fast vector loads */
+/*
+ * Controls the alignment of the accumulator.
+ * This is for compatibility with aligned vector loads, which are usually faster.
+ */
 #ifndef XXH_ACC_ALIGN
-#  if XXH_VECTOR == 0   /* scalar */
+#  if XXH_VECTOR == XXH_SCALAR  /* scalar */
 #     define XXH_ACC_ALIGN 8
-#  elif XXH_VECTOR == 1  /* sse2 */
+#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
 #     define XXH_ACC_ALIGN 16
-#  elif XXH_VECTOR == 2  /* avx2 */
+#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
 #     define XXH_ACC_ALIGN 32
-#  elif XXH_VECTOR == 3  /* neon */
+#  elif XXH_VECTOR == XXH_NEON  /* neon */
 #     define XXH_ACC_ALIGN 16
-#  elif XXH_VECTOR == 4  /* vsx */
+#  elif XXH_VECTOR == XXH_VSX   /* vsx */
 #     define XXH_ACC_ALIGN 16
 #  endif
 #endif
 
-/* xxh_u64 XXH_mult32to64(xxh_u32 a, xxh_u64 b) { return (xxh_u64)a * (xxh_u64)b; } */
-#if defined(_MSC_VER) && defined(_M_IX86)
-#    include <intrin.h>
-#    define XXH_mult32to64(x, y) __emulu(x, y)
-#else
-#    define XXH_mult32to64(x, y) ((xxh_u64)((x) & 0xFFFFFFFF) * (xxh_u64)((y) & 0xFFFFFFFF))
+/*
+ * UGLY HACK:
+ * GCC usually generates the best code with -O3 for xxHash.
+ *
+ * However, when targeting AVX2, it is overzealous in its unrolling resulting
+ * in code roughly 3/4 the speed of Clang.
+ *
+ * There are other issues, such as GCC splitting _mm256_loadu_si256 into
+ * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
+ * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
+ *
+ * That is why when compiling the AVX2 version, it is recommended to use either
+ *   -O2 -mavx2 -march=haswell
+ * or
+ *   -O2 -mavx2 -mno-avx256-split-unaligned-load
+ * for decent performance, or to use Clang instead.
+ *
+ * Fortunately, we can control the first one with a pragma that forces GCC into
+ * -O2, but the other one we can't control without "failed to inline always
+ * inline function due to target mismatch" warnings.
+ */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC push_options
+#  pragma GCC optimize("-O2")
 #endif
 
-/* VSX stuff. It's a lot because VSX support is mediocre across compilers and
- * there is a lot of mischief with endianness. */
+
+#if XXH_VECTOR == XXH_NEON
+/*
+ * NEON's setup for vmlal_u32 is a little more complicated than it is on
+ * SSE2, AVX2, and VSX.
+ *
+ * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.
+ *
+ * To do the same operation, the 128-bit 'Q' register needs to be split into
+ * two 64-bit 'D' registers, performing this operation::
+ *
+ *   [                a                 |                 b                ]
+ *            |              '---------. .--------'                |
+ *            |                         x                          |
+ *            |              .---------' '--------.                |
+ *   [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[    a >> 32     |     b >> 32    ]
+ *
+ * Due to significant changes in aarch64, the fastest method for aarch64 is
+ * completely different than the fastest method for ARMv7-A.
+ *
+ * ARMv7-A treats D registers as unions overlaying Q registers, so modifying
+ * D11 will modify the high half of Q5. This is similar to how modifying AH
+ * will only affect bits 8-15 of AX on x86.
+ *
+ * VZIP takes two registers, and puts even lanes in one register and odd lanes
+ * in the other.
+ *
+ * On ARMv7-A, this strangely modifies both parameters in place instead of
+ * taking the usual 3-operand form.
+ *
+ * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the
+ * lower and upper halves of the Q register to end up with the high and low
+ * halves where we want - all in one instruction.
+ *
+ *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }
+ *
+ * Unfortunately we need inline assembly for this: Instructions modifying two
+ * registers at once is not possible in GCC or Clang's IR, and they have to
+ * create a copy.
+ *
+ * aarch64 requires a different approach.
+ *
+ * In order to make it easier to write a decent compiler for aarch64, many
+ * quirks were removed, such as conditional execution.
+ *
+ * NEON was also affected by this.
+ *
+ * aarch64 cannot access the high bits of a Q-form register, and writes to a
+ * D-form register zero the high bits, similar to how writes to W-form scalar
+ * registers (or DWORD registers on x86_64) work.
+ *
+ * The formerly free vget_high intrinsics now require a vext (with a few
+ * exceptions)
+ *
+ * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent
+ * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one
+ * operand.
+ *
+ * The equivalent of the VZIP.32 on the lower and upper halves would be this
+ * mess:
+ *
+ *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }
+ *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }
+ *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }
+ *
+ * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):
+ *
+ *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 >> 32);
+ *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 & 0xFFFFFFFF);
+ *
+ * This is available on ARMv7-A, but is less efficient than a single VZIP.32.
+ */
+
+/*
+ * Function-like macro:
+ * void XXH_SPLIT_IN_PLACE(uint64x2_t &in, uint32x2_t &outLo, uint32x2_t &outHi)
+ * {
+ *     outLo = (uint32x2_t)(in & 0xFFFFFFFF);
+ *     outHi = (uint32x2_t)(in >> 32);
+ *     in = UNDEFINED;
+ * }
+ */
+# if !defined(XXH_NO_VZIP_HACK) /* define to disable */ \
+   && defined(__GNUC__) \
+   && !defined(__aarch64__) && !defined(__arm64__)
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
+    do {                                                                                    \
+      /* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */ \
+      /* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */     \
+      /* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */ \
+      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
+      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
+      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
+   } while (0)
+# else
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
+    do {                                                                                  \
+      (outLo) = vmovn_u64    (in);                                                        \
+      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
+    } while (0)
+# endif
+#endif  /* XXH_VECTOR == XXH_NEON */
+
+/*
+ * VSX and Z Vector helpers.
+ *
+ * This is very messy, and any pull requests to clean this up are welcome.
+ *
+ * There are a lot of problems with supporting VSX and s390x, due to
+ * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
+ */
 #if XXH_VECTOR == XXH_VSX
-#  include <altivec.h>
-#  undef vector
-typedef __vector unsigned long long U64x2;
-typedef __vector unsigned char U8x16;
-typedef __vector unsigned U32x4;
+#  if defined(__s390x__)
+#    include <s390intrin.h>
+#  else
+#    include <altivec.h>
+#  endif
+
+#  undef vector /* Undo the pollution */
 
-#ifndef XXH_VSX_BE
+typedef __vector unsigned long long xxh_u64x2;
+typedef __vector unsigned char xxh_u8x16;
+typedef __vector unsigned xxh_u32x4;
+
+# ifndef XXH_VSX_BE
 #  if defined(__BIG_ENDIAN__) \
   || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
 #    define XXH_VSX_BE 1
@@ -175,67 +363,82 @@ typedef __vector unsigned U32x4;
 #  else
 #    define XXH_VSX_BE 0
 #  endif
-#endif
+# endif /* !defined(XXH_VSX_BE) */
 
-/* We need some helpers for big endian mode. */
-#if XXH_VSX_BE
+# if XXH_VSX_BE
 /* A wrapper for POWER9's vec_revb. */
-#  ifdef __POWER9_VECTOR__
+#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
 #    define XXH_vec_revb vec_revb
 #  else
-XXH_FORCE_INLINE U64x2 XXH_vec_revb(U64x2 val)
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
 {
-    U8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
-                              0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
+    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
+                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
     return vec_perm(val, val, vByteSwap);
 }
 #  endif
+# endif /* XXH_VSX_BE */
 
-/* Power8 Crypto gives us vpermxor which is very handy for
- * PPC64EB.
- *
- * U8x16 vpermxor(U8x16 a, U8x16 b, U8x16 mask)
- * {
- *     U8x16 ret;
- *     for (int i = 0; i < 16; i++) {
- *         ret[i] = a[mask[i] & 0xF] ^ b[mask[i] >> 4];
- *     }
- *     return ret;
- * }
- *
- * Because both of the main loops load the key, swap, and xor it with input,
- * we can combine the key swap into this instruction.
+/*
+ * Performs an unaligned load and byte swaps it on big endian.
  */
-#  ifdef vec_permxor
-#    define XXH_vec_permxor vec_permxor
-#  else
-#    define XXH_vec_permxor __builtin_crypto_vpermxor
-#  endif
-#endif
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
+{
+    xxh_u64x2 ret;
+    memcpy(&ret, ptr, sizeof(xxh_u64x2));
+# if XXH_VSX_BE
+    ret = XXH_vec_revb(ret);
+# endif
+    return ret;
+}
+
 /*
- * Because we reinterpret the multiply, there are endian memes: vec_mulo actually becomes
- * vec_mule.
+ * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
  *
- * Additionally, the intrinsic wasn't added until GCC 8, despite existing for a while.
- * Clang has an easy way to control this, we can just use the builtin which doesn't swap.
- * GCC needs inline assembly. */
-#if __has_builtin(__builtin_altivec_vmuleuw)
+ * These intrinsics weren't added until GCC 8, despite existing for a while,
+ * and they are endian dependent. Also, their meaning swap depending on version.
+ * */
+# if defined(__s390x__)
+ /* s390x is always big endian, no issue on this platform */
+#  define XXH_vec_mulo vec_mulo
+#  define XXH_vec_mule vec_mule
+# elif defined(__clang__) && __has_builtin(__builtin_altivec_vmuleuw)
+/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
 #  define XXH_vec_mulo __builtin_altivec_vmulouw
 #  define XXH_vec_mule __builtin_altivec_vmuleuw
-#else
+# else
+/* gcc needs inline assembly */
 /* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
-XXH_FORCE_INLINE U64x2 XXH_vec_mulo(U32x4 a, U32x4 b) {
-    U64x2 result;
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
     __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
     return result;
 }
-XXH_FORCE_INLINE U64x2 XXH_vec_mule(U32x4 a, U32x4 b) {
-    U64x2 result;
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
     __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
     return result;
 }
-#endif
-#endif
+# endif /* XXH_vec_mulo, XXH_vec_mule */
+#endif /* XXH_VECTOR == XXH_VSX */
+
+
+/* prefetch
+ * can be disabled, by declaring XXH_NO_PREFETCH build macro */
+#if defined(XXH_NO_PREFETCH)
+#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
+#else
+#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  /* _mm_prefetch() is not defined outside of x86/x64 */
+#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
+#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
+#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
+#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
+#  else
+#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
+#  endif
+#endif  /* XXH_NO_PREFETCH */
 
 
 /* ==========================================
@@ -248,6 +451,7 @@ XXH_FORCE_INLINE U64x2 XXH_vec_mule(U32x4 a, U32x4 b) {
 #  error "default keyset is not large enough"
 #endif
 
+/* Pseudorandom secret taken directly from FARSH */
 XXH_ALIGN(64) static const xxh_u8 kSecret[XXH_SECRET_DEFAULT_SIZE] = {
     0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
     0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
@@ -265,16 +469,40 @@ XXH_ALIGN(64) static const xxh_u8 kSecret[XXH_SECRET_DEFAULT_SIZE] = {
 };
 
 /*
- * GCC for x86 has a tendency to use SSE in this loop. While it
- * successfully avoids swapping (as MUL overwrites EAX and EDX), it
- * slows it down because instead of free register swap shifts, it
- * must use pshufd and punpckl/hd.
+ * Does a 32-bit to 64-bit long multiply.
+ *
+ * Wraps __emulu on MSVC x86 because it tends to call __allmul when it doesn't
+ * need to (but it shouldn't need to anyways, it is about 7 instructions to do
+ * a 64x64 multiply...). Since we know that this will _always_ emit MULL, we
+ * use that instead of the normal method.
  *
- * To prevent this, we use this attribute to shut off SSE.
+ * If you are compiling for platforms like Thumb-1 and don't have a better option,
+ * you may also want to write your own long multiply routine here.
+ *
+ * XXH_FORCE_INLINE xxh_u64 XXH_mult32to64(xxh_u64 x, xxh_u64 y)
+ * {
+ *    return (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF);
+ * }
+ */
+#if defined(_MSC_VER) && defined(_M_IX86)
+#    include <intrin.h>
+#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
+#else
+/*
+ * Downcast + upcast is usually better than masking on older compilers like
+ * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
+ *
+ * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
+ * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
  */
-#if defined(__GNUC__) && !defined(__clang__) && defined(__i386__)
-__attribute__((__target__("no-sse")))
+#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
 #endif
+
+/*
+ * Calculates a 64->128-bit long multiply.
+ *
+ * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.
+ */
 static XXH128_hash_t
 XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
 {
@@ -287,9 +515,9 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
      *
      * Usually.
      *
-     * Despite being a 32-bit platform, Clang (and emscripten) define this
-     * type despite not having the arithmetic for it. This results in a
-     * laggy compiler builtin call which calculates a full 128-bit multiply.
+     * Despite being a 32-bit platform, Clang (and emscripten) define this type
+     * despite not having the arithmetic for it. This results in a laggy
+     * compiler builtin call which calculates a full 128-bit multiply.
      * In that case it is best to use the portable one.
      * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
      */
@@ -322,29 +550,30 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
     /*
      * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
      *
-     * This is a fast and simple grade school multiply, which is shown
-     * below with base 10 arithmetic instead of base 0x100000000.
+     * This is a fast and simple grade school multiply, which is shown below
+     * with base 10 arithmetic instead of base 0x100000000.
      *
      *           9 3 // D2 lhs = 93
      *         x 7 5 // D2 rhs = 75
      *     ----------
-     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10)
-     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10)
-     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10)
-     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10)
+     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
+     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
+     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
+     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
      *     ---------
-     *         2 7 | // D2 cross  = (15 / 10) + (45 % 10) + 21
-     *     + 6 7 | | // D2 upper  = (27 / 10) + (45 / 10) + 63
+     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
+     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
      *     ---------
-     *       6 9 7 5
+     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
      *
      * The reasons for adding the products like this are:
      *  1. It avoids manual carry tracking. Just like how
-     *     (9 * 9) + 9 + 9 = 99, the same applies with this for
-     *     UINT64_MAX. This avoids a lot of complexity.
+     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
+     *     This avoids a lot of complexity.
      *
      *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
-     *     instruction available in ARMv6+ A32/T32, which is shown below:
+     *     instruction available in ARM's Digital Signal Processing extension
+     *     in 32-bit ARMv6 and later, which is shown below:
      *
      *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
      *         {
@@ -353,12 +582,12 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
      *             *RdHi = (xxh_u32)(product >> 32);
      *         }
      *
-     *     This instruction was designed for efficient long multiplication,
-     *     and allows this to be calculated in only 4 instructions which
-     *     is comparable to some 64-bit ALUs.
+     *     This instruction was designed for efficient long multiplication, and
+     *     allows this to be calculated in only 4 instructions at speeds
+     *     comparable to some 64-bit ALUs.
      *
-     *  3. It isn't terrible on other platforms. Usually this will be
-     *     a couple of 32-bit ADD/ADCs.
+     *  3. It isn't terrible on other platforms. Usually this will be a couple
+     *     of 32-bit ADD/ADCs.
      */
 
     /* First calculate all of the cross products. */
@@ -378,17 +607,11 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
 }
 
 /*
- * We want to keep the attribute here because a target switch
- * disables inlining.
- *
  * Does a 64-bit to 128-bit multiply, then XOR folds it.
- * The reason for the separate function is to prevent passing
- * too many structs around by value. This will hopefully inline
- * the multiply, but we don't force it.
+ *
+ * The reason for the separate function is to prevent passing too many structs
+ * around by value. This will hopefully inline the multiply, but we don't force it.
  */
-#if defined(__GNUC__) && !defined(__clang__) && defined(__i386__)
-__attribute__((__target__("no-sse")))
-#endif
 static xxh_u64
 XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
 {
@@ -396,32 +619,78 @@ XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
     return product.low64 ^ product.high64;
 }
 
+/* Seems to produce slightly better code on GCC for some reason. */
+XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
+{
+    XXH_ASSERT(0 <= shift && shift < 64);
+    return v64 ^ (v64 >> shift);
+}
 
+/*
+ * We don't need to (or want to) mix as much as XXH64.
+ *
+ * Short hashes are more evenly distributed, so it isn't necessary.
+ */
 static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
 {
-    h64 ^= h64 >> 37;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
+    h64 = XXH_xorshift64(h64, 37);
+    h64 *= 0x165667919E3779F9ULL;
+    h64 = XXH_xorshift64(h64, 32);
     return h64;
 }
 
 
 /* ==========================================
  * Short keys
- * ========================================== */
+ * ==========================================
+ * One of the shortcomings of XXH32 and XXH64 was that their performance was
+ * sub-optimal on short lengths. It used an iterative algorithm which strongly
+ * favored lengths that were a multiple of 4 or 8.
+ *
+ * Instead of iterating over individual inputs, we use a set of single shot
+ * functions which piece together a range of lengths and operate in constant time.
+ *
+ * Additionally, the number of multiplies has been significantly reduced. This
+ * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
+ *
+ * Depending on the platform, this may or may not be faster than XXH32, but it
+ * is almost guaranteed to be faster than XXH64.
+ */
 
+/*
+ * At very short lengths, there isn't enough input to fully hide secrets, or use
+ * the entire secret.
+ *
+ * There is also only a limited amount of mixing we can do before significantly
+ * impacting performance.
+ *
+ * Therefore, we use different sections of the secret and always mix two secret
+ * samples with an XOR. This should have no effect on performance on the
+ * seedless or withSeed variants because everything _should_ be constant folded
+ * by modern compilers.
+ *
+ * The XOR mixing hides individual parts of the secret and increases entropy.
+ *
+ * This adds an extra layer of strength for custom secrets.
+ */
 XXH_FORCE_INLINE XXH64_hash_t
 XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(1 <= len && len <= 3);
     XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
+     */
     {   xxh_u8 const c1 = input[0];
         xxh_u8 const c2 = input[len >> 1];
         xxh_u8 const c3 = input[len - 1];
-        xxh_u32  const combined = ((xxh_u32)c1) | (((xxh_u32)c2) << 8) | (((xxh_u32)c3) << 16) | (((xxh_u32)len) << 24);
-        xxh_u64  const keyed = (xxh_u64)combined ^ (XXH_readLE32(secret) + seed);
-        xxh_u64  const mixed = keyed * PRIME64_1;
+        xxh_u32 const combined = ((xxh_u32)c1<<16) | (((xxh_u32)c2) << 24) | (((xxh_u32)c3) << 0) | (((xxh_u32)len) << 8);
+        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
+        xxh_u64 const mixed = keyed * PRIME64_1;
         return XXH3_avalanche(mixed);
     }
 }
@@ -431,13 +700,19 @@ XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_h
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
-    XXH_ASSERT(4 <= len && len <= 8);
-    {   xxh_u32 const input_lo = XXH_readLE32(input);
-        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
-        xxh_u64 const input_64 = input_lo | ((xxh_u64)input_hi << 32);
-        xxh_u64 const keyed = input_64 ^ (XXH_readLE64(secret) + seed);
-        xxh_u64 const mix64 = len + ((keyed ^ (keyed >> 51)) * PRIME32_1);
-        return XXH3_avalanche((mix64 ^ (mix64 >> 47)) * PRIME64_2);
+    XXH_ASSERT(4 <= len && len < 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input1 = XXH_readLE32(input);
+        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
+        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
+        xxh_u64 x = input64 ^ bitflip;
+        /* this mix is inspired by Pelle Evensen's rrmxmx */
+        x ^= XXH_rotl64(x, 49) ^ XXH_rotl64(x, 24);
+        x *= 0x9FB21C651E98DF25ULL;
+        x ^= (x >> 35) + len ;
+        x *= 0x9FB21C651E98DF25ULL;
+        return XXH_xorshift64(x, 28);
     }
 }
 
@@ -446,10 +721,14 @@ XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
-    XXH_ASSERT(9 <= len && len <= 16);
-    {   xxh_u64 const input_lo = XXH_readLE64(input)           ^ (XXH_readLE64(secret)     + seed);
-        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ (XXH_readLE64(secret + 8) - seed);
-        xxh_u64 const acc = len + (input_lo + input_hi) + XXH3_mul128_fold64(input_lo, input_hi);
+    XXH_ASSERT(8 <= len && len <= 16);
+    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
+        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
+        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
+        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
+        xxh_u64 const acc = len
+                          + XXH_swap64(input_lo) + input_hi
+                          + XXH3_mul128_fold64(input_lo, input_hi);
         return XXH3_avalanche(acc);
     }
 }
@@ -458,10 +737,152 @@ XXH_FORCE_INLINE XXH64_hash_t
 XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
 {
     XXH_ASSERT(len <= 16);
-    {   if (len > 8) return XXH3_len_9to16_64b(input, len, secret, seed);
-        if (len >= 4) return XXH3_len_4to8_64b(input, len, secret, seed);
+    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
+        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
         if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
-        return 0;
+        return XXH3_avalanche((PRIME64_1 + seed) ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
+    }
+}
+
+/*
+ * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
+ * multiplication by zero, affecting hashes of lengths 17 to 240.
+ *
+ * However, they are very unlikely.
+ *
+ * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
+ * unseeded non-cryptographic hashes, it does not attempt to defend itself
+ * against specially crafted inputs, only random inputs.
+ *
+ * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
+ * cancelling out the secret is taken an arbitrary number of times (addressed
+ * in XXH3_accumulate_512), this collision is very unlikely with random inputs
+ * and/or proper seeding:
+ *
+ * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
+ * function that is only called up to 16 times per hash with up to 240 bytes of
+ * input.
+ *
+ * This is not too bad for a non-cryptographic hash function, especially with
+ * only 64 bit outputs.
+ *
+ * The 128-bit variant (which trades some speed for strength) is NOT affected
+ * by this, although it is always a good idea to use a proper seed if you care
+ * about strength.
+ */
+XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
+                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
+{
+#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
+  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
+    /*
+     * UGLY HACK:
+     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
+     * slower code.
+     *
+     * By forcing seed64 into a register, we disrupt the cost model and
+     * cause it to scalarize. See `XXH32_round()`
+     *
+     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
+     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
+     * GCC 9.2, despite both emitting scalar code.
+     *
+     * GCC generates much better scalar code than Clang for the rest of XXH3,
+     * which is why finding a more optimal codepath is an interest.
+     */
+    __asm__ ("" : "+r" (seed64));
+#endif
+    {   xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64 const input_hi = XXH_readLE64(input+8);
+        return XXH3_mul128_fold64(
+            input_lo ^ (XXH_readLE64(secret)   + seed64),
+            input_hi ^ (XXH_readLE64(secret+8) - seed64)
+        );
+    }
+}
+
+/* For mid range keys, XXH3 uses a Mum-hash variant. */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                     XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   xxh_u64 acc = len * PRIME64_1;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc += XXH3_mix16B(input+48, secret+96, seed);
+                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
+                }
+                acc += XXH3_mix16B(input+32, secret+64, seed);
+                acc += XXH3_mix16B(input+len-48, secret+80, seed);
+            }
+            acc += XXH3_mix16B(input+16, secret+32, seed);
+            acc += XXH3_mix16B(input+len-32, secret+48, seed);
+        }
+        acc += XXH3_mix16B(input+0, secret+0, seed);
+        acc += XXH3_mix16B(input+len-16, secret+16, seed);
+
+        return XXH3_avalanche(acc);
+    }
+}
+
+#define XXH3_MIDSIZE_MAX 240
+
+XXH_NO_INLINE XXH64_hash_t
+XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    #define XXH3_MIDSIZE_STARTOFFSET 3
+    #define XXH3_MIDSIZE_LASTOFFSET  17
+
+    {   xxh_u64 acc = len * PRIME64_1;
+        int const nbRounds = (int)len / 16;
+        int i;
+        for (i=0; i<8; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
+        }
+        acc = XXH3_avalanche(acc);
+        XXH_ASSERT(nbRounds >= 8);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */ \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
+         * In everywhere else, it uses scalar code.
+         *
+         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
+         * would still be slower than UMAAL (see XXH_mult64to128).
+         *
+         * Unfortunately, Clang doesn't handle the long multiplies properly and
+         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
+         * scalarized into an ugly mess of VMOV.32 instructions.
+         *
+         * This mess is difficult to avoid without turning autovectorization
+         * off completely, but they are usually relatively minor and/or not
+         * worth it to fix.
+         *
+         * This loop is the easiest to fix, as unlike XXH32, this pragma
+         * _actually works_ because it is a loop vectorization instead of an
+         * SLP vectorization.
+         */
+        #pragma clang loop vectorize(disable)
+#endif
+        for (i=8 ; i < nbRounds; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
+        }
+        /* last bytes */
+        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
+        return XXH3_avalanche(acc);
     }
 }
 
@@ -474,6 +895,28 @@ XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_
 
 typedef enum { XXH3_acc_64bits, XXH3_acc_128bits } XXH3_accWidth_e;
 
+/*
+ * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
+ *
+ * It is a hardened version of UMAC, based off of FARSH's implementation.
+ *
+ * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
+ * implementations, and it is ridiculously fast.
+ *
+ * We harden it by mixing the original input to the accumulators as well as the product.
+ *
+ * This means that in the (relatively likely) case of a multiply by zero, the
+ * original input is preserved.
+ *
+ * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
+ * cross-pollination, as otherwise the upper and lower halves would be
+ * essentially independent.
+ *
+ * This doesn't matter on 64-bit hashes since they all get merged together in
+ * the end, so we skip the extra step.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
 XXH_FORCE_INLINE void
 XXH3_accumulate_512(      void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
@@ -483,46 +926,75 @@ XXH3_accumulate_512(      void* XXH_RESTRICT acc,
 #if (XXH_VECTOR == XXH_AVX2)
 
     XXH_ASSERT((((size_t)acc) & 31) == 0);
-    {   XXH_ALIGN(32) __m256i* const xacc  =       (__m256i *) acc;
-        const         __m256i* const xinput = (const __m256i *) input;  /* not really aligned, just for ptr arithmetic, and because _mm256_loadu_si256() requires this type */
-        const         __m256i* const xsecret = (const __m256i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm256_loadu_si256() requires this type */
+    {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
+        const         __m256i* const xinput  = (const __m256i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
 
         size_t i;
         for (i=0; i < STRIPE_LEN/sizeof(__m256i); i++) {
-            __m256i const data_vec = _mm256_loadu_si256 (xinput+i);
-            __m256i const key_vec = _mm256_loadu_si256 (xsecret+i);
-            __m256i const data_key = _mm256_xor_si256 (data_vec, key_vec);                                  /* uint32 dk[8]  = {d0+k0, d1+k1, d2+k2, d3+k3, ...} */
-            __m256i const product = _mm256_mul_epu32 (data_key, _mm256_shuffle_epi32 (data_key, 0x31));  /* uint64 mul[4] = {dk0*dk1, dk2*dk3, ...} */
+            /* data_vec    = xinput[i]; */
+            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
             if (accWidth == XXH3_acc_128bits) {
-                __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
-                __m256i const sum = _mm256_add_epi64(xacc[i], data_swap);
-                xacc[i]  = _mm256_add_epi64(product, sum);
+                /* xacc[i] += swap(data_vec); */
+                __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
+                __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
+                /* xacc[i] += product; */
+                xacc[i] = _mm256_add_epi64(product, sum);
             } else {  /* XXH3_acc_64bits */
+                /* xacc[i] += data_vec; */
                 __m256i const sum = _mm256_add_epi64(xacc[i], data_vec);
-                xacc[i]  = _mm256_add_epi64(product, sum);
+                /* xacc[i] += product; */
+                xacc[i] = _mm256_add_epi64(product, sum);
             }
     }   }
 
 #elif (XXH_VECTOR == XXH_SSE2)
 
+    /* SSE2 is just a half-scale version of the AVX2 version. */
     XXH_ASSERT((((size_t)acc) & 15) == 0);
-    {   XXH_ALIGN(16) __m128i* const xacc  =       (__m128i *) acc;
-        const         __m128i* const xinput = (const __m128i *) input;  /* not really aligned, just for ptr arithmetic, and because _mm_loadu_si128() requires this type */
-        const         __m128i* const xsecret = (const __m128i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm_loadu_si128() requires this type */
+    {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xinput  = (const __m128i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
 
         size_t i;
         for (i=0; i < STRIPE_LEN/sizeof(__m128i); i++) {
-            __m128i const data_vec = _mm_loadu_si128 (xinput+i);
-            __m128i const key_vec = _mm_loadu_si128 (xsecret+i);
-            __m128i const data_key = _mm_xor_si128 (data_vec, key_vec);                                  /* uint32 dk[8]  = {d0+k0, d1+k1, d2+k2, d3+k3, ...} */
-            __m128i const product = _mm_mul_epu32 (data_key, _mm_shuffle_epi32 (data_key, 0x31));  /* uint64 mul[4] = {dk0*dk1, dk2*dk3, ...} */
+            /* data_vec    = xinput[i]; */
+            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
             if (accWidth == XXH3_acc_128bits) {
+                /* xacc[i] += swap(data_vec); */
                 __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
-                __m128i const sum = _mm_add_epi64(xacc[i], data_swap);
-                xacc[i]  = _mm_add_epi64(product, sum);
+                __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
+                /* xacc[i] += product; */
+                xacc[i] = _mm_add_epi64(product, sum);
             } else {  /* XXH3_acc_64bits */
+                /* xacc[i] += data_vec; */
                 __m128i const sum = _mm_add_epi64(xacc[i], data_vec);
-                xacc[i]  = _mm_add_epi64(product, sum);
+                /* xacc[i] += product; */
+                xacc[i] = _mm_add_epi64(product, sum);
             }
     }   }
 
@@ -537,117 +1009,66 @@ XXH3_accumulate_512(      void* XXH_RESTRICT acc,
 
         size_t i;
         for (i=0; i < STRIPE_LEN / sizeof(uint64x2_t); i++) {
-#if !defined(__aarch64__) && !defined(__arm64__) && defined(__GNUC__) /* ARM32-specific hack */
-            /* vzip on ARMv7 Clang generates a lot of vmovs (technically vorrs) without this.
-             * vzip on 32-bit ARM NEON will overwrite the original register, and I think that Clang
-             * assumes I don't want to destroy it and tries to make a copy. This slows down the code
-             * a lot.
-             * aarch64 not only uses an entirely different syntax, but it requires three
-             * instructions...
-             *    ext    v1.16B, v0.16B, #8    // select high bits because aarch64 can't address them directly
-             *    zip1   v3.2s, v0.2s, v1.2s   // first zip
-             *    zip2   v2.2s, v0.2s, v1.2s   // second zip
-             * ...to do what ARM does in one:
-             *    vzip.32 d0, d1               // Interleave high and low bits and overwrite. */
-
-            /* data_vec = xsecret[i]; */
-            uint8x16_t const data_vec    = vld1q_u8(xinput + (i * 16));
-            /* key_vec  = xsecret[i];  */
-            uint8x16_t const key_vec     = vld1q_u8(xsecret  + (i * 16));
-            /* data_key = data_vec ^ key_vec; */
-            uint32x4_t       data_key;
-
-            if (accWidth == XXH3_acc_64bits) {
-                /* Add first to prevent register swaps */
-                /* xacc[i] += data_vec; */
-                xacc[i] = vaddq_u64 (xacc[i], vreinterpretq_u64_u8(data_vec));
-            } else {  /* XXH3_acc_128bits */
-                /* xacc[i] += swap(data_vec); */
-                /* can probably be optimized better */
-                uint64x2_t const data64 = vreinterpretq_u64_u8(data_vec);
-                uint64x2_t const swapped= vextq_u64(data64, data64, 1);
-                xacc[i] = vaddq_u64 (xacc[i], swapped);
-            }
-
-            data_key = vreinterpretq_u32_u8(veorq_u8(data_vec, key_vec));
-
-            /* Here's the magic. We use the quirkiness of vzip to shuffle data_key in place.
-             * shuffle: data_key[0, 1, 2, 3] = data_key[0, 2, 1, 3] */
-            __asm__("vzip.32 %e0, %f0" : "+w" (data_key));
-            /* xacc[i] += (uint64x2_t) data_key[0, 1] * (uint64x2_t) data_key[2, 3]; */
-            xacc[i] = vmlal_u32(xacc[i], vget_low_u32(data_key), vget_high_u32(data_key));
-
-#else
-            /* On aarch64, vshrn/vmovn seems to be equivalent to, if not faster than, the vzip method. */
-
-            /* data_vec = xsecret[i]; */
-            uint8x16_t const data_vec    = vld1q_u8(xinput + (i * 16));
+            /* data_vec = xinput[i]; */
+            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
             /* key_vec  = xsecret[i];  */
-            uint8x16_t const key_vec     = vld1q_u8(xsecret  + (i * 16));
+            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
             /* data_key = data_vec ^ key_vec; */
-            uint64x2_t const data_key    = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
-            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF); */
-            uint32x2_t const data_key_lo = vmovn_u64  (data_key);
-            /* data_key_hi = (uint32x2_t) (data_key >> 32); */
-            uint32x2_t const data_key_hi = vshrn_n_u64 (data_key, 32);
+            uint64x2_t data_key    = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
+            uint32x2_t data_key_lo, data_key_hi;
             if (accWidth == XXH3_acc_64bits) {
                 /* xacc[i] += data_vec; */
                 xacc[i] = vaddq_u64 (xacc[i], vreinterpretq_u64_u8(data_vec));
             } else {  /* XXH3_acc_128bits */
                 /* xacc[i] += swap(data_vec); */
-                uint64x2_t const data64 = vreinterpretq_u64_u8(data_vec);
-                uint64x2_t const swapped= vextq_u64(data64, data64, 1);
+                uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
+                uint64x2_t const swapped = vextq_u64(data64, data64, 1);
                 xacc[i] = vaddq_u64 (xacc[i], swapped);
             }
+            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (data_key >> 32);
+             * data_key = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
             /* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */
             xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);
 
-#endif
         }
     }
 
 #elif (XXH_VECTOR == XXH_VSX)
-          U64x2* const xacc =        (U64x2*) acc;    /* presumed aligned */
-    U64x2 const* const xinput = (U64x2 const*) input;   /* no alignment restriction */
-    U64x2 const* const xsecret  = (U64x2 const*) secret;    /* no alignment restriction */
-    U64x2 const v32 = { 32,  32 };
-#if XXH_VSX_BE
-    U8x16 const vXorSwap  = { 0x07, 0x16, 0x25, 0x34, 0x43, 0x52, 0x61, 0x70,
-                              0x8F, 0x9E, 0xAD, 0xBC, 0xCB, 0xDA, 0xE9, 0xF8 };
-#endif
+          xxh_u64x2* const xacc     =       (xxh_u64x2*) acc;    /* presumed aligned */
+    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   /* no alignment restriction */
+    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    /* no alignment restriction */
+    xxh_u64x2 const v32 = { 32, 32 };
     size_t i;
-    for (i = 0; i < STRIPE_LEN / sizeof(U64x2); i++) {
+    for (i = 0; i < STRIPE_LEN / sizeof(xxh_u64x2); i++) {
         /* data_vec = xinput[i]; */
+        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
         /* key_vec = xsecret[i]; */
-#if XXH_VSX_BE
-        /* byteswap */
-        U64x2 const data_vec = XXH_vec_revb(vec_vsx_ld(0, xinput + i));
-        U64x2 const key_raw = vec_vsx_ld(0, xsecret + i);
-        /* See comment above. data_key = data_vec ^ swap(xsecret[i]); */
-        U64x2 const data_key = (U64x2)XXH_vec_permxor((U8x16)data_vec, (U8x16)key_raw, vXorSwap);
-#else
-        U64x2 const data_vec = vec_vsx_ld(0, xinput + i);
-        U64x2 const key_vec = vec_vsx_ld(0, xsecret + i);
-        U64x2 const data_key = data_vec ^ key_vec;
-#endif
+        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+        xxh_u64x2 const data_key = data_vec ^ key_vec;
         /* shuffled = (data_key << 32) | (data_key >> 32); */
-        U32x4 const shuffled = (U32x4)vec_rl(data_key, v32);
-        /* product = ((U64x2)data_key & 0xFFFFFFFF) * ((U64x2)shuffled & 0xFFFFFFFF); */
-        U64x2 const product = XXH_vec_mulo((U32x4)data_key, shuffled);
+        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
+        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
+        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
         xacc[i] += product;
 
         if (accWidth == XXH3_acc_64bits) {
             xacc[i] += data_vec;
         } else {  /* XXH3_acc_128bits */
             /* swap high and low halves */
-            U64x2 const data_swapped = vec_xxpermdi(data_vec, data_vec, 2);
+#ifdef __s390x__
+            xxh_u64x2 const data_swapped = vec_permi(data_vec, data_vec, 2);
+#else
+            xxh_u64x2 const data_swapped = vec_xxpermdi(data_vec, data_vec, 2);
+#endif
             xacc[i] += data_swapped;
         }
     }
 
 #else   /* scalar variant of Accumulator - universal */
 
-    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;    /* presumed aligned on 32-bytes boundaries, little hint for the auto-vectorizer */
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; /* presumed aligned */
     const xxh_u8* const xinput = (const xxh_u8*) input;  /* no alignment restriction */
     const xxh_u8* const xsecret  = (const xxh_u8*) secret;   /* no alignment restriction */
     size_t i;
@@ -666,6 +1087,26 @@ XXH3_accumulate_512(      void* XXH_RESTRICT acc,
 #endif
 }
 
+/*
+ * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
+ *
+ * Multiplication isn't perfect, as explained by Google in HighwayHash:
+ *
+ *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
+ *  // varying degrees. In descending order of goodness, bytes
+ *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
+ *  // As expected, the upper and lower bytes are much worse.
+ *
+ * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
+ *
+ * Since our algorithm uses a pseudorandom secret to add some variance into the
+ * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
+ *
+ * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
+ * extraction.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
 XXH_FORCE_INLINE void
 XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 {
@@ -673,7 +1114,9 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 
     XXH_ASSERT((((size_t)acc) & 31) == 0);
     {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
-        const         __m256i* const xsecret = (const __m256i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm256_loadu_si256() requires this argument type */
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
         const __m256i prime32 = _mm256_set1_epi32((int)PRIME32_1);
 
         size_t i;
@@ -687,7 +1130,7 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
             __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
 
             /* xacc[i] *= PRIME32_1; */
-            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, 0x31);
+            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
             __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
             __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
             xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
@@ -698,7 +1141,9 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 
     XXH_ASSERT((((size_t)acc) & 15) == 0);
     {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
-        const         __m128i* const xsecret = (const __m128i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm_loadu_si128() requires this argument type */
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
         const __m128i prime32 = _mm_set1_epi32((int)PRIME32_1);
 
         size_t i;
@@ -707,12 +1152,12 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
             __m128i const acc_vec     = xacc[i];
             __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
             __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
-            /* xacc[i] ^= xsecret; */
+            /* xacc[i] ^= xsecret[i]; */
             __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
             __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
 
             /* xacc[i] *= PRIME32_1; */
-            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, 0x31);
+            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
             __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
             __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
             xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
@@ -723,80 +1168,91 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 
     XXH_ASSERT((((size_t)acc) & 15) == 0);
 
-    {   uint64x2_t* const xacc =     (uint64x2_t*) acc;
-        uint8_t const* const xsecret = (uint8_t const*) secret;
-        uint32x2_t const prime     = vdup_n_u32 (PRIME32_1);
+    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
+        uint8_t const* xsecret = (uint8_t const*) secret;
+        uint32x2_t prime       = vdup_n_u32 (PRIME32_1);
 
         size_t i;
         for (i=0; i < STRIPE_LEN/sizeof(uint64x2_t); i++) {
-            /* data_vec = xacc[i] ^ (xacc[i] >> 47); */
-            uint64x2_t const   acc_vec  = xacc[i];
-            uint64x2_t const   shifted  = vshrq_n_u64 (acc_vec, 47);
-            uint64x2_t const   data_vec = veorq_u64   (acc_vec, shifted);
-
-            /* key_vec  = xsecret[i]; */
-            uint32x4_t const   key_vec  = vreinterpretq_u32_u8(vld1q_u8(xsecret + (i * 16)));
-            /* data_key = data_vec ^ key_vec; */
-            uint32x4_t const   data_key = veorq_u32   (vreinterpretq_u32_u64(data_vec), key_vec);
-            /* shuffled = { data_key[0, 2], data_key[1, 3] }; */
-            uint32x2x2_t const shuffled = vzip_u32    (vget_low_u32(data_key), vget_high_u32(data_key));
-
-            /* data_key *= PRIME32_1 */
-
-            /* prod_hi = (data_key >> 32) * PRIME32_1; */
-            uint64x2_t const   prod_hi = vmull_u32    (shuffled.val[1], prime);
-            /* xacc[i] = prod_hi << 32; */
-            xacc[i] = vshlq_n_u64(prod_hi, 32);
-            /* xacc[i] += (prod_hi & 0xFFFFFFFF) * PRIME32_1; */
-            xacc[i] = vmlal_u32(xacc[i], shuffled.val[0], prime);
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            uint64x2_t acc_vec  = xacc[i];
+            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
+            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);
+
+            /* xacc[i] ^= xsecret[i]; */
+            uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
+            uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));
+
+            /* xacc[i] *= PRIME32_1 */
+            uint32x2_t data_key_lo, data_key_hi;
+            /* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
+             * xacc[i] = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
+            {   /*
+                 * prod_hi = (data_key >> 32) * PRIME32_1;
+                 *
+                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
+                 * incorrectly "optimize" this:
+                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
+                 *   shifted = vshll_n_u32(tmp, 32);
+                 * to this:
+                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
+                 *   shifted = vshlq_n_u64(tmp, 32);
+                 *
+                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
+                 * for NEON, and it scalarizes two 64-bit multiplies instead.
+                 *
+                 * vmull_u32 has the same timing as vmul_u32, and it avoids
+                 * this bug completely.
+                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
+                 */
+                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
+                /* xacc[i] = prod_hi << 32; */
+                xacc[i] = vshlq_n_u64(prod_hi, 32);
+                /* xacc[i] += (prod_hi & 0xFFFFFFFF) * PRIME32_1; */
+                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
+            }
     }   }
 
 #elif (XXH_VECTOR == XXH_VSX)
 
-          U64x2* const xacc =       (U64x2*) acc;
-    const U64x2* const xsecret = (const U64x2*) secret;
-    /* constants */
-    U64x2 const v32  = { 32, 32 };
-    U64x2 const v47 = { 47, 47 };
-    U32x4 const prime = { PRIME32_1, PRIME32_1, PRIME32_1, PRIME32_1 };
-    size_t i;
-#if XXH_VSX_BE
-    /* endian swap */
-    U8x16 const vXorSwap  = { 0x07, 0x16, 0x25, 0x34, 0x43, 0x52, 0x61, 0x70,
-                              0x8F, 0x9E, 0xAD, 0xBC, 0xCB, 0xDA, 0xE9, 0xF8 };
-#endif
-    for (i = 0; i < STRIPE_LEN / sizeof(U64x2); i++) {
-        U64x2 const acc_vec  = xacc[i];
-        U64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
-        /* key_vec = xsecret[i]; */
-#if XXH_VSX_BE
-        /* swap bytes words */
-        U64x2 const key_raw  = vec_vsx_ld(0, xsecret + i);
-        U64x2 const data_key = (U64x2)XXH_vec_permxor((U8x16)data_vec, (U8x16)key_raw, vXorSwap);
-#else
-        U64x2 const key_vec  = vec_vsx_ld(0, xsecret + i);
-        U64x2 const data_key = data_vec ^ key_vec;
-#endif
-
-        /* data_key *= PRIME32_1 */
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
 
-        /* prod_lo = ((U64x2)data_key & 0xFFFFFFFF) * ((U64x2)prime & 0xFFFFFFFF);  */
-        U64x2 const prod_even  = XXH_vec_mule((U32x4)data_key, prime);
-        /* prod_hi = ((U64x2)data_key >> 32) * ((U64x2)prime >> 32);  */
-        U64x2 const prod_odd  = XXH_vec_mulo((U32x4)data_key, prime);
-        xacc[i] = prod_odd + (prod_even << v32);
-    }
+    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
+        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
+        /* constants */
+        xxh_u64x2 const v32  = { 32, 32 };
+        xxh_u64x2 const v47 = { 47, 47 };
+        xxh_u32x4 const prime = { PRIME32_1, PRIME32_1, PRIME32_1, PRIME32_1 };
+        size_t i;
+        for (i = 0; i < STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            xxh_u64x2 const acc_vec  = xacc[i];
+            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
+
+            /* xacc[i] ^= xsecret[i]; */
+            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+            xxh_u64x2 const data_key = data_vec ^ key_vec;
+
+            /* xacc[i] *= PRIME32_1 */
+            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
+            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
+            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
+            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
+            xacc[i] = prod_odd + (prod_even << v32);
+    }   }
 
 #else   /* scalar variant of Scrambler - universal */
 
-    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned on 32-bytes boundaries, little hint for the auto-vectorizer */
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
     const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
     size_t i;
     XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
     for (i=0; i < ACC_NB; i++) {
         xxh_u64 const key64 = XXH_readLE64(xsecret + 8*i);
         xxh_u64 acc64 = xacc[i];
-        acc64 ^= acc64 >> 47;
+        acc64 = XXH_xorshift64(acc64, 47);
         acc64 ^= key64;
         acc64 *= PRIME32_1;
         xacc[i] = acc64;
@@ -805,9 +1261,15 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 #endif
 }
 
-/* assumption : nbStripes will not overflow secret size */
+#define XXH_PREFETCH_DIST 384
+
+/*
+ * XXH3_accumulate()
+ * Loops over XXH3_accumulate_512().
+ * Assumption: nbStripes will not overflow the secret size
+ */
 XXH_FORCE_INLINE void
-XXH3_accumulate(       xxh_u64* XXH_RESTRICT acc,
+XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
                 const xxh_u8* XXH_RESTRICT input,
                 const xxh_u8* XXH_RESTRICT secret,
                       size_t nbStripes,
@@ -815,24 +1277,16 @@ XXH3_accumulate(       xxh_u64* XXH_RESTRICT acc,
 {
     size_t n;
     for (n = 0; n < nbStripes; n++ ) {
+        const xxh_u8* const in = input + n*STRIPE_LEN;
+        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
         XXH3_accumulate_512(acc,
-                            input  + n*STRIPE_LEN,
+                            in,
                             secret + n*XXH_SECRET_CONSUME_RATE,
                             accWidth);
     }
 }
 
-/* note : clang auto-vectorizes well in SS2 mode _if_ this function is `static`,
- *        and doesn't auto-vectorize it at all if it is `FORCE_INLINE`.
- *        However, it auto-vectorizes better AVX2 if it is `FORCE_INLINE`
- *        Pretty much every other modes and compilers prefer `FORCE_INLINE`.
- */
-
-#if defined(__clang__) && (XXH_VECTOR==0) && !defined(__AVX2__) && !defined(__arm__) && !defined(__thumb__)
-static void
-#else
 XXH_FORCE_INLINE void
-#endif
 XXH3_hashLong_internal_loop( xxh_u64* XXH_RESTRICT acc,
                       const xxh_u8* XXH_RESTRICT input, size_t len,
                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
@@ -860,7 +1314,8 @@ XXH3_hashLong_internal_loop( xxh_u64* XXH_RESTRICT acc,
         /* last stripe */
         if (len & (STRIPE_LEN - 1)) {
             const xxh_u8* const p = input + len - STRIPE_LEN;
-#define XXH_SECRET_LASTACC_START 7  /* do not align on 8, so that secret is different from scrambler */
+            /* Do not align on 8, so that the secret is different from the scrambler */
+#define XXH_SECRET_LASTACC_START 7
             XXH3_accumulate_512(acc, p, secret + secretSize - STRIPE_LEN - XXH_SECRET_LASTACC_START, accWidth);
     }   }
 }
@@ -899,19 +1354,27 @@ XXH3_hashLong_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
 
     /* converge into final hash */
     XXH_STATIC_ASSERT(sizeof(acc) == 64);
-#define XXH_SECRET_MERGEACCS_START 11  /* do not align on 8, so that secret is different from accumulator */
+    /* do not align on 8, so that the secret is different from the accumulator */
+#define XXH_SECRET_MERGEACCS_START 11
     XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
     return XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
 }
 
-
-XXH_NO_INLINE XXH64_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
 XXH3_hashLong_64b_defaultSecret(const xxh_u8* XXH_RESTRICT input, size_t len)
 {
     return XXH3_hashLong_internal(input, len, kSecret, sizeof(kSecret));
 }
 
-XXH_NO_INLINE XXH64_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
 XXH3_hashLong_64b_withSecret(const xxh_u8* XXH_RESTRICT input, size_t len,
                              const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
 {
@@ -942,14 +1405,18 @@ XXH_FORCE_INLINE void XXH3_initCustomSecret(xxh_u8* customSecret, xxh_u64 seed64
 }
 
 
-/* XXH3_hashLong_64b_withSeed() :
- * Generate a custom key,
- * based on alteration of default kSecret with the seed,
+/*
+ * XXH3_hashLong_64b_withSeed():
+ * Generate a custom key based on alteration of default kSecret with the seed,
  * and then use this key for long mode hashing.
+ *
  * This operation is decently fast but nonetheless costs a little bit of time.
  * Try to avoid it whenever possible (typically when seed==0).
+ *
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
  */
-XXH_NO_INLINE XXH64_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
+XXH_NO_INLINE XXH64_hash_t
 XXH3_hashLong_64b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
 {
     XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
@@ -958,76 +1425,6 @@ XXH3_hashLong_64b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
     return XXH3_hashLong_internal(input, len, secret, sizeof(secret));
 }
 
-
-XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
-                                 const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
-{
-    xxh_u64 const input_lo = XXH_readLE64(input);
-    xxh_u64 const input_hi = XXH_readLE64(input+8);
-    return XXH3_mul128_fold64(
-               input_lo ^ (XXH_readLE64(secret)   + seed64),
-               input_hi ^ (XXH_readLE64(secret+8) - seed64) );
-}
-
-
-XXH_FORCE_INLINE XXH64_hash_t
-XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
-                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
-                     XXH64_hash_t seed)
-{
-    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
-    XXH_ASSERT(16 < len && len <= 128);
-
-    {   xxh_u64 acc = len * PRIME64_1;
-        if (len > 32) {
-            if (len > 64) {
-                if (len > 96) {
-                    acc += XXH3_mix16B(input+48, secret+96, seed);
-                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
-                }
-                acc += XXH3_mix16B(input+32, secret+64, seed);
-                acc += XXH3_mix16B(input+len-48, secret+80, seed);
-            }
-            acc += XXH3_mix16B(input+16, secret+32, seed);
-            acc += XXH3_mix16B(input+len-32, secret+48, seed);
-        }
-        acc += XXH3_mix16B(input+0, secret+0, seed);
-        acc += XXH3_mix16B(input+len-16, secret+16, seed);
-
-        return XXH3_avalanche(acc);
-    }
-}
-
-#define XXH3_MIDSIZE_MAX 240
-
-XXH_NO_INLINE XXH64_hash_t
-XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
-                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
-                      XXH64_hash_t seed)
-{
-    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
-    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
-
-    #define XXH3_MIDSIZE_STARTOFFSET 3
-    #define XXH3_MIDSIZE_LASTOFFSET  17
-
-    {   xxh_u64 acc = len * PRIME64_1;
-        int const nbRounds = (int)len / 16;
-        int i;
-        for (i=0; i<8; i++) {
-            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
-        }
-        acc = XXH3_avalanche(acc);
-        XXH_ASSERT(nbRounds >= 8);
-        for (i=8 ; i < nbRounds; i++) {
-            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
-        }
-        /* last bytes */
-        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
-        return XXH3_avalanche(acc);
-    }
-}
-
 /* ===   Public entry point   === */
 
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* input, size_t len)
@@ -1042,14 +1439,16 @@ XXH_PUBLIC_API XXH64_hash_t
 XXH3_64bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
 {
     XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
-    /* if an action must be taken should `secret` conditions not be respected,
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
      * it should be done here.
      * For now, it's a contract pre-condition.
-     * Adding a check and a branch here would cost performance at every hash */
-     if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
-     if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
-     if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
-     return XXH3_hashLong_64b_withSecret((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize);
+     * Adding a check and a branch here would cost performance at every hash.
+     */
+    if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
+    if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+    return XXH3_hashLong_64b_withSecret((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize);
 }
 
 XXH_PUBLIC_API XXH64_hash_t
@@ -1152,6 +1551,9 @@ XXH3_consumeStripes( xxh_u64* acc,
     }
 }
 
+/*
+ * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
+ */
 XXH_FORCE_INLINE XXH_errorcode
 XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_e accWidth)
 {
@@ -1171,12 +1573,16 @@ XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_
             state->bufferedSize += (XXH32_hash_t)len;
             return XXH_OK;
         }
-        /* input now > XXH3_INTERNALBUFFER_SIZE */
+        /* input is now > XXH3_INTERNALBUFFER_SIZE */
 
         #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / STRIPE_LEN)
         XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % STRIPE_LEN == 0);   /* clean multiple */
 
-        if (state->bufferedSize) {   /* some input within internal buffer: fill then consume it */
+        /*
+         * There is some input left inside the internal buffer.
+         * Fill it, then consume it.
+         */
+        if (state->bufferedSize) {
             size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
             XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
             input += loadSize;
@@ -1188,7 +1594,7 @@ XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_
             state->bufferedSize = 0;
         }
 
-        /* consume input by full buffer quantities */
+        /* Consume input by full buffer quantities */
         if (input+XXH3_INTERNALBUFFER_SIZE <= bEnd) {
             const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
             do {
@@ -1201,7 +1607,7 @@ XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_
             } while (input<=limit);
         }
 
-        if (input < bEnd) { /* some remaining input input : buffer it */
+        if (input < bEnd) { /* Some remaining input: buffer it */
             XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
             state->bufferedSize = (XXH32_hash_t)(bEnd-input);
         }
@@ -1220,7 +1626,11 @@ XXH3_64bits_update(XXH3_state_t* state, const void* input, size_t len)
 XXH_FORCE_INLINE void
 XXH3_digest_long (XXH64_hash_t* acc, const XXH3_state_t* state, XXH3_accWidth_e accWidth)
 {
-    memcpy(acc, state->acc, sizeof(state->acc));  /* digest locally, state remains unaltered, and can continue ingesting more input afterwards */
+    /*
+     * Digest on a local copy. This way, the state remains unaltered, and it can
+     * continue ingesting more input afterwards.
+     */
+    memcpy(acc, state->acc, sizeof(state->acc));
     if (state->bufferedSize >= STRIPE_LEN) {
         size_t const totalNbStripes = state->bufferedSize / STRIPE_LEN;
         XXH32_hash_t nbStripesSoFar = state->nbStripesSoFar;
@@ -1271,40 +1681,52 @@ XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(1 <= len && len <= 3);
     XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
+     */
     {   xxh_u8 const c1 = input[0];
         xxh_u8 const c2 = input[len >> 1];
         xxh_u8 const c3 = input[len - 1];
-        xxh_u32  const combinedl = ((xxh_u32)c1) + (((xxh_u32)c2) << 8) + (((xxh_u32)c3) << 16) + (((xxh_u32)len) << 24);
-        xxh_u32  const combinedh = XXH_swap32(combinedl);
-        xxh_u64  const keyed_lo = (xxh_u64)combinedl ^ (XXH_readLE32(secret)   + seed);
-        xxh_u64  const keyed_hi = (xxh_u64)combinedh ^ (XXH_readLE32(secret+4) - seed);
-        xxh_u64  const mixedl = keyed_lo * PRIME64_1;
-        xxh_u64  const mixedh = keyed_hi * PRIME64_5;
+        xxh_u32 const combinedl = ((xxh_u32)c1<<16) | (((xxh_u32)c2) << 24) | (((xxh_u32)c3) << 0) | (((xxh_u32)len) << 8);
+        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
+        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
+        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
+        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
+        xxh_u64 const mixedl = keyed_lo * PRIME64_1;
+        xxh_u64 const mixedh = keyed_hi * PRIME64_5;
         XXH128_hash_t const h128 = { XXH3_avalanche(mixedl) /*low64*/, XXH3_avalanche(mixedh) /*high64*/ };
         return h128;
     }
 }
 
-
 XXH_FORCE_INLINE XXH128_hash_t
 XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
     XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
     {   xxh_u32 const input_lo = XXH_readLE32(input);
         xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
-        xxh_u64 const input_64_lo = input_lo + ((xxh_u64)input_hi << 32);
-        xxh_u64 const input_64_hi = XXH_swap64(input_64_lo);
-        xxh_u64 const keyed_lo = input_64_lo ^ (XXH_readLE64(secret) + seed);
-        xxh_u64 const keyed_hi = input_64_hi ^ (XXH_readLE64(secret + 8) - seed);
-        xxh_u64 const mix64l1 = len + ((keyed_lo ^ (keyed_lo >> 51)) * PRIME32_1);
-        xxh_u64 const mix64l2 = (mix64l1 ^ (mix64l1 >> 47)) * PRIME64_2;
-        xxh_u64 const mix64h1 = ((keyed_hi ^ (keyed_hi >> 47)) * PRIME64_1) - len;
-        xxh_u64 const mix64h2 = (mix64h1 ^ (mix64h1 >> 43)) * PRIME64_4;
-        {   XXH128_hash_t const h128 = { XXH3_avalanche(mix64l2) /*low64*/, XXH3_avalanche(mix64h2) /*high64*/ };
-            return h128;
-    }   }
+        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
+        xxh_u64 const keyed = input_64 ^ bitflip;
+
+        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
+        XXH128_hash_t m128 = XXH_mult64to128(keyed, PRIME64_1 + (len << 2));
+
+        m128.high64 += (m128.low64 << 1);
+        m128.low64  ^= (m128.high64 >> 3);
+
+        m128.low64   = XXH_xorshift64(m128.low64, 35);
+        m128.low64  *= 0x9FB21C651E98DF25ULL;
+        m128.low64   = XXH_xorshift64(m128.low64, 28);
+        m128.high64  = XXH3_avalanche(m128.high64);
+        return m128;
+    }
 }
 
 XXH_FORCE_INLINE XXH128_hash_t
@@ -1313,15 +1735,66 @@ XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
     XXH_ASSERT(9 <= len && len <= 16);
-    {   xxh_u64 const input_lo = XXH_readLE64(input) ^ (XXH_readLE64(secret) + seed);
-        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ (XXH_readLE64(secret+8) - seed);
-        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi, PRIME64_1);
-        xxh_u64 const lenContrib = XXH_mult32to64(len, PRIME32_5);
-        m128.low64 += lenContrib;
-        m128.high64 += input_hi * PRIME64_1;
-        m128.low64  ^= (m128.high64 >> 32);
-        {   XXH128_hash_t h128 = XXH_mult64to128(m128.low64, PRIME64_2);
+    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
+        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
+        xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
+        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, PRIME64_1);
+        /*
+         * Put len in the middle of m128 to ensure that the length gets mixed to
+         * both the low and high bits in the 128x64 multiply below.
+         */
+        m128.low64  += (xxh_u64)(len - 1) << 54;
+        input_hi ^= bitfliph;
+        /*
+         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
+         * add the long product of the low 32 bits of input_hi and PRIME32_2 to
+         * the high 64 bits of m128.
+         *
+         * The best approach to this operation is different on 32-bit and 64-bit.
+         */
+        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
+            /*
+             * 32-bit optimized version, which is more readable.
+             *
+             * On 32-bit, it removes an ADC and delays a dependency between the two
+             * halves of m128.high64, but it generates an extra mask on 64-bit.
+             */
+            m128.high64 += (input_hi & 0xFFFFFFFF00000000) + XXH_mult32to64((xxh_u32)input_hi, PRIME32_2);
+        } else {
+            /*
+             * 64-bit optimized (albeit more confusing) version.
+             *
+             * Uses some properties of addition and multiplication to remove the mask:
+             *
+             * Let:
+             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
+             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
+             *    c = PRIME32_2
+             *
+             *    a + (b * c)
+             * Inverse Property: x + y - x == y
+             *    a + (b * (1 + c - 1))
+             * Distributive Property: x * (y + z) == (x * y) + (x * z)
+             *    a + (b * 1) + (b * (c - 1))
+             * Identity Property: x * 1 == x
+             *    a + b + (b * (c - 1))
+             *
+             * Substitute a, b, and c:
+             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (PRIME32_2 - 1))
+             *
+             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
+             *    input_hi + ((xxh_u64)input_hi.lo * (PRIME32_2 - 1))
+             */
+            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, PRIME32_2 - 1);
+        }
+        /* m128 ^= XXH_swap64(m128 >> 64); */
+        m128.low64  ^= XXH_swap64(m128.high64);
+
+        {   /* 128x64 multiply: h128 = m128 * PRIME64_2; */
+            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, PRIME64_2);
             h128.high64 += m128.high64 * PRIME64_2;
+
             h128.low64   = XXH3_avalanche(h128.low64);
             h128.high64  = XXH3_avalanche(h128.high64);
             return h128;
@@ -1337,52 +1810,18 @@ XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64
     {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
         if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
         if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
-        {   XXH128_hash_t const h128 = { 0, 0 };
+        {   XXH128_hash_t h128;
+            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
+            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
+            h128.low64 = XXH3_avalanche((PRIME64_1 + seed) ^ bitflipl);
+            h128.high64 = XXH3_avalanche((PRIME64_2 - seed) ^ bitfliph);
             return h128;
     }   }
 }
 
-XXH_FORCE_INLINE XXH128_hash_t
-XXH3_hashLong_128b_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
-                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
-{
-    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[ACC_NB] = XXH3_INIT_ACC;
-
-    XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_128bits);
-
-    /* converge into final hash */
-    XXH_STATIC_ASSERT(sizeof(acc) == 64);
-    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
-    {   xxh_u64 const low64 = XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
-        xxh_u64 const high64 = XXH3_mergeAccs(acc, secret + secretSize - sizeof(acc) - XXH_SECRET_MERGEACCS_START, ~((xxh_u64)len * PRIME64_2));
-        XXH128_hash_t const h128 = { low64, high64 };
-        return h128;
-    }
-}
-
-XXH_NO_INLINE XXH128_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
-XXH3_hashLong_128b_defaultSecret(const xxh_u8* input, size_t len)
-{
-    return XXH3_hashLong_128b_internal(input, len, kSecret, sizeof(kSecret));
-}
-
-XXH_NO_INLINE XXH128_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
-XXH3_hashLong_128b_withSecret(const xxh_u8* input, size_t len,
-                              const xxh_u8* secret, size_t secretSize)
-{
-    return XXH3_hashLong_128b_internal(input, len, secret, secretSize);
-}
-
-XXH_NO_INLINE XXH128_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
-XXH3_hashLong_128b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
-{
-    XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
-    if (seed == 0) return XXH3_hashLong_128b_defaultSecret(input, len);
-    XXH3_initCustomSecret(secret, seed);
-    return XXH3_hashLong_128b_internal(input, len, secret, sizeof(secret));
-}
-
-
+/*
+ * A bit slower than XXH3_mix16B, but handles multiply by zero better.
+ */
 XXH_FORCE_INLINE XXH128_hash_t
 XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2, const xxh_u8* secret, XXH64_hash_t seed)
 {
@@ -1393,6 +1832,36 @@ XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2, c
     return acc;
 }
 
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   XXH128_hash_t acc;
+        acc.low64 = len * PRIME64_1;
+        acc.high64 = 0;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
+                }
+                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
+            }
+            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
+        }
+        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
+        {   xxh_u64 const low64 = acc.low64 + acc.high64;
+            xxh_u64 const high64 = (acc.low64 * PRIME64_1) + (acc.high64 * PRIME64_4) + ((len - seed) * PRIME64_2);
+            XXH128_hash_t const h128 = { XXH3_avalanche(low64), (XXH64_hash_t)0 - XXH3_avalanche(high64) };
+            return h128;
+        }
+    }
+}
+
 XXH_NO_INLINE XXH128_hash_t
 XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                        const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
@@ -1426,36 +1895,59 @@ XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
     }
 }
 
-
 XXH_FORCE_INLINE XXH128_hash_t
-XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
-                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
-                      XXH64_hash_t seed)
+XXH3_hashLong_128b_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
+                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
 {
-    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
-    XXH_ASSERT(16 < len && len <= 128);
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[ACC_NB] = XXH3_INIT_ACC;
 
-    {   XXH128_hash_t acc;
-        acc.low64 = len * PRIME64_1;
-        acc.high64 = 0;
-        if (len > 32) {
-            if (len > 64) {
-                if (len > 96) {
-                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
-                }
-                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
-            }
-            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
-        }
-        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
-        {   xxh_u64 const low64 = acc.low64 + acc.high64;
-            xxh_u64 const high64 = (acc.low64 * PRIME64_1) + (acc.high64 * PRIME64_4) + ((len - seed) * PRIME64_2);
-            XXH128_hash_t const h128 = { XXH3_avalanche(low64), (XXH64_hash_t)0 - XXH3_avalanche(high64) };
-            return h128;
-        }
+    XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_128bits);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    {   xxh_u64 const low64 = XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
+        xxh_u64 const high64 = XXH3_mergeAccs(acc, secret + secretSize - sizeof(acc) - XXH_SECRET_MERGEACCS_START, ~((xxh_u64)len * PRIME64_2));
+        XXH128_hash_t const h128 = { low64, high64 };
+        return h128;
     }
 }
 
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_defaultSecret(const xxh_u8* input, size_t len)
+{
+    return XXH3_hashLong_128b_internal(input, len, kSecret, sizeof(kSecret));
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSecret(const xxh_u8* input, size_t len,
+                              const xxh_u8* secret, size_t secretSize)
+{
+    return XXH3_hashLong_128b_internal(input, len, secret, secretSize);
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
+{
+    XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+    if (seed == 0) return XXH3_hashLong_128b_defaultSecret(input, len);
+    XXH3_initCustomSecret(secret, seed);
+    return XXH3_hashLong_128b_internal(input, len, secret, sizeof(secret));
+}
+
+
 XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* input, size_t len)
 {
     if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, kSecret, 0);
@@ -1468,10 +1960,12 @@ XXH_PUBLIC_API XXH128_hash_t
 XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
 {
     XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
-    /* if an action must be taken should `secret` conditions not be respected,
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
      * it should be done here.
      * For now, it's a contract pre-condition.
-     * Adding a check and a branch here would cost performance at every hash */
+     * Adding a check and a branch here would cost performance at every hash.
+     */
      if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
      if (len <= 128) return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
      if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
@@ -1562,7 +2056,7 @@ XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
 
 /* 128-bit utility functions */
 
-#include <string.h>   /* memcmp */
+#include <string.h>   /* memcmp, memcpy */
 
 /* return : 1 is equal, 0 if different */
 XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
@@ -1608,6 +2102,11 @@ XXH128_hashFromCanonical(const XXH128_canonical_t* src)
     return h;
 }
 
+/* Pop our optimization override from above */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC pop_options
+#endif
 
-
-#endif  /* XXH3_H */
+#endif  /* XXH3_H_1397135465 */
diff --git a/mupen64plus-core/subprojects/xxhash/xxhash.c b/mupen64plus-core/subprojects/xxhash/xxhash.c
deleted file mode 100644
index 3f49b7d1..00000000
--- a/mupen64plus-core/subprojects/xxhash/xxhash.c
+++ /dev/null
@@ -1,1110 +0,0 @@
-/*
-*  xxHash - Fast Hash algorithm
-*  Copyright (C) 2012-2016, Yann Collet
-*
-*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions are
-*  met:
-*
-*  * Redistributions of source code must retain the above copyright
-*  notice, this list of conditions and the following disclaimer.
-*  * Redistributions in binary form must reproduce the above
-*  copyright notice, this list of conditions and the following disclaimer
-*  in the documentation and/or other materials provided with the
-*  distribution.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*  You can contact the author at :
-*  - xxHash homepage: http://www.xxhash.com
-*  - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
-
-
-/* since xxhash.c can be included (via XXH_INLINE_ALL),
- * it's good practice to protect it with guard
- * in case of multiples inclusions */
-#ifndef XXHASH_C_01393879
-#define XXHASH_C_01393879
-
-/* *************************************
-*  Tuning parameters
-***************************************/
-/*!XXH_FORCE_MEMORY_ACCESS :
- * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
- * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
- * The below switch allow to select different access method for improved performance.
- * Method 0 (default) : use `memcpy()`. Safe and portable.
- * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
- *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
- * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
- *            It can generate buggy code on targets which do not support unaligned memory accesses.
- *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
- * See http://stackoverflow.com/a/32095106/646947 for details.
- * Prefer these methods in priority order (0 > 1 > 2)
- */
-#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
-#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
-#    define XXH_FORCE_MEMORY_ACCESS 2
-#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
-  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
-#    define XXH_FORCE_MEMORY_ACCESS 1
-#  endif
-#endif
-
-/*!XXH_ACCEPT_NULL_INPUT_POINTER :
- * If input pointer is NULL, xxHash default behavior is to dereference it, triggering a segfault.
- * When this macro is enabled, xxHash actively checks input for null pointer.
- * It it is, result for null input pointers is the same as a null-length input.
- */
-#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
-#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
-#endif
-
-/*!XXH_FORCE_ALIGN_CHECK :
- * This is a minor performance trick, only useful with lots of very small keys.
- * It means : check for aligned/unaligned input.
- * The check costs one initial branch per hash;
- * set it to 0 when the input is guaranteed to be aligned,
- * or when alignment doesn't matter for performance.
- */
-#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
-#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
-#    define XXH_FORCE_ALIGN_CHECK 0
-#  else
-#    define XXH_FORCE_ALIGN_CHECK 1
-#  endif
-#endif
-
-/*!XXH_REROLL:
- * Whether to reroll XXH32_finalize, and XXH64_finalize,
- * instead of using an unrolled jump table/if statement loop.
- *
- * This is automatically defined on -Os/-Oz on GCC and Clang. */
-#ifndef XXH_REROLL
-#  if defined(__OPTIMIZE_SIZE__)
-#    define XXH_REROLL 1
-#  else
-#    define XXH_REROLL 0
-#  endif
-#endif
-
-/* *************************************
-*  Includes & Memory related functions
-***************************************/
-/*! Modify the local functions below should you wish to use some other memory routines
-*   for malloc(), free() */
-#include <stdlib.h>
-static void* XXH_malloc(size_t s) { return malloc(s); }
-static void  XXH_free  (void* p)  { free(p); }
-/*! and for memcpy() */
-#include <string.h>
-static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
-
-#include <limits.h>   /* ULLONG_MAX */
-
-#define XXH_STATIC_LINKING_ONLY
-#include "xxhash.h"
-
-
-/* *************************************
-*  Compiler Specific Options
-***************************************/
-#ifdef _MSC_VER    /* Visual Studio */
-#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
-#  define XXH_FORCE_INLINE static __forceinline
-#  define XXH_NO_INLINE static __declspec(noinline)
-#else
-#  if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
-#    ifdef __GNUC__
-#      define XXH_FORCE_INLINE static inline __attribute__((always_inline))
-#      define XXH_NO_INLINE static __attribute__((noinline))
-#    else
-#      define XXH_FORCE_INLINE static inline
-#      define XXH_NO_INLINE static
-#    endif
-#  else
-#    define XXH_FORCE_INLINE static
-#    define XXH_NO_INLINE static
-#  endif /* __STDC_VERSION__ */
-#endif
-
-
-
-/* *************************************
-*  Debug
-***************************************/
-/* DEBUGLEVEL is expected to be defined externally,
- * typically through compiler command line.
- * Value must be a number. */
-#ifndef DEBUGLEVEL
-#  define DEBUGLEVEL 0
-#endif
-
-#if (DEBUGLEVEL>=1)
-#  include <assert.h>   /* note : can still be disabled with NDEBUG */
-#  define XXH_ASSERT(c)   assert(c)
-#else
-#  define XXH_ASSERT(c)   ((void)0)
-#endif
-
-/* note : use after variable declarations */
-#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }
-
-
-/* *************************************
-*  Basic Types
-***************************************/
-#if !defined (__VMS) \
- && (defined (__cplusplus) \
- || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
-# include <stdint.h>
-  typedef uint8_t  xxh_u8;
-#else
-  typedef unsigned char      xxh_u8;
-#endif
-typedef XXH32_hash_t xxh_u32;
-
-
-/* ===   Memory access   === */
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
-static xxh_u32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-static xxh_u32 XXH_read32(const void* memPtr)
-{
-    xxh_u32 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-
-/* ===   Endianess   === */
-typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
-
-/* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line */
-#ifndef XXH_CPU_LITTLE_ENDIAN
-#  if defined(_WIN32) /* Windows is always little endian */ \
-     || defined(__LITTLE_ENDIAN__) \
-     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
-#    define XXH_CPU_LITTLE_ENDIAN 1
-#  elif defined(__BIG_ENDIAN__) \
-     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
-#    define XXH_CPU_LITTLE_ENDIAN 0
-#  else
-static int XXH_isLittleEndian(void)
-{
-    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
-    return one.c[0];
-}
-#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
-#  endif
-#endif
-
-
-
-
-/* ****************************************
-*  Compiler-specific Functions and Macros
-******************************************/
-#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-
-#ifndef __has_builtin
-#  define __has_builtin(x) 0
-#endif
-
-#if !defined(NO_CLANG_BUILTIN) && __has_builtin(__builtin_rotateleft32) && __has_builtin(__builtin_rotateleft64)
-#  define XXH_rotl32 __builtin_rotateleft32
-#  define XXH_rotl64 __builtin_rotateleft64
-/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
-#elif defined(_MSC_VER)
-#  define XXH_rotl32(x,r) _rotl(x,r)
-#  define XXH_rotl64(x,r) _rotl64(x,r)
-#else
-#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
-#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
-#endif
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap32 _byteswap_ulong
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap32 __builtin_bswap32
-#else
-static xxh_u32 XXH_swap32 (xxh_u32 x)
-{
-    return  ((x << 24) & 0xff000000 ) |
-            ((x <<  8) & 0x00ff0000 ) |
-            ((x >>  8) & 0x0000ff00 ) |
-            ((x >> 24) & 0x000000ff );
-}
-#endif
-
-
-/* ***************************
-*  Memory reads
-*****************************/
-typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
-
-XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
-}
-
-static xxh_u32 XXH_readBE32(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
-}
-
-XXH_FORCE_INLINE xxh_u32
-XXH_readLE32_align(const void* ptr, XXH_alignment align)
-{
-    if (align==XXH_unaligned) {
-        return XXH_readLE32(ptr);
-    } else {
-        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
-    }
-}
-
-
-/* *************************************
-*  Misc
-***************************************/
-XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
-
-
-/* *******************************************************************
-*  32-bit hash functions
-*********************************************************************/
-static const xxh_u32 PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
-static const xxh_u32 PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
-static const xxh_u32 PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */
-static const xxh_u32 PRIME32_4 = 0x27D4EB2FU;   /* 0b00100111110101001110101100101111 */
-static const xxh_u32 PRIME32_5 = 0x165667B1U;   /* 0b00010110010101100110011110110001 */
-
-static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
-{
-    acc += input * PRIME32_2;
-    acc  = XXH_rotl32(acc, 13);
-    acc *= PRIME32_1;
-#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
-    /* UGLY HACK:
-     * This inline assembly hack forces acc into a normal register. This is the
-     * only thing that prevents GCC and Clang from autovectorizing the XXH32 loop
-     * (pragmas and attributes don't work for some resason) without globally
-     * disabling SSE4.1.
-     *
-     * The reason we want to avoid vectorization is because despite working on
-     * 4 integers at a time, there are multiple factors slowing XXH32 down on
-     * SSE4:
-     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on newer chips!)
-     *   making it slightly slower to multiply four integers at once compared to four
-     *   integers independently. Even when pmulld was fastest, Sandy/Ivy Bridge, it is
-     *   still not worth it to go into SSE just to multiply unless doing a long operation.
-     *
-     * - Four instructions are required to rotate,
-     *      movqda tmp,  v // not required with VEX encoding
-     *      pslld  tmp, 13 // tmp <<= 13
-     *      psrld  v,   19 // x >>= 19
-     *      por    v,  tmp // x |= tmp
-     *   compared to one for scalar:
-     *      roll   v, 13    // reliably fast across the board
-     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
-     *
-     * - Instruction level parallelism is actually more beneficial here because the
-     *   SIMD actually serializes this operation: While v1 is rotating, v2 can load data,
-     *   while v3 can multiply. SSE forces them to operate together.
-     *
-     * How this hack works:
-     * __asm__(""       // Declare an assembly block but don't declare any instructions
-     *          :       // However, as an Input/Output Operand,
-     *          "+r"    // constrain a read/write operand (+) as a general purpose register (r).
-     *          (acc)   // and set acc as the operand
-     * );
-     *
-     * Because of the 'r', the compiler has promised that seed will be in a
-     * general purpose register and the '+' says that it will be 'read/write',
-     * so it has to assume it has changed. It is like volatile without all the
-     * loads and stores.
-     *
-     * Since the argument has to be in a normal register (not an SSE register),
-     * each time XXH32_round is called, it is impossible to vectorize. */
-    __asm__("" : "+r" (acc));
-#endif
-    return acc;
-}
-
-/* mix all bits */
-static xxh_u32 XXH32_avalanche(xxh_u32 h32)
-{
-    h32 ^= h32 >> 15;
-    h32 *= PRIME32_2;
-    h32 ^= h32 >> 13;
-    h32 *= PRIME32_3;
-    h32 ^= h32 >> 16;
-    return(h32);
-}
-
-#define XXH_get32bits(p) XXH_readLE32_align(p, align)
-
-static xxh_u32
-XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
-{
-#define PROCESS1               \
-    h32 += (*ptr++) * PRIME32_5; \
-    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
-
-#define PROCESS4                         \
-    h32 += XXH_get32bits(ptr) * PRIME32_3; \
-    ptr+=4;                                \
-    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
-
-    /* Compact rerolled version */
-    if (XXH_REROLL) {
-        len &= 15;
-        while (len >= 4) {
-            PROCESS4;
-            len -= 4;
-        }
-        while (len > 0) {
-            PROCESS1;
-            --len;
-        }
-        return XXH32_avalanche(h32);
-    } else {
-         switch(len&15) /* or switch(bEnd - p) */ {
-           case 12:      PROCESS4;
-                         /* fallthrough */
-           case 8:       PROCESS4;
-                         /* fallthrough */
-           case 4:       PROCESS4;
-                         return XXH32_avalanche(h32);
-
-           case 13:      PROCESS4;
-                         /* fallthrough */
-           case 9:       PROCESS4;
-                         /* fallthrough */
-           case 5:       PROCESS4;
-                         PROCESS1;
-                         return XXH32_avalanche(h32);
-
-           case 14:      PROCESS4;
-                         /* fallthrough */
-           case 10:      PROCESS4;
-                         /* fallthrough */
-           case 6:       PROCESS4;
-                         PROCESS1;
-                         PROCESS1;
-                         return XXH32_avalanche(h32);
-
-           case 15:      PROCESS4;
-                         /* fallthrough */
-           case 11:      PROCESS4;
-                         /* fallthrough */
-           case 7:       PROCESS4;
-                         /* fallthrough */
-           case 3:       PROCESS1;
-                         /* fallthrough */
-           case 2:       PROCESS1;
-                         /* fallthrough */
-           case 1:       PROCESS1;
-                         /* fallthrough */
-           case 0:       return XXH32_avalanche(h32);
-        }
-        XXH_ASSERT(0);
-        return h32;   /* reaching this point is deemed impossible */
-    }
-}
-
-XXH_FORCE_INLINE xxh_u32
-XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
-{
-    const xxh_u8* bEnd = input + len;
-    xxh_u32 h32;
-
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-    if (input==NULL) {
-        len=0;
-        bEnd=input=(const xxh_u8*)(size_t)16;
-    }
-#endif
-
-    if (len>=16) {
-        const xxh_u8* const limit = bEnd - 15;
-        xxh_u32 v1 = seed + PRIME32_1 + PRIME32_2;
-        xxh_u32 v2 = seed + PRIME32_2;
-        xxh_u32 v3 = seed + 0;
-        xxh_u32 v4 = seed - PRIME32_1;
-
-        do {
-            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
-            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
-            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
-            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
-        } while (input < limit);
-
-        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
-            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
-    } else {
-        h32  = seed + PRIME32_5;
-    }
-
-    h32 += (xxh_u32)len;
-
-    return XXH32_finalize(h32, input, len&15, align);
-}
-
-
-XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH32_state_t state;
-    XXH32_reset(&state, seed);
-    XXH32_update(&state, (const xxh_u8*)input, len);
-    return XXH32_digest(&state);
-
-#else
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
-            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
-    }   }
-
-    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
-#endif
-}
-
-
-
-/*======   Hash streaming   ======*/
-
-XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
-{
-    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
-{
-    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state));
-    state.v1 = seed + PRIME32_1 + PRIME32_2;
-    state.v2 = seed + PRIME32_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME32_1;
-    /* do not write into reserved, planned to be removed in a future version */
-    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH_errorcode
-XXH32_update(XXH32_state_t* state, const void* input, size_t len)
-{
-    if (input==NULL)
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-        return XXH_OK;
-#else
-        return XXH_ERROR;
-#endif
-
-    {   const xxh_u8* p = (const xxh_u8*)input;
-        const xxh_u8* const bEnd = p + len;
-
-        state->total_len_32 += (XXH32_hash_t)len;
-        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
-
-        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
-            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
-            state->memsize += (XXH32_hash_t)len;
-            return XXH_OK;
-        }
-
-        if (state->memsize) {   /* some data left from previous update */
-            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
-            {   const xxh_u32* p32 = state->mem32;
-                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
-                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
-                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
-                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
-            }
-            p += 16-state->memsize;
-            state->memsize = 0;
-        }
-
-        if (p <= bEnd-16) {
-            const xxh_u8* const limit = bEnd - 16;
-            xxh_u32 v1 = state->v1;
-            xxh_u32 v2 = state->v2;
-            xxh_u32 v3 = state->v3;
-            xxh_u32 v4 = state->v4;
-
-            do {
-                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
-                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
-                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
-                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
-            } while (p<=limit);
-
-            state->v1 = v1;
-            state->v2 = v2;
-            state->v3 = v3;
-            state->v4 = v4;
-        }
-
-        if (p < bEnd) {
-            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
-            state->memsize = (unsigned)(bEnd-p);
-        }
-    }
-
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
-{
-    xxh_u32 h32;
-
-    if (state->large_len) {
-        h32 = XXH_rotl32(state->v1, 1)
-            + XXH_rotl32(state->v2, 7)
-            + XXH_rotl32(state->v3, 12)
-            + XXH_rotl32(state->v4, 18);
-    } else {
-        h32 = state->v3 /* == seed */ + PRIME32_5;
-    }
-
-    h32 += state->total_len_32;
-
-    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
-}
-
-
-/*======   Canonical representation   ======*/
-
-/*! Default XXH result types are basic unsigned 32 and 64 bits.
-*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
-*   These functions allow transformation of hash result into and from its canonical format.
-*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.
-*/
-
-XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
-{
-    return XXH_readBE32(src);
-}
-
-
-#ifndef XXH_NO_LONG_LONG
-
-/* *******************************************************************
-*  64-bit hash functions
-*********************************************************************/
-
-/*======   Memory access   ======*/
-
-typedef XXH64_hash_t xxh_u64;
-
-
-/*! XXH_REROLL_XXH64:
- * Whether to reroll the XXH64_finalize() loop.
- *
- * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a performance gain
- * on 64-bit hosts, as only one jump is required.
- *
- * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit registers,
- * and 64-bit arithmetic needs to be simulated, it isn't beneficial to unroll. The code becomes
- * ridiculously large (the largest function in the binary on i386!), and rerolling it saves
- * anywhere from 3kB to 20kB. It is also slightly faster because it fits into cache better
- * and is more likely to be inlined by the compiler.
- *
- * If XXH_REROLL is defined, this is ignored and the loop is always rerolled. */
-#ifndef XXH_REROLL_XXH64
-#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
-   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
-     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
-     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
-     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
-   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
-#    define XXH_REROLL_XXH64 1
-#  else
-#    define XXH_REROLL_XXH64 0
-#  endif
-#endif /* !defined(XXH_REROLL_XXH64) */
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
-static xxh_u64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-
-static xxh_u64 XXH_read64(const void* memPtr)
-{
-    xxh_u64 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap64 _byteswap_uint64
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap64 __builtin_bswap64
-#else
-static xxh_u64 XXH_swap64 (xxh_u64 x)
-{
-    return  ((x << 56) & 0xff00000000000000ULL) |
-            ((x << 40) & 0x00ff000000000000ULL) |
-            ((x << 24) & 0x0000ff0000000000ULL) |
-            ((x << 8)  & 0x000000ff00000000ULL) |
-            ((x >> 8)  & 0x00000000ff000000ULL) |
-            ((x >> 24) & 0x0000000000ff0000ULL) |
-            ((x >> 40) & 0x000000000000ff00ULL) |
-            ((x >> 56) & 0x00000000000000ffULL);
-}
-#endif
-
-XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
-}
-
-static xxh_u64 XXH_readBE64(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
-}
-
-XXH_FORCE_INLINE xxh_u64
-XXH_readLE64_align(const void* ptr, XXH_alignment align)
-{
-    if (align==XXH_unaligned)
-        return XXH_readLE64(ptr);
-    else
-        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
-}
-
-
-/*======   xxh64   ======*/
-
-static const xxh_u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
-static const xxh_u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
-static const xxh_u64 PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
-static const xxh_u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
-static const xxh_u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */
-
-static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
-{
-    acc += input * PRIME64_2;
-    acc  = XXH_rotl64(acc, 31);
-    acc *= PRIME64_1;
-    return acc;
-}
-
-static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
-{
-    val  = XXH64_round(0, val);
-    acc ^= val;
-    acc  = acc * PRIME64_1 + PRIME64_4;
-    return acc;
-}
-
-static xxh_u64 XXH64_avalanche(xxh_u64 h64)
-{
-    h64 ^= h64 >> 33;
-    h64 *= PRIME64_2;
-    h64 ^= h64 >> 29;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
-    return h64;
-}
-
-
-#define XXH_get64bits(p) XXH_readLE64_align(p, align)
-
-static xxh_u64
-XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
-{
-#define PROCESS1_64            \
-    h64 ^= (*ptr++) * PRIME64_5; \
-    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
-
-#define PROCESS4_64          \
-    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * PRIME64_1; \
-    ptr+=4;                    \
-    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
-
-#define PROCESS8_64 {        \
-    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
-    ptr+=8;                    \
-    h64 ^= k1;               \
-    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
-}
-
-    /* Rerolled version for 32-bit targets is faster and much smaller. */
-    if (XXH_REROLL || XXH_REROLL_XXH64) {
-        len &= 31;
-        while (len >= 8) {
-            PROCESS8_64;
-            len -= 8;
-        }
-        if (len >= 4) {
-            PROCESS4_64;
-            len -= 4;
-        }
-        while (len > 0) {
-            PROCESS1_64;
-            --len;
-        }
-         return  XXH64_avalanche(h64);
-    } else {
-        switch(len & 31) {
-           case 24: PROCESS8_64;
-                         /* fallthrough */
-           case 16: PROCESS8_64;
-                         /* fallthrough */
-           case  8: PROCESS8_64;
-                    return XXH64_avalanche(h64);
-
-           case 28: PROCESS8_64;
-                         /* fallthrough */
-           case 20: PROCESS8_64;
-                         /* fallthrough */
-           case 12: PROCESS8_64;
-                         /* fallthrough */
-           case  4: PROCESS4_64;
-                    return XXH64_avalanche(h64);
-
-           case 25: PROCESS8_64;
-                         /* fallthrough */
-           case 17: PROCESS8_64;
-                         /* fallthrough */
-           case  9: PROCESS8_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 29: PROCESS8_64;
-                         /* fallthrough */
-           case 21: PROCESS8_64;
-                         /* fallthrough */
-           case 13: PROCESS8_64;
-                         /* fallthrough */
-           case  5: PROCESS4_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 26: PROCESS8_64;
-                         /* fallthrough */
-           case 18: PROCESS8_64;
-                         /* fallthrough */
-           case 10: PROCESS8_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 30: PROCESS8_64;
-                         /* fallthrough */
-           case 22: PROCESS8_64;
-                         /* fallthrough */
-           case 14: PROCESS8_64;
-                         /* fallthrough */
-           case  6: PROCESS4_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 27: PROCESS8_64;
-                         /* fallthrough */
-           case 19: PROCESS8_64;
-                         /* fallthrough */
-           case 11: PROCESS8_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 31: PROCESS8_64;
-                         /* fallthrough */
-           case 23: PROCESS8_64;
-                         /* fallthrough */
-           case 15: PROCESS8_64;
-                         /* fallthrough */
-           case  7: PROCESS4_64;
-                         /* fallthrough */
-           case  3: PROCESS1_64;
-                         /* fallthrough */
-           case  2: PROCESS1_64;
-                         /* fallthrough */
-           case  1: PROCESS1_64;
-                         /* fallthrough */
-           case  0: return XXH64_avalanche(h64);
-        }
-    }
-    /* impossible to reach */
-    XXH_ASSERT(0);
-    return 0;  /* unreachable, but some compilers complain without it */
-}
-
-XXH_FORCE_INLINE xxh_u64
-XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
-{
-    const xxh_u8* bEnd = input + len;
-    xxh_u64 h64;
-
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-    if (input==NULL) {
-        len=0;
-        bEnd=input=(const xxh_u8*)(size_t)32;
-    }
-#endif
-
-    if (len>=32) {
-        const xxh_u8* const limit = bEnd - 32;
-        xxh_u64 v1 = seed + PRIME64_1 + PRIME64_2;
-        xxh_u64 v2 = seed + PRIME64_2;
-        xxh_u64 v3 = seed + 0;
-        xxh_u64 v4 = seed - PRIME64_1;
-
-        do {
-            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
-            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
-            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
-            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
-        } while (input<=limit);
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-
-    } else {
-        h64  = seed + PRIME64_5;
-    }
-
-    h64 += (xxh_u64) len;
-
-    return XXH64_finalize(h64, input, len, align);
-}
-
-
-XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH64_state_t state;
-    XXH64_reset(&state, seed);
-    XXH64_update(&state, (const xxh_u8*)input, len);
-    return XXH64_digest(&state);
-
-#else
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
-            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
-    }   }
-
-    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
-
-#endif
-}
-
-/*======   Hash Streaming   ======*/
-
-XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
-{
-    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
-{
-    XXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state));
-    state.v1 = seed + PRIME64_1 + PRIME64_2;
-    state.v2 = seed + PRIME64_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME64_1;
-     /* do not write into reserved64, might be removed in a future version */
-    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API XXH_errorcode
-XXH64_update (XXH64_state_t* state, const void* input, size_t len)
-{
-    if (input==NULL)
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-        return XXH_OK;
-#else
-        return XXH_ERROR;
-#endif
-
-    {   const xxh_u8* p = (const xxh_u8*)input;
-        const xxh_u8* const bEnd = p + len;
-
-        state->total_len += len;
-
-        if (state->memsize + len < 32) {  /* fill in tmp buffer */
-            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
-            state->memsize += (xxh_u32)len;
-            return XXH_OK;
-        }
-
-        if (state->memsize) {   /* tmp buffer is full */
-            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
-            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
-            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
-            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
-            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
-            p += 32-state->memsize;
-            state->memsize = 0;
-        }
-
-        if (p+32 <= bEnd) {
-            const xxh_u8* const limit = bEnd - 32;
-            xxh_u64 v1 = state->v1;
-            xxh_u64 v2 = state->v2;
-            xxh_u64 v3 = state->v3;
-            xxh_u64 v4 = state->v4;
-
-            do {
-                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
-                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
-                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
-                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
-            } while (p<=limit);
-
-            state->v1 = v1;
-            state->v2 = v2;
-            state->v3 = v3;
-            state->v4 = v4;
-        }
-
-        if (p < bEnd) {
-            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
-            state->memsize = (unsigned)(bEnd-p);
-        }
-    }
-
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
-{
-    xxh_u64 h64;
-
-    if (state->total_len >= 32) {
-        xxh_u64 const v1 = state->v1;
-        xxh_u64 const v2 = state->v2;
-        xxh_u64 const v3 = state->v3;
-        xxh_u64 const v4 = state->v4;
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-    } else {
-        h64  = state->v3 /*seed*/ + PRIME64_5;
-    }
-
-    h64 += (xxh_u64) state->total_len;
-
-    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
-}
-
-
-/*====== Canonical representation   ======*/
-
-XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
-{
-    return XXH_readBE64(src);
-}
-
-
-
-/* *********************************************************************
-*  XXH3
-*  New generation hash designed for speed on small keys and vectorization
-************************************************************************ */
-
-#include "xxh3.h"
-
-
-#endif  /* XXH_NO_LONG_LONG */
-
-#endif  /* XXHASH_C_01393879 */
diff --git a/mupen64plus-core/subprojects/xxhash/xxhash.h b/mupen64plus-core/subprojects/xxhash/xxhash.h
index 60435bed..f711b34e 100644
--- a/mupen64plus-core/subprojects/xxhash/xxhash.h
+++ b/mupen64plus-core/subprojects/xxhash/xxhash.h
@@ -1,40 +1,42 @@
 /*
-   xxHash - Extremely Fast Hash algorithm
-   Header File
-   Copyright (C) 2012-2016, Yann Collet.
-
-   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are
-   met:
-
-       * Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
-       * Redistributions in binary form must reproduce the above
-   copyright notice, this list of conditions and the following disclaimer
-   in the documentation and/or other materials provided with the
-   distribution.
-
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-   You can contact the author at :
-   - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
+ * xxHash - Extremely Fast Hash algorithm
+ * Header File
+ * Copyright (C) 2012-present, Yann Collet.
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
 
-/* Notice extracted from xxHash homepage :
+/* TODO: update */
+/* Notice extracted from xxHash homepage:
 
-xxHash is an extremely fast Hash algorithm, running at RAM speed limits.
+xxHash is an extremely fast hash algorithm, running at RAM speed limits.
 It also successfully passes all tests from the SMHasher suite.
 
 Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)
@@ -49,17 +51,19 @@ Lookup3         1.2 GB/s      9       Bob Jenkins
 SuperFastHash   1.2 GB/s      1       Paul Hsieh
 CityHash64      1.05 GB/s    10       Pike & Alakuijala
 FNV             0.55 GB/s     5       Fowler, Noll, Vo
-CRC32           0.43 GB/s    9
+CRC32           0.43 GB/s     9
 MD5-32          0.33 GB/s    10       Ronald L. Rivest
 SHA1-32         0.28 GB/s    10
 
-Note : other CRC32 implementations can be over 40x faster than SMHasher's:
-http://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735
-
 Q.Score is a measure of quality of the hash function.
 It depends on successfully passing SMHasher test set.
 10 is a perfect score.
 
+Note: SMHasher's CRC32 implementation is not the fastest one.
+Other speed-oriented implementations can be faster,
+especially in combination with PCLMUL instruction:
+https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735
+
 A 64-bit version, named XXH64, is available since r35.
 It offers much better speed, but for 64-bit applications only.
 Name     Speed on 64 bits    Speed on 32 bits
@@ -67,40 +71,38 @@ XXH64       13.8 GB/s            1.9 GB/s
 XXH32        6.8 GB/s            6.0 GB/s
 */
 
-#ifndef XXHASH_H_5627135585666179
-#define XXHASH_H_5627135585666179 1
-
 #if defined (__cplusplus)
 extern "C" {
 #endif
 
-
 /* ****************************
-*  Definitions
-******************************/
-#include <stddef.h>   /* size_t */
-typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
-
-
-/* ****************************
- *  API modifier
+ *  INLINE mode
  ******************************/
-/** XXH_INLINE_ALL (and XXH_PRIVATE_API)
- *  This build macro includes xxhash functions in `static` mode
- *  in order to inline them, and remove their symbol from the public list.
- *  Inlining offers great performance improvement on small keys,
- *  and dramatic ones when length is expressed as a compile-time constant.
- *  See https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html .
- *  Methodology :
+/*!
+ * XXH_INLINE_ALL (and XXH_PRIVATE_API)
+ * Use these build macros to inline xxhash into the target unit.
+ * Inlining improves performance on small inputs, especially when the length is
+ * expressed as a compile-time constant:
+ *
+ *      https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
+ *
+ * It also keeps xxHash symbols private to the unit, so they are not exported.
+ *
+ * Usage:
  *     #define XXH_INLINE_ALL
  *     #include "xxhash.h"
- * `xxhash.c` is automatically included.
- *  It's not useful to compile and link it as a separate object.
+ *
+ * Do not compile and link xxhash.o as a separate object, as it is not useful.
  */
-#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
-#  ifndef XXH_STATIC_LINKING_ONLY
-#    define XXH_STATIC_LINKING_ONLY
-#  endif
+#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
+    && !defined(XXH_INLINE_ALL_31684351384)
+   /* this section should be traversed only once */
+#  define XXH_INLINE_ALL_31684351384
+   /* give access to the advanced API, required to compile implementations */
+#  undef XXH_STATIC_LINKING_ONLY   /* avoid macro redef */
+#  define XXH_STATIC_LINKING_ONLY
+   /* make all functions private */
+#  undef XXH_PUBLIC_API
 #  if defined(__GNUC__)
 #    define XXH_PUBLIC_API static __inline __attribute__((unused))
 #  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
@@ -108,10 +110,63 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 #  elif defined(_MSC_VER)
 #    define XXH_PUBLIC_API static __inline
 #  else
-     /* this version may generate warnings for unused static functions */
+     /* note: this version may generate warnings for unused static functions */
 #    define XXH_PUBLIC_API static
 #  endif
-#else
+
+   /*
+    * This part deals with the special case where a unit wants to inline xxHash,
+    * but "xxhash.h" has previously been included without XXH_INLINE_ALL, such
+    * as part of some previously included *.h header file.
+    * Without further action, the new include would just be ignored,
+    * and functions would effectively _not_ be inlined (silent failure).
+    * The following macros solve this situation by prefixing all inlined names,
+    * avoiding naming collision with previous inclusions.
+    */
+#  ifdef XXH_NAMESPACE
+#    error "XXH_INLINE_ALL with XXH_NAMESPACE is not supported"
+     /*
+      * Note: Alternative: #undef all symbols (it's a pretty large list).
+      * Without #error: it compiles, but functions are actually not inlined.
+      */
+#  endif
+#  define XXH_NAMESPACE XXH_INLINE_
+   /*
+    * Some identifiers (enums, type names) are not symbols, but they must
+    * still be renamed to avoid redeclaration.
+    * Alternative solution: do not redeclare them.
+    * However, this requires some #ifdefs, and is a more dispersed action.
+    * Meanwhile, renaming can be achieved in a single block
+    */
+#  define XXH_IPREF(Id)   XXH_INLINE_ ## Id
+#  define XXH_OK XXH_IPREF(XXH_OK)
+#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
+#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
+#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
+#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
+#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
+#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
+#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
+#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
+#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
+#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
+#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
+#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
+   /* Ensure the header is parsed again, even if it was previously included */
+#  undef XXHASH_H_5627135585666179
+#  undef XXHASH_H_STATIC_13879238742
+#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
+
+
+
+/* ****************************************************************
+ *  Stable API
+ *****************************************************************/
+#ifndef XXHASH_H_5627135585666179
+#define XXHASH_H_5627135585666179 1
+
+/* specific declaration modes for Windows */
+#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
 #  if defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
 #    ifdef XXH_EXPORT
 #      define XXH_PUBLIC_API __declspec(dllexport)
@@ -121,18 +176,20 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 #  else
 #    define XXH_PUBLIC_API   /* do nothing */
 #  endif
-#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
+#endif
 
-/*! XXH_NAMESPACE, aka Namespace Emulation :
+/*!
+ * XXH_NAMESPACE, aka Namespace Emulation:
  *
- * If you want to include _and expose_ xxHash functions from within your own library,
- * but also want to avoid symbol collisions with other libraries which may also include xxHash,
+ * If you want to include _and expose_ xxHash functions from within your own
+ * library, but also want to avoid symbol collisions with other libraries which
+ * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix
+ * any public symbol from xxhash library with the value of XXH_NAMESPACE
+ * (therefore, avoid empty or numeric values).
  *
- * you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library
- * with the value of XXH_NAMESPACE (therefore, avoid NULL and numeric values).
- *
- * Note that no change is required within the calling program as long as it includes `xxhash.h` :
- * regular symbol name will be automatically translated by this header.
+ * Note that no change is required within the calling program as long as it
+ * includes `xxhash.h`: Regular symbol names will be automatically translated
+ * by this header.
  */
 #ifdef XXH_NAMESPACE
 #  define XXH_CAT(A,B) A##B
@@ -164,11 +221,18 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 ***************************************/
 #define XXH_VERSION_MAJOR    0
 #define XXH_VERSION_MINOR    7
-#define XXH_VERSION_RELEASE  2
+#define XXH_VERSION_RELEASE  3
 #define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
 XXH_PUBLIC_API unsigned XXH_versionNumber (void);
 
 
+/* ****************************
+*  Definitions
+******************************/
+#include <stddef.h>   /* size_t */
+typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
+
+
 /*-**********************************************************************
 *  32-bit hash
 ************************************************************************/
@@ -185,39 +249,43 @@ XXH_PUBLIC_API unsigned XXH_versionNumber (void);
 #     if ULONG_MAX == 0xFFFFFFFFUL
         typedef unsigned long XXH32_hash_t;
 #     else
-#       error "unsupported platform : need a 32-bit type"
+#       error "unsupported platform: need a 32-bit type"
 #     endif
 #   endif
 #endif
 
-/*! XXH32() :
-    Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
-    The memory between input & input+length must be valid (allocated and read-accessible).
-    "seed" can be used to alter the result predictably.
-    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s */
+/*!
+ * XXH32():
+ *  Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
+ *  The memory between input & input+length must be valid (allocated and read-accessible).
+ *  "seed" can be used to alter the result predictably.
+ *  Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s
+ */
 XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);
 
-/*======   Streaming   ======*/
+/*******   Streaming   *******/
 
 /*
  * Streaming functions generate the xxHash value from an incrememtal input.
  * This method is slower than single-call functions, due to state management.
  * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
  *
- * XXH state must first be allocated, using XXH*_createState() .
+ * An XXH state must first be allocated using `XXH*_createState()`.
  *
- * Start a new hash by initializing state with a seed, using XXH*_reset().
+ * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
  *
- * Then, feed the hash state by calling XXH*_update() as many times as necessary.
- * The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.
+ * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
  *
- * Finally, a hash value can be produced anytime, by using XXH*_digest().
+ * The function returns an error code, with 0 meaning OK, and any other value
+ * meaning there is an error.
+ *
+ * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
  * This function returns the nn-bits hash as an int or long long.
  *
- * It's still possible to continue inserting input into the hash state after a digest,
- * and generate some new hash values later on, by invoking again XXH*_digest().
+ * It's still possible to continue inserting input into the hash state after a
+ * digest, and generate new hash values later on by invoking `XXH*_digest()`.
  *
- * When done, release the state, using XXH*_freeState().
+ * When done, release the state using `XXH*_freeState()`.
  */
 
 typedef struct XXH32_state_s XXH32_state_t;   /* incomplete type */
@@ -229,21 +297,25 @@ XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t
 XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
 XXH_PUBLIC_API XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 
-/* Default return values from XXH functions are basic unsigned 32 and 64 bits.
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
  * This the simplest and fastest format for further post-processing.
- * However, this leaves open the question of what is the order of bytes,
- * since little and big endian conventions will write the same number differently.
  *
- * The canonical representation settles this issue,
- * by mandating big-endian convention,
- * aka, the same convention as human-readable numbers (large digits first).
- * When writing hash values to storage, sending them over a network, or printing them,
- * it's highly recommended to use the canonical representation,
- * to ensure portability across a wider range of systems, present and future.
+ * However, this leaves open the question of what is the order on the byte level,
+ * since little and big endian conventions will store the same number differently.
+ *
+ * The canonical representation settles this issue by mandating big-endian
+ * convention, the same convention as human-readable numbers (large digits first).
  *
- * The following functions allow transformation of hash values into and from canonical format.
+ * When writing hash values to storage, sending them over a network, or printing
+ * them, it's highly recommended to use the canonical representation to ensure
+ * portability across a wider range of systems, present and future.
+ *
+ * The following functions allow transformation of hash values to and from
+ * canonical format.
  */
 
 typedef struct { unsigned char digest[4]; } XXH32_canonical_t;
@@ -265,14 +337,17 @@ XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src
     typedef unsigned long long XXH64_hash_t;
 #endif
 
-/*! XXH64() :
-    Calculate the 64-bit hash of sequence of length "len" stored at memory address "input".
-    "seed" can be used to alter the result predictably.
-    This function runs faster on 64-bit systems, but slower on 32-bit systems (see benchmark).
-*/
+/*!
+ * XXH64():
+ * Returns the 64-bit hash of sequence of length @length stored at memory
+ * address @input.
+ * @seed can be used to alter the result predictably.
+ * This function usually runs faster on 64-bit systems, but slower on 32-bit
+ * systems (see benchmark).
+ */
 XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t length, XXH64_hash_t seed);
 
-/*======   Streaming   ======*/
+/*******   Streaming   *******/
 typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
 XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void);
 XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
@@ -282,7 +357,7 @@ XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t
 XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
 XXH_PUBLIC_API XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 typedef struct { unsigned char digest[8]; } XXH64_canonical_t;
 XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);
 XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);
@@ -290,20 +365,25 @@ XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src
 
 #endif  /* XXH_NO_LONG_LONG */
 
+#endif /* XXHASH_H_5627135585666179 */
 
 
-#ifdef XXH_STATIC_LINKING_ONLY
 
-/* ================================================================================================
-   This section contains declarations which are not guaranteed to remain stable.
-   They may change in future versions, becoming incompatible with a different version of the library.
-   These declarations should only be used with static linking.
-   Never use them in association with dynamic linking !
-=================================================================================================== */
+#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
+#define XXHASH_H_STATIC_13879238742
+/* ****************************************************************************
+ * This section contains declarations which are not guaranteed to remain stable.
+ * They may change in future versions, becoming incompatible with a different
+ * version of the library.
+ * These declarations should only be used with static linking.
+ * Never use them in association with dynamic linking!
+ ***************************************************************************** */
 
-/* These definitions are only present to allow
- * static allocation of XXH state, on stack or in a struct for example.
- * Never **ever** use members directly. */
+/*
+ * These definitions are only present to allow static allocation of an XXH
+ * state, for example, on the stack or in a struct.
+ * Never **ever** access members directly.
+ */
 
 struct XXH32_state_s {
    XXH32_hash_t total_len_32;
@@ -317,7 +397,9 @@ struct XXH32_state_s {
    XXH32_hash_t reserved;   /* never read nor write, might be removed in a future version */
 };   /* typedef'd to XXH32_state_t */
 
-#ifndef XXH_NO_LONG_LONG  /* remove 64-bit support */
+
+#ifndef XXH_NO_LONG_LONG  /* defined when there is no 64-bit support */
+
 struct XXH64_state_s {
    XXH64_hash_t total_len;
    XXH64_hash_t v1;
@@ -329,81 +411,58 @@ struct XXH64_state_s {
    XXH32_hash_t reserved32;  /* required for padding anyway */
    XXH64_hash_t reserved64;  /* never read nor write, might be removed in a future version */
 };   /* typedef'd to XXH64_state_t */
-#endif   /* XXH_NO_LONG_LONG */
 
 
 /*-**********************************************************************
 *  XXH3
 *  New experimental hash
 ************************************************************************/
-#ifndef XXH_NO_LONG_LONG
-
 
-/* ============================================
- * XXH3 is a new hash algorithm,
- * featuring improved speed performance for both small and large inputs.
- * See full speed analysis at : http://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
- * In general, expect XXH3 to run about ~2x faster on large inputs,
- * and >3x faster on small ones, though exact differences depend on platform.
+/* ************************************************************************
+ * XXH3 is a new hash algorithm featuring:
+ *  - Improved speed for both small and large inputs
+ *  - True 64-bit and 128-bit outputs
+ *  - SIMD acceleration
+ *  - Improved 32-bit viability
+ *
+ * Speed analysis methodology is explained here:
+ *
+ *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
+ *
+ * In general, expect XXH3 to run about ~2x faster on large inputs and >3x
+ * faster on small ones compared to XXH64, though exact differences depend on
+ * the platform.
  *
- * The algorithm is portable, will generate the same hash on all platforms.
- * It benefits greatly from vectorization units, but does not require it.
+ * The algorithm is portable: Like XXH32 and XXH64, it generates the same hash
+ * on all platforms.
+ *
+ * It benefits greatly from SIMD and 64-bit arithmetic, but does not require it.
+ *
+ * Almost all 32-bit and 64-bit targets that can run XXH32 smoothly can run
+ * XXH3 at usable speeds, even if XXH64 runs slowly. Further details are
+ * explained in the implementation.
+ *
+ * Optimized implementations are provided for AVX2, SSE2, NEON, POWER8, ZVector,
+ * and scalar targets. This can be controlled with the XXH_VECTOR macro.
  *
  * XXH3 offers 2 variants, _64bits and _128bits.
- * When only 64 bits are needed, prefer calling the _64bits variant :
- * it reduces the amount of mixing, resulting in faster speed on small inputs.
+ * When only 64 bits are needed, prefer calling the _64bits variant, as it
+ * reduces the amount of mixing, resulting in faster speed on small inputs.
+ *
  * It's also generally simpler to manipulate a scalar return type than a struct.
  *
- * The XXH3 algorithm is still considered experimental.
- * Produced results can still change between versions.
- * Results produced by v0.7.x are not comparable with results from v0.7.y .
- * It's nonetheless possible to use XXH3 for ephemeral data (local sessions),
- * but avoid storing values in long-term storage for later reads.
+ * The 128-bit version adds additional strength, but it is slightly slower.
  *
- * The API supports one-shot hashing, streaming mode, and custom secrets.
+ * The XXH3 algorithm is still in development.
+ * The results it produces may still change in future versions.
+ *
+ * Results produced by v0.7.x are not comparable with results from v0.7.y.
+ * However, the API is completely stable, and it can safely be used for
+ * ephemeral data (local sessions).
  *
- * There are still a number of opened questions that community can influence during the experimental period.
- * I'm trying to list a few of them below, though don't consider this list as complete.
- *
- * - 128-bits output type : currently defined as a structure of two 64-bits fields.
- *                          That's because 128-bit values do not exist in C standard.
- *                          Note that it means that, at byte level, result is not identical depending on endianess.
- *                          However, at field level, they are identical on all platforms.
- *                          The canonical representation solves the issue of identical byte-level representation across platforms,
- *                          which is necessary for serialization.
- *                          Q1 : Would there be a better representation for a 128-bit hash result ?
- *                          Q2 : Are the names of the inner 64-bit fields important ? Should they be changed ?
- *
- * - Prototype XXH128() :   XXH128() uses the same arguments as XXH64(), for consistency.
- *                          It means it maps to XXH3_128bits_withSeed().
- *                          This variant is slightly slower than XXH3_128bits(),
- *                          because the seed is now part of the algorithm, and can't be simplified.
- *                          Is that a good idea ?
- *
- * - Seed type for XXH128() : currently, it's a single 64-bit value, like the 64-bit variant.
- *                          It could be argued that it's more logical to offer a 128-bit seed input parameter for a 128-bit hash.
- *                          But 128-bit seed is more difficult to use, since it requires to pass a structure instead of a scalar value.
- *                          Such a variant could either replace current one, or become an additional one.
- *                          Farmhash, for example, offers both variants (the 128-bits seed variant is called `doubleSeed`).
- *                          Follow up question : if both 64-bit and 128-bit seeds are allowed, which variant should be called XXH128 ?
- *
- * - Result for len==0 :    Currently, the result of hashing a zero-length input is always `0`.
- *                          It seems okay as a return value when using "default" secret and seed.
- *                          But is it still fine to return `0` when secret or seed are non-default ?
- *                          Are there use cases which could depend on generating a different hash result for zero-length input when the secret is different ?
- *
- * - Consistency (1) :      Streaming XXH128 uses an XXH3 state, which is the same state as XXH3_64bits().
- *                          It means a 128bit streaming loop must invoke the following symbols :
- *                          XXH3_createState(), XXH3_128bits_reset(), XXH3_128bits_update() (loop), XXH3_128bits_digest(), XXH3_freeState().
- *                          Is that consistent enough ?
- *
- * - Consistency (2) :      The canonical representation of `XXH3_64bits` is provided by existing functions
- *                          XXH64_canonicalFromHash(), and reverse operation XXH64_hashFromCanonical().
- *                          As a mirror, canonical functions for XXH128_hash_t results generated by `XXH3_128bits`
- *                          are XXH128_canonicalFromHash() and XXH128_hashFromCanonical().
- *                          Which means, `XXH3` doesn't appear in the names, because canonical functions operate on a type,
- *                          independently of which algorithm was used to generate that type.
- *                          Is that consistent enough ?
+ * Avoid storing values in long-term storage until the algorithm is finalized.
+ *
+ * The API supports one-shot hashing, streaming mode, and custom secrets.
  */
 
 #ifdef XXH_NAMESPACE
@@ -422,28 +481,32 @@ struct XXH64_state_s {
 #  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
 #endif
 
-/* XXH3_64bits() :
+/* XXH3_64bits():
  * default 64-bit variant, using default secret and default seed of 0.
  * It's the fastest variant. */
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* data, size_t len);
 
-/* XXH3_64bits_withSecret() :
+/*
+ * XXH3_64bits_withSecret():
  * It's possible to provide any blob of bytes as a "secret" to generate the hash.
- * This makes it more difficult for an external actor to prepare an intentional collision.
+ * This makes it more difficult for an external actor to prepare an intentional
+ * collision.
  * The secret *must* be large enough (>= XXH3_SECRET_SIZE_MIN).
  * It should consist of random bytes.
- * Avoid repeating same character, or sequences of bytes,
- * and especially avoid swathes of \0.
+ * Avoid trivial sequences, such as repeating sequences and especially '\0',
+ * as this can cancel out itself.
  * Failure to respect these conditions will result in a poor quality hash.
  */
 #define XXH3_SECRET_SIZE_MIN 136
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
 
-/* XXH3_64bits_withSeed() :
- * This variant generates on the fly a custom secret,
- * based on the default secret, altered using the `seed` value.
+/*
+ * XXH3_64bits_withSeed():
+ * This variant generates a custom secret on the fly based on the default
+ * secret, altered using the `seed` value.
  * While this operation is decently fast, note that it's not completely free.
- * note : seed==0 produces same results as XXH3_64bits() */
+ * Note: seed==0 produces the same results as XXH3_64bits().
+ */
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
 
 
@@ -460,14 +523,24 @@ XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, X
 #  define XXH_ALIGN(n)   /* disabled */
 #endif
 
+/* Old GCC versions only accept the attribute after the type in structures. */
+#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
+    && defined(__GNUC__)
+#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
+#else
+#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
+#endif
+
 typedef struct XXH3_state_s XXH3_state_t;
 
 #define XXH3_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */
 #define XXH3_INTERNALBUFFER_SIZE 256
 struct XXH3_state_s {
-   XXH_ALIGN(64) XXH64_hash_t acc[8];
-   XXH_ALIGN(64) unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE];  /* used to store a custom secret generated from the seed. Makes state larger. Design might change */
-   XXH_ALIGN(64) unsigned char buffer[XXH3_INTERNALBUFFER_SIZE];
+   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
+  /* used to store a custom secret generated from the seed. Makes state larger.
+   * Design might change */
+   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
+   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
    XXH32_hash_t bufferedSize;
    XXH32_hash_t nbStripesPerBlock;
    XXH32_hash_t nbStripesSoFar;
@@ -477,30 +550,40 @@ struct XXH3_state_s {
    XXH64_hash_t totalLen;
    XXH64_hash_t seed;
    XXH64_hash_t reserved64;
-   const unsigned char* secret;    /* note : there is some padding after, due to alignment on 64 bytes */
+   /* note: there is some padding after due to alignment on 64 bytes */
+   const unsigned char* secret;
 };   /* typedef'd to XXH3_state_t */
 
-/* Streaming requires state maintenance.
- * This operation costs memory and cpu.
- * As a consequence, streaming is slower than one-shot hashing.
- * For better performance, prefer using one-shot functions whenever possible. */
+#undef XXH_ALIGN_MEMBER
 
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever possible.
+ */
 XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void);
 XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
 XXH_PUBLIC_API void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);
 
 
-/* XXH3_64bits_reset() :
- * initialize with default parameters.
- * result will be equivalent to `XXH3_64bits()`. */
+/*
+ * XXH3_64bits_reset():
+ * Initialize with the default parameters.
+ * The result will be equivalent to `XXH3_64bits()`.
+ */
 XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);
-/* XXH3_64bits_reset_withSeed() :
- * generate a custom secret from `seed`, and store it into state.
- * digest will be equivalent to `XXH3_64bits_withSeed()`. */
+/*
+ * XXH3_64bits_reset_withSeed():
+ * Generate a custom secret from `seed`, and store it into `statePtr`.
+ * digest will be equivalent to `XXH3_64bits_withSeed()`.
+ */
 XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
-/* XXH3_64bits_reset_withSecret() :
- * `secret` is referenced, and must outlive the hash streaming session.
- * secretSize must be >= XXH3_SECRET_SIZE_MIN.
+/*
+ * XXH3_64bits_reset_withSecret():
+ * `secret` is referenced, and must outlive the hash streaming session, so
+ * be careful when using stack arrays.
+ * `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`.
  */
 XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
 
@@ -546,20 +629,27 @@ XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const
 XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);
 
 
-/* Note : for better performance, following functions can be inlined,
- * using XXH_INLINE_ALL */
+/* Note: For better performance, these functions can be inlined using XXH_INLINE_ALL */
 
-/* return : 1 is equal, 0 if different */
+/*!
+ * XXH128_isEqual():
+ * Return: 1 if `h1` and `h2` are equal, 0 if they are not.
+ */
 XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);
 
-/* This comparator is compatible with stdlib's qsort().
- * return : >0 if *h128_1  > *h128_2
- *          <0 if *h128_1  < *h128_2
- *          =0 if *h128_1 == *h128_2  */
+/*!
+ * XXH128_cmp():
+ *
+ * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
+ *
+ * return: >0 if *h128_1  > *h128_2
+ *         <0 if *h128_1  < *h128_2
+ *         =0 if *h128_1 == *h128_2
+ */
 XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2);
 
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 typedef struct { unsigned char digest[16]; } XXH128_canonical_t;
 XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);
 XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);
@@ -567,21 +657,1285 @@ XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t*
 
 #endif  /* XXH_NO_LONG_LONG */
 
+#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
+#  define XXH_IMPLEMENTATION
+#endif
+
+#endif  /* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) */
+
+
+/* ======================================================================== */
+/* ======================================================================== */
+/* ======================================================================== */
+
 
 /*-**********************************************************************
-*  XXH_INLINE_ALL
-************************************************************************/
-#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
-#  include "xxhash.c"   /* include xxhash function bodies as `static`, for inlining */
+ * xxHash implementation
+ *-**********************************************************************
+ * xxHash's implementation used to be found in xxhash.c.
+ *
+ * However, code inlining requires the implementation to be visible to the
+ * compiler, usually within the header.
+ *
+ * As a workaround, xxhash.c used to be included within xxhash.h. This caused
+ * some issues with some build systems, especially ones which treat .c files
+ * as source files.
+ *
+ * Therefore, the implementation is now directly integrated within xxhash.h.
+ * Another small advantage is that xxhash.c is no longer needed in /include.
+ ************************************************************************/
+
+#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
+   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
+#  define XXH_IMPLEM_13a8737387
+
+/* *************************************
+*  Tuning parameters
+***************************************/
+/*!
+ * XXH_FORCE_MEMORY_ACCESS:
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is
+ * safe and portable.
+ *
+ * Unfortunately, on some target/compiler combinations, the generated assembly
+ * is sub-optimal.
+ *
+ * The below switch allow to select a different access method for improved
+ * performance.
+ * Method 0 (default):
+ *     Use `memcpy()`. Safe and portable.
+ * Method 1:
+ *     `__attribute__((packed))` statement. It depends on compiler extensions
+ *     and is therefore not portable.
+ *     This method is safe if your compiler supports it, and *generally* as
+ *     fast or faster than `memcpy`.
+ * Method 2:
+ *     Direct access via cast. This method doesn't depend on the compiler but
+ *     violates the C standard.
+ *     It can generate buggy code on targets which do not support unaligned
+ *     memory accesses.
+ *     But in some circumstances, it's the only known way to get the most
+ *     performance (ie GCC + ARMv6)
+ * Method 3:
+ *     Byteshift. This can generate the best code on old compilers which don't
+ *     inline small `memcpy()` calls, and it might also be faster on big-endian
+ *     systems which lack a native byteswap instruction.
+ * See https://stackoverflow.com/a/32095106/646947 for details.
+ * Prefer these methods in priority order (0 > 1 > 2 > 3)
+ */
+#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
+#    define XXH_FORCE_MEMORY_ACCESS 2
+#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
+  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
+#    define XXH_FORCE_MEMORY_ACCESS 1
+#  endif
 #endif
 
+/*!
+ *XXH_ACCEPT_NULL_INPUT_POINTER:
+ * If the input pointer is NULL, xxHash's default behavior is to dereference it,
+ * triggering a segfault.
+ * When this macro is enabled, xxHash actively checks the input for a null pointer.
+ * If it is, the result for null input pointers is the same as a zero-length input.
+ */
+#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
+#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
+#endif
 
+/*!
+ * XXH_FORCE_ALIGN_CHECK:
+ * This is a minor performance trick, only useful with lots of very small keys.
+ * It means: check for aligned/unaligned input.
+ * The check costs one initial branch per hash;
+ * Set it to 0 when the input is guaranteed to be aligned or when alignment
+ * doesn't matter for performance.
+ *
+ * This option does not affect XXH3.
+ */
+#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
+#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
+#    define XXH_FORCE_ALIGN_CHECK 0
+#  else
+#    define XXH_FORCE_ALIGN_CHECK 1
+#  endif
+#endif
+
+/*!
+ * XXH_NO_INLINE_HINTS:
+ *
+ * By default, xxHash tries to force the compiler to inline almost all internal
+ * functions.
+ *
+ * This can usually improve performance due to reduced jumping and improved
+ * constant folding, but significantly increases the size of the binary which
+ * might not be favorable.
+ *
+ * Additionally, sometimes the forced inlining can be detrimental to performance,
+ * depending on the architecture.
+ *
+ * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
+ * compiler full control on whether to inline or not.
+ *
+ * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using
+ * -fno-inline with GCC or Clang, this will automatically be defined.
+ */
+#ifndef XXH_NO_INLINE_HINTS
+#  if defined(__OPTIMIZE_SIZE__) /* -Os, -Oz */ \
+   || defined(__NO_INLINE__)     /* -O0, -fno-inline */
+#    define XXH_NO_INLINE_HINTS 1
+#  else
+#    define XXH_NO_INLINE_HINTS 0
+#  endif
+#endif
 
-#endif /* XXH_STATIC_LINKING_ONLY */
+/*!
+ * XXH_REROLL:
+ * Whether to reroll XXH32_finalize, and XXH64_finalize,
+ * instead of using an unrolled jump table/if statement loop.
+ *
+ * This is automatically defined on -Os/-Oz on GCC and Clang.
+ */
+#ifndef XXH_REROLL
+#  if defined(__OPTIMIZE_SIZE__)
+#    define XXH_REROLL 1
+#  else
+#    define XXH_REROLL 0
+#  endif
+#endif
 
 
-#if defined (__cplusplus)
+/* *************************************
+*  Includes & Memory related functions
+***************************************/
+/*!
+ * Modify the local functions below should you wish to use some other memory
+ * routines for malloc() and free()
+ */
+#include <stdlib.h>
+static void* XXH_malloc(size_t s) { return malloc(s); }
+static void  XXH_free  (void* p)  { free(p); }
+/*! and for memcpy() */
+#include <string.h>
+static void* XXH_memcpy(void* dest, const void* src, size_t size)
+{
+    return memcpy(dest,src,size);
 }
+
+#include <limits.h>   /* ULLONG_MAX */
+
+
+/* *************************************
+*  Compiler Specific Options
+***************************************/
+#ifdef _MSC_VER /* Visual Studio warning fix */
+#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
 #endif
 
-#endif /* XXHASH_H_5627135585666179 */
+#if XXH_NO_INLINE_HINTS /* disable inlining hints */
+#  define XXH_FORCE_INLINE static
+#  define XXH_NO_INLINE static
+#elif defined(_MSC_VER)    /* Visual Studio */
+#  define XXH_FORCE_INLINE static __forceinline
+#  define XXH_NO_INLINE static __declspec(noinline)
+#else
+#  if defined (__cplusplus) \
+    || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
+#    ifdef __GNUC__
+#      define XXH_FORCE_INLINE static inline __attribute__((always_inline))
+#      define XXH_NO_INLINE static __attribute__((noinline))
+#    else
+#      define XXH_FORCE_INLINE static inline
+#      define XXH_NO_INLINE static
+#    endif
+#  else
+#    define XXH_FORCE_INLINE static
+#    define XXH_NO_INLINE static
+#  endif /* __STDC_VERSION__ */
+#endif
+
+
+
+/* *************************************
+*  Debug
+***************************************/
+/*
+ * DEBUGLEVEL is expected to be defined externally, typically via the compiler's
+ * command line options. The value must be a number.
+ */
+#ifndef DEBUGLEVEL
+#  define DEBUGLEVEL 0
+#endif
+
+#if (DEBUGLEVEL>=1)
+#  include <assert.h>   /* note: can still be disabled with NDEBUG */
+#  define XXH_ASSERT(c)   assert(c)
+#else
+#  define XXH_ASSERT(c)   ((void)0)
+#endif
+
+/* note: use after variable declarations */
+#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }
+
+
+/* *************************************
+*  Basic Types
+***************************************/
+#if !defined (__VMS) \
+ && (defined (__cplusplus) \
+ || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+# include <stdint.h>
+  typedef uint8_t  xxh_u8;
+#else
+  typedef unsigned char      xxh_u8;
+#endif
+typedef XXH32_hash_t xxh_u32;
+
+
+/* ***   Memory access   *** */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE32 and XXH_readBE32.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/*
+ * Force direct memory access. Only works on CPU which support unaligned memory
+ * access in hardware.
+ */
+static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
+static xxh_u32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://stackoverflow.com/a/32095106/646947
+ */
+static xxh_u32 XXH_read32(const void* memPtr)
+{
+    xxh_u32 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+
+/* ***   Endianess   *** */
+typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
+
+/*!
+ * XXH_CPU_LITTLE_ENDIAN:
+ * Defined to 1 if the target is little endian, or 0 if it is big endian.
+ * It can be defined externally, for example on the compiler command line.
+ *
+ * If it is not defined, a runtime check (which is usually constant folded)
+ * is used instead.
+ */
+#ifndef XXH_CPU_LITTLE_ENDIAN
+/*
+ * Try to detect endianness automatically, to avoid the nonstandard behavior
+ * in `XXH_isLittleEndian()`
+ */
+#  if defined(_WIN32) /* Windows is always little endian */ \
+     || defined(__LITTLE_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 1
+#  elif defined(__BIG_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 0
+#  else
+static int XXH_isLittleEndian(void)
+{
+    /*
+     * Nonstandard, but well-defined behavior in practice.
+     * Don't use static: it is detrimental to performance.
+     */
+    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
+    return one.c[0];
+}
+#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
+#  endif
+#endif
+
+
+
+
+/* ****************************************
+*  Compiler-specific Functions and Macros
+******************************************/
+#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+#ifndef __has_builtin
+#  define __has_builtin(x) 0
+#endif
+
+#if !defined(NO_CLANG_BUILTIN) && __has_builtin(__builtin_rotateleft32) \
+                               && __has_builtin(__builtin_rotateleft64)
+#  define XXH_rotl32 __builtin_rotateleft32
+#  define XXH_rotl64 __builtin_rotateleft64
+/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
+#elif defined(_MSC_VER)
+#  define XXH_rotl32(x,r) _rotl(x,r)
+#  define XXH_rotl64(x,r) _rotl64(x,r)
+#else
+#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
+#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
+#endif
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap32 _byteswap_ulong
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap32 __builtin_bswap32
+#else
+static xxh_u32 XXH_swap32 (xxh_u32 x)
+{
+    return  ((x << 24) & 0xff000000 ) |
+            ((x <<  8) & 0x00ff0000 ) |
+            ((x >>  8) & 0x0000ff00 ) |
+            ((x >> 24) & 0x000000ff );
+}
+#endif
+
+
+/* ***************************
+*  Memory reads
+*****************************/
+typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
+
+/*
+ * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
+ *
+ * This is ideal for older compilers which don't inline memcpy.
+ */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u32)bytePtr[1] << 8)
+         | ((xxh_u32)bytePtr[2] << 16)
+         | ((xxh_u32)bytePtr[3] << 24);
+}
+
+XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[3]
+         | ((xxh_u32)bytePtr[2] << 8)
+         | ((xxh_u32)bytePtr[1] << 16)
+         | ((xxh_u32)bytePtr[0] << 24);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
+}
+
+static xxh_u32 XXH_readBE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u32
+XXH_readLE32_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned) {
+        return XXH_readLE32(ptr);
+    } else {
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
+    }
+}
+
+
+/* *************************************
+*  Misc
+***************************************/
+XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
+
+
+/* *******************************************************************
+*  32-bit hash functions
+*********************************************************************/
+static const xxh_u32 PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
+static const xxh_u32 PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
+static const xxh_u32 PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */
+static const xxh_u32 PRIME32_4 = 0x27D4EB2FU;   /* 0b00100111110101001110101100101111 */
+static const xxh_u32 PRIME32_5 = 0x165667B1U;   /* 0b00010110010101100110011110110001 */
+
+static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
+{
+    acc += input * PRIME32_2;
+    acc  = XXH_rotl32(acc, 13);
+    acc *= PRIME32_1;
+#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
+    /*
+     * UGLY HACK:
+     * This inline assembly hack forces acc into a normal register. This is the
+     * only thing that prevents GCC and Clang from autovectorizing the XXH32
+     * loop (pragmas and attributes don't work for some resason) without globally
+     * disabling SSE4.1.
+     *
+     * The reason we want to avoid vectorization is because despite working on
+     * 4 integers at a time, there are multiple factors slowing XXH32 down on
+     * SSE4:
+     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
+     *   newer chips!) making it slightly slower to multiply four integers at
+     *   once compared to four integers independently. Even when pmulld was
+     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
+     *   just to multiply unless doing a long operation.
+     *
+     * - Four instructions are required to rotate,
+     *      movqda tmp,  v // not required with VEX encoding
+     *      pslld  tmp, 13 // tmp <<= 13
+     *      psrld  v,   19 // x >>= 19
+     *      por    v,  tmp // x |= tmp
+     *   compared to one for scalar:
+     *      roll   v, 13    // reliably fast across the board
+     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
+     *
+     * - Instruction level parallelism is actually more beneficial here because
+     *   the SIMD actually serializes this operation: While v1 is rotating, v2
+     *   can load data, while v3 can multiply. SSE forces them to operate
+     *   together.
+     *
+     * How this hack works:
+     * __asm__(""       // Declare an assembly block but don't declare any instructions
+     *          :       // However, as an Input/Output Operand,
+     *          "+r"    // constrain a read/write operand (+) as a general purpose register (r).
+     *          (acc)   // and set acc as the operand
+     * );
+     *
+     * Because of the 'r', the compiler has promised that seed will be in a
+     * general purpose register and the '+' says that it will be 'read/write',
+     * so it has to assume it has changed. It is like volatile without all the
+     * loads and stores.
+     *
+     * Since the argument has to be in a normal register (not an SSE register),
+     * each time XXH32_round is called, it is impossible to vectorize.
+     */
+    __asm__("" : "+r" (acc));
+#endif
+    return acc;
+}
+
+/* mix all bits */
+static xxh_u32 XXH32_avalanche(xxh_u32 h32)
+{
+    h32 ^= h32 >> 15;
+    h32 *= PRIME32_2;
+    h32 ^= h32 >> 13;
+    h32 *= PRIME32_3;
+    h32 ^= h32 >> 16;
+    return(h32);
+}
+
+#define XXH_get32bits(p) XXH_readLE32_align(p, align)
+
+static xxh_u32
+XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define PROCESS1               \
+    h32 += (*ptr++) * PRIME32_5; \
+    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
+
+#define PROCESS4                         \
+    h32 += XXH_get32bits(ptr) * PRIME32_3; \
+    ptr+=4;                                \
+    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
+
+    /* Compact rerolled version */
+    if (XXH_REROLL) {
+        len &= 15;
+        while (len >= 4) {
+            PROCESS4;
+            len -= 4;
+        }
+        while (len > 0) {
+            PROCESS1;
+            --len;
+        }
+        return XXH32_avalanche(h32);
+    } else {
+         switch(len&15) /* or switch(bEnd - p) */ {
+           case 12:      PROCESS4;
+                         /* fallthrough */
+           case 8:       PROCESS4;
+                         /* fallthrough */
+           case 4:       PROCESS4;
+                         return XXH32_avalanche(h32);
+
+           case 13:      PROCESS4;
+                         /* fallthrough */
+           case 9:       PROCESS4;
+                         /* fallthrough */
+           case 5:       PROCESS4;
+                         PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 14:      PROCESS4;
+                         /* fallthrough */
+           case 10:      PROCESS4;
+                         /* fallthrough */
+           case 6:       PROCESS4;
+                         PROCESS1;
+                         PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 15:      PROCESS4;
+                         /* fallthrough */
+           case 11:      PROCESS4;
+                         /* fallthrough */
+           case 7:       PROCESS4;
+                         /* fallthrough */
+           case 3:       PROCESS1;
+                         /* fallthrough */
+           case 2:       PROCESS1;
+                         /* fallthrough */
+           case 1:       PROCESS1;
+                         /* fallthrough */
+           case 0:       return XXH32_avalanche(h32);
+        }
+        XXH_ASSERT(0);
+        return h32;   /* reaching this point is deemed impossible */
+    }
+}
+
+XXH_FORCE_INLINE xxh_u32
+XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
+{
+    const xxh_u8* bEnd = input + len;
+    xxh_u32 h32;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (input==NULL) {
+        len=0;
+        bEnd=input=(const xxh_u8*)(size_t)16;
+    }
+#endif
+
+    if (len>=16) {
+        const xxh_u8* const limit = bEnd - 15;
+        xxh_u32 v1 = seed + PRIME32_1 + PRIME32_2;
+        xxh_u32 v2 = seed + PRIME32_2;
+        xxh_u32 v3 = seed + 0;
+        xxh_u32 v4 = seed - PRIME32_1;
+
+        do {
+            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
+            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
+            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
+            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
+        } while (input < limit);
+
+        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
+            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
+    } else {
+        h32  = seed + PRIME32_5;
+    }
+
+    h32 += (xxh_u32)len;
+
+    return XXH32_finalize(h32, input, len&15, align);
+}
+
+
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH32_state_t state;
+    XXH32_reset(&state, seed);
+    XXH32_update(&state, (const xxh_u8*)input, len);
+    return XXH32_digest(&state);
+
+#else
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
+            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+#endif
+}
+
+
+
+/*******   Hash streaming   *******/
+
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
+{
+    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
+{
+    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME32_1 + PRIME32_2;
+    state.v2 = seed + PRIME32_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME32_1;
+    /* do not write into reserved, planned to be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH_errorcode
+XXH32_update(XXH32_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len_32 += (XXH32_hash_t)len;
+        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
+
+        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
+            state->memsize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* some data left from previous update */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
+            {   const xxh_u32* p32 = state->mem32;
+                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
+                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
+                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
+                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
+            }
+            p += 16-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p <= bEnd-16) {
+            const xxh_u8* const limit = bEnd - 16;
+            xxh_u32 v1 = state->v1;
+            xxh_u32 v2 = state->v2;
+            xxh_u32 v3 = state->v3;
+            xxh_u32 v4 = state->v4;
+
+            do {
+                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
+                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
+                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
+                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
+            } while (p<=limit);
+
+            state->v1 = v1;
+            state->v2 = v2;
+            state->v3 = v3;
+            state->v4 = v4;
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
+{
+    xxh_u32 h32;
+
+    if (state->large_len) {
+        h32 = XXH_rotl32(state->v1, 1)
+            + XXH_rotl32(state->v2, 7)
+            + XXH_rotl32(state->v3, 12)
+            + XXH_rotl32(state->v4, 18);
+    } else {
+        h32 = state->v3 /* == seed */ + PRIME32_5;
+    }
+
+    h32 += state->total_len_32;
+
+    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
+}
+
+
+/*******   Canonical representation   *******/
+
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
+ *
+ * The canonical representation uses big endian convention, the same convention
+ * as human-readable numbers (large digits first).
+ *
+ * This way, hash values can be written into a file or buffer, remaining
+ * comparable across different systems.
+ *
+ * The following functions allow transformation of hash values to and from their
+ * canonical format.
+ */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
+{
+    return XXH_readBE32(src);
+}
+
+
+#ifndef XXH_NO_LONG_LONG
+
+/* *******************************************************************
+*  64-bit hash functions
+*********************************************************************/
+
+/*******   Memory access   *******/
+
+typedef XXH64_hash_t xxh_u64;
+
+
+/*!
+ * XXH_REROLL_XXH64:
+ * Whether to reroll the XXH64_finalize() loop.
+ *
+ * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a
+ * performance gain on 64-bit hosts, as only one jump is required.
+ *
+ * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit
+ * registers, and 64-bit arithmetic needs to be simulated, it isn't beneficial
+ * to unroll. The code becomes ridiculously large (the largest function in the
+ * binary on i386!), and rerolling it saves anywhere from 3kB to 20kB. It is
+ * also slightly faster because it fits into cache better and is more likely
+ * to be inlined by the compiler.
+ *
+ * If XXH_REROLL is defined, this is ignored and the loop is always rerolled.
+ */
+#ifndef XXH_REROLL_XXH64
+#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
+   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
+     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
+     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
+     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
+   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
+#    define XXH_REROLL_XXH64 1
+#  else
+#    define XXH_REROLL_XXH64 0
+#  endif
+#endif /* !defined(XXH_REROLL_XXH64) */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE64 and XXH_readBE64.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer, but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
+static xxh_u64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://stackoverflow.com/a/32095106/646947
+ */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    xxh_u64 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap64 _byteswap_uint64
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap64 __builtin_bswap64
+#else
+static xxh_u64 XXH_swap64 (xxh_u64 x)
+{
+    return  ((x << 56) & 0xff00000000000000ULL) |
+            ((x << 40) & 0x00ff000000000000ULL) |
+            ((x << 24) & 0x0000ff0000000000ULL) |
+            ((x << 8)  & 0x000000ff00000000ULL) |
+            ((x >> 8)  & 0x00000000ff000000ULL) |
+            ((x >> 24) & 0x0000000000ff0000ULL) |
+            ((x >> 40) & 0x000000000000ff00ULL) |
+            ((x >> 56) & 0x00000000000000ffULL);
+}
+#endif
+
+
+/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u64)bytePtr[1] << 8)
+         | ((xxh_u64)bytePtr[2] << 16)
+         | ((xxh_u64)bytePtr[3] << 24)
+         | ((xxh_u64)bytePtr[4] << 32)
+         | ((xxh_u64)bytePtr[5] << 40)
+         | ((xxh_u64)bytePtr[6] << 48)
+         | ((xxh_u64)bytePtr[7] << 56);
+}
+
+XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[7]
+         | ((xxh_u64)bytePtr[6] << 8)
+         | ((xxh_u64)bytePtr[5] << 16)
+         | ((xxh_u64)bytePtr[4] << 24)
+         | ((xxh_u64)bytePtr[3] << 32)
+         | ((xxh_u64)bytePtr[2] << 40)
+         | ((xxh_u64)bytePtr[1] << 48)
+         | ((xxh_u64)bytePtr[0] << 56);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
+}
+
+static xxh_u64 XXH_readBE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u64
+XXH_readLE64_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return XXH_readLE64(ptr);
+    else
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
+}
+
+
+/*******   xxh64   *******/
+
+static const xxh_u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
+static const xxh_u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
+static const xxh_u64 PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
+static const xxh_u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
+static const xxh_u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */
+
+static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
+{
+    acc += input * PRIME64_2;
+    acc  = XXH_rotl64(acc, 31);
+    acc *= PRIME64_1;
+    return acc;
+}
+
+static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
+{
+    val  = XXH64_round(0, val);
+    acc ^= val;
+    acc  = acc * PRIME64_1 + PRIME64_4;
+    return acc;
+}
+
+static xxh_u64 XXH64_avalanche(xxh_u64 h64)
+{
+    h64 ^= h64 >> 33;
+    h64 *= PRIME64_2;
+    h64 ^= h64 >> 29;
+    h64 *= PRIME64_3;
+    h64 ^= h64 >> 32;
+    return h64;
+}
+
+
+#define XXH_get64bits(p) XXH_readLE64_align(p, align)
+
+static xxh_u64
+XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define PROCESS1_64            \
+    h64 ^= (*ptr++) * PRIME64_5; \
+    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
+
+#define PROCESS4_64          \
+    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * PRIME64_1; \
+    ptr+=4;                    \
+    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
+
+#define PROCESS8_64 {        \
+    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
+    ptr+=8;                    \
+    h64 ^= k1;               \
+    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
+}
+
+    /* Rerolled version for 32-bit targets is faster and much smaller. */
+    if (XXH_REROLL || XXH_REROLL_XXH64) {
+        len &= 31;
+        while (len >= 8) {
+            PROCESS8_64;
+            len -= 8;
+        }
+        if (len >= 4) {
+            PROCESS4_64;
+            len -= 4;
+        }
+        while (len > 0) {
+            PROCESS1_64;
+            --len;
+        }
+         return  XXH64_avalanche(h64);
+    } else {
+        switch(len & 31) {
+           case 24: PROCESS8_64;
+                         /* fallthrough */
+           case 16: PROCESS8_64;
+                         /* fallthrough */
+           case  8: PROCESS8_64;
+                    return XXH64_avalanche(h64);
+
+           case 28: PROCESS8_64;
+                         /* fallthrough */
+           case 20: PROCESS8_64;
+                         /* fallthrough */
+           case 12: PROCESS8_64;
+                         /* fallthrough */
+           case  4: PROCESS4_64;
+                    return XXH64_avalanche(h64);
+
+           case 25: PROCESS8_64;
+                         /* fallthrough */
+           case 17: PROCESS8_64;
+                         /* fallthrough */
+           case  9: PROCESS8_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 29: PROCESS8_64;
+                         /* fallthrough */
+           case 21: PROCESS8_64;
+                         /* fallthrough */
+           case 13: PROCESS8_64;
+                         /* fallthrough */
+           case  5: PROCESS4_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 26: PROCESS8_64;
+                         /* fallthrough */
+           case 18: PROCESS8_64;
+                         /* fallthrough */
+           case 10: PROCESS8_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 30: PROCESS8_64;
+                         /* fallthrough */
+           case 22: PROCESS8_64;
+                         /* fallthrough */
+           case 14: PROCESS8_64;
+                         /* fallthrough */
+           case  6: PROCESS4_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 27: PROCESS8_64;
+                         /* fallthrough */
+           case 19: PROCESS8_64;
+                         /* fallthrough */
+           case 11: PROCESS8_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 31: PROCESS8_64;
+                         /* fallthrough */
+           case 23: PROCESS8_64;
+                         /* fallthrough */
+           case 15: PROCESS8_64;
+                         /* fallthrough */
+           case  7: PROCESS4_64;
+                         /* fallthrough */
+           case  3: PROCESS1_64;
+                         /* fallthrough */
+           case  2: PROCESS1_64;
+                         /* fallthrough */
+           case  1: PROCESS1_64;
+                         /* fallthrough */
+           case  0: return XXH64_avalanche(h64);
+        }
+    }
+    /* impossible to reach */
+    XXH_ASSERT(0);
+    return 0;  /* unreachable, but some compilers complain without it */
+}
+
+XXH_FORCE_INLINE xxh_u64
+XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
+{
+    const xxh_u8* bEnd = input + len;
+    xxh_u64 h64;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (input==NULL) {
+        len=0;
+        bEnd=input=(const xxh_u8*)(size_t)32;
+    }
+#endif
+
+    if (len>=32) {
+        const xxh_u8* const limit = bEnd - 32;
+        xxh_u64 v1 = seed + PRIME64_1 + PRIME64_2;
+        xxh_u64 v2 = seed + PRIME64_2;
+        xxh_u64 v3 = seed + 0;
+        xxh_u64 v4 = seed - PRIME64_1;
+
+        do {
+            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
+            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
+            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
+            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
+        } while (input<=limit);
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+
+    } else {
+        h64  = seed + PRIME64_5;
+    }
+
+    h64 += (xxh_u64) len;
+
+    return XXH64_finalize(h64, input, len, align);
+}
+
+
+XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH64_state_t state;
+    XXH64_reset(&state, seed);
+    XXH64_update(&state, (const xxh_u8*)input, len);
+    return XXH64_digest(&state);
+
+#else
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
+            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+
+#endif
+}
+
+/*******   Hash Streaming   *******/
+
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
+{
+    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
+{
+    XXH64_state_t state;   /* use a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME64_1 + PRIME64_2;
+    state.v2 = seed + PRIME64_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME64_1;
+     /* do not write into reserved64, might be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH64_update (XXH64_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len += len;
+
+        if (state->memsize + len < 32) {  /* fill in tmp buffer */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
+            state->memsize += (xxh_u32)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* tmp buffer is full */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
+            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
+            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
+            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
+            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
+            p += 32-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p+32 <= bEnd) {
+            const xxh_u8* const limit = bEnd - 32;
+            xxh_u64 v1 = state->v1;
+            xxh_u64 v2 = state->v2;
+            xxh_u64 v3 = state->v3;
+            xxh_u64 v4 = state->v4;
+
+            do {
+                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
+                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
+                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
+                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
+            } while (p<=limit);
+
+            state->v1 = v1;
+            state->v2 = v2;
+            state->v3 = v3;
+            state->v4 = v4;
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
+{
+    xxh_u64 h64;
+
+    if (state->total_len >= 32) {
+        xxh_u64 const v1 = state->v1;
+        xxh_u64 const v2 = state->v2;
+        xxh_u64 const v3 = state->v3;
+        xxh_u64 const v4 = state->v4;
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+    } else {
+        h64  = state->v3 /*seed*/ + PRIME64_5;
+    }
+
+    h64 += (xxh_u64) state->total_len;
+
+    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
+}
+
+
+/******* Canonical representation   *******/
+
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
+{
+    return XXH_readBE64(src);
+}
+
+
+
+/* *********************************************************************
+*  XXH3
+*  New generation hash designed for speed on small keys and vectorization
+************************************************************************ */
+
+#include "xxh3.h"
+
+
+#endif  /* XXH_NO_LONG_LONG */
+
+
+#endif  /* XXH_IMPLEMENTATION */
+
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/mupen64plus-core/tools/gen_asm_script.cmd b/mupen64plus-core/tools/gen_asm_script.cmd
new file mode 100644
index 00000000..6f32aaf4
--- /dev/null
+++ b/mupen64plus-core/tools/gen_asm_script.cmd
@@ -0,0 +1,42 @@
+@echo off
+::
+:: To correctly handle the undefined GAS_ARG2TOINF
+setlocal enableextensions disabledelayedexpansion
+::
+:: Validation of the parameters sent by VS to use them as variables, if an invalid parameter is sent (syntax conflict), this script will fail without error code
+for /f "tokens=1*" %%A in ('echo %*') do set GAS_ARG1=%%A& set GAS_ARG2TOINF=%%B
+::
+:: Lite version of Anti-PEBCAK/Layer_8/Wetware implementation
+:: * Makes GAS_PATH more "static"...
+:: * Ensures that "Item A" and "Item B" exist, and sends "corresponding" error if not
+:: * The sole purpose of this piece of code is to make the script fail outside VS
+::
+set GAS_PATH=..\..\src\asm_defines\
+if not exist mupen64plus-core.vcxproj exit /b 202
+if not exist "%GAS_PATH%asm_defines.c" exit /b 303
+::
+:: Legacy code adaptation for this script:
+:: * Delete the "glue code" libraries previously generated by gawk and/or this script
+:: * CL's stuff/witchcraft, if all goes well it will generate "Item C"
+::
+del %GAS_PATH%asm_defines_*
+cl /c /Fo%GAS_ARG1% %GAS_ARG2TOINF% /I ..\..\src %GAS_PATH%asm_defines.c
+::
+:: If "Item C" does not exist, send error
+if not exist "%GAS_ARG1%asm_defines.obj" exit /b 404
+::
+:: Legacy code adaptation for gawk, currently disabled
+REM "..\..\..\mupen64plus-win32-deps\gawk-3.1.6-1\bin\gawk.exe" -v dest_dir="../../src/asm_defines" -f ..\..\tools\gen_asm_defines.awk %GAS_ARG1%asm_defines.obj
+::
+:: Simplified adaptation of 'gen_asm_defines.awk':
+:: * Display 'asm_defines.obj' as a list
+:: * Look for the '@ASM_DEFINE' pattern
+:: * Take element '$2' and '$3' on that line
+:: * Print '#define "$2" ("$3")' to asm_defines_gas.h
+:: * Print '%define "$2" ("$3")' to asm_defines_nasm.h
+::
+for /f "tokens=2,3" %%J in ('type %GAS_ARG1%asm_defines.obj ^| find "@ASM_DEFINE"') do (
+echo #define %%J ^(%%K^)>>%GAS_PATH%asm_defines_gas.h
+echo %%define %%J ^(%%K^)>>%GAS_PATH%asm_defines_nasm.h
+)
+exit /b 0
\ No newline at end of file

From 2bca1c0a0f09ee14e269a9317506c0da94d0a293 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Thu, 30 Apr 2020 11:36:36 +0200
Subject: [PATCH 02/28] git subrepo clone --force --branch=rebase
 git@github.com:libretro/GLideN64.git GLideN64

subrepo:
  subdir:   "GLideN64"
  merged:   "589b1b61"
upstream:
  origin:   "git@github.com:libretro/GLideN64.git"
  branch:   "rebase"
  commit:   "589b1b61"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 GLideN64/.gitignore                           |     1 +
 GLideN64/.gitrepo                             |     6 +-
 GLideN64/appveyor.yml                         |    57 +-
 GLideN64/ini/GLideN64.custom.ini              |    19 +
 GLideN64/projects/msvc/GLideN64.sln           |   127 +-
 GLideN64/projects/msvc/GLideN64.vcxproj       |   130 +-
 .../projects/msvc/GLideN64.vcxproj.filters    |    23 +-
 GLideN64/projects/msvc/GLideNUI-wtl.vcxproj   |   191 +
 .../msvc/GLideNUI-wtl.vcxproj.filters         |   295 +
 GLideN64/projects/msvc/GLideNUI.vcxproj       |     8 +-
 .../projects/msvc/GLideNUI.vcxproj.filters    |     2 +-
 GLideN64/projects/msvc/libGLideNHQ.vcxproj    |     9 +-
 .../projects/msvc/libGLideNHQ.vcxproj.filters |     4 +-
 GLideN64/projects/msvc/osal.vcxproj           |     5 +
 GLideN64/src/BufferCopy/BlueNoiseTexture.cpp  |   533 +
 GLideN64/src/BufferCopy/BlueNoiseTexture.h    |     8 +
 .../src/BufferCopy/ColorBufferToRDRAM.cpp     |    56 +-
 GLideN64/src/BufferCopy/ColorBufferToRDRAM.h  |     8 +-
 .../src/BufferCopy/DepthBufferToRDRAM.cpp     |     2 +-
 GLideN64/src/BufferCopy/DepthBufferToRDRAM.h  |     2 +-
 .../src/BufferCopy/RDRAMtoColorBuffer.cpp     |     5 +-
 GLideN64/src/BufferCopy/WriteToRDRAM.h        |     6 +-
 GLideN64/src/CMakeLists.txt                   |    22 +-
 GLideN64/src/CRC.h                            |     4 +-
 GLideN64/src/CRC32.cpp                        |    20 +-
 GLideN64/src/CRC32_ARMV8.cpp                  |    24 +-
 GLideN64/src/CRC_OPT.cpp                      |    10 +-
 GLideN64/src/Config.cpp                       |     5 +-
 GLideN64/src/Config.h                         |    14 +-
 GLideN64/src/FrameBuffer.cpp                  |     2 +-
 GLideN64/src/GBI.cpp                          |    12 +
 GLideN64/src/GLideN64.rc                      |   Bin 0 -> 2842 bytes
 GLideN64/src/GLideNUI-wtl/About.cpp           |   403 +
 GLideN64/src/GLideNUI-wtl/About.h             |    60 +
 GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp       |   432 +
 GLideN64/src/GLideNUI-wtl/ConfigDlg.h         |    77 +
 GLideN64/src/GLideNUI-wtl/FileClass.cpp       |   350 +
 GLideN64/src/GLideNUI-wtl/FileClass.h         |    81 +
 GLideN64/src/GLideNUI-wtl/FontInfo.cpp        |   166 +
 GLideN64/src/GLideNUI-wtl/FontInfo.h          |    10 +
 .../src/GLideNUI-wtl/FullscreenResolutions.h  |    10 +
 GLideN64/src/GLideNUI-wtl/GLideNUI.cpp        |    93 +
 GLideN64/src/GLideNUI-wtl/GLideNUI.h          |    26 +
 GLideN64/src/GLideNUI-wtl/GLideNUI.rc         |   Bin 0 -> 53324 bytes
 GLideN64/src/GLideNUI-wtl/GlSettings.cpp      |   261 +
 GLideN64/src/GLideNUI-wtl/GlSettings.h        |    75 +
 GLideN64/src/GLideNUI-wtl/IniFileClass.cpp    |   879 ++
 GLideN64/src/GLideNUI-wtl/IniFileClass.h      |   127 +
 GLideN64/src/GLideNUI-wtl/InputDialog.cpp     |    46 +
 GLideN64/src/GLideNUI-wtl/InputDialog.h       |    34 +
 GLideN64/src/GLideNUI-wtl/Language.cpp        |   410 +
 GLideN64/src/GLideNUI-wtl/Language.h          |   255 +
 GLideN64/src/GLideNUI-wtl/ScreenShot.cpp      |   122 +
 GLideN64/src/GLideNUI-wtl/Settings.cpp        |   564 +
 GLideN64/src/GLideNUI-wtl/Settings.h          |    15 +
 GLideN64/src/GLideNUI-wtl/WTL/atlapp.h        |  2125 ++++
 GLideN64/src/GLideNUI-wtl/WTL/atlcrack.h      |  2384 ++++
 GLideN64/src/GLideNUI-wtl/WTL/atlctrls.h      | 10071 ++++++++++++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlctrlw.h      |  4157 +++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlctrlx.h      |  4979 ++++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlddx.h        |   685 ++
 GLideN64/src/GLideNUI-wtl/WTL/atldlgs.h       |  6386 ++++++++++
 GLideN64/src/GLideNUI-wtl/WTL/atldwm.h        |   461 +
 GLideN64/src/GLideNUI-wtl/WTL/atlfind.h       |  1032 ++
 GLideN64/src/GLideNUI-wtl/WTL/atlframe.h      |  3688 ++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlgdi.h        |  3891 ++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlmisc.h       |  3746 ++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlprint.h      |  1109 ++
 GLideN64/src/GLideNUI-wtl/WTL/atlres.h        |   263 +
 GLideN64/src/GLideNUI-wtl/WTL/atlresce.h      |    93 +
 GLideN64/src/GLideNUI-wtl/WTL/atlribbon.h     |  3446 ++++++
 GLideN64/src/GLideNUI-wtl/WTL/atlscrl.h       |  2007 +++
 GLideN64/src/GLideNUI-wtl/WTL/atlsplit.h      |   917 ++
 GLideN64/src/GLideNUI-wtl/WTL/atltheme.h      |  1218 ++
 GLideN64/src/GLideNUI-wtl/WTL/atluser.h       |  1391 +++
 GLideN64/src/GLideNUI-wtl/WTL/atlwince.h      |  2987 +++++
 GLideN64/src/GLideNUI-wtl/WTL/atlwinx.h       |   595 +
 GLideN64/src/GLideNUI-wtl/config-debug.cpp    |    40 +
 GLideN64/src/GLideNUI-wtl/config-debug.h      |    21 +
 .../src/GLideNUI-wtl/config-emulation.cpp     |   211 +
 GLideN64/src/GLideNUI-wtl/config-emulation.h  |    41 +
 .../src/GLideNUI-wtl/config-framebuffer.cpp   |   190 +
 .../src/GLideNUI-wtl/config-framebuffer.h     |    33 +
 GLideN64/src/GLideNUI-wtl/config-osd.cpp      |   301 +
 GLideN64/src/GLideNUI-wtl/config-osd.h        |    61 +
 GLideN64/src/GLideNUI-wtl/config-overscan.cpp |    61 +
 GLideN64/src/GLideNUI-wtl/config-overscan.h   |    27 +
 GLideN64/src/GLideNUI-wtl/config-tab.cpp      |    11 +
 GLideN64/src/GLideNUI-wtl/config-tab.h        |    20 +
 GLideN64/src/GLideNUI-wtl/config-texture.cpp  |   297 +
 GLideN64/src/GLideNUI-wtl/config-texture.h    |    46 +
 GLideN64/src/GLideNUI-wtl/config-video.cpp    |   467 +
 GLideN64/src/GLideNUI-wtl/config-video.h      |    63 +
 .../fullscreenresolutions_windows.cpp         |   180 +
 GLideN64/src/GLideNUI-wtl/resource.h          |   Bin 0 -> 20272 bytes
 GLideN64/src/GLideNUI-wtl/util.cpp            |    57 +
 GLideN64/src/GLideNUI-wtl/util.h              |    11 +
 .../src/GLideNUI-wtl/wtl-BitmapPicture.cpp    |    68 +
 GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.h |    33 +
 GLideN64/src/GLideNUI-wtl/wtl-ColorButton.cpp |    67 +
 GLideN64/src/GLideNUI-wtl/wtl-ColorButton.h   |    39 +
 GLideN64/src/GLideNUI-wtl/wtl-OsdButton.cpp   |    60 +
 GLideN64/src/GLideNUI-wtl/wtl-OsdButton.h     |    19 +
 GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.cpp  |   120 +
 GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.h    |    25 +
 GLideN64/src/GLideNUI-wtl/wtl-WindowFont.h    |    97 +
 GLideN64/src/GLideNUI-wtl/wtl-tooltip.h       |   113 +
 GLideN64/src/GLideNUI-wtl/wtl.h               |    21 +
 GLideN64/src/GLideNUI/ConfigDialog.cpp        |    12 +-
 .../GLideNUI/{ => Resources}/BottomLeft.ico   |   Bin
 .../GLideNUI/{ => Resources}/BottomRight.ico  |   Bin
 .../src/GLideNUI/{ => Resources}/Down.ico     |   Bin
 .../{ => Resources}/Icon-Original.ico         |   Bin
 .../src/GLideNUI/{ => Resources}/Icon.ico     |   Bin
 .../src/GLideNUI/{ => Resources}/Info.ico     |   Bin
 .../src/GLideNUI/{ => Resources}/Left.ico     |   Bin
 .../src/GLideNUI/{ => Resources}/Right.ico    |   Bin
 .../src/GLideNUI/{ => Resources}/TopLeft.ico  |   Bin
 .../src/GLideNUI/{ => Resources}/TopRight.ico |   Bin
 GLideN64/src/GLideNUI/{ => Resources}/Up.ico  |   Bin
 .../src/GLideNUI/{ => Resources}/Warning.ico  |   Bin
 GLideN64/src/GLideNUI/Settings.cpp            |    15 +-
 GLideN64/src/GLideNUI/configDialog.ui         |    99 +-
 GLideN64/src/GLideNUI/icon.qrc                |    22 +-
 GLideN64/src/Graphics/CombinerProgram.cpp     |     4 +-
 .../GLSL/glsl_CombinerProgramBuilder.cpp      |   320 +-
 .../glsl_CombinerProgramUniformFactory.cpp    |    21 +-
 .../OpenGLContext/GLSL/glsl_ShaderStorage.h   |     2 +-
 .../GLSL/glsl_SpecialShadersFactory.cpp       |     2 +-
 .../OpenGLContext/opengl_BufferedDrawer.cpp   |     2 +-
 .../OpenGLContext/opengl_BufferedDrawer.h     |     2 +-
 GLideN64/src/GraphicsDrawer.cpp               |    66 +-
 GLideN64/src/Neon/CRC_OPT_NEON.cpp            |    16 +-
 GLideN64/src/NoiseTexture.cpp                 |     5 +-
 GLideN64/src/PaletteTexture.cpp               |     1 +
 GLideN64/src/PaletteTexture.h                 |     2 +-
 GLideN64/src/RDP.cpp                          |     5 +-
 GLideN64/src/RSP.cpp                          |     4 +-
 GLideN64/src/SoftwareRender.cpp               |     3 +
 GLideN64/src/Textures.cpp                     |    24 +-
 GLideN64/src/Textures.h                       |     6 +-
 GLideN64/src/VI.cpp                           |    10 +-
 GLideN64/src/gDP.cpp                          |   624 +-
 GLideN64/src/gDP.h                            |    24 +-
 GLideN64/src/gSP.cpp                          |     3 +-
 GLideN64/src/mupenplus/Config_mupenplus.cpp   |    24 +-
 GLideN64/src/resource.h                       |   Bin 0 -> 814 bytes
 GLideN64/src/uCodes/S2DEX.cpp                 |    22 +-
 GLideN64/src/windows/GLideN64_windows.cpp     |    20 +-
 GLideN64/src/xxHash/xxh3.h                    |  1579 ++-
 GLideN64/src/xxHash/xxhash.c                  |  1110 --
 GLideN64/src/xxHash/xxhash.h                  |  1796 ++-
 GLideN64/translations/wtl/gliden64_de.Lang    |   217 +
 GLideN64/translations/wtl/gliden64_en.Lang    |   236 +
 GLideN64/translations/wtl/gliden64_es.Lang    |   160 +
 GLideN64/translations/wtl/gliden64_fr.Lang    |   160 +
 GLideN64/translations/wtl/gliden64_it.Lang    |    42 +
 GLideN64/translations/wtl/gliden64_ja.Lang    |    45 +
 GLideN64/translations/wtl/gliden64_pl.Lang    |    45 +
 GLideN64/translations/wtl/gliden64_pt_BR.Lang |    45 +
 160 files changed, 71032 insertions(+), 2300 deletions(-)
 create mode 100644 GLideN64/projects/msvc/GLideNUI-wtl.vcxproj
 create mode 100644 GLideN64/projects/msvc/GLideNUI-wtl.vcxproj.filters
 create mode 100644 GLideN64/src/BufferCopy/BlueNoiseTexture.cpp
 create mode 100644 GLideN64/src/BufferCopy/BlueNoiseTexture.h
 create mode 100644 GLideN64/src/GLideN64.rc
 create mode 100644 GLideN64/src/GLideNUI-wtl/About.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/About.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/ConfigDlg.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/FileClass.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/FileClass.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/FontInfo.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/FontInfo.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/FullscreenResolutions.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/GLideNUI.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/GLideNUI.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/GLideNUI.rc
 create mode 100644 GLideN64/src/GLideNUI-wtl/GlSettings.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/GlSettings.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/IniFileClass.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/IniFileClass.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/InputDialog.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/InputDialog.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/Language.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/Language.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/ScreenShot.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/Settings.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/Settings.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlapp.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlcrack.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlctrls.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlctrlw.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlctrlx.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlddx.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atldlgs.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atldwm.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlfind.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlframe.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlgdi.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlmisc.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlprint.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlres.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlresce.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlribbon.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlscrl.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlsplit.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atltheme.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atluser.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlwince.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/WTL/atlwinx.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-debug.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-debug.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-emulation.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-emulation.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-framebuffer.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-osd.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-osd.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-overscan.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-overscan.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-tab.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-tab.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-texture.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-texture.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-video.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/config-video.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/fullscreenresolutions_windows.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/resource.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/util.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/util.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-ColorButton.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-ColorButton.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-OsdButton.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-OsdButton.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.cpp
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-WindowFont.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl-tooltip.h
 create mode 100644 GLideN64/src/GLideNUI-wtl/wtl.h
 rename GLideN64/src/GLideNUI/{ => Resources}/BottomLeft.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/BottomRight.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Down.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Icon-Original.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Icon.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Info.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Left.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Right.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/TopLeft.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/TopRight.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Up.ico (100%)
 rename GLideN64/src/GLideNUI/{ => Resources}/Warning.ico (100%)
 create mode 100644 GLideN64/src/resource.h
 delete mode 100644 GLideN64/src/xxHash/xxhash.c
 create mode 100644 GLideN64/translations/wtl/gliden64_de.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_en.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_es.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_fr.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_it.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_ja.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_pl.Lang
 create mode 100644 GLideN64/translations/wtl/gliden64_pt_BR.Lang

diff --git a/GLideN64/.gitignore b/GLideN64/.gitignore
index 67be4a1b..72ebf0f1 100644
--- a/GLideN64/.gitignore
+++ b/GLideN64/.gitignore
@@ -3,6 +3,7 @@ Debug*/
 Release*/
 build*/
 Roms/
+*.aps
 *.ncb
 *.suo
 *.sdf
diff --git a/GLideN64/.gitrepo b/GLideN64/.gitrepo
index bc2bd2b9..db1534a1 100644
--- a/GLideN64/.gitrepo
+++ b/GLideN64/.gitrepo
@@ -5,8 +5,8 @@
 ;
 [subrepo]
 	remote = git@github.com:libretro/GLideN64.git
-	branch = develop
-	commit = ae05f137c6f17627ec43f80e653b71622ba58b8e
-	parent = 0ea1a6d4a5950ba7d6a632efa519391cd1338480
+	branch = rebase
+	commit = 589b1b617c11cfee99fd87d5db0fb42752c21942
+	parent = 2171d0866885ad820fdf1da96073e5025f648c89
 	method = rebase
 	cmdver = 0.4.0
diff --git a/GLideN64/appveyor.yml b/GLideN64/appveyor.yml
index c848d626..78257b1f 100644
--- a/GLideN64/appveyor.yml
+++ b/GLideN64/appveyor.yml
@@ -9,15 +9,19 @@ branches:
 skip_branch_with_pr: true
 
 environment:
-  N64PluginsDir: C:\projects\gliden64\build\Zilmar-spec\
-  N64PluginsDir_x64: C:\projects\gliden64\build\Zilmar-spec_x64\
-  Mupen64PluginsDir: C:\projects\gliden64\build\Mupen64Plus\
-  Mupen64PluginsDir_x64: C:\projects\gliden64\build\Mupen64Plus_x64\
+  BUILD_PATH: $(APPVEYOR_BUILD_FOLDER)\build
   QTDIR_x86: C:\Static_Qt_x86
   QTDIR_x64: C:\Static_Qt_x64
   QT_BUILD_BASE_URL: https://github.com/gonetz/GLideN64/releases/download/qt_build/
   QT_BUILD_x86: qt-5_7_1-x86-msvc2017-static
   QT_BUILD_x64: qt-5_7_1-x64-msvc2017-static
+  # Builds
+  PJ64PluginsDirQT: $(BUILD_PATH)\QT_for_Project64\
+  PJ64PluginsDirQT_x64: $(BUILD_PATH)\QT_for_Project64_x64\
+  PJ64PluginsDirWTL: $(BUILD_PATH)\WTL_for_Project64\
+  PJ64PluginsDirWTL_x64: $(BUILD_PATH)\WTL_for_Project64_x64\
+  Mupen64PluginsDir: $(BUILD_PATH)\for_Mupen64Plus\
+  Mupen64PluginsDir_x64: $(BUILD_PATH)\for_Mupen64Plus_x64\
 
 before_build:
   - curl -L -o %QT_BUILD_x86%.7z %QT_BUILD_BASE_URL%/%QT_BUILD_x86%.7z
@@ -27,31 +31,50 @@ before_build:
 
 build_script:
   - cd %APPVEYOR_BUILD_FOLDER%
+  # Zilmar-spec (Qt)
   - set QTDIR=%QTDIR_x64%\%QT_BUILD_x64%
   - msbuild projects/msvc/GLideNUI.vcxproj /m /p:Configuration=Release;Platform=x64
-  - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release;Platform=x64
+  - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release_qt;Platform=x64
   - set QTDIR=%QTDIR_x86%\%QT_BUILD_x86%
   - msbuild projects/msvc/GLideNUI.vcxproj /m /p:Configuration=Release;Platform=Win32
-  - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release;Platform=Win32
+  - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release_qt;Platform=Win32
+  # Zilmar-spec (WTL)
+  - msbuild projects/msvc/GLideNUI-wtl.vcxproj /m /p:Configuration=Release;Platform=x64
+  - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release_wtl;Platform=x64
+  - msbuild projects/msvc/GLideNUI-wtl.vcxproj /m /p:Configuration=Release;Platform=Win32
+  - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release_wtl;Platform=Win32
+  # Mupen64Plus (nogui)
   - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release_mupenplus;Platform=x64
   - msbuild projects/msvc/GLideN64.sln /m /p:Configuration=Release_mupenplus;Platform=Win32
 
 after_build:
-  - copy ini\GLideN64.custom.ini %N64PluginsDir_x64%
-  - copy translations\release\*.qm %N64PluginsDir_x64%
-  - copy ini\GLideN64.custom.ini %N64PluginsDir%
-  - copy translations\release\*.qm %N64PluginsDir%
+  # Zilmar-spec (Qt)
+  - copy ini\GLideN64.custom.ini %PJ64PluginsDirQT_x64%
+  - copy ini\GLideN64.custom.ini %PJ64PluginsDirQT%
+  - copy translations\release\*.qm %PJ64PluginsDirQT_x64%
+  - copy translations\release\*.qm %PJ64PluginsDirQT%
+  # Zilmar-spec (WTL)
+  - copy ini\GLideN64.custom.ini %PJ64PluginsDirWTL_x64%
+  - copy ini\GLideN64.custom.ini %PJ64PluginsDirWTL%
+  - mkdir %PJ64PluginsDirWTL_x64%\translations
+  - mkdir %PJ64PluginsDirWTL%\translations
+  - copy translations\wtl\*.Lang %PJ64PluginsDirWTL_x64%\translations
+  - copy translations\wtl\*.Lang %PJ64PluginsDirWTL%\translations
+  # Mupen64Plus (nogui)
   - copy ini\GLideN64.custom.ini %Mupen64PluginsDir_x64%\
   - copy ini\GLideN64.custom.ini %Mupen64PluginsDir%\
-  - del /Q %N64PluginsDir_x64%\*.lib %N64PluginsDir_x64%\*.exp
-  - del /Q %N64PluginsDir%\*.lib %N64PluginsDir%\*.exp
+  # Cleanup
+  - del /Q %PJ64PluginsDirQT_x64%\*.lib %PJ64PluginsDirQT_x64%\*.exp
+  - del /Q %PJ64PluginsDirQT%\*.lib %PJ64PluginsDirQT%\*.exp
+  - del /Q %PJ64PluginsDirWTL_x64%\*.lib %PJ64PluginsDirWTL_x64%\*.exp
+  - del /Q %PJ64PluginsDirWTL%\*.lib %PJ64PluginsDirWTL%\*.exp
   - del /Q %Mupen64PluginsDir_x64%\*.lib %Mupen64PluginsDir_x64%\*.exp
   - del /Q %Mupen64PluginsDir%\*.lib %Mupen64PluginsDir%\*.exp
-  - cd C:\projects\gliden64\build
+  - cd %BUILD_PATH%
   - ps: $env:revision = git describe --always
-  - set archive_name=GLideN64-%revision%.7z
-  - 7z a %archive_name% *
+  - set archive_name=GLideN64-%revision%-@fname.7z
+  - forfiles /p %BUILD_PATH% /c "cmd /c 7z a %archive_name% @path\*"
 
 artifacts:
-  - path: build\$(archive_name)
-    name: GLideN64
+  - path: build\*.7z
+    name: GLideN64 plugin
diff --git a/GLideN64/ini/GLideN64.custom.ini b/GLideN64/ini/GLideN64.custom.ini
index 97a48be9..14312af5 100644
--- a/GLideN64/ini/GLideN64.custom.ini
+++ b/GLideN64/ini/GLideN64.custom.ini
@@ -10,6 +10,11 @@ frameBufferEmulation\N64DepthCompare=1
 Good_Name=Bio F.R.E.A.K.S. (E)(U)
 frameBufferEmulation\copyToRDRAM=1
 
+[BioHazard%20II]
+frameBufferEmulation\copyFromRDRAM=1
+frameBufferEmulation\copyToRDRAM=0
+frameBufferEmulation\copyDepthToRDRAM=0
+
 [52150A67]
 Good_Name=Bokujou Monogatari 2 (J)
 frameBufferEmulation\N64DepthCompare=1
@@ -41,7 +46,9 @@ frameBufferEmulation\copyDepthToRDRAM=1
 
 [DR.MARIO%2064]
 Good_Name=Dr. Mario 64 (U)
+frameBufferEmulation\fbInfoDisabled=0
 frameBufferEmulation\copyFromRDRAM=1
+frameBufferEmulation\copyToRDRAM=0
 
 [EXTREME_G]
 Good_Name=Extreme-G (E)
@@ -67,6 +74,12 @@ frameBufferEmulation\N64DepthCompare=1
 Good_Name=F-1 Pole Position 64 (E)(U)
 frameBufferEmulation\copyToRDRAM=1
 
+[FLAPPYBIRD64]
+Good_Name=FlappyBird64
+frameBufferEmulation\fbInfoDisabled=0
+frameBufferEmulation\copyFromRDRAM=1
+frameBufferEmulation\copyToRDRAM=0
+
 [GOEMON2%20DERODERO]
 Good_Name=Ganbare Goemon - Dero Dero Douchuu Obake Tenkomori (J)
 graphics2D\enableNativeResTexrects=1
@@ -177,6 +190,7 @@ frameBufferEmulation\N64DepthCompare=1
 
 [POKEMON%20SNAP]
 Good_Name=Pokemon Snap (U)
+generalEmulation\rdramImageDitheringMode=1
 frameBufferEmulation\copyAuxToRDRAM=1
 frameBufferEmulation\copyToRDRAM=1
 frameBufferEmulation\fbInfoDisabled=0
@@ -199,6 +213,11 @@ texture\enableHalosRemoval=1
 Good_Name=Rat Attack
 frameBufferEmulation\fbInfoDisabled=0
 
+[RESIDENT%20EVIL%20II]
+frameBufferEmulation\copyFromRDRAM=1
+frameBufferEmulation\copyToRDRAM=0
+frameBufferEmulation\copyDepthToRDRAM=0
+
 [ROCKMAN%20DASH]
 Good_Name=Rockman Dash - Hagane no Boukenshin (J)
 graphics2D\correctTexrectCoords=2
diff --git a/GLideN64/projects/msvc/GLideN64.sln b/GLideN64/projects/msvc/GLideN64.sln
index af640359..45857614 100644
--- a/GLideN64/projects/msvc/GLideN64.sln
+++ b/GLideN64/projects/msvc/GLideN64.sln
@@ -1,5 +1,4 @@
-
-Microsoft Visual Studio Solution File, Format Version 12.00
+Microsoft Visual Studio Solution File, Format Version 12.00
 # Visual Studio 14
 VisualStudioVersion = 14.0.25420.1
 MinimumVisualStudioVersion = 10.0.40219.1
@@ -15,84 +14,134 @@ Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "osal", "osal.vcxproj", "{7B
 EndProject
 Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GLideNUI", "GLideNUI.vcxproj", "{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}"
 EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "GLideNUI-wtl", "GLideNUI-wtl.vcxproj", "{9E05B70F-A294-44A9-A151-B2CC95AA884E}"
+EndProject
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug_mupenplus|Win32 = Debug_mupenplus|Win32
 		Debug_mupenplus|x64 = Debug_mupenplus|x64
-		Debug|Win32 = Debug|Win32
-		Debug|x64 = Debug|x64
+		Debug_qt|Win32 = Debug_qt|Win32
+		Debug_qt|x64 = Debug_qt|x64
+		Debug_wtl|Win32 = Debug_wtl|Win32
+		Debug_wtl|x64 = Debug_wtl|x64
 		Release_mupenplus|Win32 = Release_mupenplus|Win32
 		Release_mupenplus|x64 = Release_mupenplus|x64
-		Release|Win32 = Release|Win32
-		Release|x64 = Release|x64
+		Release_qt|Win32 = Release_qt|Win32
+		Release_qt|x64 = Release_qt|x64
+		Release_wtl|Win32 = Release_wtl|Win32
+		Release_wtl|x64 = Release_wtl|x64
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_mupenplus|Win32.ActiveCfg = Debug_mupenplus|Win32
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_mupenplus|Win32.Build.0 = Debug_mupenplus|Win32
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_mupenplus|x64.ActiveCfg = Debug_mupenplus|x64
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_mupenplus|x64.Build.0 = Debug_mupenplus|x64
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug|Win32.ActiveCfg = Debug|Win32
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug|Win32.Build.0 = Debug|Win32
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug|x64.ActiveCfg = Debug|x64
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug|x64.Build.0 = Debug|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_qt|Win32.ActiveCfg = Debug_qt|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_qt|Win32.Build.0 = Debug_qt|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_qt|x64.ActiveCfg = Debug_qt|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_qt|x64.Build.0 = Debug_qt|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_wtl|Win32.ActiveCfg = Debug_wtl|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_wtl|Win32.Build.0 = Debug_wtl|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_wtl|x64.ActiveCfg = Debug_wtl|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Debug_wtl|x64.Build.0 = Debug_wtl|x64
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_mupenplus|Win32.ActiveCfg = Release_mupenplus|Win32
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_mupenplus|Win32.Build.0 = Release_mupenplus|Win32
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_mupenplus|x64.ActiveCfg = Release_mupenplus|x64
 		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_mupenplus|x64.Build.0 = Release_mupenplus|x64
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release|Win32.ActiveCfg = Release|Win32
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release|Win32.Build.0 = Release|Win32
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release|x64.ActiveCfg = Release|x64
-		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release|x64.Build.0 = Release|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_qt|Win32.ActiveCfg = Release_qt|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_qt|Win32.Build.0 = Release_qt|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_qt|x64.ActiveCfg = Release_qt|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_qt|x64.Build.0 = Release_qt|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_wtl|Win32.ActiveCfg = Release_wtl|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_wtl|Win32.Build.0 = Release_wtl|Win32
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_wtl|x64.ActiveCfg = Release_wtl|x64
+		{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}.Release_wtl|x64.Build.0 = Release_wtl|x64
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_mupenplus|Win32.ActiveCfg = Debug|Win32
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_mupenplus|Win32.Build.0 = Debug|Win32
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_mupenplus|x64.ActiveCfg = Debug|x64
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_mupenplus|x64.Build.0 = Debug|x64
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug|Win32.ActiveCfg = Debug|Win32
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug|Win32.Build.0 = Debug|Win32
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug|x64.ActiveCfg = Debug|x64
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug|x64.Build.0 = Debug|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_qt|Win32.ActiveCfg = Debug|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_qt|Win32.Build.0 = Debug|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_qt|x64.ActiveCfg = Debug|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_qt|x64.Build.0 = Debug|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_wtl|Win32.ActiveCfg = Debug|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_wtl|Win32.Build.0 = Debug|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_wtl|x64.ActiveCfg = Debug|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Debug_wtl|x64.Build.0 = Debug|x64
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_mupenplus|Win32.ActiveCfg = Release|Win32
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_mupenplus|Win32.Build.0 = Release|Win32
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_mupenplus|x64.ActiveCfg = Release|x64
 		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_mupenplus|x64.Build.0 = Release|x64
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release|Win32.ActiveCfg = Release|Win32
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release|Win32.Build.0 = Release|Win32
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release|x64.ActiveCfg = Release|x64
-		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release|x64.Build.0 = Release|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_qt|Win32.ActiveCfg = Release|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_qt|Win32.Build.0 = Release|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_qt|x64.ActiveCfg = Release|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_qt|x64.Build.0 = Release|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_wtl|Win32.ActiveCfg = Release|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_wtl|Win32.Build.0 = Release|Win32
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_wtl|x64.ActiveCfg = Release|x64
+		{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}.Release_wtl|x64.Build.0 = Release|x64
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_mupenplus|Win32.ActiveCfg = Debug|Win32
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_mupenplus|Win32.Build.0 = Debug|Win32
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_mupenplus|x64.ActiveCfg = Debug|x64
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_mupenplus|x64.Build.0 = Debug|x64
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug|Win32.ActiveCfg = Debug|Win32
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug|Win32.Build.0 = Debug|Win32
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug|x64.ActiveCfg = Debug|x64
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug|x64.Build.0 = Debug|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_qt|Win32.ActiveCfg = Debug|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_qt|Win32.Build.0 = Debug|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_qt|x64.ActiveCfg = Debug|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_qt|x64.Build.0 = Debug|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_wtl|Win32.ActiveCfg = Debug|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_wtl|Win32.Build.0 = Debug|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_wtl|x64.ActiveCfg = Debug|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Debug_wtl|x64.Build.0 = Debug|x64
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_mupenplus|Win32.ActiveCfg = Release|Win32
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_mupenplus|Win32.Build.0 = Release|Win32
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_mupenplus|x64.ActiveCfg = Release|x64
 		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_mupenplus|x64.Build.0 = Release|x64
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release|Win32.ActiveCfg = Release|Win32
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release|Win32.Build.0 = Release|Win32
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release|x64.ActiveCfg = Release|x64
-		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release|x64.Build.0 = Release|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_qt|Win32.ActiveCfg = Release|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_qt|Win32.Build.0 = Release|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_qt|x64.ActiveCfg = Release|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_qt|x64.Build.0 = Release|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_wtl|Win32.ActiveCfg = Release|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_wtl|Win32.Build.0 = Release|Win32
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_wtl|x64.ActiveCfg = Release|x64
+		{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}.Release_wtl|x64.Build.0 = Release|x64
 		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_mupenplus|Win32.ActiveCfg = Debug|Win32
 		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_mupenplus|x64.ActiveCfg = Debug|x64
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug|Win32.ActiveCfg = Debug|Win32
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug|Win32.Build.0 = Debug|Win32
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug|x64.ActiveCfg = Debug|x64
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug|x64.Build.0 = Debug|x64
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_qt|Win32.ActiveCfg = Debug|Win32
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_qt|Win32.Build.0 = Debug|Win32
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_qt|x64.ActiveCfg = Debug|x64
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_qt|x64.Build.0 = Debug|x64
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_wtl|Win32.ActiveCfg = Debug|Win32
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Debug_wtl|x64.ActiveCfg = Debug|x64
 		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_mupenplus|Win32.ActiveCfg = Release|Win32
 		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_mupenplus|x64.ActiveCfg = Release|x64
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release|Win32.ActiveCfg = Release|Win32
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release|Win32.Build.0 = Release|Win32
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release|x64.ActiveCfg = Release|x64
-		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release|x64.Build.0 = Release|x64
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_qt|Win32.ActiveCfg = Release|Win32
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_qt|Win32.Build.0 = Release|Win32
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_qt|x64.ActiveCfg = Release|x64
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_qt|x64.Build.0 = Release|x64
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_wtl|Win32.ActiveCfg = Release|Win32
+		{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}.Release_wtl|x64.ActiveCfg = Release|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_mupenplus|Win32.ActiveCfg = Debug|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_mupenplus|x64.ActiveCfg = Debug|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_qt|Win32.ActiveCfg = Debug|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_qt|x64.ActiveCfg = Debug|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_wtl|Win32.ActiveCfg = Debug|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_wtl|Win32.Build.0 = Debug|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_wtl|x64.ActiveCfg = Debug|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Debug_wtl|x64.Build.0 = Debug|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_mupenplus|Win32.ActiveCfg = Release|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_mupenplus|x64.ActiveCfg = Release|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_qt|Win32.ActiveCfg = Release|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_qt|x64.ActiveCfg = Release|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_wtl|Win32.ActiveCfg = Release|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_wtl|Win32.Build.0 = Release|Win32
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_wtl|x64.ActiveCfg = Release|x64
+		{9E05B70F-A294-44A9-A151-B2CC95AA884E}.Release_wtl|x64.Build.0 = Release|x64
 	EndGlobalSection
 	GlobalSection(SolutionProperties) = preSolution
 		HideSolutionNode = FALSE
 	EndGlobalSection
 	GlobalSection(ExtensibilityGlobals) = postSolution
-		SolutionGuid = {D7155823-2893-4425-94B4-BA469E774A27}
 		Qt5Version = $(DefaultQtVersion)
+		SolutionGuid = {D7155823-2893-4425-94B4-BA469E774A27}
 	EndGlobalSection
 EndGlobal
diff --git a/GLideN64/projects/msvc/GLideN64.vcxproj b/GLideN64/projects/msvc/GLideN64.vcxproj
index 6befe926..bd40f141 100644
--- a/GLideN64/projects/msvc/GLideN64.vcxproj
+++ b/GLideN64/projects/msvc/GLideN64.vcxproj
@@ -9,12 +9,20 @@
       <Configuration>Debug_mupenplus</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
+    <ProjectConfiguration Include="Debug_qt|Win32">
+      <Configuration>Debug_qt</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Debug|x64">
-      <Configuration>Debug</Configuration>
+    <ProjectConfiguration Include="Debug_qt|x64">
+      <Configuration>Debug_qt</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug_wtl|Win32">
+      <Configuration>Debug_wtl</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug_wtl|x64">
+      <Configuration>Debug_wtl</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
     <ProjectConfiguration Include="Release_mupenplus|Win32">
@@ -25,12 +33,20 @@
       <Configuration>Release_mupenplus</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
+    <ProjectConfiguration Include="Release_qt|Win32">
+      <Configuration>Release_qt</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release_qt|x64">
+      <Configuration>Release_qt</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release_wtl|Win32">
+      <Configuration>Release_wtl</Configuration>
       <Platform>Win32</Platform>
     </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|x64">
-      <Configuration>Release</Configuration>
+    <ProjectConfiguration Include="Release_wtl|x64">
+      <Configuration>Release_wtl</Configuration>
       <Platform>x64</Platform>
     </ProjectConfiguration>
   </ItemGroup>
@@ -38,6 +54,11 @@
     <ProjectGuid>{37D31D7F-C4E7-45B0-AEF6-D6824A243CF7}</ProjectGuid>
     <RootNamespace>GLideN64</RootNamespace>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)'=='' and '$(VisualStudioVersion)' != '12.0' and '$(VisualStudioVersion)' != '14.0'">
+    <LatestTargetPlatformVersion>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion('Windows', '10.0'))</LatestTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
+    <TargetPlatformVersion>$(WindowsTargetPlatformVersion)</TargetPlatformVersion>
+  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
     <ConfigurationType>DynamicLibrary</ConfigurationType>
@@ -60,10 +81,10 @@
     <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\</OutDir>
     <IntDir>$(SolutionDir)build\$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Debug_mupenplus'">
+  <PropertyGroup Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or'$(Configuration)'=='Debug_mupenplus'">
     <LinkIncremental>true</LinkIncremental>
   </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)'=='Release' Or '$(Configuration)'=='Release_mupenplus'">
+  <PropertyGroup Condition="'$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl' Or '$(Configuration)'=='Release_mupenplus'">
     <LinkIncremental>false</LinkIncremental>
   </PropertyGroup>
   <PropertyGroup Condition="'$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release_mupenplus'">
@@ -90,7 +111,7 @@
       <Command>call ..\..\src\getRevision.bat</Command>
     </PreBuildEvent>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Debug_mupenplus'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Debug_mupenplus'">
     <ClCompile>
       <PreprocessorDefinitions>GL_DEBUG;DEBUG_DUMP;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <Optimization>Disabled</Optimization>
@@ -103,7 +124,7 @@
       <AdditionalDependencies>freetype253MT_D.lib;%(AdditionalDependencies)</AdditionalDependencies>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release' Or '$(Configuration)'=='Release_mupenplus'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl' Or '$(Configuration)'=='Release_mupenplus'">
     <ClCompile>
       <Optimization>Full</Optimization>
       <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
@@ -116,7 +137,7 @@
       <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
       <StringPooling>true</StringPooling>
       <FunctionLevelLinking>true</FunctionLevelLinking>
-      <WholeProgramOptimization>true</WholeProgramOptimization>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
     </ClCompile>
     <Link>
       <GenerateDebugInformation>false</GenerateDebugInformation>
@@ -142,41 +163,56 @@
       <AdditionalDependencies>legacy_stdio_definitions.lib;%(AdditionalDependencies)</AdditionalDependencies>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="('$(Configuration)'=='Debug' Or '$(Configuration)'=='Debug_mupenplus') And '$(Platform)'=='Win32'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_wtl'">
+    <ClCompile>
+      <PreprocessorDefinitions>WTL_UI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ClCompile>
+    <ResourceCompile>
+      <PreprocessorDefinitions>WTL_UI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+    </ResourceCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="('$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Debug_mupenplus') And '$(Platform)'=='Win32'">
     <Link>
       <AdditionalLibraryDirectories Condition="'$(MSBuildAssemblyVersion)'=='12.0'">lib/msvc12/dbg</AdditionalLibraryDirectories>
       <AdditionalLibraryDirectories Condition="'$(MSBuildAssemblyVersion)'!='12.0'">lib/dbg</AdditionalLibraryDirectories>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="('$(Configuration)'=='Debug' Or '$(Configuration)'=='Debug_mupenplus') And '$(Platform)'=='x64'">
+  <ItemDefinitionGroup Condition="('$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Debug_mupenplus') And '$(Platform)'=='x64'">
     <Link>
       <AdditionalLibraryDirectories>lib/x64/dbg</AdditionalLibraryDirectories>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="('$(Configuration)'=='Release' Or '$(Configuration)'=='Release_mupenplus') And '$(Platform)'=='Win32'">
+  <ItemDefinitionGroup Condition="('$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl' Or '$(Configuration)'=='Release_mupenplus') And '$(Platform)'=='Win32'">
     <Link>
       <AdditionalLibraryDirectories Condition="'$(MSBuildAssemblyVersion)'=='12.0'">lib/msvc12/rel</AdditionalLibraryDirectories>
       <AdditionalLibraryDirectories Condition="'$(MSBuildAssemblyVersion)'!='12.0'">lib/rel</AdditionalLibraryDirectories>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="('$(Configuration)'=='Release' Or '$(Configuration)'=='Release_mupenplus') And '$(Platform)'=='x64'">
+  <ItemDefinitionGroup Condition="('$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl' Or '$(Configuration)'=='Release_mupenplus') And '$(Platform)'=='x64'">
     <Link>
       <AdditionalLibraryDirectories>lib/x64/rel</AdditionalLibraryDirectories>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">
     <ClCompile>
       <PreprocessorDefinitions>GL_USE_UNIFORMBLOCK;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ClCompile>
     <ResourceCompile>
       <PreprocessorDefinitions>ZILMAR_API;%(PreprocessorDefinitions)</PreprocessorDefinitions>
     </ResourceCompile>
-    <PostBuildEvent>
+    <PostBuildEvent Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Release_qt'">
       <Message>Copy result to plugins folder</Message>
-      <Command Condition="'$(Platform)'=='Win32'">if NOT "$(N64PluginsDir)" == "" (if not exist "$(N64PluginsDir)" mkdir "$(N64PluginsDir)"
-copy /Y "$(OutDir)$(TargetName).*" "$(N64PluginsDir)")</Command>
-      <Command Condition="'$(Platform)'=='x64'">if NOT "$(N64PluginsDir_x64)" == "" (if not exist "$(N64PluginsDir_x64)" mkdir "$(N64PluginsDir_x64)"
-copy /Y "$(OutDir)$(TargetName).*" "$(N64PluginsDir_x64)")</Command>
+      <Command Condition="'$(Platform)'=='Win32'">if NOT "$(PJ64PluginsDirQT)" == "" (if not exist "$(PJ64PluginsDirQT)" mkdir "$(PJ64PluginsDirQT)"
+copy /Y "$(OutDir)$(TargetName).*" "$(PJ64PluginsDirQT)")</Command>
+      <Command Condition="'$(Platform)'=='x64'">if NOT "$(PJ64PluginsDirQT_x64)" == "" (if not exist "$(PJ64PluginsDirQT_x64)" mkdir "$(PJ64PluginsDirQT_x64)"
+copy /Y "$(OutDir)$(TargetName).*" "$(PJ64PluginsDirQT_x64)")</Command>
+    </PostBuildEvent>
+    <PostBuildEvent Condition="'$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_wtl'">
+      <Message>Copy result to plugins folder</Message>
+      <Command Condition="'$(Platform)'=='Win32'">if NOT "$(PJ64PluginsDirWTL)" == "" (if not exist "$(PJ64PluginsDirWTL)" mkdir "$(PJ64PluginsDirWTL)"
+copy /Y "$(OutDir)$(TargetName).*" "$(PJ64PluginsDirWTL)")</Command>
+      <Command Condition="'$(Platform)'=='x64'">if NOT "$(PJ64PluginsDirWTL_x64)" == "" (if not exist "$(PJ64PluginsDirWTL_x64)" mkdir "$(PJ64PluginsDirWTL_x64)"
+copy /Y "$(OutDir)$(TargetName).*" "$(PJ64PluginsDirWTL_x64)")</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
   <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release_mupenplus'">
@@ -191,24 +227,35 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir)")</Command>
 copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     </PostBuildEvent>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_qt'">
     <Link>
       <AdditionalDependencies>bin\$(Platform)\Debug\lib\GLideNUI.lib;%(AdditionalDependencies)</AdditionalDependencies>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_wtl'">
+    <Link>
+      <AdditionalDependencies>bin\$(Platform)\Debug\lib\GLideNUI-wtl.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release_qt'">
     <Link>
       <AdditionalDependencies>bin\$(Platform)\Release\lib\GLideNUI.lib;%(AdditionalDependencies)</AdditionalDependencies>
       <AdditionalOptions>/LTCG %(AdditionalOptions)</AdditionalOptions>
     </Link>
   </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release' Or '$(Configuration)'=='Release_mupenplus'">
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release_wtl'">
+    <Link>
+      <AdditionalDependencies>bin\$(Platform)\Release\lib\GLideNUI-wtl.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Link>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl' Or '$(Configuration)'=='Release_mupenplus'">
     <ClCompile>
       <AdditionalIncludeDirectories>../../src/inc/freetype/include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
     </ClCompile>
   </ItemDefinitionGroup>
   <ItemGroup>
     <ClCompile Include="..\..\src\3DMath.cpp" />
+    <ClCompile Include="..\..\src\BufferCopy\BlueNoiseTexture.cpp" />
     <ClCompile Include="..\..\src\BufferCopy\ColorBufferToRDRAM.cpp" />
     <ClCompile Include="..\..\src\BufferCopy\DepthBufferToRDRAM.cpp" />
     <ClCompile Include="..\..\src\BufferCopy\RDRAMtoColorBuffer.cpp" />
@@ -245,7 +292,7 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     <ClCompile Include="..\..\src\Graphics\OpenGLContext\GLSL\glsl_SpecialShadersFactory.cpp" />
     <ClCompile Include="..\..\src\Graphics\OpenGLContext\GLSL\glsl_Utils.cpp" />
     <ClCompile Include="..\..\src\Graphics\OpenGLContext\mupen64plus\mupen64plus_DisplayWindow.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\Graphics\OpenGLContext\opengl_Attributes.cpp" />
     <ClCompile Include="..\..\src\Graphics\OpenGLContext\opengl_BufferManipulationObjectFactory.cpp" />
@@ -278,19 +325,19 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     <ClCompile Include="..\..\src\Keys.cpp" />
     <ClCompile Include="..\..\src\Log.cpp" />
     <ClCompile Include="..\..\src\MupenPlusPluginAPI.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\mupenplus\CommonAPIImpl_mupenplus.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\mupenplus\Config_mupenplus.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\mupenplus\MemoryStatus_mupenplus.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\mupenplus\MupenPlusAPIImpl.cpp">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClCompile>
     <ClCompile Include="..\..\src\N64.cpp" />
     <ClCompile Include="..\..\src\NoiseTexture.cpp" />
@@ -352,7 +399,6 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     <ClCompile Include="..\..\src\windows\ZilmarAPIImpl_windows.cpp">
       <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release_mupenplus'">true</ExcludedFromBuild>
     </ClCompile>
-    <ClCompile Include="..\..\src\xxHash\xxhash.c" />
     <ClCompile Include="..\..\src\ZilmarPluginAPI.cpp">
       <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release_mupenplus'">true</ExcludedFromBuild>
     </ClCompile>
@@ -360,6 +406,7 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\3DMath.h" />
+    <ClInclude Include="..\..\src\BufferCopy\BlueNoiseTexture.h" />
     <ClInclude Include="..\..\src\BufferCopy\ColorBufferToRDRAM.h" />
     <ClInclude Include="..\..\src\BufferCopy\DepthBufferToRDRAM.h" />
     <ClInclude Include="..\..\src\BufferCopy\RDRAMtoColorBuffer.h" />
@@ -433,7 +480,7 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     <ClInclude Include="..\..\src\Log.h" />
     <ClInclude Include="..\..\src\MemoryStatus.h" />
     <ClInclude Include="..\..\src\mupenplus\GLideN64_mupenplus.h">
-      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug' Or '$(Configuration)'=='Release'">true</ExcludedFromBuild>
+      <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_qt' Or '$(Configuration)'=='Release_wtl'">true</ExcludedFromBuild>
     </ClInclude>
     <ClInclude Include="..\..\src\N64.h" />
     <ClInclude Include="..\..\src\NoiseTexture.h" />
@@ -444,6 +491,7 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     <ClInclude Include="..\..\src\PostProcessor.h" />
     <ClInclude Include="..\..\src\RDP.h" />
     <ClInclude Include="..\..\src\GraphicsDrawer.h" />
+    <ClInclude Include="..\..\src\resource.h" />
     <ClInclude Include="..\..\src\RSP.h" />
     <ClInclude Include="..\..\src\SoftwareRender.h" />
     <ClInclude Include="..\..\src\TexrectDrawer.h" />
@@ -479,12 +527,23 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
     <ClInclude Include="..\..\src\VI.h" />
     <ClInclude Include="..\..\src\windows\GLideN64_windows.h" />
     <ClInclude Include="..\..\src\wst.h" />
+    <ClInclude Include="..\..\src\xxHash\xxh3.h" />
     <ClInclude Include="..\..\src\xxHash\xxhash.h" />
     <ClInclude Include="..\..\src\ZilmarGFX_1_3.h">
       <ExcludedFromBuild Condition="'$(Configuration)'=='Debug_mupenplus' Or '$(Configuration)'=='Release_mupenplus'">true</ExcludedFromBuild>
     </ClInclude>
     <ClInclude Include="..\..\src\ZlutTexture.h" />
   </ItemGroup>
+  <ItemGroup Condition="'$(Configuration)'=='Debug_qt' Or '$(Configuration)'=='Release_qt'">
+    <ProjectReference Include="GLideNUI.vcxproj">
+      <Project>{37cab375-a7a6-3cab-bd56-0e954d3fd2fe}</Project>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup Condition="'$(Configuration)'=='Debug_wtl' Or '$(Configuration)'=='Release_wtl'">
+    <ProjectReference Include="GLideNUI-wtl.vcxproj">
+      <Project>{9e05b70f-a294-44a9-a151-b2cc95aa884e}</Project>
+    </ProjectReference>
+  </ItemGroup>
   <ItemGroup>
     <ProjectReference Include="libGLideNHQ.vcxproj">
       <Project>{da965bcf-2219-47af-ace7-eaf76d5d4756}</Project>
@@ -493,6 +552,9 @@ copy /Y "$(OutDir)$(TargetName).*" "$(Mupen64PluginsDir_x64)")</Command>
       <Project>{7bf6f100-31db-44ae-a2a5-5ddeed9a909c}</Project>
     </ProjectReference>
   </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\..\src\GLideN64.rc" />
+  </ItemGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
   <ImportGroup Label="ExtensionTargets">
   </ImportGroup>
diff --git a/GLideN64/projects/msvc/GLideN64.vcxproj.filters b/GLideN64/projects/msvc/GLideN64.vcxproj.filters
index 0923c563..4a085887 100644
--- a/GLideN64/projects/msvc/GLideN64.vcxproj.filters
+++ b/GLideN64/projects/msvc/GLideN64.vcxproj.filters
@@ -75,6 +75,9 @@
     <Filter Include="Source Files\Graphics\OpenGL\ThreadedOpenGL">
       <UniqueIdentifier>{32e9be50-cb55-445a-9562-bbe05085bbe1}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{afe20b4b-eb13-4282-bf72-47335887c770}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
     <ClCompile Include="..\..\src\Combiner.cpp">
@@ -305,9 +308,6 @@
     <ClCompile Include="..\..\src\CRC_OPT.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
-    <ClCompile Include="..\..\src\xxHash\xxhash.c">
-      <Filter>Source Files</Filter>
-    </ClCompile>
     <ClCompile Include="..\..\src\DebugDump.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -422,6 +422,9 @@
     <ClCompile Include="..\..\src\Graphics\OpenGLContext\ThreadedOpenGl\RingBufferPool.cpp">
       <Filter>Source Files\Graphics\OpenGL\ThreadedOpenGL</Filter>
     </ClCompile>
+    <ClCompile Include="..\..\src\BufferCopy\BlueNoiseTexture.cpp">
+      <Filter>Source Files\BufferCopy</Filter>
+    </ClCompile>
   </ItemGroup>
   <ItemGroup>
     <ClInclude Include="..\..\src\3DMath.h">
@@ -664,6 +667,9 @@
     <ClInclude Include="..\..\src\TexrectDrawer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\xxHash\xxh3.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\..\src\xxHash\xxhash.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -781,5 +787,16 @@
     <ClInclude Include="..\..\src\Graphics\OpenGLContext\ThreadedOpenGl\readerwriterqueue.h">
       <Filter>Header Files\Graphics\OpenGL\ThreadedOpenGL</Filter>
     </ClInclude>
+    <ClInclude Include="..\..\src\BufferCopy\BlueNoiseTexture.h">
+      <Filter>Header Files\BufferCopy</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\resource.h">
+      <Filter>Resource Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\..\src\GLideN64.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
   </ItemGroup>
 </Project>
\ No newline at end of file
diff --git a/GLideN64/projects/msvc/GLideNUI-wtl.vcxproj b/GLideN64/projects/msvc/GLideNUI-wtl.vcxproj
new file mode 100644
index 00000000..9406407b
--- /dev/null
+++ b/GLideN64/projects/msvc/GLideNUI-wtl.vcxproj
@@ -0,0 +1,191 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup Label="ProjectConfigurations">
+    <ProjectConfiguration Include="Debug|x64">
+      <Configuration>Debug</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|Win32">
+      <Configuration>Release</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Debug|Win32">
+      <Configuration>Debug</Configuration>
+      <Platform>Win32</Platform>
+    </ProjectConfiguration>
+    <ProjectConfiguration Include="Release|x64">
+      <Configuration>Release</Configuration>
+      <Platform>x64</Platform>
+    </ProjectConfiguration>
+  </ItemGroup>
+  <PropertyGroup Label="Globals">
+    <ProjectGuid>{9E05B70F-A294-44A9-A151-B2CC95AA884E}</ProjectGuid>
+    <RootNamespace>GLideNUIwtl</RootNamespace>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)'=='' and '$(VisualStudioVersion)' != '12.0' and '$(VisualStudioVersion)' != '14.0'">
+    <LatestTargetPlatformVersion>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion('Windows', '10.0'))</LatestTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
+    <TargetPlatformVersion>$(WindowsTargetPlatformVersion)</TargetPlatformVersion>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
+  <PropertyGroup Label="Configuration">
+    <PlatformToolSet>$(DefaultPlatformToolset)</PlatformToolSet>
+    <ATLMinimizesCRunTimeLibraryUsage>false</ATLMinimizesCRunTimeLibraryUsage>
+    <CharacterSet>NotSet</CharacterSet>
+    <ConfigurationType>StaticLibrary</ConfigurationType>
+    <PrimaryOutput>GLideNUI-wtl</PrimaryOutput>
+  </PropertyGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
+  <ImportGroup Label="ExtensionSettings" />
+  <ImportGroup Label="PropertySheets">
+    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
+  </ImportGroup>
+  <PropertyGroup Label="UserMacros" />
+  <PropertyGroup>
+    <OutDir>$(SolutionDir)bin\$(Platform)\$(Configuration)\lib\</OutDir>
+    <IntDir>$(SolutionDir)build\$(Platform)\$(Configuration)\$(ProjectName)\</IntDir>
+    <TargetName>$(ProjectName)</TargetName>
+    <IgnoreImportLibrary>true</IgnoreImportLibrary>
+  </PropertyGroup>
+  <ItemDefinitionGroup>
+    <ClCompile>
+      <PreprocessorDefinitions>_WINDOWS;UNICODE;WIN32;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <AdditionalIncludeDirectories>%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
+      <AdditionalOptions>-Zm200 -w34100 -w34189 %(AdditionalOptions)</AdditionalOptions>
+      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
+      <BrowseInformation>false</BrowseInformation>
+      <ExceptionHandling>Sync</ExceptionHandling>
+      <ObjectFileName>$(IntDir)</ObjectFileName>
+      <PreprocessToFile>false</PreprocessToFile>
+      <ProgramDataBaseFileName>$(IntDir)vc$(VisualStudioVersion).pdb</ProgramDataBaseFileName>
+      <RuntimeTypeInfo>true</RuntimeTypeInfo>
+      <SuppressStartupBanner>true</SuppressStartupBanner>
+      <TreatWChar_tAsBuiltInType>true</TreatWChar_tAsBuiltInType>
+      <WarningLevel>Level3</WarningLevel>
+      <OutputFile>$(OutDir)\GLideNUI-wtl.lib</OutputFile>
+    </ClCompile>
+    <Lib>
+      <AdditionalDependencies>imm32.lib;Ws2_32.lib;%(AdditionalDependencies)</AdditionalDependencies>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Debug'">
+    <ClCompile>
+      <PreprocessorDefinitions>DEBUG_DUMP;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
+      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
+      <Optimization>Disabled</Optimization>
+      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
+      <MultiProcessorCompilation>true</MultiProcessorCompilation>
+    </ClCompile>
+  </ItemDefinitionGroup>
+  <ItemDefinitionGroup Condition="'$(Configuration)'=='Release'">
+    <ClCompile>
+      <DebugInformationFormat>None</DebugInformationFormat>
+      <Optimization>MaxSpeed</Optimization>
+      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
+      <WholeProgramOptimization>false</WholeProgramOptimization>
+    </ClCompile>
+    <Lib>
+      <LinkTimeCodeGeneration>true</LinkTimeCodeGeneration>
+    </Lib>
+  </ItemDefinitionGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\About.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-debug.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-emulation.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-framebuffer.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-osd.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-overscan.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-tab.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-texture.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-video.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\ConfigDlg.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\FileClass.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\FontInfo.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\fullscreenresolutions_windows.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\GLideNUI.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\GlSettings.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\IniFileClass.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\InputDialog.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\Language.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\ScreenShot.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\Settings.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\util.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-BitmapPicture.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-ColorButton.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-OsdButton.cpp" />
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-OsdPreview.cpp" />
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\About.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-debug.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-emulation.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-framebuffer.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-osd.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-overscan.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-tab.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-texture.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-video.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\ConfigDlg.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\FileClass.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\FontInfo.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\FullscreenResolutions.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\GLideNUI.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\GlSettings.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\IniFileClass.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\InputDialog.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\Language.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\resource.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\Settings.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\util.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-BitmapPicture.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-ColorButton.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-OsdButton.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-OsdPreview.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-tooltip.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-WindowFont.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlapp.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlcrack.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlctrls.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlctrlw.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlctrlx.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlddx.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atldlgs.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atldwm.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlfind.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlframe.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlgdi.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlmisc.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlprint.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlres.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlresce.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlribbon.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlscrl.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlsplit.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atltheme.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atluser.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlwince.h" />
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlwinx.h" />
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\..\src\GLideNUI-wtl\GLideNUI.rc" />
+  </ItemGroup>
+  <ItemGroup>
+    <Image Include="..\..\src\GLideNUI\Resources\BottomLeft.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\BottomRight.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Down.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Icon-Original.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Icon.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Info.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Left.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Right.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\TopLeft.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\TopRight.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Up.ico" />
+    <Image Include="..\..\src\GLideNUI\Resources\Warning.ico" />
+  </ItemGroup>
+  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
+  <ImportGroup Label="ExtensionTargets" />
+  <ProjectExtensions>
+  </ProjectExtensions>
+</Project>
\ No newline at end of file
diff --git a/GLideN64/projects/msvc/GLideNUI-wtl.vcxproj.filters b/GLideN64/projects/msvc/GLideNUI-wtl.vcxproj.filters
new file mode 100644
index 00000000..a286bf8a
--- /dev/null
+++ b/GLideN64/projects/msvc/GLideNUI-wtl.vcxproj.filters
@@ -0,0 +1,295 @@
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+  <ItemGroup>
+    <Filter Include="Source Files">
+      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
+      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
+    </Filter>
+    <Filter Include="Header Files">
+      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
+      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
+    </Filter>
+    <Filter Include="Resource Files">
+      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
+      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
+    </Filter>
+    <Filter Include="Header Files\WTL">
+      <UniqueIdentifier>{b0c2b4e8-31f7-46e5-9b96-cfe8b94db5cf}</UniqueIdentifier>
+    </Filter>
+  </ItemGroup>
+  <ItemGroup>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\About.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-debug.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\ConfigDlg.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-emulation.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-framebuffer.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-osd.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-overscan.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-tab.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-texture.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\config-video.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\FileClass.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\FontInfo.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\fullscreenresolutions_windows.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\GLideNUI.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\GlSettings.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\IniFileClass.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\ScreenShot.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\Settings.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\util.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-BitmapPicture.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-ColorButton.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-OsdButton.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\wtl-OsdPreview.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\InputDialog.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\..\src\GLideNUI-wtl\Language.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+  </ItemGroup>
+  <ItemGroup>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\About.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-debug.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\ConfigDlg.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-emulation.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-framebuffer.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-osd.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-overscan.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-tab.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-texture.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\config-video.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\FileClass.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\FontInfo.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\FullscreenResolutions.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\GLideNUI.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\GlSettings.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\IniFileClass.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\resource.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\Settings.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\util.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-BitmapPicture.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-ColorButton.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-OsdButton.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-OsdPreview.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-WindowFont.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlapp.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlcrack.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlctrls.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlctrlw.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlctrlx.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlddx.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atldlgs.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atldwm.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlfind.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlframe.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlgdi.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlmisc.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlprint.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlres.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlresce.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlribbon.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlscrl.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlsplit.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atltheme.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atluser.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlwince.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\WTL\atlwinx.h">
+      <Filter>Header Files\WTL</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\InputDialog.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\Language.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\..\src\GLideNUI-wtl\wtl-tooltip.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+  </ItemGroup>
+  <ItemGroup>
+    <Image Include="..\..\src\GLideNUI-wtl\Icon-Original.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\BottomLeft.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\BottomRight.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Down.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Icon.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Icon-Original.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Info.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Left.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Right.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\TopLeft.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\TopRight.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Up.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+    <Image Include="..\..\src\GLideNUI\Resources\Warning.ico">
+      <Filter>Resource Files</Filter>
+    </Image>
+  </ItemGroup>
+  <ItemGroup>
+    <ResourceCompile Include="..\..\src\GLideNUI-wtl\GLideNUI.rc">
+      <Filter>Resource Files</Filter>
+    </ResourceCompile>
+  </ItemGroup>
+</Project>
\ No newline at end of file
diff --git a/GLideN64/projects/msvc/GLideNUI.vcxproj b/GLideN64/projects/msvc/GLideNUI.vcxproj
index 689b28aa..d0027245 100644
--- a/GLideN64/projects/msvc/GLideNUI.vcxproj
+++ b/GLideN64/projects/msvc/GLideNUI.vcxproj
@@ -22,7 +22,11 @@
     <ProjectGuid>{37CAB375-A7A6-3CAB-BD56-0E954D3FD2FE}</ProjectGuid>
     <RootNamespace>GLideNUI</RootNamespace>
     <Keyword>Qt4VSv1.0</Keyword>
-    <WindowsTargetPlatformVersion>8.1</WindowsTargetPlatformVersion>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)'=='' and '$(VisualStudioVersion)' != '12.0' and '$(VisualStudioVersion)' != '14.0'">
+    <LatestTargetPlatformVersion>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion('Windows', '10.0'))</LatestTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
+    <TargetPlatformVersion>$(WindowsTargetPlatformVersion)</TargetPlatformVersion>
   </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
@@ -168,7 +172,7 @@ endlocal
     </CustomBuild>
   </ItemGroup>
   <ItemGroup>
-    <None Include="..\..\src\GLideNUI\Icon.ico">
+    <None Include="..\..\src\GLideNUI\Resources\Icon.ico">
       <ExcludedFromBuild>true</ExcludedFromBuild>
     </None>
     <CustomBuild Include="..\..\src\GLideNUI\icon.qrc">
diff --git a/GLideN64/projects/msvc/GLideNUI.vcxproj.filters b/GLideN64/projects/msvc/GLideNUI.vcxproj.filters
index 29383d81..67b6c557 100644
--- a/GLideN64/projects/msvc/GLideNUI.vcxproj.filters
+++ b/GLideN64/projects/msvc/GLideNUI.vcxproj.filters
@@ -117,7 +117,7 @@
     </CustomBuild>
   </ItemGroup>
   <ItemGroup>
-    <None Include="..\..\src\GLideNUI\Icon.ico">
+    <None Include="..\..\src\GLideNUI\Resources\Icon.ico">
       <Filter>Resource Files</Filter>
     </None>
     <CustomBuild Include="..\..\src\GLideNUI\icon.qrc">
diff --git a/GLideN64/projects/msvc/libGLideNHQ.vcxproj b/GLideN64/projects/msvc/libGLideNHQ.vcxproj
index d5f69b70..2166cb09 100644
--- a/GLideN64/projects/msvc/libGLideNHQ.vcxproj
+++ b/GLideN64/projects/msvc/libGLideNHQ.vcxproj
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="us-ascii"?>
+<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup Label="ProjectConfigurations">
     <ProjectConfiguration Include="Debug|Win32">
@@ -20,10 +20,13 @@
   </ItemGroup>
   <PropertyGroup Label="Globals">
     <ProjectGUID>{DA965BCF-2219-47AF-ACE7-EAF76D5D4756}</ProjectGUID>
-    <Keyword>Win32Proj</Keyword>
-    <Platform>Win32</Platform>
     <ProjectName>libGLideNHQ</ProjectName>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)'=='' and '$(VisualStudioVersion)' != '12.0' and '$(VisualStudioVersion)' != '14.0'">
+    <LatestTargetPlatformVersion>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion('Windows', '10.0'))</LatestTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
+    <TargetPlatformVersion>$(WindowsTargetPlatformVersion)</TargetPlatformVersion>
+  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
diff --git a/GLideN64/projects/msvc/libGLideNHQ.vcxproj.filters b/GLideN64/projects/msvc/libGLideNHQ.vcxproj.filters
index 55eed07a..c8484e32 100644
--- a/GLideN64/projects/msvc/libGLideNHQ.vcxproj.filters
+++ b/GLideN64/projects/msvc/libGLideNHQ.vcxproj.filters
@@ -1,5 +1,5 @@
-<?xml version="1.0" encoding="Windows-1252"?>
-<Project ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
+<?xml version="1.0" encoding="utf-8"?>
+<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
   <ItemGroup>
     <ClCompile Include="..\..\src\GLideNHQ\TextureFilters_2xsai.cpp">
       <Filter>Source Files</Filter>
diff --git a/GLideN64/projects/msvc/osal.vcxproj b/GLideN64/projects/msvc/osal.vcxproj
index d4158819..0659e90b 100644
--- a/GLideN64/projects/msvc/osal.vcxproj
+++ b/GLideN64/projects/msvc/osal.vcxproj
@@ -22,6 +22,11 @@
     <ProjectGuid>{7BF6F100-31DB-44AE-A2A5-5DDEED9A909C}</ProjectGuid>
     <RootNamespace>osal</RootNamespace>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(WindowsTargetPlatformVersion)'=='' and '$(VisualStudioVersion)' != '12.0' and '$(VisualStudioVersion)' != '14.0'">
+    <LatestTargetPlatformVersion>$([Microsoft.Build.Utilities.ToolLocationHelper]::GetLatestSDKTargetPlatformVersion('Windows', '10.0'))</LatestTargetPlatformVersion>
+    <WindowsTargetPlatformVersion>$(LatestTargetPlatformVersion)</WindowsTargetPlatformVersion>
+    <TargetPlatformVersion>$(WindowsTargetPlatformVersion)</TargetPlatformVersion>
+  </PropertyGroup>
   <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
   <PropertyGroup Label="Configuration">
     <ConfigurationType>StaticLibrary</ConfigurationType>
diff --git a/GLideN64/src/BufferCopy/BlueNoiseTexture.cpp b/GLideN64/src/BufferCopy/BlueNoiseTexture.cpp
new file mode 100644
index 00000000..ac8b848a
--- /dev/null
+++ b/GLideN64/src/BufferCopy/BlueNoiseTexture.cpp
@@ -0,0 +1,533 @@
+#include "BlueNoiseTexture.h"
+
+const BlueNoiseItem blueNoiseTex[8][64][64] =
+{
+	{
+		{ { -1, -3, 2 },{ 1, -4, -1 },{ -4, -4, 2 },{ 0, -1, -2 },{ 1, 3, 1 },{ -3, 0, 0 },{ -2, 2, -1 },{ 0, -2, 3 },{ -3, 2, -1 },{ 3, -2, 0 },{ 3, 2, -4 },{ 1, -2, 3 },{ 0, -4, 0 },{ -2, -1, -3 },{ -1, 0, 1 },{ 3, -4, 1 },{ 0, 3, 2 },{ -1, 2, -1 },{ -4, -2, -4 },{ 1, 1, 1 },{ -1, -2, -4 },{ -3, 2, 3 },{ 3, 2, -3 },{ 1, -4, 0 },{ -3, 1, -2 },{ 3, -3, 3 },{ -1, 1, 1 },{ 0, -2, 3 },{ 2, -3, -1 },{ -4, 3, -3 },{ -2, -2, 0 },{ 2, -4, -1 },{ -2, 1, 2 },{ 1, 0, -2 },{ 2, 3, 1 },{ -1, 1, -1 },{ -4, 0, -2 },{ 1, -2, 3 },{ -3, 2, -4 },{ 2, -3, 0 },{ 0, 1, 1 },{ -2, 3, -3 },{ -4, -3, -1 },{ 1, 2, -2 },{ -1, 0, 3 },{ -2, 2, 2 },{ -3, 0, -1 },{ 0, -2, 2 },{ -2, -2, 3 },{ -3, 3, -4 },{ 2, 0, 0 },{ -1, -1, 2 },{ -3, 3, -1 },{ 1, 2, 3 },{ 2, 3, -1 },{ -2, -2, 2 },{ -4, -1, -3 },{ -2, 3, 3 },{ 0, 1, -3 },{ 1, -3, 0 },{ -1, -2, -2 },{ 3, -1, 2 },{ -2, -4, 0 },{ 2, 3, 3 } },
+		{ { 0, 0, -2 },{ 2, 2, 1 },{ 3, 2, -4 },{ -3, -1, 0 },{ -1, -4, -4 },{ 1, -3, -3 },{ 3, 0, 1 },{ -1, -3, -3 },{ 1, 1, 2 },{ -4, -3, -4 },{ -2, 3, 3 },{ -4, -1, -2 },{ 2, 1, 2 },{ 1, 3, -4 },{ -4, -3, -1 },{ -3, -1, -4 },{ 1, 1, 3 },{ -3, -4, -3 },{ 3, -1, 2 },{ -2, 3, -2 },{ 2, -1, 1 },{ 0, -3, 0 },{ -4, 0, -2 },{ -1, -2, 1 },{ 0, -1, -4 },{ 2, -4, -4 },{ -2, 0, 1 },{ -3, 1, 0 },{ -2, -4, -4 },{ 3, 0, 2 },{ 1, 1, -3 },{ -1, -3, 1 },{ -4, -1, -1 },{ 3, -3, 0 },{ -3, 0, 3 },{ -3, -4, 1 },{ 2, -1, -3 },{ -2, -3, 1 },{ 0, -4, 2 },{ 3, -1, -2 },{ -1, -1, -2 },{ -1, 0, 3 },{ 2, 1, 1 },{ 0, 3, 0 },{ -4, -2, -4 },{ -1, -4, -3 },{ 3, 1, 1 },{ -4, -1, -4 },{ 2, 1, -1 },{ 0, -4, 0 },{ -4, 1, -2 },{ 0, -4, -3 },{ -4, -2, -4 },{ 3, 1, -3 },{ 0, -1, -2 },{ -1, -4, -4 },{ 2, 1, 0 },{ 3, -1, 1 },{ -2, -4, -4 },{ -4, 0, -1 },{ 2, 2, 3 },{ -3, 3, -2 },{ 1, -3, -3 },{ -3, 1, -3 } },
+		{ { -4, -2, 2 },{ -2, 1, 3 },{ 0, -3, -2 },{ -4, -2, 1 },{ -2, 1, 3 },{ 2, 2, 2 },{ -4, 3, -2 },{ 0, -1, -4 },{ -2, 3, -1 },{ 0, -4, 1 },{ -1, 0, -3 },{ -3, 1, -1 },{ 3, -3, -3 },{ 0, 0, 0 },{ -2, 2, 3 },{ 2, -2, -3 },{ 2, 3, -2 },{ 0, -1, 1 },{ -4, 0, -3 },{ -3, -3, -1 },{ 1, 1, 3 },{ -1, -2, -3 },{ -2, 0, 2 },{ 3, 3, -1 },{ -1, -3, -1 },{ -4, 3, 2 },{ 1, 2, -3 },{ 1, -1, -1 },{ 2, 2, 3 },{ 0, -2, -2 },{ -3, 3, 3 },{ 2, 0, -4 },{ -2, 2, 3 },{ -1, -2, 2 },{ 3, 2, -3 },{ 1, 3, -4 },{ -1, -2, 0 },{ -4, 1, 3 },{ 3, 3, -1 },{ -3, 2, -4 },{ -4, -2, 2 },{ 2, -4, -3 },{ -3, -3, -1 },{ -2, -2, 3 },{ 3, 1, 1 },{ 2, -4, -2 },{ 1, 3, 3 },{ -2, 3, 0 },{ 2, -1, -3 },{ -2, -2, 2 },{ 1, 3, 3 },{ 3, 0, 0 },{ -1, -2, 1 },{ -3, -3, 2 },{ -1, 0, 0 },{ -4, 2, 1 },{ 0, -2, -2 },{ -3, 0, 2 },{ 1, -2, -2 },{ 3, -3, 2 },{ -1, 1, 1 },{ -2, -1, -4 },{ 3, -4, 1 },{ 0, -1, -1 } },
+		{ { 3, 3, -4 },{ -1, 0, 0 },{ -3, 3, -3 },{ 3, 3, -2 },{ 2, -4, -1 },{ -1, -1, 1 },{ -3, -2, 0 },{ 2, -4, 3 },{ 3, 0, 0 },{ 2, 2, 0 },{ 1, -1, 2 },{ 2, -4, -2 },{ -1, -2, 1 },{ -3, 3, 3 },{ 3, -4, 1 },{ -2, 1, -1 },{ -1, 0, 0 },{ -2, -2, 0 },{ 2, -4, 3 },{ 0, 2, -4 },{ 3, 2, 0 },{ -4, -4, -4 },{ 2, -1, 1 },{ -3, 2, 3 },{ 1, 1, 0 },{ 3, -2, 2 },{ -3, -4, -2 },{ -4, 3, -3 },{ -1, -3, 1 },{ -1, -1, 1 },{ -3, 1, -1 },{ 1, -4, 0 },{ 0, 3, -4 },{ -4, -4, -2 },{ -2, -1, -1 },{ 0, -3, 2 },{ -2, 2, -2 },{ 1, 1, -3 },{ -2, -3, -3 },{ 1, 0, 3 },{ -1, 3, 1 },{ 3, 2, 0 },{ 1, 1, -3 },{ 0, 3, -4 },{ -1, -1, -2 },{ -3, -2, -1 },{ 0, 0, 2 },{ -4, -3, -3 },{ -1, -4, -1 },{ 3, -1, 1 },{ -3, 2, -4 },{ 0, -3, -1 },{ -2, -1, 1 },{ 3, 2, -2 },{ 1, 3, -3 },{ 2, -4, 3 },{ 3, -3, -1 },{ -1, 2, 3 },{ -4, 3, -1 },{ 0, -1, -3 },{ -3, 2, -2 },{ 1, -2, 0 },{ -4, 2, 3 },{ 1, -3, -1 } },
+		{ { -3, -1, -4 },{ 2, -4, 1 },{ 1, -1, 3 },{ -2, -2, 0 },{ 0, 0, -4 },{ -3, 2, -3 },{ 0, -3, -2 },{ -1, 1, 2 },{ -4, -2, -4 },{ -3, -3, -2 },{ -2, -1, 3 },{ -4, 2, 2 },{ 1, 1, -4 },{ 0, -2, -3 },{ -4, -1, -2 },{ 1, 2, 2 },{ -4, -3, -4 },{ 1, 3, 2 },{ 3, 1, -2 },{ -3, -3, 2 },{ -1, 0, -1 },{ -2, 3, 2 },{ 2, 1, -2 },{ 0, -4, -3 },{ -3, -3, -3 },{ 0, -1, 1 },{ -1, 0, 3 },{ 2, 0, -2 },{ 3, -4, -4 },{ -4, 3, 0 },{ 1, -3, -3 },{ 3, -2, -2 },{ -4, 2, 2 },{ 1, 1, 0 },{ 0, -3, -4 },{ 3, 0, 3 },{ -4, -2, 1 },{ 2, -4, 1 },{ -3, 0, 0 },{ 0, -2, -1 },{ 1, -3, -2 },{ -4, -1, 0 },{ -2, -4, 2 },{ 2, 0, 3 },{ -4, -3, 1 },{ 1, 2, 2 },{ -2, -3, -4 },{ 2, 0, -2 },{ 1, 2, 3 },{ -3, 1, -2 },{ -1, 0, -3 },{ 2, 3, 2 },{ -4, -4, 3 },{ 0, 1, -4 },{ -3, -2, 1 },{ -2, -1, -1 },{ -3, -1, -4 },{ 1, 3, -3 },{ -1, 0, 1 },{ 2, -3, 2 },{ -2, -4, -4 },{ 2, 1, 3 },{ -1, 0, 1 },{ -2, 2, -2 } },
+		{ { -4, 1, 2 },{ 0, 2, -1 },{ -1, -3, -2 },{ 2, 1, 1 },{ -4, 1, 3 },{ 3, -1, 2 },{ 1, 3, -1 },{ -2, 0, 3 },{ 1, 3, -3 },{ 3, 1, -1 },{ -1, -3, -4 },{ 3, 3, 0 },{ -2, 0, 1 },{ 0, -4, -1 },{ 3, -3, -4 },{ 2, 0, 3 },{ -2, -3, -2 },{ -1, -1, 0 },{ -4, 2, -3 },{ 1, -1, -3 },{ 2, -4, 1 },{ -3, -2, -2 },{ 0, -2, 3 },{ 3, 2, -4 },{ -2, 0, 1 },{ -4, 2, -4 },{ 2, 1, 0 },{ -2, -2, -1 },{ 0, 2, 2 },{ 0, -1, 3 },{ -2, 1, -1 },{ -1, -2, 1 },{ 3, 0, 3 },{ -2, -1, 1 },{ 2, 3, -1 },{ -3, 1, -2 },{ -1, 3, 0 },{ 3, -1, 2 },{ -1, 2, -1 },{ 2, 0, -4 },{ -1, -2, 2 },{ -2, 2, -2 },{ -3, 0, -4 },{ 0, -2, 0 },{ 2, 2, -3 },{ -3, -1, -1 },{ 3, 1, 0 },{ 0, 3, 2 },{ -2, -3, 0 },{ -4, -2, 2 },{ 1, -4, -4 },{ 2, 0, 0 },{ -2, -2, -2 },{ 2, 2, -3 },{ 0, 0, 0 },{ 1, 1, 2 },{ -4, -3, 0 },{ 3, 1, -4 },{ -2, -4, 0 },{ -4, 1, -1 },{ 3, -1, 0 },{ 0, 3, -1 },{ -3, -3, -3 },{ 3, -4, 2 } },
+		{ { 0, -2, 0 },{ -3, -3, 1 },{ -4, 0, -4 },{ 1, 3, 2 },{ -2, -4, -1 },{ -3, -3, -3 },{ 2, -3, 0 },{ 0, 0, -2 },{ -4, -4, 1 },{ -2, 2, 2 },{ 0, -4, 1 },{ 1, 0, -1 },{ -4, -2, -3 },{ -3, 2, 2 },{ -1, 3, -1 },{ -3, 0, 1 },{ 3, 3, -3 },{ -1, -2, 3 },{ 0, -4, 1 },{ -3, 0, -1 },{ -2, 1, -4 },{ 1, 3, 1 },{ -4, -3, 0 },{ -2, -1, -1 },{ 1, 3, 0 },{ -1, -3, 3 },{ 1, -4, -1 },{ -3, -3, -2 },{ -3, 2, -4 },{ -2, -1, 2 },{ 2, 2, -3 },{ -3, -4, -4 },{ -1, 0, -1 },{ -3, -3, -3 },{ -1, -4, 3 },{ -4, 1, -3 },{ 1, -4, -2 },{ -2, -1, -4 },{ -3, 2, -3 },{ -4, -4, 3 },{ 2, 3, -3 },{ 3, 1, 1 },{ 1, -3, -1 },{ -1, 3, 3 },{ 3, -4, -2 },{ -2, 1, -3 },{ -4, -4, 1 },{ -1, -2, -4 },{ -1, -1, -1 },{ 3, 1, 0 },{ 0, 3, 1 },{ -4, -3, -1 },{ 3, 1, 2 },{ -3, -3, -3 },{ -1, -4, 3 },{ 3, 2, -2 },{ 1, -2, 2 },{ 0, 0, -2 },{ -3, -2, 3 },{ 1, 2, 3 },{ -3, -3, -3 },{ -1, 0, 2 },{ 2, -2, -3 },{ 1, 1, -2 } },
+		{ { 3, -1, -4 },{ 1, 0, -3 },{ 3, 2, 3 },{ 2, -2, 0 },{ -1, -1, -4 },{ -3, 2, 1 },{ 3, -2, -4 },{ -1, 1, 3 },{ 2, -1, -3 },{ 2, -2, -1 },{ -3, 1, -3 },{ -1, -1, -2 },{ 3, -3, 3 },{ 2, 1, 0 },{ 1, -1, 3 },{ -2, -4, -4 },{ 1, 1, 1 },{ -4, 2, -2 },{ 3, -2, 0 },{ 2, 3, 2 },{ -1, -3, 3 },{ 3, 0, -2 },{ 0, 2, 2 },{ -1, -4, -1 },{ 3, -2, -3 },{ -4, 1, -2 },{ 3, -1, -3 },{ 0, 3, 3 },{ 1, 0, 1 },{ 3, -4, 0 },{ 2, -3, -2 },{ -4, 1, 3 },{ 1, 3, 0 },{ 1, 2, -4 },{ 3, -2, 2 },{ 2, 2, 0 },{ 0, -2, 2 },{ 3, -3, 3 },{ 1, 0, 1 },{ 0, 1, 0 },{ -2, -4, 2 },{ -4, -1, 1 },{ 1, -1, -2 },{ -4, 1, -4 },{ 0, -2, 0 },{ -1, 0, 2 },{ 1, 3, 3 },{ 2, 2, -3 },{ -3, -2, 3 },{ 2, 0, -2 },{ 0, -1, -4 },{ -2, 2, 3 },{ -1, -1, 1 },{ 1, 3, 0 },{ -4, 1, -1 },{ -3, -1, -4 },{ -2, 3, 1 },{ 2, -4, -3 },{ 0, -2, -1 },{ 3, 3, -2 },{ 1, -1, -4 },{ -4, 2, 1 },{ -1, -4, 3 },{ -2, 3, 0 } },
+		{ { -3, -4, -1 },{ -1, 3, 2 },{ -4, -1, -2 },{ -2, -4, -3 },{ 0, 1, -1 },{ 1, 2, 3 },{ -4, -2, 0 },{ -2, 3, -2 },{ -3, -3, 1 },{ 0, 2, 0 },{ 2, 1, 3 },{ -4, 3, -4 },{ -2, 0, 2 },{ 0, 2, -3 },{ -4, -2, -2 },{ 2, -4, 0 },{ 0, -1, -3 },{ 1, 0, 2 },{ -2, -3, -4 },{ 0, 2, -2 },{ -4, -4, -3 },{ 1, -1, -1 },{ -3, 1, -4 },{ -3, -2, 3 },{ 0, 3, 1 },{ -2, 0, 2 },{ 2, 2, 2 },{ -2, -3, 1 },{ -4, 1, -2 },{ -1, -2, -1 },{ 0, 3, 1 },{ -2, -1, 2 },{ 0, 1, -2 },{ 2, -3, -1 },{ -3, -1, 1 },{ -2, 0, -4 },{ -1, 3, 0 },{ -3, -3, -1 },{ -4, 3, -4 },{ 3, -2, -2 },{ -1, -3, -1 },{ 0, 0, -4 },{ -2, 2, 3 },{ 2, -4, 2 },{ -3, 1, 0 },{ 2, -3, 1 },{ -2, -3, -1 },{ -3, 0, -4 },{ 1, -4, 2 },{ -4, 2, 0 },{ -2, -3, -2 },{ -3, -4, -3 },{ 1, 0, -2 },{ 2, -1, -4 },{ 3, -4, 3 },{ -2, -3, -1 },{ -1, 1, 0 },{ -4, 2, 1 },{ -2, 0, 2 },{ -1, 1, -4 },{ 0, -4, 1 },{ -3, 0, 0 },{ 3, -1, -2 },{ -2, 1, 3 } },
+		{ { 2, -2, -4 },{ 0, -3, 1 },{ -3, 1, 1 },{ 2, -3, -1 },{ 3, 3, 2 },{ 2, 0, 0 },{ -3, -4, -2 },{ 1, 0, 2 },{ 3, -1, -4 },{ -1, -4, -1 },{ -2, -3, 3 },{ 1, -2, 1 },{ 1, -4, -1 },{ 2, -3, -4 },{ -3, 1, 1 },{ -2, 3, 3 },{ -1, -3, -1 },{ -4, -1, -1 },{ -3, 1, 2 },{ 3, -1, 0 },{ -2, 0, 0 },{ 2, 2, 2 },{ -1, -2, 1 },{ 3, 0, -4 },{ 2, -4, 0 },{ -4, 1, -4 },{ 0, -2, -1 },{ -1, -4, -3 },{ 1, -1, -4 },{ 2, 0, -3 },{ -4, 0, 3 },{ -3, -4, -4 },{ 1, -2, 1 },{ -4, 0, 2 },{ -2, -4, -2 },{ -4, 1, 3 },{ 2, -2, -2 },{ -1, -1, -3 },{ 1, 2, 1 },{ -3, 1, 2 },{ 2, -1, -1 },{ 3, -3, -3 },{ -3, 3, 1 },{ 0, 0, -3 },{ 1, 2, -2 },{ 3, -1, -4 },{ -4, 3, -2 },{ 0, 2, -2 },{ 3, 1, 1 },{ -1, -2, -1 },{ 2, 3, 3 },{ 3, 1, 2 },{ -4, 2, 0 },{ -2, -2, 2 },{ 0, 3, -3 },{ 1, -2, 2 },{ 2, 0, -3 },{ 3, -3, -4 },{ -3, -1, -1 },{ -2, -3, 0 },{ 2, -2, 3 },{ -4, 3, -3 },{ 2, -3, -1 },{ 0, 2, 1 } },
+		{ { -2, 2, -3 },{ 1, 0, 0 },{ -4, -2, -2 },{ 0, 2, 3 },{ -1, 0, -4 },{ -4, -3, -3 },{ -2, -2, -2 },{ 0, 2, 1 },{ 1, 1, -3 },{ -3, 3, 2 },{ -4, 0, -2 },{ 3, 3, -3 },{ -3, -1, 0 },{ -2, 2, -1 },{ 0, -1, 2 },{ 3, 2, 0 },{ 1, 2, -3 },{ 3, -4, -4 },{ -1, 3, 1 },{ 2, 1, 3 },{ -3, -4, -4 },{ 0, 3, 0 },{ 2, 1, -2 },{ -4, -3, 3 },{ 1, -1, -2 },{ -1, 2, 0 },{ -3, -1, -1 },{ 3, 3, 2 },{ 2, 2, 3 },{ -3, 3, 0 },{ -1, -3, -1 },{ 3, -3, -3 },{ -1, 2, 0 },{ 3, -2, -3 },{ 0, 3, 2 },{ 1, 2, 0 },{ 3, -4, -1 },{ 0, 0, 2 },{ -1, -2, 3 },{ -2, -4, -4 },{ -4, 2, 0 },{ 1, 1, 2 },{ -1, -4, -2 },{ -4, -2, -1 },{ -1, -2, 3 },{ -2, -4, 1 },{ 0, 1, 3 },{ -4, -1, 0 },{ 0, -4, 2 },{ -2, -1, -4 },{ 1, -3, -3 },{ 2, 0, 1 },{ -1, -3, -1 },{ 0, -4, 1 },{ -3, 2, -2 },{ -4, 1, 0 },{ -1, 3, 1 },{ 0, -2, 3 },{ 2, 2, -2 },{ 1, 1, 2 },{ 3, 3, 0 },{ 0, -4, -4 },{ -1, 0, -2 },{ -4, -1, 2 } },
+		{ { -1, 3, 0 },{ 2, -4, 3 },{ 3, 1, -4 },{ -3, -1, -2 },{ 1, -2, 1 },{ -1, 3, 2 },{ 2, 1, 0 },{ 3, -3, 3 },{ -4, -2, -1 },{ 2, -4, 0 },{ -1, -2, -2 },{ 0, -1, 1 },{ 3, 1, 3 },{ -1, -4, 2 },{ 1, -2, -4 },{ -3, 0, -2 },{ -4, -3, 3 },{ 2, -2, 0 },{ 0, 1, -3 },{ -2, -3, -2 },{ 1, -2, 3 },{ -4, -3, -3 },{ -1, -1, -1 },{ -3, 3, 2 },{ -2, -4, -3 },{ 3, 1, 3 },{ 0, -3, 1 },{ -4, 0, -4 },{ 0, -4, 2 },{ -2, -2, 0 },{ 3, 2, -2 },{ 0, 1, 1 },{ -2, 1, 3 },{ 2, 3, -1 },{ -1, -1, -4 },{ -3, -3, -4 },{ -2, -1, 1 },{ -3, 3, -3 },{ 1, -3, -2 },{ 3, 0, -2 },{ 0, 3, 3 },{ -2, -2, 1 },{ 2, 0, -4 },{ 3, 2, 0 },{ -3, 3, 2 },{ -2, 0, -3 },{ 2, -3, -4 },{ 3, -2, 0 },{ -1, 0, 3 },{ -3, 3, -3 },{ -4, 1, 1 },{ -3, -2, -1 },{ 0, 3, -4 },{ -3, -1, -4 },{ 2, 0, 3 },{ 3, -3, -2 },{ -3, -2, -4 },{ 1, 0, 3 },{ -3, -4, -3 },{ -1, -1, -3 },{ -4, -2, -1 },{ -2, 0, 1 },{ 1, 1, 3 },{ 3, -3, -2 } },
+		{ { -4, 1, -3 },{ -2, -1, -1 },{ 0, 3, 2 },{ -2, -4, -1 },{ 1, 1, 0 },{ -3, -4, -3 },{ 0, 0, -4 },{ -1, -1, -1 },{ 2, 0, -4 },{ -3, 2, 2 },{ 0, 1, -4 },{ 2, 3, 1 },{ -4, -3, -3 },{ -2, 0, 0 },{ 2, 3, -2 },{ -1, -1, -3 },{ 0, -4, 1 },{ -2, 0, 1 },{ -4, 2, -1 },{ 2, -1, -2 },{ -3, 0, 2 },{ 1, 2, -1 },{ 3, -2, 1 },{ -1, 1, -3 },{ 2, 0, 1 },{ 1, 3, -1 },{ -3, -3, -3 },{ 2, 0, -2 },{ -2, 2, -1 },{ -1, -3, 3 },{ -3, -1, -4 },{ 1, -1, 2 },{ -4, -4, -2 },{ -3, -3, 1 },{ 1, 0, 3 },{ -4, -4, -1 },{ 2, 1, 3 },{ 3, 2, 0 },{ 0, -2, 1 },{ -4, -4, -3 },{ 1, -1, -1 },{ 0, 2, -4 },{ -3, -3, 2 },{ 1, 1, -2 },{ 2, -4, 0 },{ 1, -1, 2 },{ -3, 2, -1 },{ 1, 3, -3 },{ 2, -3, -2 },{ 3, 2, -1 },{ 0, -1, 2 },{ 1, -4, -2 },{ 3, 2, 0 },{ 1, 1, 3 },{ -1, -4, 0 },{ 2, -1, -3 },{ -2, 2, 2 },{ 0, -4, 0 },{ -4, 1, 1 },{ 3, 3, -1 },{ -2, 2, 2 },{ 2, -3, 0 },{ 0, -1, -4 },{ -3, -4, 1 } },
+		{ { -1, -2, 1 },{ 1, 0, -3 },{ 2, -3, 2 },{ -4, 2, 0 },{ 3, -2, 1 },{ -2, -1, 3 },{ 3, 2, 2 },{ -3, 3, 1 },{ -2, -4, -2 },{ 1, -2, 0 },{ -1, 1, 3 },{ -2, -4, -1 },{ 1, -2, -4 },{ -4, 2, -1 },{ 0, -3, 2 },{ -3, 1, 3 },{ 1, 2, -1 },{ 3, 3, -4 },{ -2, 0, 2 },{ -1, -4, -4 },{ 3, 3, 1 },{ -2, 1, -4 },{ 0, -3, 3 },{ -4, -4, 0 },{ 0, -2, -4 },{ -4, 2, 2 },{ -2, -2, 3 },{ 0, -1, 0 },{ 1, 1, -3 },{ -4, -2, 1 },{ 1, 3, -4 },{ 2, 0, -1 },{ -2, -2, -3 },{ 0, 2, 1 },{ 3, 0, -2 },{ -1, 3, 0 },{ 0, -2, -3 },{ -3, 0, 1 },{ 2, 3, 3 },{ -3, 1, 2 },{ -2, 0, 0 },{ -4, -4, -1 },{ 3, -2, 3 },{ -2, 3, -3 },{ 0, -1, -1 },{ -4, -3, -3 },{ -1, -2, 1 },{ -2, 1, 3 },{ -4, -4, 2 },{ -3, 0, -4 },{ -1, -2, 1 },{ -2, 1, 3 },{ -4, -3, 2 },{ -2, 0, -3 },{ -2, -3, -1 },{ -4, 3, 2 },{ 0, 2, -2 },{ 3, 1, -1 },{ -2, -1, -4 },{ 0, -2, 3 },{ 1, -4, -4 },{ -3, 3, -2 },{ 3, 0, 2 },{ 2, 2, -1 } },
+		{ { 0, 1, -4 },{ 3, -3, 3 },{ -3, 2, -2 },{ -1, 0, -3 },{ 0, 3, -4 },{ 0, 0, -2 },{ -4, -3, -2 },{ 1, -3, -3 },{ -1, 2, 3 },{ -4, -1, 1 },{ 3, -3, -2 },{ 2, 0, -3 },{ -3, -1, 3 },{ 3, 3, 1 },{ -1, 0, -1 },{ 3, -4, -4 },{ -3, -1, 2 },{ 1, -2, 0 },{ 0, -2, -2 },{ -3, -3, 3 },{ 1, -1, 0 },{ -4, -4, 1 },{ 2, 3, -2 },{ -3, 2, -2 },{ 1, -1, 0 },{ 3, 0, 1 },{ -1, 3, -2 },{ -3, -4, -4 },{ 3, 1, 2 },{ 3, -4, -1 },{ -3, 2, 2 },{ -1, -4, 0 },{ 3, 3, 0 },{ -2, 1, -4 },{ 1, -1, -3 },{ 2, -3, 2 },{ -2, 2, -2 },{ -4, -4, -4 },{ -1, -1, -4 },{ -1, -3, -2 },{ 3, 2, -3 },{ 2, -1, 2 },{ -1, 2, 1 },{ -4, -3, -2 },{ -1, 0, 1 },{ 3, 3, 3 },{ 0, 0, -4 },{ 3, 2, -1 },{ 0, -4, 0 },{ 1, 3, -3 },{ 0, 1, -1 },{ 2, -2, -2 },{ 3, 3, -3 },{ 1, 2, -1 },{ 0, -1, -4 },{ 2, -2, 1 },{ -3, 0, 0 },{ 2, -3, 3 },{ -1, -3, -2 },{ 2, 0, 1 },{ -4, -2, -1 },{ -1, 2, -3 },{ -2, -2, 3 },{ -4, -1, -2 } },
+		{ { -2, -4, 2 },{ -3, 3, 0 },{ 1, -1, 1 },{ 3, -1, 3 },{ -3, -3, -1 },{ 2, -4, 1 },{ -1, 1, 2 },{ 2, 1, -1 },{ 3, -2, -1 },{ -3, 3, -4 },{ 0, 1, 2 },{ -4, 2, -2 },{ -2, -2, 0 },{ 0, -4, 1 },{ 2, 0, -3 },{ -2, 3, 0 },{ -1, -3, -2 },{ 2, -1, 1 },{ -4, 3, -1 },{ 3, 1, -3 },{ -1, 2, 0 },{ -2, -1, -3 },{ 2, 0, 2 },{ -1, -3, 3 },{ -2, 0, -4 },{ 3, -4, 2 },{ -2, -3, -3 },{ 1, 3, 0 },{ 0, 0, 3 },{ -2, -2, 1 },{ 0, 0, -3 },{ -1, -1, -2 },{ -4, -3, 3 },{ 2, -4, 2 },{ -3, -1, 0 },{ -3, -2, 3 },{ 0, 1, -1 },{ 3, 0, 2 },{ 2, -4, -1 },{ 1, 3, 3 },{ -2, -3, 0 },{ 0, 0, -4 },{ -3, 3, 0 },{ 2, -1, -4 },{ 1, 1, -2 },{ -3, -4, 0 },{ 2, -3, -2 },{ -4, -1, -2 },{ -2, 2, 2 },{ 3, -1, 3 },{ -1, -3, 0 },{ -3, 0, -4 },{ -4, -4, 1 },{ -3, -1, 2 },{ 3, -4, 3 },{ -1, 1, -2 },{ -3, -2, -4 },{ 1, 3, -3 },{ -3, 0, 2 },{ 0, 3, 0 },{ 2, 1, 3 },{ -2, -4, 1 },{ 1, -3, -1 },{ 1, 3, 1 } },
+		{ { 0, -3, -3 },{ -4, 1, -2 },{ -1, -2, -4 },{ -2, -4, -1 },{ -4, 3, 2 },{ 1, 2, -4 },{ -2, -2, 0 },{ -4, -1, 3 },{ 0, -4, -3 },{ -1, 0, 0 },{ 1, -4, 3 },{ 0, -1, -1 },{ 2, 2, -4 },{ -4, -2, 2 },{ -3, 1, -2 },{ 0, -2, 2 },{ -4, 2, 3 },{ -2, 1, -3 },{ 2, -4, -4 },{ 0, 0, 1 },{ -1, -4, 3 },{ 3, 1, -1 },{ 1, -2, -4 },{ 0, 1, -1 },{ -4, 3, -1 },{ 1, 2, 3 },{ -4, -1, -2 },{ 2, 1, -1 },{ -1, -2, -3 },{ -4, 2, -1 },{ -3, -3, -3 },{ 2, 0, 3 },{ 3, 2, -1 },{ -1, 1, -1 },{ -4, 2, -4 },{ 3, 3, 1 },{ 1, -3, -3 },{ -2, 1, 0 },{ -4, 2, 1 },{ 0, -2, -1 },{ -4, -1, -3 },{ 3, 1, 2 },{ -2, -4, -1 },{ 0, -2, 3 },{ 2, 1, 2 },{ -2, -2, 2 },{ -3, 3, 1 },{ 0, 0, -3 },{ 2, -2, -4 },{ -3, -2, 1 },{ -4, 2, -3 },{ 0, 1, 1 },{ -1, -1, 3 },{ 1, 3, -3 },{ -1, 3, -2 },{ -4, 0, 1 },{ 2, -4, 0 },{ -2, 2, 2 },{ -4, -4, -3 },{ 3, -2, -2 },{ -2, 0, -3 },{ 0, 3, -4 },{ -4, -1, 0 },{ 3, 0, -3 } },
+		{ { -1, -2, -1 },{ 2, 2, 3 },{ 2, 0, 0 },{ 0, 1, -3 },{ 1, -2, 1 },{ -2, 0, -2 },{ 3, 3, -3 },{ -3, 0, 1 },{ -2, 3, -2 },{ 2, -3, -4 },{ -2, -2, 2 },{ -3, 3, 0 },{ 2, -3, -3 },{ -1, 0, 3 },{ 1, -4, -4 },{ 3, 2, -1 },{ 0, -3, -2 },{ 3, 0, 1 },{ -3, 3, 2 },{ -2, -2, -1 },{ -3, 2, -2 },{ -4, -3, 1 },{ -3, 2, 2 },{ 2, -2, -3 },{ -2, -4, 1 },{ 0, -2, 1 },{ -3, 0, -4 },{ -1, -3, 3 },{ 3, -1, 0 },{ 2, -4, 1 },{ -3, 3, -4 },{ 1, 3, 1 },{ -2, -3, -4 },{ 0, -2, 1 },{ 1, -4, -3 },{ -1, 0, -2 },{ -1, -1, 2 },{ -3, -2, -4 },{ 2, 2, 3 },{ 0, 0, -2 },{ -2, 3, 1 },{ 1, -3, 3 },{ -3, -2, -2 },{ 0, 2, 0 },{ -4, 0, -4 },{ 3, 2, -3 },{ -1, -4, 2 },{ 1, 1, 3 },{ -1, 0, -1 },{ 1, -4, -1 },{ 2, 3, 3 },{ 3, -3, -2 },{ 2, -4, -1 },{ -2, -1, -1 },{ 1, -3, 0 },{ 0, 2, 3 },{ 3, -3, -4 },{ -1, -1, -1 },{ 1, 2, 1 },{ 0, -1, 3 },{ -3, 2, -4 },{ 3, -3, -1 },{ 2, 1, 2 },{ -3, 2, 2 } },
+		{ { -2, 0, -4 },{ -3, -3, 3 },{ 3, -4, 0 },{ -4, -1, -2 },{ -1, 1, 1 },{ 3, -3, 3 },{ 0, -4, 0 },{ 2, -2, -1 },{ 1, 1, 3 },{ 3, 2, 1 },{ -4, 0, -3 },{ 1, 1, -2 },{ 3, 1, -1 },{ -2, 3, 1 },{ -3, 0, 0 },{ 2, -2, 1 },{ -4, -1, -4 },{ 1, -4, 0 },{ -1, -1, 3 },{ 2, -2, -3 },{ 1, 3, -4 },{ 3, -1, -2 },{ -1, -3, 3 },{ -3, 3, 0 },{ 3, 1, -3 },{ 1, -1, 0 },{ 2, 1, -2 },{ -3, 3, -1 },{ 0, 2, 2 },{ 1, -3, -2 },{ 0, 1, 2 },{ 3, -2, 0 },{ -3, 0, -2 },{ -4, -1, 2 },{ -2, 3, 3 },{ 2, 1, 0 },{ 1, -4, -2 },{ -1, 3, -4 },{ -3, -3, 2 },{ 3, -4, -1 },{ -3, -1, -4 },{ 2, 1, 0 },{ -1, -4, -3 },{ 3, 3, 1 },{ -2, -3, -1 },{ -3, -1, -1 },{ 2, -3, -2 },{ -4, -1, 1 },{ 3, 2, 0 },{ -2, -3, -4 },{ -3, 1, 2 },{ -1, -2, -4 },{ 0, 0, 0 },{ -4, 1, -4 },{ -3, -2, 2 },{ -3, 0, -3 },{ 2, 3, 1 },{ -2, -1, -1 },{ -4, -3, 0 },{ 1, 1, -2 },{ -3, -3, 1 },{ 1, 0, 0 },{ -1, -2, 3 },{ 0, -4, -2 } },
+		{ { 1, 2, 1 },{ -2, -1, 1 },{ 1, 3, -4 },{ -2, 0, 2 },{ -3, 3, -3 },{ 0, 2, -2 },{ -4, -3, 2 },{ -3, 2, -4 },{ -1, -1, -3 },{ -4, -4, 0 },{ -2, -3, 3 },{ -1, -1, 2 },{ 0, -3, -4 },{ -4, -4, 3 },{ 1, -1, -3 },{ -1, 2, -2 },{ -2, 3, 3 },{ -3, 1, -1 },{ 0, 2, -3 },{ -4, -3, 2 },{ 1, 1, 1 },{ 0, -4, 2 },{ 2, 0, 0 },{ -2, 0, -2 },{ 1, 2, -4 },{ -4, -4, 3 },{ 3, -2, 2 },{ -1, 0, -3 },{ -2, -4, -4 },{ -4, -1, -2 },{ -1, 1, 3 },{ -2, -4, 0 },{ 1, 2, -3 },{ 3, -1, 2 },{ 2, -3, -3 },{ -2, 2, -1 },{ -4, -2, 3 },{ 3, 1, 1 },{ 1, 0, -1 },{ 1, -3, -3 },{ -1, 3, 1 },{ 3, 0, -2 },{ -4, 2, 2 },{ 1, -1, 3 },{ -1, 0, -3 },{ 1, 2, 0 },{ 0, 3, -4 },{ -2, -3, -3 },{ -3, 2, -1 },{ 0, -1, -3 },{ -4, -4, 1 },{ 1, 0, 0 },{ -2, 2, 3 },{ 3, 2, 2 },{ 2, -4, -3 },{ 1, -2, -2 },{ -1, 1, 3 },{ -1, -4, -4 },{ 3, 0, 2 },{ 2, 3, -3 },{ -2, -4, 3 },{ -4, -1, -1 },{ 3, 3, -3 },{ -4, 1, -2 } },
+		{ { 1, -2, -1 },{ 3, -3, -3 },{ -1, 2, -1 },{ 0, -4, 2 },{ 3, -2, -1 },{ 1, -1, -4 },{ -2, -1, 0 },{ 1, 1, 1 },{ 3, -2, -1 },{ 0, 1, 2 },{ 1, 3, -2 },{ 3, -2, -4 },{ 0, 3, 0 },{ -3, -1, -1 },{ 3, 1, 2 },{ 0, -3, -1 },{ 1, -2, -4 },{ 3, -3, 1 },{ 2, 1, -2 },{ -1, 0, 0 },{ -2, -1, -1 },{ -2, 3, -4 },{ -4, -2, -3 },{ 0, -3, 2 },{ -1, -3, 1 },{ -2, 3, -1 },{ -4, 1, 1 },{ 2, -3, 2 },{ -2, 0, 0 },{ 2, 3, 2 },{ -3, 0, -1 },{ 2, -2, -4 },{ -4, 3, 3 },{ -1, -4, -1 },{ 0, 1, -4 },{ -3, -3, 0 },{ 0, -1, 1 },{ -4, 2, -3 },{ -2, -1, 2 },{ 0, 2, 0 },{ -4, -2, 3 },{ -2, 0, 0 },{ -1, -3, -4 },{ -3, -2, -2 },{ 3, 1, 1 },{ 0, -4, 2 },{ -3, -2, 3 },{ 3, 0, 2 },{ -1, 0, 3 },{ 2, 3, 1 },{ 3, 1, -2 },{ -3, -2, -2 },{ -2, 3, -3 },{ -1, -3, -1 },{ -4, -1, 1 },{ 0, -4, -1 },{ -4, 2, 0 },{ 1, 1, -3 },{ -3, -2, 2 },{ -1, -2, -4 },{ 2, 3, -1 },{ 0, 1, 2 },{ -1, -1, -4 },{ 2, -4, 0 } },
+		{ { -4, 0, 3 },{ -3, 3, -3 },{ -1, 1, 3 },{ -4, -2, -2 },{ 2, 1, -1 },{ -4, -4, 3 },{ -1, 3, 2 },{ -2, 2, -2 },{ 2, 0, -3 },{ -3, -3, 0 },{ -1, 0, 1 },{ 2, 2, -1 },{ -3, -2, 1 },{ 2, 0, -2 },{ -2, -4, -3 },{ 2, 3, 2 },{ -4, 0, 0 },{ -1, 0, 2 },{ -2, -4, -3 },{ -3, 3, 2 },{ 2, -2, -1 },{ 3, 1, 3 },{ -3, 2, 1 },{ 2, 2, -1 },{ 3, -2, -3 },{ -1, -1, -2 },{ 0, 3, -4 },{ 3, -2, -3 },{ 0, 2, -1 },{ -4, -3, -3 },{ 3, -1, 1 },{ 1, -3, -1 },{ -2, 1, 1 },{ -1, 2, 0 },{ 2, -1, -2 },{ -3, 0, 3 },{ 1, 3, -2 },{ 2, -4, -4 },{ 2, 1, -1 },{ -3, -3, -2 },{ 0, -4, -3 },{ 2, 2, -1 },{ 2, -1, 2 },{ 0, -3, -1 },{ -4, 3, -1 },{ 2, -1, 1 },{ -1, 1, -2 },{ 2, -2, -4 },{ -4, -3, 0 },{ 1, -2, -4 },{ -1, -4, -1 },{ 2, -1, 2 },{ 0, -3, 0 },{ 1, 0, -4 },{ 2, 1, 1 },{ 3, 3, 3 },{ -2, -3, -2 },{ 2, 2, 2 },{ 0, -1, 0 },{ -4, -4, -2 },{ 3, 0, 0 },{ -3, -2, -3 },{ -2, -3, 3 },{ -3, 3, 1 } },
+		{ { 2, -1, -2 },{ 3, -4, 0 },{ 1, -1, 2 },{ -2, -1, 1 },{ 2, 2, 0 },{ -1, 0, -4 },{ 1, -3, -3 },{ 3, -4, 2 },{ -4, -2, -1 },{ 0, 3, -4 },{ -4, -4, 3 },{ -2, 1, -3 },{ 1, -4, 3 },{ -3, 2, -3 },{ -1, -3, 0 },{ -4, 1, 3 },{ -3, 2, -4 },{ 0, -2, -1 },{ 2, -2, 3 },{ -4, 2, -2 },{ 1, -3, -4 },{ 0, -4, 0 },{ 0, -4, -3 },{ -4, 0, 1 },{ 2, 1, 3 },{ -3, -4, 0 },{ 1, 0, 0 },{ -3, -2, 3 },{ -1, -4, -2 },{ 1, 2, 0 },{ -3, -2, 3 },{ 0, 1, -3 },{ 3, -4, -4 },{ -4, 0, 2 },{ 1, -2, -3 },{ 3, -4, 2 },{ -2, 0, 1 },{ -1, -2, -1 },{ -2, 2, 3 },{ 1, 3, 1 },{ 3, -1, -4 },{ -2, 1, 3 },{ -3, 3, 0 },{ 1, -4, -3 },{ -2, 2, -4 },{ -4, -1, -1 },{ 1, -4, -3 },{ -3, 3, 0 },{ 0, 2, -2 },{ -2, 0, 2 },{ -4, 1, 3 },{ 1, 3, -3 },{ 3, -4, 1 },{ -3, 2, 3 },{ -3, -1, -4 },{ -1, -2, -1 },{ -3, 0, -4 },{ 3, -3, -3 },{ -2, 0, 1 },{ -1, 2, 1 },{ 1, 1, 3 },{ -2, -1, -2 },{ 3, 2, 2 },{ 0, 0, -1 } },
+		{ { -1, 1, -4 },{ 0, -3, -2 },{ -4, 2, -4 },{ 0, -4, -3 },{ -3, 3, -2 },{ 3, -3, 1 },{ -3, 1, 0 },{ 0, -2, -1 },{ -1, 2, 3 },{ 2, -1, 1 },{ 3, -1, -2 },{ -1, -3, 0 },{ 2, 0, -4 },{ 0, 3, 2 },{ 3, -1, 1 },{ 1, -2, -1 },{ 1, -1, -2 },{ 3, -4, -3 },{ -1, 0, 1 },{ 0, 3, -4 },{ -3, 1, 3 },{ -1, -1, 2 },{ 3, 3, -2 },{ -2, -1, -4 },{ -3, 0, 3 },{ 1, -3, -1 },{ -2, 3, 2 },{ -4, 2, -4 },{ 3, 0, 2 },{ 0, 1, 1 },{ -2, 3, -4 },{ -1, -1, -2 },{ 1, 3, 2 },{ -4, -2, 0 },{ 0, 2, -1 },{ -2, 3, 0 },{ -4, 1, -4 },{ 3, -3, 2 },{ -4, -1, 0 },{ 0, -4, -3 },{ -1, 0, 2 },{ -4, -2, -2 },{ 3, -2, 1 },{ -1, 0, 3 },{ 3, 1, 2 },{ -2, 3, 3 },{ 1, -1, 2 },{ -2, 2, -3 },{ 3, -4, -1 },{ 2, -1, 1 },{ -2, -2, -4 },{ -1, 2, -2 },{ -4, 0, -1 },{ -2, -2, -2 },{ 1, 3, 0 },{ -1, 1, 1 },{ -4, -4, 3 },{ 0, -1, -1 },{ 1, 3, 3 },{ -4, -4, -4 },{ 0, -3, -2 },{ 2, 3, -1 },{ 1, -4, -4 },{ -4, -2, 1 } },
+		{ { -2, 0, 2 },{ -2, 3, -1 },{ 2, -2, 3 },{ 3, 1, 1 },{ -1, 0, 3 },{ -4, -1, -4 },{ -2, 3, 3 },{ 2, 2, -3 },{ -3, 0, -4 },{ -2, -4, 2 },{ 1, 1, -3 },{ -4, 3, -1 },{ -1, -2, 2 },{ -4, 1, -1 },{ -2, -4, -4 },{ 0, 1, -2 },{ -3, 0, 1 },{ -2, 3, 2 },{ -4, -3, 0 },{ 1, -1, -1 },{ 3, 0, 1 },{ -2, -2, -3 },{ -4, -2, -1 },{ 0, 3, 2 },{ 1, -3, -3 },{ -1, 2, 1 },{ 3, -2, -2 },{ -2, -1, -1 },{ 1, -4, 1 },{ 2, -1, -3 },{ -3, -3, 0 },{ 2, 0, 3 },{ -2, -4, -1 },{ -3, 1, -4 },{ 2, -1, 3 },{ 1, -3, -2 },{ -1, -3, -3 },{ 0, 1, -2 },{ 1, 0, 2 },{ -2, 2, -1 },{ -4, -3, 0 },{ 0, 3, -3 },{ 1, 1, -2 },{ -3, -4, 0 },{ 2, -3, -4 },{ 0, -3, -2 },{ -1, -2, 0 },{ 3, 0, 1 },{ -3, -3, 3 },{ 0, -1, -3 },{ 3, 2, 2 },{ -3, -4, 0 },{ 2, 0, 3 },{ 0, -3, 2 },{ 3, 2, -3 },{ 1, -4, 2 },{ 0, 1, -1 },{ 3, 3, -4 },{ -2, -1, 0 },{ 2, -2, -3 },{ -4, 1, 2 },{ -1, -1, 0 },{ -3, -2, -3 },{ 1, 2, 1 } },
+		{ { -3, -4, -3 },{ 1, -1, 2 },{ 0, 1, -2 },{ -3, -4, -1 },{ 1, -2, 2 },{ -2, -1, -1 },{ 1, -4, 0 },{ -4, -3, -2 },{ 1, -2, 1 },{ 3, 3, 0 },{ -3, -3, 1 },{ 1, 2, 3 },{ -2, -3, 0 },{ 3, -1, -3 },{ 2, 2, 3 },{ 2, -3, 3 },{ -1, -3, -3 },{ 0, 2, -4 },{ 3, 1, 3 },{ -1, -4, -2 },{ -3, 1, 0 },{ 2, 2, -2 },{ 1, -3, 2 },{ 3, 1, 0 },{ -4, -1, -4 },{ 2, -1, -1 },{ -3, 3, -3 },{ 0, 1, 3 },{ -4, -3, -4 },{ -1, -2, 3 },{ 0, 2, -1 },{ 3, 2, 0 },{ 1, -3, 1 },{ -1, -2, -3 },{ 3, 0, 1 },{ 0, 2, 1 },{ -3, -1, 3 },{ 3, 3, 0 },{ -3, -2, -3 },{ 2, 3, -4 },{ 3, -3, 3 },{ 1, 1, 1 },{ -2, -1, 2 },{ -3, 0, -3 },{ -1, 2, -1 },{ -4, 3, 1 },{ 1, 1, -2 },{ -4, -4, -4 },{ -1, 3, 2 },{ -4, 1, -2 },{ 1, -3, 0 },{ -1, 3, -4 },{ 2, -2, 1 },{ -3, 1, -4 },{ -2, -1, 0 },{ 2, -3, -2 },{ -4, 2, 1 },{ -3, -2, 2 },{ -1, 0, -2 },{ 2, 2, -2 },{ -3, -4, 1 },{ -1, 0, 3 },{ 3, 3, -1 },{ 3, -3, 3 } },
+		{ { 2, -1, -2 },{ -2, -3, 0 },{ -4, 0, -4 },{ -1, 3, 0 },{ 2, 2, -3 },{ 0, 1, -3 },{ 0, 1, 1 },{ 2, 0, 2 },{ -1, 2, -4 },{ -4, 0, -1 },{ 0, -2, -2 },{ 2, 0, -4 },{ -1, -4, 1 },{ 0, 2, -2 },{ -4, 0, 0 },{ -3, 3, -1 },{ -4, -2, 1 },{ 2, -1, -1 },{ 1, 2, 2 },{ -2, -2, -4 },{ -4, -4, -3 },{ 0, 0, 3 },{ -1, 3, -4 },{ -3, -4, -2 },{ -1, 1, 3 },{ -2, -4, 1 },{ 0, -3, 2 },{ 1, 0, 0 },{ 3, 2, -2 },{ -3, 3, -2 },{ -2, -4, 2 },{ -4, -1, -4 },{ 2, 3, -2 },{ -4, 1, -2 },{ -2, -2, 2 },{ -2, 3, -3 },{ -4, -4, -1 },{ 0, 1, 2 },{ 2, -2, 1 },{ -1, 0, -2 },{ -3, -4, 0 },{ 1, -1, -4 },{ 3, 2, -1 },{ 0, -4, -4 },{ 2, 1, 3 },{ 3, -1, 2 },{ -3, -2, 0 },{ 2, 0, -4 },{ -2, 2, -1 },{ 1, -2, 1 },{ 0, 0, -3 },{ -4, -4, 3 },{ 1, 1, -1 },{ -1, -2, -2 },{ -4, 3, 3 },{ 1, 0, -3 },{ -2, -2, -3 },{ 0, 0, 1 },{ 1, -3, 0 },{ -2, 3, 3 },{ 3, 0, 0 },{ 0, 2, -4 },{ -4, -3, -2 },{ 0, 1, 0 } },
+		{ { -3, 1, -4 },{ 1, 2, 3 },{ 3, -2, -1 },{ 2, -4, 2 },{ -4, -3, -4 },{ 3, -2, 3 },{ -2, 3, 1 },{ -1, -3, -3 },{ -3, -1, 3 },{ -2, -4, -1 },{ 3, 3, 2 },{ -1, 1, -3 },{ -3, -1, -1 },{ 3, -2, 2 },{ 1, -2, -3 },{ -2, 1, 1 },{ -1, -4, -4 },{ 3, -1, 0 },{ -4, -3, 0 },{ 0, 3, 2 },{ 2, -1, 1 },{ 2, -3, -1 },{ -3, -1, 0 },{ 0, 2, 1 },{ 3, -2, -1 },{ 2, 0, -2 },{ -2, 3, 0 },{ -4, -4, -3 },{ 2, 1, 1 },{ -1, 0, 2 },{ 1, -2, -3 },{ 0, 1, 1 },{ -3, 0, 3 },{ -1, -3, 0 },{ 0, -4, 3 },{ 2, 0, -4 },{ 3, -1, -1 },{ -2, -4, -4 },{ 0, 2, -1 },{ -4, -2, 3 },{ -1, 1, -1 },{ -3, 3, 3 },{ -4, -2, 0 },{ 0, -2, 1 },{ -2, -3, -3 },{ -2, 0, -1 },{ 0, -4, -3 },{ 1, 1, 1 },{ -2, -3, 3 },{ 3, -1, -1 },{ 2, 2, -3 },{ -2, -1, 2 },{ -2, -3, -2 },{ 3, 2, 0 },{ -3, -1, 2 },{ 0, -4, -4 },{ 3, 3, -1 },{ 2, 1, 3 },{ -4, -4, -4 },{ 0, -1, -3 },{ -3, -3, -1 },{ 1, -2, -3 },{ -2, -1, 1 },{ -1, 3, -1 } },
+		{ { -4, -2, 2 },{ 0, 0, -3 },{ -2, 3, 1 },{ 0, -1, 2 },{ -3, 2, -2 },{ -2, 0, -1 },{ -3, -4, 0 },{ 3, 3, -2 },{ 0, -1, -4 },{ 2, 1, 0 },{ 1, -4, 1 },{ -4, -2, -3 },{ -2, 3, 3 },{ -2, 1, -2 },{ 0, -3, -4 },{ 2, 0, 3 },{ 3, 3, -2 },{ -2, 2, 3 },{ -3, 0, -2 },{ -2, 0, -3 },{ 3, 1, 2 },{ -1, 3, -3 },{ -2, 0, 2 },{ 1, -3, 3 },{ -1, -1, -3 },{ -4, 2, 1 },{ 3, 1, -4 },{ 0, -1, 3 },{ -3, -1, -4 },{ -1, -4, -1 },{ 1, -2, 0 },{ 3, 2, -3 },{ -2, -4, -1 },{ 3, 3, -4 },{ 1, 2, -2 },{ -4, -2, 0 },{ -1, 2, 3 },{ 1, -3, 2 },{ -3, 3, -3 },{ 3, -3, -3 },{ 2, 0, 1 },{ 0, -4, -3 },{ -1, 0, 2 },{ 2, 3, -2 },{ 1, 2, 3 },{ -4, 3, 0 },{ 3, -2, 2 },{ -1, 3, 1 },{ 0, 2, -2 },{ -4, -2, 0 },{ -3, -4, -4 },{ 1, 3, 3 },{ 0, 0, 1 },{ 3, 1, -4 },{ 2, -4, 1 },{ -1, -3, 0 },{ -3, 2, 2 },{ -1, -2, 0 },{ -4, 3, -2 },{ 3, -1, 2 },{ -2, 1, 2 },{ 1, 2, -2 },{ -1, -4, 2 },{ 2, -4, 3 } },
+		{ { 3, 0, 0 },{ -1, -3, -1 },{ -4, -4, -3 },{ 3, 2, 1 },{ -1, -1, 0 },{ 0, 1, -4 },{ 1, -2, 3 },{ 2, 2, -2 },{ -4, -3, 2 },{ -2, 2, 0 },{ -3, 0, -2 },{ 3, -3, 2 },{ 2, -1, 0 },{ 1, 2, 1 },{ -3, -4, -1 },{ -4, -2, 1 },{ -1, 1, -3 },{ 1, -4, 2 },{ 0, -2, -2 },{ -1, -4, -1 },{ 1, -2, -4 },{ -4, 2, 0 },{ -4, -4, -2 },{ 3, 1, -4 },{ -3, 3, -3 },{ -3, -4, 2 },{ -1, -2, -1 },{ 1, -3, 3 },{ 2, 2, 0 },{ -2, 3, 2 },{ -4, 1, -2 },{ 2, -3, 2 },{ -1, -1, 1 },{ -4, 0, 2 },{ -1, -3, 1 },{ 3, -1, -3 },{ -3, 1, 1 },{ 2, 0, -2 },{ 1, -1, 2 },{ -2, 2, 0 },{ 1, 1, -4 },{ -2, -3, -2 },{ -3, 1, -1 },{ 3, -4, -4 },{ -3, -1, 1 },{ -1, 1, -2 },{ 2, -4, -4 },{ -4, -1, -1 },{ -1, -3, -4 },{ -3, 0, 3 },{ 2, 3, 2 },{ 0, 1, -1 },{ -4, -3, -3 },{ -3, 2, 1 },{ -1, -2, 3 },{ -2, 0, -2 },{ 1, -1, -2 },{ 2, 1, -1 },{ 0, -3, 3 },{ -1, 1, -4 },{ 2, -3, 1 },{ -3, 3, 0 },{ -4, -1, -2 },{ 3, 2, -4 } },
+		{ { -2, 3, 2 },{ -2, -2, 0 },{ 1, 1, -4 },{ -3, -2, -2 },{ 1, -3, 3 },{ 2, -1, -3 },{ -4, -4, 1 },{ -1, 0, 1 },{ 0, 1, -3 },{ 1, -2, 3 },{ -1, -1, -3 },{ -4, 3, -4 },{ 0, -4, 3 },{ -1, 0, -3 },{ 3, 2, -4 },{ -3, 3, 2 },{ 1, -1, 0 },{ -4, 1, -4 },{ 2, 2, 0 },{ -3, 3, 3 },{ 3, -1, 1 },{ -2, -4, -3 },{ 2, -2, 3 },{ 1, 0, 0 },{ 0, -2, -1 },{ 2, 3, 2 },{ 0, 1, -2 },{ -2, -2, -3 },{ 3, -1, -2 },{ -4, 0, -4 },{ -2, 3, -1 },{ 1, -2, 3 },{ -3, 1, -4 },{ 0, 3, -2 },{ 1, 1, -1 },{ -2, -3, 3 },{ -3, 3, -2 },{ 0, -2, -1 },{ -4, -4, 0 },{ -2, -1, 1 },{ 2, 3, 3 },{ -4, -2, 2 },{ 0, -1, 0 },{ 2, 0, 3 },{ -1, -3, -1 },{ -2, -1, -3 },{ 3, 0, 3 },{ -3, 2, 2 },{ 1, 1, -2 },{ 3, 0, 1 },{ -1, -4, -3 },{ -1, -1, 0 },{ 2, -2, -2 },{ 1, -3, -1 },{ -4, 3, -3 },{ 3, 1, 2 },{ -4, 3, -4 },{ -3, -4, -3 },{ 1, 2, 1 },{ -2, 0, -3 },{ 3, -2, 0 },{ -1, -2, -1 },{ 1, 0, -3 },{ 0, 1, 1 } },
+		{ { -3, -1, -3 },{ 1, -1, -1 },{ 2, 2, 3 },{ -1, 0, 0 },{ -3, 3, 2 },{ 3, 2, -3 },{ -2, 2, -1 },{ -3, -3, -4 },{ 3, 3, 2 },{ -2, -2, -1 },{ 3, 2, 0 },{ 0, -3, -1 },{ 1, 1, -2 },{ -4, -2, 2 },{ 2, -3, -1 },{ 0, -1, -2 },{ 3, -4, 1 },{ -1, -2, -1 },{ 0, 0, 2 },{ 2, -3, -2 },{ -1, 1, 1 },{ 0, 1, 0 },{ -3, 3, -1 },{ -1, 0, 1 },{ 3, -3, -2 },{ -4, -4, 3 },{ 2, 0, 0 },{ -3, 3, 1 },{ 1, -4, -1 },{ 0, -3, 1 },{ 3, -4, 1 },{ 2, -1, -3 },{ 0, 0, -1 },{ -3, -4, 3 },{ 2, -2, 0 },{ 0, -4, -4 },{ -1, 2, -4 },{ 3, -4, 1 },{ -1, 0, -3 },{ 0, -2, -4 },{ -3, 2, -1 },{ 3, -4, -3 },{ 1, 3, -2 },{ -4, 2, 2 },{ 1, -2, -3 },{ 0, 3, 1 },{ 0, -4, 0 },{ 2, 1, -3 },{ -2, -2, -1 },{ 1, -3, -4 },{ -4, 3, 1 },{ -2, 1, 0 },{ 3, 2, 3 },{ 0, 0, -4 },{ 0, -1, -1 },{ 2, -4, 1 },{ -2, -2, 3 },{ 2, 0, 0 },{ 0, -4, -1 },{ -4, -2, 3 },{ -4, 3, 2 },{ 2, 1, -4 },{ -2, -4, 3 },{ 2, -3, 1 } },
+		{ { -1, -4, -4 },{ 0, 3, -2 },{ 3, -4, 2 },{ -4, -3, -4 },{ 0, 0, -1 },{ 2, -2, 0 },{ -1, -1, 3 },{ 0, 1, 0 },{ 2, -4, -1 },{ -3, -1, -4 },{ -4, 1, 3 },{ 1, 3, 1 },{ -3, 0, 0 },{ -2, -2, 3 },{ -1, 1, -2 },{ -3, -3, 0 },{ -2, 3, 3 },{ -3, 2, -4 },{ 3, -3, -3 },{ -3, -1, 3 },{ -4, 3, -4 },{ -2, -1, -4 },{ 1, -3, 2 },{ 0, 2, -3 },{ -4, 1, -4 },{ -2, -1, 1 },{ -1, 1, -4 },{ -3, 2, -3 },{ -1, -1, 2 },{ 0, 0, 3 },{ -3, 2, -2 },{ -1, 2, 0 },{ 3, -2, 1 },{ -4, 3, -2 },{ 3, 2, -3 },{ -2, -1, 2 },{ 1, 0, 3 },{ -4, 2, 0 },{ 2, 3, 3 },{ 1, -1, -2 },{ 3, -3, 2 },{ -1, 1, 1 },{ -1, -4, 0 },{ -2, 0, -4 },{ 3, -3, -1 },{ -4, 1, 3 },{ -3, 2, -2 },{ -1, -1, 0 },{ 3, -4, 2 },{ -3, 2, 3 },{ 0, -3, -3 },{ 2, -1, -4 },{ -3, -4, 2 },{ -2, 2, 0 },{ -3, -2, 2 },{ 1, 1, -2 },{ 0, 2, -4 },{ -2, -1, 1 },{ 3, 0, 2 },{ -1, 2, -2 },{ -3, -3, -3 },{ 1, -1, 0 },{ -2, 3, 2 },{ -4, 2, -2 } },
+		{ { 1, 1, 3 },{ -3, 1, 1 },{ -4, -1, -1 },{ -1, 2, -3 },{ 0, -4, 1 },{ -3, 0, 2 },{ -4, -3, -3 },{ 1, 3, -2 },{ -1, 0, 1 },{ -2, -4, -3 },{ 2, -1, 2 },{ -1, -3, -4 },{ 3, -4, -3 },{ 1, 2, -4 },{ -1, 3, 1 },{ 3, 0, -3 },{ 2, 1, -2 },{ 1, 0, 0 },{ -4, 3, -3 },{ 1, -4, 0 },{ 2, -2, -1 },{ 0, 0, 2 },{ 3, -4, -2 },{ -1, -1, 0 },{ 2, 2, 3 },{ 1, -4, -1 },{ 2, -3, -2 },{ 3, -2, 2 },{ -1, 1, -1 },{ 2, 3, -3 },{ -4, -2, -4 },{ -2, -4, 2 },{ -3, 1, -4 },{ 1, -3, 2 },{ -1, 0, 0 },{ -4, -2, -1 },{ 1, -1, 1 },{ -3, -3, -3 },{ 2, 1, 2 },{ -2, -2, -3 },{ -4, 0, -1 },{ -3, 2, 3 },{ 0, -1, -2 },{ -2, -1, 3 },{ 2, 3, 2 },{ 1, -3, -2 },{ 1, -2, 1 },{ -4, 3, -4 },{ -2, -2, -1 },{ 0, 2, -2 },{ -1, 0, 2 },{ 1, -1, -1 },{ -4, 3, -2 },{ -1, -4, 3 },{ 3, -3, -3 },{ -3, -1, -1 },{ -4, 1, 0 },{ -1, -3, -1 },{ 2, 3, -4 },{ 1, -1, -2 },{ 0, 1, 1 },{ 3, -4, -1 },{ -3, -1, -3 },{ 3, -2, 0 } },
+		{ { 0, 0, -4 },{ 3, -3, -3 },{ 2, -2, 0 },{ -2, -2, 3 },{ 3, 1, -4 },{ -2, 3, -2 },{ 2, -2, -1 },{ -4, 1, 1 },{ 3, -2, 3 },{ 1, 2, 0 },{ 0, 3, -2 },{ 2, 0, -1 },{ -3, -2, 0 },{ 2, 0, 3 },{ -4, -1, -1 },{ 0, -4, 2 },{ -2, -2, 1 },{ 0, -4, 3 },{ -1, -2, 1 },{ -1, 1, -2 },{ -2, 2, 3 },{ 3, 1, 1 },{ -3, -2, -3 },{ -3, 3, -1 },{ -2, -3, 2 },{ 0, -2, -3 },{ -3, 3, 0 },{ 1, -1, 3 },{ -4, -4, 0 },{ -2, -3, -1 },{ 3, 1, 0 },{ 1, -1, -2 },{ 2, -1, 3 },{ -1, 3, -1 },{ 0, -4, -2 },{ 3, 1, -3 },{ -1, 3, -2 },{ -3, -3, -4 },{ 0, -1, -1 },{ -1, 2, 0 },{ 1, -4, 1 },{ 2, 3, -3 },{ 2, -3, -4 },{ -3, 1, 1 },{ -1, -2, 0 },{ -3, 2, -3 },{ 0, 0, -4 },{ 2, -3, 3 },{ -2, 0, 0 },{ 3, 1, 0 },{ -3, -3, 3 },{ 1, -2, -2 },{ 3, 1, 0 },{ 0, 2, -3 },{ 2, 0, -4 },{ 0, 3, 2 },{ 1, -4, 3 },{ -2, -2, -3 },{ -3, -3, 3 },{ -3, 2, 0 },{ 0, 0, 2 },{ 2, -3, -4 },{ -1, 2, 3 },{ -1, 0, 1 } },
+		{ { -2, -4, 2 },{ -4, -1, -1 },{ 1, 3, 2 },{ -1, 2, -2 },{ 1, 0, 1 },{ 3, -3, 2 },{ 0, -1, -3 },{ -1, 2, -4 },{ -3, -3, 3 },{ -4, 0, -3 },{ -1, -2, 1 },{ -4, 2, 2 },{ -2, -1, 1 },{ 0, 2, -3 },{ -3, 1, 0 },{ 3, -3, -4 },{ -4, 2, -1 },{ 2, 2, -4 },{ -3, -1, 2 },{ 2, 0, 0 },{ -4, 2, -2 },{ 1, -4, -4 },{ -4, -1, 2 },{ 1, 2, -1 },{ 3, 0, -4 },{ -2, 1, 1 },{ -4, 0, -2 },{ 3, 2, -3 },{ -1, 0, -4 },{ 1, -3, 2 },{ -2, 3, 3 },{ 0, 2, -3 },{ -4, -3, 1 },{ -3, 1, -4 },{ 3, -2, 3 },{ -2, 3, 0 },{ 0, -4, 2 },{ 2, 1, 1 },{ 3, 2, -2 },{ -3, -4, 3 },{ -4, 0, -4 },{ 0, -2, 2 },{ 3, 2, -1 },{ -4, -4, 0 },{ 1, 0, -3 },{ 3, -4, -1 },{ -1, 1, 1 },{ 2, -1, 2 },{ 0, 3, -3 },{ -4, -4, -4 },{ 2, 3, 1 },{ -1, 1, -4 },{ -2, -3, 3 },{ -4, -1, 1 },{ -3, -2, 1 },{ -1, -1, 0 },{ 3, 2, -2 },{ -4, 3, -4 },{ 2, 0, 0 },{ 3, -2, -3 },{ -2, -4, 3 },{ -4, 2, -1 },{ 1, -2, -2 },{ -3, 3, -1 } },
+		{ { 2, 1, -3 },{ -2, 2, 3 },{ 2, -2, -2 },{ -3, -4, -3 },{ -3, 1, -1 },{ -4, -4, 3 },{ -2, 3, 0 },{ 2, -1, -1 },{ 0, -4, -1 },{ 3, 1, -2 },{ -2, -3, -4 },{ 1, 1, 3 },{ 1, -4, -2 },{ -1, -3, -3 },{ 2, 3, 3 },{ 1, -2, -2 },{ -2, 0, 1 },{ 1, -1, -3 },{ 3, 3, -1 },{ -2, -3, -4 },{ 0, -3, -3 },{ -1, -2, 0 },{ -1, 3, 3 },{ 2, -3, 1 },{ 0, -4, -3 },{ 3, 2, 3 },{ 1, -4, 1 },{ -3, 3, 2 },{ 0, 0, -2 },{ 2, -1, 1 },{ -3, -2, -4 },{ 2, 0, 0 },{ -1, -4, -3 },{ 1, 0, 1 },{ -4, -1, 2 },{ -2, 2, -4 },{ 1, 0, 1 },{ -4, 0, 3 },{ -1, -2, -1 },{ 1, 1, 2 },{ 3, -1, -3 },{ -1, -3, 0 },{ -2, 0, 3 },{ 0, 3, -2 },{ 1, -3, 3 },{ -3, 1, 2 },{ -2, 2, -2 },{ -4, -2, 0 },{ 3, -3, 3 },{ -2, -1, -2 },{ 0, -2, -3 },{ -4, -4, -1 },{ 1, 3, 2 },{ -1, 0, -2 },{ 2, 1, -1 },{ 3, -4, -2 },{ 0, 0, 2 },{ -1, -3, 1 },{ 0, -1, 2 },{ 1, 1, -1 },{ -4, 3, -3 },{ -2, 0, 1 },{ 3, -4, 2 },{ 1, -3, -4 } },
+		{ { -4, -1, 0 },{ -3, -4, 1 },{ 0, 1, -4 },{ 3, 0, 2 },{ 0, -3, 0 },{ 1, -1, -3 },{ -1, 1, 3 },{ 1, 0, -2 },{ -3, -4, 1 },{ 2, 3, 2 },{ -3, -1, 0 },{ 3, -2, -1 },{ 0, 3, -4 },{ -2, -3, 0 },{ -4, -1, 2 },{ -3, 2, 0 },{ -1, 0, 3 },{ -2, -4, -2 },{ -4, -3, 3 },{ 0, 2, 2 },{ 2, 0, 1 },{ 3, 3, 1 },{ -2, 1, -2 },{ 0, -3, -2 },{ -4, 1, 0 },{ -1, -1, 2 },{ -2, -2, -4 },{ -4, -3, -1 },{ 2, 1, -1 },{ -4, -4, 1 },{ -1, 2, -2 },{ -3, -3, 3 },{ 3, 3, -1 },{ 0, 2, -1 },{ 2, -3, 0 },{ 1, -3, -3 },{ -3, -2, -2 },{ 3, -4, -3 },{ -2, -1, -4 },{ -4, 3, 1 },{ 0, 3, -2 },{ -3, 1, -1 },{ 2, -2, 2 },{ -2, 2, -4 },{ 3, -1, 1 },{ -4, -2, -1 },{ 0, 3, -4 },{ 1, -4, -2 },{ -3, 0, 2 },{ 1, 2, 1 },{ 2, 1, 0 },{ -3, 0, -1 },{ 3, -1, 2 },{ 1, -3, -3 },{ -4, 3, -4 },{ -2, 1, 3 },{ -3, -2, -3 },{ 2, 2, -1 },{ -2, -4, -2 },{ 2, -1, 3 },{ -1, -3, -4 },{ 0, 1, 0 },{ -1, -1, -2 },{ 0, 1, 1 } },
+		{ { 1, -2, -3 },{ 1, 3, 3 },{ -1, -3, 0 },{ -4, -1, -2 },{ 2, 3, 1 },{ -2, 2, -4 },{ 3, -2, -4 },{ -4, 2, 2 },{ 0, 1, 0 },{ -2, -2, -4 },{ -1, 2, -2 },{ 2, -1, 1 },{ -3, 0, 2 },{ 3, 1, -1 },{ 2, -2, -1 },{ 0, -4, -4 },{ 3, -3, 1 },{ 2, 3, -3 },{ -1, 1, 0 },{ 0, -1, -2 },{ -3, -4, -1 },{ -4, -2, -3 },{ 2, -1, -4 },{ -3, 0, 2 },{ -3, -1, -3 },{ 2, 3, -1 },{ -1, 0, -3 },{ 0, -4, 0 },{ 3, 2, 3 },{ -2, -2, -4 },{ 1, 1, -1 },{ 1, -1, 2 },{ -2, 1, -4 },{ -3, -2, -2 },{ -2, -4, 3 },{ -1, 2, 3 },{ 0, 3, -1 },{ -1, 1, 0 },{ 2, 2, -1 },{ 2, -3, -2 },{ -2, -3, 3 },{ 3, 0, 0 },{ -4, -4, -4 },{ -1, 2, 1 },{ 1, -1, -3 },{ -1, -3, 0 },{ 2, 1, 3 },{ -1, -1, -3 },{ 0, 2, -1 },{ -2, -3, -4 },{ -1, 3, 3 },{ 3, -1, -2 },{ 0, -2, -4 },{ -1, 2, 3 },{ -2, -4, 1 },{ 0, -2, 0 },{ 1, -1, 2 },{ -4, -3, -4 },{ -2, 3, 0 },{ 3, 1, -3 },{ -3, 3, 1 },{ 2, -2, 3 },{ -3, 2, -3 },{ 3, 3, -1 } },
+		{ { -2, -1, -4 },{ 2, 0, -2 },{ -3, 2, 2 },{ -1, 2, -3 },{ 3, -4, 0 },{ -2, -1, 3 },{ -3, -4, -1 },{ 0, -3, 1 },{ 3, 0, -3 },{ -2, -2, 3 },{ 0, 2, -3 },{ -4, -4, 3 },{ 1, -3, -4 },{ -4, 1, -3 },{ 0, 3, 3 },{ -2, 2, 2 },{ 1, -1, -3 },{ -3, 1, 0 },{ -4, -2, 2 },{ 3, 0, -4 },{ 1, 1, 3 },{ -2, 2, 2 },{ 1, -4, -1 },{ 0, 2, 3 },{ 2, -3, 1 },{ 3, 2, 3 },{ 1, -2, -2 },{ -3, 1, 2 },{ 0, -1, -3 },{ -1, 3, 0 },{ 3, -2, -3 },{ -4, -3, 2 },{ 0, 0, 0 },{ 2, 3, -3 },{ 3, 0, 1 },{ -4, 1, -4 },{ 3, -1, 2 },{ -2, -2, 1 },{ -4, -4, 2 },{ -3, 0, 3 },{ 1, -2, -4 },{ -1, 1, 1 },{ 1, -3, -2 },{ -3, 3, 3 },{ -3, -4, -2 },{ 2, 1, -1 },{ 3, 0, 2 },{ -3, 2, 1 },{ 3, -4, 0 },{ -4, -1, -2 },{ 2, -2, 2 },{ -3, -4, 0 },{ -4, 2, 0 },{ -2, 0, -1 },{ 2, -3, 2 },{ 2, 3, -1 },{ 3, 2, -2 },{ -1, 0, 3 },{ -3, -1, 2 },{ 0, -2, 0 },{ -4, -4, -1 },{ 1, 0, -2 },{ -2, -3, 2 },{ -4, -4, 2 } },
+		{ { -1, -2, 0 },{ 3, 1, -1 },{ 0, -3, 3 },{ 1, -2, -1 },{ -4, 0, 2 },{ 0, 3, -2 },{ 2, -2, -2 },{ -1, 3, -1 },{ 2, -1, 2 },{ -4, -4, 1 },{ 3, 1, -1 },{ -1, 0, -2 },{ -1, 2, 0 },{ -2, -4, 1 },{ 2, -2, -2 },{ -1, -2, -1 },{ -4, 0, -4 },{ 2, 3, 3 },{ 1, -4, -1 },{ 0, 2, 1 },{ -2, -3, -3 },{ 3, 0, 0 },{ -1, -2, -3 },{ -4, 3, 0 },{ -1, 0, -4 },{ -2, -4, 0 },{ -4, -1, -4 },{ 2, 3, 3 },{ -4, -3, 1 },{ -2, 0, -2 },{ -3, 1, 1 },{ 1, -4, 3 },{ -1, 2, -2 },{ -3, -2, 2 },{ 1, -4, -1 },{ -3, -3, -2 },{ 0, 0, -3 },{ 1, 3, -3 },{ 0, 1, 0 },{ 3, 2, -4 },{ 0, -1, -1 },{ -4, 3, 2 },{ 3, -2, -3 },{ 2, 1, 0 },{ 0, 0, 2 },{ -2, -2, -4 },{ -1, 3, -2 },{ -4, -3, 3 },{ -2, 0, -3 },{ 0, 1, -4 },{ -1, -3, 2 },{ 1, 3, -3 },{ 3, 0, -3 },{ -3, 1, 1 },{ 0, -1, -4 },{ -4, -2, -3 },{ -3, 0, 0 },{ 1, -4, -2 },{ 1, 2, -4 },{ 3, 1, 3 },{ 2, -2, -4 },{ -2, 2, 1 },{ 0, 1, -1 },{ 2, -3, 0 } },
+		{ { -4, 1, 2 },{ -3, 3, 1 },{ -2, -4, -4 },{ 2, -1, -3 },{ -2, -3, -4 },{ 1, 1, 1 },{ -3, 0, 2 },{ -4, 1, -3 },{ 1, 2, -4 },{ -2, 3, -2 },{ 1, -3, 0 },{ -3, -2, 3 },{ 2, 3, 2 },{ 3, 0, -4 },{ 1, -1, 3 },{ -3, 1, 0 },{ -2, -4, 1 },{ 3, -3, -2 },{ -2, -2, -4 },{ -4, -1, 3 },{ -1, 3, -2 },{ 2, -4, 1 },{ -4, -1, -1 },{ 3, -3, -2 },{ 1, 1, 2 },{ 0, -2, -1 },{ -2, 2, -2 },{ -1, -1, -1 },{ 3, -4, 1 },{ 1, 2, -1 },{ -1, 0, -4 },{ 3, -2, -1 },{ -4, 1, -4 },{ 0, 2, 0 },{ 2, -1, -3 },{ -2, 3, 2 },{ -4, -4, 0 },{ 2, -3, 3 },{ -1, -2, -2 },{ -2, -2, 0 },{ -3, -4, -2 },{ 1, 2, 1 },{ -1, -1, -3 },{ -3, -4, 3 },{ 0, -1, -1 },{ -4, -3, -4 },{ 1, 2, 2 },{ 1, -2, 0 },{ 2, -3, -1 },{ 2, 3, 1 },{ -4, 1, 3 },{ -2, -4, -1 },{ 1, -2, 1 },{ 2, 2, -2 },{ -1, -4, 3 },{ 3, 1, 0 },{ -2, 3, 1 },{ 0, -3, -3 },{ -2, -2, 1 },{ -1, 3, 1 },{ -3, -4, -2 },{ -1, 0, -3 },{ 3, -1, 3 },{ -1, 3, -4 } },
+		{ { 1, -4, -2 },{ 3, -1, -3 },{ 1, 0, 0 },{ -4, 3, 1 },{ -1, 2, 0 },{ 3, -3, -3 },{ 0, -4, 0 },{ 1, -2, 3 },{ 3, -4, -1 },{ -3, 0, 2 },{ 0, -1, -4 },{ 3, -1, -3 },{ -3, -3, -1 },{ -1, 2, -1 },{ -4, -3, 2 },{ 1, 3, -3 },{ 0, 2, 0 },{ -1, 0, 1 },{ 2, 3, 2 },{ 0, 1, -1 },{ -3, 0, 0 },{ 1, -2, -4 },{ -3, 1, 3 },{ -2, 2, 2 },{ 1, -1, -3 },{ 2, 3, 3 },{ -4, -3, 0 },{ 2, 1, -3 },{ 0, -2, -4 },{ 2, -3, 3 },{ -2, 3, 0 },{ 2, -4, 2 },{ -2, -1, -2 },{ 3, -3, 1 },{ -3, 1, 3 },{ 0, -1, -1 },{ 3, 2, -4 },{ 1, 0, 1 },{ -4, 2, 2 },{ 2, -1, -3 },{ 2, 1, 3 },{ -2, -3, 0 },{ 0, 0, -4 },{ -2, 2, 0 },{ 2, 3, 1 },{ 3, -4, -3 },{ 1, 1, -1 },{ -3, -1, -3 },{ -2, -1, 3 },{ 0, 0, 0 },{ -1, 2, -2 },{ 3, -1, -4 },{ -3, 3, 2 },{ -1, -1, 0 },{ 1, -3, -4 },{ -4, 1, 2 },{ 0, -1, 3 },{ 2, -4, -4 },{ 3, 1, -1 },{ -4, -1, -1 },{ 1, -3, 2 },{ 2, 0, 0 },{ -3, 2, 1 },{ -4, -3, -3 } },
+		{ { -2, 0, 0 },{ 0, 2, 3 },{ 2, -2, -1 },{ -3, -2, 2 },{ -2, 1, 3 },{ 3, -1, -2 },{ -4, 2, 1 },{ -2, -1, -4 },{ -1, 1, 0 },{ -1, -3, 1 },{ 2, 2, 3 },{ -4, 1, -2 },{ 0, 0, 1 },{ 2, -4, -2 },{ -3, 1, -4 },{ 1, -2, -2 },{ 3, -1, 3 },{ -3, -4, -2 },{ -3, 1, -3 },{ 2, -3, -3 },{ 3, -4, 3 },{ 0, 3, 1 },{ 0, 2, -3 },{ -1, -4, -1 },{ -3, 0, 1 },{ 3, -4, -4 },{ -3, 0, 2 },{ 1, -1, 2 },{ -3, 3, 0 },{ -3, 0, 2 },{ -4, 2, -3 },{ 0, -1, 1 },{ -3, 3, -3 },{ -1, 0, 2 },{ 1, -3, -4 },{ -1, 1, -2 },{ -2, -4, 1 },{ -3, -1, -2 },{ -1, 1, 3 },{ 3, 3, -1 },{ -1, -4, -2 },{ -4, 0, 2 },{ 1, 3, -1 },{ 3, -3, -2 },{ -1, 0, 2 },{ -4, 1, 3 },{ -1, 2, -2 },{ -2, -4, 1 },{ 3, 3, -4 },{ -3, -3, -2 },{ -1, -2, 1 },{ 1, 0, -1 },{ -4, -4, 3 },{ -2, -3, -3 },{ 2, 2, -2 },{ -3, -2, -1 },{ -3, 3, -2 },{ -1, -1, 2 },{ -4, 2, 0 },{ -2, 2, -3 },{ 0, -2, 3 },{ -3, 3, -4 },{ 0, -4, -1 },{ 2, -2, 3 } },
+		{ { -2, 2, -4 },{ -4, -3, 2 },{ 0, 1, -2 },{ 2, -4, -2 },{ -1, 0, -3 },{ 0, -4, 2 },{ -3, 3, -1 },{ 2, -2, 3 },{ 0, 3, -2 },{ -4, 0, -1 },{ -2, -4, -3 },{ -2, 3, 0 },{ 1, -2, 2 },{ -1, 2, 3 },{ -2, 3, 0 },{ -4, -2, 2 },{ -1, 1, -1 },{ 1, -3, -4 },{ -4, -1, 0 },{ -1, 2, 2 },{ -2, 0, -1 },{ -4, -2, -2 },{ 3, 0, 2 },{ 2, -3, -4 },{ -2, -2, -2 },{ -1, 3, 1 },{ 0, 2, -2 },{ -1, -4, -1 },{ -2, 1, -2 },{ 1, -3, -4 },{ -1, 1, -1 },{ 3, -3, 3 },{ 1, -4, -4 },{ -4, 2, -1 },{ 3, -2, 0 },{ 0, 3, 2 },{ -4, 2, -3 },{ 2, -2, -1 },{ 0, -3, -4 },{ -3, -3, -3 },{ -2, 2, 2 },{ 3, -1, -4 },{ 0, -2, 3 },{ -4, -4, -3 },{ -2, -1, 0 },{ -3, -2, -4 },{ 2, 3, 1 },{ 0, -2, 3 },{ -4, 2, 0 },{ 2, -4, 2 },{ 2, 1, -3 },{ -3, -1, 3 },{ 0, 3, -4 },{ 3, 1, 1 },{ 0, 0, 0 },{ 2, 0, -3 },{ 1, -4, 2 },{ 3, -2, -4 },{ 1, 0, 1 },{ 2, -4, -3 },{ 3, -1, 2 },{ -2, 1, -2 },{ 1, -1, -1 },{ -1, 1, 0 } },
+		{ { 3, -1, -3 },{ 3, 3, 1 },{ -3, 0, -4 },{ -2, -3, 0 },{ 1, 3, -4 },{ -4, -2, -1 },{ 2, 0, -3 },{ -1, 1, -4 },{ 1, -3, 2 },{ 3, 2, -3 },{ 2, -3, 2 },{ 1, -2, -4 },{ -3, 1, -1 },{ 2, -4, -3 },{ 0, -3, 1 },{ 3, -1, -3 },{ 2, 0, 2 },{ -2, 3, -1 },{ 0, -2, 3 },{ 3, 1, 1 },{ 1, -4, -4 },{ -2, 2, 0 },{ -4, -2, 3 },{ -1, -1, 0 },{ 1, 1, -1 },{ -4, -3, 3 },{ 3, 0, -3 },{ -4, -2, 1 },{ 2, -2, 3 },{ 3, 3, 0 },{ 2, -1, -2 },{ -2, -2, 1 },{ 0, 2, 2 },{ 1, 0, 0 },{ -3, -4, -2 },{ 2, -1, 3 },{ -2, -3, 1 },{ 3, 1, 0 },{ -1, -1, 3 },{ 1, 3, 1 },{ -4, -2, 0 },{ 1, 1, 1 },{ -3, 2, -1 },{ 2, 1, 2 },{ 1, 2, -3 },{ 0, -3, -1 },{ 3, 0, -2 },{ -1, -1, -3 },{ 1, 0, -4 },{ 1, 1, 2 },{ -2, -2, -2 },{ 0, 2, 1 },{ -4, -3, 0 },{ -2, -2, -2 },{ -1, 2, 1 },{ -4, -3, 3 },{ -2, 3, -1 },{ 0, 1, 1 },{ -4, 3, -2 },{ -2, -3, 3 },{ -1, 0, 1 },{ -3, 3, -4 },{ -4, -3, 2 },{ 0, -4, 1 } },
+		{ { -3, 2, 3 },{ 1, -2, -1 },{ -4, -1, 2 },{ 2, 1, 1 },{ 1, 2, 3 },{ 3, -1, 1 },{ -2, -3, 2 },{ -2, -4, 0 },{ -3, 0, 0 },{ -4, -1, -2 },{ 0, 2, 1 },{ -2, 0, 3 },{ -4, -1, -2 },{ 3, -1, 1 },{ -4, 2, -1 },{ -3, 0, 1 },{ 1, 2, -4 },{ 0, -4, -2 },{ 2, 3, 0 },{ -3, -3, -2 },{ 1, -1, -3 },{ 0, 3, -1 },{ 2, -4, -3 },{ 3, 3, 1 },{ 0, 1, 2 },{ -2, 2, 0 },{ 1, -1, -4 },{ -1, -3, 0 },{ 0, 2, -3 },{ -4, -4, 2 },{ -1, 1, -4 },{ -3, 0, 0 },{ 3, 3, -1 },{ -4, 1, -3 },{ -2, -3, -4 },{ 1, -2, -1 },{ -1, 0, -3 },{ 1, 3, -2 },{ -4, 2, -1 },{ 0, -4, 0 },{ 3, 0, -2 },{ -1, -3, -4 },{ -2, -4, 1 },{ 2, 3, -2 },{ -4, -1, 3 },{ -3, 0, 2 },{ -2, 3, -1 },{ 0, -3, 2 },{ -3, -4, -1 },{ -4, -3, 0 },{ -1, 3, -4 },{ 2, 0, 3 },{ 3, -4, -1 },{ 1, -1, -4 },{ -3, 0, 2 },{ 2, -4, -3 },{ 0, 2, -4 },{ -3, -1, 0 },{ -1, -2, -3 },{ 2, -3, 0 },{ 0, 1, -1 },{ 3, -4, 0 },{ 2, 3, -3 },{ 1, 0, -2 } },
+		{ { -1, -3, -3 },{ 0, -4, -2 },{ -1, 2, 0 },{ -2, -4, -2 },{ 0, 0, -3 },{ -4, 1, -1 },{ -1, 3, -2 },{ 3, 2, -4 },{ 2, -4, 2 },{ -1, -1, 3 },{ 0, 3, -4 },{ 3, -3, 0 },{ 1, 1, -3 },{ -1, 3, 0 },{ 0, -3, -4 },{ -1, 1, 3 },{ -2, -4, 2 },{ -3, -1, -1 },{ -4, -2, -3 },{ -1, 0, 3 },{ -3, 1, 2 },{ -4, -2, 1 },{ -1, 1, 3 },{ -3, 0, -4 },{ -3, -3, -3 },{ 3, -4, -2 },{ -2, 3, -1 },{ 2, -1, -2 },{ -3, 0, 1 },{ 1, 2, 0 },{ 0, -3, 3 },{ 1, -3, -3 },{ -2, -1, 1 },{ -1, -1, 3 },{ 2, -2, 1 },{ -3, 3, 2 },{ -4, 1, 3 },{ 3, -4, 1 },{ -2, 0, -4 },{ -3, -2, 2 },{ 2, 2, -3 },{ -2, 0, 3 },{ -1, -1, -2 },{ 0, -3, 0 },{ -1, -2, -4 },{ 3, -4, 1 },{ 2, 1, 0 },{ -4, 2, -3 },{ 3, -1, 3 },{ 3, 3, 1 },{ -2, 0, -3 },{ 0, -3, -1 },{ -3, 1, -3 },{ 1, 3, 2 },{ -1, -2, -2 },{ 3, 1, 0 },{ -1, -3, 1 },{ 2, -2, 3 },{ 3, 2, 2 },{ -4, 2, -4 },{ 1, -1, -2 },{ -4, 2, 3 },{ -2, -2, 2 },{ -2, 1, 0 } },
+		{ { 2, 0, 2 },{ -4, 1, 1 },{ 3, 3, -4 },{ -3, -2, 3 },{ 3, -2, 2 },{ -4, -3, 0 },{ 2, -1, 3 },{ 0, -2, 1 },{ -3, 2, -3 },{ 1, 0, -1 },{ -3, -2, -2 },{ -1, -4, 1 },{ -4, -3, 3 },{ 2, 0, 2 },{ -2, -2, -1 },{ 3, -2, -2 },{ 3, -3, 0 },{ 1, 1, 3 },{ 2, 3, 1 },{ 0, 0, -4 },{ 3, -4, 0 },{ -2, -1, -1 },{ 2, -3, -3 },{ 0, 2, -2 },{ 1, -2, 1 },{ -4, -1, 3 },{ 0, 3, 2 },{ -3, 1, 3 },{ 3, -2, -3 },{ -2, -4, -4 },{ -4, 0, -1 },{ 2, 3, -2 },{ 0, -4, 2 },{ 3, 2, -4 },{ 2, 2, -1 },{ 0, 0, -3 },{ -1, -3, 0 },{ -3, -2, -2 },{ 0, -1, -1 },{ 2, 1, 2 },{ 1, -3, 1 },{ -4, 3, -3 },{ 3, 0, -1 },{ 2, 2, 2 },{ -2, 1, -3 },{ 1, 3, -2 },{ -1, -2, 2 },{ -1, -4, -4 },{ 0, 1, 1 },{ -3, -2, -2 },{ 1, -4, 2 },{ -4, 2, 1 },{ 3, 2, 0 },{ -1, -2, 3 },{ -3, 1, -1 },{ 0, 3, -4 },{ -4, -1, 2 },{ -3, 3, -2 },{ 1, 0, -1 },{ -2, -4, -3 },{ -1, -1, 2 },{ -1, -2, 1 },{ 3, -3, -4 },{ 0, 2, -3 } },
+		{ { -2, -1, -1 },{ 2, -3, 0 },{ 0, -1, -2 },{ -2, 1, -3 },{ 1, -4, -1 },{ 1, 2, -4 },{ -1, 1, -2 },{ -2, 0, -3 },{ 1, -3, -1 },{ -4, 3, 2 },{ 3, 1, 0 },{ 2, 1, -2 },{ -3, 2, -4 },{ 2, -4, -3 },{ 0, 2, 2 },{ -3, 3, -3 },{ -4, 0, -2 },{ -1, 2, -4 },{ -2, -2, -1 },{ 0, -3, -3 },{ 3, 2, 0 },{ -4, 3, 2 },{ 2, -2, 2 },{ -1, 2, 0 },{ -2, 0, -1 },{ 2, 1, 1 },{ -1, -4, -4 },{ -1, -3, -2 },{ 3, 2, -1 },{ -1, -1, 2 },{ -3, 2, 1 },{ 1, 1, -2 },{ -1, -2, 0 },{ -4, -4, 2 },{ -3, 0, -3 },{ 1, -3, 0 },{ 2, 2, 1 },{ 3, -4, -4 },{ -1, 1, 3 },{ -2, 3, -1 },{ 0, -2, -4 },{ -3, -1, 3 },{ 0, -4, 1 },{ -3, 2, -4 },{ -4, -3, -1 },{ -3, -1, 3 },{ -4, -2, -2 },{ 2, 0, -1 },{ 1, 2, -4 },{ 2, -1, 3 },{ -3, 1, -3 },{ -1, -3, -4 },{ 1, -1, -2 },{ -2, -4, 1 },{ 2, -3, -3 },{ -4, -3, 1 },{ 2, 0, -3 },{ -2, -4, -1 },{ 0, 1, 0 },{ 2, -3, 3 },{ -3, 3, -2 },{ 1, 1, -2 },{ -3, -1, -1 },{ -4, 3, 1 } },
+		{ { 1, -4, -4 },{ 3, 3, 3 },{ -4, -2, 2 },{ -1, 2, 1 },{ 2, 3, 1 },{ -3, -1, 3 },{ -2, -2, 0 },{ 3, 1, 2 },{ -3, -4, -2 },{ 2, -3, 3 },{ -2, -1, -4 },{ 0, 3, 1 },{ -1, -1, -1 },{ 1, -1, 0 },{ -4, 3, -1 },{ -1, -3, 1 },{ 1, 0, 0 },{ 2, -1, 2 },{ -4, -4, 1 },{ -1, 2, 3 },{ -3, -1, -2 },{ 1, 1, -4 },{ 0, 0, -4 },{ -4, -4, 3 },{ 1, -1, 2 },{ 3, -3, -4 },{ -4, 2, 0 },{ 0, 0, -3 },{ 1, -2, 1 },{ -4, 3, 0 },{ 2, -1, -3 },{ 3, -3, 3 },{ -3, 1, 0 },{ -2, -2, -4 },{ 0, -1, -2 },{ -2, 3, 3 },{ -4, 1, -2 },{ 1, 3, 0 },{ -3, 0, -3 },{ -4, -3, -2 },{ 3, 2, 0 },{ 1, 1, -2 },{ 2, -2, 0 },{ -1, 0, 2 },{ 1, -2, -3 },{ 2, 0, 1 },{ 0, 3, 0 },{ -2, 2, 2 },{ -3, -3, -2 },{ 0, 0, -1 },{ -1, 3, 1 },{ 2, -2, 0 },{ -3, 0, 3 },{ -4, 0, -4 },{ 3, 2, 2 },{ 1, 1, -1 },{ -1, -1, 3 },{ 3, -2, 1 },{ 1, 2, -4 },{ -2, 0, 2 },{ 0, -4, 1 },{ 3, 0, -3 },{ 2, -2, 0 },{ -1, -4, 3 } },
+		{ { 1, 1, -2 },{ -3, 0, -3 },{ 0, -3, -1 },{ 3, 0, -2 },{ -3, -3, -4 },{ 2, 0, 0 },{ -4, -4, -3 },{ 0, 3, 3 },{ 2, -1, -4 },{ -1, 2, 0 },{ 1, -2, -3 },{ -4, -4, 2 },{ -2, 0, 3 },{ 3, -3, -4 },{ -2, 1, 3 },{ 3, -2, -4 },{ 0, -4, 3 },{ -2, 3, -3 },{ 3, 1, -4 },{ -1, 0, -1 },{ 1, -2, 2 },{ -3, -4, 1 },{ -2, -3, -1 },{ 3, 1, -2 },{ -3, 3, -1 },{ -1, 1, -3 },{ -3, -1, 3 },{ -2, -4, 0 },{ 2, 3, 3 },{ -2, -3, -4 },{ 0, -4, 2 },{ -1, 0, -1 },{ 2, 3, -3 },{ 1, 2, 1 },{ 3, -1, 2 },{ 2, -4, -1 },{ -4, -2, -4 },{ 3, -2, 2 },{ 0, -4, 3 },{ 2, -1, 1 },{ -2, -1, 2 },{ -3, -4, -4 },{ 1, 3, -1 },{ -2, -1, 0 },{ 0, 2, -2 },{ 3, -4, 2 },{ 1, -4, -4 },{ 3, 1, 3 },{ -4, -3, -3 },{ 3, -4, 0 },{ -2, -2, 2 },{ 1, 3, -1 },{ 0, -1, -2 },{ 3, 2, 0 },{ -2, -2, -2 },{ -2, 3, 1 },{ 0, -4, -4 },{ -4, 2, -3 },{ -3, -1, 0 },{ -1, -3, -1 },{ -4, -2, -4 },{ -2, 3, 0 },{ 0, 1, 2 },{ -3, 2, -4 } },
+		{ { 2, -2, 1 },{ -1, 3, 0 },{ -4, -1, 2 },{ -2, -4, -4 },{ 0, 2, 3 },{ -1, 3, -2 },{ 3, -3, 2 },{ -2, 2, -1 },{ -3, 0, 1 },{ -1, 0, 1 },{ 3, -2, -2 },{ 0, 2, -1 },{ -3, 2, -2 },{ 0, -4, 0 },{ 2, 1, 1 },{ -3, -1, -2 },{ 1, 2, -1 },{ -3, 1, 2 },{ 1, -3, -2 },{ -4, -2, 0 },{ 3, 1, -3 },{ 0, 3, 3 },{ -2, 2, 0 },{ 2, -3, -3 },{ 1, -2, 1 },{ 0, -4, 0 },{ 2, 3, -2 },{ 3, 0, 2 },{ -2, 1, -1 },{ -4, 1, -3 },{ 0, -1, -2 },{ -3, 1, 1 },{ -4, -3, 3 },{ -2, -4, -1 },{ 0, 0, 1 },{ -1, -3, -4 },{ -1, 0, 2 },{ 0, 2, -3 },{ -2, 2, 1 },{ 2, -3, -4 },{ -1, 1, -1 },{ -4, 3, 3 },{ 3, -4, -3 },{ -4, 1, 1 },{ -1, -3, 3 },{ -3, 1, -3 },{ -3, 0, -1 },{ -2, -1, 1 },{ -1, 3, -2 },{ 2, 1, -4 },{ -4, 0, 3 },{ 1, 1, -4 },{ -4, -4, 2 },{ 0, -4, -3 },{ 1, 1, -1 },{ -3, -1, -2 },{ 0, -3, 3 },{ 2, 0, 2 },{ -4, 3, -2 },{ 3, 1, 2 },{ 2, 2, -2 },{ 1, 0, 3 },{ -4, -3, -1 },{ -2, -3, -2 } },
+		{ { -1, 1, 3 },{ 1, 2, 1 },{ 2, 1, -3 },{ 3, -2, -1 },{ 0, -1, 2 },{ -4, 1, 0 },{ 1, -4, -4 },{ 0, -2, -3 },{ 2, -3, -1 },{ -4, 3, -2 },{ -3, -4, 3 },{ 1, 1, -4 },{ 2, -2, 2 },{ -4, 0, -3 },{ -1, 3, 2 },{ -1, -2, -1 },{ -2, -3, -3 },{ 2, -1, 0 },{ 0, 0, 3 },{ -2, -4, 1 },{ 2, 3, -4 },{ -1, 0, -2 },{ -4, -1, -1 },{ 0, 0, 2 },{ -3, -1, 3 },{ -2, 2, -4 },{ 0, -2, 1 },{ -4, -3, -2 },{ 1, -1, -3 },{ 3, -2, 3 },{ 2, 2, 0 },{ -1, -2, -1 },{ 3, 3, -4 },{ 2, -2, -2 },{ -3, 2, -3 },{ -3, 3, 0 },{ 3, 1, -1 },{ -2, -4, -2 },{ 1, 0, -1 },{ -3, 3, -3 },{ 1, -2, 1 },{ -2, 0, -2 },{ 2, -1, 3 },{ 0, -2, -4 },{ -1, 0, -1 },{ 2, 3, -4 },{ 1, -2, 0 },{ -1, -2, 0 },{ 0, -1, 1 },{ -3, -4, 2 },{ -1, 2, -2 },{ 3, -3, -1 },{ -2, 3, 1 },{ -1, -3, 3 },{ -3, 0, 2 },{ 2, -2, 0 },{ 3, 3, -4 },{ -1, 1, 0 },{ 1, -4, -3 },{ 0, -2, 3 },{ -2, -3, -3 },{ -1, -4, 1 },{ 3, 3, -3 },{ 3, -1, -1 } },
+		{ { 0, -4, 0 },{ -4, -4, -4 },{ -2, -3, 2 },{ -3, 3, 1 },{ 1, 0, -3 },{ -2, -1, 0 },{ 3, 1, 1 },{ -1, 3, 2 },{ 1, -1, -3 },{ -2, 0, 2 },{ 3, 1, 0 },{ -1, -3, -1 },{ -3, -1, 1 },{ 1, -3, -2 },{ 3, 2, -4 },{ -3, -3, 2 },{ -4, 0, -2 },{ 3, -4, 1 },{ -1, 3, -4 },{ -4, 2, -2 },{ 1, -1, 2 },{ -3, -2, -3 },{ 3, -4, 0 },{ -1, 3, -4 },{ 1, 1, -2 },{ -4, -4, -1 },{ 2, 3, 3 },{ -1, 2, -4 },{ -1, -3, -1 },{ -3, 2, 1 },{ -3, -4, 2 },{ -2, -1, -4 },{ 1, 0, 2 },{ -4, 1, 1 },{ 0, -3, 3 },{ 1, 1, 1 },{ -4, -1, 3 },{ 2, -3, 2 },{ -4, -1, 0 },{ -1, 1, 3 },{ 3, -3, -2 },{ 0, 2, 0 },{ -3, -3, 1 },{ 1, 1, -2 },{ -2, 2, 2 },{ 2, -4, 2 },{ -4, -3, -2 },{ -4, 3, 3 },{ 3, 2, -3 },{ 2, 0, -3 },{ 0, -2, 1 },{ -3, -1, -3 },{ 2, 0, 3 },{ 3, 1, -3 },{ -2, 3, -2 },{ 0, -4, -4 },{ -4, -3, 1 },{ -2, 1, -1 },{ 2, -2, 1 },{ 0, -1, 0 },{ -3, 1, -4 },{ 2, 3, 1 },{ -3, -1, 3 },{ -4, 0, -4 } },
+		{ { -2, 2, -2 },{ -1, -1, 0 },{ 1, 1, -3 },{ 2, -2, -2 },{ -1, -4, 3 },{ -4, -3, -2 },{ -3, 2, -2 },{ -3, 0, 3 },{ 2, -4, -4 },{ -4, 2, 1 },{ 0, -3, -4 },{ 1, 3, 3 },{ -2, 3, -3 },{ 2, -4, 0 },{ -2, 0, 3 },{ 2, 1, 0 },{ 1, 3, -4 },{ 0, 2, 3 },{ 2, -2, -1 },{ -3, -3, 0 },{ 2, 1, 1 },{ 0, -4, 3 },{ -2, 2, 2 },{ -3, -1, 1 },{ 2, -3, -1 },{ 3, -2, 2 },{ -3, 0, -3 },{ -2, 1, 2 },{ 1, -4, 0 },{ 3, 0, 3 },{ 1, 3, -3 },{ 0, 1, -2 },{ -1, -4, 3 },{ 2, -1, 0 },{ -2, -3, -4 },{ 2, -2, -2 },{ 0, -4, -3 },{ -1, 2, -4 },{ 3, -2, 0 },{ 1, 3, -4 },{ -3, -4, 2 },{ 3, -2, -1 },{ -1, 1, -4 },{ -4, 3, 0 },{ 3, -1, 3 },{ -2, -3, -3 },{ 0, 2, 0 },{ 1, 0, -4 },{ -2, -3, -1 },{ -3, -4, 0 },{ 1, 3, 1 },{ -4, 0, -1 },{ 1, -3, -4 },{ -1, -1, 0 },{ -4, -2, -1 },{ 2, 2, 2 },{ -1, -1, 3 },{ -3, 2, -3 },{ -2, 0, -1 },{ -4, 3, 3 },{ 3, 0, -2 },{ -1, -3, -1 },{ 0, 1, 0 },{ 1, -2, 2 } },
+		{ { 3, 3, -3 },{ 3, -1, 3 },{ -3, 2, -1 },{ -1, 0, 1 },{ 0, 3, -4 },{ 3, 2, -1 },{ 2, -3, 2 },{ 0, -1, 0 },{ 3, -2, 0 },{ -3, 1, -2 },{ -1, -2, 2 },{ 3, 0, -2 },{ -4, -1, -3 },{ 0, 2, 2 },{ 0, -1, -1 },{ -3, -2, -2 },{ -1, -1, 2 },{ -4, -4, -3 },{ -2, 0, 2 },{ -1, -1, -3 },{ 1, 1, -1 },{ -4, 0, -4 },{ 3, 3, -2 },{ 1, -2, -3 },{ -1, 0, 1 },{ -1, 2, -4 },{ 0, -4, 0 },{ 2, -1, 1 },{ -3, 0, -2 },{ -4, 1, -4 },{ 0, -2, 0 },{ -4, -3, -1 },{ 3, 2, -2 },{ -3, 3, -3 },{ -2, 0, 0 },{ 3, 3, -1 },{ -1, 2, 2 },{ -3, 1, 1 },{ -2, 0, -2 },{ 0, -1, 0 },{ -2, 0, 1 },{ -4, -1, -3 },{ 2, 2, 2 },{ -1, -2, -3 },{ 1, -4, -1 },{ -3, 0, 1 },{ 3, 1, -2 },{ 2, 1, 2 },{ -2, -2, 2 },{ -1, 2, 3 },{ 2, -2, -2 },{ -1, 1, 3 },{ -2, 3, 2 },{ 3, -4, 0 },{ 0, 2, 1 },{ 1, 0, -2 },{ 2, 1, 0 },{ 1, -4, -3 },{ 3, -3, 1 },{ 0, -1, -4 },{ 1, -4, 2 },{ -2, 2, -2 },{ -4, 0, -3 },{ 2, -3, 2 } },
+		{ { -3, 1, 1 },{ 0, -4, 0 },{ -4, -3, -2 },{ 1, -1, 2 },{ 2, -2, 3 },{ -2, 0, -4 },{ 0, 1, -1 },{ -1, -4, -3 },{ 1, 3, -1 },{ -2, -3, 3 },{ 0, 0, -1 },{ 2, 2, 0 },{ -3, -2, 1 },{ -4, -4, -4 },{ 3, 3, -1 },{ -2, -3, 1 },{ -3, 1, -2 },{ 3, -1, 0 },{ 2, 3, -1 },{ 0, -3, 3 },{ 3, 2, 2 },{ -1, -2, 0 },{ -4, -3, -1 },{ 0, 1, 3 },{ -2, 2, -2 },{ -4, -1, 3 },{ 1, 3, -1 },{ 0, 2, -2 },{ -2, -3, 1 },{ 3, -3, -3 },{ -1, 3, 2 },{ 2, -2, 2 },{ -3, 0, -3 },{ 1, -1, 1 },{ 0, -4, 2 },{ -4, 2, -4 },{ -3, -1, -2 },{ 1, -3, 3 },{ 2, -3, -3 },{ -4, 3, 3 },{ 0, -4, -2 },{ 1, 2, 3 },{ -2, -3, 1 },{ 2, -4, -4 },{ 0, 3, 3 },{ -3, -1, -2 },{ -1, -2, -4 },{ -4, -1, -1 },{ 0, -4, -1 },{ 3, 2, -4 },{ -4, -1, -3 },{ 1, -4, -1 },{ 2, 2, -4 },{ -3, -2, 1 },{ -3, -3, -3 },{ -2, 0, -4 },{ -1, -4, 3 },{ -4, 3, -1 },{ 2, -2, 2 },{ -1, 1, -2 },{ -4, -1, 1 },{ 2, -4, 3 },{ 1, 2, -1 },{ -2, -2, -4 } },
+		{ { -1, -1, 3 },{ 2, 2, -1 },{ 0, 0, -4 },{ -2, 1, 0 },{ -4, -4, -2 },{ -3, 2, 1 },{ -2, -2, 2 },{ -4, 3, -3 },{ 3, 1, 2 },{ -4, -1, -4 },{ -3, -4, -3 },{ 2, -4, 1 },{ -1, 1, 3 },{ 1, -2, -4 },{ 3, 1, 3 },{ 1, 2, -3 },{ 2, -2, 3 },{ 0, -3, -4 },{ 1, 0, 1 },{ -4, 2, -2 },{ -3, -4, -3 },{ 2, -1, -4 },{ -2, 0, 2 },{ 2, -4, 1 },{ 2, -3, -4 },{ -3, -4, -1 },{ 3, -2, 2 },{ -4, 0, -4 },{ -1, 3, -3 },{ 2, -1, 3 },{ 0, 0, 0 },{ -2, -1, -4 },{ -1, -4, 1 },{ 2, 2, 3 },{ 0, -3, 0 },{ 3, -1, -1 },{ 1, 0, 2 },{ -4, -4, -1 },{ 3, 1, -3 },{ -1, 3, 1 },{ 0, -1, -4 },{ 3, 1, -1 },{ -3, 0, -2 },{ -2, -1, 1 },{ -4, 2, 0 },{ 3, 3, 0 },{ 1, -4, 2 },{ -2, -3, 1 },{ 2, 3, 1 },{ -3, 0, -3 },{ -2, -1, 0 },{ -1, -3, 2 },{ -4, 1, -2 },{ 3, 0, -1 },{ 0, -3, 3 },{ -4, 3, -2 },{ 3, -1, -1 },{ -2, -2, 0 },{ -3, 2, -3 },{ 0, 3, -1 },{ -3, 1, 0 },{ 3, -3, -4 },{ -3, 3, -2 },{ -1, -4, 1 } },
+		{ { -4, -2, 0 },{ 3, 0, -4 },{ 1, -3, 2 },{ -1, 3, -3 },{ 3, -3, 0 },{ -1, -1, -3 },{ 2, 1, 3 },{ 1, -3, 1 },{ 0, 0, 0 },{ 2, 3, 1 },{ -1, -1, 3 },{ 1, 2, -2 },{ -2, 3, -2 },{ -1, 0, 0 },{ -4, 0, 0 },{ -2, -4, -2 },{ -1, 3, 2 },{ -4, 0, 0 },{ -2, -4, -4 },{ 0, 1, 3 },{ -3, -1, 1 },{ 1, 3, -1 },{ 3, 0, 3 },{ -3, 2, 0 },{ 0, 3, -3 },{ -2, -1, 2 },{ 1, 1, 0 },{ -1, -3, -1 },{ 1, -4, 2 },{ -3, 1, 1 },{ -4, -4, -1 },{ 3, 2, -1 },{ 1, 1, -2 },{ -4, -2, -2 },{ -3, 1, -3 },{ -2, -2, 1 },{ 0, 3, -4 },{ -1, -2, 1 },{ 1, 0, 0 },{ -3, -3, -1 },{ 3, -2, 2 },{ -3, 2, 0 },{ -1, -3, -2 },{ 1, -2, 2 },{ 2, 1, -4 },{ -1, -3, 3 },{ -1, 2, -3 },{ 1, 0, -3 },{ -4, 1, 3 },{ 0, -3, -2 },{ 3, 3, 1 },{ 0, -2, 2 },{ -2, 2, -4 },{ 2, 3, 1 },{ 1, -1, -3 },{ 1, 2, 2 },{ 2, 1, 1 },{ 0, -3, 3 },{ 1, 0, -4 },{ 3, -3, -3 },{ -1, -1, 1 },{ 1, 0, 2 },{ 0, 0, 0 },{ 3, 3, -2 } },
+		{ { -3, 1, -1 },{ -4, -4, -3 },{ -2, 2, 2 },{ -3, -2, 3 },{ 0, 3, 1 },{ 3, 1, -4 },{ -2, -1, -1 },{ -3, -4, -2 },{ -1, -2, -2 },{ -2, 2, -4 },{ 3, -2, -1 },{ -4, -2, 2 },{ 1, -3, -4 },{ -3, -1, 2 },{ 0, 3, 1 },{ 2, -3, -3 },{ -4, 2, -1 },{ -1, -2, 1 },{ 3, 2, -2 },{ 2, -2, -1 },{ -2, -3, 0 },{ 0, 2, -2 },{ -1, -2, -4 },{ -4, -2, -2 },{ 1, 0, 0 },{ -1, 1, 3 },{ 2, -1, -2 },{ -3, 3, -3 },{ 3, -2, 3 },{ 0, 2, -2 },{ -3, -1, -4 },{ 0, -3, 2 },{ -2, 3, 3 },{ -1, 0, -4 },{ 2, 2, 0 },{ 3, -4, 3 },{ -4, 3, -2 },{ 2, -2, 2 },{ -2, 2, -4 },{ 2, 1, -3 },{ -4, -4, 1 },{ 0, 0, -4 },{ 2, 3, 3 },{ 3, 2, -3 },{ -4, -1, -1 },{ -3, -2, -2 },{ 2, 1, 0 },{ 3, 3, -1 },{ -2, -2, -4 },{ 1, -1, 2 },{ 2, 1, 0 },{ -4, -4, -3 },{ 1, 0, 3 },{ -1, -2, -2 },{ -1, -4, -1 },{ -2, -2, 0 },{ -4, -4, -4 },{ -1, 0, -2 },{ -2, 3, 2 },{ 2, -4, 3 },{ -4, -2, -1 },{ -2, 1, 1 },{ -2, -3, -4 },{ 2, -1, 3 } },
+		{ { -1, 3, -2 },{ 0, -3, 1 },{ 2, 1, 0 },{ 2, -1, -2 },{ -4, -4, -1 },{ 1, 0, 2 },{ 1, 2, 0 },{ -3, -2, -4 },{ 3, 0, 0 },{ 0, -4, 3 },{ -4, 1, -3 },{ 0, 3, 0 },{ 3, -3, -1 },{ -2, 1, -2 },{ 2, -4, 3 },{ 0, -1, -3 },{ 3, -2, 1 },{ 1, 1, 2 },{ -3, -1, -4 },{ -1, 3, 3 },{ 2, -3, -3 },{ -4, 1, 2 },{ 3, -4, 1 },{ -3, 3, -1 },{ -1, -3, 2 },{ 3, -4, -4 },{ -2, 2, -4 },{ -4, -2, 1 },{ 2, 0, -1 },{ -2, 3, -3 },{ 1, 1, 3 },{ 2, -3, -3 },{ 3, -1, 0 },{ -2, -4, 1 },{ -1, 0, -1 },{ 1, -1, -3 },{ -3, 1, 0 },{ -2, 1, -2 },{ -1, -4, 3 },{ 0, -1, 2 },{ -2, 3, -2 },{ -1, -2, 0 },{ -4, -3, 3 },{ 0, -4, 1 },{ 0, 0, -1 },{ -2, -3, 1 },{ 0, -4, 2 },{ -4, -1, 2 },{ -1, -4, -2 },{ 0, 0, 3 },{ -3, -3, -4 },{ -2, 3, -1 },{ 3, -3, 0 },{ -3, -1, 1 },{ -4, 1, 2 },{ 3, 3, 3 },{ -3, 2, -3 },{ 2, 1, 0 },{ -4, -1, 0 },{ 0, 1, -2 },{ -3, 2, -3 },{ 1, 3, -1 },{ -4, 0, -3 },{ 1, -4, 2 } },
+		{ { -3, -2, -1 },{ 1, 0, 3 },{ 3, 2, -4 },{ -1, -3, -1 },{ -2, -2, -3 },{ -4, 2, 2 },{ -1, -3, -2 },{ 2, 3, 3 },{ -2, 1, 2 },{ 1, 3, -1 },{ -3, -3, 2 },{ 2, -1, -4 },{ 0, 0, 3 },{ -1, 1, -3 },{ -3, -2, 0 },{ -2, 2, -4 },{ -3, 0, 3 },{ -2, -4, -1 },{ 0, 3, -3 },{ -4, 0, 1 },{ 3, 0, -2 },{ -1, -1, 0 },{ 0, -1, -4 },{ 1, 1, -3 },{ 2, -2, 1 },{ -4, 2, -1 },{ -2, -4, 2 },{ 0, 0, 0 },{ 1, -3, 2 },{ -1, -4, 1 },{ -1, -2, -2 },{ -3, 0, 1 },{ -4, 2, -1 },{ 1, -2, 2 },{ 3, 2, 3 },{ -3, -3, 2 },{ 2, -1, -4 },{ 1, -3, -1 },{ -4, -1, 1 },{ 3, -3, -1 },{ 1, 0, -4 },{ 2, 2, 0 },{ -3, 1, -1 },{ -1, 0, -3 },{ -2, 3, -4 },{ 2, 1, 3 },{ 1, 3, -4 },{ -4, 1, -2 },{ -3, 0, 0 },{ 2, 2, -1 },{ -1, 2, -3 },{ -4, -1, 2 },{ 3, 2, -4 },{ 0, 1, -2 },{ 0, 0, -4 },{ 1, -2, -3 },{ 2, -3, -1 },{ 0, -2, 2 },{ -1, -1, -4 },{ 3, -3, 3 },{ 2, -4, 2 },{ -1, -2, -2 },{ 3, -3, 3 },{ 0, 2, 1 } },
+		{ { 3, 1, -3 },{ -2, -2, 0 },{ -3, 3, -3 },{ -1, 0, 2 },{ 2, 1, 3 },{ 3, -2, -2 },{ 0, -4, -4 },{ -4, 0, 1 },{ 2, -1, -3 },{ -1, -4, -2 },{ -1, 0, 1 },{ -3, 2, -2 },{ -4, -4, 1 },{ 3, 3, -1 },{ 1, 2, 2 },{ -4, -2, -2 },{ 2, 0, -2 },{ 1, -3, 0 },{ 3, -3, 0 },{ -2, 1, 3 },{ 1, -4, -2 },{ -3, 3, -1 },{ 2, -3, 2 },{ -2, 0, 3 },{ -4, 3, 0 },{ 0, -1, -3 },{ 1, 3, -2 },{ -3, -1, -2 },{ 3, 2, -4 },{ -4, 1, 0 },{ 0, -1, 3 },{ 3, 3, -4 },{ 0, -3, -2 },{ -4, 2, -3 },{ 0, -2, -4 },{ -2, -4, 0 },{ 0, 3, 2 },{ 3, 2, -3 },{ -1, 0, 0 },{ -4, 3, -3 },{ -3, -2, 3 },{ 1, -4, 2 },{ 3, -1, -4 },{ 3, -2, 2 },{ -3, -4, 0 },{ 1, -1, -2 },{ 3, -3, 0 },{ -1, 2, -3 },{ 1, -3, 1 },{ 3, -4, -2 },{ -2, 1, 1 },{ 1, -3, 3 },{ 2, -2, -2 },{ -2, -4, 0 },{ -3, -3, 1 },{ -1, 0, 3 },{ 3, 2, -2 },{ -3, -4, -1 },{ 1, 2, 1 },{ -3, 3, 1 },{ -4, 0, -4 },{ 0, 1, -1 },{ -2, 2, 0 },{ -4, -1, -4 } }
+	},
+	{
+		{ { 2, 3, -3 },{ -1, 0, 3 },{ 1, -1, -1 },{ -3, 0, 1 },{ 2, -4, -4 },{ -1, -3, -1 },{ -4, 2, -4 },{ 1, -1, -2 },{ -2, 0, -3 },{ -4, 3, -4 },{ 3, 1, 2 },{ 2, 2, -4 },{ -2, 0, 0 },{ -4, -2, 3 },{ 3, -1, 1 },{ -1, -2, -3 },{ -4, 0, -1 },{ 0, 0, -3 },{ -1, 1, 3 },{ -2, -3, -4 },{ 3, 0, -1 },{ -3, 3, 2 },{ -4, -4, 1 },{ 3, 1, -4 },{ -3, 0, 1 },{ 3, -2, -3 },{ -4, 0, -4 },{ 2, -2, -2 },{ -3, -4, 2 },{ -4, 2, -1 },{ 3, -1, 2 },{ -3, 1, 0 },{ 1, -2, 3 },{ 0, 0, -3 },{ -2, -4, 2 },{ -1, -1, -4 },{ 3, 2, 0 },{ 1, -4, 3 },{ -4, -2, 1 },{ -1, 1, -4 },{ -3, -2, 0 },{ 0, 2, -1 },{ -4, 3, -3 },{ 2, -2, 0 },{ -2, 1, -4 },{ -3, 0, 3 },{ -2, 2, -2 },{ 1, 2, 1 },{ 0, -3, -1 },{ 2, -2, -2 },{ -2, -1, -3 },{ -1, -4, -2 },{ -4, -2, 3 },{ 0, -1, -3 },{ 3, 1, -1 },{ 2, -4, 1 },{ -4, 3, -1 },{ 3, 0, 3 },{ 3, 1, -4 },{ -4, -4, 1 },{ 2, 1, -2 },{ 3, -2, -2 },{ -2, -4, 2 },{ -1, 3, -3 } },
+		{ { -3, -2, -1 },{ -2, -4, 0 },{ -4, 2, 2 },{ 3, -3, -3 },{ 0, 1, 1 },{ 1, 3, -1 },{ -1, 0, 3 },{ 3, -4, 3 },{ -3, -2, 2 },{ 0, -3, -1 },{ -3, 0, 1 },{ -1, 3, -2 },{ 1, -1, -1 },{ -2, 1, -3 },{ 2, -3, 0 },{ -1, 3, -4 },{ -3, -3, 2 },{ 2, 3, -2 },{ -3, -2, 1 },{ 1, -4, -4 },{ -1, 2, 1 },{ 2, -2, 3 },{ 0, -1, -2 },{ -2, -4, -3 },{ 1, -1, -1 },{ -3, -3, -2 },{ -1, 3, 0 },{ 3, 1, -3 },{ 1, -1, 0 },{ 0, 0, 1 },{ 1, -3, -3 },{ -1, -3, 3 },{ 2, 1, -4 },{ -3, -1, -1 },{ -4, 3, 0 },{ 2, 2, -2 },{ -3, -2, 2 },{ 0, 1, -3 },{ 3, 0, -1 },{ 1, -3, 3 },{ -2, -1, -2 },{ 2, -1, -4 },{ 1, -4, 1 },{ -1, 1, -2 },{ 1, 0, -1 },{ 2, -1, 2 },{ -4, -4, 1 },{ 2, 0, -4 },{ -4, -4, 3 },{ -4, 1, 2 },{ -2, 0, 2 },{ 2, 3, 0 },{ 3, 1, -4 },{ -3, 2, 1 },{ -1, -2, -3 },{ 0, 2, -2 },{ -3, -2, 0 },{ 1, 3, -3 },{ 0, -2, 0 },{ -1, -3, 2 },{ -1, 3, -4 },{ 1, -1, 0 },{ -4, 2, -4 },{ 1, 0, 3 } },
+		{ { 3, 2, -2 },{ -4, 1, 2 },{ 2, -3, -4 },{ -1, 3, -3 },{ -4, -2, 2 },{ -2, 0, -2 },{ 3, -2, -4 },{ -2, 2, -1 },{ 0, 1, 0 },{ 1, -1, -3 },{ -1, -2, 3 },{ -4, -4, -3 },{ 2, -2, 2 },{ 0, -4, 1 },{ -3, 2, 0 },{ 1, 1, 3 },{ 3, -1, -1 },{ -2, -4, 0 },{ 3, 2, 2 },{ -3, 0, -3 },{ -4, 1, -1 },{ 1, -3, -2 },{ -4, 3, 3 },{ 0, 2, 0 },{ 2, 1, 2 },{ -1, 2, 3 },{ -2, -1, 2 },{ 1, -4, 3 },{ -3, -3, 0 },{ 3, 3, 2 },{ -2, 0, -4 },{ -4, 2, -1 },{ -1, 3, -2 },{ 3, -3, 2 },{ 1, -3, -3 },{ 0, 1, 1 },{ -1, -4, -1 },{ -2, -1, 0 },{ -4, 2, -2 },{ 0, 3, 2 },{ -3, 0, 1 },{ 3, 2, 3 },{ -3, 3, 2 },{ -4, -2, -3 },{ 3, -3, 3 },{ 1, 3, -3 },{ -1, -2, -2 },{ -1, 1, 2 },{ 3, 3, -1 },{ 1, 2, -1 },{ 0, -2, -4 },{ -3, -4, 1 },{ 1, 0, -1 },{ 1, -1, 2 },{ -3, -3, 3 },{ 0, 1, -2 },{ -2, 0, 2 },{ -1, -3, -4 },{ -4, -1, -2 },{ 2, 2, 3 },{ -3, -2, -3 },{ -2, 0, 2 },{ 0, -3, -1 },{ 2, -3, 1 } },
+		{ { 0, 3, -4 },{ 1, -4, 0 },{ 0, -1, 3 },{ 0, -1, -1 },{ 2, -4, 3 },{ -3, 2, 0 },{ 2, -3, 2 },{ -4, -3, -3 },{ -3, 3, -2 },{ 2, 1, 1 },{ 0, 2, 0 },{ 3, 0, 3 },{ 0, 3, -1 },{ -3, 0, -4 },{ 3, -1, -2 },{ -2, -4, 2 },{ 0, -2, -2 },{ -4, 1, -4 },{ 0, -1, 0 },{ 1, 3, 3 },{ 3, -3, 0 },{ -1, -1, -4 },{ -2, 0, 0 },{ 3, -3, -4 },{ -4, -2, 1 },{ 0, 3, -4 },{ 2, -4, -3 },{ -4, 0, -1 },{ -1, 1, -4 },{ 2, 2, -2 },{ -4, -2, -3 },{ 1, -4, 1 },{ 2, -2, 1 },{ -2, 1, 0 },{ -1, -1, 3 },{ -4, 0, -3 },{ 2, -2, -4 },{ 3, 3, 3 },{ -2, -4, -4 },{ 2, -3, -1 },{ 0, -2, -3 },{ -2, -4, 0 },{ -1, 0, -4 },{ -2, -3, 0 },{ 0, 1, -1 },{ -4, 2, 1 },{ -3, -3, -3 },{ 0, -2, 0 },{ -2, -1, -3 },{ 2, -3, 0 },{ 3, -3, -3 },{ -2, 2, 3 },{ -4, 1, -2 },{ -1, -3, 0 },{ 3, 3, -4 },{ 2, -4, 0 },{ 1, -1, 3 },{ 3, 1, 1 },{ -3, -3, -1 },{ 0, 2, -1 },{ 3, -4, 0 },{ 2, 1, 3 },{ -4, 1, -2 },{ -1, -1, 1 } },
+		{ { -2, 0, -3 },{ -3, -2, 0 },{ -3, 1, -2 },{ 3, 1, 1 },{ -1, 2, -3 },{ -4, -1, -2 },{ 0, 1, 1 },{ -1, 0, 1 },{ 1, -4, 3 },{ 3, -1, -4 },{ -2, -3, -4 },{ -4, -3, -2 },{ -3, 3, 1 },{ 2, -3, -1 },{ -1, 0, 0 },{ -4, 2, -3 },{ -1, 3, 1 },{ 2, 0, 3 },{ 1, -3, -3 },{ -2, 1, -2 },{ 0, -2, -2 },{ -2, 2, 1 },{ 2, 1, 2 },{ -3, -4, -1 },{ 0, 0, -2 },{ 3, -2, -1 },{ -3, -3, 0 },{ 2, 2, -2 },{ -2, -1, 1 },{ 0, -3, 2 },{ -1, -1, 3 },{ -3, 1, -1 },{ 0, 0, 2 },{ -2, -4, -4 },{ 3, 3, -1 },{ -3, 2, 1 },{ 1, 1, 0 },{ 0, -3, 2 },{ 1, 0, 1 },{ -1, 1, 2 },{ -4, 3, -3 },{ 1, -1, -2 },{ 3, 1, 2 },{ 0, 3, -2 },{ 2, -4, 3 },{ -2, 0, -4 },{ 3, 2, -1 },{ 2, -4, 3 },{ -3, 0, 2 },{ -1, 3, 1 },{ -3, -1, -4 },{ 0, 3, 3 },{ 2, -4, -3 },{ -1, -1, 2 },{ -2, 2, -1 },{ -4, -2, -3 },{ -2, 2, 1 },{ 2, 3, -4 },{ -4, -4, 2 },{ 0, 0, -3 },{ 1, -1, 1 },{ -2, 3, -3 },{ -3, -4, -1 },{ 3, -1, 2 } },
+		{ { -1, 2, 3 },{ 3, 0, -2 },{ -2, -3, -4 },{ 1, 3, 2 },{ -2, -2, -1 },{ 1, -3, -4 },{ 3, 3, 0 },{ 1, 0, -3 },{ -3, -2, -1 },{ -4, 2, 2 },{ -1, 2, 0 },{ 1, -2, 2 },{ -1, 1, -3 },{ -2, -1, 3 },{ 1, 2, 3 },{ 0, -3, -3 },{ 3, -2, 1 },{ -3, -4, -1 },{ -4, 2, 2 },{ -1, -4, 1 },{ -3, -2, 3 },{ 3, 0, -3 },{ 1, -4, 1 },{ -4, 1, -3 },{ -1, 3, 3 },{ -2, 0, 1 },{ 1, 1, 2 },{ -1, 0, 3 },{ -4, -2, -4 },{ 1, 2, -1 },{ 3, -4, 0 },{ 3, 3, -3 },{ -4, -2, -2 },{ 2, 2, -3 },{ -3, -2, 3 },{ 3, -4, -1 },{ -1, -3, -3 },{ -4, -1, -2 },{ -3, 2, -1 },{ 3, -1, -2 },{ 0, -4, 1 },{ 2, -1, 3 },{ -3, -3, -1 },{ -4, -1, -3 },{ 1, 0, 1 },{ -3, -2, 0 },{ 3, -1, 1 },{ 0, 3, -4 },{ -4, 1, -2 },{ -1, -4, -2 },{ 1, 0, 0 },{ -4, 1, -1 },{ 3, -2, 1 },{ 1, 0, 1 },{ -3, 3, -3 },{ 2, -3, 3 },{ -1, 0, -1 },{ -3, -2, -2 },{ 3, 1, 1 },{ -2, -3, -4 },{ -1, 0, -2 },{ -4, -2, 3 },{ 1, 2, -4 },{ 2, -3, -1 } },
+		{ { 0, -4, 2 },{ 2, 3, -1 },{ -4, -2, 0 },{ 0, -4, 1 },{ -4, 0, -1 },{ 3, 2, 3 },{ -2, -1, 2 },{ -1, -4, -2 },{ -2, 3, 3 },{ 2, -1, -2 },{ 0, -4, -1 },{ 2, 0, 1 },{ 3, -2, 0 },{ -4, -4, -2 },{ 3, 2, -4 },{ -3, -2, 2 },{ -2, 1, -2 },{ 1, 0, -4 },{ 2, -1, 0 },{ 3, 3, -4 },{ 0, 0, -1 },{ -4, 3, -1 },{ -1, -2, 2 },{ 2, -1, 0 },{ 3, -2, -3 },{ 1, 2, -4 },{ -3, -4, 0 },{ 3, 3, -2 },{ 2, -4, -3 },{ -3, 0, 3 },{ -2, 3, -2 },{ 1, 0, 1 },{ -1, -1, -4 },{ 0, -3, 2 },{ -4, 0, 1 },{ 1, 0, -2 },{ -2, 2, 2 },{ -2, 3, -4 },{ 2, -4, 0 },{ -3, -2, 3 },{ -2, 1, -4 },{ -4, 2, 0 },{ -1, 2, 1 },{ 3, -2, -4 },{ 0, 2, 3 },{ -1, 3, -2 },{ -2, -3, 2 },{ -1, 1, -1 },{ 1, -2, 1 },{ 3, -3, 3 },{ 0, 2, 2 },{ 2, -2, -3 },{ -3, -4, -2 },{ 0, -1, -4 },{ 1, 1, -1 },{ 3, -4, 1 },{ -1, -3, -4 },{ 1, -1, 0 },{ 0, 2, 3 },{ -3, -2, 0 },{ 2, 3, 2 },{ 0, -3, 0 },{ -1, 1, -3 },{ -4, 3, 1 } },
+		{ { -4, -1, -4 },{ 0, -3, 3 },{ -1, 1, -3 },{ 2, -1, -3 },{ -3, 1, 2 },{ 0, -4, -2 },{ -3, -2, -4 },{ -4, 1, 0 },{ 2, 0, -4 },{ 3, -3, 1 },{ -2, 1, -3 },{ -3, 3, 3 },{ 1, 1, -4 },{ 0, -1, -1 },{ -1, -4, 1 },{ 2, 0, -1 },{ -2, 3, 2 },{ 0, -1, 0 },{ -1, -3, -2 },{ -4, 1, -3 },{ 2, -3, 2 },{ -1, 2, -2 },{ -2, -3, -4 },{ 1, 3, -2 },{ -3, -3, 3 },{ -2, -1, -1 },{ 0, -3, -3 },{ -4, -1, 2 },{ -1, 1, 1 },{ 0, -3, -1 },{ 0, -2, -3 },{ -4, 1, 0 },{ -2, -3, 3 },{ 2, 3, -1 },{ -1, 1, 0 },{ 0, -2, -4 },{ 2, -1, 3 },{ 3, -2, 1 },{ 0, 3, 0 },{ 1, 0, -3 },{ -1, -3, 2 },{ 2, 3, -2 },{ -2, -4, 2 },{ -1, 0, 0 },{ -4, -4, -3 },{ 2, -3, 0 },{ -4, -1, -4 },{ -3, -4, -3 },{ 2, 2, -3 },{ -3, -1, 0 },{ -2, 0, -4 },{ -2, 2, 2 },{ -4, -3, 0 },{ -1, 3, 3 },{ -2, -1, 2 },{ -4, 0, -2 },{ 0, 2, 2 },{ -4, 3, -3 },{ -2, 1, -1 },{ 3, -4, -2 },{ 2, 2, 3 },{ 1, -1, -1 },{ -2, -2, -2 },{ 3, 0, 0 } },
+		{ { -2, 0, -2 },{ 3, 2, 1 },{ -3, -2, -1 },{ 1, 2, 1 },{ -1, 3, -4 },{ 2, -3, 0 },{ -2, 2, 1 },{ 1, 2, -1 },{ 0, 0, 2 },{ -1, -3, 2 },{ -4, -2, -2 },{ -2, 0, -1 },{ 3, -3, 2 },{ -4, 2, -3 },{ -2, 3, 3 },{ 1, -1, 0 },{ -4, -3, -3 },{ 3, -4, 3 },{ -2, 3, 2 },{ -3, -2, 1 },{ 1, -4, 3 },{ 2, -1, 0 },{ 3, 0, 0 },{ -3, 2, 2 },{ 0, 1, 1 },{ -4, -2, -2 },{ 2, 0, 0 },{ -1, -2, -4 },{ -3, 3, 3 },{ 3, 0, -4 },{ -2, 2, 1 },{ 2, -4, 0 },{ 3, -1, 2 },{ -3, 2, -3 },{ 3, -4, -1 },{ -3, 3, 1 },{ -4, -3, -3 },{ 0, 1, -1 },{ -2, 1, 3 },{ -4, -3, -2 },{ 2, -2, -4 },{ 1, 1, -1 },{ 3, 0, 3 },{ -3, -2, -2 },{ 2, 2, -1 },{ 1, 1, -1 },{ 3, 1, 3 },{ 0, 0, 2 },{ -1, 3, -1 },{ -4, -1, 3 },{ 2, -4, -4 },{ 0, 3, -1 },{ 1, 0, -1 },{ 3, 2, 1 },{ 2, -2, -4 },{ -3, 1, -3 },{ 3, -2, 0 },{ 2, -4, 2 },{ -1, -1, -4 },{ -3, -3, 1 },{ -4, 1, -4 },{ -2, 0, -3 },{ -3, -2, 1 },{ 2, -4, 2 } },
+		{ { 1, 2, -2 },{ -3, -3, -4 },{ 2, 0, 3 },{ -4, -4, -2 },{ 1, -1, 3 },{ 3, 0, -1 },{ 0, -1, -3 },{ -4, -2, 3 },{ 3, -4, 0 },{ -3, 3, -3 },{ 1, 2, 1 },{ -1, -2, -4 },{ 2, -4, 0 },{ -3, 0, -2 },{ 0, -2, 1 },{ 2, 1, -4 },{ -3, 1, -1 },{ 1, 2, -3 },{ 2, 0, -2 },{ -4, 2, 0 },{ 0, 1, -4 },{ -2, -2, -3 },{ -4, -4, 3 },{ -1, 0, -3 },{ 1, -4, -4 },{ 3, 3, 3 },{ -2, 1, 2 },{ 2, 2, 0 },{ 0, -4, -1 },{ 2, -1, -2 },{ -4, -3, 3 },{ 1, 3, -4 },{ -3, -2, -2 },{ -1, 0, -2 },{ 1, -2, 3 },{ 1, 0, -4 },{ -1, -3, 2 },{ -3, 0, -2 },{ 2, -4, -3 },{ 3, 2, 0 },{ -3, -1, 1 },{ -4, -4, 2 },{ 0, 3, -3 },{ 1, -3, -4 },{ -2, 3, 2 },{ 0, -1, 1 },{ -3, -2, -3 },{ 3, 3, 1 },{ 1, -3, 0 },{ 0, -2, -2 },{ 3, 1, 1 },{ -3, -1, 2 },{ 2, -3, -2 },{ -4, -4, -3 },{ -1, 1, 0 },{ 0, -3, 1 },{ -2, 0, -1 },{ 1, 2, 3 },{ 1, 0, 1 },{ 0, -2, -1 },{ 1, 3, 0 },{ 3, -4, 2 },{ -1, 1, 3 },{ 0, 3, -3 } },
+		{ { -1, -4, 0 },{ 0, -2, 2 },{ -2, 1, -3 },{ -1, 3, 1 },{ -2, -3, 2 },{ -4, 0, -2 },{ -1, 3, 1 },{ 2, -3, -4 },{ -1, 1, -2 },{ 1, -1, -4 },{ -2, -1, 2 },{ 3, 1, -1 },{ 1, 3, 3 },{ -3, -1, 0 },{ 3, 2, -2 },{ -1, -3, 3 },{ -4, -4, 1 },{ 0, -1, -4 },{ -1, -3, 1 },{ 3, 0, -3 },{ -3, -1, -1 },{ 0, 3, 1 },{ 2, 1, -2 },{ -1, 3, -1 },{ 2, -1, 0 },{ -2, -3, -1 },{ -3, 0, -4 },{ 1, -4, -2 },{ -4, 3, 1 },{ -2, 0, -3 },{ 1, 1, 2 },{ -1, 2, -1 },{ 0, -4, 0 },{ -4, -1, 2 },{ -2, 1, 1 },{ 3, 2, 0 },{ -2, 3, 0 },{ 0, -1, -1 },{ 1, -1, 2 },{ -2, 3, 3 },{ -1, 0, -3 },{ -1, 2, -1 },{ 2, -1, 0 },{ -2, -2, 1 },{ -3, 0, 3 },{ -1, -4, -1 },{ -4, -4, -2 },{ -2, 2, -4 },{ -4, -1, 2 },{ -1, -4, -2 },{ -1, 3, -3 },{ -2, 1, 1 },{ 1, -3, 3 },{ 0, -1, -1 },{ -3, 2, 3 },{ 2, -2, -2 },{ -1, -4, -4 },{ -4, 3, -2 },{ -3, 1, -3 },{ -1, -2, 2 },{ -4, 2, -2 },{ -2, -3, -4 },{ 1, -1, 1 },{ -4, 2, -1 } },
+		{ { 3, 3, 3 },{ -4, -1, 0 },{ 3, 1, -1 },{ -3, -3, -4 },{ 3, -2, -1 },{ 1, 2, -3 },{ -3, -4, 0 },{ -2, -2, 2 },{ 2, 2, -1 },{ -3, 3, 3 },{ 0, -4, 1 },{ -4, 0, -1 },{ -1, -4, -3 },{ -2, -2, 2 },{ -1, -3, -4 },{ 1, 3, 2 },{ 3, 2, -1 },{ -2, -2, 3 },{ -2, -2, 0 },{ 1, 3, 2 },{ 3, -3, 3 },{ 1, 1, 1 },{ -3, -2, -4 },{ -4, -3, 2 },{ 3, 2, 1 },{ 1, 2, -3 },{ 0, -2, 2 },{ -1, 2, 1 },{ 3, -2, 3 },{ -1, -3, 0 },{ -3, -1, -3 },{ 3, -2, 1 },{ 2, 3, -1 },{ -4, 0, -3 },{ 1, -3, -4 },{ -3, -2, -2 },{ 2, -4, 3 },{ -4, 2, -4 },{ 3, -2, -3 },{ 0, 1, 1 },{ -3, -3, -2 },{ 1, -4, 2 },{ -4, 3, 0 },{ 3, -3, -2 },{ 2, 1, -4 },{ 3, 2, 0 },{ 1, -3, -3 },{ 0, -2, 3 },{ 2, 1, 0 },{ 3, 2, -4 },{ -4, 0, 3 },{ 0, -2, -1 },{ -2, 3, -4 },{ 3, 0, -3 },{ -1, 2, 0 },{ -4, 3, 2 },{ 3, -1, -1 },{ -2, -3, 3 },{ 2, 0, 1 },{ 3, -4, -3 },{ 2, 3, 3 },{ 0, 0, -2 },{ 3, -1, -1 },{ -3, -2, -3 } },
+		{ { 1, 0, -4 },{ 0, -4, 1 },{ 2, 2, -2 },{ -2, -1, 2 },{ 0, 1, 3 },{ 0, 3, 0 },{ 3, -1, 1 },{ -4, 1, -2 },{ 0, -1, -3 },{ 3, 0, 0 },{ 1, -3, -2 },{ -3, 2, 1 },{ 2, -2, -4 },{ 0, 2, -1 },{ -4, 0, -3 },{ -3, -1, -2 },{ 1, 0, 0 },{ 2, 1, -3 },{ -3, 0, -2 },{ -1, -4, -2 },{ -4, 2, -1 },{ -2, -4, -3 },{ -1, -1, 0 },{ 1, -3, -2 },{ -3, 0, 3 },{ -1, -4, 0 },{ -4, -1, -3 },{ 3, -1, -1 },{ 1, 1, -4 },{ -3, 3, -2 },{ 0, 0, 3 },{ 0, 2, 0 },{ -2, 1, -4 },{ 3, -4, 3 },{ -1, 3, 1 },{ 0, -1, -3 },{ 2, 2, -1 },{ -3, -4, 2 },{ -1, 0, 1 },{ 2, -3, 0 },{ -2, 0, -4 },{ 3, -2, -4 },{ 0, 1, 3 },{ -2, 2, -3 },{ 0, -1, 2 },{ -1, 0, -2 },{ -3, 1, 2 },{ 2, 3, 2 },{ -2, 0, -1 },{ -3, -2, -3 },{ 1, -4, 1 },{ 2, -3, 0 },{ -4, 1, 2 },{ -3, -2, -2 },{ 2, -4, 1 },{ 1, -2, 3 },{ -2, 1, -4 },{ 0, -3, -1 },{ 1, 2, 0 },{ -2, -1, 2 },{ -4, -3, 0 },{ -1, 0, -4 },{ -2, 1, 3 },{ -3, -3, 1 } },
+		{ { 2, 2, -1 },{ -2, -2, 3 },{ -1, 0, -3 },{ 1, -4, 0 },{ -4, -3, -3 },{ -1, 0, -4 },{ 1, -4, 3 },{ -2, -3, -1 },{ -4, 2, 2 },{ 0, -3, -4 },{ -1, -2, 3 },{ -4, 1, -2 },{ 3, 1, 2 },{ 1, 3, 3 },{ 3, -4, 0 },{ 0, -3, 3 },{ -2, 2, 1 },{ -4, -4, -4 },{ 3, 3, 2 },{ 0, -1, 1 },{ -1, 0, -4 },{ 2, 2, 2 },{ 3, 3, 3 },{ 0, 1, -2 },{ -2, 1, -4 },{ 0, 3, 0 },{ 2, -4, 3 },{ -3, 1, -2 },{ 0, 0, 1 },{ -2, -4, -1 },{ 2, -2, -3 },{ -4, -4, 2 },{ -1, -3, -2 },{ 2, -1, 2 },{ -3, 2, 0 },{ -4, 0, 1 },{ 1, -2, -4 },{ -2, 1, 2 },{ -4, 3, -2 },{ -1, 2, -1 },{ -4, -4, 3 },{ 0, 2, 2 },{ -1, -1, -1 },{ -4, -2, 0 },{ -3, -4, 1 },{ 3, -2, 0 },{ -4, 2, -4 },{ -1, -4, 1 },{ 0, -3, -2 },{ 2, 2, 3 },{ -3, 0, -1 },{ 3, 3, -2 },{ 1, -1, -4 },{ 0, 2, -1 },{ -1, -4, 1 },{ 2, -1, -3 },{ -3, 0, -3 },{ -3, 2, 2 },{ -1, -2, -4 },{ 0, 3, -2 },{ 1, 1, -1 },{ -3, -3, 1 },{ 2, 2, 2 },{ 0, -4, -3 } },
+		{ { -1, 3, 0 },{ -3, -1, -2 },{ -4, 2, 2 },{ 3, 3, -1 },{ -3, 1, 1 },{ -2, -2, -2 },{ 2, 2, 2 },{ 1, -1, -3 },{ 3, 1, 0 },{ -2, 3, -1 },{ 2, -4, 1 },{ -1, 0, -3 },{ -2, -1, -1 },{ -2, -3, -2 },{ -3, 0, 1 },{ 2, -2, -4 },{ -1, 1, -1 },{ 3, -1, 2 },{ 0, -2, 0 },{ -3, 1, 3 },{ 2, -3, -3 },{ -4, -2, -1 },{ -3, -4, 1 },{ -2, -1, -4 },{ 3, -2, -3 },{ -4, 3, -1 },{ 2, -3, 2 },{ -2, -1, -4 },{ -4, 3, 2 },{ 1, -3, 3 },{ 3, 2, -3 },{ -2, 1, -4 },{ 1, -1, -1 },{ 0, 3, -2 },{ 3, -2, 2 },{ -2, -4, -3 },{ 0, 1, -1 },{ 3, -3, 3 },{ 2, -1, -3 },{ 1, -2, 0 },{ 3, 1, 1 },{ 1, 0, -3 },{ 2, -3, -2 },{ 1, 3, -2 },{ -1, 1, -4 },{ 1, 3, 3 },{ 0, -3, -3 },{ 3, -1, -2 },{ -4, -1, -1 },{ -1, 3, -4 },{ -1, -1, 1 },{ -2, 1, 2 },{ -1, -3, 3 },{ -2, 1, -2 },{ -4, 3, 0 },{ 0, 0, 3 },{ 2, 3, -2 },{ 3, -4, 1 },{ -4, -1, -1 },{ 3, -2, 3 },{ -2, 2, -3 },{ 3, -4, 0 },{ 1, -2, -2 },{ -4, 1, -1 } },
+		{ { 3, -3, 2 },{ -1, 1, -4 },{ 1, -3, 0 },{ 2, -4, 3 },{ 0, -1, -4 },{ -3, -2, 0 },{ -4, 3, -2 },{ 0, -4, 3 },{ -1, 0, 1 },{ -3, 2, -4 },{ 1, -1, 3 },{ 3, -3, 0 },{ -4, 3, 1 },{ 1, -4, -4 },{ 2, 2, 2 },{ 0, 3, -3 },{ -4, -4, -2 },{ -2, 2, -3 },{ 1, -3, -3 },{ 0, 3, -1 },{ -2, 1, 1 },{ 1, 0, -2 },{ -1, -3, 0 },{ 2, 0, 2 },{ 1, 2, 3 },{ -3, -3, 1 },{ -1, 0, 0 },{ 3, -2, -3 },{ -1, 2, -1 },{ 1, -2, 0 },{ -1, -1, 0 },{ -3, 0, 1 },{ 2, 2, 3 },{ -4, -3, -4 },{ -1, 1, -3 },{ 1, 0, 3 },{ -2, -1, 0 },{ 3, 2, -2 },{ -3, -4, 2 },{ -3, -1, -4 },{ -2, 3, -1 },{ -4, -4, 1 },{ -3, -1, 2 },{ 3, 1, 0 },{ -3, -4, 2 },{ -2, 0, -1 },{ 1, -2, 2 },{ 2, 1, 1 },{ -2, 1, 3 },{ 1, -4, 0 },{ 3, -2, -3 },{ -4, -4, 0 },{ 2, 0, -4 },{ -3, -1, 2 },{ 3, -3, -3 },{ -1, -3, -1 },{ 1, 2, 0 },{ -2, -4, 2 },{ 0, 1, -2 },{ 2, -3, 2 },{ -4, 0, -4 },{ -1, 3, 3 },{ -3, -1, 1 },{ 2, -1, -4 } },
+		{ { 0, 0, 1 },{ -4, -2, 0 },{ -2, 3, -2 },{ 2, -1, -3 },{ 0, 0, -1 },{ 3, 2, 2 },{ 2, -3, -4 },{ -2, 1, -1 },{ 2, -3, -3 },{ -4, -2, -2 },{ -3, 2, 0 },{ 0, 1, -3 },{ 2, 0, 2 },{ -3, 2, -2 },{ -1, -1, -1 },{ 1, -1, 3 },{ -3, 0, 1 },{ 2, -3, 2 },{ -3, 0, 3 },{ -4, -4, 0 },{ 3, -1, -4 },{ 3, 3, 3 },{ 0, -3, 2 },{ -4, 2, -3 },{ -1, -2, -1 },{ 0, -4, -2 },{ 1, 1, -4 },{ 2, -1, 3 },{ -3, 2, -2 },{ -4, -4, -4 },{ 3, 1, 2 },{ -2, 3, -2 },{ -3, -4, 1 },{ 0, -3, 0 },{ 3, 3, -1 },{ -3, -4, -2 },{ -4, 2, 1 },{ -1, 3, -4 },{ 0, 0, 3 },{ 1, 1, -3 },{ -1, -3, 3 },{ 3, 2, -2 },{ -1, -2, -4 },{ 0, -1, 3 },{ 2, 0, -1 },{ -2, -3, -3 },{ -4, 2, -3 },{ -3, 3, 0 },{ 0, -2, -4 },{ -3, 1, 2 },{ -4, 0, -3 },{ 2, 3, -1 },{ 0, -2, -2 },{ 1, 2, 3 },{ 3, 3, -1 },{ -4, -2, -4 },{ -3, 0, 1 },{ 1, -1, -4 },{ -3, 3, -3 },{ -1, -2, 1 },{ 2, -4, -1 },{ 0, 2, -3 },{ -3, -3, -2 },{ 1, 1, 3 } },
+		{ { 2, -4, -3 },{ -2, 2, -1 },{ 3, -4, 2 },{ -3, 2, 2 },{ -2, 1, 1 },{ -4, -3, 3 },{ -1, -1, 0 },{ -3, 2, 2 },{ 0, -1, 1 },{ 3, -4, 2 },{ 1, 3, -1 },{ -2, -2, 3 },{ 3, -3, -4 },{ -1, -4, 0 },{ -4, 1, 2 },{ 3, -2, -1 },{ -2, 3, 0 },{ 0, 1, -4 },{ 2, -1, -1 },{ -2, 2, 2 },{ -1, -2, -2 },{ -3, -2, -3 },{ -3, 3, -1 },{ 1, 1, -4 },{ 3, -1, 0 },{ -2, 2, 1 },{ -4, 3, 3 },{ -2, -4, -1 },{ 1, 0, 2 },{ -2, -3, -1 },{ 0, -2, 3 },{ 1, 0, -3 },{ 1, 2, -2 },{ -2, -1, 3 },{ 2, 0, 2 },{ 1, -2, -1 },{ 0, -1, -4 },{ 2, -3, 1 },{ -4, -2, 0 },{ -2, -3, -1 },{ 2, 0, 1 },{ 0, 1, -4 },{ -4, -3, -1 },{ -2, 2, -3 },{ 1, 3, 1 },{ 3, -2, -2 },{ 0, -1, 3 },{ 2, -3, 1 },{ -1, -4, -1 },{ 1, 2, -2 },{ 0, -1, 1 },{ -2, -3, 3 },{ -3, 2, 0 },{ -1, -4, -2 },{ -2, -4, 1 },{ 2, 1, 2 },{ -1, -1, -2 },{ 0, -2, 3 },{ 2, 2, 0 },{ -2, 1, -2 },{ 3, 1, 3 },{ 0, -1, 0 },{ -2, 3, -1 },{ -2, -2, 2 } },
+		{ { -4, 3, 0 },{ 1, 1, 3 },{ -1, -1, -4 },{ 0, -3, -3 },{ -1, 0, -1 },{ 1, -4, -3 },{ 1, 3, -2 },{ 3, 1, -4 },{ -3, 0, -3 },{ -1, 3, 0 },{ 0, 0, -4 },{ -4, -4, -2 },{ -2, -1, 2 },{ 0, 1, 1 },{ 2, -3, -3 },{ 0, 2, -3 },{ -4, -3, 1 },{ 3, 3, -2 },{ -1, -2, -3 },{ 1, -4, 0 },{ 1, 1, 1 },{ 0, 0, -2 },{ 2, -4, 1 },{ -2, 0, 3 },{ 2, -4, -2 },{ -4, -2, -4 },{ 3, 1, 1 },{ 0, 1, -3 },{ 2, -3, 1 },{ 0, 3, 0 },{ -4, 0, -3 },{ 2, -2, 1 },{ 3, -4, -1 },{ -1, 1, -4 },{ -3, 3, -3 },{ -4, -3, 2 },{ -1, 2, 3 },{ 3, 0, -2 },{ -2, 3, -3 },{ 2, -2, 2 },{ -3, 2, 0 },{ -4, 3, 0 },{ 1, 0, 2 },{ 2, -3, 1 },{ -3, 2, 0 },{ -1, -4, 3 },{ -4, 1, -4 },{ -1, 0, -3 },{ 3, -3, -1 },{ -3, 0, 3 },{ 3, 2, 0 },{ 1, 1, -4 },{ 3, 0, 1 },{ -4, -1, -4 },{ 1, 0, -3 },{ 0, 3, 3 },{ 3, -3, -1 },{ -4, 1, 0 },{ -1, -4, -3 },{ 1, -3, -1 },{ -4, 0, 1 },{ 1, -4, 2 },{ -1, 0, -3 },{ 3, -3, -4 } },
+		{ { 0, 0, -2 },{ 3, -2, -1 },{ -3, 1, 1 },{ 2, -2, -2 },{ 0, 3, 0 },{ -4, 0, 2 },{ -2, -2, 1 },{ 2, -4, -2 },{ -2, -3, 0 },{ -1, -2, 3 },{ 2, -1, 1 },{ -3, 2, -1 },{ 3, 2, -2 },{ -3, 3, 3 },{ 1, -1, -4 },{ -2, -2, -1 },{ 2, -4, 3 },{ -1, 0, 1 },{ -3, -2, -4 },{ -4, 2, 3 },{ 3, -3, -1 },{ -4, 1, 0 },{ -3, -1, 2 },{ -1, -3, -1 },{ 0, 3, 2 },{ -1, -2, 0 },{ 1, -3, -3 },{ -3, -1, -2 },{ -1, -1, 2 },{ 3, 2, -4 },{ -3, 1, -2 },{ -1, -3, 3 },{ -3, 3, -1 },{ -4, -2, 2 },{ 0, 0, 0 },{ 3, -4, -3 },{ 1, 1, 0 },{ 0, -4, 2 },{ -3, -1, -2 },{ 0, 2, 3 },{ 3, -4, -4 },{ -1, -2, -2 },{ 2, -4, 3 },{ -1, -1, -2 },{ -3, -2, -4 },{ 3, 2, -1 },{ 1, -1, 2 },{ -2, 3, 2 },{ -4, -1, 0 },{ 0, 3, -4 },{ -2, -4, -2 },{ -4, -2, 2 },{ -1, -2, -2 },{ 0, 3, 2 },{ -3, 1, 0 },{ -3, -3, -1 },{ 1, 2, -4 },{ -2, 0, 2 },{ -4, 3, 2 },{ 0, -1, -4 },{ -3, -2, -4 },{ 3, 2, 3 },{ -4, 1, -1 },{ -3, -1, 1 } },
+		{ { 2, 2, -4 },{ -2, -4, 2 },{ -4, 3, -2 },{ 1, -3, 3 },{ 3, -4, 0 },{ -3, 1, -4 },{ 3, 3, 3 },{ 0, -1, -1 },{ -4, 1, 3 },{ 1, 1, -3 },{ -2, -2, -4 },{ 2, -3, 1 },{ 1, 0, -3 },{ -1, -2, 2 },{ -3, 0, 0 },{ 0, 1, -2 },{ -4, 2, 2 },{ 1, 0, 2 },{ -2, 2, 0 },{ 0, -1, -3 },{ 2, 3, 3 },{ -1, -1, -4 },{ 1, 3, -3 },{ 3, 2, -4 },{ -3, 0, -1 },{ -2, 2, 2 },{ 1, 0, 3 },{ -4, 3, -4 },{ -2, -4, 3 },{ -3, 2, -1 },{ 2, -4, 0 },{ -2, -1, 2 },{ 1, 1, -4 },{ 0, -3, 0 },{ 2, -1, -2 },{ -2, -1, 1 },{ -3, 3, -3 },{ -4, -2, -1 },{ 1, 0, -4 },{ -1, -3, 1 },{ -4, 1, -3 },{ -2, -1, -1 },{ 0, 3, -3 },{ 3, 1, 2 },{ -4, 1, 1 },{ 1, 0, -2 },{ -2, -4, -2 },{ 0, -2, 0 },{ 2, 1, -3 },{ 1, -2, 3 },{ -2, -4, 1 },{ 2, 3, -3 },{ 3, -3, -1 },{ -1, 0, -1 },{ -2, -4, 2 },{ 2, -2, -3 },{ -2, 0, -2 },{ 2, -4, 3 },{ 3, -1, 1 },{ 2, 2, 0 },{ -2, -3, -2 },{ -1, 3, -2 },{ 2, -4, 0 },{ 0, -3, 3 } },
+		{ { -2, 3, -3 },{ 3, -3, 0 },{ 0, 0, -3 },{ -3, 2, 1 },{ -2, -1, -4 },{ 1, -1, 2 },{ -1, 2, -2 },{ -3, -3, -3 },{ 0, 2, 0 },{ 3, 3, 2 },{ -4, -4, -2 },{ -3, 1, 0 },{ 0, -1, 2 },{ 3, -4, -2 },{ -2, -3, 0 },{ 3, 3, 1 },{ 2, -4, -4 },{ 0, -1, -3 },{ 3, -3, -1 },{ -3, -2, -2 },{ -2, -4, 2 },{ 0, 1, 0 },{ 2, -3, -2 },{ -4, -4, 1 },{ 3, 1, 3 },{ 0, -4, -3 },{ 2, -3, 0 },{ 0, 2, -1 },{ 3, -2, 1 },{ 1, 0, -2 },{ 0, -2, -4 },{ 3, 0, 3 },{ -4, 3, -3 },{ -1, 2, 1 },{ -2, 1, 3 },{ 1, 2, -4 },{ -1, -3, 3 },{ 3, 3, 1 },{ 0, 1, -1 },{ 2, -4, 2 },{ 1, 3, 1 },{ -2, -1, 3 },{ 0, 0, -1 },{ 2, -4, -4 },{ -4, -3, 0 },{ -1, 2, 2 },{ 2, 3, -3 },{ 0, -4, 1 },{ -3, 0, -4 },{ 2, 2, -1 },{ -4, 0, 2 },{ 0, 1, 0 },{ -3, -1, 3 },{ 2, 2, -4 },{ 3, 2, 3 },{ 1, -1, 1 },{ -4, -2, 0 },{ 0, 3, -3 },{ -3, -2, -2 },{ -1, 1, -1 },{ 0, 1, 3 },{ 1, -2, -3 },{ -2, 0, 0 },{ 1, 1, 2 } },
+		{ { -4, -2, -4 },{ -1, -1, 2 },{ -3, 1, -1 },{ -1, -2, 3 },{ 2, 1, -3 },{ -4, -3, -2 },{ 1, -2, 0 },{ -1, -4, 1 },{ 2, 0, -4 },{ -2, -2, 2 },{ 2, -1, -3 },{ -1, 3, 3 },{ -4, 2, -1 },{ 1, 1, -4 },{ -4, 2, 3 },{ -1, 0, -3 },{ -3, -2, -1 },{ 1, -3, 0 },{ -3, 3, 3 },{ 2, 1, 1 },{ -1, 0, -4 },{ 3, 2, -1 },{ -3, -2, 3 },{ -2, -1, 0 },{ -1, -2, -4 },{ -3, 3, -2 },{ 2, -1, 1 },{ -2, 1, -1 },{ -4, -3, -3 },{ 1, 3, 2 },{ -1, 1, -2 },{ -3, -1, 0 },{ 2, -3, -1 },{ 3, -4, -2 },{ -4, -2, 1 },{ 2, -4, -1 },{ -3, -3, -3 },{ 2, -1, 0 },{ -2, 0, -2 },{ -4, 2, 0 },{ 3, -3, -4 },{ -3, -2, -2 },{ -3, 2, 1 },{ 1, 3, 0 },{ -2, -2, 3 },{ 3, -1, -3 },{ -3, -3, 3 },{ -4, 1, -1 },{ -1, -2, 2 },{ 3, -1, 3 },{ -1, -3, -2 },{ -3, 3, -4 },{ 1, 1, 0 },{ -2, -4, -2 },{ -4, -3, 1 },{ 0, 3, -2 },{ -1, 1, -1 },{ 3, -4, -4 },{ -3, -3, 3 },{ 2, 3, 2 },{ -4, -4, 1 },{ -4, 0, -4 },{ 3, 2, 2 },{ -3, -2, -1 } },
+		{ { 2, -1, 1 },{ 1, 0, 1 },{ 3, 3, -2 },{ 2, -4, -1 },{ 0, 0, 0 },{ -2, 3, 1 },{ 3, 0, 2 },{ -4, 2, 3 },{ 0, 0, -1 },{ -3, -3, -1 },{ 1, 1, 0 },{ -1, -3, -4 },{ 2, 0, 1 },{ -2, -4, -2 },{ 2, -1, 1 },{ 0, -2, 3 },{ -1, 3, -2 },{ -4, 2, -4 },{ -1, 1, 0 },{ 1, -1, 2 },{ -4, -4, -2 },{ 0, -3, 1 },{ -2, 2, 2 },{ 1, 0, -3 },{ 1, 3, 0 },{ -4, -1, 2 },{ 0, 1, -4 },{ -3, -3, 3 },{ 3, 0, 0 },{ -2, 2, -3 },{ -4, -3, 3 },{ -2, -4, 1 },{ 0, -1, -3 },{ -1, 1, 2 },{ -3, 0, -4 },{ 0, 3, -1 },{ 1, 1, 2 },{ -1, -1, 2 },{ -3, -4, -4 },{ 0, -2, 3 },{ 1, 2, 0 },{ -1, 0, -2 },{ 2, -3, 2 },{ 1, -4, -2 },{ -1, 1, -4 },{ 0, 0, 1 },{ 2, 3, -1 },{ 3, -3, -2 },{ -2, 2, 0 },{ 1, 2, -4 },{ -2, -4, -1 },{ 3, 0, 1 },{ 0, -2, 2 },{ -4, -1, -3 },{ -1, 3, -4 },{ 2, -3, 2 },{ 1, 0, 0 },{ -4, 2, 1 },{ 1, 0, -4 },{ 3, -1, -2 },{ -2, -3, -3 },{ 0, -1, -1 },{ 2, -4, 0 },{ -1, 3, -2 } },
+		{ { -2, 1, -1 },{ -3, -4, 3 },{ 1, -2, -4 },{ -4, -3, -4 },{ -2, 2, 2 },{ 0, -4, -2 },{ -3, -1, -3 },{ 1, 3, -4 },{ 2, -2, -2 },{ -4, 1, 1 },{ 3, 2, -3 },{ 0, -2, 3 },{ -3, -2, 0 },{ 1, 3, -1 },{ 0, -3, 2 },{ -3, 1, -3 },{ 2, -2, 1 },{ 3, 0, 2 },{ -2, -4, -3 },{ 1, -2, -4 },{ -3, 3, 3 },{ 3, 1, -3 },{ 0, 0, -4 },{ 2, -4, -1 },{ -4, 2, 2 },{ 3, -4, 1 },{ -2, 0, -2 },{ 1, -4, -3 },{ 2, -2, 2 },{ -1, -1, 0 },{ 2, 2, -2 },{ 2, 3, -4 },{ 1, 2, 2 },{ -2, -1, 3 },{ 3, 2, 0 },{ -2, -2, -2 },{ 3, -2, 3 },{ -1, 3, -3 },{ -4, 1, -2 },{ 3, -3, -3 },{ -1, -1, 2 },{ -4, 3, -4 },{ -2, 0, 1 },{ 3, -1, 0 },{ -3, 1, -3 },{ -4, -4, 2 },{ 1, -1, -4 },{ 0, 1, 2 },{ -4, -4, -3 },{ 1, 0, 1 },{ -4, 1, -3 },{ 2, -2, 3 },{ -2, -3, -2 },{ 2, 2, 1 },{ -3, 1, -1 },{ 0, -4, 3 },{ -2, -1, -3 },{ -2, -2, 3 },{ -1, 2, -1 },{ 0, 1, 0 },{ -1, 3, 0 },{ 3, 1, 3 },{ -3, 2, 1 },{ 0, -3, -4 } },
+		{ { 3, 0, -3 },{ 0, 3, 0 },{ -1, 2, 2 },{ -3, -1, 1 },{ 3, 1, 3 },{ 2, -2, -1 },{ -1, 1, 0 },{ 0, -3, 1 },{ -2, -4, 2 },{ -1, -1, 3 },{ -2, 3, -2 },{ 0, -4, -2 },{ 3, 2, 1 },{ -4, -1, -4 },{ -2, 0, -3 },{ 1, 2, 0 },{ 0, -4, -2 },{ -3, 0, 3 },{ 2, 2, -1 },{ -2, -2, -1 },{ -4, 2, -2 },{ 1, -1, 0 },{ -3, -3, 1 },{ -1, -2, -1 },{ 2, -1, -3 },{ 0, -3, 3 },{ -1, 3, -1 },{ -1, 2, 1 },{ -3, 3, -1 },{ 0, -2, -4 },{ 0, -4, 1 },{ -4, 1, 0 },{ 3, -2, -1 },{ -4, -3, -2 },{ 1, -3, -4 },{ 0, 0, 0 },{ -4, -4, -1 },{ 2, 1, 1 },{ 1, 0, 2 },{ 0, 3, -1 },{ -2, -4, 1 },{ 3, 1, -1 },{ 0, -4, -3 },{ -4, 3, 3 },{ 0, -2, -1 },{ 2, 2, 1 },{ -2, 3, -2 },{ -3, -2, 0 },{ 3, -2, 3 },{ -1, 3, 0 },{ -3, -3, -2 },{ 0, 3, -4 },{ 3, 2, 3 },{ -1, -2, -1 },{ 1, 0, 2 },{ 3, 1, -4 },{ -3, -2, -2 },{ 2, 3, -1 },{ 2, -4, 1 },{ -4, -3, -4 },{ -3, -1, 3 },{ 1, -4, -2 },{ -1, 0, -3 },{ -4, -3, 3 } },
+		{ { -2, 1, 2 },{ -4, -3, -2 },{ 2, -1, -3 },{ 0, 3, -2 },{ -1, 0, -1 },{ -4, -3, -4 },{ 1, -1, 3 },{ -3, 3, -1 },{ 3, 1, -3 },{ 2, -3, -1 },{ -4, -1, 0 },{ 2, 0, 2 },{ -3, 1, -3 },{ -1, 3, 3 },{ 3, -4, 2 },{ -4, -1, -1 },{ -2, -3, -4 },{ -1, 3, 0 },{ 0, -3, 1 },{ 3, 0, 2 },{ 2, -4, 3 },{ -1, 0, 0 },{ -2, 1, 3 },{ 2, 3, -2 },{ -3, 1, 1 },{ -2, 2, -4 },{ 3, -2, -2 },{ -4, 1, 3 },{ -3, -4, -4 },{ 3, 0, -1 },{ -2, 1, 3 },{ -3, -1, -2 },{ -1, 0, 2 },{ -3, 3, -3 },{ 2, -4, 2 },{ -2, 1, 1 },{ 0, 2, -2 },{ -3, -3, -4 },{ -2, -3, 3 },{ 2, 2, 0 },{ -4, -2, -2 },{ 1, -1, 3 },{ 2, 2, -3 },{ -1, 0, -2 },{ -2, -3, 2 },{ 3, -1, -4 },{ -1, -4, 3 },{ -3, 0, -1 },{ 2, 2, -4 },{ -2, -1, 2 },{ -1, -1, 1 },{ 1, 1, -1 },{ -4, -4, 0 },{ 0, 0, -3 },{ -4, -3, -2 },{ -1, 3, 0 },{ -2, -4, 1 },{ 1, 0, -3 },{ -1, -1, 2 },{ 3, 1, -2 },{ 2, -2, -4 },{ -2, 3, 2 },{ 1, -2, -1 },{ 3, -1, 1 } },
+		{ { -3, 2, -1 },{ -1, -2, 0 },{ 3, -4, 3 },{ -3, 1, -3 },{ 1, -2, 0 },{ 3, 2, 1 },{ -2, -4, -3 },{ -1, 1, -2 },{ 2, -1, 2 },{ -4, 2, -4 },{ 0, 3, -4 },{ -2, -3, 2 },{ 1, -4, -1 },{ -1, -2, -2 },{ 2, -2, 1 },{ 1, 3, -1 },{ 3, 1, 2 },{ 1, -1, -4 },{ -3, 1, -3 },{ -4, -1, -2 },{ 0, -3, -4 },{ -2, 2, -4 },{ 3, -2, 2 },{ 0, 3, -3 },{ -4, -2, 3 },{ 0, -4, -2 },{ 1, -1, 0 },{ 2, -1, 1 },{ 0, 0, 0 },{ 1, -3, 2 },{ 2, 2, -3 },{ -2, -3, 1 },{ 0, -4, -4 },{ 2, 2, 1 },{ -1, 3, -1 },{ -4, -1, -4 },{ 1, -1, 3 },{ 2, 3, 0 },{ -1, -2, -3 },{ 3, 0, -4 },{ -3, 2, -1 },{ 1, -3, 1 },{ -2, -2, 2 },{ -3, 1, 0 },{ 1, -1, 0 },{ 2, 2, -1 },{ -4, 3, 1 },{ 1, -3, -2 },{ 2, 1, 0 },{ 0, -4, -3 },{ 3, 2, -4 },{ -3, -3, 2 },{ -1, -1, -3 },{ -2, 3, 1 },{ 1, -2, 3 },{ 3, 2, -4 },{ -3, -1, 2 },{ 0, 1, -2 },{ -4, 3, 3 },{ -2, -3, 0 },{ 0, 0, -1 },{ -4, 1, 1 },{ -1, -4, -2 },{ 2, 3, -4 } },
+		{ { 1, -1, -2 },{ 2, -3, -4 },{ 1, 0, 2 },{ -2, 0, -1 },{ -2, -4, 3 },{ 0, 3, -2 },{ -4, -2, 2 },{ 0, 0, 3 },{ -2, -2, 1 },{ 1, -4, -1 },{ -1, -2, 3 },{ -3, 1, -2 },{ 2, -1, 0 },{ -4, 0, -3 },{ -3, 2, -4 },{ -2, 0, 1 },{ -1, -3, -3 },{ -4, -2, 3 },{ -2, 3, -1 },{ 1, -4, 2 },{ 2, 3, -2 },{ -1, -1, -1 },{ -4, -3, 1 },{ 1, -4, -1 },{ 2, 0, 0 },{ -1, -3, 2 },{ -3, 3, -4 },{ -2, -3, -3 },{ -4, 2, -2 },{ -1, -2, 2 },{ -3, 3, -2 },{ 1, -1, 0 },{ 3, 1, 3 },{ -1, -2, -2 },{ 3, -2, 0 },{ -3, 1, 3 },{ 3, -3, -3 },{ -2, 0, -1 },{ -4, -4, 1 },{ 0, -1, 2 },{ -1, 3, -4 },{ -4, 0, 2 },{ 3, 3, -2 },{ 0, -4, -4 },{ -4, -2, -3 },{ 0, -4, 3 },{ -1, 0, -4 },{ -2, -2, -3 },{ -4, 2, 1 },{ 0, 0, 3 },{ -3, -3, -1 },{ 1, 3, -2 },{ 3, 0, 1 },{ 2, -4, 2 },{ -3, 1, -1 },{ 2, -3, -2 },{ -4, -3, 0 },{ 3, 0, 1 },{ 1, 2, -4 },{ -3, -4, -1 },{ 0, -1, 2 },{ 3, 2, -3 },{ 0, -2, 3 },{ -4, 1, 1 } },
+		{ { -1, 0, 3 },{ -2, 2, 1 },{ -4, 3, 2 },{ -1, -1, -4 },{ -3, 2, -2 },{ 3, -2, 0 },{ 2, 2, -4 },{ -1, -3, 0 },{ -3, 3, -3 },{ 3, 2, 0 },{ 0, 0, 1 },{ 3, 2, -1 },{ -2, -4, 3 },{ 3, 1, 2 },{ 0, -3, 0 },{ -1, 2, 3 },{ 1, -4, -2 },{ 2, 0, 1 },{ 3, 1, 0 },{ -2, -2, 1 },{ 2, 1, 2 },{ -3, -1, 0 },{ 1, 2, -4 },{ 3, 1, -2 },{ -3, 2, -3 },{ -1, 0, -1 },{ 3, 1, 2 },{ 2, 3, 3 },{ 1, -2, -1 },{ -1, -4, -4 },{ 3, 1, 3 },{ -4, -4, -1 },{ -4, 2, -4 },{ 1, -1, 2 },{ -3, 0, -1 },{ -1, 0, -2 },{ 0, -4, 1 },{ -2, 2, -1 },{ 1, 1, 2 },{ 3, -3, -2 },{ -2, 1, 3 },{ 2, -4, 0 },{ -1, -2, -1 },{ 2, 1, 3 },{ -3, 3, 1 },{ 1, 1, -1 },{ 3, -1, 2 },{ -3, 1, 2 },{ 1, -4, 0 },{ -1, -1, 1 },{ -4, -2, 3 },{ -2, 1, -4 },{ 0, -2, 0 },{ -3, -1, -3 },{ -1, 1, -4 },{ 0, 2, 0 },{ -2, -1, 3 },{ 1, -2, -3 },{ -1, -4, -1 },{ 2, 2, 2 },{ -3, 3, -3 },{ -2, 0, -2 },{ 2, -3, 0 },{ -3, -4, 0 } },
+		{ { 3, 2, -4 },{ 0, -2, -1 },{ 2, -3, -2 },{ 3, 1, -3 },{ 1, -3, 2 },{ 1, 0, 1 },{ -4, -1, -3 },{ 3, 1, -1 },{ 1, -3, -2 },{ -3, -1, 2 },{ -4, -2, -4 },{ 1, -3, -3 },{ -3, 3, -4 },{ 0, 1, 1 },{ 1, -2, -3 },{ -4, -1, 0 },{ 3, 3, -2 },{ -3, -3, -4 },{ 0, 2, 3 },{ -4, 0, -3 },{ 0, -4, -2 },{ -3, 2, 3 },{ -1, -2, 2 },{ -2, -2, 2 },{ 0, -3, -4 },{ -2, -1, 1 },{ 0, -4, 1 },{ -4, 1, -1 },{ -3, -1, -3 },{ 0, 0, 1 },{ 2, 2, -3 },{ 0, -1, 1 },{ -2, -3, -3 },{ 1, 3, 0 },{ -2, -4, 2 },{ 2, 2, -4 },{ 2, 3, 1 },{ -4, -2, -3 },{ 1, -1, 0 },{ -3, 3, -3 },{ -3, -2, 0 },{ 0, -1, -3 },{ -4, 2, -2 },{ 3, 0, -1 },{ -2, -3, 1 },{ 0, 2, -3 },{ 2, -3, -2 },{ -1, 3, -1 },{ 3, -2, -4 },{ 1, 3, -3 },{ 2, 2, -2 },{ 3, 0, -1 },{ 1, -3, 2 },{ -4, 3, 3 },{ 1, -1, 1 },{ -2, -4, -2 },{ -4, 3, 2 },{ 3, 1, -4 },{ -1, -3, 1 },{ -4, -1, 3 },{ 1, -2, 0 },{ -2, -3, -4 },{ 2, 2, 2 },{ -4, -1, -3 } },
+		{ { 0, -1, -1 },{ -3, -4, 3 },{ -4, -2, 1 },{ 0, 3, 0 },{ -1, -4, -1 },{ -3, 2, 3 },{ -2, -4, 1 },{ 0, 0, -4 },{ -2, 1, 3 },{ 0, -4, 2 },{ 2, 0, 0 },{ -1, -1, -1 },{ -2, -2, 3 },{ 3, -4, -2 },{ -1, -1, -1 },{ -2, 3, 2 },{ 0, 1, -4 },{ -3, -1, 0 },{ -1, -4, -1 },{ 1, -2, -3 },{ 3, 3, -4 },{ 2, -3, -1 },{ -1, 0, -3 },{ -4, 3, 0 },{ 2, -1, 3 },{ 1, 2, -2 },{ 3, -4, -2 },{ 1, 2, -3 },{ 3, -2, 2 },{ -2, -3, 0 },{ -3, 3, 2 },{ 2, 0, -2 },{ 0, -2, 3 },{ 3, 1, -1 },{ -1, -3, -3 },{ -4, -2, 1 },{ -2, 1, 3 },{ 3, -4, -2 },{ -1, -1, 2 },{ 2, 2, -4 },{ -1, 1, 1 },{ 1, -4, 3 },{ 1, 3, 2 },{ -1, -3, -4 },{ -3, -2, 3 },{ -2, -1, -3 },{ -4, -4, 0 },{ -2, -1, 3 },{ -4, 1, -2 },{ 0, 0, 2 },{ -2, -4, 1 },{ -1, -4, 0 },{ -3, 1, -4 },{ 2, 2, -2 },{ 3, -3, -3 },{ 2, 2, 0 },{ 0, 0, -1 },{ -3, -2, -2 },{ 2, 3, -4 },{ 0, 0, 0 },{ 3, 1, -2 },{ 1, -2, 3 },{ -1, 1, -1 },{ 1, 3, 1 } },
+		{ { 3, 0, 2 },{ 1, 1, 0 },{ -3, 2, -3 },{ -2, -1, -4 },{ 2, 1, 3 },{ -4, -1, -3 },{ 2, -3, 0 },{ 1, 3, -2 },{ -3, -2, 1 },{ 3, 3, -4 },{ -4, 1, -2 },{ -2, 3, 2 },{ 2, 2, 0 },{ -3, 2, -4 },{ -4, -2, 1 },{ 2, -4, -3 },{ 0, -3, 3 },{ 2, 0, 2 },{ 3, 2, 1 },{ -2, -3, 2 },{ -4, 1, 1 },{ 0, -1, 1 },{ 3, 0, -1 },{ 2, -4, -3 },{ -3, 2, 1 },{ -4, -2, -4 },{ -2, 0, 3 },{ -1, 3, 0 },{ -4, -3, 1 },{ -1, 2, -4 },{ 1, 0, -1 },{ -3, -4, 0 },{ -1, 2, -4 },{ -3, 3, 0 },{ 1, -4, 2 },{ 3, 3, -2 },{ 0, -1, -4 },{ -3, 0, 0 },{ 0, -3, 3 },{ -4, -4, -2 },{ 3, 0, -1 },{ -2, -2, -4 },{ -3, 1, 0 },{ 3, -1, 1 },{ 2, 0, 0 },{ 0, 3, -2 },{ 3, 2, 2 },{ 2, 0, -4 },{ -1, -2, 1 },{ -3, -3, -3 },{ 3, -1, 0 },{ -4, 3, 3 },{ 0, 0, -2 },{ -1, -2, 1 },{ -4, -4, -1 },{ -2, 0, 3 },{ 0, -3, 1 },{ -1, -1, 3 },{ -2, 2, -1 },{ -4, -3, 2 },{ -3, -4, -3 },{ -1, 2, 1 },{ -4, 0, -4 },{ -2, -3, -2 } },
+		{ { -1, 3, -4 },{ -2, -4, -2 },{ 3, 0, 2 },{ 1, -3, 1 },{ -2, -2, -2 },{ 3, 3, -2 },{ -1, 1, -1 },{ 1, 2, 2 },{ -4, -3, -3 },{ 2, 0, -1 },{ -1, -4, 1 },{ 3, -2, -3 },{ 1, -3, 3 },{ 0, 0, -2 },{ 1, 0, 0 },{ 3, 1, 1 },{ -2, 3, -3 },{ -1, -2, -2 },{ -4, 1, -1 },{ 1, 0, -2 },{ -2, 3, 3 },{ -3, -2, -4 },{ -1, -4, 2 },{ 1, 1, 3 },{ 0, 1, -1 },{ 3, -3, 0 },{ -3, -1, 2 },{ 0, 0, -4 },{ 2, -2, -1 },{ 3, 1, -2 },{ -2, -2, 3 },{ -4, -1, -3 },{ 2, 1, 1 },{ 2, 0, 3 },{ -4, -1, -3 },{ -2, 1, -1 },{ -3, -2, 3 },{ 2, 2, -1 },{ 1, 3, 1 },{ -2, 1, -3 },{ 2, -1, 0 },{ -4, -3, 2 },{ 0, 0, -2 },{ -2, 3, -3 },{ -4, -4, 3 },{ 1, 1, -4 },{ 1, -2, 1 },{ -2, -4, -1 },{ 1, 3, 3 },{ -1, 2, -2 },{ 1, -1, -4 },{ 2, 1, 2 },{ -2, -2, -3 },{ 1, -1, 0 },{ -2, 2, 2 },{ 1, 1, -4 },{ -4, -1, -3 },{ 3, 3, 1 },{ 2, -4, -3 },{ 2, 0, 3 },{ 0, -1, -1 },{ 3, 3, 2 },{ -3, -4, -1 },{ 2, -2, 3 } },
+		{ { 0, 2, 0 },{ -1, -1, -3 },{ 2, -3, -1 },{ -3, 2, 2 },{ 0, 0, -4 },{ 0, -4, 3 },{ -3, -1, 1 },{ -2, -2, -3 },{ 3, -4, 3 },{ -1, 2, 0 },{ -2, 1, -2 },{ -4, -3, 3 },{ 0, -1, -3 },{ -3, 3, -1 },{ -2, -4, 2 },{ -4, -3, -1 },{ 1, -2, -4 },{ -3, 2, 3 },{ 2, -4, -4 },{ -1, -4, -3 },{ 0, -1, 0 },{ 3, 2, -2 },{ -4, 3, 0 },{ -2, -2, -4 },{ 1, -4, -2 },{ -1, 3, 1 },{ 2, 1, -3 },{ -2, -3, -2 },{ 0, -4, 3 },{ -4, 2, 1 },{ 1, -1, 2 },{ 3, -4, -4 },{ 0, -3, -1 },{ -2, -2, -2 },{ 0, 0, 2 },{ 1, -3, -3 },{ -1, -4, 1 },{ 1, 1, -3 },{ -4, -2, -4 },{ -1, -3, 2 },{ 1, 2, -2 },{ -1, 3, 3 },{ 2, 2, -3 },{ 1, -3, -1 },{ 0, 1, 2 },{ -1, -2, -1 },{ -3, -3, 2 },{ -3, 1, -3 },{ 3, -1, 1 },{ -4, -4, 0 },{ -2, 1, -1 },{ 0, -3, -3 },{ -4, 3, 3 },{ 2, -4, -1 },{ 3, 1, -4 },{ 0, 3, -2 },{ -3, -2, -1 },{ 1, -4, 0 },{ -3, 1, -4 },{ -1, 2, -2 },{ -2, -3, -4 },{ 1, -1, 0 },{ 1, 1, -3 },{ -4, -3, 3 } },
+		{ { -3, 1, 1 },{ 1, 0, 0 },{ -4, -4, 3 },{ -1, 3, 0 },{ -4, 2, 0 },{ 2, -3, -1 },{ 2, 1, -4 },{ -1, 0, 2 },{ 0, 3, -2 },{ 1, 0, 2 },{ -3, -1, -4 },{ 1, 3, 0 },{ 2, 1, 1 },{ 3, -2, 0 },{ -1, 2, -4 },{ -1, 0, 3 },{ 2, -1, 1 },{ 0, 1, -1 },{ 3, 3, 2 },{ -3, 1, 0 },{ 1, -2, -1 },{ 2, 0, 2 },{ -2, -3, 3 },{ 0, 0, -3 },{ 3, -1, -1 },{ -4, -3, 2 },{ -1, 2, -4 },{ 2, 0, 0 },{ -3, 3, -3 },{ 0, -2, -2 },{ -2, 2, 0 },{ -3, 3, -1 },{ -1, 2, 2 },{ -4, -3, -4 },{ 3, 3, 1 },{ 2, 2, 0 },{ -4, 0, 0 },{ -1, 3, -2 },{ 3, -1, 3 },{ 0, -4, 0 },{ -3, 1, -4 },{ 3, -4, -1 },{ -3, -2, 1 },{ -2, -1, 0 },{ 3, -4, -4 },{ -4, -1, -2 },{ 2, 3, 0 },{ -2, 0, -3 },{ 0, 2, -4 },{ 2, -2, 3 },{ -3, 3, 1 },{ 3, 0, 2 },{ -1, -2, -2 },{ -3, 0, 0 },{ -3, -3, 2 },{ -1, -3, 1 },{ 3, 1, 3 },{ -1, -2, 2 },{ -2, 0, 1 },{ 1, -2, 3 },{ -4, 3, 0 },{ -3, 1, 2 },{ -1, 0, -3 },{ 3, -2, -2 } },
+		{ { -4, 3, -2 },{ 3, -2, -4 },{ 1, -2, -2 },{ -2, 1, -3 },{ 3, -1, -3 },{ -1, -2, 2 },{ -3, 3, -1 },{ -4, -3, 0 },{ 2, -4, -4 },{ -3, -1, 0 },{ 3, -2, 2 },{ -1, -3, -2 },{ -4, 2, -4 },{ -3, -1, 2 },{ 1, -4, -3 },{ 3, 3, -2 },{ -4, -3, 0 },{ -1, -3, 1 },{ -3, -1, -3 },{ 1, 0, 2 },{ -1, -4, -4 },{ -3, 2, 1 },{ -4, -3, -2 },{ 3, 3, 1 },{ -3, 1, 1 },{ -4, -1, 3 },{ 1, -2, 0 },{ 3, 0, 2 },{ -4, -4, 3 },{ -1, -1, -4 },{ 2, 1, 2 },{ 1, 0, -3 },{ 2, -4, 3 },{ 0, -1, -1 },{ -3, 1, 3 },{ -2, -2, -4 },{ 3, -3, 2 },{ -3, -1, -3 },{ -2, -3, -1 },{ 2, 3, 1 },{ -4, 0, 2 },{ -1, -2, -1 },{ 0, 0, -3 },{ 3, 2, 3 },{ -3, 3, 1 },{ 1, 0, 3 },{ 0, 2, 1 },{ -1, -4, -1 },{ 3, 0, 2 },{ 1, -3, -2 },{ -3, -4, -1 },{ -1, 1, -4 },{ 3, 2, 1 },{ 0, -4, 0 },{ 2, 2, -3 },{ 0, -1, -2 },{ -4, 0, -1 },{ 2, 3, -3 },{ 0, -3, -1 },{ 2, -1, -2 },{ 3, -2, 1 },{ 0, -4, -4 },{ 2, 3, -1 },{ -2, -1, 2 } },
+		{ { -1, -1, 3 },{ 2, -4, 1 },{ 0, 0, 2 },{ -3, 3, -4 },{ 1, -4, 3 },{ -2, -1, 1 },{ 1, 2, -3 },{ 3, -2, 1 },{ -2, 1, -3 },{ 0, 3, 3 },{ -4, 2, -2 },{ 2, 0, -1 },{ -1, -4, 3 },{ 0, 1, 1 },{ 0, -1, -2 },{ -3, 0, 2 },{ -2, 1, -4 },{ 2, 2, 0 },{ -2, -2, -2 },{ -4, -2, 3 },{ 3, 3, -1 },{ 1, 1, -3 },{ 0, -1, -4 },{ 1, 2, 0 },{ 2, -2, -3 },{ -2, -4, -4 },{ 0, 3, -2 },{ -2, -3, -1 },{ 1, 2, -1 },{ 3, -2, 1 },{ -3, -3, -4 },{ -1, -2, 0 },{ -2, 1, 1 },{ 0, 0, -3 },{ -4, 2, 0 },{ 1, -4, -2 },{ 0, 0, 3 },{ -2, 2, -1 },{ 1, 1, 1 },{ 1, 1, -3 },{ 2, -1, -2 },{ -4, 3, 3 },{ 0, -3, -4 },{ -1, -1, -1 },{ -4, 1, -2 },{ -1, -2, -3 },{ 2, -3, -4 },{ -2, -1, 2 },{ -4, 1, 0 },{ -4, -2, -3 },{ 1, 2, -2 },{ -2, -1, 2 },{ 1, -1, -2 },{ -4, -2, 3 },{ 1, 1, -4 },{ -2, 3, 2 },{ 3, -4, 1 },{ -2, 0, -4 },{ -4, 2, -3 },{ -3, -3, 2 },{ 0, 1, -2 },{ -3, 2, 3 },{ -2, -4, 1 },{ 0, -3, -4 } },
+		{ { -4, 1, 0 },{ -2, 2, -1 },{ 0, -3, 1 },{ -3, 1, 0 },{ 3, -3, -1 },{ 0, 0, -2 },{ -4, 0, -2 },{ 1, 1, 2 },{ -1, -3, 0 },{ -2, -1, -1 },{ 1, -4, -3 },{ 1, 1, 1 },{ -2, -2, -3 },{ 3, 3, 0 },{ -3, -2, -1 },{ 2, 3, 1 },{ 1, -4, 3 },{ 0, 0, -3 },{ 2, -3, -1 },{ 0, 2, -4 },{ -2, 1, 3 },{ 2, -4, 0 },{ -1, -2, 3 },{ -3, -4, 2 },{ -1, 3, -1 },{ 2, 1, 3 },{ -1, 2, 1 },{ -3, -1, -2 },{ -2, 1, -3 },{ 2, 3, 2 },{ 0, 0, 0 },{ -4, 3, -2 },{ 2, -3, -3 },{ 3, -4, 2 },{ -1, 3, -1 },{ 1, -1, -4 },{ 3, -4, 1 },{ -1, 3, -3 },{ -4, -2, 2 },{ 0, -4, 0 },{ -2, -3, -4 },{ -2, 2, 0 },{ 2, -3, 2 },{ 2, 2, 0 },{ -3, -4, 2 },{ 1, -3, 0 },{ -3, 1, -2 },{ 3, 2, 3 },{ -2, -1, 0 },{ 0, 3, -4 },{ 2, -4, 3 },{ -1, 0, 0 },{ -4, -3, -3 },{ -2, 3, -1 },{ 3, 0, -4 },{ -3, -3, 3 },{ -1, -2, -1 },{ -3, 1, 2 },{ 1, -4, 3 },{ -1, 3, 0 },{ 3, -1, -4 },{ -4, 0, -1 },{ 3, -2, 0 },{ 1, 2, -2 } },
+		{ { 2, -3, -3 },{ -1, 3, -3 },{ 3, -2, 2 },{ -4, 0, -2 },{ 2, 3, -4 },{ -2, 2, 3 },{ -3, -4, 1 },{ 3, 3, -4 },{ 0, -3, 3 },{ 2, 0, -4 },{ -1, 2, 1 },{ -3, -2, 2 },{ -4, -3, -2 },{ 2, 2, 3 },{ -1, -3, -4 },{ -4, -1, -3 },{ -2, -2, -1 },{ 3, 2, 2 },{ -3, -4, -2 },{ 1, -1, 0 },{ -3, -3, -2 },{ -4, 2, 1 },{ 3, -1, -3 },{ -2, 0, -2 },{ 3, 0, 0 },{ -3, -3, 2 },{ 1, -1, -3 },{ 3, -4, -4 },{ -4, -3, 3 },{ 0, -1, 1 },{ -3, -4, -2 },{ 3, 2, 3 },{ 1, -2, 1 },{ -4, 0, -2 },{ -2, 1, 1 },{ 2, -2, 3 },{ -4, 2, 0 },{ -1, -2, -2 },{ 2, 0, -4 },{ -3, -1, -1 },{ 3, 2, 3 },{ -1, 0, 1 },{ 1, -1, -2 },{ 3, 0, -3 },{ -2, 3, 3 },{ 0, -1, 1 },{ -1, 3, -2 },{ 1, -3, -3 },{ 2, -4, 2 },{ -1, 0, 1 },{ 3, 2, 3 },{ 0, -2, -1 },{ 2, 3, 1 },{ 0, -4, 2 },{ -1, -2, 1 },{ 1, 1, -2 },{ 2, -1, -3 },{ 0, 2, 0 },{ 3, -2, -2 },{ 1, 0, -1 },{ -2, -3, -3 },{ -1, 3, 2 },{ 1, -2, 3 },{ -3, 0, 1 } },
+		{ { 1, -1, -1 },{ -1, 1, 3 },{ 0, -4, -1 },{ -3, -1, -4 },{ -1, -4, 2 },{ 2, -2, 0 },{ -1, -2, -3 },{ -4, 0, -2 },{ -3, 2, -1 },{ -4, -1, 0 },{ 3, 1, 3 },{ 0, -1, -4 },{ 1, 3, 0 },{ -2, 0, -1 },{ 2, 0, 2 },{ 0, 2, -2 },{ 1, 1, 1 },{ -3, 3, 1 },{ -4, -1, 3 },{ 0, 3, -4 },{ -1, 0, 2 },{ -1, -2, 1 },{ 0, 1, -4 },{ 1, 2, -1 },{ -4, -3, -4 },{ 0, 3, 1 },{ -4, -2, 0 },{ -1, 2, 3 },{ 3, 0, 0 },{ 1, 2, 2 },{ -1, -1, -4 },{ -2, 1, -1 },{ -1, 3, -4 },{ 1, -1, 3 },{ -3, -3, -1 },{ 0, 0, -4 },{ 0, -3, 2 },{ -3, 2, 0 },{ 3, -4, 3 },{ 1, 3, -2 },{ 0, -2, -3 },{ -4, -4, 1 },{ -3, -2, -3 },{ -1, 1, -4 },{ -4, -4, -1 },{ 2, -2, -4 },{ 3, 1, 1 },{ -3, 0, -4 },{ 0, -2, -1 },{ -4, 1, -3 },{ -2, -1, -2 },{ -3, -3, -4 },{ -3, 1, -3 },{ 3, 2, 0 },{ 0, -1, 0 },{ -4, 3, -3 },{ -3, -3, 2 },{ 0, 1, 1 },{ -4, -1, -4 },{ -2, 0, 1 },{ 0, -3, 3 },{ 2, 2, -3 },{ -3, 1, -2 },{ -2, -4, -4 } },
+		{ { 3, -2, -2 },{ -4, 2, 0 },{ 1, 2, 2 },{ -2, -2, 1 },{ 3, 1, -1 },{ 1, 3, 3 },{ -2, -1, 1 },{ 1, -4, 2 },{ 2, -3, 2 },{ -1, 3, -2 },{ 1, -4, 2 },{ -4, 2, -2 },{ 3, -4, -3 },{ -1, -1, 2 },{ -3, -3, -4 },{ -2, -4, 3 },{ 3, -2, -3 },{ -1, -1, -4 },{ -1, -3, -2 },{ 3, 1, 0 },{ 2, -2, -3 },{ 2, -4, -1 },{ -3, 3, 2 },{ 2, -3, 3 },{ -2, -1, -2 },{ 1, 1, 2 },{ 2, 0, -2 },{ -2, -2, -1 },{ 0, 3, -2 },{ -3, -4, -3 },{ 2, -2, -1 },{ 3, 0, 2 },{ -3, -3, 0 },{ 0, -4, -3 },{ -2, 2, 0 },{ 3, 2, -2 },{ -3, -1, -3 },{ 2, 1, -1 },{ -2, -1, 1 },{ -1, 1, 2 },{ 2, -3, -1 },{ -3, 3, 0 },{ 3, 1, 2 },{ 1, 2, 2 },{ 0, -1, 3 },{ -3, -4, 0 },{ -4, 2, 3 },{ -2, -1, -1 },{ -1, -4, 2 },{ -3, 3, 0 },{ 3, 2, 1 },{ 0, 0, -1 },{ 1, -2, 3 },{ -2, 0, -4 },{ 2, -4, -2 },{ -2, 0, 3 },{ 3, 2, -1 },{ -1, -4, -4 },{ 2, 3, 3 },{ -3, -4, -2 },{ -4, 2, 0 },{ 0, -4, -1 },{ 3, -1, 1 },{ -4, 3, 2 } },
+		{ { -1, -3, -4 },{ -2, 3, 0 },{ 2, 0, -3 },{ -3, 0, -3 },{ 0, -3, 0 },{ -4, 1, -3 },{ 2, 1, -2 },{ 3, 2, -4 },{ 0, -2, 0 },{ -2, 0, -3 },{ 3, -2, -3 },{ -2, -3, 1 },{ -1, 1, 0 },{ 1, 2, 1 },{ -3, 1, -1 },{ 1, 3, 0 },{ -4, 0, 0 },{ 2, 2, -1 },{ 1, -3, 1 },{ -2, 1, 2 },{ -4, 3, 0 },{ -2, -1, -2 },{ 0, 0, 0 },{ -4, 2, 1 },{ -1, -4, -4 },{ 3, -4, -3 },{ -3, 1, 3 },{ -1, -1, 1 },{ 2, -3, -4 },{ -4, 1, 1 },{ -2, 3, 0 },{ -4, -2, 1 },{ 1, 0, -3 },{ 2, 3, 2 },{ -4, -4, 3 },{ -1, -2, -1 },{ 3, 3, 2 },{ 1, -4, 1 },{ -4, -2, -4 },{ -1, 2, -3 },{ -4, 0, -2 },{ -2, -1, -4 },{ 2, -2, -1 },{ -2, -3, 0 },{ 3, 0, -2 },{ 1, 2, -3 },{ 1, -2, 0 },{ 2, 3, 2 },{ 3, -3, -2 },{ 1, 0, 3 },{ 2, -3, -3 },{ -1, -1, 2 },{ -4, 3, -1 },{ 2, -3, 3 },{ -4, 2, 1 },{ 1, -3, -3 },{ -3, -1, 0 },{ -1, -2, -1 },{ 1, 2, -3 },{ 3, 0, 1 },{ 1, -1, 2 },{ -1, 3, -4 },{ 2, -3, 0 },{ 0, 1, 3 } },
+		{ { 0, -1, 2 },{ 1, -4, 1 },{ 3, -2, -2 },{ 1, -4, 3 },{ -3, 3, -4 },{ -2, -1, 2 },{ -3, -3, -1 },{ -1, -1, 0 },{ -4, 2, 1 },{ -3, 1, 3 },{ 1, 0, -1 },{ -3, 3, -4 },{ 2, -2, 3 },{ -4, -3, -2 },{ 3, -1, -3 },{ 0, -2, 2 },{ 0, 0, 3 },{ -2, -4, -2 },{ -3, 0, -4 },{ 0, 2, 3 },{ 1, -4, -3 },{ -3, -3, -4 },{ 3, 0, 3 },{ 2, -2, -2 },{ -3, -1, 1 },{ 0, 3, 0 },{ 1, 2, -1 },{ -3, -3, -3 },{ 2, 0, 3 },{ 0, -1, -1 },{ -2, -4, -3 },{ 1, 2, 3 },{ 0, 1, -2 },{ -3, -1, -2 },{ 2, 1, 1 },{ 1, 0, -4 },{ -4, -3, -2 },{ -2, 1, 3 },{ 1, -1, 0 },{ 0, -3, 0 },{ 3, -4, 3 },{ 1, 3, 3 },{ 0, -4, 1 },{ -4, 0, -4 },{ -3, 3, -2 },{ -1, -3, 1 },{ 0, 0, -4 },{ -4, -1, -2 },{ -2, 2, -4 },{ 0, -2, 0 },{ -4, -4, -2 },{ 3, 2, -4 },{ -1, -4, 1 },{ -2, 1, -3 },{ 3, 3, -2 },{ -1, 0, 2 },{ 1, -2, 1 },{ -4, 3, 2 },{ 2, -2, 3 },{ -2, 1, -2 },{ -1, -2, -3 },{ -3, 1, 2 },{ -4, -2, -3 },{ -2, 0, -2 } },
+		{ { -3, 0, -1 },{ -2, 2, -4 },{ -4, 1, -1 },{ -1, 3, 1 },{ 2, 0, 2 },{ 0, -2, -1 },{ 3, -4, -2 },{ 0, 3, 3 },{ 1, -3, -3 },{ 2, -4, -1 },{ 0, -1, 2 },{ -2, 2, 1 },{ -1, 0, -2 },{ 0, -4, 3 },{ 2, 3, -1 },{ -1, 2, -4 },{ -4, -3, -3 },{ 3, -1, 1 },{ -1, 3, -1 },{ 2, -2, 2 },{ 3, -1, -2 },{ 0, 2, 1 },{ -1, 3, 2 },{ 1, 1, -3 },{ -2, -1, -1 },{ 3, -2, 2 },{ -4, 1, -2 },{ -1, -4, 0 },{ -2, 2, 2 },{ 3, 2, -2 },{ 1, 0, -4 },{ 3, -2, 3 },{ -1, -3, -1 },{ -2, 3, -4 },{ 3, -2, 2 },{ -1, -1, 0 },{ -3, -3, -1 },{ 2, 0, -3 },{ -1, 3, -3 },{ -3, 1, 2 },{ 2, 2, -1 },{ -2, -1, -3 },{ 0, 1, 1 },{ -4, 1, -3 },{ 2, -4, 2 },{ -2, -1, 3 },{ 3, 1, -1 },{ -3, -4, 2 },{ -2, 1, 1 },{ -1, 3, 3 },{ -3, 0, 1 },{ -2, 1, -2 },{ 1, -2, 2 },{ 0, -2, 0 },{ -3, -1, -1 },{ 2, -4, -4 },{ 0, 1, -2 },{ -2, -4, -2 },{ -3, 0, -4 },{ 0, -3, -1 },{ -2, -3, 0 },{ 3, 2, 3 },{ 1, -4, -2 },{ 2, 3, 0 } },
+		{ { 1, -1, 1 },{ 3, -3, -3 },{ 0, -3, 3 },{ -3, -1, -2 },{ -1, -2, -4 },{ -4, 2, 1 },{ 2, 1, 3 },{ -2, 0, -4 },{ -4, -2, -2 },{ -1, 1, -1 },{ 3, -4, -4 },{ 2, 3, 3 },{ 0, -2, 0 },{ -4, 1, -4 },{ -2, -4, 2 },{ -3, -1, 1 },{ 3, 3, -2 },{ 1, 1, -3 },{ -4, -3, 3 },{ -2, 0, 0 },{ -4, 1, -1 },{ -3, -2, -1 },{ 1, -3, 3 },{ -1, -4, 0 },{ -4, 2, -4 },{ 2, 3, 3 },{ 0, -3, -4 },{ 1, -2, -2 },{ -3, 3, 1 },{ -1, -2, -3 },{ -4, -4, 2 },{ -1, -1, 0 },{ -3, 1, -3 },{ -4, -4, 0 },{ 0, 0, 2 },{ -2, 2, -3 },{ -2, 2, 1 },{ 0, 3, 2 },{ 3, -4, -1 },{ -4, -2, -4 },{ 2, 0, -1 },{ -3, -3, -2 },{ -1, 2, 0 },{ 3, -3, 2 },{ 2, 2, -1 },{ 1, 3, -4 },{ -1, -2, 0 },{ 2, 2, -3 },{ 0, -4, -1 },{ 2, -1, -3 },{ 1, -3, -4 },{ 3, 3, -1 },{ -4, 1, 3 },{ 2, -3, -3 },{ -1, 0, 1 },{ -4, 1, 3 },{ 1, 2, 0 },{ -1, 3, 1 },{ 3, -1, 0 },{ 3, 1, 2 },{ -4, 3, -1 },{ 0, -1, 1 },{ 2, 2, -4 },{ -4, -4, 2 } },
+		{ { -2, 1, 3 },{ -4, 3, 0 },{ 1, 2, 1 },{ 2, -4, -1 },{ 1, 2, 0 },{ -2, 1, -3 },{ -1, -3, -1 },{ 3, -1, 2 },{ -1, 2, 1 },{ -2, 3, 0 },{ -4, -1, 2 },{ -3, -3, -3 },{ -3, 2, -3 },{ 3, -1, -1 },{ 1, 1, -1 },{ -1, -3, 3 },{ 2, -2, 1 },{ -3, -4, 2 },{ 1, 1, -4 },{ -2, -3, -4 },{ -1, -4, 1 },{ 3, 3, -3 },{ -3, 1, -4 },{ 2, -4, 0 },{ -2, 0, 1 },{ -3, -3, -3 },{ 3, 2, 3 },{ -1, 0, -1 },{ 2, -1, 0 },{ 2, 1, 3 },{ -2, 3, -2 },{ 2, -3, 1 },{ 3, 3, 1 },{ 1, 2, -3 },{ 1, -4, 3 },{ 2, -1, -4 },{ 3, 0, -2 },{ -3, -3, 0 },{ 1, 1, 3 },{ -2, -2, 2 },{ 0, 3, -4 },{ -1, -4, 1 },{ 1, -1, 3 },{ 0, -2, -4 },{ -2, 0, 0 },{ -4, -1, -2 },{ -3, -3, 2 },{ 1, 0, -2 },{ 3, -2, 3 },{ -4, 2, 0 },{ 0, -3, 2 },{ -3, 0, -1 },{ 0, -4, 0 },{ 1, 2, -4 },{ -2, 3, -2 },{ 3, -2, -3 },{ -3, -3, 3 },{ 2, -1, -3 },{ 0, -4, -4 },{ -3, 2, 3 },{ 1, -3, -3 },{ -1, -1, -2 },{ -3, 0, 1 },{ -1, -2, -3 } },
+		{ { 2, 3, -2 },{ -1, 0, -4 },{ -3, -2, 2 },{ -2, 0, -3 },{ 3, -3, 3 },{ -3, -4, 0 },{ 2, 3, -2 },{ -3, -1, -4 },{ 1, -4, 1 },{ 2, -2, 3 },{ 1, 0, -4 },{ 3, 1, -2 },{ 1, -4, 2 },{ -1, 0, 1 },{ 2, 2, -2 },{ -4, 0, -4 },{ 0, 1, 0 },{ -1, -1, -1 },{ 3, 2, 0 },{ 0, 3, -2 },{ 2, 0, 3 },{ 1, -1, 2 },{ -4, 0, -2 },{ 0, -2, 3 },{ 3, -1, -2 },{ 0, 1, 0 },{ -4, -4, 2 },{ 0, 0, -3 },{ -4, -4, 1 },{ -3, -3, -4 },{ 0, 1, -1 },{ -3, 0, -4 },{ 0, -1, 3 },{ -3, -2, -1 },{ -2, 3, -1 },{ -4, -3, 3 },{ 0, -2, 1 },{ 1, -4, -3 },{ -1, -1, -2 },{ 2, -1, 1 },{ -4, 1, 3 },{ 3, 0, -1 },{ -3, 3, -3 },{ -4, 1, -2 },{ 0, -3, 3 },{ 3, -4, -1 },{ -3, 2, 1 },{ -1, 3, -3 },{ -4, -1, 2 },{ 1, 1, -4 },{ -2, 3, 1 },{ -1, -1, -2 },{ 3, -2, 3 },{ -1, 1, 2 },{ -3, -4, 1 },{ 0, 0, 0 },{ -1, -3, -1 },{ -4, 1, 2 },{ -2, -2, -2 },{ 1, 0, 0 },{ -1, 1, -4 },{ -4, -4, 2 },{ 1, 2, -2 },{ 3, -3, 0 } },
+		{ { -1, -3, -1 },{ 3, -4, -1 },{ 0, -1, -2 },{ -4, 3, 1 },{ 0, 1, -4 },{ 1, -1, 2 },{ -4, -2, 3 },{ 0, 3, -1 },{ 3, 2, -3 },{ 0, -3, 2 },{ -4, 1, -1 },{ -1, -2, 0 },{ -2, 3, 1 },{ 0, -2, -4 },{ -4, -3, 0 },{ -2, 3, 3 },{ 2, -2, -3 },{ -2, -4, -2 },{ -4, 2, 2 },{ 1, -1, 1 },{ -3, -3, -1 },{ -2, -2, -3 },{ -1, 2, 1 },{ 1, 3, -1 },{ -4, -1, -3 },{ 1, 3, 2 },{ -2, -2, -4 },{ 2, 3, -1 },{ -2, 2, 3 },{ 3, -2, -3 },{ 1, -1, 0 },{ -4, -4, 2 },{ 3, 2, 1 },{ -1, -3, -2 },{ -1, 1, -4 },{ 2, 1, 0 },{ -4, 3, 2 },{ -3, 2, -1 },{ -2, 1, -4 },{ -1, 3, 0 },{ 3, -4, -3 },{ 0, -2, 2 },{ -2, -3, 0 },{ 2, 2, 1 },{ 2, 0, -3 },{ -1, 3, 1 },{ 0, -1, 0 },{ 2, 1, -4 },{ -2, -4, -1 },{ 2, -2, -2 },{ -3, -4, 2 },{ 2, 0, -3 },{ -4, 2, 0 },{ -2, -1, -4 },{ 3, 2, -2 },{ 2, -2, 2 },{ -2, 3, -4 },{ 3, 2, 1 },{ 1, 3, -1 },{ 2, -4, 1 },{ -2, 0, 2 },{ 3, 2, -1 },{ -3, -2, 3 },{ 0, -1, 2 } },
+		{ { -3, 1, -4 },{ -4, 0, 1 },{ 2, 2, 2 },{ -1, -3, -1 },{ -2, -1, -3 },{ 2, 2, 0 },{ -1, 1, 1 },{ -3, -4, -4 },{ -1, 0, -1 },{ -2, 3, -2 },{ -3, -1, -3 },{ 2, 2, -1 },{ 0, -4, 3 },{ 3, -1, 2 },{ 1, 2, -3 },{ -3, -4, 1 },{ 3, 0, 2 },{ 0, -1, -4 },{ -3, 0, -1 },{ 2, -2, -3 },{ -1, 1, 3 },{ 2, 3, 0 },{ -3, -4, -4 },{ 3, 0, 2 },{ -3, -4, 0 },{ 2, 1, -2 },{ -3, -3, 1 },{ -1, 2, -1 },{ 1, -1, 2 },{ -2, 1, -2 },{ -1, 3, -1 },{ 0, -2, -3 },{ 1, 0, -3 },{ 3, -4, 0 },{ -3, 0, 1 },{ 0, -1, -4 },{ 3, -4, -3 },{ 3, -3, 3 },{ -3, 0, -1 },{ 2, -3, 2 },{ -4, -2, -2 },{ 1, 2, 0 },{ -1, 1, -4 },{ -3, -4, 2 },{ -2, -2, -1 },{ 1, 1, -4 },{ -4, -3, 3 },{ 3, -3, 2 },{ 0, 1, 1 },{ -1, 2, 0 },{ 3, -3, -4 },{ 1, 3, -1 },{ 0, -3, 2 },{ 1, -4, -1 },{ -3, -1, 0 },{ -1, 0, -4 },{ 0, 1, -1 },{ -4, -2, 2 },{ -1, -3, -3 },{ -3, -1, 3 },{ 0, 3, 0 },{ 2, -3, -3 },{ -4, 3, -4 },{ 1, 1, 1 } },
+		{ { -2, 3, 3 },{ 3, -3, -3 },{ 1, 1, 3 },{ -3, -2, -4 },{ 2, -4, 3 },{ 3, 0, -3 },{ -2, -3, -2 },{ 2, 0, 2 },{ -4, -2, 0 },{ 3, 1, 3 },{ 0, -3, 2 },{ 3, -4, -4 },{ -4, 2, -2 },{ -3, 1, -3 },{ 2, -1, -1 },{ -1, -2, -2 },{ 1, 3, 0 },{ 1, 2, 3 },{ -1, -3, 1 },{ 3, -4, -4 },{ -4, 2, -2 },{ 0, 0, 1 },{ 3, -3, -3 },{ -2, -3, 3 },{ 0, 2, -4 },{ -1, -1, 1 },{ 2, -3, 3 },{ 3, 0, -4 },{ -4, -4, 0 },{ 0, 0, 2 },{ 2, -4, 3 },{ -3, 2, 1 },{ -2, 3, -1 },{ -4, -2, 3 },{ 2, 3, 2 },{ -2, 1, -2 },{ -1, -2, 0 },{ 0, 2, 1 },{ 1, -1, 2 },{ -2, 1, -3 },{ -3, 3, -4 },{ 2, -1, 3 },{ 0, -1, -2 },{ 3, 3, 1 },{ -4, 0, 3 },{ 0, -2, -2 },{ -3, 2, -3 },{ 2, -1, -1 },{ -4, 0, -2 },{ -3, -2, 3 },{ -2, 1, 3 },{ -2, 0, 1 },{ -4, 2, -3 },{ 2, 1, 3 },{ 0, -3, -2 },{ -4, 3, 3 },{ 1, -4, -3 },{ 2, -4, 1 },{ -3, 0, -3 },{ 3, 2, -4 },{ -1, -2, -1 },{ 0, -4, 2 },{ 2, -1, -3 },{ -2, -2, 0 } },
+		{ { 0, -4, -2 },{ -1, -1, 0 },{ 0, -2, 0 },{ -3, 3, -1 },{ -4, 3, 1 },{ 1, -2, -1 },{ -4, 2, 0 },{ 0, -1, 3 },{ 1, -4, -4 },{ 1, 3, 1 },{ -2, -1, 0 },{ -2, 0, 1 },{ 1, -2, 2 },{ -1, 3, -1 },{ -2, 0, 1 },{ 0, -3, -4 },{ -3, -3, 0 },{ -4, 1, -3 },{ -2, 3, -1 },{ 2, -2, 0 },{ -2, 1, 2 },{ -3, -1, -2 },{ 1, 2, 1 },{ -1, 1, -1 },{ -4, -2, -2 },{ -2, 3, 0 },{ 0, 1, -3 },{ -4, -2, -2 },{ -3, 3, -3 },{ 2, 0, -4 },{ -3, -3, -2 },{ -2, -1, -2 },{ 2, 1, -4 },{ 0, -3, 2 },{ 1, -2, -2 },{ -2, 0, -3 },{ 2, -4, 3 },{ -4, 3, -4 },{ 1, 0, -2 },{ 0, -2, -1 },{ -1, -4, 1 },{ -4, 0, 1 },{ -2, -3, -1 },{ 1, -4, -2 },{ -1, 3, -3 },{ 2, 0, 0 },{ -2, -4, 0 },{ 1, 3, 2 },{ -1, -4, -4 },{ 1, 3, -3 },{ 0, -1, -2 },{ 2, -3, 1 },{ 3, -2, -4 },{ -2, 0, 0 },{ 0, -2, 1 },{ 3, 1, 2 },{ -2, -1, -1 },{ 1, 1, 0 },{ 0, 0, -2 },{ 1, -2, 3 },{ -4, 1, -2 },{ -2, 0, -1 },{ 1, 1, 1 },{ 3, 2, -2 } },
+		{ { 2, -1, 2 },{ -3, 2, -3 },{ 1, 1, -2 },{ 3, 0, -4 },{ -2, -4, 2 },{ 0, 1, 2 },{ -1, -1, -3 },{ 3, 3, -1 },{ -1, 2, -3 },{ -4, -3, -2 },{ -1, 1, -3 },{ 2, 1, 3 },{ -4, -3, -2 },{ 3, -3, 0 },{ -1, 0, 3 },{ 2, 2, -3 },{ -4, -1, 1 },{ 3, -4, 2 },{ 1, 0, -3 },{ 0, 3, 2 },{ -4, -1, -4 },{ 2, -4, 3 },{ 0, -2, -3 },{ -4, -1, 2 },{ 2, 3, -4 },{ 3, -4, 3 },{ 1, 0, 1 },{ -1, -2, 2 },{ 3, 2, -1 },{ -1, -3, 0 },{ 1, 2, 3 },{ 3, -2, 0 },{ 0, 0, 2 },{ -4, 2, -1 },{ -1, -4, -4 },{ -3, -1, 0 },{ 1, 2, 1 },{ -4, -3, -2 },{ -2, 0, 2 },{ 3, -4, 3 },{ 2, 3, -3 },{ 3, 1, 0 },{ 0, 2, 3 },{ -3, -2, -4 },{ -2, 1, 1 },{ 3, -1, 3 },{ -1, -2, -4 },{ -3, 2, 2 },{ 3, 0, -1 },{ 2, 1, 0 },{ -4, -4, -1 },{ -1, 2, -1 },{ -3, 1, 2 },{ -3, -4, -2 },{ -1, 3, -4 },{ 2, 2, -3 },{ -3, -3, -2 },{ -2, 3, 3 },{ -4, -3, 0 },{ -2, 3, 1 },{ 3, 2, 1 },{ -3, -3, -4 },{ -1, -4, 3 },{ -4, 0, -4 } },
+		{ { 1, 0, 2 },{ -2, -3, 1 },{ -4, -4, 3 },{ 2, 0, 1 },{ -1, -1, -2 },{ -3, -3, 0 },{ 2, 1, -4 },{ -2, -2, 2 },{ -3, -4, 1 },{ 3, 0, -1 },{ 2, -3, 3 },{ -3, 3, -4 },{ 0, -1, -2 },{ 1, 3, -4 },{ -3, -4, 3 },{ 3, 1, 2 },{ -2, 2, -2 },{ 0, -2, -1 },{ 2, 0, 3 },{ -1, -3, -2 },{ -1, 2, 0 },{ 3, -3, -1 },{ -2, 3, 0 },{ -1, 1, 3 },{ -3, -4, -2 },{ 1, -3, -1 },{ -2, -1, -3 },{ 1, 1, 0 },{ -2, -4, 3 },{ 0, -1, 1 },{ -4, 1, 1 },{ -1, -4, -3 },{ -2, -3, -3 },{ 2, 2, 1 },{ 3, 3, 1 },{ -3, 1, 3 },{ -1, -2, -1 },{ 3, 1, 0 },{ -1, -1, -4 },{ -3, 2, -1 },{ -3, -2, 0 },{ -1, 2, 2 },{ -4, 0, -3 },{ 1, -3, 2 },{ 3, -4, -1 },{ -4, 1, 2 },{ 1, -3, -2 },{ -2, -3, -3 },{ 0, -2, 1 },{ -3, -3, 3 },{ 0, -1, -4 },{ -2, 3, 3 },{ 1, -2, -3 },{ 3, -1, 3 },{ 2, 0, 0 },{ -4, -4, 1 },{ -1, -2, 2 },{ 3, -1, -4 },{ 2, 0, -4 },{ 0, -4, 2 },{ 1, -1, -3 },{ 2, -2, 2 },{ 0, 3, 0 },{ -3, 2, -1 } },
+		{ { 3, 3, -3 },{ -1, -2, -1 },{ 2, 2, -4 },{ 0, 2, -1 },{ 1, -2, -3 },{ -4, -4, 3 },{ 2, 3, -2 },{ 1, 0, -1 },{ -4, 1, 1 },{ -1, -1, -4 },{ 0, -2, 2 },{ -2, 2, 0 },{ 2, 1, 0 },{ -3, -1, 1 },{ -2, -2, -1 },{ 1, -2, -4 },{ -1, 3, 0 },{ -2, -3, -4 },{ -3, 1, 0 },{ -4, -4, 2 },{ 2, -1, -3 },{ -3, 1, 1 },{ 1, 2, -4 },{ 2, -2, -3 },{ 0, 0, 0 },{ -3, 2, 1 },{ 0, 3, 2 },{ -4, 2, -2 },{ 2, -1, -4 },{ -3, 3, -2 },{ 3, 0, -4 },{ 0, 3, -1 },{ -3, -1, 3 },{ -2, 0, -2 },{ 3, -3, -1 },{ 0, -2, -4 },{ -2, -4, -3 },{ 2, 2, 3 },{ 0, 3, 1 },{ -4, -3, 2 },{ 2, -2, -4 },{ 0, -3, -2 },{ 2, -1, -3 },{ -2, -1, 0 },{ 0, 2, -1 },{ -3, 3, -2 },{ 0, 0, -4 },{ 2, 1, 1 },{ -4, 3, -1 },{ -1, 2, 2 },{ 3, 0, -3 },{ 1, -3, 1 },{ -1, -2, 0 },{ -4, 2, -1 },{ 0, 0, -2 },{ 1, -3, 3 },{ -3, 2, -3 },{ 0, 1, -1 },{ -1, -1, 3 },{ -3, -3, -2 },{ -2, 2, -1 },{ -1, 1, -3 },{ -2, -3, -2 },{ 2, -3, 1 } },
+		{ { -1, 1, 1 },{ -3, -4, 3 },{ -2, 1, -2 },{ -3, -2, 2 },{ 3, 3, 1 },{ -1, 1, -3 },{ -2, 2, 1 },{ 3, -3, 3 },{ 0, -4, 0 },{ 1, 3, -3 },{ 3, 0, -2 },{ -4, -4, 2 },{ -1, -4, 1 },{ 2, 2, -2 },{ -4, 0, -3 },{ 0, -4, -1 },{ 2, 0, 3 },{ 1, -1, 1 },{ -3, 1, -4 },{ 3, 3, -1 },{ 1, -2, 3 },{ -4, 0, -2 },{ -1, -1, 2 },{ -4, -4, -1 },{ 3, 1, 2 },{ -2, -2, -4 },{ 3, -3, 3 },{ 2, 0, -1 },{ -1, -4, -3 },{ -2, -2, 0 },{ 1, -3, 2 },{ 2, 2, 3 },{ 1, 1, -4 },{ -4, -2, 0 },{ 0, 0, 2 },{ 1, 3, 2 },{ -1, 0, -2 },{ 2, -1, -1 },{ 1, -4, -3 },{ -2, 0, -2 },{ 1, 0, -1 },{ -1, 1, 3 },{ -4, 3, 3 },{ 3, -4, 1 },{ -1, 1, -3 },{ -2, -2, 3 },{ 2, 2, 3 },{ -1, -4, 0 },{ 1, -1, -4 },{ -3, -2, -2 },{ 3, 0, 0 },{ -4, -4, -2 },{ -2, 1, -3 },{ 2, 3, 2 },{ -2, -3, -4 },{ 1, 3, 1 },{ -4, 0, 0 },{ 3, -4, 1 },{ -3, 3, 0 },{ 2, 2, -1 },{ 3, 0, 1 },{ -4, -2, 0 },{ 1, 1, 3 },{ -4, -1, -4 } },
+		{ { 0, -2, 0 },{ 1, 3, -3 },{ 2, -1, 0 },{ 0, -3, -4 },{ -2, 0, 2 },{ -4, -1, -1 },{ 0, -2, -4 },{ -2, -1, 0 },{ -4, 0, -3 },{ 2, 3, 3 },{ -3, -3, -1 },{ 1, 1, -3 },{ -2, -2, -4 },{ 1, 3, 3 },{ 3, 1, 0 },{ -3, -3, 2 },{ -4, 3, -2 },{ 0, -4, 3 },{ 2, -2, -1 },{ -2, 0, -3 },{ 1, 2, 1 },{ 0, -4, -4 },{ 3, -3, -1 },{ -1, 3, 1 },{ -2, -2, -3 },{ 1, -1, -2 },{ -4, 1, 0 },{ 0, -2, 1 },{ -3, 0, 2 },{ 1, 1, 0 },{ -2, -3, -2 },{ -4, -4, -1 },{ -1, 3, 0 },{ 2, -1, 1 },{ -2, -4, -3 },{ -4, 2, 1 },{ -3, -3, -4 },{ -4, -2, 2 },{ -1, 1, 3 },{ -3, 2, 1 },{ 3, -4, 0 },{ -3, 3, -4 },{ 1, -3, 1 },{ 1, 0, -2 },{ -3, -2, -4 },{ 3, -4, 0 },{ -4, -1, -1 },{ -3, -2, 2 },{ 3, 1, -3 },{ 0, -4, 2 },{ -2, 2, 3 },{ 2, 2, -4 },{ 0, -1, 1 },{ -3, -2, 0 },{ -1, -2, 2 },{ 3, 1, -1 },{ -2, -1, -3 },{ 0, -2, -3 },{ 2, -2, -2 },{ -4, 0, -4 },{ -2, -4, 3 },{ 0, 3, -4 },{ 3, -4, 2 },{ -3, 0, -2 } },
+		{ { 2, -3, -4 },{ -4, -4, 2 },{ -1, 3, 1 },{ -4, 2, -2 },{ 3, -4, 3 },{ 2, -3, 0 },{ 1, 2, -2 },{ 3, -4, 2 },{ -3, 2, 1 },{ -1, -2, -2 },{ -1, 2, 1 },{ 3, -1, 0 },{ -3, 2, 3 },{ 0, -3, -1 },{ -1, -1, -4 },{ -2, 0, -3 },{ -1, 2, 2 },{ 1, 2, -3 },{ -1, -1, 0 },{ -2, -4, -2 },{ -1, 3, 2 },{ -3, -1, 0 },{ -3, 1, 3 },{ 2, 0, 1 },{ 1, -4, -3 },{ -3, 3, 3 },{ -1, 2, -4 },{ 0, -3, -1 },{ 3, 2, 3 },{ -4, 3, -3 },{ 2, -1, 2 },{ 0, 0, -3 },{ -3, 1, -4 },{ 1, -3, -2 },{ 3, 1, 3 },{ -2, 2, -2 },{ 3, -1, -1 },{ 1, 3, 0 },{ 3, -1, -4 },{ 0, 0, -1 },{ 2, -2, 2 },{ -2, -2, -3 },{ -2, 1, -2 },{ 0, 2, 0 },{ -4, 2, 2 },{ 1, 3, 1 },{ 1, 0, -3 },{ -2, -3, 1 },{ 2, 3, -2 },{ -1, 1, 0 },{ -4, -2, -1 },{ -1, -3, 3 },{ 1, 3, -1 },{ 2, 0, -4 },{ -4, -4, -2 },{ 1, -1, 3 },{ 2, 3, -1 },{ -3, -3, 2 },{ 0, 2, 3 },{ 1, 1, 1 },{ -1, -3, 0 },{ 1, -1, -3 },{ -3, 3, -1 },{ 3, 2, 0 } },
+		{ { 0, -1, 3 },{ 3, 1, -1 },{ -2, 0, -3 },{ 1, -2, -1 },{ -3, 1, -4 },{ 0, 3, 2 },{ -2, -1, -3 },{ -3, 1, 3 },{ 0, 0, -4 },{ 2, -4, -4 },{ -2, -1, 2 },{ 1, 0, -3 },{ -4, -3, -2 },{ 2, 3, 2 },{ -3, -2, 1 },{ 2, -4, -1 },{ 3, -2, 0 },{ -4, 2, -4 },{ 3, -3, 2 },{ -4, 1, 3 },{ 2, -3, 0 },{ 3, -2, -3 },{ 1, 2, -4 },{ 0, -2, -2 },{ -4, 2, -1 },{ 2, -1, 2 },{ 3, -4, 0 },{ 1, 0, -3 },{ -2, -1, -2 },{ -3, -4, -4 },{ -1, -2, 1 },{ 3, -2, 3 },{ -2, 3, 1 },{ -1, -4, -1 },{ 2, -1, -3 },{ 0, -3, 3 },{ 0, 1, 0 },{ -1, -4, 2 },{ -4, -3, -3 },{ -1, 2, -2 },{ -4, -4, 2 },{ 3, -1, 1 },{ 2, -1, -1 },{ -1, -3, 3 },{ 3, -4, -4 },{ 0, -1, -2 },{ -1, 1, -1 },{ -3, 2, -4 },{ -4, 0, 3 },{ 1, -1, -4 },{ 2, -3, -2 },{ -3, 1, -3 },{ 0, -1, 2 },{ 3, -4, 1 },{ -3, 2, -3 },{ -1, 1, 2 },{ -4, -3, -4 },{ -1, 2, 0 },{ -2, -4, -2 },{ 3, 3, 2 },{ -3, -1, -3 },{ 2, 1, 3 },{ -1, -2, -2 },{ -2, 0, 1 } },
+		{ { -1, 0, -4 },{ -3, 2, 2 },{ 1, -4, 0 },{ 0, -1, 3 },{ 3, -2, -3 },{ -1, 1, -1 },{ -4, -3, 0 },{ 1, 0, -2 },{ -1, -3, 1 },{ 3, 3, -1 },{ -4, 1, 3 },{ 0, -4, 0 },{ 1, -1, -4 },{ -1, 1, 0 },{ 3, 1, 3 },{ -4, 0, -2 },{ 0, -4, 1 },{ -1, -1, -2 },{ -3, 1, -4 },{ 0, 0, 1 },{ -2, 3, -1 },{ -4, -1, -2 },{ -1, -4, 0 },{ -2, 0, 2 },{ -3, -3, 0 },{ -1, 1, -1 },{ -2, -2, -4 },{ -4, -3, 1 },{ 0, 1, 1 },{ 2, 3, -1 },{ 1, 1, 0 },{ -2, 0, -3 },{ -4, 2, 2 },{ 1, -1, -1 },{ -4, 3, 1 },{ -3, 0, -4 },{ -3, -2, -2 },{ 2, 2, 1 },{ -2, 1, 3 },{ 1, -2, -4 },{ 0, 3, -1 },{ -3, 1, -3 },{ 0, 2, 0 },{ -4, 3, 2 },{ -2, 0, -3 },{ -3, -2, 3 },{ 2, -3, 0 },{ 0, -2, 1 },{ 3, -4, 2 },{ 0, -1, -1 },{ -2, 3, 0 },{ 3, 0, 1 },{ -2, 1, -2 },{ -4, -3, 3 },{ 1, 2, -1 },{ 0, -1, 0 },{ 3, 0, 1 },{ 1, 0, -4 },{ -2, -1, -1 },{ -4, -2, -3 },{ 0, 2, -1 },{ -4, -3, 1 },{ 1, -4, 2 },{ -4, 2, -3 } },
+		{ { 0, -4, -2 },{ 2, -3, 0 },{ -4, -1, -3 },{ -2, 3, 2 },{ -3, -3, 1 },{ 1, 2, 1 },{ 2, -4, 3 },{ 3, 2, 2 },{ -4, -2, -1 },{ 0, 3, -2 },{ -2, -2, 0 },{ 3, 2, -3 },{ -3, -4, 1 },{ -2, -3, 3 },{ 1, 2, -4 },{ 2, 3, -3 },{ -2, 0, 2 },{ 1, -3, 3 },{ 3, 3, -1 },{ 2, -2, -3 },{ 0, -4, 3 },{ 1, 0, -2 },{ 0, 3, 3 },{ 2, -3, 1 },{ 3, 3, -3 },{ 0, 0, 2 },{ 2, 2, 3 },{ -1, 3, -2 },{ 3, -3, 2 },{ -1, -1, 3 },{ -4, -4, -2 },{ 0, -3, -4 },{ 3, -2, 0 },{ 2, 1, -2 },{ -1, -4, 0 },{ 3, -2, 2 },{ -2, 3, -3 },{ 3, -3, 1 },{ -4, 0, -3 },{ 2, -3, 0 },{ -2, 0, 1 },{ -1, -4, 3 },{ 3, -3, -4 },{ 2, -2, -2 },{ -2, -4, -1 },{ 1, 2, 2 },{ 3, 1, -2 },{ -2, 2, -4 },{ -4, 3, 0 },{ -1, 0, 2 },{ -3, -2, -3 },{ 0, -4, 3 },{ 2, 2, -4 },{ -1, -1, 0 },{ 3, -3, -3 },{ -2, -2, -1 },{ -3, 3, -2 },{ 2, -3, 3 },{ 3, -4, 3 },{ 0, 1, 0 },{ 2, -2, 1 },{ -2, 0, -4 },{ 2, 3, 0 },{ 3, -2, -1 } },
+		{ { -3, 3, 3 },{ -1, 1, -4 },{ 3, 2, 1 },{ 2, 0, -1 },{ -1, -4, -4 },{ -2, 0, -2 },{ 0, 1, -1 },{ -3, -1, -4 },{ -2, 0, -3 },{ 2, -3, 3 },{ 1, 0, 2 },{ -4, 1, -4 },{ 2, 3, -1 },{ -1, -1, -1 },{ -3, -2, -3 },{ -4, -2, 0 },{ 0, -1, 2 },{ -1, 1, 0 },{ -3, 2, -2 },{ -1, -4, 1 },{ -3, 0, -4 },{ 3, 1, 1 },{ -4, 2, 0 },{ -2, -1, -4 },{ 1, 1, -4 },{ -3, -4, -2 },{ 1, 0, 0 },{ -4, -1, -3 },{ -3, -2, -1 },{ 1, 2, -3 },{ -2, 2, -2 },{ 2, 0, 2 },{ -3, -3, 3 },{ 0, 0, -3 },{ -2, 2, 2 },{ 0, -4, 3 },{ 1, 1, -4 },{ -3, -1, -1 },{ 0, 2, 3 },{ -1, -1, -2 },{ 2, 3, 2 },{ -3, -2, -2 },{ 1, 1, -1 },{ -3, 0, 1 },{ -1, -1, 1 },{ 0, 0, -3 },{ -4, -3, 3 },{ -1, -1, -1 },{ 2, -4, -2 },{ 3, 2, -3 },{ -4, -3, 1 },{ 1, 3, -2 },{ -4, -2, 0 },{ -1, 1, 2 },{ 1, 3, 3 },{ -3, -4, -3 },{ 0, 1, 2 },{ -4, 0, -3 },{ -1, 2, 1 },{ -3, 3, -4 },{ 1, -4, -2 },{ -3, 1, 3 },{ -1, -1, 2 },{ 1, 1, -2 } },
+		{ { -4, 0, 2 },{ 1, -2, 1 },{ 0, -4, -2 },{ -4, -2, 3 },{ 3, 1, -3 },{ 1, 3, 0 },{ -4, -2, -3 },{ 0, -4, 2 },{ 3, 2, 0 },{ -3, -1, -2 },{ -3, -3, -3 },{ -1, 2, 0 },{ 0, -1, 2 },{ 3, 0, 2 },{ -2, -4, 1 },{ 2, 1, -1 },{ 2, 3, -4 },{ -2, -3, -3 },{ 1, -2, -2 },{ -4, 2, 2 },{ -2, -1, 2 },{ 2, -3, -3 },{ -3, -3, -1 },{ 3, -2, 3 },{ -2, -1, -1 },{ -4, -4, -2 },{ 2, 2, 1 },{ 0, -3, -4 },{ 3, 0, 0 },{ 2, -1, 1 },{ -3, -3, 3 },{ 3, 1, 0 },{ -1, 3, -1 },{ 1, -1, -4 },{ -4, -2, -2 },{ 2, 0, -1 },{ -4, 3, 0 },{ 1, -3, -2 },{ 0, -2, 2 },{ 3, -4, -1 },{ -2, 2, -4 },{ -4, -1, -3 },{ 1, 1, 0 },{ -1, 3, 3 },{ 2, 2, -4 },{ -4, 3, -1 },{ 2, -4, 0 },{ -1, -2, 2 },{ 1, 0, 3 },{ -2, -1, 1 },{ -1, 1, -1 },{ 2, -2, -4 },{ -3, 0, -3 },{ 3, -3, 1 },{ 1, 0, -4 },{ -2, -1, -2 },{ 2, 2, 1 },{ -1, -2, 0 },{ 2, -3, -3 },{ 1, 0, 2 },{ -1, -3, -1 },{ 3, 2, -3 },{ -2, -2, -4 },{ -3, -3, -1 } },
+		{ { 3, -1, 0 },{ -2, -3, -4 },{ 0, 2, -2 },{ -2, 3, 0 },{ -3, -1, 3 },{ 2, -1, 2 },{ -2, -3, 1 },{ 2, 1, 0 },{ -1, 3, 1 },{ 1, -4, -1 },{ 2, -2, 3 },{ 0, -3, 1 },{ -4, -4, -2 },{ 1, 3, -4 },{ 0, 2, -2 },{ -3, -3, 3 },{ 1, 2, 1 },{ 3, -4, 0 },{ -4, -1, 3 },{ 2, 3, -1 },{ 1, -2, 0 },{ 0, 1, -3 },{ -1, 0, -2 },{ -1, 3, 2 },{ 1, 2, 3 },{ 0, -3, 0 },{ -1, 3, 2 },{ -2, 1, 3 },{ 0, 2, -1 },{ -2, -4, -3 },{ -1, 3, -4 },{ 0, -2, -2 },{ -4, -4, 1 },{ 3, 2, 1 },{ -3, 1, -2 },{ 2, -3, 3 },{ -1, -1, 1 },{ -2, 0, -4 },{ -3, 3, -3 },{ 2, 1, 0 },{ 3, -4, 3 },{ 0, 0, 1 },{ -2, -3, 2 },{ 3, -4, -2 },{ -3, -2, 2 },{ 0, -3, -3 },{ 3, -1, 0 },{ -3, 1, -3 },{ 0, 3, -4 },{ -3, -3, 0 },{ 3, 2, 3 },{ 1, 3, 0 },{ 0, -4, 2 },{ -2, 0, -1 },{ -4, 3, 0 },{ -1, -3, 3 },{ 1, -1, -4 },{ -2, -4, 2 },{ -3, 2, -2 },{ -2, -1, -1 },{ 0, 3, 3 },{ -4, 0, 1 },{ 0, -4, 0 },{ 2, 1, 1 } }
+	},
+	{
+		{ { 3, -4, 2 },{ -4, 0, -3 },{ 1, 3, 0 },{ 2, -2, -1 },{ -4, 3, -4 },{ 1, 0, -2 },{ -1, -3, 3 },{ -2, 2, 1 },{ 1, 0, 0 },{ -4, -2, -3 },{ 3, 1, 2 },{ 2, -3, -1 },{ -3, -4, 1 },{ 3, 1, -3 },{ -2, -2, 1 },{ 0, 2, -4 },{ -4, 0, 2 },{ -1, -3, 1 },{ 2, -1, 0 },{ -3, -3, -3 },{ 3, -4, 2 },{ 0, -1, 3 },{ 1, 0, 0 },{ -4, -4, 1 },{ -1, 1, 2 },{ -4, -1, 3 },{ 3, 2, 0 },{ 0, 1, 3 },{ -4, -2, -3 },{ 1, 2, -3 },{ 3, 0, 3 },{ -4, -4, 1 },{ -1, 0, -1 },{ -2, -3, -3 },{ -1, 3, -2 },{ -1, -2, -2 },{ 1, 2, 0 },{ -1, 0, -1 },{ -2, -4, -4 },{ -2, -2, -2 },{ -3, -4, 0 },{ -1, 1, 3 },{ 3, -4, -3 },{ -2, -3, -4 },{ 2, -4, -2 },{ -3, 1, 2 },{ -1, 2, -1 },{ -4, -2, 2 },{ 1, 2, 0 },{ -3, -1, -2 },{ 1, -4, 2 },{ 3, -2, -2 },{ 1, 1, 3 },{ -1, -3, 1 },{ -3, -1, -1 },{ 1, -3, -4 },{ -4, 1, -1 },{ 0, -2, 2 },{ 3, -4, 1 },{ -3, 3, -3 },{ -2, 2, 0 },{ 0, -2, 3 },{ -3, 3, -3 },{ 2, -3, 1 } },
+		{ { -1, 2, -1 },{ 0, -1, -2 },{ -2, 1, 2 },{ -3, -4, 0 },{ 1, -3, 2 },{ 3, 2, 0 },{ -2, 1, 1 },{ 0, -1, 3 },{ 3, -4, -2 },{ -3, 3, 0 },{ 0, -3, -2 },{ 1, -1, -4 },{ -4, 2, 3 },{ 0, -2, -3 },{ -1, -1, -1 },{ -3, -4, -1 },{ 1, 1, -3 },{ 3, -2, -2 },{ -1, 1, -1 },{ 1, 3, 3 },{ -4, 3, -1 },{ 3, -3, 1 },{ 0, 1, -3 },{ -1, -2, -1 },{ 1, 2, -4 },{ 2, -1, 0 },{ -2, -4, -2 },{ -3, -3, -1 },{ 1, 3, 1 },{ -1, -4, 0 },{ -3, -1, -2 },{ 0, -1, 0 },{ 3, 3, 2 },{ 1, 0, 3 },{ -4, -4, 1 },{ 2, 2, 1 },{ -3, -1, -4 },{ 0, -3, 3 },{ 2, 3, -1 },{ 3, 2, 2 },{ 0, 0, 1 },{ 1, -2, -2 },{ -4, 3, -1 },{ -2, -1, 1 },{ 0, -2, 3 },{ 1, -1, 0 },{ -2, -4, -3 },{ 3, 0, -3 },{ 2, -3, 0 },{ 3, 1, -3 },{ -4, 0, 1 },{ -2, 2, -1 },{ -3, -1, 1 },{ 2, 3, -3 },{ -1, -4, 2 },{ 0, 0, 3 },{ 3, 3, -2 },{ -2, -3, -3 },{ 1, -1, -1 },{ -1, 0, -1 },{ 2, -3, -2 },{ 3, 1, 2 },{ -4, -1, -4 },{ -3, -2, 0 } },
+		{ { 1, 2, 3 },{ 3, -3, -4 },{ -4, -2, 3 },{ 0, -1, -3 },{ -1, 0, -3 },{ 2, -2, -2 },{ -3, 3, -4 },{ 2, -4, -4 },{ -4, 1, -1 },{ 1, -2, 2 },{ -2, 2, 3 },{ -1, 0, -2 },{ 3, 3, 1 },{ -2, 1, 2 },{ 2, -3, 3 },{ 3, 3, -2 },{ -2, 2, 3 },{ -4, -4, 1 },{ -2, 2, -3 },{ -3, -2, -4 },{ -1, 1, -2 },{ -2, -2, -4 },{ 2, 3, 2 },{ -2, -1, 3 },{ 3, -3, 0 },{ -3, -2, -3 },{ 2, 3, 2 },{ 0, 0, -4 },{ 3, 1, -2 },{ -2, -3, 1 },{ 1, 1, 3 },{ -3, 2, -4 },{ 2, -2, -1 },{ 0, -2, -3 },{ -2, 1, 0 },{ 3, -3, -3 },{ -4, -1, 2 },{ 2, -2, -2 },{ -4, 1, 1 },{ -3, -3, -3 },{ 2, 1, -3 },{ -4, -3, 3 },{ 0, 2, -4 },{ 2, 0, 2 },{ 1, 2, -3 },{ -3, 3, 0 },{ 2, -1, -1 },{ 0, 1, 3 },{ -2, 3, -4 },{ 0, -3, 3 },{ -1, 0, 0 },{ 2, -2, -4 },{ -4, 2, -2 },{ 3, -3, -4 },{ -1, 3, 2 },{ -4, -2, -1 },{ 2, 2, -4 },{ -3, -4, 3 },{ -4, 3, 0 },{ 0, 2, 2 },{ -2, -4, -4 },{ -1, 0, 3 },{ 1, 1, -2 },{ -1, -4, 1 } },
+		{ { 0, -1, 1 },{ 2, 0, 0 },{ -3, 2, -1 },{ 2, 3, 1 },{ 0, -3, 3 },{ -4, 0, -1 },{ -1, -3, 2 },{ 1, 2, 3 },{ -1, -1, 0 },{ -3, 0, -3 },{ 3, 1, -4 },{ -4, -4, 0 },{ 1, -1, -1 },{ -1, -2, -3 },{ -4, 2, 0 },{ 2, 0, -4 },{ 1, -1, -1 },{ 0, -1, 2 },{ 2, -2, 0 },{ 0, 0, 2 },{ 2, -4, 1 },{ 1, 2, -2 },{ -4, 0, 1 },{ -3, -4, -4 },{ -1, 2, -2 },{ 0, 0, 2 },{ -2, -2, 1 },{ -3, 2, -1 },{ -4, -2, 3 },{ 2, -1, -4 },{ 3, 3, 2 },{ -2, -3, -2 },{ -4, -4, 0 },{ -3, 1, -4 },{ 0, 0, -1 },{ 1, 3, 3 },{ -2, 1, -4 },{ 1, 3, 0 },{ -1, -4, 3 },{ -1, 0, -4 },{ 1, -1, 0 },{ -2, -4, 0 },{ 3, 0, -1 },{ -1, -2, 2 },{ -4, 1, -2 },{ 3, -4, -4 },{ -4, -3, 1 },{ -1, -2, -2 },{ -3, -2, 1 },{ -4, 3, -1 },{ 2, -1, -2 },{ 0, -4, 2 },{ 0, -2, 3 },{ -2, 1, 0 },{ 1, 0, 0 },{ -3, -1, -2 },{ 1, 1, -3 },{ -1, -3, 0 },{ 1, 0, 1 },{ 3, -1, -3 },{ -4, -2, 1 },{ -2, 3, -1 },{ 3, -1, -3 },{ -4, 3, -3 } },
+		{ { -2, -3, -3 },{ 3, 1, -2 },{ -2, 0, -4 },{ -2, -4, 1 },{ 3, 1, -2 },{ 1, 2, 0 },{ -2, -2, -2 },{ 3, 0, -3 },{ -3, -3, 1 },{ 2, 3, -1 },{ 0, -3, 1 },{ -1, -2, 3 },{ -3, -4, -4 },{ 1, 3, -2 },{ 0, -3, 2 },{ -3, -2, 1 },{ -1, -4, -3 },{ -3, 1, 3 },{ -2, 3, -4 },{ 3, -3, -1 },{ -4, -1, 2 },{ -1, -3, 0 },{ 3, 1, -1 },{ 0, -1, 1 },{ 3, 3, -1 },{ -4, 1, -4 },{ 1, -4, 3 },{ 3, -1, -3 },{ -1, 2, 2 },{ -4, -4, -3 },{ 0, 1, -1 },{ -1, 0, 1 },{ -1, -1, 3 },{ 1, 3, 2 },{ 3, -2, -2 },{ -1, -3, 1 },{ -3, -4, -3 },{ 0, 2, -1 },{ -2, -1, -2 },{ 3, -2, 2 },{ -3, 3, -1 },{ 0, 2, 3 },{ -3, 1, -2 },{ 2, -4, -4 },{ -2, -3, 3 },{ 1, 3, 1 },{ -1, 0, 2 },{ 0, 2, -4 },{ 1, 1, 2 },{ 3, -4, -1 },{ 1, 1, -3 },{ -2, 3, 1 },{ -3, -3, -2 },{ 3, 2, -3 },{ 0, -4, 3 },{ -4, 1, 1 },{ 0, -2, 2 },{ 3, 0, 2 },{ 0, 2, -2 },{ -3, 1, -4 },{ 2, -4, 3 },{ 1, 2, -1 },{ 2, -2, 2 },{ -3, -3, 0 } },
+		{ { 1, 0, 3 },{ -4, -4, 2 },{ 1, -2, 2 },{ -1, 3, -1 },{ -4, -1, -4 },{ -3, -4, 2 },{ 0, 0, 0 },{ 1, 3, -1 },{ 0, -4, 3 },{ -4, -1, -4 },{ 3, 2, -2 },{ -2, 0, 0 },{ 2, 2, 2 },{ -4, 1, -1 },{ 3, -3, 3 },{ -2, 0, -4 },{ -1, 2, 0 },{ 3, 1, -1 },{ -1, -3, -3 },{ 1, 2, -2 },{ -2, 0, 3 },{ -3, 3, -3 },{ 1, -2, -3 },{ -2, -3, 3 },{ -1, -1, 0 },{ 2, -3, -2 },{ -3, 2, 1 },{ 0, -4, -1 },{ 1, 0, 0 },{ -2, -2, -2 },{ -3, 3, 0 },{ 1, -3, 2 },{ 3, 2, -3 },{ 2, -4, -1 },{ -3, 2, 1 },{ -4, -1, 2 },{ 3, 0, 0 },{ 1, -2, -2 },{ -4, 2, 1 },{ 0, -3, 2 },{ 2, -3, -3 },{ -4, -2, -3 },{ -1, 3, 1 },{ 0, -1, 0 },{ -2, 2, -3 },{ 0, -1, -2 },{ 3, 2, -1 },{ 2, -4, 0 },{ -2, -3, -3 },{ -3, -1, 3 },{ -3, 2, 0 },{ -1, 1, 2 },{ -4, 0, -4 },{ 1, -1, 1 },{ 2, -3, -2 },{ -2, 3, -1 },{ 2, -4, -4 },{ -2, -2, -1 },{ -4, 3, -3 },{ -1, -3, 0 },{ -2, -3, 1 },{ -4, 1, -2 },{ 0, 0, -4 },{ -1, 2, 1 } },
+		{ { -1, -1, -2 },{ 0, 3, -3 },{ 1, -2, 0 },{ 2, 1, 0 },{ -1, -3, 3 },{ 1, 2, -3 },{ 3, -1, -4 },{ -4, 1, 1 },{ -1, 2, -1 },{ -2, -2, -2 },{ 1, 1, 2 },{ -3, -2, -3 },{ 0, 0, -1 },{ -1, -1, 1 },{ 2, 3, -3 },{ -3, 0, -2 },{ 2, -1, 2 },{ 1, -4, 1 },{ -4, -2, 3 },{ 2, 3, 0 },{ 0, -1, 1 },{ 1, -4, 2 },{ 2, 1, -4 },{ -4, 2, 0 },{ 1, -2, 3 },{ -1, 3, -3 },{ -2, 0, -4 },{ 2, 1, 0 },{ 0, 3, 2 },{ 2, -2, -4 },{ 3, -3, 3 },{ -4, 1, -3 },{ -2, -1, -2 },{ -3, -2, -2 },{ 0, 3, -4 },{ -1, -4, -1 },{ 2, 1, 3 },{ -1, -2, 3 },{ -4, 3, -4 },{ 2, 0, 0 },{ -2, 1, 2 },{ 1, -1, -2 },{ 3, 0, 2 },{ -4, -3, -1 },{ 3, 0, -1 },{ -3, -2, 2 },{ -4, -2, 0 },{ -3, 3, 3 },{ 1, 0, -2 },{ 0, -1, -4 },{ 3, -3, -2 },{ 2, -2, 3 },{ 3, -2, -1 },{ -1, 3, 2 },{ -3, -1, 0 },{ -4, 2, -4 },{ 2, 0, 3 },{ -3, -3, -2 },{ 3, 1, 3 },{ 1, -1, -1 },{ 0, 3, 0 },{ 3, -1, -3 },{ -3, -4, 2 },{ 2, 3, -1 } },
+		{ { 3, -3, -4 },{ -4, 1, 2 },{ -3, -3, -3 },{ 3, -1, -2 },{ -3, 2, 1 },{ 0, -4, -2 },{ -2, -2, 2 },{ 2, -3, 2 },{ 2, -2, -4 },{ -1, 0, 3 },{ -4, -4, 0 },{ 2, 3, 1 },{ -2, -4, -4 },{ 1, -3, 0 },{ -4, 2, 3 },{ 0, -4, 0 },{ 1, 3, -1 },{ -4, -2, -4 },{ -3, 0, -2 },{ 3, -4, -4 },{ 0, 1, -1 },{ -3, -2, -3 },{ -2, 0, -1 },{ -4, 1, -2 },{ 2, -4, 2 },{ 3, -2, 1 },{ -3, -3, -1 },{ -4, -1, 3 },{ -3, -4, -2 },{ -1, 2, -4 },{ -1, 0, 1 },{ 0, -2, 1 },{ -4, 2, 0 },{ 1, -3, 3 },{ 2, 0, -4 },{ -2, 1, 0 },{ 1, 3, -3 },{ 2, -3, -3 },{ -3, -1, 1 },{ 3, -4, -1 },{ -2, 3, -4 },{ -3, -4, 1 },{ 2, -2, 0 },{ -1, 3, 3 },{ 1, 1, -4 },{ 2, 0, 1 },{ -2, -4, -3 },{ -1, 1, -4 },{ 3, -3, -1 },{ -1, 3, 1 },{ -4, 2, 0 },{ -2, -4, -3 },{ 0, 1, -2 },{ -2, 0, -4 },{ 1, -4, -1 },{ -1, 1, 2 },{ 0, -2, 0 },{ -1, 3, 1 },{ 2, 1, 2 },{ -4, -4, -4 },{ 2, 0, 2 },{ -2, 2, -2 },{ 1, -2, 3 },{ -3, 1, 0 } },
+		{ { 2, 2, 1 },{ 0, -2, 3 },{ -2, 2, -1 },{ -1, 0, -4 },{ 2, 3, -1 },{ -2, -2, 3 },{ -4, 1, -3 },{ 1, 3, 0 },{ -3, 2, -2 },{ 3, -3, -1 },{ 0, 2, -3 },{ 3, 1, 2 },{ -1, -1, -3 },{ 0, 0, 3 },{ -2, -3, -2 },{ 3, -2, -3 },{ 0, 1, 2 },{ -2, 3, 2 },{ -1, 0, 0 },{ -2, 2, 1 },{ -4, -3, 3 },{ -1, 2, 1 },{ 3, -3, 3 },{ 0, 3, -1 },{ 0, -1, -4 },{ -2, 1, -3 },{ -1, 2, 0 },{ 1, -3, -3 },{ 3, -1, 2 },{ 1, 1, -1 },{ -3, 3, 3 },{ 2, -4, -1 },{ 3, -1, -3 },{ -1, 1, 2 },{ 0, -4, 1 },{ -4, -2, 2 },{ -3, -1, -2 },{ -2, 2, 0 },{ 0, 0, -2 },{ -1, 1, 3 },{ 1, -1, -2 },{ 0, 2, 3 },{ -2, 2, -4 },{ 0, -3, -3 },{ -4, -4, -2 },{ -1, 3, 3 },{ 0, 2, -2 },{ 1, -1, 2 },{ -4, -2, 3 },{ 2, 0, 2 },{ 1, 2, -3 },{ 0, -1, 1 },{ -3, -4, 3 },{ 3, 2, 1 },{ -4, -3, 3 },{ 3, -1, -3 },{ 1, 0, -2 },{ -2, -1, -3 },{ 0, -3, -4 },{ -2, -2, 0 },{ -3, 2, 1 },{ -1, -3, -3 },{ 1, -1, -1 },{ -4, -4, -4 } },
+		{ { -1, 3, -2 },{ 0, 0, 2 },{ 2, -4, 0 },{ -4, -4, 2 },{ 1, 1, 1 },{ 3, -1, 0 },{ 0, 0, -4 },{ -3, -1, -1 },{ -1, -4, 1 },{ 1, 0, 1 },{ -2, -1, 3 },{ -3, -3, -2 },{ -4, 2, -1 },{ 2, 3, 1 },{ -4, 1, 0 },{ -3, -1, -4 },{ -2, 2, -1 },{ 2, -3, 0 },{ 1, -1, -3 },{ 3, -4, -2 },{ 2, 3, 2 },{ -3, -1, -2 },{ 1, -3, -4 },{ -2, 0, 2 },{ -3, -4, 1 },{ 2, 3, 0 },{ 3, 0, 3 },{ 0, 0, 1 },{ 0, 3, -3 },{ -2, -2, 0 },{ -3, -4, -2 },{ 3, 0, -4 },{ -2, 3, 3 },{ -3, 0, -2 },{ 1, -2, 0 },{ 3, 3, -1 },{ 3, -3, 3 },{ -1, 0, -1 },{ 1, -4, 2 },{ -4, -2, 0 },{ 3, -3, -3 },{ 2, 0, 1 },{ -4, -1, 2 },{ -3, 1, -1 },{ 1, -2, 1 },{ 2, 0, 0 },{ -2, -3, -3 },{ 3, 2, 0 },{ -3, 1, -1 },{ -1, -4, 0 },{ -2, -2, -4 },{ -4, 3, -2 },{ 1, -1, 0 },{ 2, 0, -1 },{ 0, 2, -4 },{ -3, 3, -2 },{ -2, -3, 3 },{ 2, 2, 0 },{ -4, -4, -1 },{ 3, 0, 3 },{ -1, 3, -2 },{ 3, 0, -1 },{ 0, 1, 3 },{ -2, -1, 1 } },
+		{ { -3, -1, -3 },{ 3, -3, -1 },{ -2, -1, -3 },{ 1, 3, -4 },{ -3, -2, 1 },{ -1, -3, -2 },{ 3, -3, 2 },{ -1, 3, -3 },{ 2, -2, 3 },{ -4, 3, -3 },{ 1, 1, 0 },{ 0, -3, -4 },{ 3, -2, 2 },{ -1, -4, -4 },{ 1, 0, -1 },{ 3, -4, 3 },{ 2, 0, 1 },{ -4, -3, -3 },{ 0, 1, 3 },{ -4, 2, -4 },{ 0, 0, -1 },{ 2, -2, -3 },{ 0, 1, 0 },{ -4, 2, 1 },{ 2, -1, -1 },{ -1, -2, -2 },{ -4, -4, -4 },{ -2, 2, -1 },{ -4, -3, 2 },{ 2, 1, -3 },{ 0, -1, 1 },{ -4, -3, 2 },{ 0, -3, 0 },{ -1, 1, -4 },{ 2, -1, -3 },{ -3, 2, -3 },{ -4, -4, 1 },{ 2, 1, -4 },{ -2, 2, -4 },{ -4, 3, 2 },{ -3, 1, -1 },{ 2, -3, -3 },{ -1, -4, -1 },{ 3, 3, 1 },{ 2, -1, 3 },{ -3, -1, -4 },{ -4, -4, 2 },{ 0, -1, -2 },{ -3, 3, -4 },{ 2, -4, -2 },{ 0, 1, 3 },{ 3, -3, 0 },{ -1, 1, 2 },{ -3, -2, -3 },{ -1, -2, 2 },{ -2, -4, 1 },{ 3, 1, 2 },{ -3, 1, 0 },{ 1, 3, -3 },{ 0, -1, 2 },{ -4, -2, -4 },{ 2, -4, 0 },{ -4, 3, 2 },{ 1, -3, -4 } },
+		{ { 1, 0, 0 },{ -4, 2, 3 },{ 3, -2, -2 },{ 0, 1, 3 },{ -1, 2, -2 },{ -4, -4, -4 },{ -2, 1, 3 },{ 2, 2, -2 },{ -4, -4, 1 },{ 3, -2, -4 },{ -2, 1, -2 },{ -1, 0, 3 },{ -3, 2, 1 },{ 2, -2, -2 },{ -2, 3, 2 },{ -1, -2, -3 },{ -1, -1, -2 },{ -3, 3, 1 },{ 3, -2, 2 },{ -1, -1, 0 },{ -2, -4, 1 },{ -2, -2, 0 },{ 3, 3, 3 },{ -1, -3, -3 },{ 1, 1, -4 },{ 0, 2, 3 },{ -3, -1, 2 },{ -2, -2, -2 },{ 2, -4, 0 },{ 3, 0, 3 },{ -1, 3, -4 },{ 1, 2, -1 },{ 2, -2, -1 },{ -4, 2, 3 },{ -1, -4, 1 },{ 0, -1, 2 },{ -1, 0, -1 },{ 1, 2, 3 },{ 3, -2, -3 },{ -1, -3, -2 },{ 0, -1, 3 },{ 0, 2, 0 },{ -2, 0, -2 },{ 1, -2, 0 },{ -1, 2, -4 },{ -3, 1, -1 },{ 3, 3, 1 },{ 2, -2, 2 },{ 1, 0, -3 },{ -2, -2, 1 },{ -1, 3, 3 },{ -3, -3, -4 },{ 2, 2, -1 },{ 1, -4, 1 },{ -4, 3, -2 },{ 0, -1, -1 },{ 2, -2, -4 },{ -4, 0, -3 },{ -1, -1, -2 },{ 2, -4, 1 },{ -2, 1, 3 },{ -1, -2, -3 },{ -3, -3, -2 },{ 3, 2, 0 } },
+		{ { 0, -4, -4 },{ -1, 1, 1 },{ -2, 3, -1 },{ -3, -3, 0 },{ 3, 0, 2 },{ 1, 2, -1 },{ -3, 0, 0 },{ 1, -1, 0 },{ -1, 1, -1 },{ 0, -1, 2 },{ -3, -4, 0 },{ 3, 3, -1 },{ 1, 1, -3 },{ -4, -3, 1 },{ 0, 1, 3 },{ 0, 2, 0 },{ -3, 1, -4 },{ 2, -3, -1 },{ 1, 2, -2 },{ -4, 1, -2 },{ 0, 2, 3 },{ -3, 1, -4 },{ 2, -4, -2 },{ -4, 0, 2 },{ -2, 2, -1 },{ 3, -3, 0 },{ 2, 0, -3 },{ -1, 3, 2 },{ 1, 1, -4 },{ -1, -1, -1 },{ -3, -3, 2 },{ 0, 2, 1 },{ -2, -2, -3 },{ 3, 0, -2 },{ -3, -3, 1 },{ 1, 3, 0 },{ -2, -2, -3 },{ -3, -3, 0 },{ 0, 0, 1 },{ 2, -4, 0 },{ 3, 3, 2 },{ -3, 1, -4 },{ -2, -2, 3 },{ -4, 2, -3 },{ 0, -4, 2 },{ -1, -3, -2 },{ -2, 1, -1 },{ -1, -4, 3 },{ -4, 2, 0 },{ 3, 0, 1 },{ 2, -1, -1 },{ -4, -2, -3 },{ 1, 1, 0 },{ -2, -1, 3 },{ 3, 0, -2 },{ 1, 3, 0 },{ 2, 2, 1 },{ 0, -4, 3 },{ -2, -2, 2 },{ 0, 3, -1 },{ 1, 2, -4 },{ 3, -1, -2 },{ 0, 1, 3 },{ -2, 3, 2 } },
+		{ { 2, -1, -4 },{ -4, 0, 3 },{ 2, -4, -3 },{ 0, -2, -3 },{ 2, -3, 1 },{ -2, -1, -4 },{ 3, -2, 3 },{ 0, 3, -3 },{ -3, -3, -4 },{ 2, -3, -2 },{ -1, 3, 2 },{ 1, -2, 3 },{ -2, -1, -3 },{ -4, -3, -1 },{ 1, -1, -4 },{ 3, -4, -2 },{ -4, -2, 3 },{ 0, -4, 2 },{ -2, 0, -4 },{ 3, -3, 1 },{ 1, -3, -3 },{ -1, -1, -1 },{ 1, 3, 3 },{ 0, -4, 1 },{ -3, -2, -2 },{ 1, 0, -4 },{ -4, -4, 0 },{ 3, -2, 1 },{ -3, 2, -1 },{ -4, 0, -2 },{ 1, -4, -3 },{ -4, 1, 3 },{ 2, -4, 0 },{ 1, -1, -4 },{ -2, 1, 3 },{ 3, 2, -4 },{ -4, -2, -1 },{ 2, 3, -2 },{ -2, -1, 3 },{ -4, 1, -4 },{ -1, -2, 1 },{ 1, -1, -2 },{ 2, -4, 1 },{ -4, 3, -3 },{ 2, -1, 3 },{ 3, 0, 1 },{ 1, -3, -4 },{ 1, -1, -2 },{ -1, 1, -3 },{ 0, -3, -1 },{ -2, 3, 2 },{ -3, 2, -2 },{ 0, 0, -4 },{ -1, -4, 3 },{ -2, -3, -3 },{ -4, -2, -4 },{ -3, -3, 0 },{ -1, 2, -1 },{ 3, 0, -3 },{ -4, -3, 1 },{ -3, 2, 0 },{ 2, 0, 1 },{ -4, -4, -3 },{ -1, -2, -1 } },
+		{ { 3, 3, 2 },{ -3, -3, -2 },{ 1, 2, 0 },{ -3, 3, 2 },{ -2, 1, -2 },{ -4, 3, 1 },{ 0, -4, -2 },{ -4, 2, 2 },{ -2, 0, 3 },{ 2, 2, -3 },{ -4, 0, 1 },{ 0, -4, -4 },{ -3, 0, -1 },{ 2, 3, 0 },{ -2, 2, 2 },{ 2, 0, 1 },{ -2, 3, -1 },{ 1, -1, 0 },{ 3, 0, -2 },{ -3, 2, 3 },{ -2, 3, 2 },{ 2, -1, 0 },{ -4, 0, -4 },{ 3, 2, -2 },{ 2, -1, 2 },{ -1, 3, 3 },{ -2, 2, -1 },{ 0, 1, 3 },{ -2, -3, -3 },{ 2, -2, 3 },{ 3, 0, 0 },{ -2, 3, -2 },{ -1, 3, 1 },{ -3, 0, 2 },{ 0, -4, -2 },{ 2, 1, -1 },{ 1, -4, 2 },{ 0, -1, 1 },{ 1, 3, -3 },{ -2, 0, -1 },{ -3, -4, -3 },{ 0, 2, 2 },{ 3, 0, -1 },{ -2, -3, 0 },{ 0, 1, -4 },{ -3, 2, -1 },{ -4, 3, 2 },{ -3, -2, 2 },{ 2, 2, -3 },{ -4, -4, -4 },{ 3, -2, 3 },{ 0, -4, 0 },{ 2, 3, 2 },{ -4, -2, -1 },{ 3, 2, 1 },{ -1, 1, 2 },{ 1, -1, 3 },{ 3, 3, -2 },{ -3, 1, -1 },{ 1, -4, -4 },{ -2, -1, 2 },{ -1, -3, -1 },{ 1, 2, 3 },{ -3, -2, 0 } },
+		{ { -1, 1, 1 },{ 2, -1, -4 },{ 0, -1, -1 },{ -1, 0, 3 },{ 0, -3, -4 },{ 2, 1, 0 },{ 2, -2, -3 },{ -1, -4, 1 },{ 1, -2, -1 },{ 3, -1, 0 },{ -2, 2, -2 },{ -1, 1, 2 },{ 3, 2, 3 },{ -1, -2, -3 },{ -1, -4, -2 },{ -3, 0, -3 },{ 0, -2, 3 },{ -4, 3, -3 },{ -1, 1, -4 },{ 1, -4, 1 },{ -4, -2, -1 },{ -1, -2, -3 },{ 0, 1, 1 },{ -2, 1, 0 },{ -3, -3, -1 },{ 1, -3, -3 },{ -4, -1, -2 },{ 2, -1, -4 },{ 1, 3, 1 },{ 0, -2, 2 },{ -2, 1, -4 },{ 2, -3, -1 },{ 0, -1, -3 },{ 1, -2, 0 },{ -1, 2, -2 },{ -3, 0, 3 },{ -4, -2, -4 },{ -1, 2, 0 },{ 3, -3, 2 },{ 2, 1, -1 },{ -4, -3, 3 },{ -1, 3, -4 },{ 1, 0, -2 },{ -3, 1, 3 },{ -1, -2, 1 },{ 1, -4, -3 },{ 3, 2, 0 },{ -1, -1, 3 },{ -2, -4, -1 },{ 1, 0, 1 },{ 1, 0, 1 },{ -1, -1, -2 },{ -3, -3, -3 },{ 2, 2, -1 },{ 1, 0, -3 },{ 0, -4, 1 },{ -2, 0, -4 },{ -3, -3, 1 },{ 2, -2, -2 },{ 0, 1, 3 },{ -1, 0, 1 },{ 3, 3, -3 },{ -4, 0, -2 },{ 1, 1, -3 } },
+		{ { -2, -4, 3 },{ -4, 2, 2 },{ 3, -4, 1 },{ -4, -2, -3 },{ 3, 0, 0 },{ -1, -1, 3 },{ -3, 0, -1 },{ 3, 1, -4 },{ -3, 3, 1 },{ -4, -2, 3 },{ 2, -4, -2 },{ 1, -3, -4 },{ 2, -1, 0 },{ -3, -1, 3 },{ 1, -3, -1 },{ 3, 2, 2 },{ 2, -3, 1 },{ -3, -3, -1 },{ -1, -1, -2 },{ 2, 2, 2 },{ 0, 0, -3 },{ 3, -3, 0 },{ 1, -4, 3 },{ -3, 3, -3 },{ 0, -2, 1 },{ 3, 1, 1 },{ -2, -4, 0 },{ -1, 1, 2 },{ -3, -3, -2 },{ 3, 2, 0 },{ -1, -1, 1 },{ -4, -4, -3 },{ -4, 2, 2 },{ 3, -3, 2 },{ -4, -2, -3 },{ 2, 3, 1 },{ -1, -3, -2 },{ -2, 1, 3 },{ -3, -4, -2 },{ 2, -2, -2 },{ 0, -1, 1 },{ 3, -2, 0 },{ -2, -4, 2 },{ 2, 2, -4 },{ -4, -1, -1 },{ -2, -3, 2 },{ 0, 0, -4 },{ 3, -3, 0 },{ -2, 3, -2 },{ 0, 1, 0 },{ -4, 2, -4 },{ -3, 3, 2 },{ 1, 1, 3 },{ -2, -3, 1 },{ -4, 1, -4 },{ 2, -2, -2 },{ -1, 3, -1 },{ 1, -4, 2 },{ -4, -1, -3 },{ 0, 3, 0 },{ 3, -2, -2 },{ -2, -4, -4 },{ 2, -2, 2 },{ 0, -3, -1 } },
+		{ { -1, 3, -4 },{ 0, -2, -1 },{ 1, 2, -2 },{ -2, 3, -4 },{ 1, -4, 1 },{ -4, 2, 2 },{ 0, 3, -2 },{ -2, -3, 2 },{ 1, -1, -3 },{ -1, -3, 0 },{ 0, 3, -3 },{ -3, 1, -1 },{ -4, -3, 1 },{ -2, 1, -4 },{ 0, 3, 1 },{ -4, 1, -3 },{ -2, -1, -4 },{ -2, 1, 0 },{ 3, -4, 3 },{ 1, -2, 2 },{ -3, 2, -4 },{ -2, 3, -2 },{ -1, -1, 3 },{ -4, -2, -4 },{ 2, 2, -1 },{ 0, 0, 3 },{ 1, 3, -3 },{ -4, 0, -3 },{ 0, -1, 3 },{ -3, -4, -4 },{ 1, 1, -1 },{ -1, 3, 1 },{ 3, -1, 3 },{ -2, 1, -4 },{ 0, 2, -1 },{ 1, -4, 0 },{ 3, -1, -3 },{ 2, 3, -4 },{ 1, 0, 1 },{ -1, 2, -4 },{ -4, 1, 3 },{ 0, 2, -3 },{ -3, -3, -1 },{ 3, 3, 1 },{ 2, -1, -2 },{ 0, 2, -2 },{ -3, 1, -1 },{ 2, -2, 1 },{ -4, -1, -3 },{ 3, -2, 3 },{ 2, -1, -3 },{ -1, -4, -1 },{ 3, -2, 0 },{ -2, -1, -2 },{ 0, 3, 3 },{ -3, -1, 0 },{ 3, 0, 2 },{ -1, 2, -3 },{ 3, -3, 0 },{ -2, 2, 3 },{ -4, -3, -1 },{ -3, 1, 1 },{ 1, 2, 1 },{ -3, 0, -2 } },
+		{ { 2, -1, -3 },{ -3, 0, 0 },{ 1, 1, 3 },{ -3, -3, -3 },{ -2, 1, 0 },{ 0, -2, -3 },{ 2, -3, -1 },{ -4, 2, 3 },{ 0, 1, -4 },{ 3, 0, -1 },{ -2, 0, 2 },{ 1, 2, 1 },{ 3, -1, 2 },{ 2, 3, -2 },{ -1, -4, 0 },{ 0, -2, -1 },{ 3, 2, 2 },{ 1, -3, 1 },{ -1, 3, -3 },{ -4, 1, -1 },{ -2, -3, 0 },{ 2, -1, 1 },{ 3, 0, -1 },{ 1, -3, -2 },{ -2, 1, 2 },{ -1, -4, -4 },{ 2, -2, -1 },{ 3, -3, 0 },{ -2, 3, 1 },{ 2, 0, -1 },{ 0, -2, 3 },{ -3, 0, -3 },{ 2, -4, -1 },{ 0, 0, -2 },{ -2, 3, 1 },{ -3, -1, 2 },{ -4, 1, 3 },{ -2, -2, 0 },{ 0, -1, -1 },{ -3, -4, 0 },{ 3, 3, 2 },{ -4, -4, -1 },{ 1, -1, -3 },{ -1, 0, 1 },{ -4, -4, 3 },{ -1, -2, 3 },{ -2, 3, -4 },{ 1, -4, 2 },{ -3, 2, -2 },{ 0, -3, 3 },{ -2, 1, 2 },{ -3, -3, -1 },{ 1, 2, -4 },{ 3, 0, -3 },{ 0, -4, 2 },{ -4, -3, -2 },{ 2, 2, -4 },{ -3, 1, 1 },{ -3, -1, -1 },{ 1, -4, -4 },{ 2, 0, 3 },{ -1, -1, 2 },{ 0, 3, -1 },{ 3, -3, 0 } },
+		{ { -4, -2, 2 },{ 3, 3, 1 },{ -1, -2, -1 },{ 2, -1, 3 },{ 3, 2, 2 },{ -1, 0, -2 },{ 2, -4, 1 },{ -2, -1, -4 },{ 3, 2, 0 },{ -3, -4, 3 },{ -4, -2, -2 },{ -1, -4, -4 },{ 0, 0, -3 },{ -3, -2, 3 },{ -3, 0, -3 },{ 2, -2, 3 },{ -4, 3, -4 },{ 0, 0, -2 },{ -3, 0, 1 },{ 1, -2, -4 },{ 0, 2, -3 },{ -3, 3, 2 },{ 0, -4, 1 },{ 0, -2, -4 },{ -4, 3, 1 },{ -3, -1, -2 },{ -3, 2, 2 },{ 0, -4, 2 },{ -4, 2, -4 },{ -2, -3, -2 },{ 3, -2, 2 },{ -3, 3, -4 },{ -1, 1, 0 },{ 2, -3, 2 },{ -1, -4, -3 },{ 3, -2, -4 },{ 0, 2, -1 },{ -4, -3, -2 },{ 3, 2, 2 },{ -1, 0, -3 },{ 1, -2, -2 },{ -2, 0, 1 },{ 0, 1, -4 },{ -3, -3, 0 },{ 0, 2, -3 },{ 2, 0, 0 },{ 1, 1, -3 },{ 3, -1, -1 },{ -1, 0, 1 },{ 1, 3, -4 },{ 0, -1, 0 },{ 2, 2, 1 },{ -4, 0, 3 },{ -1, -2, 2 },{ 2, 3, 1 },{ -2, 1, -1 },{ 0, -4, 3 },{ 1, -2, 2 },{ -1, 3, 1 },{ 0, 1, -2 },{ -1, 1, -1 },{ 2, -2, -3 },{ -4, -4, -4 },{ -2, 1, 3 } },
+		{ { -2, -3, -3 },{ 0, -4, -2 },{ -4, 1, -4 },{ -2, -4, -1 },{ -4, -3, -2 },{ 1, 3, -3 },{ -3, 1, 2 },{ -3, -1, 0 },{ 0, -2, -2 },{ 1, 3, -1 },{ -4, -3, 1 },{ 2, 2, -1 },{ -2, 1, 0 },{ 1, -3, -2 },{ 3, -1, 0 },{ -1, -4, 2 },{ -3, 1, -2 },{ 0, -4, -1 },{ 3, -1, 3 },{ 2, -3, 2 },{ -1, -4, -1 },{ 3, 1, 3 },{ -4, 0, -3 },{ -1, 2, 0 },{ 3, -3, 3 },{ 2, 1, -1 },{ -1, -1, -3 },{ 1, 1, 1 },{ 1, 0, -2 },{ -1, -1, 2 },{ 2, 2, 0 },{ -4, -4, -2 },{ 1, -1, 1 },{ -4, -1, 3 },{ -3, 2, -2 },{ 2, -3, 0 },{ -1, 1, 2 },{ 2, 3, -3 },{ 1, -1, 3 },{ -3, -3, 1 },{ 2, 1, -2 },{ -1, 2, 3 },{ 3, -2, 2 },{ 2, 3, -1 },{ -2, 1, 2 },{ -4, -2, -1 },{ -3, -3, 1 },{ -1, -4, 3 },{ -4, 2, -1 },{ -3, -2, -3 },{ -2, -4, -2 },{ 2, 3, -4 },{ -1, -1, -2 },{ -3, -4, -1 },{ -3, 2, -3 },{ 3, -1, -4 },{ -1, -2, -2 },{ -4, 0, -3 },{ 3, -3, -4 },{ -4, 2, 2 },{ -2, -1, -3 },{ 3, -3, 1 },{ 0, 3, -2 },{ 1, 2, 0 } },
+		{ { -1, -1, 2 },{ 1, 0, 1 },{ 2, 3, 0 },{ 0, 0, -4 },{ 3, -2, 1 },{ -1, 2, 3 },{ -2, 0, -1 },{ 3, -4, 2 },{ 0, 2, -3 },{ -1, 0, 2 },{ 1, 1, -4 },{ 3, -2, 3 },{ -2, -1, 1 },{ -4, 3, -4 },{ 1, 2, -1 },{ -2, 2, 1 },{ 2, -3, 0 },{ -2, 3, -3 },{ -4, 2, 0 },{ -2, 1, -2 },{ -4, -1, 0 },{ -2, -2, -2 },{ 2, -1, -4 },{ -2, 2, -2 },{ 1, 0, 3 },{ -2, -2, -3 },{ 3, -3, -4 },{ -4, 3, 3 },{ 2, -4, -1 },{ -2, -2, -3 },{ -1, 1, 1 },{ 0, -3, -4 },{ 3, 2, -1 },{ 0, 3, -3 },{ 1, 0, 3 },{ -2, -1, -2 },{ -3, 0, 1 },{ -1, -4, -1 },{ -2, -2, -4 },{ -4, 3, 0 },{ 3, -4, -4 },{ -4, -1, 0 },{ 1, -4, -2 },{ -3, -3, -4 },{ 1, -1, -3 },{ 3, -4, 3 },{ 0, 3, -2 },{ -2, 0, -4 },{ 2, 0, 0 },{ 3, -2, 2 },{ -2, 1, 1 },{ -4, -3, 3 },{ 0, 0, 0 },{ 3, -2, 0 },{ 1, 1, 1 },{ -2, 3, 3 },{ 0, -3, 0 },{ 2, 3, -1 },{ -3, 0, 3 },{ 2, -2, 0 },{ 1, -4, 0 },{ -3, 0, 3 },{ -3, 0, 1 },{ 2, 1, -4 } },
+		{ { -4, 2, -1 },{ -3, -3, -3 },{ 3, -1, 3 },{ -3, 2, 1 },{ -4, -1, 2 },{ 1, -3, -4 },{ 2, 0, 0 },{ -4, -2, -4 },{ 2, 3, 3 },{ -2, -3, -3 },{ -3, -1, 0 },{ 3, 2, -3 },{ 0, 0, 3 },{ 0, -4, 2 },{ -4, 1, -3 },{ 1, -2, -4 },{ 3, -1, 2 },{ -1, 1, -3 },{ 3, -2, 2 },{ -1, 0, -4 },{ 1, 3, 1 },{ 1, -3, 2 },{ 2, 1, 2 },{ -3, -3, -1 },{ 0, -4, 1 },{ -1, 3, 0 },{ -4, 0, 2 },{ 0, 1, -2 },{ -3, -2, 0 },{ 3, 3, -4 },{ -4, 2, 3 },{ 1, -4, 0 },{ -3, 0, 2 },{ -2, -2, 1 },{ 3, -4, -4 },{ 0, 1, -1 },{ -4, 3, -4 },{ 3, -2, 2 },{ 0, 2, 3 },{ 0, 1, -2 },{ 0, -1, 1 },{ -2, 3, -3 },{ -1, 0, 2 },{ -2, 2, 1 },{ -1, 0, 0 },{ 2, 2, 1 },{ -4, 1, -4 },{ 0, -3, 0 },{ 1, 2, 2 },{ -1, 3, -3 },{ 1, -4, -1 },{ 3, 1, -4 },{ -1, 3, 2 },{ -2, -4, -3 },{ 2, -3, -2 },{ -4, 0, 2 },{ 1, 1, 0 },{ -1, -4, -3 },{ -2, 1, 1 },{ -2, -1, -2 },{ 3, 3, -4 },{ -4, 2, -2 },{ 0, -2, 3 },{ 1, -4, -1 } },
+		{ { 3, 0, 3 },{ -1, -3, 0 },{ 0, -2, -2 },{ -1, 1, -1 },{ -2, -4, -2 },{ 1, 3, -3 },{ 0, 2, 0 },{ -3, -3, -2 },{ 1, 1, 1 },{ -1, -1, 1 },{ -4, -4, -1 },{ 1, 3, -2 },{ -3, -4, -1 },{ -1, -3, -2 },{ 2, 0, 0 },{ -1, 3, 3 },{ -3, -4, 1 },{ -3, 0, -1 },{ 0, -2, 3 },{ 2, -4, -1 },{ -3, 3, -4 },{ -2, -4, 0 },{ -1, 0, -3 },{ 3, 3, -2 },{ -4, -1, -4 },{ 2, 2, 1 },{ -2, -2, -3 },{ -1, 0, -1 },{ 1, -4, 1 },{ 0, 0, 3 },{ -2, -2, -1 },{ 3, 1, -3 },{ -3, 3, -1 },{ -1, -2, -3 },{ 1, -3, 2 },{ -4, 2, 3 },{ 3, -1, 0 },{ 2, -4, -2 },{ -2, 0, 0 },{ 1, -3, 2 },{ -3, -3, -1 },{ 3, 2, -1 },{ 1, 1, 3 },{ -4, -2, 0 },{ 3, -3, -3 },{ -3, -1, 3 },{ -2, -1, -1 },{ 2, -3, -2 },{ 3, -2, 3 },{ -3, -1, -2 },{ 0, -3, 1 },{ 1, -1, -1 },{ -4, 2, 3 },{ -3, -1, -2 },{ 0, 2, -4 },{ -1, -1, 3 },{ 2, -4, -4 },{ -4, 2, -2 },{ 1, -2, 2 },{ 0, -3, -3 },{ -1, 2, 2 },{ 1, -1, -1 },{ 3, -3, -3 },{ -2, 1, 0 } },
+		{ { 2, 3, 2 },{ -2, 2, -4 },{ -4, -4, 2 },{ 2, 3, -3 },{ -3, -3, -1 },{ 3, -1, 1 },{ -1, 1, 3 },{ -3, -4, 2 },{ 0, 0, -1 },{ 3, 3, -4 },{ 2, -3, 3 },{ -2, 1, 2 },{ -3, 2, 1 },{ 3, -1, -4 },{ 2, -2, -1 },{ -4, -3, -2 },{ 0, 2, -2 },{ 1, -3, -4 },{ -4, -1, 1 },{ -3, 2, -3 },{ 3, 0, 3 },{ 0, -2, -1 },{ -4, 2, 2 },{ -3, 1, 1 },{ 1, -2, 3 },{ 2, -4, -1 },{ 0, 1, 2 },{ 3, -3, -4 },{ 2, 2, 1 },{ -3, -1, -4 },{ -1, -1, -2 },{ 1, -3, 1 },{ 2, 1, 2 },{ -4, -1, 3 },{ -1, 0, -2 },{ 2, 3, -1 },{ -3, -3, 1 },{ -1, -1, -3 },{ -4, 3, -3 },{ 2, 2, 1 },{ -1, -3, 3 },{ -2, -1, -4 },{ 2, -2, -3 },{ 0, -4, -1 },{ 0, 1, -2 },{ 1, 3, -4 },{ -2, -4, 2 },{ -1, 2, -3 },{ -4, 3, 0 },{ -3, -4, -4 },{ -2, 2, -2 },{ 2, 0, 1 },{ 2, -2, -4 },{ 1, 1, 1 },{ 0, 3, -1 },{ 3, -2, 1 },{ -3, -1, -1 },{ -3, -2, 3 },{ 3, 3, 0 },{ 2, 0, -1 },{ -4, -4, 1 },{ -2, 1, 2 },{ -1, 3, -4 },{ -3, -2, -2 } },
+		{ { 1, -1, -3 },{ 0, 1, 1 },{ 3, -1, 0 },{ 1, 0, 3 },{ -1, 0, 2 },{ -4, 1, -4 },{ 2, -2, -2 },{ 3, -2, -3 },{ -2, 2, 2 },{ -4, 0, -4 },{ 0, -1, 0 },{ 1, -2, -3 },{ 2, 0, -2 },{ -2, 2, 2 },{ -1, 3, 3 },{ -2, -1, 0 },{ 3, 1, -3 },{ 2, 3, 2 },{ -1, 1, 0 },{ 1, -4, -2 },{ 0, 2, 2 },{ 3, -1, 0 },{ -1, -3, -4 },{ 2, -2, -2 },{ -1, 0, 0 },{ -3, 3, -3 },{ 1, -1, -2 },{ -3, -3, 3 },{ -4, 3, -1 },{ -1, 2, 2 },{ 2, -4, 3 },{ -4, 0, -2 },{ 0, 3, -4 },{ 3, -4, 0 },{ 0, -2, -3 },{ -2, 1, -4 },{ 1, 2, -1 },{ 0, -2, 3 },{ -3, 1, -4 },{ 2, -1, -2 },{ -4, 1, 2 },{ 1, -4, -2 },{ -4, 3, 1 },{ -3, 2, 2 },{ 2, 0, 3 },{ -4, 1, 1 },{ 3, -2, -1 },{ 1, 0, 1 },{ 0, 0, 0 },{ 2, 1, 2 },{ -1, 1, 2 },{ -4, -2, -1 },{ -2, -4, -3 },{ -3, 0, 0 },{ -4, -4, 2 },{ 3, 0, -3 },{ -2, 3, -3 },{ 2, 1, 0 },{ 0, -3, -4 },{ -4, -1, -2 },{ -1, 1, -3 },{ 2, -3, 0 },{ 0, -2, 3 },{ -3, -4, 1 } },
+		{ { -1, -3, -4 },{ -4, 2, -2 },{ -2, -4, -1 },{ 0, -2, 1 },{ -3, -3, -4 },{ 1, 3, 3 },{ -1, 2, 0 },{ -2, -4, -2 },{ 1, 1, 0 },{ -3, 3, -2 },{ 3, -3, 3 },{ -1, 0, 1 },{ -4, -4, -4 },{ 0, -3, 2 },{ 1, -2, -3 },{ -4, -4, 0 },{ -1, 0, 1 },{ -2, -2, -4 },{ 3, -3, -1 },{ -2, -1, 1 },{ -1, 1, -3 },{ -4, -3, -2 },{ -2, 3, 3 },{ 1, 1, 1 },{ 0, -4, -4 },{ -2, 2, 2 },{ -4, 2, -3 },{ 1, 0, 0 },{ 0, -2, -3 },{ 3, 1, 0 },{ -2, 0, -3 },{ -2, -3, -1 },{ -1, 2, 0 },{ -3, -1, 1 },{ 1, 0, 0 },{ -2, -4, 2 },{ 3, -3, 2 },{ 0, 0, 1 },{ -2, -4, -1 },{ 3, 2, 2 },{ 0, -2, 0 },{ -2, 0, -3 },{ -1, 0, 0 },{ 3, -3, -4 },{ -1, -1, 0 },{ -2, -4, -3 },{ 2, -2, 2 },{ -3, 1, -4 },{ -2, -3, 3 },{ 3, -1, -3 },{ 1, -4, -4 },{ 0, 3, 0 },{ 3, -3, 3 },{ -1, -1, -2 },{ 0, 2, 2 },{ -1, -3, 0 },{ 1, -2, -2 },{ -1, 2, 1 },{ -2, -4, 2 },{ -3, 0, 2 },{ 1, 3, 3 },{ 3, 0, -4 },{ -4, 2, -1 },{ 3, 0, -1 } },
+		{ { 0, -3, 2 },{ 1, -2, 3 },{ -3, 3, -3 },{ 3, 2, -2 },{ -2, 0, -3 },{ 2, -4, 1 },{ -4, -1, -1 },{ 0, -3, 3 },{ -1, -1, 2 },{ 1, -4, -3 },{ -1, -2, -1 },{ -2, 1, -2 },{ 3, 3, 0 },{ 0, 1, -1 },{ -3, -1, -3 },{ 3, 0, 3 },{ 0, 2, 2 },{ -3, -4, -2 },{ -4, 3, 3 },{ 1, 0, 3 },{ -3, 3, -4 },{ 2, -4, 0 },{ 1, 2, -1 },{ 3, -1, -3 },{ -3, -3, -1 },{ 3, -2, 1 },{ -1, -3, 3 },{ 3, 1, -1 },{ -2, -4, -4 },{ -3, -2, 2 },{ 1, -4, 1 },{ 1, 2, 2 },{ 3, -2, -4 },{ -3, -3, 3 },{ 2, 2, -2 },{ -4, 3, -3 },{ -4, -2, 1 },{ 3, 3, -2 },{ -3, 0, -2 },{ 1, -4, -4 },{ -3, 3, 1 },{ 1, -1, -3 },{ 3, 2, 2 },{ 0, -3, -1 },{ -4, 1, 3 },{ 0, 2, -2 },{ 1, 3, 0 },{ -3, -3, -3 },{ -1, 3, -2 },{ -4, -2, -1 },{ 0, 0, 1 },{ -3, 2, 3 },{ -3, 0, -3 },{ 2, 3, -1 },{ 2, 1, -4 },{ -4, -4, 3 },{ 1, -1, -4 },{ -4, 0, 3 },{ 3, 3, -3 },{ 2, -2, -3 },{ -2, 2, -1 },{ 0, -4, -2 },{ -2, -1, 1 },{ 2, 1, 3 } },
+		{ { -3, 3, -2 },{ 2, 1, 0 },{ -3, -1, 2 },{ -1, -3, 2 },{ 3, 1, 0 },{ 0, -1, -2 },{ -3, 2, -4 },{ 2, 0, 1 },{ -3, 3, -4 },{ 3, 2, 1 },{ -4, -1, 2 },{ 1, 2, -4 },{ -3, -4, 3 },{ 2, 0, 1 },{ -2, 1, -2 },{ -4, 3, -4 },{ 1, -3, -1 },{ 2, -1, -3 },{ 2, 1, -1 },{ 0, -3, 1 },{ -3, 0, -2 },{ 2, -2, 2 },{ -4, -1, 2 },{ -1, 0, 3 },{ -3, 1, 0 },{ 0, -1, -2 },{ 2, 3, -2 },{ -2, -1, 1 },{ -4, 2, 3 },{ 0, 3, -2 },{ 2, 0, -1 },{ -4, 1, -4 },{ -1, 3, -3 },{ -2, -4, -2 },{ 1, -1, 2 },{ 0, 1, -1 },{ -1, 1, 0 },{ -2, -1, -4 },{ 2, -1, 3 },{ -1, 1, 1 },{ 0, -2, -1 },{ -4, -3, 3 },{ -2, -4, -2 },{ -3, 3, 2 },{ 2, -2, -4 },{ -1, -1, -3 },{ -4, -4, 0 },{ 1, 0, 3 },{ 3, -1, 1 },{ -2, 2, -2 },{ 2, -4, 2 },{ 3, 1, -2 },{ -2, -3, 0 },{ 1, -1, 1 },{ -2, -2, -3 },{ -3, 2, 1 },{ 3, 3, -1 },{ 0, -3, 0 },{ -2, -4, -1 },{ 1, -2, 1 },{ -4, -1, 0 },{ 1, -3, 2 },{ -3, 3, -4 },{ -2, 0, -3 } },
+		{ { 3, -1, -1 },{ 0, -2, 1 },{ 1, 0, -4 },{ -4, -4, -1 },{ -2, 3, 3 },{ 1, -2, 0 },{ -1, 0, 2 },{ 3, -3, -3 },{ -4, -2, -1 },{ -2, 1, 3 },{ 2, -3, -2 },{ 0, 0, 0 },{ -3, -2, -3 },{ -1, -3, 2 },{ 3, 3, 0 },{ -1, -3, 1 },{ 1, -2, 3 },{ -3, 0, 0 },{ -1, -4, -4 },{ -1, 2, -2 },{ 3, -2, 0 },{ -1, 3, -4 },{ 0, -4, -1 },{ -2, -3, -3 },{ 2, 3, -4 },{ -4, -4, 2 },{ 0, 0, -4 },{ 1, -3, 0 },{ 2, 3, -3 },{ -1, -1, -1 },{ 3, -3, 1 },{ -3, -1, 1 },{ 2, 0, 0 },{ -4, 1, 3 },{ 3, -1, 1 },{ 1, -3, -4 },{ -3, -2, 3 },{ 2, -4, -2 },{ -3, 2, 0 },{ -4, -3, -3 },{ 3, 2, 0 },{ 2, 1, -4 },{ 0, -1, 0 },{ 3, 1, -1 },{ -2, 0, 1 },{ 1, -3, 1 },{ 3, 2, -1 },{ -1, 0, 2 },{ 2, -4, -4 },{ -4, 3, -1 },{ 1, 1, -3 },{ -1, -2, -4 },{ -4, 3, 1 },{ 0, -3, 2 },{ 3, 0, -2 },{ -2, -4, 3 },{ -3, -1, -4 },{ -1, 1, -2 },{ 2, 0, 3 },{ -1, 1, -4 },{ 0, 2, 0 },{ 3, 1, 1 },{ 1, -3, -2 },{ -4, -4, 0 } },
+		{ { -1, 1, 3 },{ -1, -4, -4 },{ 2, 1, -3 },{ 0, -1, 1 },{ 2, 3, -3 },{ -4, -3, -1 },{ -2, 2, -2 },{ 0, -4, 2 },{ -1, 3, 0 },{ 2, -4, -4 },{ 0, 0, 2 },{ -1, -3, -1 },{ -4, 2, -1 },{ 1, -1, 3 },{ 2, -4, -4 },{ -2, 2, -2 },{ 0, 1, 2 },{ 3, 2, 1 },{ -2, -1, -3 },{ -4, -2, 2 },{ 1, 1, 3 },{ -2, 0, -3 },{ 3, 2, 1 },{ -3, -1, -1 },{ 3, 2, 0 },{ -1, 0, 2 },{ -2, 1, -2 },{ -3, -3, 3 },{ 3, 1, 2 },{ -4, -4, -4 },{ 0, -2, 3 },{ -2, 2, 0 },{ 1, -4, 2 },{ 0, -3, -3 },{ -2, 3, -1 },{ -1, 0, -4 },{ 3, 3, 2 },{ 0, 2, -3 },{ 1, -3, 2 },{ 3, 0, 3 },{ -2, -4, -2 },{ -3, 3, 2 },{ 1, 0, 1 },{ -2, -4, -3 },{ 0, 3, -3 },{ -3, -2, 3 },{ -4, 3, -4 },{ 0, 1, -2 },{ -2, -2, 3 },{ 0, -3, 1 },{ -3, -2, 0 },{ -1, -1, 3 },{ 1, -4, -1 },{ 2, 2, -3 },{ -4, 1, 0 },{ 0, 0, 2 },{ 1, -2, -1 },{ 3, 3, 1 },{ -3, -1, 2 },{ -4, -4, -2 },{ 2, -1, 3 },{ -3, -2, -3 },{ -1, 3, -4 },{ 1, 2, 2 } },
+		{ { -3, -2, -1 },{ -2, 3, 3 },{ -4, -3, -1 },{ -3, 2, 2 },{ 1, 0, 2 },{ 3, -2, -4 },{ -1, 1, 3 },{ 2, 0, -2 },{ 1, 1, 1 },{ -3, -1, -3 },{ -2, 3, 0 },{ 3, 1, -4 },{ 3, 2, 1 },{ 0, -2, -3 },{ -4, 1, 1 },{ -3, -1, -3 },{ 0, -3, 0 },{ -4, 3, -1 },{ 2, -2, -2 },{ 1, 1, 1 },{ -3, -4, 0 },{ -4, 3, -4 },{ 2, -3, 3 },{ 1, 1, -2 },{ 0, -2, 3 },{ 1, -4, -1 },{ 2, 2, 0 },{ -1, -2, -3 },{ -2, -1, 0 },{ 1, 0, -2 },{ -3, 2, -2 },{ 0, 0, -4 },{ 3, -2, -3 },{ -4, 1, -2 },{ -1, 2, 2 },{ -3, -2, 0 },{ -4, -4, 1 },{ -2, 1, 0 },{ 0, -1, -1 },{ -1, 3, -4 },{ -1, -2, -1 },{ -4, -1, -3 },{ 1, 2, 3 },{ -4, -3, -1 },{ 2, 1, 3 },{ 2, -1, -1 },{ -2, -4, 0 },{ 2, -1, 1 },{ -3, 2, -3 },{ 3, 0, -1 },{ 2, 2, 2 },{ -3, 3, -2 },{ 3, 0, 1 },{ -3, -4, -4 },{ -1, 3, 0 },{ 2, 2, -4 },{ 2, -3, 0 },{ -2, 2, -3 },{ 0, -3, 0 },{ -1, 3, -4 },{ -2, -4, -1 },{ 2, 0, 2 },{ -4, 0, 1 },{ 2, -3, 0 } },
+		{ { 0, -1, -3 },{ 2, 2, -2 },{ 3, 0, 1 },{ -1, -1, -3 },{ 0, -4, -2 },{ -3, -2, 0 },{ -2, -1, 1 },{ -4, 3, -4 },{ 2, -2, -1 },{ -4, -3, 3 },{ -1, -1, 1 },{ -3, -4, 3 },{ 1, -3, -2 },{ -1, 3, 0 },{ -2, 0, -1 },{ 2, -4, -2 },{ 3, -2, 3 },{ -3, 0, -4 },{ 0, -4, 3 },{ -1, 3, -2 },{ 3, -3, -1 },{ 1, -2, 2 },{ -1, 0, 0 },{ -3, -4, 1 },{ -4, 3, -4 },{ -2, -2, -3 },{ -4, 0, 1 },{ 0, -3, -1 },{ 3, 3, 3 },{ -4, -4, 1 },{ 1, 3, 0 },{ -2, -3, 3 },{ 2, 3, -1 },{ 2, -4, 0 },{ 1, 0, 3 },{ 3, -1, -4 },{ 2, -3, -1 },{ 1, 0, -2 },{ -3, -2, 3 },{ -2, 1, -3 },{ 1, -4, 1 },{ 2, 0, 0 },{ 3, -2, -4 },{ -1, -2, -2 },{ -3, 2, 0 },{ -1, 0, -2 },{ 3, -3, 2 },{ 1, 3, -3 },{ -4, -4, -2 },{ -1, -1, -4 },{ 1, -3, 2 },{ -2, 1, -4 },{ 0, -1, -1 },{ 1, -3, 2 },{ -3, -2, 3 },{ -2, -1, -2 },{ -4, -4, 2 },{ -3, 1, -3 },{ 3, 0, 3 },{ 1, -1, 1 },{ -3, 1, -3 },{ 3, -3, 0 },{ 0, 2, -3 },{ -2, -1, -2 } },
+		{ { 3, -4, 2 },{ 1, -2, -4 },{ -2, 1, 0 },{ -4, -4, -1 },{ 2, 2, 3 },{ 3, 3, -3 },{ 0, -3, 2 },{ -1, 2, -1 },{ 3, -4, -3 },{ -2, 0, 0 },{ 1, 2, -4 },{ 2, 1, -2 },{ -3, 0, 2 },{ -4, -1, 1 },{ 1, 1, 3 },{ 2, 3, 2 },{ -1, 2, -3 },{ -1, 1, 1 },{ 1, -1, 0 },{ -3, 2, -4 },{ 0, 0, 1 },{ -2, -1, -3 },{ -2, 2, -3 },{ -1, 1, -2 },{ 3, -1, 1 },{ 1, -3, 2 },{ 2, 3, 3 },{ -3, -1, -2 },{ 1, 2, -4 },{ 2, 1, -3 },{ -1, -2, -1 },{ -1, -1, 2 },{ -4, -1, 1 },{ -3, 2, -3 },{ -2, -3, 2 },{ 0, 1, -1 },{ -2, 2, -3 },{ -4, 3, 3 },{ 2, -4, -4 },{ 3, 2, 1 },{ -4, -3, 0 },{ 0, 2, 2 },{ -3, 3, 2 },{ 0, -1, -3 },{ 1, -4, 2 },{ -2, 1, -4 },{ -1, 0, 0 },{ 0, 2, 2 },{ -3, 0, 3 },{ 1, 1, 0 },{ -2, -4, 1 },{ 3, -2, -2 },{ -4, 1, 0 },{ -1, 2, -2 },{ 3, 1, -3 },{ 1, -3, 1 },{ -1, 1, -1 },{ -4, -2, 3 },{ 0, 2, -4 },{ 1, -2, -1 },{ -1, 3, -2 },{ -2, -2, 3 },{ 1, -4, 0 },{ -3, 3, 3 } },
+		{ { -1, 1, 1 },{ -3, -3, 1 },{ 0, 3, 3 },{ -1, 0, -4 },{ -2, -2, 0 },{ -4, 1, -1 },{ 1, 0, 1 },{ -3, -4, 3 },{ 2, 1, -2 },{ -1, 3, 2 },{ 1, -2, -3 },{ 0, 2, -1 },{ -2, -4, -1 },{ -1, -2, -4 },{ 3, -3, -4 },{ -3, -1, -2 },{ -2, -2, -1 },{ -4, -4, -3 },{ 3, 2, 2 },{ -2, -1, -1 },{ 2, -3, 2 },{ 2, 3, 3 },{ -4, -2, -1 },{ 3, -3, 3 },{ -3, 1, -3 },{ 2, 2, 0 },{ -1, 0, -4 },{ -2, -4, 2 },{ 0, -3, 0 },{ -3, 0, 2 },{ 3, -4, 1 },{ -3, 1, -4 },{ 1, 0, -2 },{ -1, -3, -4 },{ 3, 3, 0 },{ -4, -1, -2 },{ 1, 3, 1 },{ -1, -3, 2 },{ 0, 0, 0 },{ 2, -1, -2 },{ -2, 3, -3 },{ -2, 0, -1 },{ 2, -3, -4 },{ -2, 1, -1 },{ 3, 3, 1 },{ -4, -3, 3 },{ 1, -2, -1 },{ -4, -4, -4 },{ 3, -2, 1 },{ 0, 2, -2 },{ -4, 3, 3 },{ -3, -1, -3 },{ 2, 3, 3 },{ -1, -4, 1 },{ -4, 0, -4 },{ 0, 0, 0 },{ 3, 3, -3 },{ 2, -1, -2 },{ -1, -4, 0 },{ -3, 1, 2 },{ -4, -3, 1 },{ 0, 2, -4 },{ 3, 0, -2 },{ -4, 1, -1 } },
+		{ { 2, -3, -2 },{ -4, 0, -3 },{ 1, 2, 0 },{ 2, -4, -2 },{ 1, -1, 3 },{ -1, -1, -3 },{ 0, -3, -2 },{ 1, 2, -4 },{ -4, -1, 0 },{ -3, -3, 2 },{ 3, -3, 1 },{ -4, -1, 3 },{ 3, 3, 2 },{ 0, 1, -3 },{ 2, 3, 0 },{ 0, -3, 3 },{ 1, 0, 0 },{ 0, 3, 1 },{ 2, -3, 3 },{ -3, -4, -2 },{ -4, -2, -3 },{ 0, 1, 0 },{ 0, -4, -4 },{ 1, -1, -1 },{ -2, 0, 1 },{ 0, -2, -3 },{ -4, -3, -2 },{ 3, 2, -1 },{ -2, -1, -2 },{ -4, 0, -3 },{ 0, 3, 3 },{ 3, -4, -2 },{ 0, 2, 0 },{ 1, -2, 2 },{ -2, 1, 1 },{ 2, -4, 3 },{ 3, -2, -4 },{ -3, -4, -1 },{ -1, 1, 2 },{ -3, -2, -2 },{ 0, -1, 3 },{ 3, -4, 1 },{ 1, -2, 3 },{ -4, -4, -2 },{ 2, -1, 0 },{ -3, -1, -3 },{ 0, 2, -2 },{ 2, 3, -1 },{ -1, -2, 1 },{ -2, 0, -3 },{ 2, -3, -1 },{ 0, 0, -4 },{ 1, -3, 2 },{ -2, -2, -1 },{ 2, 3, 2 },{ -3, -4, 3 },{ 0, 2, 1 },{ -2, -3, -1 },{ 2, -1, 2 },{ 3, 3, -3 },{ -1, 0, -2 },{ 2, -1, 3 },{ 1, -2, 2 },{ -1, 2, -4 } },
+		{ { 3, -1, -3 },{ -2, -2, 3 },{ -3, -1, -4 },{ 3, -3, -1 },{ -4, 3, 2 },{ -2, 2, 2 },{ 3, -2, 0 },{ 2, 1, -1 },{ -3, 3, 1 },{ 0, 0, -4 },{ -1, -2, -3 },{ -3, -4, -1 },{ 2, 0, -2 },{ -4, -1, 1 },{ -2, 2, 2 },{ -3, -4, -2 },{ -4, 1, -4 },{ 3, -1, -3 },{ -1, 1, -1 },{ -2, 3, 0 },{ -1, 0, -4 },{ 3, 2, 1 },{ -2, 3, 3 },{ -4, 0, -2 },{ 2, 3, 2 },{ 0, -4, 2 },{ -3, 1, 0 },{ 3, 3, 3 },{ 2, 1, 1 },{ 1, -2, -1 },{ -2, 2, 0 },{ 2, -3, -3 },{ -4, 1, 3 },{ -2, -4, -1 },{ -1, 0, -3 },{ -4, 2, -2 },{ 0, -1, 0 },{ 1, 1, -1 },{ -2, 0, -4 },{ 3, 3, -3 },{ -4, 1, 2 },{ 0, 1, -4 },{ -3, 2, -1 },{ -1, 2, 2 },{ 0, 0, 1 },{ -1, -4, -4 },{ 3, 1, 3 },{ -3, 0, 2 },{ -2, -1, -4 },{ 3, -4, 2 },{ 1, 1, 0 },{ -1, 2, 0 },{ 3, 2, 1 },{ -2, -1, -3 },{ 3, 0, -1 },{ -4, -2, -2 },{ -1, -3, -4 },{ 1, 1, 2 },{ -4, 2, 0 },{ 1, -2, -4 },{ -2, -4, -1 },{ -3, -3, 1 },{ -3, 3, 0 },{ 0, -4, 2 } },
+		{ { 0, 0, 0 },{ 2, 3, 1 },{ 0, -4, 2 },{ -2, 1, 1 },{ 2, 2, -2 },{ -3, -4, -4 },{ 0, -2, -1 },{ -2, -1, 3 },{ -1, -4, 2 },{ 3, 1, -2 },{ 2, 2, 3 },{ 1, 3, 0 },{ -1, -2, -4 },{ -2, 1, 1 },{ 3, -2, 3 },{ -1, 0, -1 },{ 2, -3, -2 },{ -2, -2, 1 },{ 0, 0, 3 },{ 3, -3, -2 },{ 1, -1, 1 },{ 1, -1, 2 },{ -3, -3, -1 },{ -1, -3, -3 },{ 3, -2, 0 },{ -4, 2, -4 },{ -1, -1, -3 },{ 1, -2, 1 },{ -3, -4, -4 },{ -1, -1, 2 },{ -3, -3, -2 },{ -1, -1, 1 },{ 1, 3, 1 },{ -3, -1, -4 },{ 3, -3, -1 },{ 0, 3, 1 },{ -4, 0, 3 },{ 2, 2, -3 },{ -3, -3, 3 },{ 1, -4, 0 },{ 2, -3, 1 },{ -1, -1, -4 },{ -3, -2, -2 },{ 3, 0, -1 },{ 2, 3, -3 },{ -2, -2, 0 },{ 1, -3, 1 },{ -4, 2, 0 },{ 0, -3, -3 },{ -4, 3, -2 },{ -3, -2, 3 },{ -3, -1, -2 },{ -4, -2, -3 },{ -1, -3, -4 },{ 1, 3, 3 },{ 1, 1, -3 },{ -3, -4, 0 },{ -2, 3, 3 },{ 3, 0, -3 },{ -3, -2, -1 },{ 0, 3, 3 },{ 2, 1, -3 },{ -2, 0, -3 },{ -4, 2, -1 } },
+		{ { -3, -1, -1 },{ -1, 3, -2 },{ -4, 1, -4 },{ 0, -2, 0 },{ -1, 0, -3 },{ -4, 0, 1 },{ 1, 3, -3 },{ 3, 0, -2 },{ -4, -2, -3 },{ -2, -3, -4 },{ 1, 1, 0 },{ -4, 0, 2 },{ -2, -3, -3 },{ 0, -3, -2 },{ 1, -4, -3 },{ 0, 3, 0 },{ 1, 2, 3 },{ -4, 2, 0 },{ -2, 1, -4 },{ -3, 3, 2 },{ -4, -4, -3 },{ 2, 2, -4 },{ -1, 0, -2 },{ 0, 1, 1 },{ -3, -4, 3 },{ 1, 0, -2 },{ 2, 3, -1 },{ -2, -3, 3 },{ -4, 2, -3 },{ 1, 1, 0 },{ 3, 0, 2 },{ -4, -2, -4 },{ 2, 2, -1 },{ 0, -2, 3 },{ 2, 1, -3 },{ -2, -2, 0 },{ -2, -3, 2 },{ 3, -1, -4 },{ 0, -2, 1 },{ -4, 2, -1 },{ -2, 3, 3 },{ 1, 0, -2 },{ 2, -3, 0 },{ -4, 3, 2 },{ -2, 1, 3 },{ -3, -4, -3 },{ 3, 3, -2 },{ 0, 0, 2 },{ 1, -4, 1 },{ -1, 0, -1 },{ 2, 2, -4 },{ 2, -4, 1 },{ 0, 1, 3 },{ 3, -4, 0 },{ -2, 2, 1 },{ 0, 0, -1 },{ 2, -2, 1 },{ 3, -1, -3 },{ -1, -4, 2 },{ -4, -1, -2 },{ 1, 1, 0 },{ 3, -2, 2 },{ 1, -4, -2 },{ 3, -2, 3 } },
+		{ { 1, -4, -4 },{ 2, -3, 3 },{ -3, -3, -2 },{ 3, -1, -1 },{ 1, 3, 3 },{ 2, -4, 3 },{ -3, -3, 0 },{ 0, 2, 2 },{ 2, 3, 3 },{ -1, -3, 1 },{ -3, -1, 1 },{ 0, -4, -1 },{ 3, 2, 3 },{ 2, 0, 0 },{ -4, 2, -4 },{ -3, -1, 2 },{ -3, -1, -4 },{ 2, -4, 1 },{ 1, -2, -1 },{ 0, -3, 2 },{ 3, 1, -1 },{ -2, -2, 0 },{ -4, -2, 3 },{ 2, 3, -4 },{ 1, 1, 1 },{ -1, -3, -2 },{ -3, 0, 0 },{ 0, -1, 1 },{ 3, -4, -2 },{ 0, 3, -4 },{ -1, 2, 3 },{ 2, -4, -3 },{ -2, 3, 2 },{ -3, -4, -2 },{ 3, 1, 2 },{ -1, 0, -4 },{ 1, -4, -2 },{ 2, 3, 0 },{ -1, 1, -2 },{ -1, 0, 2 },{ 3, -1, -2 },{ -2, 2, 0 },{ 0, -4, -3 },{ 1, -1, 3 },{ -1, -3, -4 },{ -3, -1, -1 },{ 2, -1, -2 },{ -1, 2, -4 },{ -2, -2, 3 },{ 3, 1, 0 },{ 0, -1, 2 },{ -2, 1, -2 },{ 1, 3, 0 },{ -3, 0, -2 },{ -3, -1, 2 },{ -4, -2, -2 },{ 1, 2, -4 },{ -2, 1, -1 },{ 0, 0, 2 },{ 0, 2, -4 },{ -4, -3, 1 },{ -1, 1, -1 },{ -3, -1, -4 },{ -1, 2, 2 } },
+		{ { -2, -2, 0 },{ 3, 0, 1 },{ -2, 2, -3 },{ 1, 2, 2 },{ -3, -2, -1 },{ -2, -3, -2 },{ -1, 1, -4 },{ -4, -1, 0 },{ 1, 0, -1 },{ -3, 2, -4 },{ 2, 3, -2 },{ -2, -1, -3 },{ -4, 1, -1 },{ 2, -2, 2 },{ -1, 0, 1 },{ -1, 1, -2 },{ 3, -4, 3 },{ 3, 3, -2 },{ -1, 0, -3 },{ -3, -1, -3 },{ 1, 2, 3 },{ 0, 3, -2 },{ -2, -4, 2 },{ 3, -1, -3 },{ -2, 1, 0 },{ -2, 3, 2 },{ -4, -2, -4 },{ 2, 2, 2 },{ -1, 1, -1 },{ -4, -2, 0 },{ -3, -3, 1 },{ -2, 1, -2 },{ 0, 0, -1 },{ 1, -3, 1 },{ -3, -2, 0 },{ -4, 2, 3 },{ -3, 3, 1 },{ -2, -2, -3 },{ -4, 1, 2 },{ -3, -3, -3 },{ 1, -4, -4 },{ -3, -2, 1 },{ 3, 2, 2 },{ -4, 1, -1 },{ 0, -2, 0 },{ 2, 1, 1 },{ 0, 0, 2 },{ -4, -2, 0 },{ 2, 3, -3 },{ -3, -3, -3 },{ -2, 3, -1 },{ -4, -2, 2 },{ 2, -3, -3 },{ 2, 2, -4 },{ -1, -3, -1 },{ 3, 1, 3 },{ -4, -4, 0 },{ -1, -3, 1 },{ -3, 3, 3 },{ 2, -4, -2 },{ 2, -2, 0 },{ -2, 3, -3 },{ -4, 0, 3 },{ 2, 3, -2 } },
+		{ { -4, 1, -3 },{ -1, -1, -1 },{ -4, 0, 2 },{ -1, -4, 1 },{ 2, 1, -4 },{ 0, -1, -2 },{ 2, 3, 1 },{ 3, -4, -3 },{ -2, -4, 2 },{ 3, -2, 0 },{ 0, -3, 3 },{ 3, 0, 2 },{ -1, -4, -4 },{ -3, 3, 0 },{ 2, -3, -3 },{ -2, -3, -3 },{ 0, -2, -1 },{ -4, 0, 2 },{ -2, 2, 0 },{ -4, -1, 1 },{ 2, -3, -4 },{ -1, 1, -1 },{ -3, 0, 1 },{ 2, -3, -4 },{ -4, -1, -1 },{ 0, -4, 3 },{ 3, -3, 1 },{ 1, 0, -4 },{ -2, -4, 3 },{ 2, -1, -3 },{ 1, -2, 0 },{ 3, -1, -4 },{ -4, 0, 3 },{ 1, 2, -3 },{ -1, -1, -4 },{ 0, -3, -1 },{ 3, 0, -1 },{ 0, -1, 0 },{ 1, -4, 3 },{ 2, 3, -1 },{ 2, 0, 0 },{ -1, -1, 3 },{ -3, 1, -3 },{ -2, -3, -4 },{ 3, 3, -2 },{ -2, -3, 3 },{ -1, 1, -3 },{ 3, -4, 2 },{ -4, -1, 1 },{ 0, 0, -2 },{ 1, -3, 3 },{ -1, 0, -4 },{ -4, -4, 3 },{ 0, -1, 0 },{ -1, 3, 2 },{ 2, -1, -3 },{ 0, 2, 1 },{ 2, -2, -3 },{ 3, 0, -1 },{ -2, -3, -4 },{ 1, -1, -1 },{ 3, 2, 2 },{ 0, -4, 1 },{ 0, -3, 0 } },
+		{ { 2, 1, 3 },{ 0, 3, -2 },{ 1, -4, -4 },{ 3, 3, 0 },{ -2, 1, 3 },{ -4, -2, -3 },{ -3, 2, 1 },{ -1, 0, -1 },{ -2, 0, -3 },{ -4, 1, -2 },{ 1, 3, 1 },{ -4, 2, -1 },{ 1, -2, -2 },{ -2, -1, 1 },{ 1, 3, 3 },{ -4, 1, 2 },{ 1, -1, -1 },{ 0, 3, -4 },{ 1, -4, 2 },{ 3, -2, 0 },{ -1, 3, -2 },{ 3, -4, 3 },{ 0, 0, 0 },{ 1, 2, 2 },{ -1, 2, -1 },{ 2, -1, -3 },{ -3, 3, 0 },{ -1, 2, -2 },{ 0, 3, -1 },{ -4, 0, 1 },{ 0, 2, 3 },{ -2, -3, -1 },{ 3, 2, 2 },{ 2, -4, -2 },{ -1, 3, 2 },{ 2, 1, -2 },{ 3, 2, 3 },{ -3, -2, -4 },{ 1, -3, -3 },{ -2, 2, 1 },{ -4, 3, 2 },{ 0, -4, -2 },{ 2, 2, -1 },{ -1, 0, 1 },{ 1, 3, 2 },{ -3, -4, -1 },{ 1, 2, -4 },{ -3, 3, -2 },{ 0, -4, 2 },{ 3, 2, -1 },{ 2, -1, 1 },{ 3, 2, 0 },{ 1, -2, -1 },{ -2, 1, 1 },{ -3, 2, -3 },{ -2, -2, 0 },{ 1, 0, -2 },{ -3, 3, 2 },{ -1, 2, 0 },{ -4, -1, 2 },{ -1, 1, 3 },{ -3, 1, -3 },{ -2, -4, -2 },{ 3, -1, -4 } },
+		{ { 1, 0, 2 },{ -3, -3, 1 },{ -3, -2, -1 },{ 1, 0, 2 },{ 0, -3, -2 },{ 3, -3, 3 },{ 1, -1, 0 },{ 2, 3, 2 },{ 0, -2, 3 },{ -1, -3, -4 },{ -3, -1, -3 },{ -2, -4, 3 },{ 0, -2, -4 },{ 3, 2, 0 },{ -1, -4, -3 },{ 3, -2, 0 },{ -3, 2, 1 },{ 2, -3, -4 },{ -2, 1, 3 },{ -3, -3, -1 },{ 0, 0, -2 },{ -4, -2, -4 },{ -3, 3, -3 },{ -4, -2, -2 },{ 3, -4, 3 },{ -3, 1, -3 },{ 0, -3, 2 },{ 2, -2, -2 },{ -3, -3, 2 },{ 3, -4, -3 },{ 2, 1, -4 },{ -1, 3, -2 },{ -2, 1, 1 },{ -3, -2, 0 },{ -4, -1, -3 },{ -2, -3, 0 },{ -3, -4, 1 },{ -1, 2, 1 },{ -4, 0, -2 },{ 3, 1, -1 },{ -2, -2, -4 },{ 0, -3, -3 },{ 3, 0, 0 },{ -4, -4, 3 },{ 3, -1, -3 },{ 0, -2, 0 },{ -4, -1, 3 },{ 1, 0, -3 },{ -2, -2, -1 },{ -1, 1, -4 },{ -3, 1, 1 },{ -3, 3, -3 },{ 0, -4, -2 },{ 3, 0, 2 },{ -2, -3, -1 },{ 2, -4, -4 },{ -4, -1, 3 },{ 1, -4, -2 },{ 3, 1, -4 },{ -3, -4, 0 },{ 1, 3, -2 },{ 1, -2, 1 },{ -4, -2, 1 },{ -3, 3, 0 } },
+		{ { -1, 2, 3 },{ 3, -2, -4 },{ 0, 1, -1 },{ -3, -1, -3 },{ -1, 2, -3 },{ -4, 0, -1 },{ -2, 1, -4 },{ 1, -4, -2 },{ -4, -2, -1 },{ 3, 2, 2 },{ 2, 1, 0 },{ 2, 0, 2 },{ 0, 1, -1 },{ -3, 0, -2 },{ -4, -1, -4 },{ 2, 1, -2 },{ -1, -4, 2 },{ -4, 0, -2 },{ -1, 3, -3 },{ 1, 2, 1 },{ 2, 1, 3 },{ -2, -3, 2 },{ -1, 1, 0 },{ 2, -1, 1 },{ -2, -2, -4 },{ -1, 1, -1 },{ 1, -1, 1 },{ -4, 0, -4 },{ -2, 1, 0 },{ 0, -1, 3 },{ -3, -2, 1 },{ -4, -3, 0 },{ 1, 0, -4 },{ 0, -4, 3 },{ -1, -1, 2 },{ 1, 2, -2 },{ 2, 0, -3 },{ 0, -2, 2 },{ 0, 3, -4 },{ -3, -4, 3 },{ 2, -1, 2 },{ -3, -2, -1 },{ 1, 2, 1 },{ -2, -3, -4 },{ -1, 1, -2 },{ -3, 0, 1 },{ 2, 1, 0 },{ 3, -3, 1 },{ -4, 2, -4 },{ 1, -2, 2 },{ -2, -3, 3 },{ -4, -3, -3 },{ -1, -1, 2 },{ 2, -2, -4 },{ -3, 3, 1 },{ 0, 1, -1 },{ 3, -3, 3 },{ -2, 3, -3 },{ 0, -2, 1 },{ -1, -3, -3 },{ 2, 0, 3 },{ 0, -3, -4 },{ 3, 2, -1 },{ -2, -1, -3 } },
+		{ { 2, -4, -2 },{ -4, 3, 0 },{ -2, 2, 3 },{ 2, -2, 2 },{ 2, -4, 1 },{ -1, 1, 1 },{ 3, 2, 2 },{ -3, -3, 1 },{ -1, -1, -4 },{ 2, 3, 1 },{ -3, -4, 0 },{ -4, -2, -3 },{ -1, 3, 3 },{ 2, -3, 1 },{ -2, 2, 2 },{ 0, 3, 0 },{ 0, 0, 3 },{ 3, -2, -1 },{ -2, -4, -3 },{ 3, -1, 1 },{ -3, -4, -4 },{ 1, 0, -1 },{ 3, 3, -1 },{ 0, -4, 3 },{ 1, 2, 1 },{ -4, 3, 0 },{ 3, -4, 3 },{ 1, 2, -3 },{ -1, -4, 0 },{ 3, 3, -3 },{ 1, 0, -1 },{ 0, -1, 2 },{ 2, 2, -2 },{ 3, -3, -1 },{ 0, 3, -4 },{ 3, 1, 1 },{ -3, 0, -2 },{ -2, -1, 0 },{ 3, -3, -1 },{ -1, 1, 1 },{ 1, 0, -2 },{ -4, 3, 0 },{ 2, 1, 2 },{ -4, 3, -2 },{ 0, -2, 2 },{ 2, 3, -1 },{ -1, -3, -3 },{ -1, 0, 3 },{ -2, 3, -2 },{ 2, -4, 0 },{ 3, -1, -1 },{ 0, 3, 0 },{ 2, 2, -2 },{ 1, 0, 3 },{ -4, 2, 0 },{ 0, 1, -2 },{ -1, -2, 1 },{ -4, 0, 0 },{ -2, 2, 2 },{ 3, -1, -1 },{ -4, 3, 0 },{ -2, 0, 3 },{ -1, 2, 0 },{ 0, -4, -2 } },
+		{ { -4, -3, 1 },{ 1, -1, -4 },{ -1, 0, -1 },{ 1, -4, -3 },{ -4, 3, 0 },{ 0, -1, -4 },{ 1, -3, -2 },{ -2, 3, -1 },{ 0, 0, 3 },{ -2, 1, -2 },{ 1, -1, -2 },{ -1, -3, -4 },{ 1, 2, -2 },{ 3, -4, 3 },{ 1, -1, -1 },{ -3, -3, -3 },{ -2, -2, 0 },{ 1, 2, 1 },{ -4, -1, 2 },{ 0, 1, 0 },{ -1, -2, 2 },{ -4, 2, -2 },{ -2, -1, -4 },{ -4, 0, -3 },{ 2, -3, -3 },{ -1, 0, 2 },{ 0, 0, -2 },{ -3, -2, 2 },{ -2, 1, -1 },{ -4, -3, 3 },{ -1, 2, -2 },{ -3, -4, -3 },{ -2, 3, 3 },{ -2, 1, -3 },{ -4, -1, 1 },{ 1, -4, -1 },{ -4, -2, 3 },{ 2, 3, 3 },{ -1, -3, -3 },{ -4, 2, -2 },{ 3, -2, 3 },{ -1, -4, -3 },{ 0, -1, -1 },{ -2, -4, -4 },{ 3, -1, 3 },{ -2, 2, 1 },{ -4, -4, -4 },{ 1, -1, -2 },{ -3, 2, 2 },{ 0, -1, -4 },{ 1, 1, -2 },{ -2, 0, 2 },{ -4, -4, 0 },{ -2, -3, -4 },{ 3, -3, 2 },{ -1, -1, -3 },{ 2, -4, -1 },{ 2, 0, -4 },{ 1, 1, 3 },{ -3, -4, -2 },{ 1, 1, -3 },{ 2, -3, -4 },{ -3, -1, 2 },{ 3, 1, -1 } },
+		{ { 0, 0, 3 },{ -2, -3, 2 },{ -3, 1, -2 },{ 3, 0, 0 },{ -2, -3, 3 },{ -3, 2, -2 },{ -1, -2, 2 },{ 2, -1, 0 },{ 3, -4, -3 },{ -4, -3, 3 },{ 0, 3, 2 },{ 3, 1, 1 },{ -3, -1, 0 },{ -4, -2, -3 },{ 0, 1, -4 },{ -1, -4, 1 },{ 2, 1, -3 },{ -4, 3, -4 },{ 1, -3, -1 },{ -1, 3, -4 },{ 2, 2, -2 },{ 3, -3, 3 },{ 0, -4, 1 },{ -3, 3, 3 },{ 1, -2, -2 },{ -3, 1, -1 },{ -2, -3, -4 },{ 2, 2, 1 },{ 2, -1, -4 },{ 3, 0, 0 },{ 0, -3, 1 },{ 2, 1, 2 },{ 3, -2, 0 },{ -3, 0, -4 },{ -1, -3, 2 },{ 2, 3, 0 },{ 3, -4, -4 },{ -2, 1, -3 },{ 1, 1, 1 },{ 0, 0, 2 },{ -2, -3, -4 },{ -3, 2, 1 },{ 1, 0, 0 },{ 3, -2, 0 },{ -3, -3, -3 },{ 1, 2, -1 },{ 0, -2, 3 },{ 3, -3, 0 },{ -4, 1, 1 },{ 2, -2, -1 },{ -3, -4, 3 },{ -1, 2, -4 },{ 0, 1, 1 },{ 2, -1, -1 },{ -2, 3, -3 },{ -3, 1, -1 },{ -3, 3, 1 },{ 0, 2, -2 },{ -2, -2, -4 },{ -1, -1, 2 },{ 3, 3, 0 },{ -3, -2, -1 },{ -2, 2, 2 },{ 1, 1, -3 } },
+		{ { -1, 2, 0 },{ 0, 3, -4 },{ 2, -2, 3 },{ -1, -1, -4 },{ 2, 3, -3 },{ -4, 1, 2 },{ 3, 0, -3 },{ -4, 2, -4 },{ -3, 2, 1 },{ 2, -2, -1 },{ -3, -2, -4 },{ -1, 0, -1 },{ -2, -4, 2 },{ -4, 0, 1 },{ 2, 3, -2 },{ -2, 0, 3 },{ 3, -2, 2 },{ -3, -3, -2 },{ 3, 0, 3 },{ -2, -4, 1 },{ -3, -2, -3 },{ 0, 1, 0 },{ -2, -1, -1 },{ -1, 2, 1 },{ 2, -4, -3 },{ 0, -1, 0 },{ 3, 3, -2 },{ 0, -4, 1 },{ -4, 0, 2 },{ -1, 3, -3 },{ -3, -1, -4 },{ -4, -2, 0 },{ 1, -4, -1 },{ 1, 2, 1 },{ 0, -1, -2 },{ -1, -3, -3 },{ -3, 2, 2 },{ -1, -2, -1 },{ -4, -1, 0 },{ 3, -4, -2 },{ 2, 3, -4 },{ -2, -3, 2 },{ 2, 2, 3 },{ -4, 0, -3 },{ 0, 1, 2 },{ -1, -2, 0 },{ -2, 1, -4 },{ 3, 0, -3 },{ -1, 2, 2 },{ -2, 3, -1 },{ 0, -1, -3 },{ 3, -3, 1 },{ -3, -2, 3 },{ 1, 2, -2 },{ 1, -1, 1 },{ 0, -2, 3 },{ 3, -3, 2 },{ -4, -4, 0 },{ 2, -2, 3 },{ -4, -3, 1 },{ -1, 0, -2 },{ 0, -4, 1 },{ 2, -2, 1 },{ -3, -1, -3 } },
+		{ { 3, -4, -1 },{ -4, -2, -1 },{ 3, -4, 0 },{ -2, 1, 1 },{ 0, -3, -1 },{ 1, -4, 1 },{ -1, -2, 3 },{ 0, -4, -1 },{ 1, 1, 0 },{ -1, 3, -2 },{ 3, -1, 2 },{ 0, 2, -3 },{ 1, 3, 0 },{ 2, -3, -1 },{ 0, 2, -3 },{ 1, -1, 0 },{ -4, 0, 1 },{ 0, 2, -1 },{ -2, 1, 0 },{ 2, -1, 2 },{ 1, 0, -2 },{ -4, 3, 2 },{ 1, -3, -4 },{ 3, 1, -2 },{ -2, 1, 2 },{ -1, -2, 3 },{ -4, -1, 0 },{ 1, 1, 3 },{ -2, -2, -1 },{ 0, -4, -2 },{ 1, 2, 3 },{ -2, 3, -2 },{ -1, 0, -4 },{ -3, 1, 3 },{ 3, -1, 2 },{ -2, 2, -1 },{ 1, 0, -2 },{ -2, -2, 3 },{ 2, 3, 1 },{ 0, 0, 3 },{ -4, 1, -1 },{ 1, -2, 0 },{ -1, -1, -2 },{ -3, -4, -2 },{ 1, 3, 2 },{ 2, 1, -2 },{ -4, -4, -1 },{ -3, 3, -2 },{ 2, -4, 2 },{ -2, -2, -4 },{ 1, 1, 1 },{ -4, 0, -1 },{ 2, 1, -3 },{ -1, -4, 2 },{ -4, 0, 0 },{ 3, 2, -3 },{ -2, 0, -4 },{ -1, 1, -1 },{ 0, 1, -3 },{ 3, 3, -1 },{ 0, 2, -4 },{ -4, 0, 3 },{ 2, 3, -4 },{ -1, -3, -2 } },
+		{ { 2, 2, 1 },{ -3, 1, 2 },{ 1, 0, -3 },{ -3, 2, 3 },{ -3, -1, -2 },{ 2, 2, -4 },{ 3, 1, 0 },{ -2, -1, 3 },{ -2, 0, -3 },{ -4, -3, 1 },{ 2, -4, 3 },{ -2, 0, -2 },{ -3, -2, 3 },{ 3, -3, -4 },{ -1, 1, 2 },{ -3, -4, 3 },{ 2, -1, -1 },{ 0, 3, -4 },{ -1, -4, -3 },{ 3, -2, 3 },{ -4, 2, -4 },{ -2, -4, -1 },{ 3, -2, 3 },{ -3, 0, 1 },{ -4, 3, -4 },{ 1, -4, -1 },{ -3, 2, -4 },{ 3, 3, -2 },{ -3, -3, -3 },{ 2, 1, 1 },{ 3, -1, -1 },{ -4, -2, 2 },{ 2, -3, 0 },{ -2, -4, -2 },{ -4, -2, -4 },{ 1, 3, 0 },{ 3, -4, 1 },{ 0, -3, -3 },{ -3, 2, -4 },{ -1, -4, -1 },{ -3, -2, -3 },{ -2, 1, 1 },{ 3, 3, -3 },{ -4, -4, 0 },{ -1, 0, -4 },{ 3, -3, 3 },{ 0, -1, 1 },{ 1, -3, 1 },{ -4, -1, 0 },{ 2, 0, -2 },{ 0, -4, 3 },{ -3, 3, -2 },{ -2, -3, 0 },{ 0, 3, -4 },{ -4, -4, -1 },{ -1, -1, 2 },{ 2, -2, -2 },{ 1, 2, 1 },{ -3, -1, 2 },{ 2, -1, -3 },{ -2, -4, 0 },{ 1, 1, -1 },{ -4, -1, 2 },{ -2, -2, 3 } },
+		{ { 1, 2, -4 },{ -4, 0, -2 },{ -1, -3, 0 },{ 0, 3, 2 },{ 2, -2, -3 },{ -4, 0, 0 },{ -1, 3, -2 },{ 1, -3, 2 },{ -3, 2, -4 },{ 3, 1, 0 },{ 1, 3, -2 },{ -4, -4, -3 },{ 1, 2, 0 },{ -4, -1, 1 },{ -1, -4, -2 },{ -2, 3, -4 },{ 3, -2, -3 },{ -4, -3, 1 },{ -3, 1, 1 },{ -2, 0, 0 },{ 0, 3, -1 },{ 0, -1, 1 },{ 2, 2, -3 },{ -1, -3, 0 },{ 0, -1, -3 },{ 2, -4, 1 },{ 0, 0, 0 },{ -1, -2, 3 },{ 2, -3, -4 },{ -3, 0, 1 },{ -2, -4, 3 },{ 0, 1, -3 },{ 3, 2, -3 },{ 2, 3, 1 },{ -3, 0, -1 },{ 0, -1, 3 },{ -4, 1, 0 },{ -3, 0, -2 },{ 2, 1, 2 },{ 3, -1, 0 },{ 1, -3, 3 },{ 0, 2, -4 },{ 0, 0, 3 },{ 2, -2, 1 },{ -3, 2, -1 },{ -2, -1, -4 },{ 2, 1, 2 },{ -2, 3, -3 },{ 0, 2, 3 },{ 3, -3, -4 },{ -4, -1, 2 },{ -1, 2, 0 },{ 3, -1, -4 },{ 2, -2, 3 },{ 1, 2, 1 },{ -3, -3, -3 },{ -2, 3, -4 },{ 3, -4, 3 },{ -4, -2, 1 },{ -2, -3, -2 },{ -3, -3, 2 },{ 3, 3, 0 },{ -1, 0, -3 },{ 0, -3, 0 } },
+		{ { 3, 3, 3 },{ 2, -1, -4 },{ -1, -4, -1 },{ 3, -3, 1 },{ 0, -1, -4 },{ -2, -4, 1 },{ -4, -2, 2 },{ 0, 0, -3 },{ 2, -1, -1 },{ -1, -2, 3 },{ -2, -2, -4 },{ 0, 0, 1 },{ 2, 1, -1 },{ -2, -1, 2 },{ 2, 3, -1 },{ 0, 0, 0 },{ -1, 1, 3 },{ 2, 2, -2 },{ 1, -2, 2 },{ 3, -4, -2 },{ -1, 1, -3 },{ 2, -3, 3 },{ -2, 0, -1 },{ 1, -2, -2 },{ -4, 1, 3 },{ 3, 3, 2 },{ -2, -1, -3 },{ -4, 1, -1 },{ -1, 3, 2 },{ 0, 2, 0 },{ 1, -1, -4 },{ -1, 3, -1 },{ -3, -2, 3 },{ 0, 0, 1 },{ -1, -4, -3 },{ 2, -3, -4 },{ -1, -2, -3 },{ 1, 3, -2 },{ -2, -2, 2 },{ -1, 1, -3 },{ -4, 3, -2 },{ -2, -4, 1 },{ 2, -1, -1 },{ -1, 1, -2 },{ 0, -2, 2 },{ 1, 2, 0 },{ -4, -2, -3 },{ -1, -4, -1 },{ -3, 1, -1 },{ -1, 3, 0 },{ 2, 1, -3 },{ 1, -3, 1 },{ -3, -4, 2 },{ -2, 1, -1 },{ 0, 1, -2 },{ 3, -3, 3 },{ 0, 1, -1 },{ -1, 0, -2 },{ 1, 1, 0 },{ 0, 3, -3 },{ -1, 1, 3 },{ 1, -2, -4 },{ -3, 1, -2 },{ -2, -4, 1 } },
+		{ { 0, -1, 2 },{ -3, -2, 1 },{ -2, 3, -2 },{ 1, 2, 3 },{ -3, 1, 0 },{ -1, 2, -1 },{ 3, -3, 3 },{ 1, 2, -2 },{ -4, -4, 2 },{ -3, 2, 0 },{ -1, 3, -1 },{ 3, -3, 2 },{ -1, 2, -3 },{ 3, -3, -4 },{ 1, 1, 3 },{ -4, -2, -2 },{ -3, -3, 2 },{ -2, -1, 0 },{ -3, 0, -4 },{ 1, 3, 0 },{ -4, -2, 2 },{ -3, 1, -4 },{ -4, 3, 1 },{ 3, 2, 0 },{ -2, 0, 2 },{ -3, -2, -4 },{ 0, -3, -1 },{ 1, -1, 2 },{ 3, -4, -2 },{ -4, -2, 0 },{ -2, -3, -2 },{ 2, 0, 1 },{ -4, -4, 2 },{ 1, -2, -2 },{ -2, 1, 0 },{ 3, 2, 2 },{ -3, 2, 3 },{ -1, -3, 1 },{ 0, -4, -1 },{ 1, 2, 3 },{ 3, 0, -4 },{ -1, -3, -1 },{ -4, 3, 2 },{ -3, 0, -3 },{ 3, -4, -2 },{ -1, 3, 3 },{ 1, -3, 0 },{ 3, 0, -2 },{ 0, -2, -4 },{ 1, -1, 3 },{ -2, -2, -1 },{ 0, 0, -3 },{ -4, 3, 1 },{ 2, -2, -2 },{ -1, 0, 2 },{ -4, -1, 0 },{ 1, 3, 1 },{ -4, -4, 2 },{ -2, -1, -4 },{ 2, 2, -1 },{ -4, -3, 0 },{ 2, 0, 2 },{ 3, -4, -1 },{ -4, 2, -2 } },
+		{ { 1, -3, -3 },{ 3, 1, -1 },{ -1, 0, -3 },{ -4, -3, 2 },{ 1, -1, -3 },{ -3, 3, -4 },{ -1, -2, -1 },{ 3, 0, -3 },{ 0, -4, 1 },{ 1, -1, -4 },{ 2, -2, -2 },{ -4, 0, 3 },{ -3, -1, -2 },{ -2, -4, 0 },{ -4, -2, -3 },{ 0, 2, 1 },{ 2, -4, -3 },{ 3, 3, -1 },{ -1, -3, -4 },{ 0, 0, 1 },{ 2, -3, -1 },{ 1, -1, 2 },{ 0, -4, -3 },{ -1, -4, 0 },{ 2, -1, -4 },{ 1, -3, 0 },{ -2, 2, -2 },{ 3, 1, 1 },{ -3, 0, -4 },{ 2, 1, 3 },{ 0, 2, -3 },{ -3, -1, -4 },{ 2, 2, 0 },{ -3, 3, -4 },{ -2, -1, 3 },{ -4, -4, 0 },{ 2, 0, -1 },{ 3, -1, -4 },{ -4, -4, 1 },{ -3, -1, 0 },{ 2, -2, -3 },{ -2, 0, 0 },{ 1, -3, -2 },{ 2, 1, 1 },{ -2, -1, 1 },{ -4, -3, -4 },{ -3, 0, 2 },{ -2, 2, 1 },{ -4, -4, 1 },{ 2, 2, 2 },{ -3, -4, -2 },{ -1, 2, 3 },{ 3, 0, -4 },{ 0, -4, 0 },{ -2, 3, -4 },{ 3, 2, -3 },{ 2, -2, -1 },{ -3, -2, -3 },{ -1, 0, 3 },{ 3, -2, 1 },{ -3, 2, -3 },{ 0, -1, 2 },{ -1, -2, -3 },{ -3, 0, 0 } },
+		{ { -3, 0, 1 },{ 0, -4, 2 },{ -2, -2, -2 },{ 2, 1, -1 },{ 3, -2, 1 },{ 2, -4, 2 },{ -4, 1, 0 },{ -2, 3, 1 },{ -2, 2, -2 },{ -3, 1, 3 },{ 3, 1, 1 },{ 0, -4, -3 },{ 1, 2, 0 },{ 0, 1, 2 },{ 3, 3, 1 },{ -2, 0, -2 },{ 0, 1, 0 },{ 1, -1, 2 },{ -4, -4, 3 },{ -2, 2, -2 },{ 3, -1, 3 },{ -1, 1, -3 },{ -3, 0, -2 },{ 2, -3, 3 },{ -1, 1, -1 },{ -4, 2, -3 },{ 1, 3, 3 },{ -3, -2, 2 },{ -1, -3, -3 },{ -2, 3, -1 },{ 1, -4, 3 },{ 3, 0, -1 },{ 0, -2, 2 },{ 3, 1, -1 },{ 1, -3, -3 },{ 0, -1, -2 },{ 1, 2, -3 },{ -3, 1, 3 },{ -2, 3, -2 },{ 0, 1, 2 },{ 2, 3, 3 },{ -3, 2, -4 },{ 0, -4, 2 },{ -3, -2, 3 },{ 1, 3, -4 },{ 0, 1, -1 },{ 3, -1, -2 },{ 2, 2, -3 },{ 0, 0, 0 },{ -1, -2, -4 },{ 3, -1, 0 },{ -4, 1, -2 },{ 1, -1, 1 },{ -3, -2, -1 },{ -2, -4, 2 },{ -3, -1, 3 },{ 0, -3, -2 },{ 3, 2, 1 },{ 1, -4, -1 },{ 0, 0, -2 },{ -2, -4, 0 },{ -1, 1, 3 },{ 2, 3, -4 },{ 1, 2, 3 } },
+		{ { -1, -3, -4 },{ 3, 3, 3 },{ -4, 2, -4 },{ -1, -1, 0 },{ 0, 3, -3 },{ -3, 0, 3 },{ 1, -3, -4 },{ 0, -2, -2 },{ -1, 0, 3 },{ 2, -3, -4 },{ -4, -3, 0 },{ -2, 3, -1 },{ -3, 0, 3 },{ 1, -1, -4 },{ 2, -4, -1 },{ -3, -1, 3 },{ -1, -2, -4 },{ -3, 3, 0 },{ 0, 0, -3 },{ 3, 2, -2 },{ -2, -2, 0 },{ -4, 3, -3 },{ 0, 2, 1 },{ -3, 3, 2 },{ 2, -2, -2 },{ -4, -4, 2 },{ 0, 0, -4 },{ 2, -4, -1 },{ -3, -1, 1 },{ 1, 3, 0 },{ -4, -2, 2 },{ -1, -3, 0 },{ -1, 3, -4 },{ -2, 0, 3 },{ 2, -3, 1 },{ -4, 3, 1 },{ -1, -2, 2 },{ 3, -3, -1 },{ -1, -1, -2 },{ 1, -2, -4 },{ 0, -3, 1 },{ -4, 1, -1 },{ 3, -1, 0 },{ 1, 2, -3 },{ -2, 0, -1 },{ 3, -4, 0 },{ -1, -2, 3 },{ -3, 3, 3 },{ 1, -3, -1 },{ -4, 3, 1 },{ -2, -4, -4 },{ 1, 3, 2 },{ -2, -3, 3 },{ 0, 2, -1 },{ 2, 1, -3 },{ 1, 0, 1 },{ -1, 3, 0 },{ -3, 1, -4 },{ -4, 1, 2 },{ 2, 3, -4 },{ -3, -3, -3 },{ 3, 1, -1 },{ -4, -3, 1 },{ 2, -1, -2 } },
+		{ { -1, -1, -1 },{ -4, 1, 0 },{ 1, -4, 1 },{ 0, 0, 3 },{ -3, -3, -2 },{ -1, 1, -1 },{ 2, 2, 2 },{ -3, -4, 0 },{ 3, -1, -1 },{ 1, 3, -3 },{ 0, -1, 2 },{ -1, -2, 1 },{ 3, 3, -2 },{ -1, -2, -3 },{ -4, -3, -1 },{ -1, 3, 2 },{ 3, -3, -2 },{ 2, -2, -1 },{ -4, -4, 2 },{ 1, 1, 1 },{ -1, -4, -1 },{ 2, -3, -4 },{ 1, -3, 1 },{ 3, 0, 0 },{ -2, -2, -3 },{ 3, 2, 1 },{ -2, -1, 0 },{ 3, 1, -1 },{ -1, -3, -2 },{ 3, 0, -4 },{ 0, 1, -3 },{ -4, -4, -2 },{ 2, -1, -2 },{ -3, 2, 2 },{ 1, -4, -1 },{ -3, 1, -3 },{ -1, 0, -4 },{ -3, -4, 0 },{ 3, 2, 2 },{ -4, 0, -3 },{ -2, -4, -1 },{ -1, -1, -2 },{ 3, 3, 3 },{ -1, -2, -3 },{ -4, -3, 1 },{ 1, 2, -1 },{ -1, -1, 2 },{ -3, 1, -3 },{ 2, -1, -2 },{ 0, -3, -3 },{ 3, 0, 3 },{ -1, 1, -1 },{ 2, -1, -3 },{ -4, -3, -2 },{ 3, 3, 3 },{ -2, -3, -4 },{ 1, -1, 0 },{ -2, -2, -3 },{ 1, -3, 3 },{ 0, -2, 0 },{ -2, -1, 2 },{ 1, 0, 0 },{ -4, -2, -2 },{ -2, 3, 0 } },
+		{ { 2, 0, 2 },{ -3, -3, -1 },{ 3, 2, -4 },{ 2, -2, -3 },{ -2, -4, 1 },{ 3, 1, 0 },{ -4, 3, -4 },{ 0, -1, 1 },{ -4, -4, -2 },{ -3, 2, 2 },{ -1, 1, -2 },{ 2, -4, -4 },{ -4, 0, 3 },{ 2, -4, 0 },{ -2, 2, 2 },{ 1, 1, -4 },{ -2, 1, 1 },{ 0, 2, 3 },{ -1, -3, -3 },{ -3, 0, -4 },{ 2, 3, 3 },{ -2, -1, 3 },{ -4, -1, -1 },{ -1, 1, -4 },{ 0, 1, -1 },{ -3, -3, 3 },{ 1, 3, -4 },{ -1, 2, -2 },{ -4, -3, 2 },{ 2, -1, 3 },{ -2, 2, 1 },{ -3, 0, -3 },{ 3, 1, 3 },{ 0, -2, 0 },{ -2, 2, -4 },{ 2, -3, 0 },{ 0, -1, 3 },{ 1, 3, -2 },{ 2, 1, 3 },{ -3, 0, 1 },{ 1, 3, 0 },{ -1, -3, 2 },{ -3, 1, -4 },{ 2, -4, 2 },{ 0, 0, 1 },{ -4, 3, -2 },{ -2, -2, -4 },{ 1, -4, 0 },{ 3, 0, 1 },{ -2, 2, 2 },{ -3, -2, -1 },{ -3, 2, 1 },{ 1, -4, -4 },{ -4, 2, 0 },{ 0, -2, 2 },{ -1, 0, -1 },{ -4, -4, 2 },{ 3, 3, 1 },{ 2, 0, -1 },{ -3, 2, -2 },{ 3, 3, -4 },{ 0, -4, 2 },{ 3, 2, 3 },{ 0, -4, -3 } },
+		{ { -2, 3, -3 },{ 1, -2, 2 },{ -2, -1, -2 },{ -4, 2, 1 },{ 1, 3, 3 },{ -2, -1, -1 },{ 2, -2, -3 },{ -1, 0, 3 },{ 2, 2, 0 },{ -2, -2, -4 },{ 3, -3, 0 },{ -4, 0, 1 },{ 1, 2, -3 },{ -3, 1, 2 },{ 0, -1, -2 },{ 2, -2, 0 },{ -4, -4, -3 },{ 2, 0, -2 },{ -2, -1, 0 },{ 1, 1, -1 },{ 0, -2, -2 },{ -3, 2, 1 },{ 3, -4, -2 },{ 1, 3, 2 },{ 2, -3, -2 },{ -3, -4, 0 },{ 1, 0, 3 },{ -4, -2, -1 },{ -2, 0, 1 },{ 1, 3, 0 },{ -1, -4, 2 },{ 2, -2, -1 },{ 1, -3, 0 },{ 0, 3, 1 },{ -4, 0, -3 },{ 3, -1, 2 },{ -2, 3, -1 },{ -4, -4, -3 },{ -2, -3, -4 },{ 0, -2, -1 },{ 3, 0, -2 },{ 1, 2, -4 },{ -2, -2, 1 },{ -3, 0, -1 },{ 0, -3, -4 },{ 2, 1, 3 },{ 3, -1, -3 },{ -1, 1, -1 },{ -4, -4, 3 },{ -2, 3, -4 },{ 2, -2, 0 },{ 0, -4, -2 },{ 3, 0, 2 },{ -1, 0, 0 },{ -3, 1, -4 },{ 2, -1, -2 },{ -2, 2, -2 },{ 0, 1, -3 },{ -4, -4, 1 },{ -1, 2, 3 },{ -4, -2, 1 },{ -1, -3, -1 },{ -1, 1, -3 },{ 1, 0, 1 } },
+		{ { 0, -1, 3 },{ 3, -4, -1 },{ -1, 1, 0 },{ 0, 0, -4 },{ 3, -2, 2 },{ -3, -4, 0 },{ 1, 0, -2 },{ -2, -3, 1 },{ 3, 3, -3 },{ 1, 0, 2 },{ -3, 1, 3 },{ 0, 3, -4 },{ -2, -1, -1 },{ 3, -3, -3 },{ 0, -4, 1 },{ -3, 3, -4 },{ 3, 0, 3 },{ 1, 3, 2 },{ -3, -4, 1 },{ -1, 3, 2 },{ 3, -3, -3 },{ -2, 0, 0 },{ -1, -2, -4 },{ -4, 2, 2 },{ -2, 0, -3 },{ 0, -1, 1 },{ -1, 3, -3 },{ 2, -1, 2 },{ 0, -3, -3 },{ 3, -2, -4 },{ -3, 1, -3 },{ -1, 3, 3 },{ -2, 0, -4 },{ -1, -4, -2 },{ -3, -3, 3 },{ -1, -1, 1 },{ 2, 1, -1 },{ 1, -2, 2 },{ -1, 0, 0 },{ -3, -1, 1 },{ -4, -4, 3 },{ 2, 2, -3 },{ -4, 3, 2 },{ 3, -1, 0 },{ -2, 2, 0 },{ 1, -3, -2 },{ -3, 3, 2 },{ -1, 2, 0 },{ 1, -3, -2 },{ 0, -1, -4 },{ 3, 1, -2 },{ 1, -1, 3 },{ -2, 2, -3 },{ -3, -3, -1 },{ 2, 3, 1 },{ 1, -3, 3 },{ 3, 0, 2 },{ -3, -3, -4 },{ 2, -2, -1 },{ 1, 0, -3 },{ 2, -1, -4 },{ -3, 1, -2 },{ -3, -2, 0 },{ -4, 2, -4 } },
+		{ { -4, -4, 1 },{ 2, 3, 0 },{ -3, 2, -3 },{ -4, -3, -2 },{ 2, -3, 3 },{ -2, 1, -4 },{ 0, 2, -3 },{ -4, 1, 3 },{ 0, -3, -1 },{ -3, -4, -1 },{ -1, -1, -2 },{ 3, -2, 1 },{ 2, -3, 2 },{ -1, 2, 3 },{ -4, 1, -1 },{ -1, -1, 1 },{ -2, -2, 0 },{ 2, 1, -1 },{ -4, -3, -4 },{ 3, -1, 3 },{ -4, 1, -3 },{ 0, -4, 0 },{ 2, 1, 3 },{ 1, -1, 1 },{ -4, 1, -1 },{ 3, 2, -4 },{ 2, -4, 0 },{ -2, 1, -2 },{ -3, 2, 3 },{ 1, -4, -2 },{ -4, 1, -1 },{ 2, -1, 1 },{ -4, 2, -2 },{ 3, -2, 2 },{ 1, 3, -4 },{ 0, 2, -2 },{ 2, -4, 1 },{ -3, 2, -2 },{ 3, 1, -4 },{ 2, 3, 2 },{ -1, -3, -1 },{ 0, 1, -2 },{ 2, -4, 3 },{ -1, -2, -2 },{ -4, 1, -3 },{ -2, -4, 3 },{ 1, -1, 1 },{ -3, 0, -3 },{ 2, 2, 2 },{ -4, -4, 2 },{ -3, 3, 1 },{ -1, -3, -1 },{ -4, 1, 2 },{ 3, -2, 3 },{ 0, -4, -3 },{ -1, -1, -1 },{ -3, 3, 0 },{ -1, -1, 3 },{ 0, 1, 1 },{ -2, -4, 0 },{ 0, 3, 2 },{ 2, -3, 3 },{ 3, 3, 2 },{ 1, -3, -2 } },
+		{ { -1, 1, -4 },{ 2, 0, 2 },{ 0, -1, 1 },{ -1, -4, -1 },{ 1, 2, -1 },{ -1, -1, 2 },{ 3, 3, 0 },{ 2, -1, 2 },{ -3, -3, -4 },{ 1, 3, 1 },{ 2, 1, -3 },{ -4, -4, 0 },{ 0, 0, -2 },{ -3, 2, -4 },{ 2, -1, -2 },{ 1, -3, -3 },{ -2, 1, -1 },{ 0, -4, -4 },{ -1, 2, -2 },{ -2, -2, 1 },{ 1, 2, -1 },{ 2, 3, 2 },{ -1, -2, -4 },{ 3, -4, 3 },{ -2, -3, -1 },{ 0, -2, 1 },{ -3, 3, 2 },{ -4, -3, -2 },{ 3, 0, 1 },{ -1, 3, 0 },{ 0, -1, 2 },{ 0, -3, -3 },{ 3, -4, 0 },{ -2, 0, 0 },{ 0, -2, -1 },{ -4, 1, -4 },{ -3, -3, 0 },{ -2, -2, 3 },{ 0, -3, -3 },{ -4, 2, -1 },{ 0, -2, 1 },{ -2, -1, -4 },{ -3, -1, 1 },{ 0, -3, -3 },{ 2, 3, 2 },{ 3, 0, -4 },{ 0, -3, -1 },{ -2, -2, -2 },{ 2, 1, 0 },{ 3, -2, -3 },{ -2, 0, -1 },{ 1, -3, 0 },{ 2, 0, -4 },{ 0, 3, -2 },{ -2, 2, 1 },{ -4, -2, -4 },{ 1, -4, -2 },{ 3, 3, -3 },{ 1, -3, -1 },{ -4, 2, -2 },{ -2, 0, -2 },{ 3, 1, -4 },{ -1, -1, 1 },{ -2, -2, -1 } },
+		{ { -2, 2, 3 },{ -3, -3, -2 },{ 3, -2, -4 },{ -2, 1, 3 },{ 0, 0, 1 },{ -3, -2, -3 },{ -4, -4, -1 },{ 2, -2, -4 },{ -1, 2, -2 },{ 0, -1, 2 },{ -2, 2, 3 },{ -2, -2, -4 },{ -1, 3, 0 },{ 1, 0, 2 },{ -4, -4, 0 },{ 3, 3, 3 },{ 1, -2, 2 },{ -3, 3, -2 },{ 2, 0, 3 },{ 0, 0, 0 },{ -4, 2, -4 },{ -2, -3, -2 },{ -3, 0, -1 },{ -3, 2, -3 },{ 2, 3, -2 },{ 1, 0, -3 },{ -1, -4, -4 },{ 1, -1, 2 },{ -2, 1, -1 },{ 2, -3, -4 },{ -2, -2, 2 },{ -3, 2, -2 },{ 1, 3, -4 },{ 2, 1, 3 },{ -3, -1, 2 },{ 3, -4, 2 },{ 1, 0, -3 },{ 3, 3, 2 },{ -4, 0, 0 },{ 2, -1, 3 },{ 1, 1, -4 },{ 3, 3, -1 },{ -3, 0, 2 },{ 1, 2, 0 },{ -1, 2, -1 },{ -4, -2, 1 },{ 3, 0, -4 },{ 0, 3, 3 },{ -3, -4, 1 },{ -1, -1, -4 },{ -1, 3, 3 },{ 0, 2, -3 },{ -4, -4, 0 },{ -2, -1, -3 },{ 3, 1, 2 },{ 2, 2, 0 },{ -2, 0, 1 },{ -1, -1, 3 },{ -3, 1, -4 },{ 2, -2, 2 },{ 1, -1, 1 },{ -4, -4, 0 },{ 0, 0, -1 },{ 1, 2, -3 } }
+	},
+	{
+		{ { -3, -1, -1 },{ 0, 1, 1 },{ -1, 2, -4 },{ -3, 3, 0 },{ 0, -2, -2 },{ 1, -1, 2 },{ -3, 0, -1 },{ 0, 1, 0 },{ 0, -2, -4 },{ -4, 3, -2 },{ -1, -1, 0 },{ -4, 0, -4 },{ 3, 2, 3 },{ -1, -3, 1 },{ -3, 0, -3 },{ 0, -3, 3 },{ 2, 1, -2 },{ -1, 2, 1 },{ -3, 1, -3 },{ -2, -3, -2 },{ 0, -1, 0 },{ -3, -4, 2 },{ 3, 2, 3 },{ -2, 3, -2 },{ 3, -4, -3 },{ 0, -1, 3 },{ 1, 0, -1 },{ -3, -4, 1 },{ 0, 2, -4 },{ 1, 1, -2 },{ 3, -3, 1 },{ -2, 2, -1 },{ 0, -2, -4 },{ 2, -4, 0 },{ 1, 0, 1 },{ -2, -3, 1 },{ 0, -1, -4 },{ -4, -4, -2 },{ 2, 1, -1 },{ 3, -3, 3 },{ -1, 1, -1 },{ 1, 2, -2 },{ -3, 0, -3 },{ 3, -2, 1 },{ -1, -4, -1 },{ -4, -1, -1 },{ 1, -3, -3 },{ -3, 1, 3 },{ -4, 0, 0 },{ -1, -3, 3 },{ 3, 3, -1 },{ -1, -2, 2 },{ 2, -2, -2 },{ 0, -1, 2 },{ -1, -4, 0 },{ -1, -1, 1 },{ -4, 3, 2 },{ 1, -4, 0 },{ 3, 1, 0 },{ -2, -2, -2 },{ -3, 3, 2 },{ 3, -1, -2 },{ -2, -3, 1 },{ 2, -3, -1 } },
+		{ { -4, 3, 2 },{ 3, -2, 1 },{ -2, -3, -1 },{ 2, -1, 3 },{ 3, -4, -4 },{ -2, 2, -3 },{ 3, -4, -3 },{ -1, -2, 2 },{ 2, -4, -3 },{ -2, 0, 2 },{ 1, 1, 0 },{ 2, -3, 1 },{ -2, -2, 2 },{ -3, -4, -3 },{ 2, 3, -1 },{ -4, 3, 2 },{ -2, -2, -4 },{ 0, -1, 0 },{ 2, -3, -1 },{ -4, 3, 3 },{ 2, 0, -4 },{ -1, 1, -3 },{ 2, -3, -1 },{ -3, -2, 1 },{ 0, 2, -1 },{ -1, -2, 0 },{ -4, 3, -4 },{ -2, -3, -2 },{ -1, -1, 3 },{ -4, -2, -1 },{ 1, 1, 3 },{ 3, -4, 2 },{ -1, -1, -2 },{ -4, 2, 3 },{ 3, 3, -4 },{ -3, 0, 3 },{ -1, 2, -3 },{ -1, -2, 2 },{ -3, -3, 0 },{ -2, 3, -2 },{ -4, -1, -4 },{ 1, 0, 0 },{ 2, 1, 2 },{ -1, -3, -4 },{ 0, 1, 1 },{ -2, 0, 2 },{ 2, 3, -2 },{ -2, -2, -1 },{ 0, 0, 1 },{ 1, -1, -4 },{ -2, -4, -2 },{ 1, 1, 0 },{ -4, 2, 0 },{ -2, -3, -3 },{ -3, 3, 3 },{ 2, -3, -3 },{ 3, 0, -1 },{ -2, -1, -3 },{ 0, 3, -1 },{ 2, -2, 1 },{ -1, 2, -3 },{ -4, 0, 1 },{ 0, 1, -3 },{ 1, -1, -4 } },
+		{ { -2, -2, -4 },{ 1, 0, -2 },{ 1, -4, -3 },{ -4, 1, 2 },{ -3, 1, -1 },{ -1, -3, 1 },{ -4, 3, 0 },{ 1, -1, 3 },{ -4, 2, -2 },{ 3, -3, -1 },{ 0, 2, 3 },{ -4, 3, -2 },{ 1, -1, 0 },{ 0, 0, -4 },{ 3, 1, 2 },{ 1, -2, 1 },{ -4, 2, 0 },{ 0, -4, -3 },{ 3, 0, 1 },{ -3, 3, 2 },{ 1, -1, 0 },{ -1, -4, -2 },{ -4, 0, -4 },{ 1, 1, 2 },{ -3, -4, -4 },{ 3, -1, 3 },{ 1, 2, 2 },{ 3, 0, 0 },{ 2, 3, 2 },{ -3, -4, -3 },{ -2, 0, 1 },{ -4, 3, -4 },{ 0, -3, -3 },{ 2, -2, 2 },{ -3, 1, -1 },{ 0, -2, -2 },{ 2, 3, 0 },{ 1, 1, -1 },{ -3, 0, 2 },{ 0, 3, -4 },{ 3, -2, 1 },{ -3, -4, 3 },{ -4, -2, -1 },{ 0, 3, -2 },{ -4, 2, 3 },{ 3, -4, -4 },{ 1, 2, -3 },{ -1, -3, 2 },{ 3, 2, 0 },{ -4, 3, -2 },{ 0, -1, -3 },{ -3, -3, 3 },{ 3, 0, 2 },{ 0, 0, -4 },{ 1, 1, -2 },{ -2, -2, 1 },{ -4, 2, -4 },{ -1, -3, 2 },{ 1, -4, 3 },{ -4, 0, -4 },{ 3, -3, 0 },{ 1, -2, 3 },{ -3, 3, 2 },{ -1, -4, 0 } },
+		{ { -3, 1, 3 },{ 3, 2, -3 },{ -1, 3, 1 },{ -1, 0, 0 },{ 2, -1, -4 },{ 1, 2, 2 },{ -2, 0, -1 },{ 0, -3, -4 },{ -3, 3, 2 },{ -1, -2, 1 },{ 1, -4, -4 },{ -3, 0, -3 },{ -2, 2, -2 },{ 0, -3, -1 },{ -1, -4, 3 },{ -2, -1, -2 },{ 1, -3, -2 },{ 3, 1, 2 },{ -1, -4, -4 },{ 0, -2, -3 },{ -4, 2, 2 },{ -2, -2, -1 },{ 3, 3, 3 },{ 1, -1, 1 },{ -1, 1, -2 },{ -2, 3, 1 },{ -4, -3, -2 },{ 2, 1, -4 },{ -2, -2, -1 },{ 0, 1, -1 },{ 2, -1, -4 },{ 0, 2, 2 },{ 1, 0, 0 },{ -3, 1, -2 },{ 3, -4, -1 },{ -2, -3, 2 },{ -4, -4, -4 },{ 3, 2, 3 },{ 1, -3, -3 },{ -1, -4, 1 },{ 2, -1, -1 },{ -2, 2, -2 },{ 1, -3, 2 },{ -1, 0, 0 },{ 2, -1, 0 },{ -3, -1, -2 },{ -2, -2, 1 },{ 0, -3, 3 },{ 2, 0, -3 },{ -3, -4, 3 },{ 1, 1, 1 },{ -1, 3, -1 },{ 2, -4, -4 },{ -3, -2, 0 },{ 1, 2, -1 },{ 2, -4, 3 },{ -3, -1, -2 },{ 0, 2, 0 },{ -3, 1, 3 },{ -2, -1, -2 },{ -3, 2, -4 },{ -1, -4, -1 },{ 2, 2, -2 },{ 3, 1, -1 } },
+		{ { -2, -1, 2 },{ -3, -2, 0 },{ 0, -3, -1 },{ -4, 2, 3 },{ 3, -2, -2 },{ 0, -4, 1 },{ 3, -2, -2 },{ 2, 1, 0 },{ -2, -1, -3 },{ 3, 0, -1 },{ 2, 1, 0 },{ -1, -2, 2 },{ 3, -3, 1 },{ -4, 1, 1 },{ 2, 0, -4 },{ -4, 3, -3 },{ -1, -2, -1 },{ -3, 3, 3 },{ -3, 1, 0 },{ 1, 0, -1 },{ 3, -3, 1 },{ 2, -1, -3 },{ 0, 3, 2 },{ -3, -3, 0 },{ 2, 0, -3 },{ 1, 0, -1 },{ -1, -4, 3 },{ 0, -1, -3 },{ -3, -4, 2 },{ -1, 0, 1 },{ 3, -3, 0 },{ -3, 3, -2 },{ -1, -3, 0 },{ -2, -2, 1 },{ -1, 3, 3 },{ 1, 0, -3 },{ 0, -1, 1 },{ -2, -1, -1 },{ 2, 0, -2 },{ -4, 1, 3 },{ -1, 3, -3 },{ 3, -1, 0 },{ -2, 1, -4 },{ 3, 3, -3 },{ -3, -4, -3 },{ 1, 2, 2 },{ -4, 0, 0 },{ -4, 3, -2 },{ -1, -2, -4 },{ 2, 1, 0 },{ -3, -2, 1 },{ 3, 2, -2 },{ -1, 0, 2 },{ -4, -1, -2 },{ -2, 3, 1 },{ 3, 0, 2 },{ 0, 1, -3 },{ 3, -4, -1 },{ 0, 0, 1 },{ 1, -3, -3 },{ 3, 3, 0 },{ 0, -1, 1 },{ -4, 0, -3 },{ 1, -3, 1 } },
+		{ { 2, -2, -2 },{ 0, -4, -4 },{ 2, 0, 2 },{ -2, -4, -3 },{ -2, 3, -4 },{ -3, 2, -1 },{ -4, 1, 3 },{ -1, 0, 2 },{ -4, -4, 1 },{ 0, 3, -4 },{ -3, -1, 3 },{ -4, 1, -2 },{ 1, 3, -1 },{ -3, -4, 3 },{ 2, -1, 2 },{ 0, 2, 0 },{ -2, 0, 3 },{ 2, -1, 1 },{ 2, -3, -4 },{ -1, 2, -2 },{ -3, 2, 3 },{ 0, -4, -4 },{ -2, 1, -2 },{ -4, -2, -1 },{ -1, -4, -4 },{ 3, -2, -1 },{ -2, 3, 1 },{ -3, -2, 0 },{ 1, 2, -2 },{ -4, 3, 3 },{ 2, -4, -3 },{ 1, -2, 3 },{ 3, 0, -1 },{ 0, -1, -4 },{ 2, 2, 1 },{ -4, 3, -3 },{ -3, 1, 0 },{ -2, -2, 2 },{ 0, 2, -4 },{ 1, -2, 0 },{ -3, -3, 1 },{ -4, -4, 3 },{ 1, 0, 1 },{ -2, -2, 1 },{ -1, -3, 3 },{ 0, 1, -1 },{ 3, 3, -3 },{ 0, -4, 2 },{ 1, -1, -1 },{ -2, -3, -1 },{ -4, 0, -3 },{ -2, -2, -4 },{ 1, -4, 3 },{ 0, 3, -1 },{ -2, -3, -3 },{ -1, -3, 0 },{ -4, 3, -4 },{ 2, -2, -4 },{ -2, 3, 2 },{ -3, 1, 0 },{ 2, -2, 2 },{ -4, 0, 3 },{ 0, -3, -4 },{ -2, 3, -2 } },
+		{ { 3, 2, 3 },{ -4, 3, -1 },{ -3, 1, 1 },{ 1, 1, 3 },{ 2, -1, 0 },{ -1, -1, 1 },{ 0, -3, -4 },{ 2, 3, -3 },{ 1, -2, -2 },{ -1, 2, 0 },{ 2, -4, 2 },{ -2, -3, -3 },{ 3, 0, -3 },{ -2, 2, 0 },{ -1, -2, -4 },{ 1, -4, -2 },{ 3, -3, -2 },{ 0, 3, -3 },{ -2, -1, 1 },{ -4, -4, -3 },{ 1, 0, 2 },{ -3, 0, -1 },{ 3, -2, 1 },{ 2, 2, 3 },{ 0, 3, 2 },{ -4, 2, 3 },{ 0, 1, -4 },{ 2, -1, -2 },{ 3, 2, 1 },{ -2, 0, -4 },{ -1, -3, 2 },{ -4, 1, -4 },{ -3, 2, 2 },{ -4, -4, -3 },{ 2, -1, 0 },{ -1, -3, 3 },{ 3, -4, -2 },{ 2, 3, -2 },{ -1, -4, 3 },{ -3, 0, 2 },{ 0, 1, -1 },{ 2, 3, -2 },{ 0, 1, -4 },{ -4, 2, -2 },{ 2, -2, 3 },{ 1, -3, -4 },{ -1, 0, 1 },{ -2, -1, 3 },{ 3, 1, -4 },{ 0, 2, 3 },{ 1, 3, 2 },{ 3, 1, 0 },{ -4, -2, 0 },{ 2, 1, 2 },{ -3, -1, -2 },{ 2, 1, 3 },{ -1, -2, 0 },{ -4, 0, 3 },{ 1, -4, -1 },{ -1, -1, -3 },{ 0, 2, -4 },{ -2, -4, -1 },{ 3, 2, 0 },{ -1, 0, 2 } },
+		{ { 1, -1, 1 },{ -1, -1, -4 },{ 3, -3, -2 },{ -3, -2, -3 },{ 1, -3, 2 },{ 3, -4, -2 },{ -3, 0, -1 },{ -2, 2, 1 },{ 3, -3, 3 },{ -3, -1, -1 },{ 1, 0, -4 },{ 0, -2, 1 },{ 0, 3, -1 },{ -4, -2, 2 },{ 1, 0, -3 },{ -3, 2, 1 },{ -3, -4, 2 },{ -4, 1, -1 },{ 0, -2, 1 },{ 2, 3, 3 },{ 2, -2, 0 },{ -1, 3, 0 },{ 1, -3, -3 },{ -2, 0, 0 },{ -3, -1, -3 },{ 3, -3, 0 },{ -1, 0, 1 },{ -4, -4, 2 },{ -2, -3, -1 },{ 2, 0, -3 },{ 0, -1, 0 },{ -2, 2, -1 },{ 2, -2, 1 },{ 0, 1, -2 },{ -2, -3, 3 },{ 1, 1, -1 },{ 0, 0, -4 },{ -4, -2, 1 },{ 3, 2, -3 },{ 1, -1, -4 },{ 3, -4, -3 },{ -2, -1, -1 },{ 2, -2, 2 },{ 3, -4, 0 },{ -3, 3, -1 },{ -2, 0, -4 },{ 2, -3, 0 },{ -3, 2, 1 },{ -4, -2, -3 },{ -1, -4, -2 },{ -1, -1, 1 },{ -2, -4, -4 },{ 0, -3, -3 },{ -1, 2, 1 },{ 3, -4, -4 },{ 0, -1, -1 },{ 1, 2, 1 },{ -3, -2, -2 },{ 2, 3, 2 },{ 3, 2, 0 },{ -4, -3, -2 },{ 1, -2, 1 },{ -3, 1, -3 },{ -3, -4, -3 } },
+		{ { -4, 2, 2 },{ -2, -2, 0 },{ 0, 0, -1 },{ -1, 3, 3 },{ -4, 2, -4 },{ 0, 1, 0 },{ -4, -2, 2 },{ 2, 3, -3 },{ -2, -2, 3 },{ -4, 1, 0 },{ 3, 3, -2 },{ -3, 1, 3 },{ -1, -3, 1 },{ 2, 1, -2 },{ 0, -1, 3 },{ 3, 3, -1 },{ -1, -1, 3 },{ 1, 1, -4 },{ 3, 2, -2 },{ -2, 0, -1 },{ -1, -3, -4 },{ -4, -1, -2 },{ 2, 1, 1 },{ 0, 1, -2 },{ 1, -4, -1 },{ -3, 2, -3 },{ 1, -2, -2 },{ -1, 3, -4 },{ 1, 1, 3 },{ -3, -2, 2 },{ 0, -4, -1 },{ 1, 3, -2 },{ 3, -3, 3 },{ -1, 3, 1 },{ 1, 0, -4 },{ -3, 2, -1 },{ -3, -3, 2 },{ -1, 1, 1 },{ 2, 3, -1 },{ -2, 0, 0 },{ -4, -3, 1 },{ -1, 3, 3 },{ -1, 1, -3 },{ -3, 0, 1 },{ 1, -1, -2 },{ -1, 2, 2 },{ -4, -4, -2 },{ 1, 1, 0 },{ 2, 3, -2 },{ 3, -3, 3 },{ -3, -1, -1 },{ 2, 1, 2 },{ -3, 0, -2 },{ 1, 3, 3 },{ -4, -2, 2 },{ -2, 2, -3 },{ 3, 0, 1 },{ 0, -4, -3 },{ -3, -3, -4 },{ -2, 0, 3 },{ -1, -1, 1 },{ 3, 1, 3 },{ 0, 3, -1 },{ 2, -3, 0 } },
+		{ { 2, -2, 3 },{ 1, 1, -3 },{ -3, -4, 1 },{ 3, 0, 1 },{ -1, 2, -3 },{ -2, -4, 3 },{ 3, 1, -2 },{ 0, -1, -1 },{ 0, -3, -4 },{ -3, 2, 2 },{ -1, -4, 0 },{ 2, -2, -3 },{ -4, -1, -4 },{ -3, -4, 0 },{ -2, 1, -4 },{ 2, -3, 0 },{ -4, -2, -3 },{ -1, -3, -2 },{ 1, -4, 0 },{ -3, -1, 3 },{ -2, 3, -3 },{ 3, -4, 2 },{ -3, -2, 3 },{ -1, -3, -4 },{ -4, 3, 2 },{ 2, -2, 3 },{ -2, -3, 2 },{ 2, 0, -2 },{ 3, -2, -1 },{ -3, 3, 1 },{ -4, 1, 3 },{ 3, -1, -4 },{ -3, 2, 0 },{ -4, -4, -3 },{ 2, -1, 0 },{ 3, -2, 2 },{ -2, 3, -2 },{ 0, -4, -3 },{ -4, -1, 3 },{ -2, -3, -2 },{ 0, 2, 2 },{ 1, -2, -4 },{ -4, 1, 0 },{ 0, -4, 3 },{ 0, 2, 1 },{ 3, -2, -3 },{ -1, 1, 3 },{ 2, -2, 2 },{ 0, 0, 1 },{ -2, 0, -4 },{ -4, 2, -3 },{ 1, 3, 0 },{ 3, -1, -1 },{ -2, -3, -4 },{ -4, 0, 0 },{ 2, -4, -3 },{ -1, 3, -1 },{ -4, 0, 3 },{ 3, 1, -1 },{ 0, -3, -2 },{ 1, 3, -4 },{ -4, -2, 2 },{ -1, 0, -4 },{ -2, -4, -2 } },
+		{ { 1, 3, 1 },{ 0, 2, -4 },{ -2, 1, -1 },{ 2, -2, -1 },{ 1, -3, -2 },{ 2, -1, 0 },{ -3, -2, 2 },{ 1, 3, -4 },{ 3, -4, 1 },{ 1, -1, -2 },{ -2, 0, -1 },{ 3, 2, 3 },{ 0, 2, 0 },{ 1, 3, -2 },{ 1, -2, 2 },{ -2, 0, -3 },{ 0, 2, 1 },{ -3, 3, 2 },{ 3, -3, 1 },{ 0, 1, -4 },{ 0, 1, 2 },{ 2, 2, -1 },{ -3, 0, -3 },{ 0, 2, 1 },{ 3, -1, -1 },{ -2, 1, -4 },{ 0, 2, 0 },{ -4, -1, 0 },{ -1, 2, -4 },{ 2, -4, -3 },{ -2, 0, -2 },{ -1, -2, -3 },{ 1, -3, 2 },{ 0, -1, -1 },{ -1, 0, -2 },{ -2, -4, -4 },{ 3, 2, 0 },{ 1, -2, 3 },{ -1, -1, -1 },{ 3, 2, -2 },{ 2, -4, 1 },{ -3, 3, -3 },{ 3, 0, -2 },{ 2, -3, -1 },{ -3, -1, -4 },{ 2, -4, 0 },{ -2, 3, -4 },{ -4, -3, -1 },{ 1, -1, -3 },{ -3, -4, 2 },{ 0, -2, 0 },{ -1, -4, 3 },{ -2, -2, 1 },{ 0, 2, 2 },{ 2, 1, 1 },{ 1, -2, -2 },{ -3, -3, 2 },{ -1, 1, 0 },{ 1, -2, 1 },{ 2, 3, -2 },{ -2, 2, -1 },{ -3, -4, 0 },{ 3, 1, 2 },{ -1, 0, -2 } },
+		{ { -3, 0, 2 },{ -4, -4, -3 },{ 3, -3, 2 },{ -4, -1, 3 },{ -3, 3, -4 },{ -2, 2, 1 },{ -1, 1, -2 },{ -4, -3, 1 },{ -1, 0, 3 },{ -3, 2, -3 },{ -2, -2, 2 },{ 1, -3, -3 },{ -4, -3, 2 },{ -1, -1, -1 },{ 3, -4, 3 },{ 2, 0, -4 },{ -4, -4, 0 },{ 2, 0, 3 },{ -1, 2, -1 },{ -4, -1, -2 },{ -2, -2, 0 },{ 3, -4, 1 },{ 1, 3, -4 },{ -2, -3, -1 },{ 2, -1, 0 },{ -1, -4, 1 },{ 1, 0, -2 },{ -3, -3, 2 },{ 0, -1, 1 },{ 2, 2, 2 },{ 1, -3, 0 },{ -1, 0, 1 },{ -3, 2, -1 },{ -4, 1, 1 },{ 3, 1, 3 },{ -4, 3, 2 },{ 0, -3, 1 },{ -3, 0, -3 },{ 2, 1, -4 },{ -4, -4, -1 },{ 0, 0, 3 },{ 1, -1, 0 },{ -2, -2, -1 },{ -2, 2, 2 },{ -4, 3, 3 },{ -3, 0, -1 },{ 0, 1, -3 },{ -2, -2, 2 },{ 3, 3, -1 },{ -1, 2, 1 },{ 2, 1, -2 },{ 3, 3, -4 },{ -4, 0, -3 },{ -1, -4, -2 },{ -3, 3, -1 },{ 0, -1, 3 },{ -2, 2, -4 },{ 2, -4, -4 },{ -4, -1, 2 },{ -3, -4, -3 },{ 1, 0, 3 },{ -1, -1, -3 },{ 2, -3, -3 },{ 0, -2, 0 } },
+		{ { 3, -1, -1 },{ -1, -2, -4 },{ -1, 1, -2 },{ 0, -1, 0 },{ 0, 0, -3 },{ 3, -4, 2 },{ 1, 0, -1 },{ 1, 2, -3 },{ -4, -1, 0 },{ 2, 3, -1 },{ 2, 1, -2 },{ -1, 0, -4 },{ 3, 1, 1 },{ -3, 3, -1 },{ -3, 1, 1 },{ -1, -2, -1 },{ 0, 3, 0 },{ -2, -2, -3 },{ 2, -1, -3 },{ -1, 3, -1 },{ -4, -3, 3 },{ 1, 0, 0 },{ -1, -1, -3 },{ -4, 1, 3 },{ -3, -2, 3 },{ 2, 2, -3 },{ -4, 3, -4 },{ 3, -4, 3 },{ -2, -2, -3 },{ -3, 3, -1 },{ -4, -2, 3 },{ 3, -4, -4 },{ 2, 3, 2 },{ 2, -4, -2 },{ -2, -2, -4 },{ 1, 2, -1 },{ -3, -2, -2 },{ -2, 3, 0 },{ 1, 1, 2 },{ -1, -3, 2 },{ -3, 3, 0 },{ -1, -1, -3 },{ 3, -4, 2 },{ -1, 0, -3 },{ 1, -3, 1 },{ 1, 1, -2 },{ 3, -1, 1 },{ 2, 2, 3 },{ -4, -3, -2 },{ -3, 0, 0 },{ 1, -2, -3 },{ -3, -3, 3 },{ 0, 0, -1 },{ 3, -1, 2 },{ 2, 2, 0 },{ -2, -2, -3 },{ 3, 0, -2 },{ 1, 3, 1 },{ -1, -1, 0 },{ 0, 1, -2 },{ 3, 2, 2 },{ -3, -3, 1 },{ 1, 3, 3 },{ -4, 2, 1 } },
+		{ { -2, -4, -3 },{ 1, 3, 3 },{ 2, 1, 1 },{ -3, 2, -1 },{ -2, 3, 3 },{ 2, -3, 0 },{ -2, -2, -4 },{ 0, -2, 3 },{ 3, -4, -2 },{ 0, -3, 2 },{ -2, -4, 1 },{ -4, -2, 3 },{ 0, -4, -4 },{ 0, 2, -3 },{ 2, -1, 2 },{ -4, -3, -4 },{ 3, 2, -2 },{ -3, 1, 3 },{ 1, -4, 2 },{ 3, -3, -4 },{ -2, 2, 2 },{ -3, 2, -4 },{ 2, -2, -2 },{ 0, -4, 2 },{ 3, 3, -2 },{ 0, 0, -1 },{ -1, -2, 1 },{ 1, 1, -2 },{ 3, 0, 0 },{ 0, 1, -2 },{ -2, 2, -1 },{ 0, -1, -3 },{ -1, 1, 3 },{ -3, 0, 0 },{ 0, -3, -3 },{ 2, -1, 3 },{ 3, 0, 2 },{ 0, -3, 1 },{ 2, -1, -3 },{ -2, -2, -4 },{ 3, 2, 1 },{ -4, 1, -4 },{ 2, 3, 0 },{ -4, 2, -2 },{ 0, -2, 1 },{ -1, -4, -4 },{ -3, -1, 0 },{ 0, 3, -3 },{ -1, -4, -4 },{ -2, -1, 0 },{ 3, -3, 2 },{ -2, 3, -1 },{ -3, 1, 1 },{ 1, -4, -4 },{ -1, -3, 3 },{ -4, 1, 1 },{ -4, -4, 2 },{ -1, -3, -1 },{ 3, 2, 3 },{ -2, -2, -4 },{ 0, -4, -2 },{ -4, -1, -1 },{ -2, 1, -4 },{ 2, -1, -1 } },
+		{ { 0, 3, 2 },{ -3, 0, 1 },{ 3, -4, 0 },{ 1, -2, -4 },{ -4, -4, -3 },{ 2, 0, -2 },{ -4, 3, -1 },{ -3, 1, 2 },{ -2, 0, -1 },{ -3, 2, -4 },{ 1, 0, 0 },{ 3, 3, -2 },{ -3, -1, 2 },{ 1, -2, -2 },{ -2, 0, 0 },{ 1, -3, 3 },{ 0, -1, 1 },{ -1, 0, 0 },{ -3, 1, -2 },{ 2, 0, 1 },{ 0, 1, -2 },{ 3, -3, -1 },{ -1, 0, 2 },{ -2, 2, 0 },{ 1, -1, -4 },{ -2, -4, -1 },{ -4, -1, 3 },{ -2, 1, -4 },{ -3, -3, 2 },{ -1, -4, 1 },{ 2, -3, -4 },{ -3, 0, 0 },{ 1, -2, -3 },{ -4, -2, 1 },{ -1, 3, 0 },{ -2, -4, -3 },{ -1, 3, -4 },{ -1, -4, -2 },{ -4, 2, 3 },{ 2, -4, -1 },{ 0, 0, -2 },{ -3, -3, 2 },{ 0, -3, -1 },{ 2, -1, 3 },{ 2, 3, -4 },{ -2, -3, 3 },{ -4, 2, -1 },{ 2, -2, 2 },{ -2, 0, 3 },{ 0, 1, -4 },{ 2, 2, -1 },{ 1, -1, 3 },{ -4, -2, -3 },{ 2, 3, -2 },{ -3, 0, -2 },{ 3, -2, -4 },{ 0, 3, -1 },{ 1, 1, -3 },{ -3, -1, 0 },{ -4, 3, 2 },{ 2, 0, 0 },{ 1, 1, 2 },{ -3, -3, 0 },{ 2, -2, -2 } },
+		{ { -4, -3, 0 },{ -4, 2, -4 },{ -1, -1, -2 },{ -3, -3, 2 },{ -1, 2, 3 },{ 0, -1, 0 },{ -1, 1, 1 },{ 3, -4, -4 },{ 1, -3, 3 },{ -1, 3, -3 },{ 2, -2, 0 },{ -2, 1, -1 },{ -1, -3, 3 },{ 3, 2, -1 },{ -2, 2, -3 },{ -4, -4, -4 },{ 2, 3, -1 },{ -2, -2, -3 },{ 0, -3, 3 },{ -4, 3, 0 },{ -1, -2, 1 },{ -4, -4, -1 },{ 1, 3, 3 },{ -4, 1, 1 },{ -3, -3, -3 },{ -1, 3, 2 },{ 2, -3, 1 },{ 3, 2, -2 },{ 1, 3, -3 },{ -4, -1, 3 },{ 3, 3, 2 },{ -2, 1, -1 },{ 3, -4, 3 },{ -4, 2, -2 },{ 2, 0, 1 },{ 3, 1, 2 },{ -3, -2, -1 },{ -4, 0, 0 },{ 1, 1, 1 },{ -3, -1, -3 },{ -1, 1, 3 },{ 1, -2, 1 },{ -2, -4, -3 },{ -2, -1, 2 },{ -3, 0, 0 },{ 3, 1, -3 },{ -1, -4, -1 },{ 3, 3, 2 },{ -4, 0, 1 },{ 1, -4, -2 },{ -4, 2, -3 },{ -1, -2, 1 },{ 0, 1, 0 },{ -2, -4, 2 },{ 2, 2, 1 },{ -1, 0, 0 },{ -2, -2, 3 },{ 2, 2, -3 },{ 0, -4, 1 },{ 2, -3, -2 },{ 1, -2, -4 },{ -1, 3, 1 },{ -1, 0, 3 },{ 3, 2, -3 } },
+		{ { 0, -4, 3 },{ 1, -2, -1 },{ 3, 2, 1 },{ 0, -2, -1 },{ -2, 1, 1 },{ 1, 0, -3 },{ 2, 3, -1 },{ -3, -3, 1 },{ 1, -1, -2 },{ -4, -1, 1 },{ 3, 2, 3 },{ -4, -4, -3 },{ 1, 0, -4 },{ -3, -2, 1 },{ 0, 3, 1 },{ -1, 1, 2 },{ 3, -1, -2 },{ -4, 2, 1 },{ 1, -4, -4 },{ -1, 2, 2 },{ 3, -1, -3 },{ -2, -1, -3 },{ 2, -2, -4 },{ 3, -3, -2 },{ 1, 0, 0 },{ 2, 2, -3 },{ -1, 0, 2 },{ -3, -1, 0 },{ 0, -2, -4 },{ -1, -2, 0 },{ 2, 2, -2 },{ 0, -3, -3 },{ 1, 3, 0 },{ -1, -3, -4 },{ 0, 2, -1 },{ -3, -1, -4 },{ 0, -3, -1 },{ 2, 2, 3 },{ 0, -2, -4 },{ 3, 3, -1 },{ -2, -3, 0 },{ 2, 3, -4 },{ 3, 2, -1 },{ -1, 1, -2 },{ -4, 2, 1 },{ 1, -3, 1 },{ 0, -1, -3 },{ 2, 1, -2 },{ -1, -2, -1 },{ 3, -3, 1 },{ -3, 3, 0 },{ -1, -3, -4 },{ 3, 0, -1 },{ -3, -1, -3 },{ 0, 2, -2 },{ -2, -1, 2 },{ 3, -4, 0 },{ -4, -1, -4 },{ -1, 1, 3 },{ -3, 0, -1 },{ -2, 2, -3 },{ 3, -4, 2 },{ -2, -1, -2 },{ 0, -1, -1 } },
+		{ { 2, 0, -4 },{ -1, 1, 2 },{ -2, 0, -3 },{ 3, 3, -2 },{ -4, -4, -4 },{ 3, -3, 2 },{ -4, -1, -3 },{ -2, -2, 3 },{ 0, 2, -2 },{ -1, 1, -4 },{ -2, 0, 2 },{ 2, -4, -1 },{ 0, 1, 0 },{ -1, -1, 3 },{ 2, -4, -4 },{ -3, -3, -1 },{ 2, 1, 2 },{ 0, -2, 3 },{ -3, -3, -3 },{ 2, 0, -1 },{ 1, 1, 0 },{ -3, 3, 3 },{ 0, 1, 0 },{ -1, 2, 2 },{ -4, -2, -1 },{ 0, -4, 3 },{ 0, 1, -4 },{ 2, -4, -1 },{ -4, 3, 3 },{ 1, -4, 1 },{ -2, 0, -1 },{ -4, -1, 3 },{ -3, -1, 2 },{ 3, -4, 2 },{ 1, 1, -2 },{ -2, -2, 3 },{ -4, 1, -3 },{ 2, 3, 1 },{ -2, -1, 2 },{ 0, -4, -3 },{ -4, -1, 2 },{ -4, 0, 0 },{ 1, 0, 3 },{ -1, -2, -4 },{ 3, -4, 3 },{ 1, -2, 0 },{ -3, 2, -4 },{ -3, -3, 0 },{ -2, 1, -4 },{ 0, -1, 3 },{ 1, -1, 2 },{ -3, -4, -2 },{ 2, 2, 2 },{ 1, 3, 0 },{ -4, -3, 3 },{ 1, -3, -4 },{ -3, 3, -2 },{ 0, 0, 2 },{ 2, 2, -1 },{ 3, 1, 0 },{ -3, -3, 3 },{ -4, 3, -4 },{ 1, -3, -3 },{ -3, 2, 1 } },
+		{ { -3, 3, -2 },{ -4, -3, 0 },{ 2, -4, 3 },{ -3, -1, 0 },{ 0, -1, 3 },{ -1, 2, 0 },{ -2, 0, -1 },{ 2, 2, 0 },{ 3, -4, 2 },{ -3, -2, 0 },{ -1, -3, 1 },{ 1, 3, -2 },{ -3, -1, -3 },{ -2, 2, -2 },{ 3, 0, 0 },{ -4, -2, -3 },{ 1, 3, 0 },{ -2, -1, -1 },{ 3, 0, -4 },{ -2, 2, 3 },{ -4, -4, 1 },{ 0, -3, -2 },{ -3, -4, 2 },{ 3, 0, -4 },{ -2, 3, -1 },{ -4, -2, 1 },{ -2, 1, 1 },{ 3, -1, -2 },{ -3, 0, -3 },{ -1, 2, 2 },{ 3, -3, -4 },{ 2, 1, -2 },{ -2, 2, -3 },{ -4, -2, 1 },{ 2, 3, 0 },{ -1, 0, 1 },{ 3, -4, -2 },{ 1, -3, 0 },{ -1, 0, -2 },{ -3, 1, -3 },{ 2, 2, 2 },{ 0, -3, -2 },{ -2, -2, 1 },{ -3, -4, -3 },{ 0, 3, -1 },{ -4, 0, -2 },{ 2, 3, 3 },{ 0, -2, 2 },{ -4, 3, -3 },{ 3, 1, -1 },{ 1, 2, -3 },{ -2, 0, 1 },{ -2, -2, 3 },{ 2, -3, -4 },{ -1, -1, -1 },{ 3, 1, 1 },{ 0, 1, -1 },{ -2, -2, -3 },{ 1, -3, 1 },{ -1, -4, -2 },{ 0, -1, 2 },{ 2, 0, -1 },{ 1, -2, 3 },{ -1, 1, 1 } },
+		{ { 3, -2, -1 },{ -2, -3, 3 },{ 0, 1, -3 },{ 1, 3, 1 },{ 2, -2, -4 },{ -1, 1, -2 },{ 3, -4, 2 },{ 0, 3, -3 },{ -4, 0, -4 },{ 2, 1, -1 },{ 0, 3, 3 },{ -4, -2, -3 },{ 3, -3, 2 },{ -1, 3, 2 },{ 1, 1, 3 },{ -1, -3, -2 },{ -2, 2, -4 },{ 0, -4, 1 },{ -4, 3, 1 },{ 2, -2, -2 },{ -1, -1, 0 },{ 2, 3, -4 },{ -2, -1, -1 },{ 1, 1, -3 },{ 2, -1, 3 },{ -3, -3, -4 },{ 1, 2, -3 },{ 1, -3, 0 },{ -2, -1, 2 },{ 2, 3, -2 },{ -2, 1, 0 },{ 0, -4, 1 },{ 1, -2, -3 },{ 0, 0, -1 },{ -4, -4, -4 },{ -1, 2, 0 },{ 0, -1, 2 },{ -4, 3, -4 },{ -3, -2, 3 },{ 3, 2, -1 },{ 1, -4, 1 },{ 3, 0, -4 },{ -3, 2, -1 },{ 2, 1, 2 },{ 1, -1, 0 },{ -2, 1, 1 },{ -1, -4, 2 },{ 3, 0, -2 },{ 1, -4, 0 },{ -2, -2, 3 },{ -4, -4, -4 },{ 2, 3, -2 },{ -4, -1, -1 },{ 0, 1, -3 },{ -3, 3, 1 },{ -4, -4, -2 },{ 2, 0, 3 },{ -3, -2, 2 },{ 3, 3, -4 },{ -4, -1, 1 },{ -1, 2, -3 },{ -3, 3, -2 },{ 0, 1, 0 },{ 3, -4, -4 } },
+		{ { -1, 2, 2 },{ 2, -1, -2 },{ -1, 1, 1 },{ -3, 2, -2 },{ -3, -3, -3 },{ -4, -3, 2 },{ 1, 0, 3 },{ -2, -3, -1 },{ -3, -1, 1 },{ 0, -4, 1 },{ 1, -1, -2 },{ -2, 1, -4 },{ 2, 0, 0 },{ 0, -4, -1 },{ -4, -2, -4 },{ 2, 1, 1 },{ -3, 0, 3 },{ 3, -2, -2 },{ -1, -4, -1 },{ -3, 1, 2 },{ 1, 0, -3 },{ 3, -2, 3 },{ -4, 2, 2 },{ 0, -4, -2 },{ -1, -3, 0 },{ 3, 3, 2 },{ -1, 0, 1 },{ 0, 2, -1 },{ -4, -4, 3 },{ 0, -2, -4 },{ -4, -3, 0 },{ -3, 2, 3 },{ 3, 3, -2 },{ 1, 1, 2 },{ -3, -2, 3 },{ 3, 2, -3 },{ -2, 0, 2 },{ 2, 1, -3 },{ 0, -4, 1 },{ -4, -2, 0 },{ -2, -1, -4 },{ 0, 3, -1 },{ -1, -3, 3 },{ 3, 3, -2 },{ -2, -2, -4 },{ -4, -3, 1 },{ -2, -1, -4 },{ 2, 2, -2 },{ -3, 1, 1 },{ -1, -1, 0 },{ -1, 0, 1 },{ 0, -3, 2 },{ 3, -4, 0 },{ 0, -2, -4 },{ -2, 2, 2 },{ 3, -3, 0 },{ -1, 3, -4 },{ -2, -1, 0 },{ -3, 2, -1 },{ 1, -4, 0 },{ 3, -3, -2 },{ 2, -2, 1 },{ -2, -4, 2 },{ -4, 0, -3 } },
+		{ { 0, 3, 1 },{ -4, 0, -4 },{ 1, -3, 0 },{ 3, -2, -1 },{ 2, 0, 0 },{ -2, 3, 1 },{ 1, -1, -2 },{ 2, -2, -4 },{ -1, 3, -3 },{ 3, 2, 3 },{ -3, -3, -3 },{ -1, 2, 1 },{ -4, -4, 2 },{ 3, 3, -1 },{ -2, -1, -3 },{ 1, -1, 1 },{ 0, -3, 0 },{ 2, 3, -3 },{ -1, -1, 2 },{ -4, 2, -4 },{ 1, 1, 0 },{ -2, -3, 1 },{ -1, 0, -2 },{ -4, 1, 1 },{ 1, -1, 0 },{ -3, 0, -3 },{ -4, -4, -2 },{ 2, -2, -4 },{ 3, 1, 1 },{ -3, 0, -1 },{ 3, -1, 2 },{ -1, 0, -4 },{ -1, -1, 0 },{ -2, -4, 2 },{ 1, -3, -2 },{ 2, -1, -1 },{ -3, -3, -1 },{ -1, -3, 3 },{ 3, 1, -2 },{ 1, 3, 3 },{ -2, -2, 1 },{ -1, 1, 2 },{ -4, -1, 0 },{ 1, -3, -3 },{ 0, 0, 3 },{ 3, 2, -1 },{ 0, -2, -3 },{ 0, 3, -1 },{ -4, -3, 3 },{ 2, -2, -4 },{ 3, 3, -3 },{ -3, 2, 3 },{ 1, 1, -1 },{ -4, 1, 3 },{ 1, 0, 0 },{ -3, -1, -3 },{ 0, -4, -2 },{ 1, -3, 3 },{ 2, 2, -3 },{ -4, 1, 3 },{ 0, 0, 2 },{ -2, 0, -4 },{ -3, 2, 0 },{ 1, -2, -1 } },
+		{ { -1, 1, 3 },{ -3, -4, -2 },{ -2, 3, 2 },{ -2, -4, 3 },{ 0, 1, -3 },{ -1, 2, -4 },{ -3, -4, 2 },{ 0, 1, -1 },{ -4, 1, 0 },{ -2, -2, 2 },{ 2, 0, -1 },{ -3, -2, 3 },{ 1, 2, -2 },{ 0, -2, -2 },{ -3, 0, 3 },{ -1, 3, -1 },{ -4, 2, 3 },{ -2, 1, -4 },{ 1, -3, -2 },{ 3, -1, 3 },{ 0, -4, -1 },{ -3, 3, -3 },{ 2, -2, 3 },{ 0, -3, -4 },{ 3, 3, 2 },{ -2, 2, -1 },{ 1, -2, 3 },{ -1, 3, 1 },{ -2, 2, -2 },{ -1, -4, 2 },{ 1, 3, -3 },{ 2, 2, -1 },{ -4, -3, 1 },{ 2, 2, -4 },{ -2, 0, 0 },{ 0, 1, -3 },{ -1, 3, 1 },{ 1, 0, -2 },{ -2, 2, 0 },{ 1, 0, -4 },{ 2, -3, -3 },{ -3, 1, -2 },{ 3, -4, -3 },{ -3, 2, 1 },{ -4, -4, -4 },{ 1, -1, 2 },{ -3, 2, 0 },{ -1, -4, 2 },{ 3, 1, -3 },{ 1, 2, -1 },{ -2, -3, 2 },{ -3, -2, -3 },{ -1, -1, -2 },{ 2, -4, -4 },{ -1, 2, 2 },{ 2, -2, -1 },{ 3, 0, 1 },{ -4, 1, 2 },{ 0, 0, -4 },{ -2, -4, -1 },{ 1, -2, -3 },{ -1, 3, -2 },{ 3, -3, 3 },{ 0, -1, -3 } },
+		{ { 3, 0, -2 },{ 2, -2, 0 },{ 0, 2, -4 },{ 1, -2, 2 },{ -4, 0, -2 },{ 3, -3, 0 },{ -2, -2, 3 },{ 3, 2, 1 },{ 2, -3, -3 },{ 1, -4, -2 },{ 0, 3, -4 },{ -4, 1, 0 },{ 3, -1, -4 },{ -1, -3, 2 },{ 2, 2, 0 },{ 1, -4, -4 },{ 3, -4, 2 },{ 0, -2, 1 },{ -2, 1, -1 },{ -4, -3, 1 },{ 2, -1, -4 },{ -1, 2, 1 },{ 3, 1, -1 },{ -2, -1, -4 },{ -3, -4, 0 },{ 0, -1, -2 },{ 3, -3, 2 },{ -3, 1, -3 },{ 0, -3, -1 },{ 2, -1, 0 },{ -4, -3, 3 },{ -2, 1, -3 },{ 0, -4, -2 },{ 3, 1, 3 },{ -4, 3, -2 },{ 3, -2, 2 },{ -4, -4, 1 },{ 3, -1, -4 },{ -3, -2, 2 },{ -4, -4, -1 },{ -1, 0, -1 },{ 0, 3, 3 },{ 2, -2, 0 },{ 0, 0, -1 },{ -1, 3, 3 },{ 3, -1, -2 },{ 2, -3, 0 },{ -2, 0, 1 },{ -4, -1, -2 },{ 2, -4, 3 },{ -4, 1, 0 },{ -2, 0, 0 },{ 3, -2, 1 },{ 0, 3, 1 },{ -4, -3, -2 },{ -2, 2, 3 },{ -3, 3, -3 },{ 1, -2, -2 },{ -1, -3, 1 },{ -3, 3, 0 },{ 3, -1, 1 },{ -4, 1, 2 },{ -3, 2, -1 },{ 2, -4, 1 } },
+		{ { -4, 2, 2 },{ 1, -1, -1 },{ -1, 3, -3 },{ 2, -1, -1 },{ -4, 1, 1 },{ -1, -1, -1 },{ 1, 3, -4 },{ -3, -1, -1 },{ -4, 0, 3 },{ -1, 0, 1 },{ -2, -4, 2 },{ 2, -1, 1 },{ 1, 3, -1 },{ -2, 0, 1 },{ -3, 1, -3 },{ -4, -2, -2 },{ 2, 0, -1 },{ -3, -1, -3 },{ -1, 2, 0 },{ 2, 3, 2 },{ -3, 0, 0 },{ -4, -2, -3 },{ 1, -4, 2 },{ -3, 2, -2 },{ 2, 1, 1 },{ -4, 0, 3 },{ 2, -1, 0 },{ -1, 2, -4 },{ 2, -1, 3 },{ -3, 0, -4 },{ -2, 3, -2 },{ 1, -2, 1 },{ 0, -2, 2 },{ -3, -1, -1 },{ -1, -3, -3 },{ 1, 1, 3 },{ -3, -1, -4 },{ 0, 2, 0 },{ 0, -3, 3 },{ 3, 3, -2 },{ -4, -2, 2 },{ 2, 2, 1 },{ -2, -1, -4 },{ -2, 1, 2 },{ 1, -3, -1 },{ -4, 1, -3 },{ -1, 1, 3 },{ -3, 3, -4 },{ 0, -2, -3 },{ 0, 0, 1 },{ 1, 3, -2 },{ 0, -4, -4 },{ 1, 1, -1 },{ -4, 0, 3 },{ 2, -3, -4 },{ -1, -1, -1 },{ 0, 1, -1 },{ -3, -4, 0 },{ 3, 0, -4 },{ 2, 2, 3 },{ 0, -3, -2 },{ 1, -2, -4 },{ -1, -1, 0 },{ -2, -3, -4 } },
+		{ { -2, 1, 3 },{ -3, -3, 1 },{ -3, -4, -4 },{ 3, 0, 3 },{ -2, -3, -2 },{ 2, -4, 3 },{ 0, 2, -3 },{ -2, -4, -2 },{ 3, 1, 0 },{ 0, -2, -4 },{ 3, 3, -2 },{ -4, -3, -3 },{ -3, -1, -3 },{ 0, -4, 3 },{ 2, 3, 2 },{ -1, -3, 0 },{ -2, 1, 3 },{ 0, 3, -3 },{ 3, -4, -4 },{ 1, -2, -2 },{ -1, -3, -2 },{ 3, 0, 3 },{ -2, 3, -1 },{ 0, -3, 0 },{ -1, -2, -3 },{ 1, 3, -4 },{ -3, -3, -1 },{ 0, 1, 1 },{ -4, -4, -2 },{ 3, -4, 1 },{ -1, 2, 0 },{ 2, 0, -3 },{ -3, 2, 3 },{ 3, 3, -4 },{ -1, -3, 1 },{ -2, 2, 0 },{ 2, -4, -1 },{ -1, 1, -3 },{ 2, -2, -3 },{ -2, 1, 1 },{ 1, 0, -4 },{ 3, -4, -3 },{ -4, -3, -2 },{ -3, 3, 3 },{ 3, -2, -4 },{ -2, 2, -3 },{ 1, -4, -1 },{ 3, -2, 2 },{ 1, 2, 0 },{ -1, -3, -4 },{ -3, -1, -1 },{ 2, 2, 3 },{ -1, 2, 2 },{ -3, -2, -3 },{ 3, -1, 0 },{ 1, 3, 2 },{ 3, -4, 2 },{ -1, 2, 3 },{ -4, -2, -3 },{ 1, -1, -1 },{ -2, 1, 2 },{ -4, -4, 3 },{ 3, 0, -1 },{ 0, 3, -3 } },
+		{ { -1, -4, -3 },{ 1, -1, -2 },{ 2, 2, 2 },{ 0, 1, 0 },{ -3, 3, 1 },{ 1, -2, -4 },{ -1, 0, 2 },{ -4, -2, 1 },{ 2, 3, -3 },{ -3, -3, 2 },{ 1, 1, -1 },{ -1, 2, 3 },{ -1, -3, 0 },{ 3, -2, -1 },{ 0, 2, -2 },{ 1, -1, -4 },{ -3, 0, 1 },{ 3, -3, 3 },{ -4, 0, -1 },{ -2, 1, 3 },{ -3, 2, 2 },{ 0, -1, -4 },{ 2, 1, 1 },{ -3, -1, 3 },{ -1, 0, 2 },{ 3, -4, -2 },{ -2, 2, 2 },{ -2, -2, 3 },{ 0, 3, -3 },{ 3, -2, 2 },{ -2, 1, -1 },{ -4, -3, -4 },{ 1, -4, 0 },{ 2, -1, -1 },{ -4, 0, -2 },{ 1, -2, 3 },{ 2, 0, 1 },{ -4, 3, -2 },{ -2, -1, 2 },{ 1, -3, 0 },{ -1, 2, 3 },{ -1, -1, -2 },{ 0, -3, 2 },{ 2, 0, -1 },{ 0, -4, 0 },{ -3, -1, 1 },{ 2, -2, 0 },{ -4, 0, 2 },{ -3, 3, -1 },{ 3, -4, 3 },{ -2, -1, 1 },{ -4, -2, -3 },{ -1, -3, -2 },{ 0, 2, 0 },{ -2, -4, -2 },{ -2, 1, -4 },{ 1, -2, -3 },{ -4, -1, 1 },{ -2, 0, 0 },{ 2, 2, -4 },{ -2, 3, -2 },{ -3, 2, -3 },{ 2, -2, 1 },{ 2, 0, 1 } },
+		{ { -4, -2, 3 },{ 3, 3, 0 },{ -1, -2, -2 },{ -3, -4, -1 },{ 0, 2, -3 },{ -4, 1, 3 },{ 3, -1, 0 },{ 1, 3, -1 },{ -1, -4, 2 },{ 2, -1, -2 },{ -2, -2, 0 },{ 1, 2, -4 },{ -4, 0, 2 },{ -3, 1, -2 },{ -4, -1, -4 },{ -2, -4, 1 },{ 2, 2, -1 },{ -4, -2, 1 },{ 0, -2, 0 },{ 1, 2, -3 },{ 3, -3, 1 },{ -1, -4, 0 },{ 1, 3, -3 },{ -4, -3, -2 },{ 3, 2, -4 },{ -4, -2, 0 },{ 2, 0, 0 },{ 1, 1, -1 },{ -4, -1, -3 },{ 1, -1, 0 },{ -1, 3, -2 },{ 0, -2, 3 },{ -2, 0, 1 },{ -1, 2, 2 },{ 0, 1, -2 },{ -3, -3, -4 },{ 3, 2, 2 },{ 0, -1, 3 },{ -3, -4, -1 },{ 3, 0, -4 },{ -3, 3, -1 },{ -4, -2, 0 },{ -1, 3, 1 },{ 2, 1, -3 },{ -3, 2, 2 },{ 0, 1, 3 },{ -1, 3, -2 },{ 3, -3, -4 },{ -2, 1, -3 },{ 0, 1, -2 },{ 2, 0, -1 },{ 3, 3, 2 },{ 1, -4, -4 },{ 3, 0, 1 },{ -3, 3, -1 },{ -4, -2, 3 },{ -1, 1, -2 },{ 2, 3, 2 },{ 0, -3, -3 },{ 3, -3, 1 },{ -1, -4, 2 },{ 1, -1, 0 },{ 0, -3, -4 },{ -3, 2, -1 } },
+		{ { 0, -3, 2 },{ 2, 0, -4 },{ -4, 1, 2 },{ -2, -1, 1 },{ -1, -3, -4 },{ 2, -4, -2 },{ -2, -2, -1 },{ -3, 2, -4 },{ 0, 1, -3 },{ -4, 0, 3 },{ -3, 0, 1 },{ 3, -4, -2 },{ 2, -2, -3 },{ 0, 3, 3 },{ 1, -3, 0 },{ 3, 1, 2 },{ -1, -2, -2 },{ 0, 3, -4 },{ 2, -4, 0 },{ -2, -1, -2 },{ -4, 3, -4 },{ -3, -1, -1 },{ 2, -2, -2 },{ -2, 2, 1 },{ 0, -1, 3 },{ 0, -4, -1 },{ -3, 3, -4 },{ -1, -3, -3 },{ 2, 0, 2 },{ -3, -4, 1 },{ 2, 1, -4 },{ 3, -1, 2 },{ -3, 3, -3 },{ 3, -4, -3 },{ -4, -2, 2 },{ 1, 3, 0 },{ -2, -4, -3 },{ -1, 2, -4 },{ -4, -3, -1 },{ 2, 1, 2 },{ 0, -2, 2 },{ 3, -4, -4 },{ -2, 0, 1 },{ -4, -1, -3 },{ 3, -3, -1 },{ 1, -2, -4 },{ -2, -4, -2 },{ 0, 0, 1 },{ -1, -1, 3 },{ -4, -3, 1 },{ 1, -2, 0 },{ -3, 1, -3 },{ -4, -1, 0 },{ 0, -2, 3 },{ 2, 0, 1 },{ 1, -3, -4 },{ 3, -4, 0 },{ -3, 2, -2 },{ -3, 0, -1 },{ 1, 1, 3 },{ -1, -2, 1 },{ -4, 0, -1 },{ 3, 3, 2 },{ -2, 1, -2 } },
+		{ { -3, 3, -1 },{ 0, 0, -3 },{ 1, -3, 0 },{ 3, 3, 3 },{ 1, 0, -2 },{ -4, 0, 2 },{ -1, -3, 1 },{ 0, 2, 3 },{ 3, -3, 1 },{ 1, -4, -1 },{ 0, 3, -4 },{ 1, -1, 1 },{ -2, -3, 2 },{ -1, 3, -1 },{ -2, -4, -3 },{ -4, 0, 3 },{ -2, 0, -1 },{ -3, 2, -3 },{ -1, -1, 3 },{ -1, 1, 2 },{ 2, 1, 3 },{ 0, 0, -1 },{ 1, -4, 3 },{ -1, 1, 2 },{ -2, -3, -3 },{ 1, 0, -1 },{ 3, -4, 3 },{ 0, 1, 2 },{ -1, 3, 1 },{ -3, -3, -2 },{ -2, 2, -1 },{ -4, -3, 3 },{ 1, -2, -2 },{ -2, 1, 0 },{ 2, 0, -1 },{ 0, -1, 1 },{ -3, -1, -1 },{ 1, -2, 0 },{ 2, 0, 1 },{ -2, 1, -3 },{ 0, -1, -3 },{ 1, 2, 3 },{ 1, 1, -2 },{ 2, -3, 3 },{ -2, 3, 0 },{ -4, 0, 1 },{ 2, 2, 3 },{ -4, 3, -1 },{ 1, -3, 0 },{ -1, 2, -4 },{ 3, 3, 2 },{ -1, -4, -4 },{ -2, 1, 2 },{ 2, 3, -2 },{ -2, 1, -3 },{ -1, 2, -1 },{ 0, -1, 3 },{ 0, -4, 2 },{ 2, -2, -4 },{ -4, 3, -3 },{ 2, 2, -2 },{ 0, -1, -4 },{ -3, -3, -3 },{ 1, -4, 1 } },
+		{ { -1, -2, 0 },{ -2, 2, -2 },{ -1, -4, -4 },{ -3, -1, -1 },{ 3, 2, 0 },{ 2, 1, -3 },{ -2, 3, 0 },{ 3, -1, -3 },{ -4, -1, -2 },{ -2, 3, 2 },{ -1, 2, -3 },{ -4, -3, 3 },{ -3, 1, 0 },{ 3, -1, -3 },{ 2, 2, 1 },{ 1, -2, 0 },{ 2, -3, -4 },{ 3, 1, 2 },{ -3, -4, -2 },{ 1, -3, 0 },{ 3, -3, -4 },{ -4, -2, 1 },{ -3, 1, -2 },{ 3, 3, 0 },{ 2, 0, -4 },{ -3, 2, -2 },{ -4, -2, 1 },{ -2, -1, -3 },{ 1, 2, 0 },{ 3, -2, 3 },{ 0, -1, -4 },{ 0, 3, 0 },{ 2, 0, 1 },{ -1, -4, -2 },{ 2, 3, 3 },{ -4, -3, -3 },{ -2, 1, 3 },{ 3, 2, -2 },{ -1, 3, 3 },{ 3, -4, -2 },{ -2, -3, 1 },{ -4, 3, -1 },{ -3, -4, 0 },{ -1, 1, -4 },{ -3, -1, -2 },{ 0, 0, -3 },{ 3, -2, -3 },{ -3, -4, 2 },{ 2, -1, -3 },{ 2, -1, -2 },{ -3, 2, 3 },{ -2, -3, -1 },{ 1, -2, 0 },{ -4, -1, -2 },{ 1, -3, 3 },{ -4, 3, -4 },{ -3, -1, 1 },{ -1, 2, 0 },{ 3, 1, 2 },{ -2, -2, 0 },{ -2, -4, -1 },{ 2, 0, 3 },{ -1, -1, 0 },{ 3, 2, 3 } },
+		{ { 2, -1, 2 },{ 2, 1, 3 },{ -4, -3, 1 },{ 0, 0, 2 },{ -4, -4, -3 },{ -3, -2, 3 },{ 0, -2, -4 },{ 1, 0, -1 },{ -3, -4, 0 },{ 2, 1, 0 },{ 2, -2, -3 },{ 0, 0, -2 },{ 3, 1, 3 },{ -2, -4, -4 },{ 0, 0, -2 },{ -4, 3, 2 },{ 0, 2, 1 },{ 1, -3, -1 },{ -4, -1, -2 },{ 0, 3, 1 },{ -2, 2, -3 },{ 2, 2, 2 },{ -2, -4, -4 },{ 0, -3, 0 },{ -4, -2, 1 },{ -1, 2, 2 },{ 1, -3, -2 },{ -2, 1, -4 },{ 2, -1, -1 },{ -4, 0, -3 },{ -2, -4, -1 },{ -3, 1, -3 },{ 3, 2, -4 },{ -3, -1, 2 },{ 0, 2, -4 },{ -1, -3, -3 },{ 1, -2, 1 },{ -4, -4, -4 },{ 1, 0, 2 },{ -3, -2, -4 },{ -4, 0, 0 },{ 0, -1, -3 },{ 3, -2, 2 },{ 0, 2, 1 },{ 2, -4, 2 },{ 1, 2, 3 },{ -2, 3, -1 },{ 0, -3, 2 },{ -2, 1, -4 },{ -4, 0, 0 },{ 1, -4, -2 },{ 0, 0, 1 },{ 3, 2, -4 },{ 0, -1, 1 },{ -3, -4, 0 },{ 3, -3, -1 },{ 2, 0, -2 },{ -4, -2, -2 },{ 1, -3, -3 },{ -3, -1, -4 },{ 1, 1, 2 },{ -4, 3, 1 },{ 1, -4, -3 },{ -4, 1, -4 } },
+		{ { 3, -4, -4 },{ -3, -2, -1 },{ 1, 3, -2 },{ -1, 2, -3 },{ 3, -1, 3 },{ -2, 3, -1 },{ -1, -4, 1 },{ -4, -1, 2 },{ 1, 2, 3 },{ -1, -3, -4 },{ -3, -2, 1 },{ 0, 3, -1 },{ -3, 0, 2 },{ 1, -3, 0 },{ -1, -2, 3 },{ -3, -1, -2 },{ -1, -4, -3 },{ 2, 0, 3 },{ -2, 3, -4 },{ 3, 0, 0 },{ -1, -2, -3 },{ -3, 0, -1 },{ 1, -1, -2 },{ 1, 3, 3 },{ -2, 0, -3 },{ 3, -4, -1 },{ 2, 3, 2 },{ 0, -2, 0 },{ -3, -4, 3 },{ 3, 3, 2 },{ 0, -3, 1 },{ 1, 0, 2 },{ -4, -4, 3 },{ 1, -3, -1 },{ -3, 0, 2 },{ -1, 2, 0 },{ 3, 1, -1 },{ -3, -3, 2 },{ 2, -1, -1 },{ 0, 3, 0 },{ 2, -3, 3 },{ 3, 2, 3 },{ -1, -2, -2 },{ -4, 0, -3 },{ -2, -2, -4 },{ 1, -4, 0 },{ -4, 1, 0 },{ -1, -1, -2 },{ 3, 2, 1 },{ 0, -2, 3 },{ -2, 3, -3 },{ -4, -3, 3 },{ -1, 0, -1 },{ 2, 3, -3 },{ -2, 1, 3 },{ 1, 1, -3 },{ -1, 3, 2 },{ 0, 2, 1 },{ 2, -4, 0 },{ -1, 3, 3 },{ 0, 0, -1 },{ 3, -3, 1 },{ -2, -2, -2 },{ -1, 0, -1 } },
+		{ { 0, 0, 3 },{ -2, 3, 1 },{ 3, -1, 0 },{ 0, 1, -2 },{ 1, -3, 1 },{ 0, 1, -4 },{ 2, 1, -1 },{ 3, 3, -2 },{ 0, 1, -4 },{ -2, 0, 2 },{ 3, -4, 1 },{ -4, 2, -2 },{ 2, -4, -4 },{ 2, 3, -3 },{ -4, -1, -1 },{ 3, 3, 1 },{ 0, -2, -3 },{ -3, 2, 1 },{ -2, -2, -1 },{ -4, 1, 3 },{ 0, -4, 2 },{ -1, -3, 1 },{ -3, -1, 3 },{ 2, 1, -4 },{ -4, -2, -1 },{ -1, 1, 3 },{ 0, 2, -4 },{ -4, -1, -1 },{ -1, 0, -2 },{ 1, 1, -3 },{ -1, 2, -2 },{ 2, -1, 0 },{ -1, -2, -3 },{ -2, 3, -2 },{ 2, -1, 0 },{ 3, -4, 3 },{ 0, 0, -2 },{ -4, 3, 1 },{ -1, 2, -3 },{ -2, -1, -3 },{ -1, 1, -2 },{ -3, 2, -4 },{ 1, -3, -1 },{ 2, 3, 1 },{ -3, 1, 3 },{ 3, -1, -2 },{ -1, 0, -4 },{ 1, 2, 2 },{ -3, -4, 0 },{ 2, -2, -3 },{ 2, 1, -1 },{ -1, -1, 2 },{ 3, 2, -4 },{ -4, -2, 0 },{ 1, -4, 2 },{ -3, -2, -1 },{ 3, -3, -4 },{ -2, -1, 3 },{ -3, 0, -1 },{ 3, -3, -2 },{ -3, 1, -3 },{ -2, -1, -4 },{ 1, 3, 2 },{ -3, 2, 0 } },
+		{ { 1, 1, -3 },{ -4, -3, 0 },{ 2, -4, -4 },{ -4, -2, 2 },{ -3, 0, 0 },{ -2, -4, -2 },{ -4, -1, 2 },{ -3, -2, 0 },{ 2, -3, -3 },{ -4, 3, -1 },{ 1, -1, 3 },{ -1, -1, -2 },{ 0, 1, 0 },{ -2, -3, 1 },{ -1, 2, 2 },{ 3, 1, -1 },{ -2, 0, -4 },{ 1, -4, 3 },{ 2, -3, 0 },{ 3, 2, -1 },{ 2, 1, -4 },{ -4, 3, -2 },{ 3, -3, 0 },{ 0, 1, 1 },{ -1, -4, -3 },{ -3, -3, 0 },{ 3, 0, -2 },{ -3, 3, 3 },{ 2, -3, 2 },{ -4, -4, 1 },{ -2, -2, -4 },{ -3, 3, 1 },{ 3, 0, -1 },{ -4, 1, -4 },{ 0, -2, 1 },{ -2, -2, -4 },{ -3, 1, -3 },{ 2, -4, 0 },{ 1, 0, 3 },{ 3, -2, 2 },{ 2, -4, 1 },{ -2, 0, 1 },{ -4, -4, 0 },{ -1, -1, 2 },{ 0, -3, -1 },{ 0, 3, 1 },{ 2, -2, -3 },{ -4, -3, 3 },{ 3, 3, -1 },{ -2, -4, -4 },{ -3, 2, 2 },{ 1, -3, -2 },{ -3, -4, 0 },{ -2, 0, 1 },{ 0, -1, -2 },{ 0, 2, -2 },{ -4, 0, 1 },{ -1, 1, 0 },{ 0, 2, -4 },{ 2, -2, 1 },{ -4, 3, 3 },{ 0, -4, 0 },{ 2, -1, 1 },{ -1, -3, -3 } },
+		{ { 3, 2, 3 },{ -1, -2, -2 },{ -3, 0, -1 },{ -2, 2, 3 },{ 2, 3, 1 },{ 3, -3, -4 },{ -1, 2, 3 },{ 0, 0, -2 },{ 1, -2, 2 },{ -2, 1, -3 },{ 3, -3, 0 },{ -3, 2, 2 },{ -4, -2, -3 },{ 1, 0, 3 },{ -3, -3, -4 },{ 1, -4, 3 },{ -4, -1, -3 },{ 2, 3, 1 },{ -1, -2, -2 },{ 0, -1, -3 },{ -2, 0, 0 },{ 1, 2, 1 },{ -2, -2, -3 },{ 3, 2, 2 },{ 0, 3, 2 },{ 2, -1, -2 },{ -2, -2, 1 },{ 1, 1, -4 },{ 2, -2, 0 },{ 0, -1, -3 },{ 3, 1, 2 },{ 0, -3, -1 },{ 2, 2, 3 },{ 0, -4, 2 },{ -4, 3, -2 },{ 1, 2, -1 },{ -1, -3, 3 },{ 0, 0, -4 },{ -3, -2, -1 },{ -4, 3, -2 },{ -3, -3, -4 },{ 0, 3, -1 },{ 1, -1, -3 },{ 3, 1, -2 },{ -3, 0, -4 },{ -2, -4, -1 },{ -4, 2, 2 },{ -1, -1, -2 },{ 0, 0, -3 },{ -1, 0, 1 },{ 0, -1, -1 },{ 3, 3, 1 },{ 1, -1, -3 },{ -2, 1, 3 },{ 2, 3, -4 },{ 3, -3, 3 },{ -3, -2, -3 },{ 1, -4, 1 },{ 2, -1, 2 },{ -1, -4, -3 },{ -4, 2, 0 },{ 3, 0, -2 },{ -2, 1, 2 },{ -3, -4, -1 } },
+		{ { 1, 1, 1 },{ 1, -1, -4 },{ 2, 3, 2 },{ 0, -2, -3 },{ -1, -1, -3 },{ 1, 1, -2 },{ 3, 2, 0 },{ -1, -1, 1 },{ -3, -4, -1 },{ -1, 2, -4 },{ 0, 0, 1 },{ 2, -4, -4 },{ 2, 3, -1 },{ 3, 2, -2 },{ -2, -2, 0 },{ 0, 2, -2 },{ -1, -1, 0 },{ -3, 1, 2 },{ -4, 2, -4 },{ -2, -4, 2 },{ -3, -3, 3 },{ 1, -1, -3 },{ -4, -4, -1 },{ -2, 0, -4 },{ -3, -3, -1 },{ -4, 0, 3 },{ -1, 2, 1 },{ 0, -4, -3 },{ -2, 2, -1 },{ -4, 2, 3 },{ 1, -1, 0 },{ -1, -4, -4 },{ -3, 0, -3 },{ -2, -3, 1 },{ 3, -1, 0 },{ 1, 1, 2 },{ -2, -1, 2 },{ 2, 3, -2 },{ 3, -4, 1 },{ 0, 1, 0 },{ 1, -2, 2 },{ -2, 2, 3 },{ 3, -2, -3 },{ 1, 3, 3 },{ -3, -2, 0 },{ 3, 2, 0 },{ 1, 1, 3 },{ -2, -4, 1 },{ 2, 3, 0 },{ -2, -2, 3 },{ -4, 1, -2 },{ 2, -4, 3 },{ 0, 1, -4 },{ -3, 2, -1 },{ -4, -3, 2 },{ -1, 0, 0 },{ 2, 3, -3 },{ -2, 3, -2 },{ -3, 1, -1 },{ -2, -2, 3 },{ -1, 0, -1 },{ 1, -3, -4 },{ 0, 3, -4 },{ -4, -2, 2 } },
+		{ { -3, 0, -1 },{ -2, -3, -2 },{ -4, 2, 1 },{ 3, -4, 0 },{ -4, -2, -1 },{ -2, -4, 2 },{ -3, 1, -3 },{ -4, -3, 3 },{ 2, 3, -4 },{ 1, 0, 2 },{ -4, -3, 3 },{ -2, -1, -1 },{ -1, 1, 2 },{ -4, -2, 1 },{ 2, 0, -3 },{ -1, 1, 2 },{ 3, -3, -1 },{ 1, -3, -2 },{ 2, 0, -1 },{ 0, 1, 1 },{ 3, 3, 1 },{ -1, 1, -2 },{ -1, -1, 3 },{ 2, 2, 2 },{ 1, -2, 0 },{ 3, 3, -4 },{ -1, -3, -1 },{ 3, -4, 2 },{ -3, 0, -2 },{ 2, 3, 1 },{ -2, -2, -2 },{ -4, 0, -1 },{ 3, 3, 3 },{ -1, -1, -2 },{ 2, 1, -3 },{ -4, -4, -1 },{ -3, -2, -4 },{ -4, 2, 0 },{ -2, 2, 3 },{ -1, 0, -3 },{ 2, -1, -4 },{ -2, 1, 0 },{ -4, -4, 2 },{ -1, 1, 1 },{ 0, -3, -4 },{ -4, -3, -3 },{ 0, 0, -3 },{ 2, -1, -2 },{ -3, -3, -4 },{ 1, -2, 2 },{ -4, 2, -3 },{ -1, -3, 0 },{ -2, -2, -2 },{ 3, -4, 0 },{ 2, -1, 2 },{ 1, -2, -1 },{ 0, 1, 1 },{ -4, -1, 2 },{ 3, -3, -4 },{ 0, 2, -3 },{ 3, 3, 1 },{ 2, -1, 3 },{ -2, -3, 0 },{ 3, 3, -2 } },
+		{ { -1, -4, 3 },{ 2, -3, -4 },{ -1, 1, 0 },{ 1, -1, 3 },{ -3, 0, 2 },{ 2, 3, 1 },{ 0, -2, -1 },{ -1, -1, -2 },{ 2, 1, 1 },{ 3, -4, -2 },{ -3, -2, 0 },{ 1, 3, -2 },{ 0, -1, 0 },{ -2, -4, 3 },{ 1, -4, -4 },{ -4, 3, 1 },{ -2, -2, -4 },{ 2, 3, 3 },{ -4, -4, 3 },{ -3, -1, -4 },{ 3, -2, -2 },{ -4, -3, 0 },{ 2, 1, -3 },{ 0, -4, 0 },{ -3, -1, -2 },{ 2, 1, -3 },{ -4, -1, 3 },{ 1, 1, 0 },{ -3, -1, -3 },{ -1, -2, -4 },{ 3, -3, 0 },{ 1, 1, 2 },{ 0, -2, 0 },{ -3, 3, -4 },{ -1, -3, 3 },{ 0, 2, 1 },{ 3, 0, -3 },{ 1, -3, -1 },{ 0, -1, -3 },{ -1, -4, 1 },{ -3, -3, -1 },{ 3, 3, -1 },{ -1, -3, -2 },{ -4, 0, -1 },{ 2, -1, 3 },{ -1, 1, 2 },{ -2, 3, -1 },{ 3, 2, 1 },{ -3, 0, -1 },{ 1, 2, 0 },{ 3, -1, -1 },{ 2, 3, 2 },{ -3, 0, 1 },{ 1, 2, -3 },{ -1, -1, -4 },{ -3, 2, 3 },{ -4, -4, -2 },{ 2, 0, 0 },{ 1, -1, 1 },{ -1, -4, 2 },{ -3, 1, -2 },{ -3, -4, 0 },{ -4, -1, -1 },{ 0, 1, -3 } },
+		{ { 2, 2, 2 },{ -4, -1, 2 },{ 0, 1, -2 },{ -2, -3, -3 },{ 0, 2, -4 },{ 3, 0, -4 },{ -3, -3, 3 },{ 0, 3, -1 },{ -2, -1, 0 },{ -2, 2, -3 },{ -1, 1, 3 },{ 3, -3, -3 },{ -3, 0, -4 },{ -3, 2, 2 },{ 3, 1, -2 },{ -3, -1, -1 },{ 0, -3, 1 },{ -2, 2, -3 },{ 1, 0, -1 },{ -1, -1, 0 },{ 2, 3, 2 },{ -2, 2, -1 },{ 0, -2, 1 },{ -3, 3, -4 },{ -2, 0, 2 },{ 0, -4, 1 },{ -2, 2, -4 },{ 1, 3, 3 },{ 2, -3, -1 },{ -2, 1, 2 },{ 0, 3, 3 },{ -3, -4, -3 },{ -2, -1, -1 },{ 2, -2, 2 },{ -1, 0, -1 },{ 1, 1, 0 },{ -3, -3, 3 },{ 2, 3, 2 },{ 3, 0, -2 },{ -4, 1, 3 },{ 2, -2, 2 },{ 0, 2, 1 },{ 1, 2, -4 },{ -2, -1, -3 },{ 3, 2, -2 },{ 2, -4, 0 },{ -2, -2, 1 },{ -4, -3, 3 },{ 0, 1, -4 },{ 0, -4, -3 },{ -1, -1, -2 },{ -2, 1, 3 },{ 0, -3, -4 },{ -4, 0, 1 },{ 0, -3, -2 },{ -2, 3, 0 },{ 2, -3, -4 },{ 0, 1, 3 },{ -2, 3, -2 },{ -4, -2, -1 },{ 1, 0, -4 },{ 2, 0, 2 },{ 0, 2, 1 },{ 1, -2, 1 } },
+		{ { -3, 0, -2 },{ -2, 3, -3 },{ 3, 2, -1 },{ 1, -2, 1 },{ -4, 3, 0 },{ 1, -4, -2 },{ -1, 0, 1 },{ 3, 2, -3 },{ 1, -4, 2 },{ -4, -2, -1 },{ 2, 0, 1 },{ 0, 3, 1 },{ 0, -3, 2 },{ 2, -2, -2 },{ -1, -1, 0 },{ 1, 3, -3 },{ 3, 0, 0 },{ -1, -1, 2 },{ -3, -4, -2 },{ 0, 2, -3 },{ -3, -2, -4 },{ -1, -4, 1 },{ -4, 1, 3 },{ 1, -3, -2 },{ 3, 2, 0 },{ 3, -3, -1 },{ -1, -2, 0 },{ 0, 0, -2 },{ -4, -3, 1 },{ 3, 2, 1 },{ -1, 0, -3 },{ 1, 1, -4 },{ 2, -4, -2 },{ -4, 2, 2 },{ 3, -2, -3 },{ -2, 2, -2 },{ -2, -1, -4 },{ -1, -4, 1 },{ -3, -2, -4 },{ 1, 3, 0 },{ -3, -1, -2 },{ -2, -3, -3 },{ 2, -4, 3 },{ -3, 0, 0 },{ 0, 3, 2 },{ -3, 1, -2 },{ 1, -1, -4 },{ -1, -2, -2 },{ 3, 0, 2 },{ -2, -4, 1 },{ 1, 3, 2 },{ -4, -2, -4 },{ 2, 2, -1 },{ -1, -4, 0 },{ 3, 1, 2 },{ -3, 0, -3 },{ 3, -2, -1 },{ -1, -4, 1 },{ 1, 2, -3 },{ 3, -3, -2 },{ -1, 3, 3 },{ -1, -3, -1 },{ -2, 1, -4 },{ 3, -3, -3 } },
+		{ { -4, 0, 0 },{ 1, -4, -1 },{ -3, -1, 3 },{ -1, -3, 2 },{ 3, -1, -2 },{ -2, 1, 3 },{ -2, -2, 2 },{ -4, -3, -4 },{ 0, 1, 3 },{ -3, -1, -2 },{ 1, 3, -4 },{ -4, -4, 0 },{ -2, -2, -1 },{ 1, 0, -3 },{ -4, 1, 2 },{ -2, -3, 3 },{ 0, -4, -4 },{ -4, 3, 3 },{ 3, 1, 1 },{ 3, -3, 2 },{ 1, 0, 0 },{ 2, -1, 3 },{ 3, 3, -3 },{ -1, 0, -3 },{ -3, -2, 3 },{ -4, 3, 2 },{ -2, -1, -3 },{ 2, 2, -2 },{ -3, -4, -4 },{ 1, -2, 0 },{ -4, -2, -1 },{ 0, 3, 3 },{ -2, 0, 1 },{ 0, -3, 0 },{ -4, 3, -3 },{ 1, -4, 1 },{ 2, -1, -1 },{ -4, 1, 2 },{ -1, 2, -3 },{ 2, -4, 0 },{ -2, -1, -1 },{ 3, 2, 2 },{ -1, 1, 1 },{ -4, -2, -1 },{ 1, -3, -4 },{ -2, -4, 3 },{ 2, 1, 0 },{ 1, 3, -3 },{ -4, 2, -1 },{ -3, 0, 0 },{ 0, -2, -2 },{ 3, 1, 0 },{ -2, -3, -3 },{ 2, 3, -1 },{ -4, -2, 3 },{ 1, 2, -2 },{ -3, -1, 0 },{ 0, 0, 2 },{ -3, 1, -4 },{ -2, -1, 0 },{ -4, -1, 2 },{ 3, -4, -3 },{ 0, 3, 3 },{ -2, -1, 0 } },
+		{ { 3, -4, 3 },{ -1, -2, -4 },{ 2, 2, 0 },{ -4, 2, -3 },{ 0, -4, -3 },{ -3, 0, 0 },{ 2, 1, -1 },{ 2, 3, -4 },{ -1, 0, 0 },{ 3, -3, -3 },{ 1, 1, 2 },{ -1, -1, -2 },{ 3, 2, 3 },{ 2, 3, 1 },{ -3, -2, -4 },{ 3, 1, -1 },{ -3, -1, -2 },{ 2, -2, 0 },{ -1, 1, -1 },{ -2, -3, -4 },{ -4, 2, -2 },{ 0, 0, -2 },{ -2, -4, -1 },{ 2, -3, -1 },{ 0, -1, 1 },{ 1, 1, -4 },{ -3, -4, 2 },{ 0, 1, 3 },{ 3, -1, 0 },{ -2, 0, -3 },{ 2, 3, 2 },{ -3, -4, 0 },{ 3, -1, -2 },{ 1, -1, -4 },{ -1, 1, 3 },{ -3, -2, 2 },{ 0, 0, 0 },{ 3, 0, 3 },{ 0, 3, -2 },{ 1, -3, 2 },{ -1, 1, -4 },{ 2, 0, -2 },{ -4, -3, -3 },{ 0, -1, 3 },{ 3, 3, -1 },{ -1, 0, -1 },{ -3, -3, 1 },{ -1, -4, 2 },{ 3, -1, 3 },{ 2, 2, -4 },{ -3, -3, 2 },{ 1, -1, 3 },{ -3, 0, 2 },{ -1, -1, 1 },{ 0, -4, -4 },{ 1, 1, 1 },{ -1, 3, 3 },{ -4, -4, -1 },{ 2, -3, 0 },{ 2, 3, 3 },{ 1, 1, -3 },{ -4, -2, 1 },{ -3, 2, -1 },{ 1, -2, 2 } },
+		{ { -1, 3, -3 },{ 0, 1, 1 },{ -3, 0, -4 },{ -2, -2, 3 },{ 3, 3, 1 },{ 1, -3, 2 },{ -3, 2, -2 },{ 1, -4, 0 },{ -3, -1, 2 },{ -2, -4, -1 },{ -2, 2, 1 },{ -4, -2, -4 },{ -3, -3, 0 },{ -1, -4, -3 },{ 0, 2, -1 },{ 0, -4, 1 },{ 1, 2, 2 },{ -2, 3, -3 },{ -4, -1, -3 },{ 1, -4, 1 },{ 2, 3, 3 },{ -2, -2, 0 },{ -4, 2, 2 },{ -1, 1, -4 },{ 1, 0, 1 },{ -4, 2, -3 },{ 3, -3, 0 },{ 1, 3, -1 },{ -3, 2, 3 },{ -1, -3, -2 },{ 1, 1, -4 },{ 0, -3, 2 },{ -3, 2, 1 },{ -2, 2, -1 },{ 3, -3, 1 },{ 2, 3, -2 },{ 1, 1, -3 },{ -4, -4, -4 },{ -2, -2, 1 },{ -2, -3, -1 },{ -3, 0, 3 },{ 0, -2, 1 },{ 3, 3, 0 },{ 1, 2, -3 },{ -2, -1, -2 },{ 2, -2, 1 },{ -4, 3, -4 },{ 0, 1, -2 },{ -2, -3, -3 },{ -2, -2, -1 },{ -1, 1, -1 },{ 1, -4, -4 },{ 2, 3, -3 },{ -2, 1, -2 },{ -4, -2, 0 },{ 2, -3, -4 },{ -2, -2, -3 },{ 3, 2, -3 },{ 0, -1, 1 },{ -2, -4, -4 },{ 0, 0, -2 },{ 2, -3, 0 },{ -1, 1, -4 },{ 2, 3, -2 } },
+		{ { 0, 0, -2 },{ -4, -3, 2 },{ 2, -1, 1 },{ 1, -4, -2 },{ 2, 0, -1 },{ -1, -1, -4 },{ -1, -2, 1 },{ -4, 2, 3 },{ 3, -2, -1 },{ 0, 3, -3 },{ 2, 0, 3 },{ 2, 1, -2 },{ 1, 0, 1 },{ 3, -1, 3 },{ -2, -1, -2 },{ -4, 1, 2 },{ -1, -2, 0 },{ 2, 0, -2 },{ -1, -3, 3 },{ 0, 3, 1 },{ -3, -2, -2 },{ 3, 1, -4 },{ 1, -3, 1 },{ -2, -2, 3 },{ 3, 3, -2 },{ -3, -2, 2 },{ -2, -4, -2 },{ -1, -1, -4 },{ 2, 0, 1 },{ -4, -4, 2 },{ -1, 2, -3 },{ 3, -2, -1 },{ -1, -4, 3 },{ 2, 0, -3 },{ -4, -2, 0 },{ -1, -4, -1 },{ -3, 2, 0 },{ -3, -1, -3 },{ 2, 1, 2 },{ 3, 3, -2 },{ -4, -4, -3 },{ -1, 2, 2 },{ -4, -4, -4 },{ 1, -3, 1 },{ -2, 1, 2 },{ 3, 2, 3 },{ -4, 0, -3 },{ 1, -4, 0 },{ 3, 0, 3 },{ 2, 2, -3 },{ -4, 3, 1 },{ 0, -1, 1 },{ -3, 2, -1 },{ 3, -3, 2 },{ 1, 2, 2 },{ 3, 1, 0 },{ -3, 0, -2 },{ -1, 1, 2 },{ 1, 3, 2 },{ -4, 2, -1 },{ -2, -2, 3 },{ 3, 1, 2 },{ -2, -1, -1 },{ -4, -3, 3 } },
+		{ { -2, 2, 0 },{ 3, -3, -2 },{ -2, 2, -1 },{ -1, 3, 0 },{ -4, 1, -4 },{ -3, -2, 2 },{ 0, -3, -3 },{ 3, 0, -2 },{ -3, -1, -4 },{ 1, 1, 1 },{ -4, -3, 0 },{ 0, -4, -4 },{ -1, 2, 2 },{ -4, 3, -1 },{ 1, -2, 0 },{ 3, 0, -4 },{ 2, -3, 2 },{ -3, -4, -3 },{ 0, 2, 0 },{ 3, 0, -1 },{ -3, 0, 2 },{ -1, -4, -3 },{ 0, -1, -2 },{ -3, 1, 0 },{ 0, -4, -3 },{ 2, -1, 3 },{ 1, 2, 0 },{ -2, 1, -4 },{ 0, -2, -1 },{ 3, 3, -3 },{ -3, 0, 1 },{ -2, -1, 0 },{ -4, 3, -4 },{ 2, 0, -2 },{ -1, -2, 2 },{ 0, 2, -4 },{ 3, -3, 3 },{ -1, 0, 2 },{ 0, -2, 0 },{ 1, 2, -4 },{ 1, -1, 0 },{ 2, 1, 3 },{ -3, -2, -2 },{ -1, 1, -1 },{ -3, -4, 0 },{ 0, -3, -4 },{ 0, -2, -1 },{ -1, 2, 2 },{ -3, -1, 1 },{ -3, -4, 2 },{ 0, 0, -2 },{ 3, -3, 0 },{ -4, -1, -4 },{ -1, -2, 3 },{ -2, 0, -3 },{ 0, -1, 0 },{ 1, -4, 3 },{ -4, -3, -1 },{ -1, -3, -2 },{ 3, 0, -3 },{ -3, 0, 0 },{ 0, 3, -3 },{ 1, -4, -4 },{ 2, -2, 1 } },
+		{ { -3, 1, 3 },{ 1, -1, -4 },{ 0, -2, -3 },{ -4, -4, 3 },{ 0, 0, -1 },{ 2, 1, 3 },{ -2, 2, 1 },{ 1, 3, 0 },{ -1, -4, 3 },{ -1, -3, -1 },{ -3, -1, -3 },{ -2, 3, 1 },{ 1, -3, -2 },{ -3, -2, -4 },{ 2, -4, -3 },{ -2, 1, 3 },{ -3, 3, -1 },{ -2, -1, -4 },{ 3, 1, 2 },{ -2, -1, -4 },{ 1, -3, -1 },{ -4, 2, 0 },{ 3, 3, 2 },{ 2, -1, -1 },{ -1, 2, -4 },{ -1, 0, -1 },{ -4, -3, 2 },{ 3, 0, 2 },{ -4, 2, 0 },{ 1, -3, 3 },{ 2, -2, 1 },{ 0, 1, -2 },{ 1, -3, 2 },{ 1, 3, 1 },{ -3, -1, 3 },{ -2, -1, -2 },{ 1, 1, 1 },{ 3, 3, -1 },{ -4, -4, -2 },{ -2, -3, 3 },{ -1, 0, 1 },{ 0, -1, -1 },{ 2, 0, -1 },{ 1, 3, -3 },{ 2, 0, 3 },{ -3, 2, 0 },{ 3, -2, -2 },{ 2, 1, -4 },{ -2, 3, -1 },{ 1, -2, -3 },{ 2, 1, 2 },{ -2, -4, 3 },{ -1, 1, -2 },{ 2, 3, 1 },{ -3, -4, -2 },{ -4, 3, -1 },{ -2, 0, -4 },{ 2, 3, 1 },{ 3, -2, 0 },{ 1, -1, -4 },{ -3, -4, 3 },{ 2, -3, 1 },{ -4, 2, -1 },{ -1, 0, -3 } },
+		{ { -1, -4, 1 },{ 2, 3, 0 },{ -2, -3, 2 },{ 3, -1, 1 },{ -3, 2, -3 },{ 3, -4, -2 },{ 2, -3, -1 },{ -4, -2, 0 },{ -2, 1, -4 },{ 3, 2, 3 },{ 2, 0, 2 },{ 3, -1, -2 },{ -2, 1, 2 },{ -1, 0, 3 },{ 0, 1, 0 },{ 0, 3, -2 },{ 1, -3, -1 },{ 2, 2, 1 },{ -4, -2, 3 },{ 1, 3, -2 },{ 2, -4, 1 },{ -1, 1, 3 },{ -3, -2, -4 },{ 1, -3, 1 },{ -4, 1, 1 },{ 1, -4, -3 },{ -3, 3, -3 },{ 2, -1, -2 },{ 0, -4, -1 },{ -2, -1, -4 },{ -1, 3, -2 },{ 3, -3, 0 },{ -4, -4, -3 },{ -2, 1, -1 },{ 3, -4, -1 },{ -3, 2, -4 },{ 1, -4, 0 },{ -4, -1, -4 },{ -2, 0, -3 },{ 0, 3, 0 },{ -3, -3, -4 },{ 3, 2, -2 },{ -4, -4, 2 },{ -2, -1, -4 },{ 3, -2, 1 },{ -1, 3, 2 },{ -4, -4, -2 },{ 1, 0, 3 },{ -4, -3, 0 },{ -1, -2, -4 },{ 3, 2, -2 },{ -4, 3, -1 },{ 1, -3, -4 },{ 3, 1, -3 },{ 1, -2, 2 },{ -1, -3, 3 },{ 3, 2, -3 },{ 0, -1, -3 },{ -4, 1, 2 },{ 0, 1, 2 },{ -2, 3, -2 },{ 1, -1, -1 },{ 0, 1, 2 },{ 3, -2, -2 } },
+		{ { 1, -1, 3 },{ -4, 1, -1 },{ 3, 2, -4 },{ -1, 1, 2 },{ 1, 3, -2 },{ -2, -1, -4 },{ -3, 3, 2 },{ -1, 0, -3 },{ 0, -1, -3 },{ 2, -4, 1 },{ -4, 3, 0 },{ 0, -2, -4 },{ 1, -4, -1 },{ 3, 2, 1 },{ -4, -3, -3 },{ -2, -1, 2 },{ 3, -4, 1 },{ -4, -2, -3 },{ -1, 1, 0 },{ -2, -4, 2 },{ 0, 0, -3 },{ -2, -1, -2 },{ -4, 0, -2 },{ 2, 3, 0 },{ -2, -2, 3 },{ 3, 2, -1 },{ -1, -3, 1 },{ 0, -2, 3 },{ -3, 1, 0 },{ -3, 0, -3 },{ 1, 2, 2 },{ -1, -1, 3 },{ -3, 2, -3 },{ 2, 0, 1 },{ -1, -2, 2 },{ 2, 3, -3 },{ -3, -2, 3 },{ -1, -3, 2 },{ 2, -1, 3 },{ 2, 1, 1 },{ 1, -4, -3 },{ -3, 2, 2 },{ -2, 3, 1 },{ 0, -3, 3 },{ -4, 1, -3 },{ 0, -1, -3 },{ -1, -1, 1 },{ -2, 2, 2 },{ 3, 1, 0 },{ 1, -3, 1 },{ -3, -1, 3 },{ 0, 0, 1 },{ -2, -2, 0 },{ 0, -1, 3 },{ -3, 2, 0 },{ 1, 0, -2 },{ -1, -4, 1 },{ -2, -3, 3 },{ -3, 2, -2 },{ -1, -4, 0 },{ 2, 0, 0 },{ -4, 2, -4 },{ -1, -3, -3 },{ -3, 3, 2 } },
+		{ { 0, -4, -3 },{ -2, -3, -2 },{ -3, 0, 0 },{ -4, -2, -1 },{ 1, -3, 0 },{ 0, -2, 3 },{ -4, 0, 1 },{ 3, -4, 2 },{ 1, -2, -1 },{ -3, 1, -2 },{ -2, 2, 3 },{ 1, 1, -3 },{ -4, -3, 1 },{ -3, 3, -1 },{ 2, -2, -4 },{ 1, 0, 0 },{ 0, 0, 2 },{ -1, 1, -2 },{ 3, -1, -4 },{ -3, 2, -1 },{ 2, 3, 3 },{ 3, 1, 0 },{ 1, -4, -3 },{ -1, -3, 2 },{ 0, -1, -2 },{ -2, 1, -4 },{ 2, 0, 2 },{ -2, 3, -2 },{ 2, -3, -4 },{ 3, 2, 1 },{ -4, -4, -1 },{ 0, -2, -4 },{ 3, 0, 0 },{ -4, 3, 2 },{ 0, -2, -2 },{ 0, 0, 1 },{ 3, 1, -1 },{ 0, 2, 0 },{ -1, 3, -2 },{ -4, -2, -1 },{ 3, -1, -2 },{ 1, -2, 0 },{ -1, 0, -2 },{ 3, -4, -1 },{ -2, 3, 0 },{ 2, 2, -1 },{ 2, -3, -2 },{ -3, -4, -4 },{ -3, 0, -3 },{ 0, 3, -2 },{ -1, -1, -1 },{ 3, 2, -3 },{ -4, -4, 2 },{ -2, 1, -1 },{ 2, -3, -4 },{ 3, 3, 2 },{ -4, 0, 0 },{ 2, -2, -1 },{ 1, 3, -4 },{ 3, -2, -3 },{ -2, -1, 3 },{ 1, -3, 1 },{ 3, -2, 0 },{ -2, 0, -4 } },
+		{ { 2, 1, -1 },{ 2, -1, 2 },{ -1, 3, 3 },{ 0, -4, -3 },{ 2, 0, 1 },{ -2, 1, -2 },{ -1, 2, -4 },{ 2, 3, 0 },{ -3, -3, 2 },{ 1, 0, -2 },{ -1, -2, -1 },{ -3, -4, -4 },{ -1, -1, 2 },{ 2, 1, -2 },{ -2, 2, 3 },{ -3, -4, -4 },{ -1, 3, -1 },{ -3, 2, 3 },{ 1, -3, -2 },{ 1, -3, 1 },{ 0, -2, -4 },{ -4, -3, 1 },{ -3, 2, -1 },{ 3, 2, 3 },{ -3, -1, 1 },{ 3, -4, -1 },{ -4, 2, 0 },{ -4, -4, 0 },{ 0, -1, 3 },{ 1, -2, 2 },{ -1, 0, -2 },{ -3, 2, 1 },{ 1, -4, 3 },{ -2, -3, -4 },{ 1, -1, -1 },{ -4, -4, -4 },{ -2, 1, -3 },{ 3, -4, 0 },{ -3, 0, -4 },{ 0, 2, 1 },{ -3, -3, 3 },{ -2, 3, 2 },{ 1, 0, -4 },{ 2, 1, 2 },{ -3, -2, -4 },{ -1, -3, 3 },{ 1, 1, 2 },{ 0, 3, 2 },{ 2, -2, 0 },{ -1, -3, 3 },{ -4, -4, -2 },{ 1, 2, -4 },{ 2, -2, 1 },{ -1, 0, -3 },{ -4, 2, -1 },{ 0, -2, -3 },{ -3, 1, 1 },{ -1, -1, -2 },{ 2, 0, 2 },{ -4, -4, 1 },{ -1, 1, -3 },{ -3, 3, 2 },{ 2, 0, -1 },{ -4, 2, 1 } },
+		{ { -3, -2, 1 },{ 3, 2, -4 },{ 1, -3, 0 },{ -4, 1, -3 },{ 3, 3, 2 },{ -3, -4, -1 },{ 2, -1, -3 },{ -4, -1, 3 },{ -2, 1, -4 },{ 3, 3, 1 },{ 0, -3, 3 },{ 2, 2, 0 },{ 3, 0, 0 },{ 0, -3, -3 },{ -2, -2, 2 },{ 2, -3, 0 },{ -4, 1, -3 },{ 3, -2, 1 },{ -2, 0, 0 },{ -4, -1, 2 },{ -2, 3, 2 },{ -1, -4, -3 },{ 1, 0, -1 },{ -2, -2, -4 },{ 0, 3, -3 },{ 1, -3, 3 },{ -1, 0, -4 },{ 1, -1, -3 },{ -1, 1, -1 },{ 2, -3, 0 },{ -2, 3, -2 },{ 0, -1, -3 },{ 3, 1, 0 },{ -3, 1, -2 },{ 2, 2, 2 },{ -2, 3, 3 },{ -3, -3, 1 },{ 1, -1, 2 },{ 1, -4, 2 },{ -2, 0, -4 },{ 0, 1, -3 },{ -4, -3, -1 },{ 3, -1, 1 },{ -4, -4, -3 },{ 0, 0, 1 },{ -4, -2, -2 },{ 3, 0, -1 },{ -2, -1, -3 },{ -4, 2, 1 },{ 1, 1, -4 },{ 2, 0, 0 },{ -2, -3, 2 },{ -1, 3, 3 },{ 3, -1, -2 },{ 1, -4, 1 },{ -3, -3, 3 },{ 2, 3, -4 },{ 1, -4, 0 },{ -4, 2, 3 },{ 0, 2, -2 },{ 0, -2, -1 },{ 3, -3, -4 },{ 0, 3, 3 },{ -1, -4, -2 } },
+		{ { -2, 2, -2 },{ 0, -1, 3 },{ -2, 0, -1 },{ -3, -2, -2 },{ -1, 2, -4 },{ 0, -3, 3 },{ 0, 2, 1 },{ 1, -4, 0 },{ -1, -2, -1 },{ 2, 0, -3 },{ -4, -4, 2 },{ -2, 3, -4 },{ 1, -1, -2 },{ -4, 3, 2 },{ 1, -1, -3 },{ 3, 1, -1 },{ 0, -2, 2 },{ 2, -4, -4 },{ 0, 2, -1 },{ 0, 1, -3 },{ 2, 0, -2 },{ 3, -1, 1 },{ 0, 3, 3 },{ -4, 0, 0 },{ -3, -3, 2 },{ 2, 1, -2 },{ -2, 3, 1 },{ 3, -2, 1 },{ -3, 3, -3 },{ -4, 1, 2 },{ -2, -4, -4 },{ 2, -2, 1 },{ 1, 3, 2 },{ -1, -2, -1 },{ -1, -3, 0 },{ 2, -2, -2 },{ 0, 0, -3 },{ -4, 3, 0 },{ -1, -2, -1 },{ 3, 2, -2 },{ 2, -2, 3 },{ -3, 3, -2 },{ -1, 1, 0 },{ 1, 2, -3 },{ 3, 2, 0 },{ -2, 1, 1 },{ -1, 3, -4 },{ -3, -4, -3 },{ 3, -3, -1 },{ 1, 0, 2 },{ -3, 3, 1 },{ -3, -4, -3 },{ 0, 1, 0 },{ -3, 0, 0 },{ -2, 3, -4 },{ 0, -1, 3 },{ -2, 1, -2 },{ -1, -3, -1 },{ -2, 0, 0 },{ 3, -2, -4 },{ -3, 1, 2 },{ -4, 0, -2 },{ -2, -1, 0 },{ 1, -4, -3 } },
+		{ { -4, -2, 1 },{ 2, 3, -4 },{ 0, -3, 1 },{ 3, -1, 2 },{ 2, 1, 1 },{ -2, -1, -1 },{ 3, 0, -2 },{ -3, -3, 2 },{ -4, 2, -3 },{ 0, -1, -2 },{ -3, 0, 3 },{ 3, 1, 1 },{ -3, -2, -1 },{ -1, -4, 3 },{ -1, 2, 1 },{ -2, 0, -2 },{ -3, -1, -2 },{ -1, 3, 1 },{ -3, -2, 3 },{ 3, -3, 0 },{ -4, -4, -1 },{ -1, 2, -4 },{ -2, -2, 2 },{ 2, -4, -2 },{ 1, 1, -3 },{ -4, -1, 3 },{ 0, -4, -1 },{ -3, 0, 2 },{ 0, 2, -2 },{ 3, -4, 3 },{ -1, 2, 0 },{ -4, 0, 3 },{ 0, 0, -4 },{ -4, -4, -3 },{ -3, 2, 1 },{ 1, -1, -1 },{ 3, 1, -4 },{ 2, -3, 3 },{ -1, 1, -2 },{ -4, -4, 0 },{ 3, 0, 1 },{ 1, -4, 3 },{ -2, -3, -1 },{ 0, -1, 3 },{ -3, -3, 2 },{ 2, -4, 2 },{ 1, -3, 0 },{ -4, 2, 3 },{ 0, -2, 3 },{ -1, -1, -2 },{ 0, 2, -1 },{ 3, -1, -4 },{ 2, -2, 2 },{ -4, -3, -3 },{ -1, 2, -1 },{ 3, -4, 2 },{ 3, -2, 0 },{ -3, 1, -3 },{ 2, 3, 2 },{ 1, -4, 3 },{ -1, -1, -3 },{ 1, 2, 0 },{ -2, 1, 2 },{ 3, -1, 2 } },
+		{ { -1, 0, -1 },{ -3, 1, 0 },{ -1, -4, -2 },{ -4, 2, -3 },{ 1, -4, 0 },{ -4, -3, -4 },{ -1, 3, 1 },{ -2, 2, -2 },{ 3, 1, 3 },{ -1, -3, 0 },{ 0, 3, -4 },{ 1, -3, 1 },{ -2, -2, -3 },{ 2, 1, -4 },{ -3, 3, 0 },{ 2, -3, 3 },{ 1, -4, -4 },{ -4, 2, 2 },{ 1, 1, -3 },{ -2, -1, -4 },{ -3, 3, 3 },{ 1, -3, -2 },{ -3, 1, -1 },{ 3, -2, 0 },{ -1, 0, 1 },{ -1, 3, -2 },{ 3, -2, -1 },{ 2, -3, -4 },{ -1, -1, 0 },{ 1, -1, -2 },{ 2, -2, -1 },{ -3, 1, 1 },{ 3, -3, -1 },{ 0, -1, 3 },{ 3, 2, -4 },{ -4, -4, 1 },{ -2, 0, 3 },{ -3, -1, -3 },{ 0, 2, 2 },{ -3, -2, 0 },{ 1, 2, -4 },{ -1, -1, -4 },{ -3, 0, -1 },{ 2, 3, -3 },{ -4, -2, -4 },{ -2, 1, -2 },{ 0, -1, -2 },{ 2, 3, 1 },{ 3, -1, -3 },{ -4, 1, -2 },{ -2, -4, 2 },{ -4, 3, -1 },{ 1, 1, 3 },{ -2, 0, -2 },{ 2, -2, 0 },{ -4, 2, -3 },{ 1, 1, 2 },{ -4, -1, -4 },{ 0, -3, -1 },{ -3, 0, -3 },{ 3, -3, 1 },{ -4, -4, -1 },{ 2, -3, -4 },{ 1, 3, -3 } },
+		{ { 3, -4, 3 },{ 1, -2, 2 },{ 2, 2, 3 },{ -2, -2, -3 },{ 0, 3, 2 },{ 3, 1, 3 },{ -2, 0, -1 },{ 2, -2, -4 },{ 1, -4, 0 },{ 2, -1, 2 },{ -3, 2, -1 },{ 3, 0, -2 },{ 1, -4, -1 },{ -4, 2, 2 },{ 3, -1, -3 },{ 0, -3, -1 },{ -4, 0, 1 },{ -1, 2, 0 },{ 2, -1, -1 },{ 0, -4, 2 },{ 3, 0, 1 },{ 2, 1, -3 },{ -2, 2, 1 },{ 1, -3, -4 },{ -3, 2, 3 },{ -2, 2, -4 },{ -4, -3, 0 },{ 0, 2, 3 },{ -2, 3, -3 },{ -4, 1, 1 },{ 0, -4, -4 },{ -3, 3, -3 },{ -2, 0, -2 },{ 2, 3, 2 },{ -2, 0, 0 },{ 1, -2, -2 },{ -1, 3, -2 },{ -3, -4, -1 },{ 2, 3, -4 },{ 1, -1, 1 },{ -2, 1, -1 },{ -4, 3, -2 },{ -1, -2, 2 },{ 1, -4, 0 },{ 3, 2, 1 },{ -1, 3, -3 },{ -3, 0, -1 },{ -2, 1, 1 },{ 1, -4, -4 },{ 2, 2, 0 },{ -1, -3, 1 },{ 1, -2, -3 },{ 0, -4, 1 },{ 3, 3, 3 },{ -3, -3, -2 },{ 0, 0, 1 },{ -1, 3, 3 },{ 2, -2, -1 },{ -1, 0, 1 },{ -2, 2, 3 },{ 0, 3, -2 },{ -1, 1, 3 },{ -3, -2, 1 },{ 0, 2, -1 } },
+		{ { -3, 0, -2 },{ -2, -3, -4 },{ 1, 3, 0 },{ -3, 0, -1 },{ -1, -1, -4 },{ 1, -2, 1 },{ -3, -4, -1 },{ -4, 3, -3 },{ 0, 0, 2 },{ -2, -2, -3 },{ -4, 2, -2 },{ -2, -1, 3 },{ -1, -2, 2 },{ 0, 0, 0 },{ -2, 3, 1 },{ -2, -2, -4 },{ 2, -2, -2 },{ 3, 3, -3 },{ -2, -3, -1 },{ -4, -2, -4 },{ 0, 3, 3 },{ -1, -1, -2 },{ -4, -4, 2 },{ 0, -1, 0 },{ 2, -4, -3 },{ 3, -2, 1 },{ 1, 1, 2 },{ -3, -4, -2 },{ 3, 0, 0 },{ 2, -3, 2 },{ 1, -1, 3 },{ -1, 2, 0 },{ 1, -3, -1 },{ 2, -4, 2 },{ -3, -1, -3 },{ 0, 1, 1 },{ 1, -3, 0 },{ 3, 1, 2 },{ 0, -4, 3 },{ -2, -2, -3 },{ 3, -3, 3 },{ 0, -3, 2 },{ 2, 1, -3 },{ -2, 0, 3 },{ 0, -1, 0 },{ 3, -3, 3 },{ -4, -4, -1 },{ 0, -2, 2 },{ -1, -2, -3 },{ -3, 2, 0 },{ 3, -1, 3 },{ -4, 1, -4 },{ -3, -1, 0 },{ -1, 2, -4 },{ 2, -3, 1 },{ -3, -1, -4 },{ -2, -4, -3 },{ 1, 1, -2 },{ 1, -4, 0 },{ -4, 3, -2 },{ 2, -2, -3 },{ 2, -1, 0 },{ -2, 1, -4 },{ -4, -1, 2 } },
+		{ { 2, 0, -3 },{ 0, 2, -2 },{ -4, -1, 2 },{ 3, -3, 1 },{ 2, 1, -2 },{ 1, 0, -2 },{ -3, 2, 3 },{ 3, -1, 1 },{ 1, 1, 0 },{ -1, -3, -4 },{ 0, 1, 1 },{ 2, 3, -3 },{ 2, -4, -4 },{ -4, 2, -1 },{ 1, 1, -2 },{ -1, 0, 3 },{ 0, -4, 2 },{ -3, 1, 1 },{ -2, 2, 3 },{ 1, 1, 0 },{ -3, -3, -2 },{ 1, 2, 0 },{ 3, -2, -3 },{ -1, 0, -1 },{ -4, 3, 3 },{ 0, -1, -1 },{ -2, 1, -4 },{ 1, -1, 3 },{ -1, 2, -2 },{ -3, -2, -4 },{ -2, 0, -1 },{ 3, -2, -3 },{ -4, 1, 3 },{ -1, -2, -4 },{ -4, 3, -1 },{ 3, 2, -4 },{ -1, -2, 2 },{ -4, 0, -4 },{ -3, -1, -2 },{ -1, 1, -1 },{ -4, 2, -2 },{ 2, -4, 1 },{ 3, 2, 0 },{ -4, -2, -2 },{ -3, -3, -4 },{ 1, 1, 2 },{ 2, 2, -4 },{ -2, 0, 3 },{ -4, 3, -2 },{ 3, 0, 2 },{ 0, -3, -1 },{ 2, 2, -2 },{ -2, -2, -2 },{ 0, 0, -1 },{ 1, 1, 2 },{ 2, 3, -3 },{ -3, -3, 3 },{ 0, 2, 0 },{ 3, -1, 2 },{ -3, -1, -4 },{ 1, -3, 1 },{ -1, -4, 2 },{ 3, 3, -2 },{ 0, -3, 0 } },
+		{ { -1, -2, 0 },{ 2, 1, 1 },{ -2, -4, -4 },{ 0, 2, 0 },{ -4, -4, 3 },{ -2, 3, 2 },{ 0, -3, -4 },{ -1, -2, -2 },{ 3, 2, 3 },{ -4, -4, -1 },{ 3, -3, 3 },{ -3, 0, 0 },{ -1, -2, 2 },{ -3, -3, 1 },{ 1, -4, -1 },{ 3, -1, -3 },{ -4, 3, 2 },{ 2, -3, 0 },{ 2, -1, -3 },{ -1, -2, -2 },{ 3, 0, 2 },{ -3, -3, -4 },{ -2, 1, 1 },{ 2, 3, 0 },{ 1, -3, 2 },{ -1, -4, -2 },{ -3, 0, -3 },{ 2, 3, 1 },{ -1, -3, -1 },{ 0, 1, 1 },{ -4, -4, 2 },{ 2, 3, -2 },{ -2, -1, 1 },{ 0, 0, 1 },{ 2, -2, -2 },{ -2, -4, 3 },{ -2, -3, -1 },{ 2, 2, -2 },{ 1, 3, 0 },{ 3, -2, 1 },{ 0, 0, 2 },{ -3, 1, -4 },{ -2, -1, -3 },{ 1, 3, -1 },{ -1, 2, 1 },{ -2, -4, -2 },{ 1, -1, 1 },{ 3, -1, 0 },{ 0, -3, -3 },{ -2, -4, -1 },{ 1, 0, 1 },{ -2, 3, 2 },{ 1, -4, 0 },{ -4, -1, 3 },{ 3, -4, -1 },{ -4, -2, 0 },{ -2, 1, 1 },{ 3, 0, -1 },{ -4, -2, -4 },{ 0, 2, 2 },{ -2, 1, -1 },{ -4, 2, -1 },{ -3, -4, -3 },{ 1, 1, 3 } },
+		{ { -4, -4, -1 },{ 3, 3, -3 },{ -3, -2, 3 },{ 1, 0, -3 },{ -1, -1, -4 },{ 3, -2, 0 },{ -2, -4, 0 },{ 2, 1, -3 },{ -3, -1, -3 },{ -2, 3, 2 },{ 0, 0, -2 },{ 1, -1, -1 },{ 0, 2, -3 },{ 3, 1, 3 },{ -2, -1, -4 },{ -1, 2, 0 },{ -3, 0, -2 },{ 0, -4, -4 },{ -1, 0, 1 },{ -4, -4, -4 },{ 2, 3, 2 },{ 0, 2, -1 },{ -1, -4, 3 },{ -3, -1, -3 },{ 3, 0, -4 },{ -4, 2, 1 },{ 0, 2, 0 },{ 3, -3, 3 },{ -4, -2, -4 },{ 2, 1, -3 },{ 0, 3, 3 },{ 3, -3, 0 },{ -1, -4, -3 },{ 1, 2, 3 },{ -3, 1, -3 },{ 1, 3, 0 },{ -4, 0, 1 },{ -1, -1, 3 },{ -4, -4, -3 },{ -2, -3, 0 },{ 1, 3, -4 },{ -3, -1, -1 },{ 0, -4, 3 },{ -1, -2, 2 },{ 3, 0, 0 },{ -4, 2, -3 },{ -1, -2, -2 },{ -3, 1, 1 },{ 1, 3, 3 },{ -4, 2, -4 },{ -1, -2, -4 },{ -3, 1, 2 },{ 3, -3, -3 },{ -3, 2, -3 },{ 1, 0, -4 },{ -1, 3, -2 },{ 0, -1, 3 },{ 2, -4, -3 },{ -3, 3, 0 },{ 2, -3, 3 },{ -1, 0, -2 },{ 3, -1, 1 },{ 1, 0, -4 },{ -2, 2, 3 } },
+		{ { 0, -1, 2 },{ 2, 0, 1 },{ -1, -3, -2 },{ -2, 2, 2 },{ 0, 3, -1 },{ -4, -2, 1 },{ 2, 1, 3 },{ -4, 2, -1 },{ 0, -3, 1 },{ 2, -1, -2 },{ -2, 2, 0 },{ -4, -4, -4 },{ -1, -2, 0 },{ 2, 0, -2 },{ -3, 3, 1 },{ 2, -3, 0 },{ 3, -2, -1 },{ -4, 3, 3 },{ 1, 2, 0 },{ 0, 1, -1 },{ -3, -3, 1 },{ 1, 0, 3 },{ -4, -1, -2 },{ -2, 1, 1 },{ 0, -2, -1 },{ 2, -3, -2 },{ -2, -1, 0 },{ 1, 0, 2 },{ -2, -4, -3 },{ 1, 0, 0 },{ -3, -1, -2 },{ -2, 2, -4 },{ -4, -1, 2 },{ 3, 3, -1 },{ 0, -3, -1 },{ 3, -1, -4 },{ 0, -4, 2 },{ 3, 2, -3 },{ 0, 1, -1 },{ 1, 0, 3 },{ 3, -3, 2 },{ -1, 0, -2 },{ -4, 1, 1 },{ 2, -3, -3 },{ 2, 1, 3 },{ -3, 3, 2 },{ 0, -3, -1 },{ -1, 1, -3 },{ 2, -4, 1 },{ 3, -2, -2 },{ -2, 0, 3 },{ 2, -2, -1 },{ 0, 3, 0 },{ -1, 0, 3 },{ -2, -3, 1 },{ 2, 2, 2 },{ -4, -3, -1 },{ -2, 2, -4 },{ -1, 1, -2 },{ -2, -4, 0 },{ 1, -2, -3 },{ 0, -3, 2 },{ -3, 3, -1 },{ -1, -2, -4 } },
+		{ { -2, 2, 2 },{ 1, 3, -4 },{ -4, -1, -1 },{ 2, -3, 3 },{ -3, 1, -1 },{ 3, -1, -2 },{ 0, 3, -3 },{ 1, 0, 2 },{ -1, -4, 2 },{ 1, 1, -4 },{ -3, -2, 1 },{ 3, 3, 3 },{ 2, 1, 2 },{ 0, -4, -3 },{ -4, 0, 3 },{ -2, -2, -3 },{ 0, 1, 2 },{ -2, -3, -3 },{ 3, -1, 3 },{ -2, 1, -2 },{ -2, -2, -3 },{ 2, -4, -3 },{ 3, 1, -4 },{ 1, 3, -1 },{ -3, 3, 2 },{ 2, -4, 3 },{ -1, 1, -4 },{ -4, 3, -2 },{ -3, 3, -1 },{ 3, -2, 2 },{ -1, 1, -1 },{ 0, 0, 2 },{ 2, -2, -4 },{ -4, -4, 0 },{ -2, 0, 1 },{ -3, 1, -2 },{ -1, -2, -4 },{ 2, -2, 2 },{ -3, 0, -1 },{ -1, 3, -2 },{ -4, -4, 1 },{ 1, 2, -4 },{ 3, 3, -1 },{ -3, -2, 0 },{ 0, -4, -2 },{ -2, -1, -4 },{ 3, -3, 0 },{ 1, 0, 3 },{ -3, -1, -1 },{ -4, 3, 0 },{ -1, -1, 0 },{ 3, -4, -2 },{ -4, 2, -3 },{ 1, -1, 1 },{ -3, 1, -2 },{ 3, -2, -3 },{ 0, -4, 0 },{ 1, 0, 2 },{ 3, -1, 1 },{ 2, 3, 3 },{ -4, 2, -2 },{ -3, 1, 2 },{ 3, -4, 0 },{ 2, -3, -2 } },
+		{ { -4, 0, 0 },{ -3, -3, -3 },{ 3, 1, 0 },{ -2, -4, 1 },{ 1, 0, -4 },{ -1, -4, 1 },{ -3, -3, -4 },{ -4, -1, -2 },{ -2, -3, -1 },{ 3, 3, 0 },{ 0, 0, -1 },{ -3, -3, -3 },{ -2, -1, 1 },{ -4, 3, -4 },{ 1, -4, 2 },{ -1, 2, -1 },{ 1, 3, -4 },{ -4, -1, 1 },{ -1, -4, -4 },{ 2, 0, 1 },{ -4, 3, 0 },{ -1, 2, 3 },{ -2, -3, 1 },{ 1, -3, -2 },{ -3, -2, 0 },{ -1, 1, -3 },{ 3, -2, -1 },{ 1, -1, 2 },{ 0, -4, 1 },{ -3, 2, -4 },{ -1, -3, 1 },{ 3, -4, 3 },{ 1, 1, -2 },{ -1, 3, -3 },{ 2, -3, 3 },{ 0, 1, 3 },{ -2, 3, 0 },{ -4, -4, 1 },{ -2, 2, -4 },{ 2, -2, 0 },{ -3, -2, -3 },{ 2, -1, 0 },{ -2, 0, 2 },{ 0, 1, -2 },{ 1, -1, 1 },{ -2, 2, -4 },{ -4, 0, 1 },{ -1, 3, 2 },{ -2, -2, -3 },{ 1, 2, -4 },{ 0, -3, 2 },{ 1, 1, 3 },{ -2, -3, -4 },{ -1, -4, 2 },{ 2, -2, -1 },{ -2, 3, 3 },{ -4, 0, -4 },{ 0, -2, 1 },{ -1, -1, -3 },{ -4, -3, -1 },{ 2, -1, -4 },{ 0, 0, 0 },{ -4, 2, -3 },{ 1, -2, 1 } },
+		{ { 3, 2, -2 },{ 0, -4, 3 },{ 2, 0, -3 },{ -1, -2, 2 },{ -4, 2, -2 },{ 2, 3, 3 },{ 2, -2, 0 },{ -2, 1, 3 },{ 3, 2, 1 },{ -3, -1, -3 },{ 2, -4, 3 },{ -1, -2, -2 },{ 1, 2, -1 },{ 0, 1, -2 },{ 3, -1, 0 },{ -2, -2, 0 },{ 3, 0, -2 },{ -3, -4, 3 },{ 1, 2, -1 },{ 3, -2, 2 },{ 0, -2, -4 },{ 1, 1, -1 },{ -4, -1, 0 },{ 0, 0, -4 },{ 2, 0, 2 },{ -4, 2, 1 },{ -2, -3, -3 },{ 2, 1, 0 },{ -1, 0, 3 },{ 2, -2, -3 },{ -4, 3, 0 },{ -2, -1, -3 },{ -3, 0, 2 },{ -1, 2, 0 },{ -4, -1, -3 },{ 3, -3, -1 },{ 1, 2, -2 },{ 3, 0, 2 },{ 1, -1, 3 },{ -2, 2, -3 },{ 0, -3, 1 },{ -1, -4, 3 },{ -4, 3, -4 },{ 2, -3, 3 },{ -3, 3, -3 },{ 3, 1, 3 },{ 2, -2, 0 },{ 0, -4, -2 },{ 3, 2, -4 },{ 2, -4, 1 },{ -3, 1, -1 },{ -3, 0, -3 },{ 2, 3, 1 },{ -4, 0, -4 },{ 3, 2, -1 },{ 1, 1, -2 },{ -3, -3, -2 },{ 2, 1, 3 },{ -3, 2, -4 },{ -1, -4, 2 },{ 0, 1, -1 },{ 1, -4, 3 },{ -2, 3, -4 },{ -1, 0, 3 } }
+	},
+	{
+		{ { -1, 3, 1 },{ 2, -1, -1 },{ 1, -3, -4 },{ -1, 3, -2 },{ -4, 2, -3 },{ -2, -2, -2 },{ 1, 3, -4 },{ 0, 1, 3 },{ -2, 2, -2 },{ -4, -4, -3 },{ 1, -1, 3 },{ -3, -4, -1 },{ 0, 2, 1 },{ 2, 0, 2 },{ -4, 3, -1 },{ -1, -3, 3 },{ 2, -4, 0 },{ 1, 0, -3 },{ 2, 2, 3 },{ -2, -1, 1 },{ 2, -3, -3 },{ -4, 3, -1 },{ 2, -2, -2 },{ 0, -4, 1 },{ -3, -2, 3 },{ 3, -3, -2 },{ 1, -3, 2 },{ -2, 2, -3 },{ 0, -1, 1 },{ 3, -3, -2 },{ -2, -4, 3 },{ 0, -3, 2 },{ -4, 1, 1 },{ -1, -3, 3 },{ -3, 2, 0 },{ 1, 0, -4 },{ -2, -1, 2 },{ -3, 2, -4 },{ -1, -3, -1 },{ 0, -1, 1 },{ 1, 2, 3 },{ -2, 0, -2 },{ -4, -2, 1 },{ 2, 3, -4 },{ 0, 0, 1 },{ -2, 2, -4 },{ -3, -2, -3 },{ 3, 0, 0 },{ -4, -1, -3 },{ 1, -3, 0 },{ 3, 3, -2 },{ 1, 1, 1 },{ -1, -2, 0 },{ 0, 2, -3 },{ 2, -1, 1 },{ -3, 3, 3 },{ 1, -4, -4 },{ 3, -3, -2 },{ -3, 1, 2 },{ -2, -3, -3 },{ 2, -1, -2 },{ 3, 3, 1 },{ 1, 1, 0 },{ -4, -3, 2 } },
+		{ { -1, 0, -4 },{ -4, 2, -2 },{ 2, 1, -3 },{ 0, -1, 2 },{ -3, -4, 2 },{ 2, -1, 3 },{ -1, -3, -1 },{ -3, 0, -4 },{ -1, -3, 2 },{ 0, -1, 0 },{ 1, 2, -1 },{ 3, 1, -2 },{ 2, -3, -4 },{ -1, -2, 0 },{ 3, 1, -3 },{ -2, 0, -4 },{ 3, -1, 1 },{ -3, -2, -2 },{ -4, 3, 2 },{ 0, 1, 0 },{ 0, 0, -4 },{ -2, -4, 3 },{ -3, 1, 2 },{ -1, -1, -4 },{ -3, 1, 0 },{ -2, 3, -1 },{ 2, 0, 2 },{ -1, -2, -2 },{ -4, 3, 3 },{ -1, -1, -1 },{ -3, 0, -4 },{ 2, 2, 0 },{ 1, 1, -1 },{ 0, -1, -3 },{ -1, -4, -2 },{ 3, 0, 0 },{ -4, -4, 3 },{ 1, 1, -3 },{ 3, -2, 2 },{ 2, -3, 0 },{ -4, -4, -4 },{ 3, 1, 1 },{ 0, -3, -3 },{ -3, 2, 2 },{ -1, -4, 0 },{ -4, -1, 3 },{ 1, 1, 2 },{ 2, 3, -1 },{ -2, -4, 1 },{ 0, -1, -4 },{ -1, -2, -1 },{ -2, -4, 0 },{ 3, -1, 2 },{ -4, 2, -1 },{ -2, -4, -2 },{ 0, -2, -1 },{ -4, 0, 0 },{ 2, 2, -3 },{ 0, -2, 0 },{ -4, -4, -1 },{ 0, -2, 3 },{ -3, 2, -1 },{ -2, -1, -4 },{ 3, -4, 3 } },
+		{ { -3, -2, 0 },{ 3, -3, 1 },{ 0, -4, 3 },{ -2, -2, 0 },{ 3, 1, 1 },{ 3, 3, -3 },{ -4, 0, 0 },{ 0, -2, -1 },{ 3, 2, 2 },{ 2, 3, -4 },{ -4, 0, 1 },{ -2, -3, 3 },{ -3, 3, 2 },{ 0, -1, -2 },{ -3, -4, 0 },{ 1, -1, 1 },{ -4, 2, 3 },{ 0, -4, -1 },{ 3, -2, -4 },{ -2, -3, -2 },{ 2, 2, -1 },{ 3, 2, -3 },{ -4, 0, 0 },{ 1, -3, -2 },{ 0, 2, 2 },{ 3, -1, 1 },{ 0, -4, -3 },{ -3, 1, 0 },{ 2, 2, -4 },{ 1, -3, 0 },{ 3, 3, 2 },{ -3, -2, 1 },{ -2, -1, -3 },{ 3, -3, 3 },{ -4, 3, 2 },{ -1, 2, -1 },{ 0, -3, 1 },{ 2, 3, 1 },{ -4, 0, -2 },{ -2, 3, -1 },{ -3, 1, -2 },{ -1, 3, 2 },{ 1, -1, 0 },{ -2, 2, -1 },{ 3, -3, -2 },{ 2, -1, 0 },{ -1, 0, -2 },{ -3, -3, -4 },{ -3, 1, 2 },{ 3, 2, -2 },{ -3, 1, 3 },{ 2, 0, -4 },{ 0, -3, -2 },{ 2, 3, -4 },{ -3, 0, 2 },{ 3, 2, -3 },{ -1, 1, 3 },{ -3, -1, 1 },{ -1, 3, 2 },{ -1, 0, -4 },{ 3, -4, 2 },{ -4, 2, -3 },{ 0, -3, -3 },{ -2, 1, 0 } },
+		{ { 1, 3, 2 },{ -4, 0, -2 },{ -2, 2, -1 },{ -4, 0, -4 },{ -1, -3, -2 },{ 1, -3, -1 },{ -2, 2, 1 },{ 2, -4, 3 },{ -4, -2, -3 },{ -2, 0, -2 },{ -1, -4, 0 },{ 0, -2, -3 },{ -4, 2, -1 },{ 1, 1, 2 },{ 2, 2, -3 },{ -1, -3, -1 },{ -2, 3, -3 },{ 1, 0, 3 },{ -1, 1, 0 },{ -3, -1, 2 },{ -3, -1, 3 },{ 1, -3, 1 },{ 3, 3, -1 },{ -2, -2, 3 },{ -2, -4, -3 },{ 0, 0, -4 },{ -4, -2, 3 },{ 1, 2, -1 },{ -2, -4, 2 },{ -4, 0, -2 },{ 0, 1, -3 },{ -1, -4, -2 },{ 2, 1, -4 },{ -3, 3, 1 },{ 1, -2, -2 },{ 2, 0, -4 },{ -2, -2, 0 },{ -3, -1, -4 },{ -1, -4, 3 },{ 1, 0, -3 },{ 2, -1, 3 },{ 0, -2, -2 },{ -2, -4, -4 },{ 3, 0, 3 },{ -4, 1, -3 },{ 0, 3, 1 },{ 1, -4, -4 },{ 3, -2, 3 },{ 0, 0, 1 },{ 1, -2, 0 },{ -4, 3, 2 },{ -1, -4, -3 },{ -4, 1, 3 },{ 1, -3, 1 },{ -2, -2, 3 },{ 1, -1, 0 },{ -4, -3, -1 },{ 1, -3, -4 },{ 3, 1, 3 },{ -2, -1, -2 },{ 1, 3, 0 },{ 2, 0, 1 },{ 1, -1, 3 },{ 2, -2, -2 } },
+		{ { -1, 1, -4 },{ 2, -3, 3 },{ 0, -1, -3 },{ 1, 3, 2 },{ 2, 1, 3 },{ -3, 2, -4 },{ -1, -1, -3 },{ 1, 1, -2 },{ 1, 1, 0 },{ -3, -3, 3 },{ 3, 1, 2 },{ 2, -1, -4 },{ 0, -4, -3 },{ -4, 0, 1 },{ -1, -3, 3 },{ 3, 1, -2 },{ -3, -1, 0 },{ 0, -3, -4 },{ 2, 3, -3 },{ 1, -4, 1 },{ -4, 2, -3 },{ -1, -2, -4 },{ -1, -4, 0 },{ 2, 1, -2 },{ 2, 3, -1 },{ -4, 2, 1 },{ 3, -2, -2 },{ -3, 1, 1 },{ 0, -1, -4 },{ 2, -3, 1 },{ -4, 0, 3 },{ -1, -2, -1 },{ 0, -4, 0 },{ -4, 2, 2 },{ 2, 0, -3 },{ -2, -3, 2 },{ 3, 2, -1 },{ 0, 1, -3 },{ 3, -3, 1 },{ -2, 2, 0 },{ -4, -3, -1 },{ 2, 2, 2 },{ -4, 0, 0 },{ -1, -3, -1 },{ 1, -2, 2 },{ -3, -3, -3 },{ -2, 2, 0 },{ -4, 2, -1 },{ -1, -3, -2 },{ 1, -4, -3 },{ -2, 2, 1 },{ 2, -2, -1 },{ -2, -1, 0 },{ 3, 2, 1 },{ -1, 3, -4 },{ 3, -4, -2 },{ -2, 3, 1 },{ 2, -4, -2 },{ -3, 2, -3 },{ 0, -3, 0 },{ -1, -2, -4 },{ -3, 1, -2 },{ -1, -4, -1 },{ -3, 3, 1 } },
+		{ { 3, -4, 0 },{ -3, -1, -2 },{ -1, 3, 1 },{ 3, -2, 0 },{ -3, -4, -1 },{ 0, -2, 2 },{ -4, -4, 1 },{ -1, -1, 2 },{ -2, 3, 0 },{ 0, -4, -4 },{ 1, 3, 1 },{ -3, 0, -1 },{ 3, 3, 3 },{ -2, -3, -1 },{ 2, 3, -4 },{ -3, -2, 1 },{ 2, -4, 1 },{ -4, 0, 2 },{ -2, 1, -2 },{ 3, -3, 0 },{ 0, 0, -1 },{ 2, 1, 2 },{ -4, 3, 2 },{ -3, -1, -4 },{ -1, -1, 0 },{ 1, -3, 3 },{ -1, -4, 0 },{ 2, 3, -2 },{ -1, 2, -3 },{ 3, -2, 0 },{ -2, 3, 2 },{ 1, 2, -4 },{ 1, -1, 2 },{ -2, -2, -1 },{ -1, -1, 0 },{ -4, -4, 3 },{ -1, 1, -2 },{ -4, -2, 2 },{ 1, 3, -1 },{ 1, -2, 2 },{ -3, -1, -4 },{ -1, 1, -3 },{ 3, 3, 1 },{ 1, 1, -4 },{ -3, 3, 3 },{ -1, 0, -1 },{ 3, -1, 1 },{ 2, 1, 3 },{ 0, -1, -4 },{ -3, 0, 0 },{ 3, -1, 3 },{ 0, 3, -3 },{ -1, 1, -2 },{ -3, -1, -1 },{ -4, -2, -3 },{ 2, 0, 0 },{ 0, 0, 2 },{ 0, -2, 2 },{ -2, 1, -1 },{ -4, 0, 3 },{ 2, -3, 1 },{ -4, 2, 2 },{ 3, -1, -4 },{ 0, 1, -3 } },
+		{ { -2, -2, 2 },{ -2, 1, -1 },{ 2, -4, 2 },{ -1, 2, -3 },{ -2, -1, -1 },{ 0, 0, -3 },{ 3, 3, 0 },{ 2, 2, -2 },{ 3, -2, -3 },{ -1, -1, -1 },{ -4, -2, -2 },{ -2, 2, 3 },{ 1, -2, 0 },{ -1, -1, -2 },{ -2, 1, 2 },{ 0, 0, -3 },{ 1, 2, -1 },{ -2, 2, -1 },{ 2, -1, 2 },{ -1, -2, 3 },{ -3, 2, -4 },{ -2, 0, -2 },{ 3, -3, -3 },{ 0, -2, 3 },{ -3, 2, 1 },{ 3, 0, -4 },{ -2, -1, -1 },{ 0, 0, 2 },{ -3, -2, 3 },{ 1, -3, -3 },{ -3, 0, -1 },{ 3, 3, -2 },{ 2, -3, 3 },{ 0, 1, -3 },{ 3, 2, 1 },{ 1, 3, -4 },{ 0, -1, 0 },{ 3, -4, 3 },{ -3, 0, -4 },{ -1, 3, 0 },{ 3, 1, -2 },{ 0, -4, -1 },{ -2, -2, 3 },{ 0, -1, -2 },{ -4, -4, -2 },{ -2, -4, -4 },{ 2, 3, -3 },{ -4, -2, -1 },{ -1, -4, 2 },{ -3, 3, -1 },{ 2, -2, -2 },{ -4, -3, -4 },{ 1, -4, 1 },{ 1, 1, 2 },{ 0, -3, 3 },{ -3, 1, -2 },{ -4, 2, -4 },{ -1, -1, 0 },{ 3, -2, -4 },{ 1, 3, -3 },{ 2, 2, -1 },{ -2, -4, 0 },{ 0, -3, 3 },{ -4, 0, 1 } },
+		{ { 1, -3, -2 },{ -4, 2, -4 },{ 3, 0, -4 },{ -4, -3, 1 },{ 1, 3, -2 },{ -3, 1, 3 },{ 2, -3, 2 },{ -4, -3, -4 },{ -2, 0, 3 },{ 0, 1, 2 },{ -3, 0, 1 },{ 0, -4, -3 },{ 3, 2, -3 },{ -4, -2, 2 },{ -3, -4, -4 },{ 0, 0, 0 },{ 3, -2, 3 },{ -4, -4, -4 },{ 0, -1, -3 },{ -3, 3, 1 },{ 2, -3, -2 },{ 0, -4, 3 },{ 1, 1, 0 },{ -2, -2, -1 },{ 2, -4, -3 },{ -4, 2, -2 },{ 0, -3, 0 },{ -4, 1, 2 },{ 3, 3, -4 },{ -2, 1, 1 },{ -4, -4, 0 },{ -1, -1, -3 },{ -4, 1, 1 },{ -3, -4, -4 },{ -2, -2, -2 },{ -3, 0, 2 },{ 2, -3, -2 },{ -3, 2, -1 },{ -2, 0, -3 },{ 2, -2, 2 },{ -4, -4, 1 },{ 1, -1, 3 },{ -3, -3, -3 },{ 2, 2, 0 },{ 3, 1, 2 },{ 0, -2, 1 },{ 1, 0, 0 },{ -2, 2, 2 },{ 1, -3, -3 },{ -1, 2, 1 },{ 3, 1, 3 },{ 0, 0, 2 },{ -2, 2, 2 },{ 2, -3, 0 },{ 3, -1, -4 },{ -3, 3, 1 },{ 1, -4, -1 },{ 3, -3, 2 },{ -4, 3, 1 },{ 0, -4, 3 },{ -2, -1, -2 },{ -1, 0, -3 },{ 3, 3, -2 },{ 1, 3, -1 } },
+		{ { 2, 1, 3 },{ 0, 2, 0 },{ -1, -1, 1 },{ -3, -2, 3 },{ 2, -1, -4 },{ -2, 1, 1 },{ -1, -2, -2 },{ -3, 2, -1 },{ 1, -2, -3 },{ 3, 3, 0 },{ 1, -3, -4 },{ 2, -3, 2 },{ -1, 0, 0 },{ 2, 3, 0 },{ 1, 1, -2 },{ 2, -3, 3 },{ -2, 3, -2 },{ -1, 2, 1 },{ 3, -4, -1 },{ -2, 1, -4 },{ 1, -1, 2 },{ -4, 2, 0 },{ -1, 3, -4 },{ 1, 0, 1 },{ -1, 1, 2 },{ 1, 3, 2 },{ 2, -2, -4 },{ -3, -1, -3 },{ 1, -4, -2 },{ 0, -3, 1 },{ 2, 1, 3 },{ 0, 0, -1 },{ -2, -2, 2 },{ 0, 3, 0 },{ 2, -3, -1 },{ 1, 1, 1 },{ -1, -4, -3 },{ 0, 1, 0 },{ -2, -3, 1 },{ 2, 2, -2 },{ -4, 1, 0 },{ -1, 0, -4 },{ 1, 3, -1 },{ -2, -3, 1 },{ -1, 0, -2 },{ -3, -1, 3 },{ 3, -3, -4 },{ -3, 1, 1 },{ 2, -1, -4 },{ -2, 0, -2 },{ -4, -4, 0 },{ 1, -2, -3 },{ -3, 3, -1 },{ -2, 2, -3 },{ -1, 0, -2 },{ 0, -2, 3 },{ 2, 0, -3 },{ -2, -1, 3 },{ -3, 1, -2 },{ 1, 0, -4 },{ 2, 1, 1 },{ -3, -2, 2 },{ -1, -1, -4 },{ -3, -4, 1 } },
+		{ { -1, -3, 2 },{ -3, -1, -3 },{ 3, -4, -2 },{ 1, 3, -1 },{ 0, 2, 0 },{ 3, -4, 2 },{ 0, 0, -4 },{ -4, -1, 1 },{ -1, -4, 1 },{ 2, 1, 3 },{ -4, 3, -1 },{ -2, -1, -2 },{ -3, 2, 3 },{ -2, -4, -4 },{ 0, -2, 2 },{ -4, 3, -1 },{ -3, -1, -3 },{ 2, 0, 1 },{ 1, -2, 3 },{ -2, 3, -1 },{ 2, 0, 0 },{ 3, -4, 3 },{ -4, -2, -2 },{ 3, -1, -3 },{ -3, -3, -1 },{ -2, -4, 3 },{ 0, 2, 0 },{ -1, 0, 1 },{ 3, 2, -2 },{ -2, 3, 2 },{ -1, -1, -4 },{ 3, -3, -2 },{ 1, 2, -3 },{ 3, 0, 3 },{ -2, -1, -1 },{ -4, 2, 3 },{ -4, -2, -4 },{ 3, 3, 2 },{ 1, -1, 3 },{ 0, -3, -4 },{ 3, 3, 0 },{ -1, -1, -3 },{ 2, 1, -1 },{ -4, 2, 2 },{ 0, -2, -3 },{ -2, 3, -1 },{ 1, -4, -2 },{ -4, 3, 3 },{ 0, -3, -1 },{ 3, -1, 0 },{ 1, 1, -4 },{ -3, -2, -1 },{ 2, -1, 1 },{ -1, -4, -4 },{ -4, 1, 0 },{ 2, -2, 2 },{ -2, 3, -2 },{ 0, 2, -1 },{ -1, -3, -1 },{ 3, -4, 2 },{ -2, -2, 0 },{ 1, -3, -1 },{ -4, 2, 3 },{ 3, -1, -3 } },
+		{ { -2, -4, -4 },{ 1, 3, 0 },{ -4, 1, 3 },{ -2, 0, -3 },{ -3, -2, 0 },{ -4, -4, -2 },{ 1, 3, 3 },{ -2, 1, -1 },{ 3, 2, -3 },{ -3, -4, 0 },{ -2, -2, -2 },{ 1, 1, 1 },{ 3, -3, -1 },{ -4, 1, 1 },{ 1, 0, -3 },{ 3, -1, 0 },{ 1, -3, 1 },{ -1, 1, -2 },{ -4, -3, 2 },{ -3, 0, -4 },{ 0, -2, -3 },{ -1, -3, 1 },{ -3, 0, -3 },{ 0, 3, 1 },{ 0, 1, 0 },{ -3, 0, -4 },{ 3, -2, -1 },{ -4, -1, 3 },{ -2, -3, 0 },{ 2, -2, -1 },{ -3, 2, -3 },{ -4, 3, 2 },{ -3, 0, 1 },{ -1, -4, -4 },{ 0, 3, -3 },{ 2, -2, -2 },{ 3, 0, 1 },{ -3, 3, -2 },{ -1, -2, -1 },{ -3, 0, -2 },{ -2, -3, 3 },{ 1, -4, 1 },{ -3, -2, 3 },{ 3, -4, -4 },{ 0, 1, 1 },{ 2, -1, 0 },{ -1, -2, 0 },{ 0, 2, -3 },{ -1, 0, 3 },{ -3, 2, 2 },{ 0, 3, 2 },{ -1, -3, -2 },{ 1, 1, 3 },{ 3, -1, 3 },{ 1, 3, 1 },{ -4, -4, -1 },{ -1, -3, -4 },{ 1, -1, 1 },{ -4, 0, 0 },{ -4, 3, -3 },{ 3, 2, 3 },{ 0, 3, -3 },{ -4, 1, 0 },{ -2, 0, -1 } },
+		{ { 1, -2, 2 },{ 2, -2, -1 },{ 0, 1, -3 },{ 2, -3, 2 },{ -1, 2, 2 },{ 2, 2, -4 },{ 3, -3, -1 },{ 0, -1, 2 },{ 1, 0, -2 },{ -1, -2, -4 },{ 0, 0, 3 },{ 0, 3, -4 },{ 2, -1, -3 },{ -3, -3, 3 },{ -1, 2, -2 },{ -1, -4, 2 },{ -3, 1, -4 },{ 0, 2, 0 },{ 3, -4, -3 },{ 1, 2, 0 },{ -2, 1, -2 },{ 1, 3, 3 },{ 2, 2, -1 },{ -2, -3, 2 },{ 2, -1, 3 },{ -3, -4, -3 },{ 2, 3, -2 },{ -1, 1, 2 },{ 1, -4, -4 },{ -4, 0, 1 },{ 0, -2, -1 },{ 3, -4, 3 },{ 1, -3, -2 },{ -4, -1, 0 },{ 2, -2, 3 },{ -1, -4, 0 },{ -2, 1, 2 },{ 0, -4, -3 },{ 3, 1, 1 },{ -4, -4, -4 },{ 2, 2, 2 },{ 0, 2, 0 },{ -2, -2, -2 },{ 1, 0, -3 },{ -4, -3, 3 },{ 3, 2, -1 },{ -3, 0, 2 },{ 2, -4, -3 },{ -4, -2, 1 },{ -2, -3, -1 },{ 3, -4, -4 },{ -4, 2, 0 },{ -2, 2, 0 },{ -3, -3, -2 },{ 0, 0, -4 },{ -3, 2, 2 },{ 3, 1, 0 },{ 2, 2, -3 },{ 1, 1, 3 },{ -3, -4, -4 },{ -2, -1, -2 },{ 2, -2, 1 },{ 2, -4, -2 },{ 0, 2, -2 } },
+		{ { -4, 3, 3 },{ -1, 0, 1 },{ -3, -3, -4 },{ 3, -1, 0 },{ -2, 0, -2 },{ -1, -1, 1 },{ -3, 1, -3 },{ -2, -3, 2 },{ -4, 3, 0 },{ 2, -3, 2 },{ -4, 2, 1 },{ 3, -4, 2 },{ -1, 2, 0 },{ -2, -2, -2 },{ 2, 3, -4 },{ 3, 0, 2 },{ -4, -2, -3 },{ -2, -1, -1 },{ 2, 3, 3 },{ -1, -2, 2 },{ -4, -1, 1 },{ 3, -4, -4 },{ -4, -1, -1 },{ -1, -2, -4 },{ 3, 2, -2 },{ 1, 0, 0 },{ -4, 2, 1 },{ 1, -1, -3 },{ 0, 2, -3 },{ -1, 3, 3 },{ 1, 1, 0 },{ -1, -1, -4 },{ -2, 3, -1 },{ 0, 1, 2 },{ -3, 1, -2 },{ 1, 2, -4 },{ -3, -3, -1 },{ 1, 0, 3 },{ 0, -1, -3 },{ -1, 1, 2 },{ 3, -1, -1 },{ -4, 0, -3 },{ 2, 3, 2 },{ -1, 1, 0 },{ -2, 3, -2 },{ -4, -3, -4 },{ -1, 2, 1 },{ 3, 1, -4 },{ 1, -1, -2 },{ 2, 1, 3 },{ -1, -2, -3 },{ 2, 0, -2 },{ 0, -2, 2 },{ 3, -4, -3 },{ -2, -1, -1 },{ 1, -2, -2 },{ 0, -2, 3 },{ -3, -3, -2 },{ -1, -2, 2 },{ 0, 2, 0 },{ 1, 0, -1 },{ -1, 0, 3 },{ -3, -3, -4 },{ 3, 2, 1 } },
+		{ { 2, 0, -2 },{ -2, -4, -3 },{ -4, 3, -1 },{ 1, -2, 3 },{ 0, -4, -2 },{ -4, 3, -1 },{ 1, -4, 1 },{ 3, -2, 3 },{ -1, 1, -4 },{ 1, 3, -3 },{ -3, -1, -1 },{ 1, -3, -3 },{ -4, 0, -1 },{ -2, 0, 1 },{ 2, -3, 0 },{ 0, 2, 0 },{ 1, -4, 3 },{ -4, 0, 1 },{ -1, -3, -4 },{ 2, 3, -2 },{ -3, 0, 0 },{ 0, -3, -3 },{ -1, 1, 3 },{ -4, 3, 2 },{ 0, -1, 0 },{ -2, -3, -2 },{ -1, -3, 3 },{ -2, -2, -1 },{ -3, -4, 1 },{ 3, -1, -2 },{ -3, -3, -2 },{ 2, 0, 2 },{ 2, 2, 1 },{ -4, -1, -4 },{ 3, -4, 2 },{ -1, 3, 1 },{ -2, -1, -3 },{ 2, 2, -1 },{ -4, 3, 0 },{ -2, -2, 0 },{ 1, -4, -2 },{ -1, -3, 1 },{ -3, -1, -4 },{ 3, -4, -1 },{ 0, -1, 2 },{ 1, -2, 0 },{ -3, -1, 3 },{ -2, 3, 2 },{ -2, -3, -2 },{ 0, 0, 0 },{ -3, 3, -1 },{ 1, -1, 2 },{ -4, 3, -3 },{ -1, 1, 3 },{ 2, 3, 1 },{ -4, 2, -4 },{ 1, -4, 1 },{ -2, 3, -1 },{ 3, -1, -3 },{ 2, -4, 1 },{ -4, 3, -1 },{ -1, -2, 2 },{ 0, 1, -4 },{ -2, -1, 0 } },
+		{ { 1, -3, -3 },{ 0, 2, 0 },{ 3, 0, 2 },{ -2, 2, 0 },{ -1, -1, 3 },{ 3, 1, -4 },{ -3, -2, -3 },{ 0, 0, -2 },{ -2, -1, 0 },{ 2, 0, -1 },{ -2, 1, 3 },{ 0, -2, 1 },{ 3, 3, -4 },{ 0, -4, 3 },{ -4, -1, -1 },{ -3, -2, -2 },{ -1, 3, -4 },{ 3, 0, 2 },{ 0, -4, -1 },{ -3, -2, -3 },{ 3, 1, 1 },{ -2, -4, 0 },{ 2, 2, -2 },{ 3, -4, -3 },{ -2, 0, 1 },{ -3, 1, 3 },{ 2, 3, -4 },{ 3, 0, 2 },{ 2, -3, -1 },{ -3, 1, 3 },{ 1, 2, -4 },{ -4, -4, -3 },{ -2, -2, 3 },{ -1, -3, -1 },{ 2, 0, -3 },{ 0, -2, 0 },{ -4, -2, 3 },{ 2, -3, 1 },{ 0, 0, -4 },{ -3, -3, 3 },{ 2, 3, -2 },{ 1, 1, -1 },{ -3, 2, 3 },{ 2, 0, 1 },{ -1, 2, -3 },{ 1, -4, -3 },{ 0, 1, -1 },{ 3, -1, -1 },{ 0, -4, -3 },{ -4, 2, 1 },{ 1, -3, 2 },{ 3, -4, 1 },{ -2, 0, -4 },{ -3, -3, -1 },{ 2, 1, 0 },{ -3, -1, 2 },{ -2, 0, -3 },{ 0, 1, 1 },{ -4, 0, -4 },{ -3, -3, 2 },{ 3, 1, -3 },{ -3, -3, -3 },{ 3, 3, 1 },{ -4, -4, 2 } },
+		{ { -1, -1, 3 },{ -3, 1, 1 },{ 0, -2, -4 },{ -4, 1, -2 },{ 1, -3, -3 },{ 2, 0, 1 },{ -2, 2, 0 },{ -4, 2, 2 },{ 1, -4, -4 },{ 3, -3, 2 },{ -4, -4, -2 },{ -1, 1, -3 },{ 1, 2, 2 },{ -3, -2, -3 },{ 1, 3, -3 },{ 3, 1, 1 },{ 2, -3, -2 },{ -2, 1, 2 },{ 1, 2, 0 },{ -4, 1, -1 },{ 0, -1, 2 },{ 1, 3, 3 },{ -3, 0, -4 },{ 0, -2, 0 },{ 0, -2, -1 },{ 3, -1, -4 },{ -4, -4, -3 },{ 0, 2, 0 },{ -2, -1, -3 },{ 0, 3, 2 },{ 3, -2, 0 },{ -2, 1, 1 },{ 0, 2, -2 },{ 1, 3, 0 },{ -3, -4, -1 },{ -1, 1, -2 },{ 3, 2, -4 },{ 1, 0, -2 },{ -2, -4, 2 },{ 3, 2, -3 },{ -4, -1, 2 },{ -1, -2, 1 },{ 0, -4, -4 },{ -4, -2, -1 },{ -3, 3, 3 },{ 3, 0, -2 },{ -2, 3, 1 },{ -4, -3, 0 },{ 2, -2, -4 },{ -3, -1, 3 },{ -1, 1, -4 },{ 0, -2, -2 },{ 2, 2, 0 },{ -1, -2, 3 },{ 1, -4, -2 },{ -1, -3, -4 },{ 3, -2, -1 },{ 2, 3, 3 },{ 1, -4, -2 },{ -1, -1, 0 },{ 1, 2, 3 },{ -2, -1, -1 },{ 2, -2, 0 },{ -2, 2, -1 } },
+		{ { 1, 3, -2 },{ 3, -3, -4 },{ 2, -4, -1 },{ -3, 3, 3 },{ 3, -4, 2 },{ 0, 0, -1 },{ -2, -3, 3 },{ 2, 3, -2 },{ -1, -3, 1 },{ 0, -1, -2 },{ -3, 2, 1 },{ 3, -1, 0 },{ -1, -3, 0 },{ -4, 0, 3 },{ -1, 1, -1 },{ -2, -4, 2 },{ 0, -1, 0 },{ -3, 3, -3 },{ -2, -4, 3 },{ 3, -2, -2 },{ -1, -3, -4 },{ -2, 0, -3 },{ 2, -3, 1 },{ -4, 2, 3 },{ 1, 1, -2 },{ -1, 2, 2 },{ 1, -4, -1 },{ 1, 1, 1 },{ -4, 0, -2 },{ -1, -3, -4 },{ -4, -3, 1 },{ 1, 0, -1 },{ -3, -1, 2 },{ 3, 1, -4 },{ -4, -3, 2 },{ 1, 0, 3 },{ -2, 3, -1 },{ -1, -4, 1 },{ -3, 3, 0 },{ 1, -2, -1 },{ 0, 0, -4 },{ -2, 2, -2 },{ 3, -3, 2 },{ -2, 0, -3 },{ 0, -3, 1 },{ -4, -2, -4 },{ 2, 1, 2 },{ -1, 2, 2 },{ 1, 0, 3 },{ 3, 3, -3 },{ -2, 2, -1 },{ 1, 0, -2 },{ -3, -3, 2 },{ -4, -1, -3 },{ 3, 2, 1 },{ 0, 3, 0 },{ -3, 1, 3 },{ -1, -2, 0 },{ 2, 2, 2 },{ -2, -1, -4 },{ 0, 3, 1 },{ 3, 1, -4 },{ 0, -4, -2 },{ -1, 0, 3 } },
+		{ { 2, 0, 0 },{ -3, -2, 2 },{ -2, -1, -2 },{ 1, 2, -3 },{ -4, 1, 0 },{ -3, -2, -4 },{ 0, -1, -3 },{ 3, 1, 1 },{ -3, 0, -1 },{ 2, 2, -3 },{ 1, 0, 3 },{ -2, 3, -4 },{ 2, -2, -2 },{ 0, 0, -2 },{ 2, 2, 1 },{ -4, -3, -4 },{ 2, -1, 1 },{ 1, 0, -1 },{ 3, -2, -4 },{ 0, 0, 1 },{ -4, 2, 2 },{ 2, -1, -1 },{ -1, 3, -2 },{ 3, -2, 2 },{ -2, -3, -3 },{ -4, 3, 1 },{ -1, -1, 0 },{ -3, -2, 3 },{ 2, 3, 2 },{ 0, 2, -2 },{ 3, 1, 3 },{ 2, -4, -3 },{ -1, 3, -2 },{ -2, -1, 2 },{ 2, -4, 1 },{ 0, -1, -4 },{ -3, -2, -3 },{ 3, 1, 2 },{ -4, -1, -3 },{ 2, 1, 1 },{ -1, -4, 3 },{ -3, 3, -2 },{ 2, 1, 0 },{ 3, 1, 2 },{ 1, 3, 0 },{ 1, -1, 0 },{ -3, -4, -4 },{ -3, -4, -2 },{ 0, -1, -1 },{ -1, -2, 0 },{ 1, -4, 1 },{ -4, 1, -4 },{ 2, 3, 1 },{ -2, 1, -2 },{ 0, 0, 2 },{ -3, -4, -3 },{ -4, -1, -4 },{ 1, 0, -2 },{ -4, -3, -3 },{ -3, -4, -1 },{ 1, 0, 3 },{ -4, -3, 2 },{ -3, -2, -1 },{ -4, 1, -4 } },
+		{ { 1, -4, 3 },{ -2, 2, 0 },{ 0, 0, 2 },{ -1, -1, 1 },{ 1, -3, -2 },{ -1, 3, 1 },{ 1, -4, -1 },{ -4, -1, 3 },{ -2, -2, -3 },{ -3, 3, 0 },{ 1, -4, 1 },{ -4, -3, 2 },{ -2, -1, -1 },{ 3, -4, 2 },{ -3, 2, 3 },{ 0, -3, -4 },{ -1, 3, -2 },{ -4, 2, 0 },{ -3, -4, 3 },{ 2, 3, -3 },{ -2, -3, 0 },{ -4, 1, 1 },{ 1, -4, -4 },{ -3, -1, 0 },{ 0, 0, -1 },{ 2, 0, -4 },{ 3, -3, -2 },{ -3, 2, -4 },{ 3, -4, -1 },{ -2, -1, 0 },{ -3, 0, -4 },{ 1, -2, 3 },{ -2, -2, -3 },{ -4, 3, -1 },{ 0, 0, -1 },{ -3, -3, 3 },{ 0, 2, 0 },{ 1, 2, 0 },{ -2, -2, -2 },{ 3, -3, -1 },{ 0, 0, 3 },{ -3, -1, 1 },{ 1, -4, -4 },{ -4, -1, -1 },{ -1, 2, -2 },{ -1, -3, 3 },{ 3, 2, -3 },{ 2, 1, 1 },{ -2, 3, -1 },{ -4, -3, -4 },{ 3, 2, 2 },{ -1, -1, 0 },{ -2, -4, 3 },{ 3, -2, -1 },{ 1, -3, -1 },{ 2, -1, 1 },{ -2, 2, 3 },{ 0, -2, 0 },{ 3, 3, 2 },{ -1, 1, 1 },{ 0, 2, -2 },{ 3, -3, -3 },{ 2, -1, 1 },{ 0, 3, -3 } },
+		{ { -3, -3, -2 },{ 3, -2, -3 },{ -4, 3, -4 },{ 3, -4, -1 },{ -2, 2, 3 },{ 2, -2, 2 },{ 3, 2, 0 },{ 0, 2, 2 },{ -1, -4, -4 },{ 3, -2, 2 },{ 0, 0, -1 },{ 2, 1, -3 },{ -1, -2, -4 },{ -3, 3, 0 },{ 1, 1, -3 },{ 2, -2, 0 },{ 3, -2, 3 },{ -1, -1, 2 },{ -3, 1, -2 },{ 1, 2, 1 },{ 0, -4, 2 },{ 3, 0, -3 },{ -3, 3, 3 },{ 1, 2, -3 },{ 0, -4, 2 },{ -3, 2, 3 },{ -2, 1, 1 },{ 1, -3, -3 },{ -1, -1, 2 },{ -4, -2, -2 },{ -1, 2, 1 },{ 0, 2, 0 },{ 1, -3, 0 },{ 3, 1, 1 },{ 3, 2, -4 },{ -1, 3, -3 },{ 2, -1, -2 },{ -2, -4, 2 },{ 1, 0, 1 },{ -1, 2, -4 },{ -4, 3, -3 },{ 3, 0, 0 },{ -2, -2, -3 },{ 0, -3, 3 },{ -3, 0, -2 },{ -2, 0, 2 },{ 0, -2, -1 },{ 3, 0, -3 },{ 1, -1, 3 },{ -3, -2, 0 },{ 2, 0, -2 },{ 0, 1, -3 },{ 1, -1, 2 },{ -4, 2, -4 },{ -1, 3, 3 },{ -3, 1, 0 },{ 0, -4, -2 },{ 3, 3, -3 },{ -2, -2, -1 },{ 2, 0, -4 },{ -4, -4, -1 },{ -1, 2, 0 },{ -2, 3, 2 },{ 1, 1, -1 } },
+		{ { -1, -3, 0 },{ -1, -1, 3 },{ 1, 0, 1 },{ 2, 1, -2 },{ -4, -4, -3 },{ -3, 0, -4 },{ -1, 0, -3 },{ -2, -3, -2 },{ 1, 3, 0 },{ -3, 1, -4 },{ -1, 1, -2 },{ -4, -3, 1 },{ 1, 2, 3 },{ 0, 0, 2 },{ -2, 0, -2 },{ -4, -4, 1 },{ -2, 3, -3 },{ 1, -3, -4 },{ -1, 0, -1 },{ 0, -3, -4 },{ 3, -2, -2 },{ -2, -1, -1 },{ -1, -2, -2 },{ 2, 1, 1 },{ -2, -3, -2 },{ 3, -1, -1 },{ -1, 3, 1 },{ 1, 0, -3 },{ 0, 1, 3 },{ 2, -3, -1 },{ 2, 3, 2 },{ -4, -4, -3 },{ -3, 0, 3 },{ -2, -2, 2 },{ 1, -4, -2 },{ -4, -3, 1 },{ 2, -1, 2 },{ -4, 1, -4 },{ 0, -4, 3 },{ -3, -2, -2 },{ 1, -3, 2 },{ -1, 2, 1 },{ 2, -2, 0 },{ 2, 1, 2 },{ 3, 3, -4 },{ -4, -3, 1 },{ 1, -4, 0 },{ -4, 3, 3 },{ -2, 2, 2 },{ 0, -3, -4 },{ -2, 3, 1 },{ -3, -4, -1 },{ 0, 2, -3 },{ -3, -3, 0 },{ 3, 0, -2 },{ 2, -3, -4 },{ -3, 1, 1 },{ 1, -3, -1 },{ 0, -1, 3 },{ -2, 1, 2 },{ 1, -1, 0 },{ -2, -4, 3 },{ -4, -1, -4 },{ 3, 0, 1 } },
+		{ { -4, 3, 2 },{ 0, 2, -4 },{ -3, 1, 3 },{ -1, -3, 0 },{ 1, -2, 0 },{ -3, 3, 2 },{ 0, -3, 1 },{ 2, -1, 3 },{ -4, -2, -1 },{ 3, 0, 3 },{ 2, -4, 2 },{ -2, 2, -3 },{ 2, -1, 0 },{ 3, -4, -4 },{ -2, -2, -1 },{ 0, -1, -1 },{ 2, 2, 2 },{ 3, 1, 3 },{ -4, -1, 0 },{ -2, 2, 1 },{ -4, 0, 3 },{ 2, 2, -4 },{ -4, 3, 2 },{ -1, -4, 0 },{ -4, -2, -4 },{ 2, 2, -1 },{ -4, -4, 0 },{ -3, -2, -2 },{ -4, -4, 0 },{ -2, 3, -4 },{ 3, 1, -2 },{ 0, -3, -4 },{ 2, -1, -1 },{ -1, 1, -4 },{ -2, 0, 0 },{ -3, -2, 3 },{ -1, 2, -1 },{ 3, -2, -3 },{ -1, 3, 0 },{ 3, 3, -1 },{ 2, -1, 3 },{ -3, -1, -1 },{ -4, 2, -3 },{ -2, -4, -2 },{ 0, 3, 3 },{ 0, -1, -1 },{ 2, 1, -4 },{ -3, -2, -2 },{ -1, -4, -2 },{ 3, 1, -3 },{ 1, 2, 1 },{ -1, -2, 3 },{ 2, 0, -1 },{ -2, -2, 2 },{ 0, 3, -3 },{ -2, -1, 3 },{ -1, 0, -2 },{ -4, 2, 2 },{ -4, -4, -3 },{ -3, 0, -2 },{ 3, 3, -3 },{ 2, -2, -4 },{ 0, 1, -2 },{ 1, -4, -1 } },
+		{ { 3, -1, -3 },{ 2, -4, -1 },{ -3, -2, 1 },{ -2, 3, -3 },{ 3, -1, 2 },{ 0, 1, -4 },{ 3, 1, -1 },{ -1, 3, -3 },{ -4, -4, -2 },{ 0, -1, 0 },{ -1, 3, 1 },{ -3, -3, -1 },{ 3, -1, -2 },{ -4, 3, 1 },{ 1, 1, 3 },{ -3, -3, -4 },{ -1, 3, 0 },{ -3, -4, -2 },{ 2, -2, -3 },{ 2, 3, 1 },{ 1, -4, -1 },{ -3, -1, 3 },{ 0, -3, 0 },{ 3, 1, -3 },{ 0, 0, 3 },{ 0, 0, 2 },{ 3, 1, -4 },{ 1, -1, 3 },{ -1, 2, -1 },{ 1, 0, 1 },{ -2, -2, 3 },{ -1, -1, 0 },{ -3, 2, -1 },{ 3, 3, 2 },{ 2, 3, -2 },{ 0, -4, 0 },{ -3, 1, -4 },{ 0, 1, 2 },{ -4, 0, 1 },{ -2, -3, -3 },{ 0, 1, -4 },{ -3, -4, -1 },{ 1, 0, 1 },{ -1, -3, -4 },{ -3, 1, 0 },{ -2, -1, -3 },{ 3, -3, 0 },{ -1, 0, 1 },{ -4, 0, 2 },{ 2, -1, 0 },{ -4, -4, -4 },{ 3, -1, 3 },{ 2, 1, -2 },{ -4, -4, 1 },{ 1, 1, -1 },{ 3, -2, 1 },{ -1, 2, 0 },{ 2, -1, -4 },{ 3, -3, 0 },{ 1, 2, 1 },{ -1, -3, 3 },{ -3, 1, 1 },{ 0, 2, 2 },{ -2, -2, -2 } },
+		{ { 1, 1, 0 },{ -4, 0, -3 },{ 3, 2, -1 },{ 1, -4, 2 },{ -1, -1, -2 },{ -4, -3, -2 },{ 1, -4, 1 },{ -2, -2, 3 },{ 2, 2, -3 },{ 1, 2, 1 },{ -2, 0, -4 },{ -3, -2, -2 },{ -1, 1, 3 },{ 0, -4, 0 },{ -3, 2, -3 },{ 2, -1, 1 },{ 0, -2, -2 },{ -2, 1, -4 },{ 0, 0, 3 },{ -3, 1, 0 },{ -1, -4, -3 },{ 3, 1, -3 },{ 1, -1, 1 },{ -2, 2, -2 },{ -3, 3, 1 },{ 1, -3, -2 },{ -2, -2, -3 },{ -1, -3, 2 },{ 2, -1, -4 },{ -3, 2, -2 },{ 3, -4, 2 },{ -4, 1, 1 },{ 1, -3, -3 },{ -1, -4, 1 },{ -4, -2, -3 },{ 3, 0, 3 },{ 1, -3, -3 },{ 2, -1, -1 },{ -2, -4, -2 },{ 1, -2, 2 },{ 2, 1, -3 },{ 0, 3, 2 },{ 3, -1, 3 },{ 3, -2, 0 },{ 1, 2, 2 },{ -4, 2, 3 },{ 0, -2, 2 },{ 1, 1, -4 },{ 3, 3, -1 },{ 0, 2, 0 },{ -2, -2, -3 },{ -1, -3, -1 },{ 1, 3, 0 },{ -3, -1, -4 },{ -1, 2, 3 },{ -4, -3, -3 },{ 1, -4, -3 },{ 0, 3, 3 },{ -2, 1, 1 },{ 0, -2, -1 },{ -1, 0, -4 },{ -4, -1, 0 },{ 2, -3, 0 },{ -3, 3, 3 } },
+		{ { -1, 0, 2 },{ -1, -2, 3 },{ -2, -3, 1 },{ 0, 1, -4 },{ -4, 3, 3 },{ 2, 2, 0 },{ -3, 0, -1 },{ -2, 0, -4 },{ 1, 1, 2 },{ -4, -3, -1 },{ 3, -3, 3 },{ 1, 2, -4 },{ 2, -1, 0 },{ -2, 0, 2 },{ 1, -2, -2 },{ -1, 0, 3 },{ 3, -3, 1 },{ -4, 3, 2 },{ 3, -3, -2 },{ -2, -2, -4 },{ 0, 0, 1 },{ -4, 3, 2 },{ 2, -3, -4 },{ -3, -2, -1 },{ 3, -4, 3 },{ -2, 1, -4 },{ 2, 3, 0 },{ -4, 2, 1 },{ 0, 1, 3 },{ 2, -4, -3 },{ 0, -2, -1 },{ -2, 3, -3 },{ 1, 0, 3 },{ 0, -1, -4 },{ -4, 1, 0 },{ -2, 2, -1 },{ 0, 3, 1 },{ -2, 2, 2 },{ 3, 0, 0 },{ -4, -1, 3 },{ -3, 2, 0 },{ -1, -3, 1 },{ -4, 0, -2 },{ -2, 3, -3 },{ 2, -4, -1 },{ -3, -1, -2 },{ 2, 3, -3 },{ -2, -3, -1 },{ -2, -4, -2 },{ -3, 2, 3 },{ 0, 0, 2 },{ -4, 1, 1 },{ -3, -4, -4 },{ 2, 0, -2 },{ 3, 3, 1 },{ -2, 0, -1 },{ -3, -1, 2 },{ 3, 1, -2 },{ -4, -4, -4 },{ -2, 2, 3 },{ 1, -4, -1 },{ 3, 3, -3 },{ -2, -1, -2 },{ 2, -4, -4 } },
+		{ { 0, 3, 1 },{ 2, -3, -2 },{ 1, 1, -1 },{ -2, 0, -3 },{ 3, -4, 0 },{ -1, -2, -3 },{ 2, 2, 3 },{ 0, -2, 1 },{ -3, -4, 0 },{ -1, -1, -2 },{ 2, 3, 2 },{ -3, -4, -3 },{ 0, 1, 1 },{ -4, -3, -4 },{ 3, 3, -3 },{ -2, 2, -1 },{ -1, -4, -1 },{ -4, 2, 0 },{ 1, -1, 2 },{ 1, 2, -1 },{ -2, -3, 0 },{ 3, 2, -2 },{ -3, 0, 3 },{ -1, -1, 2 },{ -1, 2, 0 },{ -4, -2, -3 },{ 0, -4, 1 },{ -2, 0, -1 },{ 3, 3, -2 },{ -3, -3, 0 },{ -4, 1, -4 },{ 2, 0, 0 },{ 3, -2, -2 },{ -3, 3, 2 },{ 2, -4, 3 },{ 2, -3, -2 },{ -1, -1, -4 },{ -4, -4, 1 },{ 0, -2, -3 },{ -1, 3, -1 },{ 1, -4, -4 },{ 3, -2, -2 },{ -1, -1, 2 },{ -2, 1, -4 },{ 0, -3, 1 },{ -1, -4, 2 },{ 3, 0, -4 },{ -4, -2, 1 },{ -1, -1, 3 },{ 1, -2, -4 },{ 2, -3, -2 },{ 3, 3, -1 },{ -1, -2, 2 },{ 0, -1, 2 },{ -2, -3, 0 },{ 2, -2, -3 },{ 1, -2, -2 },{ -3, 3, 2 },{ 2, -2, -1 },{ 2, -1, -3 },{ -3, 1, 2 },{ -1, -3, 3 },{ 1, 1, 1 },{ -4, -2, -1 } },
+		{ { 3, -3, -4 },{ -4, 2, -3 },{ -3, -1, 3 },{ 2, 2, 2 },{ -3, -3, -4 },{ 0, -1, 1 },{ -2, 1, -2 },{ 1, -3, -2 },{ 3, 3, -4 },{ 0, 1, 1 },{ -1, 0, -1 },{ -4, -3, 0 },{ 3, 2, 3 },{ 0, -2, -2 },{ -4, -4, 0 },{ 1, -1, 3 },{ 2, 1, -4 },{ 0, -1, -3 },{ -3, 3, -3 },{ 2, -2, 3 },{ -4, 0, 1 },{ 0, 1, -3 },{ 0, -4, -1 },{ 2, 3, -4 },{ 1, -3, -2 },{ 1, 1, -1 },{ 3, 0, 3 },{ -4, -2, -4 },{ 1, -1, 2 },{ -1, -3, 1 },{ -1, 2, 3 },{ 0, -1, 1 },{ -3, -4, -2 },{ -2, 2, -1 },{ -1, 0, -4 },{ 1, 1, 1 },{ -3, -2, -2 },{ 2, -3, 3 },{ 3, 2, -4 },{ -2, 1, 3 },{ 2, 0, 1 },{ -3, 3, -1 },{ 1, -3, 0 },{ -4, 0, 3 },{ 2, 3, -1 },{ 0, -1, 0 },{ -3, 2, -2 },{ 3, 1, 0 },{ 1, 3, -3 },{ -4, 0, 0 },{ -2, -4, 1 },{ 1, -1, 3 },{ 2, 1, -3 },{ -4, 1, 0 },{ 1, 2, -4 },{ -4, 2, 3 },{ -1, -4, 1 },{ 0, 0, 0 },{ -1, -3, -4 },{ -1, 0, 1 },{ 0, 3, 0 },{ -4, -4, -4 },{ 2, 2, -2 },{ -3, 0, 0 } },
+		{ { -2, -1, 3 },{ 1, -4, 0 },{ -1, 3, -1 },{ 0, -1, -2 },{ 2, 3, 1 },{ -3, -4, 2 },{ -4, 3, -1 },{ 3, -1, -3 },{ -4, 0, 3 },{ -2, -2, 0 },{ -3, -1, -3 },{ 2, -2, -4 },{ -2, -1, -1 },{ -1, 0, 3 },{ -1, 3, 2 },{ -3, -2, -3 },{ 1, 1, 2 },{ -3, -4, 1 },{ -1, 0, 0 },{ 3, -4, -4 },{ -3, -2, -2 },{ -1, -3, 0 },{ -2, -1, -2 },{ -4, 0, 3 },{ 3, 2, 1 },{ -3, -3, 2 },{ -3, 3, -2 },{ 2, -4, -3 },{ -2, -1, 0 },{ 1, 3, -2 },{ -2, 0, 2 },{ 3, 1, -4 },{ -1, -2, 3 },{ 1, -3, 1 },{ 3, -1, -3 },{ 0, 3, -1 },{ -3, 1, 2 },{ -1, 0, 0 },{ 1, 3, 0 },{ -3, -3, -2 },{ -4, -1, -3 },{ 0, -4, 3 },{ -1, 1, -3 },{ 3, 2, 1 },{ 1, -2, -4 },{ -2, 1, 2 },{ -3, 0, 3 },{ -1, -2, -1 },{ 2, -4, 2 },{ 3, 1, -2 },{ -3, 2, -4 },{ -3, -2, 0 },{ -1, 3, -2 },{ 0, -3, -1 },{ -3, -4, 1 },{ 0, 0, -2 },{ 3, 3, -3 },{ -2, 1, 3 },{ 3, 2, 2 },{ -4, -1, -2 },{ 1, 1, 0 },{ -2, -2, -2 },{ 3, -2, 2 },{ 0, 3, -3 } },
+		{ { -1, 1, 0 },{ 2, 1, -3 },{ 3, -4, 2 },{ -4, -2, -1 },{ -1, -2, -4 },{ 1, 0, 3 },{ -2, 1, 0 },{ -1, -3, 2 },{ 2, 2, -1 },{ 0, -4, 2 },{ 1, 3, -2 },{ 3, 2, 2 },{ 1, 1, 1 },{ -3, -3, -4 },{ 2, 1, -2 },{ 3, -2, -1 },{ -2, 3, 1 },{ 2, -3, 3 },{ -2, 0, -2 },{ 0, 1, 2 },{ 1, 2, 1 },{ 3, 3, 2 },{ 1, 1, -3 },{ -3, -4, 0 },{ -1, -2, -1 },{ 0, -1, -4 },{ 0, 2, 1 },{ -1, 1, 0 },{ 3, 1, 2 },{ -4, -2, -4 },{ 2, -3, -1 },{ -3, -4, -1 },{ 0, 3, -3 },{ -4, 2, 2 },{ -4, -1, 0 },{ -2, -3, 1 },{ 2, -4, -1 },{ 3, 2, -4 },{ -4, -1, -2 },{ -1, -2, 2 },{ 3, 0, 1 },{ 2, 2, -4 },{ -2, 0, -1 },{ -3, -4, 2 },{ -2, -2, -3 },{ -4, -3, 0 },{ 2, -4, -2 },{ 0, 3, -4 },{ -2, -3, 1 },{ -1, 0, -1 },{ 0, -1, 2 },{ -2, -4, -3 },{ 3, 0, 2 },{ -2, -1, 3 },{ 3, -2, -4 },{ -1, -1, -1 },{ 1, 1, 1 },{ -4, -2, -3 },{ 2, -3, -1 },{ -3, -4, -3 },{ 3, 2, 3 },{ 1, -1, -1 },{ -1, -3, 1 },{ -4, 0, 2 } },
+		{ { -3, -3, -2 },{ -3, -2, 1 },{ 0, 0, 3 },{ -2, 1, -3 },{ 2, -3, -2 },{ 3, 2, 1 },{ -3, -4, -3 },{ 1, 0, 0 },{ -1, -2, -4 },{ -3, 1, -3 },{ -3, -4, 3 },{ -1, -3, -2 },{ -4, 0, 1 },{ 2, 3, 0 },{ -2, -4, -3 },{ 0, -1, -4 },{ -4, 2, -1 },{ 1, -1, -2 },{ -4, 3, -3 },{ 2, -4, -1 },{ -4, -1, -4 },{ -1, -1, -1 },{ -2, -2, 3 },{ 3, 2, -3 },{ 2, 3, 2 },{ -4, -3, 3 },{ -2, 0, -1 },{ 2, -4, -3 },{ -4, -3, 3 },{ 0, 3, -2 },{ 1, -1, 1 },{ -2, 0, 0 },{ 2, 1, -4 },{ 3, -3, -2 },{ 0, 0, 3 },{ 1, 2, -4 },{ -1, -2, -3 },{ 0, 3, 3 },{ 0, -4, 2 },{ -2, 1, -1 },{ 1, 3, -2 },{ -4, -3, 2 },{ 0, -2, 0 },{ 1, -1, -2 },{ 2, 1, 1 },{ 3, 3, -4 },{ 0, -1, 3 },{ 1, 2, -3 },{ -3, -2, 1 },{ -4, 2, -2 },{ 2, 3, 3 },{ 2, -2, 0 },{ 1, 1, 1 },{ -4, 2, -3 },{ 2, 3, 2 },{ -3, -3, 3 },{ 1, -4, 0 },{ -2, -1, -2 },{ 0, 3, 2 },{ -1, -3, -4 },{ -2, 1, 2 },{ -3, 3, -4 },{ 0, -4, -1 },{ 2, 2, -4 } },
+		{ { 1, 3, -3 },{ 3, -1, 2 },{ -1, 2, -4 },{ -4, 3, 0 },{ 0, 0, 2 },{ -3, -1, -4 },{ 0, 2, -2 },{ 2, 3, 2 },{ -4, -3, -2 },{ 1, -1, 1 },{ 3, 0, 0 },{ 0, 2, -4 },{ 0, -2, -1 },{ -1, -4, 2 },{ -4, -1, 2 },{ 2, 0, 3 },{ -1, -3, 0 },{ 3, 1, -4 },{ 0, -2, 2 },{ -2, 2, 3 },{ -3, -3, 0 },{ 2, -3, -3 },{ 0, 1, 1 },{ -1, -4, 0 },{ 1, 0, -4 },{ 3, -3, -2 },{ 1, -1, 2 },{ -3, 3, -4 },{ 0, -2, 1 },{ -1, 2, -3 },{ 3, 2, 3 },{ -3, -1, 2 },{ -1, 1, 0 },{ 1, -4, 2 },{ -2, -1, -2 },{ -3, -3, 2 },{ 2, 1, -1 },{ -4, -1, 1 },{ -3, 0, -3 },{ 2, -2, -4 },{ -2, 1, 3 },{ -1, -4, 0 },{ 3, 0, -4 },{ -3, 3, 3 },{ -1, 2, -1 },{ 0, 0, 2 },{ -4, -3, -1 },{ -2, 0, 3 },{ 3, -4, 0 },{ 0, -1, 2 },{ 0, -3, -3 },{ -2, -4, -4 },{ -4, 2, -2 },{ 0, -3, -1 },{ -2, 0, 0 },{ -1, 1, -2 },{ 2, 3, -4 },{ -4, 0, 3 },{ -1, 2, 0 },{ 3, 0, 1 },{ -4, -1, 0 },{ 1, 2, -2 },{ 3, 0, 3 },{ -2, -2, 1 } },
+		{ { 3, -4, -1 },{ -1, -1, -1 },{ -2, -3, -2 },{ 1, -4, 3 },{ 3, -2, -1 },{ 1, -2, 3 },{ -2, -4, 1 },{ -2, 0, 3 },{ 3, 3, -1 },{ -1, 2, 2 },{ -2, -1, -3 },{ 2, 3, 3 },{ -3, -3, -2 },{ 1, 1, -3 },{ 1, 2, -1 },{ -3, 3, 0 },{ -1, -3, -2 },{ -2, -4, 1 },{ -3, -1, 0 },{ 3, 1, -2 },{ 1, 0, 1 },{ -2, 3, -4 },{ -4, 0, -1 },{ -4, -2, 2 },{ -3, 2, 0 },{ -2, 1, -2 },{ -1, 3, 1 },{ 2, 0, 0 },{ -3, -4, 0 },{ 1, 0, -1 },{ -4, -3, -2 },{ 2, -3, -4 },{ 0, -2, -1 },{ -4, 2, -3 },{ 3, 2, -3 },{ -3, 3, 0 },{ 3, 0, -4 },{ -2, -3, 1 },{ 2, -4, 0 },{ 3, 2, -1 },{ -1, -1, 1 },{ -4, 2, -3 },{ 2, -4, -2 },{ 2, -1, 2 },{ -2, -3, -3 },{ -3, -4, 1 },{ 2, -1, 0 },{ -2, 1, -3 },{ 2, 3, -4 },{ -4, 2, -1 },{ 3, 0, -2 },{ -3, 1, 2 },{ -1, -3, 3 },{ 3, -2, -4 },{ 3, 0, 1 },{ 0, -4, -3 },{ -3, -1, 1 },{ 3, -2, -2 },{ 0, -4, -1 },{ 2, -2, -3 },{ -3, -3, 1 },{ 2, -4, -2 },{ -2, -2, 0 },{ -4, 1, 3 } },
+		{ { 0, -3, 0 },{ -4, 2, -3 },{ 2, 1, 1 },{ -3, 1, 1 },{ -4, 2, -3 },{ -1, 3, -2 },{ -4, 1, -4 },{ 1, -1, -1 },{ 0, -2, -4 },{ -4, -4, 0 },{ -3, -2, -2 },{ 3, -4, 1 },{ -4, 0, -4 },{ 3, 1, 1 },{ -2, -2, 1 },{ 3, -1, -4 },{ 1, 0, 3 },{ 1, 2, 2 },{ 2, -2, -3 },{ -1, 2, -4 },{ 0, -3, 3 },{ 3, -4, -2 },{ 1, -1, 3 },{ 2, 3, -3 },{ 3, -2, -3 },{ 0, -4, 3 },{ -4, -1, -4 },{ 3, -2, 2 },{ 1, 1, -1 },{ -2, -1, -4 },{ -1, 1, 2 },{ -4, -4, 1 },{ -2, 3, 0 },{ 2, 0, 3 },{ -1, -4, 1 },{ -1, -2, 3 },{ 0, -1, -2 },{ 1, 2, 3 },{ -1, 3, -2 },{ -3, -3, 2 },{ 1, -2, -3 },{ 0, 3, 1 },{ -3, 1, 3 },{ -2, -2, 0 },{ -4, -2, -4 },{ 3, 3, -3 },{ 1, 2, 2 },{ -1, 1, -2 },{ -1, -3, 3 },{ 1, -2, 1 },{ -2, 0, 0 },{ 2, 1, -1 },{ -3, 3, 1 },{ 1, -1, -3 },{ -2, -4, 3 },{ -4, 2, 0 },{ 1, -1, 2 },{ -2, 1, -4 },{ -3, 3, 3 },{ 1, 2, -2 },{ -2, -1, 3 },{ 0, 3, -4 },{ -1, 0, -3 },{ 1, 3, -4 } },
+		{ { -2, -1, 3 },{ 0, 3, -3 },{ -3, -2, 2 },{ 2, 0, -4 },{ -1, -1, -1 },{ 3, -3, 0 },{ 2, -4, 1 },{ -3, 1, -3 },{ 2, -1, 2 },{ 0, 1, -3 },{ 1, 1, 2 },{ -1, 3, 3 },{ 1, -1, 0 },{ -2, -3, -1 },{ -3, -4, 3 },{ 0, 3, -3 },{ -4, 1, -2 },{ 0, 0, -1 },{ -4, -4, -3 },{ -2, 3, 0 },{ -4, -1, 2 },{ -3, 2, 0 },{ -1, -2, -1 },{ -1, 1, 1 },{ -2, -3, 1 },{ 1, 0, -1 },{ 0, 2, -3 },{ -4, -3, 2 },{ 0, 2, -3 },{ 2, 0, 3 },{ 3, 3, 1 },{ 1, -2, -2 },{ 0, 2, -4 },{ -3, 1, -3 },{ 1, -2, 0 },{ -3, 1, -1 },{ 1, -4, 2 },{ -4, 1, -3 },{ 0, -2, -4 },{ -4, 1, 3 },{ 1, 0, -1 },{ 3, -3, -4 },{ -1, -1, 0 },{ 0, 1, -2 },{ 1, 3, -1 },{ 0, 0, 3 },{ 2, -3, -2 },{ -4, -2, 0 },{ 0, -4, -1 },{ -3, 3, -3 },{ 1, -2, -4 },{ -1, -4, 3 },{ 0, -1, -2 },{ 2, 2, -1 },{ -3, 1, 2 },{ 0, 3, -2 },{ 2, -3, -1 },{ -2, 2, 2 },{ 3, -3, 0 },{ -1, 1, -4 },{ -4, 1, 0 },{ 3, -4, 2 },{ -3, 2, 1 },{ -3, -3, 2 } },
+		{ { 1, 1, -2 },{ -1, -4, 0 },{ 3, -2, -1 },{ 0, -4, 2 },{ 1, 3, -3 },{ 0, 2, 2 },{ -2, 0, 2 },{ -3, -3, 3 },{ -1, 3, -1 },{ 3, -3, 1 },{ -2, 0, -4 },{ 0, -4, -2 },{ -4, 2, 2 },{ 2, 3, -3 },{ 0, 1, 0 },{ -3, -1, -2 },{ 2, -2, 1 },{ -2, -3, 3 },{ 3, 1, 1 },{ -1, -2, -1 },{ 1, 0, 2 },{ 3, 0, -3 },{ 0, 1, -4 },{ 2, -4, 0 },{ -3, -1, 3 },{ 3, 3, -2 },{ -2, 1, -1 },{ -3, -2, 0 },{ -1, -4, -2 },{ -3, -2, 1 },{ -3, -4, -3 },{ -2, 0, 0 },{ -1, -1, 2 },{ 3, -3, 2 },{ 0, 3, -4 },{ -4, -1, -1 },{ 2, -3, -2 },{ 3, 2, 1 },{ -2, 0, 0 },{ 2, -4, 1 },{ -2, 1, -2 },{ -3, -4, 2 },{ -4, 2, -3 },{ 2, -3, 3 },{ -1, 0, -1 },{ -3, -4, 1 },{ -3, -1, -4 },{ -2, 2, 0 },{ 3, 1, 3 },{ 2, -1, 2 },{ -4, -3, -3 },{ 3, 3, 1 },{ -4, -3, -2 },{ -1, -2, -4 },{ -2, 0, 0 },{ 3, -3, -4 },{ 1, -1, -2 },{ -1, -2, 0 },{ -4, -4, -3 },{ 2, 0, 1 },{ 1, -2, -1 },{ -1, -1, -1 },{ 3, -2, -3 },{ 2, 0, -2 } },
+		{ { -2, 2, 1 },{ 2, -1, -4 },{ -3, 3, 0 },{ -4, -3, 3 },{ -2, -1, -2 },{ -4, 0, 0 },{ 3, -2, -3 },{ 1, 3, -4 },{ 0, -1, -2 },{ -2, 2, 0 },{ -4, 0, -1 },{ -3, -1, -2 },{ 3, -3, 1 },{ -1, -2, -4 },{ 1, 0, 2 },{ 2, -4, -1 },{ -1, 3, 2 },{ 1, 2, -4 },{ -3, -1, 0 },{ 2, -4, -2 },{ 1, 3, -4 },{ -2, -3, 3 },{ -4, -2, -1 },{ -1, 3, -2 },{ -4, 0, -4 },{ -1, -4, 2 },{ 2, -1, -4 },{ -1, 1, 1 },{ 2, 3, 3 },{ 1, -1, -1 },{ 2, 3, -4 },{ 3, -3, -1 },{ -4, 1, 3 },{ 2, -4, -2 },{ -2, 0, 1 },{ -1, 2, -4 },{ -3, 3, 2 },{ -2, -1, -1 },{ 2, 0, -1 },{ -1, -2, -3 },{ 0, 3, 3 },{ 1, 3, 0 },{ 3, -1, -4 },{ -1, -2, 1 },{ -2, 2, -4 },{ 3, 1, 1 },{ 2, -2, 2 },{ 0, 3, -3 },{ -1, 0, -4 },{ -2, 2, 2 },{ 0, 0, -1 },{ -2, 2, 0 },{ -3, 1, 3 },{ 3, -4, 1 },{ 2, 2, 2 },{ -4, -4, -3 },{ 0, 0, 3 },{ -3, 3, 1 },{ 3, -2, 3 },{ -2, 3, -3 },{ 1, 0, 2 },{ -3, 2, 0 },{ 0, 1, 3 },{ -4, -4, -1 } },
+		{ { 1, -3, 3 },{ -3, 0, 2 },{ 0, 1, -3 },{ 2, 0, -1 },{ 3, 2, -4 },{ -1, -4, 1 },{ -2, 1, -2 },{ 2, -3, 0 },{ -4, -2, 1 },{ 1, -4, 3 },{ 3, -2, -3 },{ 2, 1, 3 },{ 0, -3, -1 },{ -3, 2, 0 },{ -2, 0, 3 },{ -4, 1, -3 },{ 3, -3, -4 },{ -3, -2, 0 },{ -1, -1, -2 },{ -4, 3, 3 },{ 2, 0, -1 },{ -2, -3, 0 },{ 3, 1, 2 },{ 1, 2, 1 },{ 2, -3, 3 },{ -3, 3, 0 },{ 1, 0, 2 },{ 3, -3, -3 },{ -4, 2, -4 },{ -1, -1, 0 },{ -4, 1, 3 },{ 0, -2, -3 },{ 0, 2, 0 },{ -4, 3, -1 },{ 1, -2, 0 },{ 3, -3, 3 },{ 0, -2, -3 },{ 1, -4, 1 },{ -3, 2, 3 },{ 3, -3, -4 },{ -4, 1, -2 },{ -3, -1, 2 },{ 2, 0, -1 },{ -3, -3, 0 },{ 0, -4, 3 },{ 0, 0, -2 },{ -4, -3, -1 },{ 1, -3, 0 },{ -3, -4, 1 },{ 2, -2, -2 },{ 1, -4, -1 },{ 2, -2, -4 },{ 1, 0, 2 },{ 0, 3, -3 },{ -2, -1, 0 },{ -1, 2, -1 },{ -3, 1, 2 },{ -1, 1, -4 },{ 0, -4, -1 },{ -3, 2, -2 },{ -4, -3, -4 },{ 2, -4, -4 },{ -2, -2, 0 },{ -1, 3, -3 } },
+		{ { -4, -2, -4 },{ 3, -4, -1 },{ -2, 2, 3 },{ 1, -2, -2 },{ -4, 3, 1 },{ -1, -1, 3 },{ 1, -4, -1 },{ 0, 2, -3 },{ -3, 2, 2 },{ -1, 0, -4 },{ 1, 2, 0 },{ -2, 3, 2 },{ -1, -1, -4 },{ 3, 2, -1 },{ -2, -4, -2 },{ 0, -2, 1 },{ 0, 3, -1 },{ -2, 1, 3 },{ 3, -4, 2 },{ 0, 2, -3 },{ -1, -2, 1 },{ -3, -1, -2 },{ 0, 2, -4 },{ -2, -1, -3 },{ 3, -4, -1 },{ 0, -2, -3 },{ -4, 1, -1 },{ 1, -4, 1 },{ -2, -3, -2 },{ 2, 0, 2 },{ -2, -4, 1 },{ -2, -3, 2 },{ 1, 0, -2 },{ -3, -1, -4 },{ -2, -4, 1 },{ 2, 1, 2 },{ -4, 0, -2 },{ 0, 3, -4 },{ -4, -2, 2 },{ 0, -1, 0 },{ -1, -4, -2 },{ 3, -3, 1 },{ -2, 1, 2 },{ 1, 3, -2 },{ -4, -1, -3 },{ 2, 3, -2 },{ -1, 1, 2 },{ -2, 0, -4 },{ 3, 1, -2 },{ -4, 3, 3 },{ -2, 2, 1 },{ -4, 1, -3 },{ -1, -3, -1 },{ -3, -1, -2 },{ 1, 1, 3 },{ 3, -2, -4 },{ 2, -3, -2 },{ 2, -1, 1 },{ 1, -3, 0 },{ 3, 1, 3 },{ -1, -1, 2 },{ 0, 3, 1 },{ 1, -1, 2 },{ 3, 1, -2 } },
+		{ { 2, 3, 0 },{ -2, -1, 1 },{ 0, -1, -3 },{ -1, -3, 0 },{ 2, -2, -4 },{ -3, 1, 2 },{ 3, 3, -2 },{ -4, 0, 3 },{ 2, 1, 2 },{ 3, -3, -1 },{ -3, -4, -2 },{ -4, 1, -3 },{ 2, 0, 3 },{ 1, -3, 1 },{ -4, -1, -4 },{ 1, 2, 3 },{ 2, -2, -3 },{ -3, 0, -1 },{ 1, 1, -3 },{ 2, -3, 1 },{ -3, 3, -4 },{ 3, -4, 2 },{ 0, -3, 0 },{ -3, 1, 1 },{ -4, -2, 3 },{ -2, 0, -2 },{ -1, 2, -1 },{ -3, 3, 3 },{ 0, -1, -2 },{ 3, 2, -4 },{ -1, 2, -2 },{ 1, 3, 0 },{ 3, -2, -3 },{ 3, 0, 3 },{ 0, 2, -2 },{ -1, 2, -3 },{ 2, -3, 0 },{ -2, 1, -2 },{ 3, 2, -1 },{ 1, 0, 1 },{ -2, 3, -4 },{ -4, 2, 3 },{ 0, -2, -4 },{ 3, 2, -3 },{ -2, 0, 3 },{ 1, -2, 1 },{ -3, -4, 3 },{ -3, 2, 0 },{ 0, -2, -3 },{ 2, -1, 3 },{ -1, -1, 0 },{ 3, -3, -4 },{ 2, 3, 2 },{ -4, 0, 1 },{ 1, -4, -1 },{ -2, -2, -2 },{ -4, 3, 1 },{ -2, 0, -3 },{ -4, 3, -3 },{ -1, -2, 1 },{ 3, 0, -2 },{ -4, 2, -3 },{ -3, -4, -1 },{ -1, 0, 2 } },
+		{ { 0, -3, 1 },{ -4, 3, -2 },{ 2, -4, -4 },{ -3, 2, 3 },{ 1, -2, 1 },{ 0, 0, -1 },{ -2, -3, -4 },{ -2, -3, 0 },{ -1, -1, -4 },{ 0, 3, -2 },{ 2, -2, 1 },{ -4, -2, 1 },{ -1, -4, 0 },{ -3, 3, -3 },{ 3, 1, 0 },{ -3, -1, 2 },{ -1, 0, 0 },{ -4, -3, 0 },{ 0, -4, 2 },{ -2, 2, -2 },{ -4, -1, -1 },{ 2, 0, 3 },{ 1, 2, -2 },{ -1, 0, 2 },{ 2, 3, -4 },{ 2, -3, 0 },{ 3, -1, -4 },{ 0, 1, 2 },{ -3, -4, 0 },{ 2, -2, 2 },{ -4, -3, -1 },{ -3, 1, -4 },{ -1, -2, 3 },{ -2, -4, 1 },{ -4, 3, -1 },{ 2, -1, -4 },{ -3, -3, 3 },{ -2, -2, 1 },{ 2, -4, 3 },{ -3, 0, -3 },{ -1, -2, -1 },{ 1, 1, -1 },{ 2, -4, 2 },{ -4, -4, 0 },{ -1, 1, 0 },{ 3, -3, -1 },{ 2, -1, -4 },{ 2, 3, -1 },{ 1, -3, 2 },{ -1, 0, -1 },{ -3, -4, -2 },{ 0, -2, 0 },{ -2, 1, 3 },{ -1, -3, -2 },{ 2, 2, -3 },{ -1, 2, 2 },{ 0, -3, 0 },{ 1, -1, 3 },{ 2, -4, 2 },{ -3, 2, -2 },{ -2, -3, -1 },{ 2, -2, 0 },{ -2, 0, 3 },{ 1, -3, -4 } },
+		{ { 0, -2, 3 },{ -2, 1, 2 },{ 3, 0, 2 },{ -2, 3, -1 },{ -4, 1, -3 },{ 3, -4, -2 },{ 2, 2, 1 },{ 1, -2, -1 },{ -3, -1, 1 },{ 0, 1, 3 },{ -2, 2, -1 },{ 1, 0, -4 },{ 0, -2, 3 },{ 0, 1, -2 },{ 2, -3, -2 },{ -1, -4, 2 },{ 0, 2, -4 },{ 1, 3, -2 },{ 3, -1, 3 },{ -1, -2, 0 },{ 1, 1, 1 },{ -2, -2, -4 },{ -4, 3, -1 },{ -1, -4, -3 },{ -3, -2, 1 },{ 1, 2, 2 },{ -2, -3, 3 },{ -4, -1, -3 },{ 1, 1, -3 },{ -2, 3, 0 },{ 0, -1, 3 },{ 2, 0, 1 },{ 0, 3, 0 },{ -4, -3, -2 },{ 1, 1, 2 },{ -1, -1, 1 },{ 1, 0, -1 },{ -1, 3, 0 },{ 0, -1, -4 },{ 2, 1, -2 },{ -3, -3, 3 },{ 2, -1, 1 },{ -3, -1, -3 },{ -1, -3, -2 },{ 0, 3, -4 },{ -3, 0, 2 },{ -4, 2, -2 },{ 0, -3, -3 },{ -2, 2, 1 },{ -4, 0, -4 },{ 1, 3, 2 },{ 0, 2, -3 },{ 3, 0, 1 },{ -4, -4, -4 },{ 0, -1, 2 },{ -3, 0, 1 },{ 3, 1, -4 },{ -3, 2, -1 },{ -1, 0, 0 },{ 0, -2, -4 },{ -2, 1, -4 },{ 1, 3, 3 },{ 3, 2, -3 },{ -4, 2, -2 } },
+		{ { -3, 1, -3 },{ 2, 0, -3 },{ 1, -3, -2 },{ -1, -2, 0 },{ -1, -1, 3 },{ -4, 2, 2 },{ 0, 0, 3 },{ -3, 3, -3 },{ 3, -4, -3 },{ -4, -3, 2 },{ 3, 3, -3 },{ -2, -1, 0 },{ 3, 2, 2 },{ -2, 0, -1 },{ -3, 3, -4 },{ -4, -2, 1 },{ 3, -1, -1 },{ -2, -3, -4 },{ -4, 2, 3 },{ 3, 0, -3 },{ -3, -4, -2 },{ 0, -3, 2 },{ 3, -1, 3 },{ 2, -1, 0 },{ 0, 1, -1 },{ -4, 2, -3 },{ 2, -2, -2 },{ -1, 0, 1 },{ 3, -4, -1 },{ 1, -2, -4 },{ -4, 1, 2 },{ -3, -4, -3 },{ 2, 2, -3 },{ 3, -3, -1 },{ -2, 0, -4 },{ -3, -2, 0 },{ 3, -4, -3 },{ 1, 2, -3 },{ -4, 2, 2 },{ 3, -4, 1 },{ -1, 3, -2 },{ 0, 0, 0 },{ -2, 3, 1 },{ 3, 2, 3 },{ -3, 0, -1 },{ 1, -2, 1 },{ -1, -1, 3 },{ -1, -4, 0 },{ 3, 1, 3 },{ -2, -2, -2 },{ 3, -3, -1 },{ -4, 1, 3 },{ 1, -2, 0 },{ -3, -1, -1 },{ 3, 3, 3 },{ 1, -4, -3 },{ 2, -2, -2 },{ -4, -4, -1 },{ 3, -1, 3 },{ 2, 2, 1 },{ -4, -4, 2 },{ 0, -3, -1 },{ 3, -1, 1 },{ -1, -4, -1 } },
+		{ { 1, -1, 1 },{ -4, 3, 0 },{ 2, -1, -1 },{ -3, -4, -4 },{ 1, 3, -3 },{ 2, -3, 0 },{ -1, -2, -2 },{ -3, 1, -4 },{ 1, 0, 2 },{ -1, 1, -2 },{ -3, -4, 0 },{ 1, -4, -3 },{ -4, -3, -2 },{ -1, 1, 1 },{ 2, -3, 3 },{ 1, 2, 2 },{ -2, 1, -1 },{ -3, -4, -2 },{ 2, 0, 2 },{ 1, 3, -3 },{ 0, -3, 1 },{ -2, 1, -4 },{ -1, 2, -2 },{ -3, 0, -3 },{ -3, -3, 2 },{ 3, 3, 0 },{ 0, -4, -2 },{ -3, 1, 3 },{ -2, 3, 1 },{ -1, 2, -2 },{ 3, -3, -1 },{ -2, 0, 1 },{ 0, -1, 3 },{ -3, -2, -2 },{ 0, 3, -3 },{ 3, 2, 3 },{ -2, -3, 2 },{ -4, 0, -2 },{ -2, -2, 1 },{ 0, -3, 3 },{ -2, 0, -4 },{ -4, 2, -4 },{ 2, -4, -2 },{ 1, -2, 2 },{ -2, -3, -3 },{ 2, 1, -4 },{ 3, 2, 1 },{ -4, 0, -3 },{ 1, -2, 2 },{ 1, 3, 1 },{ -3, -1, 0 },{ -1, -4, -3 },{ 2, 2, -2 },{ -1, 3, -4 },{ -2, -2, -1 },{ -4, 1, 0 },{ -1, -3, 1 },{ -2, 3, -3 },{ 0, -2, 3 },{ 1, 3, -2 },{ -1, -1, -2 },{ -4, 0, 2 },{ -3, 1, -4 },{ -2, -3, 0 } },
+		{ { 3, -2, -2 },{ -2, 2, 3 },{ 0, -4, 2 },{ 3, 2, 1 },{ -3, 1, 1 },{ -2, -1, -4 },{ 0, -4, 2 },{ 2, -2, -1 },{ -1, 3, 1 },{ 2, -1, -1 },{ 0, 0, 3 },{ -4, 3, -4 },{ 2, -2, 2 },{ -1, 2, 0 },{ 2, -4, -3 },{ 0, -1, -3 },{ 0, 0, 0 },{ -1, 2, 1 },{ 1, -2, 1 },{ -1, 1, -1 },{ -4, 2, -1 },{ 2, -2, 2 },{ 1, 3, 0 },{ -1, 0, 1 },{ 1, -4, -4 },{ 1, 2, 3 },{ -2, -1, 1 },{ 0, -3, -4 },{ 2, -2, 0 },{ -4, 0, 2 },{ 1, -4, -4 },{ 3, 3, -1 },{ -1, 1, 2 },{ -1, -3, 1 },{ 2, -1, 0 },{ -4, 1, 3 },{ 0, -4, -1 },{ 2, 1, -4 },{ 2, 3, -1 },{ -3, -1, -3 },{ 3, -4, 0 },{ 1, -2, 2 },{ -1, -1, -1 },{ -4, 1, 0 },{ -1, -4, -2 },{ 1, 3, 0 },{ -2, -3, -2 },{ 0, -1, -1 },{ -3, 3, -3 },{ 2, -4, -4 },{ -4, 2, 0 },{ -2, 0, 3 },{ 3, -3, 1 },{ 1, -3, 2 },{ -3, 1, 2 },{ 0, 2, -4 },{ 3, -1, 0 },{ -2, 0, 2 },{ -4, 1, -4 },{ -3, -3, 0 },{ 3, -2, 1 },{ 1, 3, -3 },{ 1, -2, 3 },{ 2, 2, -2 } },
+		{ { -1, -3, -4 },{ -4, 0, 1 },{ -2, 3, -4 },{ -1, 0, -2 },{ 1, -2, -1 },{ 3, 0, 3 },{ -4, 2, 0 },{ 3, -1, -2 },{ -4, 1, 2 },{ -2, -3, -4 },{ 3, 2, 1 },{ 1, -1, -1 },{ -2, 1, 1 },{ -3, -1, -3 },{ -3, 0, 0 },{ 3, -3, -2 },{ -4, 3, 3 },{ 2, -4, -4 },{ -4, -2, -3 },{ -3, -1, 3 },{ 3, -1, -4 },{ -2, -4, 3 },{ 3, -3, -3 },{ -4, 1, -2 },{ -2, -2, -1 },{ 3, -1, -4 },{ -4, 0, 2 },{ -1, 3, -3 },{ 2, -3, -1 },{ -3, 1, -3 },{ 0, -1, 3 },{ -3, -2, 0 },{ -4, 2, -3 },{ 1, 2, -4 },{ 1, -4, -4 },{ -2, 3, -1 },{ -1, -1, -2 },{ -3, -2, 2 },{ 1, -2, 0 },{ 0, 2, 2 },{ -3, 1, -1 },{ 2, 2, -2 },{ -3, -3, 3 },{ 3, 3, -4 },{ 0, 0, 2 },{ -4, -1, 3 },{ -3, -4, 1 },{ 2, 1, 3 },{ -1, -3, -1 },{ 2, 1, 1 },{ 0, -2, -4 },{ 0, 1, -2 },{ -2, -2, -1 },{ -4, 0, -3 },{ -1, -1, -2 },{ 2, -4, 3 },{ 1, 3, -2 },{ 0, -3, -3 },{ 1, -4, 2 },{ 2, 1, -1 },{ -2, 2, -3 },{ -1, -4, 0 },{ -3, 0, -1 },{ 0, 1, 2 } },
+		{ { 2, 1, 3 },{ 0, -2, -1 },{ 3, -3, -3 },{ -3, -1, 3 },{ 2, -3, -2 },{ 0, 3, -3 },{ -2, -3, 0 },{ 1, 3, -4 },{ -2, -4, 3 },{ 0, -2, 0 },{ -3, 1, -3 },{ -1, -2, 3 },{ 3, 2, -1 },{ 0, -4, -4 },{ -4, 3, 2 },{ -1, -2, -1 },{ -2, 1, 1 },{ 3, -1, 2 },{ 0, 3, 0 },{ -2, -3, -2 },{ 1, 3, 0 },{ -3, 0, -2 },{ 2, -1, 1 },{ 0, -4, 3 },{ -1, 2, 2 },{ 0, -3, 1 },{ -3, 1, -2 },{ 3, -4, -1 },{ -2, 2, 2 },{ 1, 0, 1 },{ 1, 3, -4 },{ -2, -3, -2 },{ 2, -4, -1 },{ 3, 0, 3 },{ -4, -2, 0 },{ -2, -1, 1 },{ 3, 2, 1 },{ 3, 0, -4 },{ -1, -4, -3 },{ -4, 1, 3 },{ -2, -1, 1 },{ 1, 3, -3 },{ -2, -2, 1 },{ 0, 0, -3 },{ -2, -1, 1 },{ 3, 3, -3 },{ -2, -2, -4 },{ 3, 0, 0 },{ -4, 3, -3 },{ -2, -1, 2 },{ 3, -1, 3 },{ -3, -4, 2 },{ 2, 3, 0 },{ 1, 3, 1 },{ 0, -4, -2 },{ -3, 1, 1 },{ -4, -1, 1 },{ -1, 0, -1 },{ 2, 2, 0 },{ -3, -2, 1 },{ 0, -1, 3 },{ -1, -3, 2 },{ 3, 3, -4 },{ -4, -4, -2 } },
+		{ { -3, 0, -3 },{ -1, 3, 0 },{ 1, -4, 2 },{ -1, 2, 2 },{ -4, -1, 0 },{ -1, 2, 1 },{ -3, -4, 2 },{ 0, 0, -2 },{ 2, 1, -3 },{ -3, -1, 1 },{ 2, 3, -2 },{ -4, -4, -2 },{ -2, -2, 2 },{ 2, -3, 3 },{ 1, 1, -2 },{ -2, -1, 3 },{ 2, 2, -3 },{ 1, -4, -4 },{ -3, 0, -1 },{ 2, 1, 3 },{ 0, -4, 2 },{ -1, 2, -1 },{ -3, -2, -4 },{ 0, 3, 0 },{ -4, 2, -2 },{ 2, 0, -3 },{ 2, 3, 3 },{ 0, -2, 0 },{ -4, -1, -2 },{ -2, -3, -1 },{ 3, 1, 3 },{ -1, -1, 2 },{ 0, 0, 0 },{ -3, 3, -2 },{ 1, 1, 2 },{ 0, -3, -3 },{ 2, 2, -1 },{ -3, -3, 3 },{ 1, 0, -1 },{ 0, 3, 0 },{ 2, -4, -4 },{ 0, 0, -2 },{ 3, -4, 3 },{ -4, 1, 0 },{ 2, -3, -1 },{ 1, 1, -2 },{ -1, 2, 3 },{ 1, -4, -2 },{ -3, 1, 0 },{ 0, -3, -2 },{ -1, 2, -1 },{ -4, 2, -4 },{ 3, -1, -3 },{ -2, -2, 3 },{ 2, 0, -4 },{ 3, -2, -1 },{ -3, -3, -4 },{ -1, 2, 3 },{ 3, -4, -2 },{ -3, 0, -4 },{ -4, 3, -2 },{ 3, 1, -1 },{ -2, -2, 1 },{ 1, -1, 1 } },
+		{ { 3, 2, -3 },{ -4, -4, -1 },{ 2, 1, -1 },{ -2, 0, -4 },{ 1, 1, 0 },{ 2, -2, -3 },{ 3, -2, -1 },{ -3, 0, 3 },{ -1, 2, -1 },{ 1, -3, 2 },{ -1, -4, 1 },{ 3, 0, -4 },{ 1, 0, 0 },{ -3, 3, 0 },{ 0, 1, -4 },{ 0, -4, 1 },{ -3, -3, -2 },{ -1, 0, -1 },{ -2, 2, 0 },{ 0, -2, -3 },{ -4, 2, -4 },{ 2, 0, 1 },{ -2, -1, 2 },{ 3, -3, -3 },{ 1, -4, 0 },{ -3, -1, -1 },{ -2, -2, -4 },{ -1, -4, 2 },{ -4, 1, -3 },{ 2, -2, 1 },{ -1, -4, 0 },{ -3, 2, -3 },{ -4, -3, -3 },{ 3, -2, 2 },{ -1, 0, -4 },{ -3, -4, 0 },{ -4, -1, -3 },{ -2, 3, -2 },{ -1, -3, 2 },{ 3, -1, -3 },{ -4, -3, 0 },{ -1, 2, -1 },{ -3, -2, 2 },{ -2, 2, -4 },{ -1, -4, 2 },{ -3, -2, -1 },{ 2, -2, 1 },{ 0, -3, 2 },{ -2, 2, -4 },{ 3, 0, 3 },{ 1, -3, 1 },{ 1, -4, -1 },{ -1, 1, 2 },{ -4, -3, 0 },{ -2, 2, -1 },{ -1, 1, 2 },{ 1, 3, 3 },{ 1, 0, -3 },{ -2, -2, 2 },{ 0, 3, -1 },{ 2, 0, 2 },{ 1, -3, -3 },{ 0, 2, 0 },{ -2, -1, 2 } },
+		{ { 2, -3, 3 },{ 1, 1, -4 },{ 0, -2, 1 },{ -4, 3, -2 },{ 3, -3, 3 },{ -2, 2, -4 },{ -1, 3, 1 },{ -4, -3, -1 },{ 3, 1, -4 },{ 0, -1, -3 },{ -4, 3, 3 },{ -2, 1, -1 },{ 2, -1, -3 },{ -1, -3, 1 },{ -4, 2, -1 },{ 3, -2, -3 },{ 2, -1, 2 },{ -4, 3, 3 },{ 3, -1, 1 },{ 1, -3, 2 },{ -2, -4, -2 },{ 3, -2, -1 },{ -3, 3, 2 },{ 1, 1, -4 },{ -4, -2, 3 },{ -1, 0, 1 },{ 3, 2, 0 },{ 1, 2, 3 },{ 0, 1, -2 },{ 3, 3, -4 },{ 2, 0, -1 },{ 1, 3, 1 },{ -2, -1, 3 },{ 0, -3, 1 },{ 2, 3, -1 },{ -1, 1, 3 },{ 2, 2, 0 },{ 1, -2, 1 },{ -4, 1, 3 },{ 2, 1, -4 },{ -2, 3, 1 },{ 1, -1, 3 },{ 3, 0, -3 },{ 2, 1, -2 },{ 1, 3, 3 },{ -4, -1, -4 },{ -4, 0, -3 },{ -2, 3, 2 },{ 2, -1, -1 },{ -1, -2, -3 },{ -4, 3, 1 },{ -3, -1, -2 },{ 0, 2, -3 },{ 2, -2, 2 },{ -3, 3, -2 },{ 2, -3, -4 },{ -2, -1, 0 },{ -4, -4, -3 },{ 2, -1, 1 },{ 1, -3, 0 },{ -3, 1, -3 },{ -1, -4, 3 },{ -4, -2, -4 },{ -1, 3, -2 } },
+		{ { -3, -3, 0 },{ -2, -1, 3 },{ -3, -2, 1 },{ -1, -4, 0 },{ 0, -1, -2 },{ -3, -4, 3 },{ 2, -1, 0 },{ 0, 1, -3 },{ 1, -4, 2 },{ -2, -2, 0 },{ -4, 2, -2 },{ 1, -3, 2 },{ -1, 2, 3 },{ -3, -2, -3 },{ 3, 0, 1 },{ -2, -4, 3 },{ -3, 1, 0 },{ 0, 2, -4 },{ -1, -3, -1 },{ 1, 0, -3 },{ -4, 3, -3 },{ 2, 1, 0 },{ -1, -4, -2 },{ 0, 2, 1 },{ 2, 1, -1 },{ 2, -1, -3 },{ -3, -4, -1 },{ -1, -1, -3 },{ -3, 0, 1 },{ -2, -3, 3 },{ -4, -4, 2 },{ 0, 1, -4 },{ 3, -1, -2 },{ -2, 2, -3 },{ -3, 0, -4 },{ 1, -4, 1 },{ -1, -2, -2 },{ 3, 0, -4 },{ 0, -4, -1 },{ -2, -2, -1 },{ -3, 2, 2 },{ 0, -3, -3 },{ -4, -3, 0 },{ -1, -1, 1 },{ -2, 2, -2 },{ 0, -4, 0 },{ 1, 1, -1 },{ 3, 0, 3 },{ -3, -4, -3 },{ 0, 1, 0 },{ 2, 0, 3 },{ -1, -3, -4 },{ 1, 0, 1 },{ 3, 0, -1 },{ -1, -4, 3 },{ 0, -1, 1 },{ 3, -3, -2 },{ -4, 2, -1 },{ 0, 2, -4 },{ -1, -2, 3 },{ -4, -1, -2 },{ 3, 1, 1 },{ 2, 2, 2 },{ -4, 0, -1 } },
+		{ { 1, 1, -4 },{ 3, 2, 2 },{ 1, 3, -3 },{ 3, 1, -3 },{ 1, 2, -1 },{ -4, 0, 2 },{ 1, -2, -4 },{ -2, 2, 1 },{ -3, 0, 1 },{ 2, 3, 0 },{ 2, -1, -1 },{ -3, -4, -4 },{ 3, 1, 0 },{ 0, -2, -2 },{ -2, 0, 2 },{ 1, 3, -1 },{ -1, -2, -2 },{ 1, -4, -4 },{ 3, 1, 0 },{ -3, -1, 1 },{ -1, 2, 3 },{ 0, -2, 3 },{ -4, -1, 2 },{ -2, 0, -4 },{ -1, -3, 3 },{ 0, 3, 1 },{ -4, -3, -4 },{ 1, 3, 2 },{ 3, -3, -3 },{ 1, -2, 0 },{ -3, 2, -1 },{ -4, 0, -2 },{ 2, -3, 0 },{ -1, 1, 2 },{ -4, -4, 0 },{ 3, 3, -1 },{ -3, -1, 2 },{ -4, 2, -3 },{ 2, 3, 0 },{ -1, -4, 2 },{ 3, 1, -2 },{ 2, -1, -4 },{ -1, 3, -1 },{ 1, -4, 0 },{ 3, -2, 2 },{ 3, -3, -4 },{ -1, 2, 1 },{ -3, -2, -2 },{ 2, -4, -4 },{ -4, 2, 0 },{ -2, -2, 2 },{ 3, 2, -1 },{ -3, -4, -2 },{ -2, -2, -4 },{ -4, 2, 0 },{ 1, 1, -3 },{ -3, 0, 3 },{ -2, 3, 2 },{ 2, 1, 1 },{ 3, -4, -2 },{ -2, 3, 0 },{ 0, -3, -1 },{ 0, -1, -3 },{ 2, -4, -2 } },
+		{ { -3, 0, -1 },{ 0, -3, -2 },{ -4, -4, -1 },{ -2, 0, 3 },{ -1, -3, 1 },{ -3, -1, -3 },{ 3, 3, -2 },{ -2, -3, -1 },{ -1, -4, -3 },{ 3, 1, 3 },{ 0, -2, -3 },{ -1, 3, 2 },{ 2, -4, 1 },{ 1, -1, -2 },{ -4, 3, -4 },{ 2, 1, -3 },{ 2, -3, 2 },{ -4, 0, 3 },{ -3, 3, -2 },{ -2, -2, 1 },{ 2, 1, -4 },{ 3, -3, -3 },{ 1, 3, -1 },{ -2, -3, -2 },{ 3, 2, 0 },{ -3, 0, -2 },{ 0, 1, 2 },{ -2, -1, 0 },{ 2, 1, -2 },{ -1, -2, 3 },{ 0, 2, -3 },{ 3, -4, 1 },{ 1, -2, 2 },{ -2, 3, 3 },{ -3, -2, -3 },{ 1, 0, 1 },{ 0, -3, 2 },{ -2, -1, -2 },{ 1, -3, 3 },{ -3, 0, -3 },{ 1, 0, 1 },{ -4, -2, 1 },{ 0, 3, 3 },{ -3, 1, -2 },{ -3, 0, -3 },{ -4, 0, 2 },{ 0, 3, -1 },{ -1, -1, 0 },{ 1, -1, 3 },{ 0, 1, 1 },{ 1, -3, -3 },{ -4, 3, 0 },{ 2, 1, 2 },{ -1, -1, 2 },{ 1, 3, -1 },{ -1, -3, -4 },{ 2, -2, 0 },{ 0, -3, -4 },{ -1, -2, 0 },{ -3, 0, -3 },{ -2, 3, -4 },{ 1, 0, 3 },{ -3, -4, 1 },{ -1, 3, 1 } },
+		{ { -2, -1, 2 },{ 2, 1, -4 },{ 0, -2, 2 },{ -2, 3, 0 },{ 2, 2, -4 },{ 2, -4, 0 },{ 0, 1, 3 },{ 0, -1, 2 },{ -4, 2, -2 },{ 1, -3, -4 },{ -4, -1, 2 },{ -3, 0, -2 },{ -4, 2, -1 },{ -2, 1, 3 },{ -1, -4, 2 },{ -3, -1, 1 },{ -1, 2, 0 },{ 0, -3, -1 },{ 2, 3, -2 },{ -1, -4, 2 },{ -3, -4, 0 },{ 1, 0, -1 },{ -3, 0, 0 },{ -4, -4, 2 },{ 2, -2, 1 },{ 2, -1, -3 },{ -2, -2, 3 },{ 1, -4, -2 },{ -4, 2, 1 },{ -3, -1, -4 },{ -1, 3, 2 },{ 1, 1, -3 },{ -3, 0, -4 },{ 0, -1, -1 },{ 3, 1, -2 },{ 0, 2, -4 },{ -1, -2, 3 },{ 2, 3, -4 },{ 3, 1, 1 },{ -4, -1, -3 },{ -1, 2, -1 },{ 3, -4, 3 },{ -2, 1, -4 },{ 2, -3, -3 },{ 0, 2, -1 },{ -2, -2, 3 },{ 2, -3, -3 },{ -2, 2, 2 },{ -4, -3, -4 },{ 3, 3, -2 },{ -1, 0, -1 },{ 0, -4, 3 },{ -3, -2, -3 },{ 2, -1, -1 },{ 3, 1, 3 },{ -3, -4, -2 },{ 0, 2, 2 },{ -4, 0, -1 },{ 3, -4, 1 },{ 1, 2, 3 },{ 2, -3, 2 },{ -4, -1, -2 },{ 3, 1, -4 },{ -1, -2, 3 } },
+		{ { 0, 3, -3 },{ -4, -3, 0 },{ 1, -1, 3 },{ 3, 0, -2 },{ -3, -2, -1 },{ -1, -3, -3 },{ -4, 0, 1 },{ 2, -2, -4 },{ -1, 3, 0 },{ -2, 1, 0 },{ 3, -3, 1 },{ 1, 0, -3 },{ 0, -3, -4 },{ 3, -2, 0 },{ 0, -1, -1 },{ 3, -3, -4 },{ -3, 2, -3 },{ -2, -2, 3 },{ 3, 0, -4 },{ 1, -1, -3 },{ -4, 2, 3 },{ -1, -2, -2 },{ 0, 2, 2 },{ 3, 1, -4 },{ 1, 3, 0 },{ -1, 1, -3 },{ -4, -4, -1 },{ 3, 3, -4 },{ 0, 0, 0 },{ 3, -4, -1 },{ 2, -3, 0 },{ -4, -1, 1 },{ -2, -4, -1 },{ 2, 3, 0 },{ -1, -3, 2 },{ -3, -4, -3 },{ -4, 0, 0 },{ -2, -2, 0 },{ -3, -4, -1 },{ 0, -2, -4 },{ 0, 3, 2 },{ -2, -3, -2 },{ 1, 0, 0 },{ -4, -1, 1 },{ 2, -4, 1 },{ 0, 3, 0 },{ 3, 1, -2 },{ -4, 0, -1 },{ 2, -4, 1 },{ -3, -2, -2 },{ -2, 2, -4 },{ 3, -1, 1 },{ -3, 0, -2 },{ 0, -3, 1 },{ -2, 2, -3 },{ -4, 0, 1 },{ -1, -1, -2 },{ 3, 1, -3 },{ -2, 2, 1 },{ -4, -2, -3 },{ -1, 1, -1 },{ 0, -2, 0 },{ 1, 2, 0 },{ 3, -4, -1 } },
+		{ { -1, -2, -1 },{ -3, 2, -4 },{ 3, 2, 1 },{ -4, -4, 0 },{ 0, -1, 3 },{ 1, 2, 2 },{ -2, 3, -1 },{ 3, -4, -1 },{ -3, 0, -2 },{ 1, -4, 3 },{ 0, 3, 3 },{ -1, 2, -1 },{ -2, -4, 2 },{ 2, 3, 1 },{ -4, 1, -2 },{ 1, 3, 0 },{ 2, -1, -1 },{ 1, -4, 2 },{ -4, 1, -3 },{ 0, 0, 1 },{ 2, 3, 1 },{ 3, -2, -4 },{ -4, -1, -3 },{ 0, -4, 3 },{ -3, -3, -1 },{ -3, 2, 2 },{ -1, -2, 1 },{ 1, 2, 2 },{ -2, -2, 3 },{ -2, 0, -3 },{ 1, 1, -2 },{ -1, 2, 3 },{ 3, -2, -2 },{ -4, 2, 1 },{ 1, 0, 3 },{ 2, -4, 1 },{ 3, 1, -1 },{ 0, 3, -2 },{ 1, 2, 3 },{ 2, -4, 1 },{ 2, -1, 0 },{ -3, 0, -2 },{ 3, 2, -3 },{ -1, 2, 2 },{ 1, -2, -1 },{ -2, -1, -4 },{ -3, -4, 2 },{ 1, 0, -4 },{ 0, 2, 3 },{ 1, -3, 0 },{ -2, -2, 3 },{ -1, 1, 2 },{ 1, 3, -4 },{ -4, 2, 0 },{ 1, -2, 2 },{ 2, -3, -4 },{ 2, -4, -1 },{ -3, -2, 3 },{ 0, 3, 2 },{ 2, -1, -4 },{ -1, -4, 2 },{ -2, 3, -3 },{ -4, 0, -3 },{ -3, 1, 2 } },
+		{ { 2, -3, -2 },{ -1, 0, 3 },{ 1, -3, -3 },{ -2, 1, -1 },{ -4, 3, -4 },{ 2, 1, -3 },{ -1, -2, 1 },{ -3, 1, 2 },{ 2, -2, -3 },{ -4, -1, -4 },{ 3, -2, 1 },{ -3, 1, -3 },{ -4, -1, -2 },{ 1, -2, -3 },{ -2, 0, 3 },{ -2, -3, 1 },{ -4, 0, 3 },{ 0, 3, -2 },{ -2, 2, 0 },{ -3, -3, -1 },{ -2, -3, 3 },{ 2, 2, 0 },{ -2, 1, 1 },{ 1, 0, -1 },{ 2, -1, -3 },{ -2, 3, 3 },{ 3, 0, -2 },{ 2, -3, -4 },{ -3, -1, -1 },{ -4, 3, -3 },{ 0, -4, 2 },{ 0, 0, -4 },{ -3, -3, -1 },{ -1, 1, -3 },{ -3, -1, -4 },{ 0, 3, -2 },{ -4, -1, -3 },{ -1, -2, 3 },{ -3, 1, 2 },{ -2, 2, -3 },{ -4, -1, -4 },{ 0, -3, 3 },{ -1, -2, 2 },{ -4, -4, -4 },{ 3, 1, -2 },{ -2, 2, -2 },{ -1, -3, 0 },{ 3, 3, -3 },{ -1, -1, 2 },{ 0, 1, -1 },{ -4, 3, -1 },{ 3, -4, -3 },{ 2, 0, 0 },{ -1, -4, -2 },{ 3, 3, 3 },{ -2, 1, 2 },{ 1, 3, 0 },{ -3, 0, -4 },{ 1, -3, -2 },{ -3, -1, 0 },{ 3, 1, -2 },{ 1, -4, 1 },{ -2, -3, 3 },{ 2, 0, 1 } },
+		{ { -4, -1, -4 },{ -2, -4, 1 },{ 0, 3, -2 },{ 2, -2, 2 },{ -2, -4, 1 },{ 0, -1, -2 },{ 3, -3, -4 },{ 0, -4, 3 },{ 1, 2, 0 },{ -1, -1, -2 },{ -2, 2, -1 },{ 2, -3, -4 },{ -3, 2, 3 },{ -1, -3, 0 },{ 3, 1, -4 },{ 2, -4, -3 },{ -1, -2, 1 },{ 0, -1, -4 },{ 3, -4, 1 },{ 2, -2, -2 },{ -1, 1, -1 },{ 0, -4, -3 },{ -3, -2, -2 },{ -1, 2, 1 },{ 2, -3, -4 },{ 0, -4, 0 },{ -4, -1, -2 },{ -1, 2, 1 },{ 2, 1, 3 },{ 3, -2, 1 },{ -2, 2, -1 },{ 2, -1, 2 },{ 3, -2, 1 },{ 1, -4, 0 },{ -2, 0, 3 },{ 3, 2, 2 },{ -2, -3, 1 },{ 1, -2, -4 },{ 3, 0, -2 },{ -2, -3, 0 },{ -1, 1, -1 },{ 2, 3, 1 },{ -2, -4, 0 },{ 1, 3, -1 },{ -3, 0, 3 },{ -4, -3, 3 },{ 2, 0, 1 },{ -1, -2, -1 },{ -3, -4, 1 },{ -4, 0, -3 },{ 2, -3, -2 },{ 0, -2, 1 },{ -3, 1, 3 },{ -3, -1, -3 },{ -1, -3, -4 },{ -4, -1, -1 },{ 0, -2, -3 },{ -2, 2, 1 },{ -1, -3, 2 },{ -4, 2, 0 },{ 3, 0, 3 },{ -3, 3, -2 },{ 0, -2, -4 },{ 1, 3, -1 } },
+		{ { -4, 1, 2 },{ 3, -1, 0 },{ -3, 0, -3 },{ 1, 0, 3 },{ 3, -3, 0 },{ -3, 3, 2 },{ -1, 1, 1 },{ -4, 0, -1 },{ -2, 3, 0 },{ -3, 0, 2 },{ 0, -3, 1 },{ 2, 3, 2 },{ 0, 0, 0 },{ 1, -4, -1 },{ -1, 2, -2 },{ -3, 2, 2 },{ 1, 3, -3 },{ -3, 0, 0 },{ -2, 1, 3 },{ 1, 2, -4 },{ -4, -1, 2 },{ 3, 3, 2 },{ -4, -3, 0 },{ -1, 3, 3 },{ -4, 0, 0 },{ 0, 1, 2 },{ -3, 3, -2 },{ 1, -4, -4 },{ -1, -3, -1 },{ -1, 1, 0 },{ -4, -4, -4 },{ -3, 3, 3 },{ -2, 1, -1 },{ 1, 3, -2 },{ -4, -2, -4 },{ 2, -3, -2 },{ -3, 3, 0 },{ -1, -4, 0 },{ 0, 3, -1 },{ 3, -4, 2 },{ -3, 0, -3 },{ 1, 2, 2 },{ -4, -2, -2 },{ 3, -1, -4 },{ 0, 2, 1 },{ 1, -1, -3 },{ 3, 1, 0 },{ -4, 3, -2 },{ 1, 1, -4 },{ 3, 2, 0 },{ -1, -1, 3 },{ -2, -2, -4 },{ 1, 2, 1 },{ 0, 2, -1 },{ 2, 0, 2 },{ 3, 1, 0 },{ -1, -4, -2 },{ 3, 0, 3 },{ 2, -2, -1 },{ -1, 1, -3 },{ 2, -3, -4 },{ -4, -1, 1 },{ -1, 2, 0 },{ 3, -4, 3 } },
+		{ { 0, -2, -3 },{ 1, 3, -1 },{ -1, 1, -2 },{ -2, 2, -1 },{ -4, -2, -4 },{ 2, 0, -3 },{ 1, -2, -1 },{ -2, 2, -3 },{ 3, -3, -4 },{ 1, -2, 3 },{ 3, -4, -3 },{ -4, 1, -3 },{ -2, -1, -2 },{ 3, 1, 2 },{ -4, -1, 1 },{ 0, -1, -1 },{ 2, -2, -1 },{ 1, -4, 0 },{ -4, -3, 3 },{ 2, 3, -2 },{ -3, -1, -3 },{ 0, 0, -1 },{ 1, 1, -4 },{ 3, -1, -1 },{ 1, -3, -3 },{ 3, -2, 1 },{ -2, -2, -1 },{ 1, 0, 3 },{ 0, -1, -3 },{ -3, 0, 2 },{ 1, -2, -2 },{ 2, -3, -3 },{ -1, -1, -3 },{ -4, 0, 0 },{ -1, -4, 2 },{ 2, -1, -1 },{ 0, 1, 2 },{ 2, 0, -3 },{ -4, 2, 3 },{ 1, -1, -1 },{ -2, -2, -2 },{ 2, -3, 3 },{ 0, 1, -3 },{ -2, 0, -1 },{ -1, -4, 2 },{ 0, 1, -1 },{ -2, -4, -4 },{ -2, -3, 3 },{ 0, -1, 2 },{ -3, -4, 2 },{ 2, 1, -1 },{ 1, 3, -2 },{ -4, -4, 1 },{ 2, -3, -3 },{ -2, 3, 3 },{ -3, -4, 0 },{ -3, -1, -2 },{ -4, 3, 3 },{ 1, -1, -4 },{ 0, -4, -1 },{ -2, 1, 2 },{ 0, -3, 3 },{ 2, 0, -2 },{ -1, 2, 0 } },
+		{ { -2, 0, 2 },{ -3, -4, 3 },{ 2, -3, 1 },{ 0, -4, 1 },{ -1, 3, 2 },{ 3, 2, 3 },{ 0, -4, 0 },{ -4, -1, -2 },{ 2, 1, 2 },{ -3, 3, 1 },{ -1, 0, -1 },{ -1, -2, -1 },{ -3, 3, 3 },{ 2, -2, -4 },{ -3, -3, -2 },{ -1, -3, 3 },{ -4, 0, -3 },{ 3, 1, 2 },{ -2, 2, -4 },{ 0, -3, 0 },{ -1, -2, 1 },{ 2, -4, 3 },{ -2, -2, -2 },{ -1, 2, 2 },{ -3, -4, -4 },{ -2, 0, 0 },{ 2, 2, -3 },{ -4, 3, 2 },{ 3, -3, 0 },{ -2, 2, 0 },{ 2, 3, 3 },{ 3, 1, 1 },{ 0, -3, 1 },{ 1, 2, -2 },{ 3, 3, 3 },{ -3, 1, 0 },{ -2, -1, -3 },{ -4, -2, 1 },{ 1, -3, -4 },{ -1, 1, 1 },{ -3, -1, -4 },{ 3, 3, 1 },{ -1, 2, 0 },{ -3, -3, 2 },{ 2, -2, 1 },{ -4, 3, -2 },{ -3, 0, -3 },{ 3, 2, -1 },{ 2, -2, 0 },{ -1, 2, -3 },{ -2, -3, -4 },{ -3, 0, 3 },{ 3, 0, 0 },{ -4, -2, -2 },{ 1, 1, -4 },{ 0, -2, 1 },{ 2, 2, -4 },{ 1, 1, 2 },{ -3, -3, 1 },{ 3, 3, -3 },{ -3, 2, 1 },{ -4, -2, -1 },{ 3, -4, -3 },{ -3, 3, -4 } },
+		{ { 0, -2, -2 },{ -1, -1, -4 },{ 3, -1, -3 },{ -4, 1, -1 },{ -3, -2, -4 },{ -3, -1, -2 },{ -2, 1, 1 },{ 1, -4, -1 },{ 0, -2, 2 },{ -3, 1, -4 },{ 0, -1, -2 },{ 2, 2, 1 },{ -4, -4, 2 },{ 1, 1, -4 },{ 3, 3, 0 },{ -2, 1, 2 },{ -1, 3, -4 },{ 1, -4, 1 },{ -2, -1, -2 },{ 3, 0, -1 },{ -3, 3, 2 },{ 1, 2, -3 },{ -4, -3, 1 },{ 2, 3, -2 },{ 0, 1, 3 },{ -4, 3, 1 },{ 1, -4, -2 },{ -1, -1, 2 },{ -3, 0, -4 },{ 0, -4, -2 },{ -4, -1, -4 },{ -2, -2, -1 },{ -3, 1, 3 },{ -3, -2, -4 },{ -1, -2, 1 },{ 3, -3, -4 },{ 0, -4, -2 },{ -2, 2, 2 },{ 3, 3, -1 },{ 2, -4, -2 },{ -4, 2, 2 },{ 0, -4, 0 },{ -4, -1, -3 },{ 3, 0, -2 },{ 1, 3, -4 },{ 0, -2, 3 },{ 2, -3, 2 },{ -1, -1, 0 },{ -4, 0, 1 },{ 0, 3, -3 },{ -4, -1, 1 },{ 0, -3, 2 },{ -1, 2, -3 },{ -1, -4, 2 },{ -2, 3, -1 },{ 3, -3, -1 },{ -2, 0, 1 },{ -1, -4, -3 },{ -4, -2, -2 },{ -2, 0, 0 },{ 1, -1, 3 },{ -1, 1, -2 },{ -2, 1, 2 },{ 2, -3, 1 } },
+		{ { 1, 2, 0 },{ 3, 1, 0 },{ 0, 3, 3 },{ -1, 2, -2 },{ 2, -3, 2 },{ 3, 0, 0 },{ 1, 3, -4 },{ -1, 2, 3 },{ 2, -3, -3 },{ -4, 2, 3 },{ 1, -4, 0 },{ 3, -3, -3 },{ 0, 0, 0 },{ -2, -1, -1 },{ 0, 2, 1 },{ 1, -4, -2 },{ -3, 0, -1 },{ 2, 2, 3 },{ -4, -2, -3 },{ 0, -1, -1 },{ 2, -4, 3 },{ -2, 1, -4 },{ 3, 0, 0 },{ -3, -2, -1 },{ -1, -1, 1 },{ 2, 1, -4 },{ 3, -3, -3 },{ -3, 2, 3 },{ 1, -2, -1 },{ 3, 1, -3 },{ -1, 2, 1 },{ 0, -4, 2 },{ 1, 3, -3 },{ 3, 0, 0 },{ -4, 2, -3 },{ 0, -1, -1 },{ 2, 2, 3 },{ -1, 0, 0 },{ 1, -2, 1 },{ -2, 0, -3 },{ 0, 0, 3 },{ 1, -3, -1 },{ 2, 1, -4 },{ -1, -4, 3 },{ -2, 1, 1 },{ -3, -1, -1 },{ 1, 1, 0 },{ 1, 3, -4 },{ -2, -4, 3 },{ 3, -2, -1 },{ 1, 1, -2 },{ 3, 3, -1 },{ -3, -1, 0 },{ 2, 1, -4 },{ 2, -1, 3 },{ -4, 0, 2 },{ 0, -3, -3 },{ 3, 2, 0 },{ 2, -1, 3 },{ 0, 2, -2 },{ 3, -4, -4 },{ 2, -2, 0 },{ 1, 3, -1 },{ -4, -1, 2 } },
+		{ { -3, 1, -2 },{ -2, -3, 1 },{ -4, -4, -4 },{ 1, 0, -1 },{ -2, -4, -3 },{ 0, 2, 3 },{ -4, -3, -3 },{ -1, 0, -1 },{ -3, -1, -1 },{ 0, 0, -4 },{ -2, 1, 2 },{ -2, 3, -2 },{ 2, 0, 1 },{ -3, -3, -3 },{ 3, -2, 3 },{ -4, -2, -3 },{ 3, -1, 0 },{ 0, -3, 2 },{ -1, 1, 1 },{ -3, 0, -4 },{ 1, 3, 0 },{ -4, -2, 2 },{ 0, -3, -3 },{ -2, 0, 2 },{ 1, -4, -1 },{ -1, -1, 3 },{ -2, -2, -1 },{ 0, 0, 0 },{ -1, 3, 2 },{ -3, -2, 0 },{ 2, -3, 3 },{ -4, -1, -2 },{ -1, 0, 0 },{ 0, -4, 2 },{ -2, -3, -1 },{ 1, 3, 1 },{ -4, 0, 3 },{ -3, -4, -4 },{ 2, -3, -3 },{ -4, 1, 2 },{ -2, -2, -2 },{ 2, 3, 0 },{ -3, -1, 2 },{ 0, 2, 0 },{ -4, 0, -3 },{ 3, -4, -3 },{ -4, 2, 2 },{ -1, -2, -2 },{ -3, 1, -4 },{ 2, -3, -2 },{ -2, -4, 2 },{ 2, -1, -4 },{ -2, -2, 2 },{ 0, 3, -2 },{ -4, -4, 1 },{ -1, 2, -2 },{ -3, 0, -1 },{ 0, 3, -4 },{ -4, -4, 3 },{ -2, 0, 1 },{ -3, -3, -1 },{ -4, 2, -4 },{ -1, 0, 3 },{ 3, -4, -3 } },
+		{ { 2, 2, -1 },{ -2, -2, 2 },{ -3, -1, 3 },{ 3, 0, 0 },{ 0, 1, 1 },{ 2, -2, 0 },{ -3, -1, 2 },{ 3, -4, 1 },{ 2, 3, 1 },{ 3, -2, 0 },{ -1, -2, -3 },{ -4, 3, 3 },{ -1, -1, -4 },{ 1, -4, 0 },{ -3, 1, -2 },{ 0, 2, 2 },{ -2, 1, -4 },{ -1, 3, -1 },{ -3, -3, -2 },{ 3, -4, 0 },{ -1, 1, 3 },{ 1, -1, -2 },{ -1, 2, 1 },{ 3, 2, -4 },{ 1, 3, -3 },{ -4, 1, 0 },{ -4, 2, -4 },{ 2, -4, 1 },{ 2, 0, -3 },{ -4, 1, -1 },{ 1, 3, -4 },{ -2, 0, -1 },{ 3, 3, -4 },{ 2, -2, -3 },{ -3, 1, 2 },{ 2, -2, -2 },{ -1, -2, -2 },{ 3, 3, 0 },{ 0, 1, -1 },{ -3, -1, 3 },{ 3, 3, -4 },{ -1, -4, -3 },{ -2, -3, -1 },{ 3, 1, 3 },{ 1, -2, -2 },{ -1, -3, 1 },{ 2, 3, -1 },{ 0, -4, 3 },{ -1, 0, 1 },{ 0, 2, 2 },{ -4, 2, 3 },{ -3, 0, -3 },{ -3, -3, -1 },{ 1, 0, 3 },{ 3, -3, -4 },{ -2, 1, 0 },{ 1, -2, 2 },{ -1, -1, 1 },{ 2, 3, -1 },{ 1, 1, -3 },{ -1, 1, 1 },{ 0, -2, 2 },{ -3, -3, -2 },{ 0, 0, -3 } }
+	},
+	{
+		{ { 3, -2, -2 },{ -3, -1, 1 },{ 0, -3, -1 },{ 1, 1, 3 },{ 3, 0, -3 },{ 1, -1, 0 },{ -2, -4, 3 },{ 1, 0, -3 },{ 0, -4, -2 },{ -1, 0, 0 },{ -4, -3, -3 },{ -3, -4, 2 },{ 2, 2, 3 },{ -2, 0, -2 },{ -2, -4, 2 },{ 0, -2, -2 },{ 3, -1, -1 },{ -4, 2, 0 },{ 2, -4, -4 },{ -1, 2, -3 },{ -2, -3, 2 },{ -4, 3, 3 },{ 3, -1, -2 },{ -1, -2, 3 },{ 3, 3, -2 },{ 0, 0, -1 },{ -3, -3, -2 },{ -1, 2, -4 },{ 0, -4, 2 },{ -3, 0, -1 },{ -2, 2, -3 },{ -1, -3, -2 },{ 2, -1, 0 },{ -2, 2, 3 },{ -3, -4, 2 },{ -3, -2, -1 },{ -2, -2, -2 },{ -4, 1, -3 },{ -2, -3, 2 },{ -3, -1, -1 },{ -4, -2, -4 },{ -1, 3, 3 },{ 1, -3, -2 },{ -3, 1, 2 },{ 1, -1, -2 },{ -2, 3, -4 },{ 2, -4, 1 },{ -3, -2, -1 },{ 3, 2, -3 },{ -2, -3, 2 },{ -4, 2, 0 },{ -1, -2, 1 },{ 1, -3, -4 },{ -3, 1, 2 },{ 1, -4, -3 },{ 3, 2, 0 },{ -2, -1, 2 },{ 3, 1, 2 },{ 0, 3, 3 },{ -3, 0, -4 },{ -1, -4, 1 },{ 0, 3, 2 },{ -3, -3, -3 },{ 2, -4, -4 } },
+		{ { -2, 1, 0 },{ 1, -3, -2 },{ -1, 3, 2 },{ -4, -4, 2 },{ -3, -3, -2 },{ 0, 2, -1 },{ 3, 2, -4 },{ -4, -1, 1 },{ 3, 1, -2 },{ -1, -2, 1 },{ 1, 3, -4 },{ 3, -1, -2 },{ 0, -2, -1 },{ -3, 3, 0 },{ 3, -3, 3 },{ 1, 2, -3 },{ -1, -3, -4 },{ 1, 0, 1 },{ -3, 1, 3 },{ 0, -1, -2 },{ 2, -2, 1 },{ 0, 2, 0 },{ -2, -4, -4 },{ -4, 0, 1 },{ -1, -1, -4 },{ 2, -3, 0 },{ -2, -1, 2 },{ 2, 3, 0 },{ -4, 0, -1 },{ 2, -2, 1 },{ 1, 1, 3 },{ 0, -3, -1 },{ 3, -2, 0 },{ 1, 3, -3 },{ 1, 1, -4 },{ -1, -3, -1 },{ 3, 3, 3 },{ -1, -3, 1 },{ 3, 0, -3 },{ 2, 3, 3 },{ 0, -3, 0 },{ 3, 1, -2 },{ -2, -1, -1 },{ -1, 2, 1 },{ 3, 1, -1 },{ -4, -3, 3 },{ -2, 0, -2 },{ 0, -2, 2 },{ 1, -1, 0 },{ 1, 1, 3 },{ -1, -1, -4 },{ -4, 1, -1 },{ 0, 0, -3 },{ -2, 2, 0 },{ -4, -2, 3 },{ 0, 0, 1 },{ -4, 1, -4 },{ 2, -3, -1 },{ -4, -2, -2 },{ 3, 1, 0 },{ -4, 2, -3 },{ 1, -1, -2 },{ -4, -2, 0 },{ 0, 0, -1 } },
+		{ { -4, -4, 2 },{ 0, 0, -3 },{ 3, 2, -4 },{ -2, 1, 0 },{ 2, -1, -3 },{ -4, 3, 1 },{ -1, -2, 2 },{ -2, -3, 3 },{ 2, -3, -1 },{ -4, 1, 2 },{ 1, 0, 3 },{ -2, 1, -1 },{ -3, -3, -4 },{ -1, 1, 1 },{ 2, -1, 1 },{ -4, 3, -1 },{ -1, 0, 1 },{ -3, -2, 2 },{ 3, 3, -3 },{ -2, -4, -1 },{ 1, 1, -4 },{ -3, 0, 1 },{ 2, 3, -2 },{ 1, -4, 0 },{ 1, 2, -3 },{ -3, 3, 1 },{ -2, 1, 3 },{ 1, -4, -3 },{ -1, -3, -4 },{ 3, -1, 0 },{ -4, 3, -3 },{ -3, 3, 2 },{ -2, -1, -4 },{ -4, 0, 1 },{ 2, -4, 0 },{ -4, 1, 2 },{ 2, -1, 0 },{ 0, 2, -2 },{ -3, -2, -1 },{ 1, 2, -4 },{ -2, -4, 1 },{ -4, 0, 2 },{ 1, -2, 3 },{ 0, -4, -4 },{ -4, -2, 2 },{ 1, -1, 0 },{ 0, 3, -3 },{ 3, 2, -4 },{ -4, 0, -2 },{ -3, -3, 1 },{ 2, 3, 3 },{ 2, -4, -2 },{ 3, -2, 2 },{ 2, -3, -2 },{ -3, -1, -1 },{ 2, -4, -3 },{ -1, 2, -2 },{ 0, -4, 1 },{ 1, 3, -3 },{ -1, -3, 0 },{ -2, -1, 3 },{ 2, -3, -4 },{ -2, 3, 2 },{ 3, 2, 3 } },
+		{ { 2, -1, -4 },{ -3, 3, 0 },{ 0, -2, 3 },{ -1, -2, 1 },{ 1, -4, -1 },{ 0, 0, -3 },{ 2, -4, 0 },{ 1, 0, -4 },{ -3, 3, -3 },{ 0, 2, 0 },{ 3, -4, -2 },{ -4, -2, 1 },{ 2, 2, 2 },{ 1, -2, -4 },{ -4, 0, -3 },{ -2, -4, 3 },{ 2, 1, -1 },{ -2, -1, 0 },{ 3, -3, -2 },{ -4, 2, 2 },{ -1, -2, 0 },{ 3, -3, 3 },{ -3, -1, -1 },{ 0, 1, 2 },{ -4, -2, 3 },{ 3, -1, -1 },{ 0, -2, -1 },{ -4, 0, -2 },{ -3, 2, 2 },{ 0, 2, 3 },{ -2, -4, -2 },{ 2, 0, -1 },{ 0, 1, 3 },{ -1, -2, -2 },{ -1, -1, 3 },{ -2, 2, -3 },{ 0, 0, -4 },{ 1, -2, 1 },{ -4, -4, 2 },{ -2, -1, -1 },{ -1, 0, 0 },{ 3, 3, -3 },{ -3, -3, -3 },{ 2, 3, -2 },{ 3, 1, -3 },{ -3, 1, 1 },{ 2, -4, 3 },{ -1, -4, 1 },{ -2, -2, -3 },{ 3, 3, -1 },{ -2, -4, 2 },{ -3, 0, -3 },{ -1, 3, 1 },{ 1, 1, 3 },{ -1, 3, 0 },{ 3, -2, -4 },{ -2, 2, 2 },{ -3, -1, 0 },{ 2, 0, 3 },{ -3, 2, 1 },{ 3, 0, -1 },{ 1, 1, 1 },{ -3, -1, -1 },{ -1, 1, -3 } },
+		{ { 1, -4, -1 },{ -3, 0, 2 },{ -4, 2, -2 },{ 3, -1, -4 },{ -1, 3, 3 },{ -2, 1, 2 },{ -4, 2, -2 },{ 0, 1, 1 },{ -2, -1, -3 },{ 2, -4, 3 },{ -2, -2, 0 },{ -1, -1, -3 },{ 3, 3, -1 },{ 0, -4, 0 },{ 3, 2, -2 },{ 1, -3, 2 },{ -3, -2, -4 },{ 0, 3, -2 },{ 1, 0, -4 },{ 0, -1, 3 },{ -1, 1, -2 },{ -4, -4, -3 },{ 1, 3, -3 },{ -2, -2, -1 },{ 3, -3, -4 },{ -1, 2, -4 },{ 1, -4, 1 },{ 3, 0, -3 },{ 2, -3, 1 },{ -3, -1, -4 },{ 1, -2, 0 },{ -1, -4, 1 },{ 3, -3, 2 },{ -3, 2, -3 },{ 3, -3, -1 },{ 1, -4, -2 },{ -3, -1, -4 },{ -2, 3, 0 },{ 0, 1, 2 },{ 2, 2, -3 },{ 2, 1, 3 },{ 0, -2, 2 },{ -1, 2, 1 },{ 0, -4, 0 },{ -2, -1, -1 },{ -1, 0, -1 },{ -4, -3, -4 },{ 2, 2, 2 },{ -3, 1, -1 },{ 0, 1, 0 },{ 1, -1, -4 },{ 0, -2, -3 },{ -4, 2, -1 },{ -2, -3, -4 },{ -3, -4, 2 },{ 0, 0, 1 },{ -4, -1, 3 },{ 1, 1, -1 },{ 0, -3, -3 },{ -2, -4, -4 },{ 0, 3, -2 },{ 2, -4, 3 },{ -4, -2, -4 },{ -1, -3, 1 } },
+		{ { 2, 3, -2 },{ 1, -2, -1 },{ 3, -4, 1 },{ 1, -3, -1 },{ -3, 0, -3 },{ -3, -3, 0 },{ 3, -2, -1 },{ 3, -3, 3 },{ -3, 3, -1 },{ 0, 0, -2 },{ -3, 2, -4 },{ -1, 1, 2 },{ -4, -3, 3 },{ -2, 0, -2 },{ -1, -1, 3 },{ 3, 2, -1 },{ -1, -4, 0 },{ 2, 1, 2 },{ -4, -4, 1 },{ -3, 3, 0 },{ 2, -3, 1 },{ -2, 1, -4 },{ 0, -1, 2 },{ 2, 0, 1 },{ -3, 3, -2 },{ -2, 0, 2 },{ -3, 1, 3 },{ -1, 3, 0 },{ 0, -3, 2 },{ 3, 1, -1 },{ -2, 2, -2 },{ -4, 3, -3 },{ 1, 1, -4 },{ -3, 0, 0 },{ 0, 3, 1 },{ -4, 2, 2 },{ 3, -3, 3 },{ -1, 0, -1 },{ 3, -3, -2 },{ -4, -4, -4 },{ -3, -1, -2 },{ 1, -1, -1 },{ -4, 1, -4 },{ -3, -3, 3 },{ 3, 3, 1 },{ 0, -2, 3 },{ -3, 3, 0 },{ 1, -1, 0 },{ -2, -1, -2 },{ 3, -3, 2 },{ -4, -3, 3 },{ 1, 2, 0 },{ -1, 0, 2 },{ 3, -1, -1 },{ 2, 1, -3 },{ 1, 3, -2 },{ -2, -3, -2 },{ 3, 1, -4 },{ -3, -2, -2 },{ -1, 0, 2 },{ -4, -2, 1 },{ 0, 3, 0 },{ 3, 0, -3 },{ -2, 2, 3 } },
+		{ { -3, 1, -4 },{ -1, -2, 3 },{ -2, 3, -3 },{ -4, 1, 2 },{ 2, 2, 0 },{ 0, -4, 1 },{ 1, -1, -4 },{ -1, 2, -3 },{ -4, -4, 2 },{ 1, -2, 0 },{ 3, -1, 1 },{ 2, 2, -3 },{ 1, -4, 0 },{ -3, 1, -4 },{ 0, -2, 1 },{ -4, 2, -3 },{ -3, -1, -4 },{ 0, 0, 3 },{ -2, -3, -2 },{ 3, -1, -3 },{ 1, 2, 2 },{ 3, 2, 0 },{ -3, -4, -1 },{ -4, 2, 3 },{ 1, -4, 0 },{ 2, -3, 0 },{ 0, 2, -3 },{ -4, -2, -2 },{ -2, -1, -4 },{ -3, 2, 3 },{ 0, -1, 3 },{ -1, -3, 1 },{ 2, -2, 2 },{ -2, -4, -2 },{ 2, 1, -1 },{ -1, -2, -3 },{ 2, -1, 1 },{ 0, 2, -3 },{ 1, 3, 3 },{ -1, -2, 1 },{ -2, -4, 0 },{ 3, 3, 2 },{ 2, -3, 1 },{ -2, -1, -2 },{ 1, 0, -4 },{ -1, 2, -3 },{ 3, -4, -2 },{ 0, -3, -4 },{ 2, 2, 3 },{ -1, 0, 1 },{ -3, -2, -3 },{ 0, 3, -2 },{ 2, -4, 1 },{ -2, 1, -2 },{ -4, -1, 3 },{ 0, -2, 0 },{ -1, -4, 1 },{ 2, 2, 3 },{ -4, 3, 1 },{ 3, 2, 2 },{ -3, -1, -3 },{ 1, 1, -2 },{ -2, -3, 2 },{ 0, 0, 0 } },
+		{ { 0, -4, 1 },{ 1, 0, -3 },{ -2, -1, 0 },{ -1, 1, 3 },{ 2, -2, -4 },{ -1, 3, -2 },{ -2, 0, 3 },{ 0, 1, 1 },{ 2, 0, -2 },{ -4, -3, -4 },{ -1, 0, 3 },{ 0, -3, -1 },{ 1, -1, -3 },{ -2, 3, 2 },{ 2, 0, 0 },{ 1, -3, 2 },{ 2, 3, -3 },{ -1, -2, 0 },{ -3, 2, -1 },{ 0, -1, -4 },{ -2, -4, 3 },{ -1, -2, -2 },{ 0, 0, -2 },{ 3, 1, -4 },{ -1, -2, -3 },{ -2, -1, -1 },{ 0, 0, 2 },{ 2, -4, -1 },{ 3, -2, -3 },{ 1, -4, 0 },{ 3, 0, 0 },{ -4, -1, -3 },{ 1, 2, -1 },{ -2, -1, 3 },{ 0, 3, -4 },{ -4, 0, 3 },{ -2, -4, -2 },{ -3, -2, -1 },{ 2, 1, 1 },{ -4, -1, -1 },{ 1, 2, -4 },{ 0, 2, -3 },{ -1, 0, -1 },{ -2, 1, 2 },{ 1, -4, -1 },{ -4, -2, 2 },{ -3, 0, -2 },{ -2, 1, 2 },{ -4, 3, -3 },{ -1, -4, -1 },{ 3, 2, -1 },{ -3, 1, -4 },{ -1, -2, 0 },{ 1, -3, 2 },{ -3, 3, -4 },{ -2, 0, 0 },{ -3, -3, -1 },{ 1, 0, -4 },{ 0, -3, -1 },{ 2, -1, 0 },{ -1, -4, -4 },{ 2, 2, 3 },{ 3, -3, -1 },{ -4, -1, -2 } },
+		{ { 2, 2, 0 },{ 3, 3, 2 },{ -3, -3, -2 },{ 3, -1, 1 },{ -4, -4, -1 },{ 1, -2, -2 },{ -3, -1, 2 },{ 2, -4, -1 },{ -2, 1, 2 },{ 3, 3, -3 },{ -2, 3, -1 },{ -3, 1, 2 },{ -4, -2, 1 },{ 3, 2, -2 },{ -1, -4, -2 },{ 0, 3, -1 },{ -4, -2, 3 },{ 3, -4, 1 },{ 2, 1, 2 },{ 1, 0, -1 },{ -4, 3, 0 },{ -3, -3, -3 },{ 1, -1, 3 },{ -1, -3, 1 },{ -4, 3, 2 },{ 3, 1, -4 },{ -3, 2, 3 },{ 1, 0, 1 },{ -4, 3, 2 },{ -2, 1, -2 },{ 0, 3, -4 },{ -1, -4, -1 },{ -3, 1, 1 },{ 3, -2, -3 },{ 0, -4, 0 },{ 1, 3, 2 },{ 3, 1, -3 },{ -3, -3, 2 },{ 2, -4, -4 },{ -2, 0, 2 },{ 0, 0, 3 },{ -3, -3, -3 },{ 2, -2, 0 },{ -4, 1, -4 },{ 3, 3, 1 },{ 0, -2, 0 },{ 3, 2, 3 },{ 2, -1, -1 },{ 0, -2, 1 },{ 1, -3, -4 },{ 2, 0, 2 },{ -2, -1, 3 },{ -4, -4, -1 },{ 2, 2, 1 },{ 3, -2, -4 },{ 1, 2, 2 },{ 3, 1, -3 },{ -4, -1, 1 },{ -2, 0, -2 },{ -1, -4, -3 },{ 0, 1, -1 },{ -3, 1, 1 },{ -2, 3, -4 },{ 1, -2, 2 } },
+		{ { -4, 1, -4 },{ -1, 0, 3 },{ 1, -4, -1 },{ 0, 2, -4 },{ -2, 0, 2 },{ 3, 1, -3 },{ -3, 3, 0 },{ 0, 2, -4 },{ -4, -3, 1 },{ -1, -2, 0 },{ 0, -4, -2 },{ 2, 1, -4 },{ -1, -3, 0 },{ 2, -1, 3 },{ -3, 0, -4 },{ -3, -3, 2 },{ -2, 1, -4 },{ 0, 0, -2 },{ -2, -3, -3 },{ -1, 2, 1 },{ 3, -2, 2 },{ 1, 1, -4 },{ 2, 3, 0 },{ -2, 2, 1 },{ 2, -1, -1 },{ 0, -4, -2 },{ -3, -3, 0 },{ -1, 2, -2 },{ 2, -2, -4 },{ -2, -3, 2 },{ -4, 2, 3 },{ 2, -2, 2 },{ 1, -3, -4 },{ -3, 0, 2 },{ -2, 2, 0 },{ -4, -3, -1 },{ -1, -1, -4 },{ 0, 2, 0 },{ -1, 3, 0 },{ -2, 3, -2 },{ 3, -3, 0 },{ -4, -4, 1 },{ -2, 3, 3 },{ 0, -1, -1 },{ -1, -3, -2 },{ -3, 3, -3 },{ -2, -4, 1 },{ -4, 0, -4 },{ -1, -1, 3 },{ -3, -4, 0 },{ -4, 3, -2 },{ 1, 1, 1 },{ 3, -1, -3 },{ -1, 3, -2 },{ -4, 0, 3 },{ -1, -3, -1 },{ 2, -4, 2 },{ 0, 3, 3 },{ -3, 3, -2 },{ 1, -2, 3 },{ -4, -2, 2 },{ 3, 0, 1 },{ -1, -2, -3 },{ -3, -4, -2 } },
+		{ { 3, -3, 2 },{ -2, -2, -2 },{ 2, -2, -3 },{ -4, 2, 3 },{ -1, -1, 1 },{ 2, -4, 0 },{ -1, 0, 3 },{ 2, -3, -4 },{ 3, 0, -1 },{ -3, -1, 3 },{ 1, 2, 2 },{ 3, -1, 1 },{ -4, 3, -3 },{ 0, -4, -1 },{ -2, 2, -3 },{ 1, 1, 0 },{ -1, -1, 1 },{ 2, 3, -3 },{ -3, -4, 3 },{ 2, -1, -2 },{ -4, -1, -2 },{ 0, 1, 1 },{ -3, -3, -1 },{ -4, -4, -4 },{ -1, -2, -2 },{ 3, 3, 2 },{ -4, 1, -3 },{ 2, -2, 1 },{ -1, -1, 0 },{ 3, -4, -1 },{ 0, 1, 0 },{ -2, 0, -3 },{ 2, 3, -2 },{ -1, -1, 3 },{ 2, -2, -2 },{ 3, 2, 1 },{ 1, 0, 2 },{ 2, -3, -3 },{ -4, -1, 3 },{ 3, -2, -4 },{ 1, 1, -2 },{ 1, 1, -2 },{ 3, -2, -4 },{ -3, -4, 2 },{ 2, -1, 3 },{ 1, 1, -3 },{ 2, -3, 0 },{ -1, 1, -2 },{ 2, 3, 2 },{ 3, 2, -3 },{ 0, 0, 0 },{ -1, -2, -4 },{ -3, -3, 2 },{ 0, 0, -1 },{ -2, -4, -2 },{ 0, 2, 0 },{ -4, -1, -3 },{ -2, -2, 0 },{ 3, 1, -4 },{ 3, 2, 1 },{ -2, -3, 0 },{ 0, 3, -2 },{ 2, -1, 3 },{ -1, 2, 0 } },
+		{ { -4, 3, 1 },{ 0, 0, 0 },{ -1, 1, -1 },{ -3, 3, -2 },{ 1, -3, -4 },{ -3, -2, -2 },{ 0, 2, 2 },{ -2, -1, 1 },{ 1, -2, -2 },{ -2, 3, -3 },{ 2, -4, 0 },{ -3, -2, -4 },{ 0, 0, -1 },{ -2, 1, 3 },{ 3, -2, 1 },{ 1, -4, -2 },{ 3, -3, 3 },{ -4, 2, 0 },{ -3, -2, -4 },{ 0, 2, 0 },{ -2, -2, -1 },{ 3, -4, 3 },{ -2, 0, -3 },{ 2, 2, 3 },{ 1, 0, 2 },{ 1, 0, 0 },{ -2, -3, -4 },{ 1, 2, 3 },{ -3, 0, -3 },{ -3, 3, -3 },{ 1, -1, -2 },{ -4, -3, 1 },{ -1, 2, 1 },{ -4, -4, -4 },{ -2, 0, -1 },{ -3, 1, -3 },{ -2, -3, 3 },{ -3, 1, -2 },{ 0, -2, -1 },{ -1, -4, 1 },{ -4, -1, 2 },{ -1, 2, 0 },{ 0, 0, 1 },{ -1, 2, -4 },{ -4, 0, -1 },{ -2, 2, 2 },{ 0, -2, -1 },{ -4, 2, -4 },{ 1, -1, 2 },{ -3, -3, -1 },{ 1, -4, 1 },{ 2, 2, -3 },{ 1, 1, 3 },{ 3, -2, 0 },{ -3, 0, 1 },{ 2, 2, -4 },{ 2, -2, -1 },{ -3, -3, 2 },{ -1, -1, -1 },{ 1, 0, -4 },{ -4, -4, -3 },{ -3, 1, 1 },{ 2, 2, -4 },{ 1, -1, -1 } },
+		{ { -2, 1, -2 },{ 3, -3, -4 },{ -2, -4, 3 },{ 3, 0, 1 },{ 1, -3, 2 },{ 2, 1, -3 },{ -4, 3, -1 },{ -4, -4, -1 },{ 0, 1, 2 },{ -3, 2, -2 },{ -1, 1, 0 },{ -4, -1, 3 },{ 1, -3, -2 },{ 2, 2, 2 },{ -3, 3, -4 },{ -4, -1, -2 },{ -1, 0, -1 },{ 1, 3, 2 },{ 1, 1, 1 },{ -1, -4, 2 },{ 2, 0, -2 },{ 1, 3, -4 },{ -4, 2, 1 },{ -1, -1, 0 },{ -3, -2, -2 },{ -2, 1, 3 },{ -4, -1, -1 },{ 0, 3, 1 },{ 3, -4, 2 },{ -2, -2, 2 },{ 2, 1, 3 },{ 3, -4, -1 },{ 0, 0, -3 },{ 1, 2, 2 },{ 3, -2, -1 },{ 1, -4, -2 },{ 0, 3, 1 },{ 3, 0, 2 },{ 2, 2, -3 },{ -2, 3, 2 },{ 1, 0, -3 },{ -3, -3, 3 },{ -3, -3, -2 },{ 3, 3, 1 },{ 1, -4, 0 },{ -2, -2, -3 },{ 3, 3, 0 },{ -3, -4, 3 },{ -1, -3, -1 },{ -2, -2, -3 },{ -4, 1, 3 },{ -2, -1, -1 },{ -4, -4, -2 },{ -1, 3, -4 },{ -3, 1, 2 },{ 0, -3, 3 },{ 3, 3, -3 },{ -4, 1, 1 },{ 1, -4, 3 },{ 0, 3, 0 },{ 2, -1, -1 },{ -1, -3, 2 },{ -2, -3, -3 },{ 0, -4, 2 } },
+		{ { -3, -2, -4 },{ 2, 2, 2 },{ 0, 3, -3 },{ -4, -1, 0 },{ -1, -1, -1 },{ -2, 2, 3 },{ 3, 0, -4 },{ 2, -1, 1 },{ 1, -3, 3 },{ 3, 0, -4 },{ -2, -3, 1 },{ 3, 3, -1 },{ -4, 0, -3 },{ 1, -4, 1 },{ -1, -2, 0 },{ -2, 0, 3 },{ 0, -3, -4 },{ 2, -1, 0 },{ -4, 0, -3 },{ 3, -3, -3 },{ -2, 2, 2 },{ -3, -1, 1 },{ 2, -3, -1 },{ 0, -3, -3 },{ 3, 3, -4 },{ -1, -4, 1 },{ 3, -3, -3 },{ 2, 0, -4 },{ -1, -2, -2 },{ -4, 1, 0 },{ -1, 3, -4 },{ 0, -3, 0 },{ -3, 1, 1 },{ -3, -1, 3 },{ -1, 3, 0 },{ -1, -1, 1 },{ 2, -4, -4 },{ -3, 0, 0 },{ -4, -1, -4 },{ -1, -4, 0 },{ 3, 1, -1 },{ 2, -1, -3 },{ -1, -2, -1 },{ 2, -3, 2 },{ -4, 0, -2 },{ -1, 1, 3 },{ 2, -1, 1 },{ 0, 0, -4 },{ 3, 1, -2 },{ -1, 3, -4 },{ 2, 0, 0 },{ 3, 3, 3 },{ -1, -3, 0 },{ 1, -1, -3 },{ 1, 0, -1 },{ -1, -4, -3 },{ -2, -3, 0 },{ -1, 0, -2 },{ 2, 2, -3 },{ -2, -2, -2 },{ -3, 2, 3 },{ 3, 0, -1 },{ 1, 1, -2 },{ -4, 0, 3 } },
+		{ { -1, -1, 0 },{ 1, -3, -1 },{ -4, 1, -2 },{ 3, -4, 2 },{ 1, 2, -4 },{ -3, -4, 0 },{ 0, -3, -2 },{ -1, -2, -3 },{ -3, 3, 1 },{ -1, -1, -1 },{ 2, -4, -3 },{ 0, -2, 3 },{ -2, 2, 2 },{ -1, -1, -1 },{ 3, 1, -3 },{ 0, 2, 2 },{ 2, 3, -2 },{ -2, -4, -1 },{ -3, -2, -1 },{ 0, -2, 3 },{ -4, 3, 0 },{ -1, -4, -2 },{ 1, 0, 2 },{ -2, 1, -2 },{ 2, 3, 0 },{ -4, 0, 3 },{ 0, 2, -2 },{ 1, -1, -1 },{ -3, -3, 2 },{ 2, 2, -1 },{ 1, -1, 1 },{ -3, 0, -4 },{ 2, -2, -2 },{ 3, 1, -3 },{ 1, -3, -4 },{ -4, 2, 3 },{ -4, -2, -1 },{ -1, 3, 3 },{ 1, -3, -2 },{ -2, -3, 3 },{ 0, 2, 1 },{ -4, 3, -4 },{ -2, -1, 3 },{ 0, 1, -4 },{ 1, 3, -1 },{ -3, -2, -3 },{ -2, -3, -2 },{ 1, 3, 1 },{ -4, -4, 2 },{ 0, -2, 1 },{ -3, 2, 2 },{ 0, -3, -4 },{ -3, 1, -2 },{ 3, -2, 1 },{ -4, -1, 3 },{ 2, 2, -2 },{ -3, 0, 2 },{ 1, -1, 3 },{ -4, 3, -4 },{ -3, -3, 2 },{ -1, -1, -4 },{ 1, 1, 0 },{ -4, -2, 1 },{ 3, 3, 1 } },
+		{ { -1, -1, -3 },{ -3, -2, 2 },{ 2, 2, 1 },{ 0, 0, -3 },{ -3, -2, -2 },{ -2, 3, 2 },{ 1, 0, 3 },{ 3, 2, 0 },{ -3, -1, -3 },{ -2, 1, 2 },{ -4, 3, 0 },{ 1, 1, -4 },{ 3, -1, -2 },{ -3, -4, 0 },{ 2, -3, 1 },{ -4, 1, -3 },{ -3, -2, 3 },{ -1, 2, 2 },{ 3, 1, -4 },{ 1, 1, 1 },{ 2, -1, -3 },{ 3, 0, -4 },{ -1, -3, 3 },{ -4, -2, 1 },{ -3, -1, -1 },{ 0, 1, 0 },{ -2, -4, 2 },{ -4, -2, 1 },{ -2, 3, -3 },{ 0, 0, 3 },{ 3, -4, -3 },{ -2, -2, -1 },{ -4, 2, 3 },{ 0, -4, 2 },{ -2, 1, -2 },{ 0, 0, -1 },{ 3, 1, -3 },{ 2, 2, 2 },{ 0, -1, 1 },{ -3, 1, -2 },{ 1, -2, 0 },{ 2, -4, 2 },{ 0, 1, -3 },{ 3, -4, 1 },{ -1, 0, 0 },{ 2, 2, 3 },{ -4, -3, -3 },{ 3, -1, 0 },{ -3, 1, -1 },{ 2, -1, -3 },{ 1, -4, -1 },{ -2, 0, 1 },{ 0, 3, 0 },{ 2, -4, -3 },{ -2, 2, 1 },{ 3, 3, 0 },{ 0, -2, -4 },{ -1, -4, 1 },{ 3, 1, -1 },{ 3, -3, 1 },{ 2, -4, 2 },{ -1, 3, -4 },{ 0, -4, -3 },{ 2, 2, -2 } },
+		{ { -3, -4, 3 },{ 3, 1, -4 },{ -2, 0, 0 },{ 0, -3, 3 },{ -1, 1, -1 },{ 2, -1, 0 },{ 0, 1, 1 },{ -4, -4, -4 },{ 1, 2, -1 },{ 0, -2, -2 },{ 2, -3, 3 },{ -3, -2, 1 },{ 0, 3, -3 },{ -4, 0, 3 },{ -2, 2, -2 },{ 1, -2, -4 },{ 3, -4, 1 },{ 1, -1, 0 },{ -4, 3, -2 },{ 0, -3, 2 },{ -2, 2, 0 },{ -3, 2, -1 },{ 2, 3, 2 },{ 1, 2, -4 },{ 3, -4, -3 },{ 2, -2, 3 },{ 1, 3, -4 },{ -3, 1, -1 },{ 3, -4, 0 },{ 1, 2, -2 },{ -4, -1, 2 },{ -1, 3, 0 },{ 2, 3, 1 },{ -1, 0, 0 },{ 2, -3, -2 },{ -3, -1, 1 },{ 1, -4, -4 },{ -2, -2, -1 },{ 3, 2, -3 },{ -4, 3, -4 },{ -1, -2, -1 },{ -3, 0, -2 },{ -3, 2, 0 },{ -2, -1, 2 },{ -4, -2, -2 },{ 3, -4, 0 },{ 0, 1, 2 },{ -1, 0, -4 },{ -1, 2, 3 },{ -4, -3, -3 },{ -2, 0, 2 },{ 2, 2, -4 },{ -4, -2, 3 },{ -2, 0, 2 },{ -4, -3, -4 },{ -1, -3, -2 },{ -3, 1, -1 },{ 1, -2, 2 },{ -2, 2, -3 },{ 0, 0, -1 },{ -4, 2, -2 },{ -3, 0, 3 },{ -2, -2, -1 },{ 1, -3, 2 } },
+		{ { 0, 2, 3 },{ 1, 3, -1 },{ -2, -2, -2 },{ -4, -3, 1 },{ 2, 3, 2 },{ 3, -4, -3 },{ -4, -2, -2 },{ -2, -3, 2 },{ -1, 3, 2 },{ 3, -4, -2 },{ -2, 0, 0 },{ -1, 0, 2 },{ 1, -4, -4 },{ 2, -1, 2 },{ -2, 3, 0 },{ -1, 0, -4 },{ 0, -3, -1 },{ -1, 0, 3 },{ -2, 0, -2 },{ 2, -4, -3 },{ -3, -3, 3 },{ -4, -1, -1 },{ 0, -4, -2 },{ -1, 0, 1 },{ -2, -3, 0 },{ -3, 2, -2 },{ -1, -1, -3 },{ 3, 0, -4 },{ -1, -2, 1 },{ -3, -3, 2 },{ 1, 1, -4 },{ 0, -4, 3 },{ -2, -1, -3 },{ -3, -3, -4 },{ 3, 2, 2 },{ -1, 3, 0 },{ -3, -2, 2 },{ -1, 0, 3 },{ 2, -4, 1 },{ -2, 0, 3 },{ 3, -4, 2 },{ 2, 3, -4 },{ 2, -3, 3 },{ -1, 3, -3 },{ 1, 0, -4 },{ -3, -2, 3 },{ 1, 2, -1 },{ 1, -3, -2 },{ 2, -2, 1 },{ 0, 3, -1 },{ 3, 1, 0 },{ -1, -3, -2 },{ 3, -1, -1 },{ 1, 1, -1 },{ 0, 3, -3 },{ 3, -1, 3 },{ 2, 0, -3 },{ -4, 3, 0 },{ -3, -3, -2 },{ 0, 1, 3 },{ 2, -2, 0 },{ 1, 3, -3 },{ 3, 0, 1 },{ -4, 1, -4 } },
+		{ { 2, 0, -2 },{ -4, -4, -3 },{ 3, 3, -3 },{ 1, -1, 0 },{ -3, 2, -4 },{ -2, 0, -4 },{ 1, 2, 0 },{ 2, 1, -1 },{ -3, -1, 3 },{ 0, -1, -3 },{ -4, 2, -4 },{ 3, 1, -1 },{ -2, 2, -3 },{ 0, -3, -2 },{ 3, -4, 1 },{ 2, 1, 0 },{ -3, 3, 2 },{ -4, -3, -3 },{ 2, 2, 1 },{ 0, 0, 1 },{ -1, -2, -4 },{ 1, -2, -2 },{ 3, 1, 2 },{ -4, 0, -3 },{ 1, 1, 3 },{ 0, -3, 1 },{ 2, 1, 0 },{ -4, -3, 2 },{ 0, 2, 3 },{ 2, 3, -1 },{ -3, 0, -2 },{ 3, -2, -3 },{ 1, -2, 1 },{ -4, 1, -1 },{ 2, 0, 3 },{ -2, -4, -3 },{ -4, 2, -2 },{ 1, -3, -3 },{ 0, 1, -1 },{ 0, -1, 0 },{ -4, 0, -2 },{ -1, -3, 1 },{ 0, -1, -3 },{ -3, 1, -1 },{ 3, 3, 2 },{ 0, 1, 1 },{ -4, -1, -3 },{ -3, 3, 0 },{ -2, -4, 2 },{ -3, 0, -4 },{ -4, -4, 3 },{ 0, -2, -3 },{ -3, 2, 2 },{ -1, -4, 0 },{ 2, 2, 3 },{ -2, -2, 0 },{ -1, -4, 1 },{ 1, 0, 2 },{ 3, -4, -4 },{ -1, -1, 1 },{ -3, -2, -4 },{ 3, -3, 2 },{ -2, -1, 0 },{ -1, -3, 0 } },
+		{ { -3, -2, 1 },{ -1, -1, 2 },{ -3, 0, 1 },{ 0, 1, 2 },{ -1, -2, -1 },{ -4, -3, 3 },{ 1, 3, 2 },{ 0, -3, -3 },{ 3, 0, -4 },{ -2, 3, 1 },{ 2, -3, 1 },{ 0, -1, -1 },{ -4, -2, 3 },{ -3, 2, 1 },{ -1, -1, -1 },{ -4, 1, 3 },{ 3, -1, -2 },{ 1, 2, -4 },{ -1, -2, -1 },{ -3, 3, 2 },{ 3, 1, -3 },{ -2, -1, 3 },{ 2, 3, 1 },{ -3, -3, -2 },{ 3, -1, -1 },{ -2, 3, -4 },{ -4, -4, 2 },{ 0, -2, -2 },{ 1, -1, -3 },{ -2, -1, 1 },{ -4, -3, 0 },{ -1, 2, 0 },{ -2, 3, -1 },{ 1, 0, -3 },{ 1, -2, 2 },{ 0, -1, 0 },{ 3, 3, -1 },{ 2, 1, -4 },{ -3, 3, 0 },{ -2, -2, -3 },{ 1, 2, -3 },{ 0, 1, 1 },{ 3, -4, 3 },{ -4, -2, -1 },{ -1, -4, 0 },{ -2, -3, -2 },{ 2, -1, -4 },{ -1, 1, 1 },{ 3, -2, -1 },{ 1, 1, -2 },{ 2, -1, 0 },{ -1, 3, 1 },{ 1, 0, -3 },{ -4, -3, -4 },{ -3, -2, 1 },{ 0, 1, -2 },{ -4, 3, -4 },{ -1, -1, -1 },{ 2, 2, -1 },{ -4, 2, 1 },{ -1, 3, 3 },{ 0, -4, -2 },{ -4, 1, -2 },{ 2, 3, -1 } },
+		{ { 1, 2, 3 },{ -1, -4, -4 },{ 3, -3, -1 },{ 2, 2, 3 },{ 1, -4, -2 },{ -1, 0, 0 },{ 3, -1, -2 },{ -3, -2, 1 },{ -4, -4, 0 },{ 1, 2, -2 },{ 1, -2, 3 },{ -3, -4, 2 },{ 3, 0, 0 },{ 1, 3, -3 },{ 1, -2, -4 },{ -2, -4, -2 },{ 0, -1, 0 },{ -3, -4, 3 },{ 3, -3, 0 },{ -2, 2, -2 },{ 0, -4, 0 },{ -4, 2, -1 },{ -2, -4, -4 },{ 0, 2, 3 },{ -1, -2, 0 },{ 2, 0, -3 },{ -3, 2, 1 },{ 2, 3, -1 },{ -2, 1, -4 },{ 3, 1, -1 },{ 0, -4, 3 },{ 2, 2, 2 },{ -4, -4, 3 },{ 0, -3, -2 },{ -3, 2, -4 },{ -2, -4, 1 },{ -4, -2, 2 },{ 1, -1, 3 },{ -1, -3, 1 },{ 3, -4, 3 },{ -3, -2, 2 },{ -2, 3, -2 },{ 2, -1, 0 },{ -3, 2, -4 },{ 1, -3, 3 },{ -2, 2, -3 },{ 3, -1, 0 },{ -4, -4, 3 },{ 1, 2, -3 },{ -2, -3, 2 },{ 0, 2, -4 },{ -2, -2, 2 },{ 3, 1, -1 },{ 1, -4, 3 },{ 2, 0, -2 },{ 0, 1, -3 },{ 3, -3, 2 },{ -3, -2, 3 },{ -2, 0, -2 },{ 1, -3, -3 },{ -2, 1, -1 },{ 0, 0, -3 },{ 1, 0, 3 },{ -2, -3, -4 } },
+		{ { -4, 1, 0 },{ 0, 1, -2 },{ -2, 3, 1 },{ -2, -2, -4 },{ -4, 0, -3 },{ 3, 3, 1 },{ -2, -1, -3 },{ -3, 1, -1 },{ -1, 1, 3 },{ -1, -2, -3 },{ -3, 3, -4 },{ -2, 1, -2 },{ -1, -3, -2 },{ -2, 0, 2 },{ -3, 2, 3 },{ 2, -3, -3 },{ -1, 3, 1 },{ 0, 0, -1 },{ 2, -1, -4 },{ -4, 1, 1 },{ 1, -3, 2 },{ 2, 0, -4 },{ 3, -2, 0 },{ 0, 0, 1 },{ -4, 1, -2 },{ 3, -4, -1 },{ 0, -1, 3 },{ -1, -2, 2 },{ -3, -4, 0 },{ -4, -3, -3 },{ 0, 0, -4 },{ 1, 1, -2 },{ 3, -1, -4 },{ -3, 3, 0 },{ 2, 1, 3 },{ 3, 0, -3 },{ -1, 1, -2 },{ 2, -1, -4 },{ -4, 3, 1 },{ 0, 0, -1 },{ -1, 0, -4 },{ 1, -3, -1 },{ -4, 1, 0 },{ 0, 0, 2 },{ 2, 0, -2 },{ 0, 1, 1 },{ 2, 3, -1 },{ 0, 0, 2 },{ -1, -1, -2 },{ -4, 0, -3 },{ 3, 3, 1 },{ -3, -4, -1 },{ -1, 0, -2 },{ -4, 3, -1 },{ -2, 2, 2 },{ -1, -1, 0 },{ -4, 3, -3 },{ 2, -4, 1 },{ 0, 2, 0 },{ 3, -1, 0 },{ 2, -4, 1 },{ -4, -2, 2 },{ 2, 2, 0 },{ 3, -2, 1 } },
+		{ { 1, -1, -1 },{ 2, 2, -3 },{ -3, -1, 2 },{ 1, -3, 0 },{ -4, 1, 0 },{ 0, -3, 3 },{ 0, 2, 2 },{ 2, -4, -4 },{ 3, -3, 2 },{ 0, 2, 0 },{ 2, -1, 2 },{ 3, -1, 0 },{ 0, 3, -4 },{ 0, -4, -1 },{ 3, -2, 2 },{ -4, 0, 1 },{ 1, 1, -4 },{ -4, 3, 3 },{ 2, -2, 1 },{ -3, -2, -3 },{ -1, 1, 2 },{ -2, 3, -2 },{ -3, -1, -3 },{ 1, 1, 3 },{ -1, -3, 2 },{ -2, 3, -3 },{ -3, 2, -4 },{ 1, 0, -2 },{ 3, -1, 3 },{ 2, 2, 1 },{ -3, 3, 2 },{ -2, -2, 1 },{ -1, -2, -2 },{ -4, -1, 1 },{ 0, -3, 2 },{ -2, -2, -1 },{ -3, -4, 1 },{ 0, 2, 0 },{ -2, -3, -2 },{ 2, 1, -3 },{ 3, 2, 0 },{ -2, -2, 3 },{ -1, -4, -4 },{ 3, 3, -3 },{ -3, -2, 3 },{ -3, -3, 1 },{ -4, -4, -4 },{ -3, 3, -4 },{ 0, -2, 0 },{ 2, -4, 3 },{ -3, -3, -2 },{ 2, -1, 0 },{ 0, -1, 3 },{ -2, -3, -4 },{ 3, -2, 1 },{ 2, -4, -1 },{ -2, 1, -4 },{ 1, 0, 3 },{ -1, -3, -3 },{ -3, 3, -4 },{ -3, -1, 3 },{ 0, 1, -2 },{ -2, 3, -4 },{ -3, -4, -3 } },
+		{ { -1, -3, 3 },{ 3, -2, 2 },{ -1, -4, -2 },{ 2, 3, 3 },{ 1, -1, -2 },{ -3, -4, -4 },{ -1, -1, -1 },{ -4, 3, 1 },{ -2, 0, -2 },{ 2, 0, -1 },{ -4, -4, 1 },{ -2, -3, 3 },{ -4, 1, -1 },{ 2, -2, -3 },{ 2, 2, 0 },{ -1, 1, -2 },{ -3, -3, -1 },{ 3, -4, 2 },{ -1, 0, -2 },{ 1, -1, -3 },{ 3, 2, 3 },{ 0, -4, 0 },{ 2, -2, 0 },{ -4, 3, -4 },{ 3, -3, -1 },{ 1, -1, 0 },{ 2, -2, 1 },{ -4, -3, 0 },{ -1, 2, -2 },{ -1, -4, -1 },{ -3, -1, -3 },{ 3, 2, -1 },{ 2, -4, 0 },{ 1, 1, -4 },{ 3, 3, -1 },{ -4, 0, -3 },{ 1, 3, 3 },{ 3, 0, -4 },{ -1, -2, 3 },{ -3, -4, -3 },{ -4, -1, 2 },{ 1, 2, 1 },{ -3, -4, 1 },{ 2, -1, -1 },{ 0, 2, -2 },{ -1, -2, 0 },{ 1, -1, -2 },{ 3, -3, 3 },{ -2, 2, 0 },{ 1, 1, 1 },{ 1, 2, -4 },{ -2, 1, 2 },{ -1, 3, -3 },{ 1, 0, 1 },{ 1, 0, 0 },{ -3, 3, 3 },{ 0, -1, -2 },{ -2, -2, -1 },{ -4, 2, 2 },{ 1, 1, 0 },{ -2, 0, -4 },{ 3, -4, -1 },{ -1, 2, 1 },{ -4, -1, 2 } },
+		{ { -2, 3, -4 },{ -3, 0, 0 },{ 0, 2, -1 },{ -1, 1, -4 },{ -2, 0, -1 },{ 2, 2, 0 },{ 3, -2, 2 },{ 1, 1, -3 },{ -3, -2, 3 },{ -1, -3, -2 },{ 0, 2, -4 },{ 1, 1, -3 },{ -3, -1, 1 },{ -1, 3, 3 },{ -4, -3, 0 },{ -2, -1, -4 },{ 1, -4, -3 },{ 0, 2, 0 },{ -3, 3, 0 },{ -2, -4, -4 },{ 0, 2, -1 },{ -4, -3, -2 },{ -3, -2, 2 },{ -1, 0, 1 },{ -3, 2, -2 },{ -2, -4, 1 },{ 0, 0, 2 },{ -2, 1, -3 },{ 2, 3, -4 },{ 0, 0, 1 },{ 1, 1, 0 },{ 0, -3, 3 },{ -4, 0, 2 },{ -2, 2, 3 },{ -1, -4, -3 },{ 0, -3, 1 },{ 2, -1, 0 },{ -4, -3, -1 },{ 1, 1, 1 },{ 0, 2, 2 },{ 2, -2, -1 },{ -1, 3, -2 },{ -4, 0, -3 },{ 0, 1, 2 },{ -2, 2, 3 },{ 3, -4, -4 },{ -1, 1, 2 },{ 2, 0, -1 },{ -3, 3, -3 },{ -1, -2, -2 },{ -4, 0, -1 },{ 0, -2, 3 },{ -4, -4, -2 },{ -3, 2, -3 },{ 3, -2, 2 },{ -4, -3, -4 },{ 2, 1, 1 },{ 3, -4, 2 },{ 3, -2, -3 },{ -1, -3, -2 },{ 2, 2, 2 },{ 1, -2, -3 },{ 0, -3, 0 },{ 2, 0, -2 } },
+		{ { -2, -4, -1 },{ 1, 2, -4 },{ -4, -1, 1 },{ 3, -3, 2 },{ -3, -2, 1 },{ 2, 0, 3 },{ -4, 3, -3 },{ 0, -4, 0 },{ 3, -1, -4 },{ 1, 3, 2 },{ 2, 2, 0 },{ -2, -2, 3 },{ 3, -4, -2 },{ 0, 2, -3 },{ 1, 0, 1 },{ -2, 3, 3 },{ 3, -2, -1 },{ -1, 0, 3 },{ 2, -3, -2 },{ -4, -1, 1 },{ -1, 1, 3 },{ 3, 3, -1 },{ 1, 0, -4 },{ 2, 1, 3 },{ 0, 1, -3 },{ 0, -2, -4 },{ -4, 3, 3 },{ 3, -1, -1 },{ -2, -3, 2 },{ -4, -2, 3 },{ -1, -3, -2 },{ 3, 3, -4 },{ -3, -2, -3 },{ -2, 0, 1 },{ 2, -1, -2 },{ -1, 2, -4 },{ -3, 1, 2 },{ -2, 3, -2 },{ 2, -4, 0 },{ -1, 3, -3 },{ -3, 0, -4 },{ 1, -3, 3 },{ 3, -3, 0 },{ 2, 1, -4 },{ -4, -3, -1 },{ 1, 0, -3 },{ -2, 3, 0 },{ -4, -4, 1 },{ 0, -1, 3 },{ 3, -4, 2 },{ -2, 0, -4 },{ 2, -3, 1 },{ 3, 1, -1 },{ 0, -4, 0 },{ -1, 2, 2 },{ -2, 1, -4 },{ -1, -1, -2 },{ -3, 2, 0 },{ 1, 3, 1 },{ -4, -1, 3 },{ -3, 1, 1 },{ -3, -1, 0 },{ -4, 3, 3 },{ 3, 1, -2 } },
+		{ { 0, -3, 1 },{ 2, -2, 3 },{ -4, 1, -3 },{ -1, -4, -2 },{ 0, 3, -3 },{ -2, -3, -4 },{ -1, 1, -1 },{ -3, -3, 2 },{ -1, 1, -1 },{ -3, -2, 1 },{ -4, -4, -3 },{ -1, 0, -1 },{ 2, 0, 0 },{ -3, -3, 2 },{ -1, -4, -2 },{ 2, -1, -4 },{ -4, 1, 1 },{ -3, 0, 2 },{ 1, 2, -1 },{ 2, -2, -4 },{ -1, 0, 1 },{ 1, -4, 2 },{ -2, -3, -3 },{ -4, -4, -1 },{ 3, 3, -1 },{ 1, -3, 2 },{ 2, 1, -2 },{ -3, -4, 0 },{ 1, 2, -4 },{ 2, -1, 2 },{ -4, 1, -3 },{ 0, 2, -1 },{ 2, -4, 0 },{ 0, -2, -2 },{ -4, 3, 3 },{ -3, -3, 0 },{ 3, -2, -3 },{ 0, -1, 3 },{ -4, 0, -2 },{ 3, -1, 1 },{ -2, -3, -1 },{ -2, 1, 3 },{ -3, -2, 0 },{ 0, 3, -2 },{ -1, -1, 1 },{ -3, -2, 2 },{ 0, 2, -1 },{ 3, 1, -4 },{ 1, -3, -3 },{ -3, 2, 0 },{ 2, 3, -2 },{ -3, -1, 0 },{ -2, 2, -4 },{ 1, -1, 3 },{ 2, -3, -1 },{ -4, -1, -1 },{ 1, 3, -3 },{ -3, -3, 0 },{ 0, -4, -4 },{ 0, 0, -1 },{ -1, -3, -2 },{ 3, -4, -4 },{ 1, 0, -3 },{ 0, -2, 2 } },
+		{ { -3, 2, -3 },{ -1, 0, 0 },{ 3, -1, 2 },{ 1, 2, 0 },{ 2, 0, 3 },{ -4, -1, 0 },{ 1, -2, 1 },{ -2, 2, -2 },{ 3, 0, 3 },{ 1, -1, -4 },{ 2, 2, 1 },{ -2, -2, 2 },{ 0, 1, -4 },{ 3, 3, -3 },{ -4, -1, 0 },{ -2, 1, -1 },{ 2, 3, -2 },{ 0, -3, -3 },{ -2, -4, -3 },{ 3, -2, 2 },{ -3, 2, -2 },{ -3, 3, -3 },{ 2, -1, 0 },{ -1, 2, 3 },{ -2, -1, 1 },{ -4, 0, 0 },{ -1, -2, -3 },{ -1, 0, -1 },{ 0, -4, -2 },{ -2, 2, 1 },{ 2, -1, -3 },{ -3, -2, 3 },{ -2, 3, 2 },{ 1, 1, 0 },{ 1, -3, -4 },{ 2, 0, -1 },{ 0, -4, 2 },{ -4, 2, -4 },{ 1, -2, 0 },{ 0, 1, 2 },{ 2, -4, -2 },{ 1, 2, 1 },{ -4, 2, -3 },{ 1, -4, -4 },{ -2, -1, 1 },{ 3, -4, -3 },{ 2, 3, 3 },{ -4, -2, -1 },{ -2, -1, -2 },{ 1, 2, 1 },{ -1, -2, 3 },{ 0, -3, -3 },{ -4, 3, 2 },{ -2, 0, -3 },{ 3, 3, 1 },{ 0, -4, 3 },{ -1, 0, 3 },{ 2, 0, 2 },{ -2, -2, -1 },{ 2, 1, -3 },{ 3, 3, 2 },{ -2, 2, 1 },{ -1, -3, 3 },{ -4, 3, -1 } },
+		{ { 3, -4, -4 },{ -2, 3, -2 },{ 0, -3, -1 },{ -2, 1, -4 },{ -3, -2, -2 },{ 3, 2, 2 },{ 0, -4, -4 },{ 2, 3, -2 },{ -4, -3, -3 },{ 0, -4, 0 },{ -3, 3, -1 },{ 3, -3, -2 },{ -4, -1, 3 },{ 1, 2, 1 },{ -1, -2, 3 },{ 3, -4, -3 },{ 1, -3, 2 },{ -1, 2, 0 },{ -4, -1, -1 },{ 1, 3, 3 },{ 0, 1, 0 },{ -4, -3, -4 },{ 0, -1, 1 },{ 1, -2, -2 },{ -3, -3, -4 },{ 3, 2, 1 },{ 2, -2, 3 },{ -3, 3, 2 },{ 3, -2, -2 },{ 1, 0, 0 },{ -2, 3, 0 },{ -1, -4, -1 },{ 3, -1, 1 },{ -1, 0, -4 },{ -4, 2, 3 },{ -1, -1, 1 },{ 1, 1, -2 },{ -2, 3, -1 },{ 3, -3, 2 },{ -2, 3, -4 },{ -4, -1, -3 },{ -1, 0, -2 },{ 2, 3, 3 },{ 3, -2, 2 },{ -2, 0, -1 },{ -1, 2, 0 },{ 1, -3, -4 },{ -3, 0, 2 },{ -1, 1, 0 },{ 3, -4, 2 },{ -4, 1, -2 },{ 2, -1, -1 },{ 1, -4, -4 },{ -1, 0, 0 },{ 2, -3, -2 },{ -3, -2, -3 },{ 3, 1, 0 },{ -4, 3, -2 },{ -2, -3, -4 },{ -4, -1, 3 },{ 1, -2, 0 },{ -3, -4, -2 },{ 2, -1, -1 },{ 1, 1, 0 } },
+		{ { -3, 0, 2 },{ 2, -1, 3 },{ -4, 2, 1 },{ 1, -4, -1 },{ -1, 0, 3 },{ -1, -3, -1 },{ -4, -1, 1 },{ 0, 0, 2 },{ 3, -2, 2 },{ -2, 2, -4 },{ -1, 1, 3 },{ 1, -1, -1 },{ -2, 0, 0 },{ -1, -4, -3 },{ -3, 2, 1 },{ 1, -2, -4 },{ -2, 0, 3 },{ -4, 3, 0 },{ 3, 0, 1 },{ -2, -1, -4 },{ -1, 1, -1 },{ 2, -4, 2 },{ 3, 2, 3 },{ -2, 1, -3 },{ 1, 1, -1 },{ 0, 3, -2 },{ -2, -4, -3 },{ 0, -1, -4 },{ -3, 1, 1 },{ -4, -3, 3 },{ 2, -3, -3 },{ 0, 0, -4 },{ -4, -2, 2 },{ -3, -4, -2 },{ 3, 2, -3 },{ -2, 0, 0 },{ -3, -3, 3 },{ -1, 0, -3 },{ 2, -2, -1 },{ -3, -2, 3 },{ -1, 1, 0 },{ 3, -4, -1 },{ 0, -2, 0 },{ -4, -3, -2 },{ -1, 1, 2 },{ -4, 3, -2 },{ 0, -2, 1 },{ 2, -4, 3 },{ -2, 0, -3 },{ 0, 3, -4 },{ -4, -3, -1 },{ -1, -2, 2 },{ 3, 1, 1 },{ -2, 0, 2 },{ -4, 2, -1 },{ -2, 2, -4 },{ 0, -2, 2 },{ 1, -4, 1 },{ 3, 2, 0 },{ -1, 3, 3 },{ 1, 0, -4 },{ -3, 1, 2 },{ -1, 2, -4 },{ 0, -2, 0 } },
+		{ { -1, -4, 1 },{ 1, -3, -3 },{ -4, -2, 0 },{ 3, 3, -4 },{ 0, -1, 2 },{ -3, 3, -3 },{ 3, 1, -3 },{ -2, 0, -1 },{ -3, -3, 0 },{ -1, 1, -3 },{ 1, -4, 1 },{ -3, -2, 2 },{ 2, 3, -4 },{ 2, -3, -2 },{ 0, 1, 2 },{ -3, 3, -1 },{ 0, 1, -2 },{ 3, -4, -4 },{ 0, -3, 3 },{ 1, -2, -2 },{ 2, -4, -3 },{ -4, 3, 1 },{ -2, 0, -1 },{ -1, -2, 0 },{ -4, -4, 2 },{ 2, 0, 3 },{ -4, -3, 1 },{ 1, 2, -1 },{ 3, 3, 2 },{ 0, -1, -4 },{ -2, 2, 2 },{ 3, 1, -2 },{ 1, 3, -1 },{ -3, -2, 1 },{ 0, -3, -1 },{ 2, 3, 2 },{ 3, -4, -4 },{ -4, 1, 1 },{ 0, -4, -3 },{ 2, 2, 1 },{ 0, 1, 2 },{ -2, -1, -4 },{ -3, 3, 1 },{ 1, 0, -3 },{ 2, -1, 3 },{ 3, -3, -4 },{ 1, 1, -2 },{ -4, 2, 0 },{ -1, -1, -2 },{ 2, -3, -3 },{ 3, 2, 3 },{ -3, 2, -2 },{ 1, 3, -1 },{ -3, -3, 3 },{ 0, -1, -3 },{ 2, -4, 1 },{ -3, 1, -2 },{ 2, -1, -1 },{ -3, -2, -3 },{ 0, 0, -1 },{ -2, -4, 1 },{ 3, -3, -3 },{ -4, -1, 3 },{ 2, 3, -3 } },
+		{ { -3, 2, 2 },{ -2, 0, -2 },{ 3, 1, -3 },{ 0, 1, 1 },{ -2, -3, 0 },{ 1, -2, -2 },{ 1, 2, 3 },{ -3, -4, 1 },{ 2, 3, 3 },{ 0, -1, -4 },{ -4, -1, 0 },{ 3, 3, -3 },{ -4, -3, -1 },{ 1, 0, 1 },{ 3, 1, 2 },{ -4, -1, 0 },{ 2, -3, -3 },{ -1, -1, 2 },{ -3, 2, 0 },{ -2, 2, 1 },{ 0, 0, -1 },{ -3, -1, -2 },{ 1, -3, 1 },{ 3, -2, -3 },{ -3, 3, -4 },{ -1, 0, 0 },{ 3, -1, -2 },{ -2, 1, -3 },{ -1, -4, 3 },{ -4, -2, 0 },{ -3, 0, -3 },{ 2, -4, 3 },{ -1, 1, 0 },{ 1, -1, 1 },{ -2, 2, -3 },{ 2, -1, 0 },{ -1, -2, -2 },{ 1, -1, 1 },{ -4, 2, 0 },{ -2, 0, -2 },{ 1, -3, -4 },{ -4, -4, 3 },{ 2, 2, 1 },{ 0, 2, -3 },{ -3, -4, 0 },{ -2, -1, 1 },{ -3, 2, -1 },{ 3, -3, 2 },{ 1, 1, 1 },{ -3, -1, 1 },{ -2, 0, 0 },{ 0, -4, 0 },{ -1, -2, -3 },{ 2, -4, -4 },{ 0, 0, 0 },{ 3, 1, 2 },{ -4, 3, 3 },{ -1, -1, -4 },{ -1, -4, 2 },{ -4, 2, -2 },{ 2, 0, -2 },{ 1, 2, 2 },{ -2, -2, 0 },{ 3, 1, -2 } },
+		{ { 1, -3, 1 },{ -3, 3, -1 },{ -2, -4, 2 },{ 2, -1, -1 },{ -4, -4, 3 },{ 2, 2, -1 },{ -1, -1, -4 },{ 2, -2, -2 },{ 0, 2, 0 },{ 3, -3, -2 },{ -2, 0, 2 },{ 0, 1, 3 },{ -2, -4, -2 },{ 0, 2, -1 },{ -2, -3, -4 },{ -1, -2, 3 },{ 1, -4, -2 },{ -3, 3, -1 },{ 2, 0, -3 },{ -4, -2, 2 },{ 3, 1, -4 },{ -1, -3, 2 },{ -3, 3, 3 },{ 2, 2, -2 },{ 1, -4, 2 },{ 0, 2, 3 },{ -3, -2, -1 },{ 1, -3, 0 },{ 2, 0, -2 },{ 0, 3, 0 },{ 1, -1, -1 },{ -2, -3, -3 },{ 3, 3, 2 },{ -4, -4, -4 },{ 0, 0, 3 },{ -4, 1, 2 },{ -3, 3, -1 },{ 0, 1, 3 },{ 3, -3, -4 },{ -3, 0, -1 },{ 3, 3, 2 },{ -1, -2, -1 },{ -2, 1, -2 },{ 3, -2, -1 },{ -1, 3, -1 },{ 2, 0, 3 },{ 0, -2, -3 },{ -2, -4, -4 },{ -4, 3, 3 },{ 0, -4, -3 },{ 1, 0, 2 },{ 3, 1, -4 },{ -3, 3, 1 },{ -4, -1, -2 },{ -2, 3, 3 },{ -1, -3, -1 },{ 1, -3, -2 },{ -2, 1, 1 },{ 3, 3, 0 },{ 2, -3, 3 },{ -2, -2, -4 },{ 0, 3, -1 },{ -4, -3, 0 },{ 0, -1, -4 } },
+		{ { 2, -1, -1 },{ -1, 0, -4 },{ 1, -2, 3 },{ 0, 2, -3 },{ -3, 3, -4 },{ -1, 0, 2 },{ -4, -3, 1 },{ -2, 1, 2 },{ -4, 0, -4 },{ 1, -4, -1 },{ -3, 2, 1 },{ 1, -2, -4 },{ -1, 2, 3 },{ -4, 0, -3 },{ -3, -1, 2 },{ 3, 3, -3 },{ -2, 0, 1 },{ 2, 1, 1 },{ 0, -2, -4 },{ 1, -4, 3 },{ -2, 3, -2 },{ 2, 1, 0 },{ -1, -1, -4 },{ 0, 1, 0 },{ -4, -3, 1 },{ -2, 0, -4 },{ 1, 3, -1 },{ -4, -2, 2 },{ -1, 1, -4 },{ 3, 2, 2 },{ -4, -4, 1 },{ 0, 0, 2 },{ -3, -2, -4 },{ -1, 2, -1 },{ 3, -2, -2 },{ -2, -3, -3 },{ 1, -4, -4 },{ -2, 3, 2 },{ 2, -4, -3 },{ -1, -2, 2 },{ 0, -1, 0 },{ 2, 2, -3 },{ -3, -1, 3 },{ -2, -3, 2 },{ 0, -4, -4 },{ -4, 1, 0 },{ 1, 0, -2 },{ 2, 3, 1 },{ -1, -2, -2 },{ 3, -2, -1 },{ -4, -3, -2 },{ 0, -1, 3 },{ -2, -2, -1 },{ 1, 2, 2 },{ 2, 0, -2 },{ -3, -2, -4 },{ 1, 0, -3 },{ 3, -2, 2 },{ -4, 0, -4 },{ 0, 1, -3 },{ -3, -1, 1 },{ -1, 1, 3 },{ 3, -4, -3 },{ -2, 2, 3 } },
+		{ { -4, 1, 0 },{ -1, -4, 1 },{ 3, 0, 0 },{ -4, -1, -2 },{ 3, 1, -3 },{ 0, -2, 0 },{ 1, 2, -1 },{ 3, -3, -3 },{ -3, 3, 3 },{ -1, 1, -3 },{ 2, -3, 2 },{ 1, -1, -1 },{ 3, -2, 1 },{ 2, -4, 0 },{ 0, 2, 0 },{ 1, 1, -2 },{ -4, -3, 3 },{ -1, 2, -2 },{ -4, -1, 0 },{ 3, 0, 1 },{ 0, -3, -2 },{ -4, -2, -3 },{ 1, -4, -1 },{ -2, 0, 1 },{ 3, -2, -2 },{ -3, -1, -3 },{ 3, 1, 1 },{ 2, -4, 3 },{ -3, 2, -3 },{ -2, -2, -4 },{ 0, -3, -2 },{ 2, 2, -2 },{ -4, 1, 0 },{ 2, -3, 3 },{ -1, 0, 0 },{ 0, 1, 2 },{ 2, -2, 1 },{ 1, 0, 0 },{ -4, -1, -2 },{ -3, 2, 3 },{ 1, -4, -2 },{ -4, 0, 1 },{ 1, -3, 0 },{ 2, 1, -4 },{ -1, 3, 3 },{ -4, -1, -3 },{ 3, -3, 2 },{ -3, -1, 0 },{ 1, 1, -1 },{ -2, 2, 3 },{ -1, 1, -4 },{ -2, 3, 0 },{ 2, -3, -3 },{ 3, 1, 3 },{ -1, -4, 0 },{ -3, -4, -1 },{ -4, 2, 1 },{ 0, 3, 3 },{ -2, -4, -1 },{ 1, -4, 2 },{ 2, -2, 0 },{ 2, 2, -2 },{ -3, 0, 2 },{ 0, -3, -3 } },
+		{ { 3, -3, -2 },{ -3, 2, -4 },{ 0, 3, 1 },{ -2, -3, 2 },{ 1, -3, 2 },{ -3, -1, 3 },{ -2, -4, -2 },{ 3, 0, 1 },{ -1, -2, -1 },{ 0, -1, 2 },{ -4, 3, -2 },{ -3, -3, -4 },{ -2, 3, -3 },{ 0, 0, -1 },{ -3, -3, 2 },{ 2, -1, -1 },{ -1, -2, -4 },{ 3, 0, 2 },{ -2, -4, -3 },{ -3, 2, -1 },{ 1, 3, 0 },{ -3, 0, 3 },{ 2, 2, 2 },{ -4, 2, 2 },{ 0, 3, -3 },{ 2, -4, 3 },{ -1, 0, -1 },{ -1, -3, 2 },{ -3, -1, 0 },{ 2, 3, 1 },{ -3, -1, 0 },{ -1, -2, 3 },{ 3, 3, -3 },{ 1, -1, 1 },{ -3, 3, -1 },{ 3, 2, -3 },{ -4, -2, -1 },{ -1, 1, -2 },{ 0, 0, 1 },{ 3, 3, -4 },{ -2, 1, -1 },{ -1, 3, -4 },{ -3, -1, -2 },{ 3, 2, -1 },{ 1, -2, 1 },{ 0, -2, -2 },{ -1, 2, 2 },{ -2, -3, -3 },{ -3, 0, -4 },{ 2, -1, 2 },{ 2, -4, 0 },{ -3, 2, 1 },{ 0, 0, -3 },{ -4, -2, -4 },{ 0, 1, 2 },{ 2, 3, -4 },{ 0, 1, 0 },{ -1, -1, -2 },{ -3, -2, -1 },{ 0, 3, -4 },{ -2, 0, -3 },{ -4, -1, -1 },{ 1, 3, 1 },{ 1, -2, -1 } },
+		{ { 1, 3, 2 },{ -3, -2, 3 },{ 2, 1, -1 },{ 2, -4, -3 },{ -1, 2, 0 },{ 2, 3, -1 },{ 0, 2, -4 },{ 1, 0, 3 },{ -3, -4, -3 },{ 2, -1, 0 },{ -1, 1, 1 },{ 3, 0, 3 },{ -3, 1, -2 },{ 2, -4, 3 },{ -2, 3, -4 },{ -4, 2, 1 },{ 0, -4, 2 },{ -2, 3, -1 },{ 1, -2, 3 },{ 2, 1, -4 },{ -1, -4, 1 },{ 3, -1, -3 },{ -2, -1, -4 },{ 1, -3, 0 },{ -1, -3, -2 },{ -2, -2, 0 },{ -4, 3, -4 },{ 1, 0, -2 },{ 0, 1, -3 },{ 3, -4, 3 },{ 1, 1, -1 },{ -2, 0, -4 },{ -2, -3, -2 },{ 0, -4, 2 },{ -2, 0, -4 },{ -3, -4, 3 },{ 2, 2, 3 },{ -2, -3, -4 },{ -3, -4, 2 },{ 3, -2, 0 },{ 2, -3, 2 },{ 2, -2, 3 },{ -2, -4, 2 },{ 0, 0, 1 },{ -3, -4, -3 },{ -2, 3, 0 },{ 2, 1, -1 },{ 3, -4, 3 },{ 0, 3, 1 },{ 1, -3, -1 },{ -4, -2, -2 },{ 3, 0, 2 },{ -3, -3, 1 },{ 1, 2, -1 },{ -2, -1, 0 },{ -2, -3, 3 },{ 3, -3, -3 },{ 2, 0, 1 },{ 3, 2, 2 },{ -4, 1, 3 },{ 3, -3, 1 },{ -1, -4, 3 },{ -3, 2, -4 },{ -2, 0, 2 } },
+		{ { 3, 1, -3 },{ -1, -1, -2 },{ -4, -2, -4 },{ -3, 0, 0 },{ -2, 0, -4 },{ 3, -2, -3 },{ -4, 1, 0 },{ -4, -3, 1 },{ 2, 3, -2 },{ 1, 2, -4 },{ -2, -4, -1 },{ 0, -3, 0 },{ -4, 2, 1 },{ 1, -2, 0 },{ -1, -1, -2 },{ 3, 0, -3 },{ -1, 2, 0 },{ 2, -1, -2 },{ -3, 1, -3 },{ 0, 0, 0 },{ -4, -3, 2 },{ -1, 2, -1 },{ -3, 3, -2 },{ 3, -4, -1 },{ 0, 1, -4 },{ -3, 1, 3 },{ 2, 2, 1 },{ 3, -3, 1 },{ -4, 3, -2 },{ -2, -2, -1 },{ 0, -4, 2 },{ -4, 2, 2 },{ 3, 2, 0 },{ -4, -2, 1 },{ 1, -1, -3 },{ -1, -3, 0 },{ 0, -1, -2 },{ 1, -1, -3 },{ -4, 3, 0 },{ 0, 0, -1 },{ -1, -1, -3 },{ -4, 1, -3 },{ 0, 3, 0 },{ -4, 2, -2 },{ 1, -2, -4 },{ 3, 0, 3 },{ -2, 2, -4 },{ -4, -1, -1 },{ 0, -2, -3 },{ -1, 2, 3 },{ -2, 1, -3 },{ -1, -4, -4 },{ 1, 3, -1 },{ 3, -1, 3 },{ 2, 2, -2 },{ -4, 0, 2 },{ 1, -2, -3 },{ -4, -4, 0 },{ -2, -1, -4 },{ 1, -3, -2 },{ -2, 3, -2 },{ 2, 1, -1 },{ 0, -1, -4 },{ -1, -4, -1 } },
+		{ { 2, 3, 1 },{ -2, -4, 0 },{ 1, 2, 3 },{ 3, 3, 1 },{ 0, -4, 3 },{ -3, -1, 1 },{ 1, -3, -1 },{ -1, -2, 3 },{ -2, 0, -3 },{ 0, 1, 2 },{ -3, -2, 3 },{ 3, 3, -3 },{ -1, -1, -4 },{ 2, 1, 2 },{ -3, -3, 3 },{ -4, 1, -1 },{ 1, -4, -3 },{ -3, -3, 0 },{ 1, -2, 2 },{ -2, -3, -2 },{ 2, -1, 3 },{ 3, 1, -3 },{ -3, -2, 2 },{ 1, 0, 3 },{ -4, -1, 1 },{ 2, -1, -3 },{ -2, -4, -1 },{ -1, -2, 2 },{ 0, 0, -4 },{ -3, -1, 0 },{ 2, -1, -3 },{ 1, 1, -4 },{ 0, -3, 3 },{ 2, 1, -1 },{ -1, 3, -4 },{ 3, 2, 2 },{ -4, 1, -1 },{ -1, 3, 2 },{ 3, -4, 3 },{ 1, 2, -2 },{ -3, 0, 3 },{ 1, 2, 1 },{ 3, -2, -1 },{ 2, -3, 2 },{ -1, -1, 3 },{ -4, 1, 0 },{ 1, -3, 1 },{ -3, -1, -2 },{ 3, 2, 2 },{ -4, 0, 1 },{ 3, 3, 0 },{ 0, -1, 2 },{ -2, -2, 0 },{ -4, 0, -2 },{ -1, -4, -4 },{ 0, 3, -1 },{ -3, 2, -2 },{ -1, 3, 3 },{ 1, -1, 0 },{ -1, -4, 2 },{ 2, 0, 1 },{ -4, -2, 0 },{ 3, 2, 3 },{ -4, -3, 0 } },
+		{ { -3, 0, -1 },{ 0, -1, 1 },{ 1, -3, -2 },{ -4, 1, -2 },{ -1, -2, 2 },{ -3, 3, -3 },{ 2, 2, 2 },{ 3, 1, -2 },{ -3, -4, 0 },{ 3, -1, -1 },{ -4, 0, 1 },{ 1, -3, -3 },{ -1, -4, 1 },{ 1, 0, -1 },{ 0, -2, -4 },{ 2, 3, 1 },{ 2, 1, 2 },{ 0, 0, 3 },{ 3, 3, -4 },{ -1, 2, -4 },{ -4, 3, 1 },{ 1, -4, -1 },{ 0, -3, -2 },{ -2, 3, 1 },{ -1, 2, 2 },{ 3, -2, -2 },{ 1, 1, -3 },{ -2, 2, 0 },{ 3, -3, 3 },{ -1, 3, 1 },{ -4, 2, -2 },{ 3, -3, 1 },{ -2, -1, -3 },{ -3, 3, 0 },{ -3, -2, -2 },{ 2, -4, 1 },{ -3, 0, 1 },{ -2, -3, -4 },{ 2, 1, -4 },{ -4, -2, 1 },{ -2, -4, -1 },{ -2, -1, -4 },{ 0, -4, -4 },{ -3, 3, 0 },{ -2, -3, -1 },{ 2, -4, -3 },{ 1, 3, 1 },{ -1, -2, -2 },{ 2, -3, 0 },{ 1, -4, -4 },{ -3, -4, -2 },{ 2, 2, 3 },{ -1, 1, -3 },{ -3, -2, 1 },{ 2, -4, 1 },{ 2, -2, 2 },{ -2, 1, 1 },{ 3, 1, -4 },{ 0, -2, -1 },{ -3, 2, -3 },{ 0, 2, -4 },{ -3, -2, 2 },{ 1, -3, -2 },{ -1, 1, -3 } },
+		{ { -2, 2, -4 },{ 3, -2, 3 },{ -3, 1, -4 },{ -1, -4, -1 },{ 3, -1, 0 },{ 2, -3, -4 },{ -2, 1, -1 },{ 0, -1, -4 },{ 0, 3, 2 },{ -1, 2, -4 },{ 2, -3, 3 },{ -2, 1, -2 },{ -3, -1, -2 },{ -4, 3, 2 },{ -2, 2, 0 },{ -2, -2, -3 },{ -1, -4, 1 },{ -4, -1, -1 },{ -2, -1, -1 },{ -3, -4, 1 },{ 2, 0, 0 },{ -1, 0, 3 },{ 3, -1, -3 },{ -4, 2, -4 },{ 2, -4, 0 },{ 0, -3, -1 },{ -4, 3, 3 },{ -3, -4, 1 },{ 2, 0, -4 },{ 1, -2, -2 },{ -1, 1, 3 },{ -3, -4, -1 },{ 2, 0, 2 },{ -1, -4, 3 },{ 1, -1, -2 },{ 0, -3, 3 },{ 2, 2, -3 },{ 0, -2, -1 },{ -1, -1, 0 },{ 0, 3, -3 },{ 2, -3, 2 },{ 3, 1, 1 },{ -1, 0, 3 },{ -3, 1, 1 },{ 3, 2, -2 },{ 0, 0, -3 },{ -3, 0, 2 },{ -4, 2, -4 },{ -2, 1, 3 },{ 0, 1, -1 },{ -2, -1, 0 },{ 1, 0, -4 },{ -4, 3, -1 },{ 1, -3, 3 },{ 0, 2, -4 },{ -1, -1, 0 },{ 3, -3, -2 },{ -4, -3, 1 },{ -2, 0, -3 },{ 2, -4, 3 },{ 3, 0, -1 },{ -2, 3, -2 },{ 0, -1, -3 },{ 3, -4, 2 } },
+		{ { 2, -1, 0 },{ -1, -2, 2 },{ 1, 3, -3 },{ -2, 2, 1 },{ 0, 0, -2 },{ 1, -4, 3 },{ -1, 3, -1 },{ -4, 0, 1 },{ -4, -4, 0 },{ 1, -2, -2 },{ -2, -1, 0 },{ 3, 2, -4 },{ 0, 3, 2 },{ 3, -4, 3 },{ 1, -1, -2 },{ 3, 0, -4 },{ -3, 2, 0 },{ 0, -3, -2 },{ 3, 2, 3 },{ 1, -2, -3 },{ -3, 1, -2 },{ 0, -2, 2 },{ -3, 2, 0 },{ -2, -4, -1 },{ 0, 0, -4 },{ -3, -2, 2 },{ 1, 0, -3 },{ 0, -1, -1 },{ -2, 1, -1 },{ -3, -4, 2 },{ 2, 3, 1 },{ 0, -2, -4 },{ -2, 1, -2 },{ -4, 2, 0 },{ 3, 0, -4 },{ -2, 2, -1 },{ -4, 1, 2 },{ 1, -4, -2 },{ 3, 0, 3 },{ -4, 1, 0 },{ -2, -2, -2 },{ 0, 3, -2 },{ -4, -1, -3 },{ 1, -2, 0 },{ 2, 2, 3 },{ -2, -2, -4 },{ 3, -4, -1 },{ 0, -1, 3 },{ -1, 0, -3 },{ 2, 3, 2 },{ -3, -2, -3 },{ 3, -3, 1 },{ -2, 0, 2 },{ 3, 1, -1 },{ -3, -1, -2 },{ -4, 0, -3 },{ 1, 3, 3 },{ -3, -2, -1 },{ 1, -1, 2 },{ -3, 2, 0 },{ -4, -4, 1 },{ 2, -3, 3 },{ 1, 1, 1 },{ -4, 3, 0 } },
+		{ { 0, 0, -2 },{ 0, 2, -1 },{ -4, -3, 2 },{ 2, -1, 3 },{ -4, 2, -4 },{ -3, -2, 1 },{ 0, -2, 2 },{ 2, -3, -3 },{ 3, 1, -3 },{ -3, -2, 3 },{ 1, 2, 2 },{ -4, -2, 1 },{ -1, 0, -1 },{ 2, -3, -3 },{ -4, -2, 0 },{ -1, -4, 2 },{ -3, 3, 1 },{ 0, 1, -3 },{ 2, -4, 2 },{ -4, 3, 1 },{ -1, -3, -4 },{ 2, 3, 2 },{ 3, -2, -2 },{ 1, 1, 1 },{ -1, -1, 3 },{ 3, 3, 0 },{ -1, 1, -2 },{ 3, 2, 1 },{ 0, -2, -4 },{ -4, 1, -3 },{ 3, -3, 0 },{ -4, -1, -3 },{ 3, 3, 1 },{ 0, -2, -4 },{ 1, -2, 2 },{ -2, 0, -3 },{ -1, -3, 1 },{ -2, 3, -4 },{ -3, -3, 3 },{ 1, 0, -3 },{ -3, 2, 2 },{ 3, -3, -1 },{ 2, -4, -4 },{ -1, -1, 0 },{ -2, 1, 2 },{ -4, -3, 2 },{ -1, 3, 0 },{ 1, -2, -1 },{ 3, -4, 1 },{ -4, -3, -2 },{ 1, 2, 0 },{ -1, -2, 3 },{ 0, -4, -4 },{ 2, 3, -3 },{ -2, 1, 2 },{ -1, -4, 0 },{ 3, 2, -4 },{ 0, 3, 2 },{ 2, 1, -4 },{ -1, -1, -2 },{ 0, 3, -4 },{ -2, 1, -2 },{ -1, -2, -1 },{ -3, -4, -4 } },
+		{ { -3, -3, 3 },{ 3, 0, -3 },{ -2, -4, -2 },{ 2, -1, 0 },{ -3, 1, -3 },{ 3, 3, 0 },{ -2, 0, -2 },{ 2, 2, 3 },{ -1, 1, -1 },{ 0, 3, 1 },{ -2, -4, -4 },{ 2, -4, -3 },{ 0, 0, 0 },{ -3, 1, 1 },{ -1, 2, -4 },{ 2, 1, -2 },{ 1, -3, 3 },{ 3, -1, -4 },{ -1, -2, 0 },{ -2, 0, -1 },{ 1, -3, 0 },{ 0, -1, -4 },{ -3, 0, 3 },{ -2, 3, -1 },{ -4, -3, -3 },{ 2, -4, 2 },{ -2, -2, -3 },{ -4, -3, 3 },{ 2, -1, 2 },{ -2, 3, 0 },{ 1, 0, 3 },{ -2, 0, -1 },{ -1, -3, 0 },{ 2, -3, 3 },{ -3, 2, 3 },{ 3, 3, -2 },{ -3, -1, 0 },{ 3, -2, -1 },{ 0, 2, 1 },{ 2, -4, -4 },{ -1, -1, 0 },{ -1, 0, 3 },{ -3, 2, 1 },{ -4, -4, -4 },{ 0, 3, -2 },{ 2, -3, -2 },{ -3, 0, -3 },{ -3, 1, 1 },{ 1, 3, -4 },{ -2, -1, 3 },{ -1, 1, -4 },{ -3, 2, -2 },{ 1, -4, 1 },{ -4, -1, 0 },{ 0, -3, -2 },{ 2, -2, 3 },{ 1, 0, -1 },{ -4, -2, 0 },{ -2, -4, -3 },{ 3, 1, 3 },{ -1, -2, 1 },{ -4, -1, -3 },{ 2, 2, 3 },{ 2, -1, 2 } },
+		{ { -2, 1, -4 },{ -2, 3, 1 },{ 1, -2, 1 },{ 0, 1, -4 },{ 0, -3, 3 },{ -1, -4, -1 },{ 1, -1, -3 },{ -2, -4, -4 },{ -4, -1, 1 },{ -1, 0, -1 },{ -3, -1, -2 },{ 2, 2, -2 },{ -3, -2, 2 },{ 1, -1, 3 },{ -4, 3, -1 },{ 1, -1, -3 },{ -2, 0, 1 },{ -4, 2, -1 },{ -3, 3, -2 },{ 3, 1, 3 },{ -4, 1, -3 },{ -1, -4, 1 },{ -4, 2, -3 },{ 1, -3, -2 },{ 2, 0, 0 },{ -1, -1, -4 },{ -3, 3, 0 },{ 1, 1, -2 },{ 0, -4, -2 },{ -1, 2, -1 },{ 1, -2, -4 },{ 0, 2, 2 },{ -3, 2, -3 },{ -1, -4, -1 },{ -4, 0, -1 },{ 1, -4, -3 },{ 2, 1, 2 },{ -1, -1, -1 },{ -4, 3, -2 },{ -2, 1, 0 },{ -4, -3, 2 },{ 3, 3, -2 },{ 1, 0, -3 },{ 0, -2, 2 },{ 3, 0, -1 },{ 2, 2, 3 },{ -1, -1, -3 },{ 0, -3, 0 },{ -4, 1, 2 },{ 2, -4, -1 },{ 3, -1, 0 },{ 2, 0, -3 },{ -4, 3, -1 },{ -2, -2, 3 },{ 1, 1, -4 },{ -1, -3, 1 },{ -3, 3, -2 },{ -3, -4, 3 },{ 0, 0, 0 },{ 2, 0, -1 },{ -3, -3, 2 },{ 3, -4, -1 },{ 0, 0, 0 },{ 1, 2, 0 } },
+		{ { 3, -4, -3 },{ -4, 3, -1 },{ -1, 0, 2 },{ -3, 2, -3 },{ 2, 3, -1 },{ -4, -2, 2 },{ 3, 2, 0 },{ -3, 3, 2 },{ 2, -3, -2 },{ 3, 1, 2 },{ 0, -3, 0 },{ 3, 2, 3 },{ -1, 3, -4 },{ 3, -3, 0 },{ 0, -4, 2 },{ 3, -2, -2 },{ -1, -4, 3 },{ 0, -2, 1 },{ 1, -4, -4 },{ -2, -1, 2 },{ 3, 2, 2 },{ 2, -1, 1 },{ -3, -4, -1 },{ 3, -2, 2 },{ 0, 2, 1 },{ -2, 1, -1 },{ 3, 2, 2 },{ -1, -3, 1 },{ -3, 0, -3 },{ 3, -1, 2 },{ -3, -4, 1 },{ -4, -2, -2 },{ 2, 1, -2 },{ 3, -1, 1 },{ -2, 1, 0 },{ 1, -2, -4 },{ -3, 2, 2 },{ 0, -3, 3 },{ 1, -4, -3 },{ 2, 0, 3 },{ 1, -2, -4 },{ 0, -2, -1 },{ -2, 2, 3 },{ -3, 1, 0 },{ 1, -1, 1 },{ -2, 1, -4 },{ -4, -4, 1 },{ 3, 2, 3 },{ -2, -2, -2 },{ -3, -2, -3 },{ 0, 3, 2 },{ -1, -3, 1 },{ 1, 0, 2 },{ 3, 1, -1 },{ -3, 2, -3 },{ -1, 0, 2 },{ 3, 2, -4 },{ 2, -1, -2 },{ -1, -3, -3 },{ -2, 2, 1 },{ 1, 2, -2 },{ -2, 3, 2 },{ -3, -2, -3 },{ -1, -3, -2 } },
+		{ { 2, 1, 3 },{ 0, -2, -2 },{ 1, -3, 0 },{ 3, -1, 3 },{ -2, -4, -2 },{ 0, 0, 1 },{ -1, 1, 3 },{ 1, -3, -3 },{ 0, -2, -4 },{ -2, 2, 3 },{ 1, -2, -3 },{ -4, -4, 1 },{ -2, 0, -1 },{ -2, 1, -2 },{ -3, 1, -3 },{ -3, 2, -4 },{ -2, 3, 0 },{ 2, -1, -1 },{ 2, 3, -3 },{ 1, -2, -3 },{ -1, -3, -2 },{ 0, 0, 0 },{ -1, 3, -4 },{ 2, 3, 3 },{ -3, -2, -2 },{ -4, -1, -4 },{ 0, -4, 3 },{ 1, -2, -3 },{ -4, 3, 0 },{ 2, 1, -4 },{ -2, -3, 3 },{ 3, 1, 0 },{ 1, 3, -4 },{ 0, -1, 2 },{ -1, 3, 3 },{ -1, -3, -3 },{ -4, 1, -2 },{ 3, 0, 0 },{ -2, 2, -4 },{ -3, 1, 1 },{ -1, 3, 0 },{ -3, -1, -2 },{ 3, -4, -4 },{ -4, -3, -3 },{ -1, -4, 0 },{ 1, 3, -2 },{ 2, -2, -1 },{ 1, 0, 2 },{ -1, 3, -4 },{ 2, -1, -1 },{ 0, 2, 3 },{ -4, -4, -2 },{ -2, -2, -4 },{ 0, -3, -2 },{ 2, -1, 1 },{ -4, -4, 0 },{ -2, -1, 1 },{ 1, 1, 3 },{ 0, 3, -1 },{ -4, -2, 2 },{ 1, -1, -4 },{ 2, -3, -4 },{ -4, 1, 0 },{ 0, -1, 2 } },
+		{ { 1, -4, 3 },{ -3, 0, -4 },{ -1, 1, -2 },{ -3, 2, 2 },{ -4, -3, -4 },{ 2, -1, -3 },{ -2, -2, 0 },{ -4, 3, -1 },{ 3, 0, 1 },{ -3, -4, -1 },{ -1, 3, 0 },{ -4, -1, -4 },{ 1, -2, 1 },{ 2, -1, 2 },{ 2, -3, 0 },{ 1, 0, 3 },{ 0, -3, 1 },{ -4, 1, 2 },{ -3, 0, 0 },{ -2, 2, 1 },{ -4, -3, 3 },{ 0, 1, 0 },{ -2, -1, -3 },{ 1, -4, 2 },{ -1, 1, -1 },{ 2, -3, 1 },{ -3, 0, -3 },{ 3, 2, 2 },{ -2, -1, 3 },{ -1, 3, -1 },{ 1, 0, -1 },{ -2, -1, -3 },{ -1, -4, 3 },{ -3, -2, -2 },{ -4, -3, -1 },{ 3, -4, 1 },{ 2, -1, 1 },{ 0, 3, 2 },{ -4, -4, -1 },{ 3, -3, 2 },{ 1, 0, -1 },{ -2, -2, 3 },{ 2, 1, 2 },{ 3, 3, 0 },{ -1, 0, 3 },{ -3, -3, -2 },{ 0, 1, 2 },{ -3, -4, 0 },{ 3, 0, -3 },{ -2, -3, 1 },{ 1, 1, 0 },{ -3, 0, -4 },{ 3, 2, 1 },{ -1, 3, 3 },{ 0, -2, -1 },{ -2, 2, -4 },{ 1, -3, 2 },{ 2, -2, -2 },{ -4, 1, -3 },{ 3, -4, 0 },{ -1, 0, -2 },{ -2, 0, 3 },{ 3, 3, 1 },{ -4, -2, -1 } },
+		{ { -2, 3, -1 },{ 3, -3, 1 },{ 2, 3, -3 },{ 0, -4, 1 },{ 1, 1, -1 },{ 3, 3, -4 },{ -3, -3, 3 },{ 0, 1, 1 },{ 2, -1, -2 },{ -2, 2, 3 },{ 2, 0, -3 },{ 0, 1, 2 },{ 3, 3, -2 },{ -1, -4, -1 },{ -1, 3, -4 },{ -4, 2, 2 },{ 2, -4, -2 },{ -1, -1, -4 },{ 3, 0, -2 },{ -3, -4, -1 },{ 3, -2, -4 },{ 1, 2, -1 },{ -4, -2, -4 },{ -3, 0, 1 },{ 2, -3, -3 },{ -1, 3, 0 },{ 0, 1, -1 },{ -2, -2, -2 },{ 0, -4, -4 },{ 3, -3, -2 },{ -4, -4, 2 },{ 0, 2, 1 },{ 2, 0, 1 },{ -3, 3, -2 },{ 2, 2, -4 },{ 0, 0, -3 },{ -3, 0, -1 },{ 1, -2, -4 },{ -1, -2, -2 },{ 2, -1, -3 },{ 0, 2, 1 },{ -4, -4, -3 },{ -1, 2, 1 },{ 0, -1, -4 },{ 2, -1, -1 },{ -2, 2, 2 },{ 0, -1, -4 },{ -4, 2, -1 },{ -2, -2, -2 },{ -4, 3, 1 },{ 1, -1, 3 },{ 2, -3, -2 },{ -1, 2, 0 },{ 2, -1, 2 },{ -4, 0, -3 },{ 3, 1, -3 },{ -3, 3, -1 },{ -1, -2, 0 },{ -2, -4, 1 },{ 2, 1, 3 },{ -3, 2, 1 },{ 0, -3, 2 },{ 1, 2, -2 },{ -1, -1, -3 } },
+		{ { 1, 1, 1 },{ -1, 0, 2 },{ -4, -1, 0 },{ -2, -2, 3 },{ -1, 0, 0 },{ 0, 2, 2 },{ -3, -4, -3 },{ 1, 1, 0 },{ -4, -4, -4 },{ 3, -2, 2 },{ 0, -3, 0 },{ -3, -3, -3 },{ -3, -3, 3 },{ -4, 1, 1 },{ 1, -2, -3 },{ -2, 1, -1 },{ 3, -2, -3 },{ -1, 3, 3 },{ 1, -3, 1 },{ 0, 3, -2 },{ -2, 0, 2 },{ 3, -4, 3 },{ -3, 3, 1 },{ 1, -1, -2 },{ 3, 2, 3 },{ -4, -2, -4 },{ 2, -1, 3 },{ -4, -3, 1 },{ 1, 2, 1 },{ -3, 1, 0 },{ 2, 3, -3 },{ -4, -1, -1 },{ 3, -3, -4 },{ 1, 1, 0 },{ 0, -2, 2 },{ -2, -4, 3 },{ -2, 2, 1 },{ 2, 1, 3 },{ -3, 2, 0 },{ -3, 3, 3 },{ -2, 0, -4 },{ 2, -3, -2 },{ 1, 2, -1 },{ -3, -2, 3 },{ -4, -3, -3 },{ 3, 1, 0 },{ 1, 3, -3 },{ 3, -3, 1 },{ 2, -4, 3 },{ 0, 1, -4 },{ -1, -2, -1 },{ -3, -4, -4 },{ -2, 1, -3 },{ 1, -4, -1 },{ -3, -2, 2 },{ 2, -4, 3 },{ 0, 0, 1 },{ -3, 2, -2 },{ 3, 3, -4 },{ -3, -1, -3 },{ 0, -2, -4 },{ -3, -4, -1 },{ 3, -1, -2 },{ -3, -4, -4 } },
+		{ { -4, 2, 0 },{ 0, -3, -4 },{ 2, -1, -2 },{ 1, 3, -3 },{ -4, -3, -2 },{ 2, -2, 1 },{ 3, -2, -1 },{ -1, 3, -2 },{ -2, 0, 3 },{ -3, 1, -4 },{ 1, 3, -1 },{ -2, 2, 0 },{ 3, 0, -4 },{ 1, -1, 1 },{ 0, -4, 0 },{ -3, 0, 3 },{ -3, 0, 2 },{ 1, -2, -1 },{ -2, 1, 0 },{ -4, -1, 3 },{ -1, 2, -3 },{ 2, 1, 0 },{ 0, -3, -2 },{ -1, 1, 2 },{ 0, -4, -1 },{ -2, 2, 2 },{ -3, 0, -3 },{ 3, 3, -2 },{ -1, 0, -4 },{ -2, -1, 2 },{ 1, -2, 3 },{ -1, 2, -3 },{ -2, -4, 2 },{ -4, 0, -1 },{ 3, -1, 0 },{ -1, 3, -3 },{ -4, -3, -2 },{ 3, -1, -4 },{ -1, -3, -1 },{ 0, -4, 2 },{ 3, 1, 0 },{ -4, -1, 1 },{ 3, 3, -3 },{ -2, -2, 0 },{ 0, 0, 2 },{ -2, -4, 1 },{ -1, -2, 3 },{ -3, 0, -2 },{ -1, 2, 2 },{ 1, -2, -3 },{ 3, 2, 2 },{ 2, 3, 1 },{ -4, 0, 3 },{ 3, -3, -1 },{ -2, 3, 0 },{ -4, 0, -2 },{ -1, -1, -4 },{ 2, -3, 3 },{ -2, -3, 2 },{ 1, 0, 2 },{ 1, 1, -1 },{ -1, 3, 0 },{ 2, 1, 2 },{ -2, -2, 3 } },
+		{ { 3, 0, -2 },{ 2, -2, -1 },{ -3, -4, 3 },{ -2, 1, 1 },{ 3, 2, -1 },{ 0, 0, 3 },{ -4, 2, -3 },{ -1, -1, 1 },{ 1, -3, -1 },{ 3, -4, 1 },{ -1, -1, 2 },{ 2, -1, -2 },{ -4, 2, 3 },{ -1, -2, -3 },{ 3, 2, -2 },{ 2, -3, -3 },{ -1, 3, -4 },{ -4, 1, -1 },{ 2, -4, -3 },{ 2, -2, -4 },{ 1, -3, -2 },{ -3, -1, 1 },{ -2, -2, -4 },{ -4, 1, 0 },{ 3, 0, -4 },{ 1, -3, -1 },{ -1, -4, 0 },{ 0, 3, 3 },{ 2, -4, -2 },{ -1, -1, 0 },{ 3, 1, -3 },{ 0, -3, 1 },{ -3, -2, -2 },{ -1, 1, 3 },{ -3, 2, -4 },{ 1, -2, 0 },{ 1, 0, 1 },{ 0, 3, 2 },{ 1, 1, -1 },{ -4, -3, -3 },{ 1, -2, 3 },{ -1, 1, -2 },{ -3, -4, 2 },{ 0, 1, -4 },{ 2, 0, -2 },{ -4, 2, -1 },{ 1, -3, -2 },{ -2, 1, -4 },{ 3, 0, 0 },{ -3, -1, -1 },{ -4, -3, 0 },{ -2, 0, -2 },{ 0, -1, 1 },{ 0, 1, -3 },{ 1, 2, -4 },{ 3, -3, 2 },{ 1, -2, -1 },{ -4, 1, 0 },{ 0, 3, -2 },{ 3, -2, -1 },{ -4, 2, 3 },{ -4, -3, -4 },{ 1, -1, 1 },{ 0, 3, -3 } },
+		{ { -3, 0, 2 },{ -1, 1, 0 },{ -1, 3, -3 },{ 0, 1, 2 },{ -2, -3, -4 },{ -3, -1, 0 },{ 1, -4, 2 },{ -2, 1, -4 },{ 2, 3, 0 },{ 0, 0, -3 },{ -4, 2, 3 },{ 0, -4, -2 },{ 1, -4, -1 },{ -2, 1, 2 },{ -3, 3, 2 },{ 1, -1, 1 },{ 0, -4, 0 },{ 3, -1, 3 },{ -1, 3, 1 },{ -3, 0, 2 },{ -4, 2, -1 },{ 1, 3, 1 },{ 3, -4, 3 },{ -3, 3, -2 },{ 1, -1, 3 },{ -3, -1, 1 },{ -2, 1, -3 },{ 3, -2, 2 },{ -4, -3, -1 },{ -4, 2, 0 },{ 0, -4, 1 },{ 2, 0, -4 },{ 2, 3, -1 },{ 1, 1, 2 },{ 3, -4, -3 },{ -2, -2, 1 },{ -1, -4, 3 },{ -4, -1, -2 },{ -3, -2, 0 },{ -2, 0, -4 },{ 3, 3, -2 },{ -2, -1, 1 },{ 1, -2, -1 },{ 2, -3, 2 },{ 1, 3, 3 },{ 3, -1, -4 },{ -3, -2, 3 },{ 2, 1, 0 },{ 0, 3, -3 },{ -4, -4, 3 },{ -1, 2, -4 },{ 2, 1, 3 },{ 1, -2, -2 },{ -3, -4, -1 },{ -1, 3, 0 },{ -2, 0, 1 },{ 0, 2, -3 },{ -3, -4, 1 },{ -1, 0, -3 },{ -2, -4, 1 },{ 3, 1, -2 },{ -1, 0, -3 },{ 2, -3, 0 },{ -2, -4, 2 } },
+		{ { -4, 2, -1 },{ 1, -2, -4 },{ 1, -1, 3 },{ -4, -4, 0 },{ 3, -3, -2 },{ -1, 3, -4 },{ 2, 0, 1 },{ -4, -3, -2 },{ 2, -2, 2 },{ -3, 2, -2 },{ -3, -2, 1 },{ 2, 1, 0 },{ -2, 0, -4 },{ -1, -3, -1 },{ -4, 0, -2 },{ 2, 2, 1 },{ -4, -3, -2 },{ -2, 2, -4 },{ 3, 0, 0 },{ 0, -3, -2 },{ -1, -4, -3 },{ 2, 1, 2 },{ 0, -1, -3 },{ -1, -2, 0 },{ 2, -4, -3 },{ -1, 3, -1 },{ -4, 2, -2 },{ 0, -1, -3 },{ 2, 0, 3 },{ -2, 3, -4 },{ -3, -2, 2 },{ -2, 3, -2 },{ -4, -1, 1 },{ -1, -3, 0 },{ -2, -1, -4 },{ 2, 2, -2 },{ 2, 1, -1 },{ 3, 1, -4 },{ -1, 3, 1 },{ 2, 2, 3 },{ 0, -4, 2 },{ -4, 0, -4 },{ -1, 2, -1 },{ -4, 2, 0 },{ -2, -4, -3 },{ -1, -1, 1 },{ 0, 3, -1 },{ -4, -4, 1 },{ -2, -1, 2 },{ 1, -2, 1 },{ 0, -3, -3 },{ 3, 3, -1 },{ -3, -4, 1 },{ -4, -1, 3 },{ 2, -2, 2 },{ -2, -3, -2 },{ -4, 1, 2 },{ 3, -1, 3 },{ 2, 2, -4 },{ 1, -1, 1 },{ -2, -2, 0 },{ -1, 1, 3 },{ -3, 3, -4 },{ 3, -4, -2 } },
+		{ { -2, -3, -3 },{ 3, 3, 1 },{ 0, -2, -1 },{ 2, 2, -3 },{ -4, 0, 2 },{ 1, -2, 0 },{ 0, 3, 3 },{ -2, -1, -3 },{ 3, 0, 3 },{ 0, -4, 0 },{ -1, -1, -4 },{ 1, 3, -3 },{ -3, -2, 1 },{ 3, 3, 3 },{ 1, -2, -3 },{ -2, -4, -4 },{ -1, 0, -1 },{ 0, 1, 3 },{ -3, -2, 2 },{ -2, 2, -2 },{ 3, -2, 3 },{ -2, 0, -4 },{ -4, 2, -1 },{ -2, -3, 1 },{ 0, 2, 2 },{ 3, 0, 1 },{ 2, -3, 3 },{ -1, -3, -4 },{ 1, 1, 0 },{ 3, 1, -2 },{ -1, -3, 3 },{ 3, -1, -1 },{ 1, -4, -3 },{ 0, 2, 3 },{ -4, 0, -1 },{ -3, 3, 3 },{ 0, -3, 0 },{ -4, -1, -1 },{ 0, -4, -3 },{ 3, -3, 0 },{ -3, -2, -1 },{ 2, 1, -3 },{ 0, -3, 3 },{ 3, -1, -3 },{ -3, 1, 0 },{ -2, 2, -2 },{ 2, -3, 0 },{ 3, -3, -4 },{ 1, 1, -2 },{ 2, 2, 0 },{ -3, 0, -2 },{ -1, -1, 2 },{ -1, 1, -4 },{ 2, 3, -3 },{ 1, 0, -3 },{ 2, -1, -1 },{ 0, -4, -4 },{ -1, -2, -1 },{ -3, 3, -1 },{ 1, -3, 3 },{ -4, -4, -2 },{ 0, -1, -1 },{ 2, 2, 1 },{ 1, -1, 2 } },
+		{ { -1, 1, 3 },{ -3, 0, -2 },{ 0, -3, 0 },{ -3, 2, 3 },{ -2, 0, 1 },{ 2, 1, -1 },{ -1, -4, -3 },{ -3, 2, -1 },{ 1, 1, -4 },{ -1, 3, 3 },{ -4, -3, -1 },{ 2, 2, 1 },{ 3, 1, 2 },{ -1, -3, -1 },{ 0, -1, 0 },{ 2, -1, 3 },{ 3, 3, 2 },{ 1, -4, -1 },{ 2, -1, -4 },{ -4, 3, 0 },{ 0, -4, 1 },{ 1, 1, -1 },{ 2, -3, 3 },{ -3, 3, -2 },{ -1, 0, -4 },{ -4, -4, -2 },{ -2, 3, 2 },{ -3, -2, 0 },{ -3, 2, 1 },{ 0, -4, -3 },{ 1, -3, 0 },{ -3, 2, 2 },{ -2, 1, -2 },{ -1, -2, 2 },{ 3, -4, 1 },{ 0, -2, -3 },{ 1, -3, 2 },{ -2, 2, 2 },{ -1, 0, -2 },{ -3, -1, 3 },{ 1, 2, -2 },{ -2, 3, 1 },{ -1, -1, 2 },{ 1, -3, -4 },{ 0, -2, 3 },{ 3, 3, 2 },{ -4, 0, -3 },{ -1, 1, -1 },{ -2, -1, 3 },{ -3, 3, -4 },{ 2, -4, 1 },{ -2, -2, -1 },{ -4, 2, 2 },{ 3, 1, 1 },{ -3, -3, 0 },{ -4, 3, 3 },{ 3, 2, -2 },{ -1, 1, 2 },{ 2, 0, 0 },{ -4, 2, -3 },{ 3, 1, -4 },{ -3, 3, 2 },{ 0, -2, -2 },{ -4, 0, 0 } },
+		{ { 2, 2, -4 },{ -2, -4, 1 },{ 3, -1, -3 },{ -1, 1, -4 },{ 1, -3, -3 },{ -3, -4, -2 },{ 3, -1, 0 },{ -3, -2, 2 },{ 2, -4, 1 },{ 3, 0, -2 },{ -2, -1, -3 },{ 0, -3, 2 },{ -4, -4, -2 },{ -2, 0, -4 },{ -3, 2, 0 },{ -4, 2, -3 },{ -2, -3, -2 },{ -4, 2, 1 },{ 1, 1, -3 },{ -3, -3, -1 },{ 2, -1, 2 },{ -3, 2, -2 },{ 1, -2, 0 },{ 0, -1, -4 },{ 3, 1, 3 },{ 1, -2, 0 },{ 0, 1, -1 },{ 1, -1, -4 },{ 2, -2, -1 },{ -4, 3, 3 },{ -4, 0, 1 },{ 2, 0, -4 },{ 3, 3, -3 },{ -4, -1, 0 },{ 2, 1, -4 },{ -3, 3, -2 },{ 3, 0, 0 },{ -2, -2, -4 },{ 1, 3, -3 },{ 3, 1, 1 },{ -2, -2, -4 },{ -4, -4, 2 },{ 1, 0, 0 },{ -3, 1, -1 },{ 2, 0, -1 },{ -2, -4, -4 },{ 1, -2, 3 },{ -3, 2, 2 },{ -1, -2, -1 },{ 0, -3, -3 },{ 3, 2, 3 },{ 0, -1, 0 },{ 1, -4, -2 },{ 0, -3, -4 },{ -2, -2, -1 },{ 0, 0, 1 },{ -2, -4, -4 },{ 1, -2, 1 },{ -3, -3, -3 },{ 0, -1, 1 },{ 2, 0, 3 },{ -2, -4, -4 },{ 3, -2, 2 },{ 1, -3, -1 } },
+		{ { 0, 3, -2 },{ -1, 2, 2 },{ -4, -2, 1 },{ 2, -2, -1 },{ 0, 3, 2 },{ -1, 3, 3 },{ -4, -1, -4 },{ 0, 2, 1 },{ -4, 3, -2 },{ -1, -2, 2 },{ -3, 2, 0 },{ 1, 1, -2 },{ 2, 0, 3 },{ 0, 3, -1 },{ 2, 1, 2 },{ 3, -2, 1 },{ -1, -2, -3 },{ -1, -4, 3 },{ 3, 1, 2 },{ 0, -2, 1 },{ -1, 3, -4 },{ 3, -4, -3 },{ -2, 1, 2 },{ -4, -4, 1 },{ -2, -1, -1 },{ 2, -2, -3 },{ -3, 2, 3 },{ 3, 0, 2 },{ -1, -4, -3 },{ -1, 1, -2 },{ 0, -2, -4 },{ -2, -1, 0 },{ 1, -4, 2 },{ -1, -3, 3 },{ -2, 2, -2 },{ 0, -4, 1 },{ -4, 1, 3 },{ 2, -4, -1 },{ -4, 2, 1 },{ -1, -3, 3 },{ 0, -3, -1 },{ 2, 1, -2 },{ 3, 2, -4 },{ -2, 3, -2 },{ -4, -2, 1 },{ 0, -4, 1 },{ 1, 3, -3 },{ 3, -1, 0 },{ 2, -4, 1 },{ -4, 1, 0 },{ -2, 0, -3 },{ -4, 3, -4 },{ 2, 2, 2 },{ -1, 0, -1 },{ -3, 3, 3 },{ 1, -1, -3 },{ 3, 2, 0 },{ -4, 1, 3 },{ -1, -3, -2 },{ 3, 3, -1 },{ -2, -4, 0 },{ -1, 1, -1 },{ -4, 3, 1 },{ -3, 0, -3 } },
+		{ { -2, -2, 0 },{ 2, -4, 3 },{ 1, -1, -2 },{ -4, 1, -1 },{ 0, -3, 2 },{ 3, 0, -1 },{ 1, -2, -2 },{ -2, 1, 2 },{ 1, -3, -3 },{ 0, 0, 3 },{ 3, -4, -4 },{ -1, -1, 1 },{ -4, -2, -3 },{ -3, -4, -1 },{ -1, -3, -4 },{ 1, 1, 3 },{ 0, -1, 0 },{ -3, 0, -4 },{ 2, 0, -2 },{ -2, -3, -1 },{ -4, -1, 3 },{ -1, 0, 0 },{ -3, 3, -3 },{ 2, 2, -2 },{ -1, 3, 0 },{ -2, -4, 1 },{ -4, 3, -3 },{ 0, -3, -2 },{ -2, -1, 1 },{ 2, 2, 3 },{ 3, -3, -1 },{ 0, 3, -1 },{ -3, 2, -3 },{ 2, 0, 1 },{ -4, -3, -1 },{ 1, 0, -3 },{ -1, -1, 2 },{ -3, -2, -2 },{ 1, 0, -4 },{ 2, 1, 0 },{ -3, -1, -3 },{ -1, -2, 2 },{ -4, -4, 3 },{ -1, -1, -3 },{ 2, 2, 3 },{ -3, 1, -2 },{ -4, 0, 0 },{ -2, -3, -4 },{ 0, 3, -2 },{ 1, -1, 3 },{ 3, -2, 2 },{ -1, 0, 0 },{ -3, -3, -3 },{ 2, -1, 3 },{ 3, 1, 0 },{ -4, -4, -4 },{ -1, -2, 2 },{ 2, 0, -1 },{ 0, 3, -4 },{ -3, -2, 2 },{ 1, 2, -3 },{ -4, -2, 0 },{ 1, -1, -2 },{ 3, -3, 3 } },
+		{ { 0, 1, -1 },{ -3, 0, -4 },{ -1, 3, -4 },{ -2, 0, 0 },{ 2, -4, -3 },{ -3, 2, 1 },{ -2, -3, -4 },{ 3, -1, 0 },{ 2, 0, -1 },{ -3, -4, -1 },{ -2, 3, -4 },{ 1, 1, 1 },{ 3, 2, 0 },{ -2, -1, 3 },{ 2, 2, -2 },{ -4, -4, -2 },{ -2, 3, -1 },{ -4, 3, 0 },{ 2, -4, -3 },{ -3, 2, 1 },{ 1, 2, -2 },{ 1, -2, 1 },{ 3, -1, -4 },{ 0, -3, 2 },{ 1, 0, 1 },{ 2, 0, -4 },{ -1, -3, 3 },{ 3, 1, 0 },{ -3, 3, 0 },{ -4, 0, -4 },{ 1, -1, -2 },{ -2, -4, 3 },{ -1, -2, 2 },{ 0, 1, -2 },{ 3, -2, -4 },{ -1, 1, 0 },{ 2, 3, 2 },{ 3, -1, -3 },{ 0, -4, 0 },{ -2, 3, 1 },{ 3, 3, 2 },{ -2, 0, -2 },{ 1, 0, 0 },{ 0, -3, 2 },{ 0, -1, 0 },{ 3, -2, -2 },{ 2, 2, 3 },{ -1, 0, 2 },{ -3, 1, -1 },{ -3, -4, -4 },{ 1, -3, -2 },{ -2, 1, 1 },{ -3, -4, -2 },{ 1, -2, 1 },{ -2, 2, -2 },{ 0, -3, -3 },{ -2, 3, -1 },{ -2, -1, 3 },{ -4, 0, 0 },{ 2, -1, -2 },{ 0, -3, 3 },{ 2, 1, 2 },{ -1, 2, -4 },{ -2, 0, -3 } },
+		{ { -4, 3, 1 },{ 1, -3, 2 },{ 3, 2, 1 },{ -2, -3, 0 },{ 3, -2, 3 },{ -4, 0, -3 },{ 0, 3, 1 },{ -1, -4, 3 },{ -4, 2, 0 },{ 0, 3, 3 },{ -1, -2, -2 },{ -4, 0, 2 },{ 2, -3, 0 },{ 0, 0, -3 },{ -3, 3, 2 },{ 0, -1, 1 },{ 3, -2, 1 },{ 1, 2, 3 },{ -1, -3, 2 },{ 3, -1, -1 },{ -2, -3, -3 },{ 0, 1, 3 },{ -4, -4, -1 },{ -3, 1, 3 },{ 3, -3, -1 },{ -3, 2, -2 },{ 1, -2, 2 },{ -2, -1, -1 },{ 1, -4, -3 },{ 0, -3, 2 },{ -4, 2, 1 },{ -3, 1, 0 },{ 2, -1, -4 },{ -4, 3, 1 },{ -3, 2, 3 },{ 1, -4, -2 },{ -2, 2, 1 },{ -3, -3, -1 },{ 0, 1, 3 },{ -4, -1, -2 },{ 1, -3, -1 },{ -4, 2, -4 },{ 3, 3, -1 },{ -3, -4, -4 },{ -2, 2, 1 },{ 1, -3, -4 },{ -2, -2, -3 },{ 0, -4, 1 },{ 3, 3, -3 },{ -1, -2, 1 },{ 3, 2, -1 },{ 0, -1, -4 },{ 2, 3, 2 },{ 3, 0, -1 },{ -4, 3, 2 },{ 1, -2, -3 },{ 2, 1, 1 },{ 3, -4, -2 },{ 1, 2, -4 },{ -2, -4, 1 },{ 3, -2, -3 },{ -3, 3, -1 },{ 0, -4, 1 },{ 2, -4, 3 } },
+		{ { -1, -2, -1 },{ -3, -1, -3 },{ 2, -1, -2 },{ -4, 1, 3 },{ 0, 3, -4 },{ 2, -1, -2 },{ 1, 1, 0 },{ -3, 2, -2 },{ 2, -2, -3 },{ -2, -1, 1 },{ 3, -1, -3 },{ 1, -3, -2 },{ -3, 3, 3 },{ -2, -2, -2 },{ 1, 0, -4 },{ 2, -4, 0 },{ -1, 1, -3 },{ 0, -3, -4 },{ -4, 1, -2 },{ 1, 0, -4 },{ -1, 1, 2 },{ 2, 3, -2 },{ -2, -2, 0 },{ -1, 3, -3 },{ -2, -1, -4 },{ 0, 2, -2 },{ -4, 1, 2 },{ -1, 0, -4 },{ 2, 3, -1 },{ 3, -2, 3 },{ -1, 0, -3 },{ 1, -3, -3 },{ 3, -1, -1 },{ 1, -4, 2 },{ -2, 0, 0 },{ 3, -3, -3 },{ -1, -2, -2 },{ -2, 0, -4 },{ 2, 2, 2 },{ -1, -2, -4 },{ 2, -4, 0 },{ -2, -2, 3 },{ -1, 1, 1 },{ 2, -1, -2 },{ -4, 1, -1 },{ -1, 0, 2 },{ -4, 3, -1 },{ 0, -1, 0 },{ 2, 1, 2 },{ -4, -1, 3 },{ -1, 2, -3 },{ -4, 1, 3 },{ -1, -3, 0 },{ -2, -4, -4 },{ 0, 2, 0 },{ -3, -1, 2 },{ -1, 1, 3 },{ -3, -3, -3 },{ 0, -1, 1 },{ -1, 0, 2 },{ -3, 1, -1 },{ -2, 3, 0 },{ 1, -1, -2 },{ 3, 0, -4 } },
+		{ { 1, 2, 3 },{ -1, -4, 0 },{ 0, -3, -1 },{ -2, 2, -2 },{ 1, -4, 2 },{ -1, -2, -1 },{ -4, -3, 2 },{ 3, -3, -3 },{ 0, 0, -4 },{ 1, -4, 2 },{ -4, 1, 0 },{ -1, 1, -4 },{ -1, -4, 2 },{ 3, -2, -1 },{ -4, 2, 1 },{ 2, -3, 2 },{ -3, -1, -1 },{ -2, 0, -2 },{ 3, -2, 1 },{ -4, 3, 3 },{ 0, -4, 0 },{ -3, -1, 1 },{ 2, 0, -3 },{ 1, 2, 2 },{ -1, -4, 1 },{ 3, -4, 3 },{ 2, -1, 0 },{ -4, -3, -3 },{ -2, 1, 1 },{ -3, -4, -2 },{ -1, 3, 0 },{ 2, 2, 3 },{ -2, -2, -1 },{ 0, 3, -4 },{ -1, -3, 1 },{ -4, 2, 3 },{ 1, -1, 1 },{ -4, -4, -1 },{ 3, 3, 1 },{ -3, 0, -3 },{ -2, 2, 2 },{ 0, 0, -1 },{ 0, -3, 3 },{ -3, 3, -3 },{ 3, -2, 2 },{ 1, -4, 3 },{ 3, 2, -2 },{ -3, -3, -4 },{ 1, -3, -1 },{ -2, 0, -2 },{ 1, -2, 0 },{ -3, -4, 1 },{ 1, -1, -3 },{ 3, -1, -2 },{ -4, 0, 3 },{ 0, -4, -4 },{ 2, -2, -1 },{ 1, 2, 0 },{ -4, 3, -2 },{ 3, 1, -4 },{ 1, -3, 3 },{ -4, -2, -3 },{ -2, -3, -2 },{ -4, 0, 1 } },
+		{ { -2, 1, 2 },{ 2, 3, -3 },{ -4, 0, -4 },{ 3, -2, 1 },{ -3, 3, 0 },{ -1, 1, -4 },{ -3, -1, 1 },{ 2, 3, 2 },{ -2, 2, -1 },{ -3, -2, 3 },{ 3, 2, -1 },{ 2, 3, 1 },{ 0, -1, -3 },{ -4, 0, 0 },{ 1, 1, -4 },{ -1, 1, -3 },{ -3, 3, 3 },{ 2, -4, 2 },{ 0, 2, 0 },{ -2, -2, -1 },{ 3, 0, -3 },{ 1, -3, -1 },{ -3, 1, -4 },{ 0, -3, 2 },{ -4, 1, -1 },{ -3, -2, -3 },{ 1, 1, 1 },{ 3, 3, 3 },{ 0, -2, -2 },{ 1, -1, 2 },{ 3, 1, -4 },{ -4, -4, 1 },{ -4, 1, 2 },{ 0, 0, -3 },{ 2, -1, -2 },{ 3, 1, 0 },{ 0, 3, -4 },{ 1, 0, 3 },{ 1, -4, 0 },{ 0, 1, -2 },{ 2, -1, 1 },{ 3, 2, -3 },{ -4, -4, -4 },{ 2, 0, 0 },{ -2, -3, 0 },{ 0, 2, -3 },{ -1, 0, 0 },{ -4, 1, 1 },{ -1, 3, 3 },{ 2, -4, -4 },{ 0, 0, -2 },{ 3, 3, -1 },{ -2, 3, 3 },{ 2, 1, 1 },{ -1, -3, -1 },{ -2, 3, -2 },{ 1, 0, 1 },{ -3, -3, -3 },{ -2, -2, 2 },{ -1, -4, -1 },{ 2, -1, -1 },{ 3, 2, 1 },{ 0, 1, 3 },{ -1, 2, 0 } }
+	},
+	{
+		{ { 3, -1, -4 },{ 1, -2, 3 },{ 2, -1, 0 },{ -1, 0, 0 },{ -3, -3, 3 },{ -4, 2, -1 },{ 2, -4, 3 },{ 0, 2, -4 },{ 3, -1, -2 },{ -4, 2, 3 },{ 2, 0, -4 },{ 3, -2, -2 },{ -2, -1, 2 },{ -3, 1, 0 },{ -1, -4, -3 },{ -3, -3, 3 },{ 1, -4, -4 },{ 3, -1, 1 },{ -1, -2, 2 },{ -2, -4, -4 },{ 3, -1, 1 },{ -1, 1, 2 },{ -2, -1, -2 },{ 1, 2, 1 },{ -4, 1, 2 },{ 0, -3, -3 },{ 2, -2, -3 },{ -4, 0, -2 },{ 1, -4, 3 },{ -3, 3, -1 },{ -2, -1, -2 },{ 0, -4, -3 },{ -3, 1, -1 },{ 3, 1, -4 },{ -1, -2, -2 },{ 2, -1, -3 },{ -2, 3, -4 },{ -2, -2, -1 },{ 3, 1, -2 },{ 0, -3, 1 },{ 0, -2, 2 },{ -4, 2, -2 },{ -1, -3, 1 },{ 2, -4, -4 },{ -2, 2, -1 },{ -4, 3, -1 },{ -1, -1, -3 },{ 1, 1, 0 },{ -3, -2, 1 },{ 0, 0, -3 },{ -4, 0, -1 },{ 3, 1, -4 },{ 2, -3, 0 },{ -1, 1, -2 },{ -4, 3, 1 },{ -2, 2, 0 },{ -1, -2, 0 },{ -4, 2, 3 },{ -1, -1, 2 },{ 2, -3, 1 },{ 1, 3, -1 },{ -2, -1, 3 },{ 0, -2, 2 },{ -3, 2, -2 } },
+		{ { -2, -3, -1 },{ -1, -4, 2 },{ -4, 2, -3 },{ 3, -2, -3 },{ 1, 3, -4 },{ 1, 1, 2 },{ -2, 1, 1 },{ -4, -3, -1 },{ 0, 0, 0 },{ -2, -2, -1 },{ -2, 2, 2 },{ 1, -3, 0 },{ 0, -3, -3 },{ 0, 3, -1 },{ 3, -1, 1 },{ 1, 2, -2 },{ -2, 3, -1 },{ -4, 1, -3 },{ 2, 1, -1 },{ 1, 3, 2 },{ -3, -3, -2 },{ 1, 2, -1 },{ 2, -2, -4 },{ -4, -4, -3 },{ 0, 0, 0 },{ 2, 3, 3 },{ -3, -1, 0 },{ 3, 1, -4 },{ -1, 2, 3 },{ 2, 2, -4 },{ 3, 0, 2 },{ -4, -3, -3 },{ -1, 0, 0 },{ 1, 3, 2 },{ -4, 2, -1 },{ -3, -3, 2 },{ 1, 3, 0 },{ -1, 0, 3 },{ 2, -3, -3 },{ -2, -4, 1 },{ 2, 1, -4 },{ -3, 0, -2 },{ 3, -2, 3 },{ 0, 1, -3 },{ -3, -2, 1 },{ 3, -3, 1 },{ 1, -1, 3 },{ -2, 3, 2 },{ 2, 2, -2 },{ -1, -3, 3 },{ -2, -1, -2 },{ 2, 2, 2 },{ -3, -2, 3 },{ 1, -2, -3 },{ -3, -4, -2 },{ 3, 0, 3 },{ 1, -2, -3 },{ -2, 1, -4 },{ 3, -4, 0 },{ -3, 1, -4 },{ -1, 0, 3 },{ -4, 2, -3 },{ 3, 1, 0 },{ -3, 3, 1 } },
+		{ { 3, 0, -4 },{ -1, 3, 1 },{ -2, 0, 0 },{ 0, -3, 3 },{ -2, -1, 1 },{ 3, -4, -2 },{ -3, -2, 0 },{ 1, 3, -4 },{ 3, -4, 2 },{ 1, -1, -2 },{ 2, -4, 1 },{ -4, 1, -4 },{ -1, 3, 3 },{ 2, 0, -4 },{ -4, -2, 0 },{ -1, 0, 2 },{ 2, -3, 3 },{ -1, -1, 0 },{ 0, -2, -4 },{ -3, 0, -3 },{ -4, 0, 0 },{ 0, 1, 3 },{ -1, -3, 1 },{ 3, 3, 3 },{ -2, 1, -1 },{ -1, -3, -2 },{ -3, 2, 1 },{ 1, -4, -1 },{ 0, -3, -3 },{ -4, -2, 1 },{ -1, -2, -1 },{ 2, -1, 3 },{ 0, 2, -4 },{ 2, -4, 0 },{ -2, -3, 3 },{ 0, 0, -3 },{ -4, -4, 1 },{ 0, -1, -1 },{ -4, 2, 2 },{ -3, 3, -3 },{ 3, 0, 0 },{ 1, -4, 2 },{ -2, 3, -1 },{ 1, -1, -2 },{ -4, 0, -4 },{ 0, 2, 2 },{ -1, -2, -3 },{ -3, -4, -1 },{ 0, 0, -4 },{ 3, -4, 0 },{ 1, 2, -4 },{ -4, -4, -1 },{ -1, 0, 2 },{ 0, 3, -4 },{ 2, -1, -1 },{ -4, 1, 2 },{ 0, -3, 1 },{ -3, -1, -2 },{ 0, 3, -3 },{ 2, -3, -1 },{ -4, -2, 1 },{ -1, -3, -3 },{ 2, -4, -2 },{ 0, -1, -1 } },
+		{ { 1, -3, -3 },{ -4, 1, 3 },{ 2, 2, -2 },{ -3, -2, -1 },{ 0, 1, -4 },{ -4, -1, -2 },{ 2, 0, 2 },{ -1, 2, -3 },{ -3, 1, 3 },{ -1, 3, -3 },{ 0, -1, -3 },{ -3, 1, -1 },{ -3, -2, 1 },{ 1, 1, 2 },{ -2, -4, -3 },{ -3, 2, -4 },{ 2, -3, -2 },{ -2, 3, 0 },{ 3, -4, 3 },{ -1, 3, 3 },{ 3, -4, -1 },{ 1, -1, -4 },{ -3, 0, -3 },{ -2, -2, 2 },{ 3, -1, -3 },{ 1, -4, -4 },{ -4, -1, 2 },{ 0, 1, 2 },{ -2, 0, -2 },{ 3, 3, 2 },{ -3, -4, 0 },{ 1, 3, -2 },{ -3, 0, 1 },{ 3, -2, 2 },{ 2, -1, -2 },{ -1, 0, -2 },{ 3, 1, -4 },{ 2, -2, 2 },{ -2, -2, -2 },{ 1, 1, -1 },{ -1, -1, 3 },{ -4, 2, -3 },{ -1, -3, 1 },{ 2, 3, 2 },{ -3, 1, 0 },{ 2, -4, -2 },{ 3, 0, 0 },{ -4, 2, 0 },{ 1, 1, -2 },{ -4, -1, 3 },{ -1, 3, 0 },{ 0, -3, -3 },{ -2, 0, 1 },{ 3, 2, 3 },{ -2, -3, 0 },{ -1, 3, -3 },{ 2, -4, -1 },{ 1, 2, 3 },{ -3, -2, 2 },{ 1, 0, 2 },{ -2, 2, -2 },{ 0, 3, 3 },{ 1, -2, 1 },{ -4, 1, 2 } },
+		{ { -2, 2, -4 },{ 1, -2, 0 },{ 3, -4, -3 },{ 2, -3, 2 },{ -2, 1, 1 },{ 1, 3, 3 },{ -1, -3, -3 },{ 0, -2, 0 },{ -4, -1, 1 },{ 3, -3, -1 },{ -2, -2, 3 },{ 3, 2, 2 },{ 2, -4, -2 },{ -2, -3, -2 },{ 3, -1, 1 },{ 0, -1, -1 },{ -4, 1, 2 },{ 0, 2, -4 },{ 1, -1, -2 },{ -3, -2, 1 },{ 2, 2, -2 },{ -2, -3, 1 },{ 0, 3, -2 },{ -4, 1, 0 },{ 1, 0, 2 },{ -1, 2, 0 },{ 2, -2, -2 },{ 2, 3, 0 },{ -2, -1, 1 },{ -4, -4, -4 },{ 1, 1, 3 },{ -1, 1, 0 },{ -3, -3, -3 },{ -2, 2, -4 },{ -4, 1, -1 },{ 0, 3, 1 },{ -3, -3, 3 },{ 1, 2, -1 },{ 3, 1, -4 },{ 0, -3, 0 },{ 2, -3, 1 },{ -3, 0, -4 },{ 3, -2, -1 },{ 0, -4, -3 },{ -2, 2, 3 },{ -1, -3, -1 },{ 0, 3, 3 },{ -2, -3, -4 },{ 3, -2, 2 },{ -2, 2, 2 },{ 1, 1, 1 },{ 3, -3, -3 },{ -3, -1, -1 },{ 1, -4, -2 },{ -3, 1, 2 },{ 3, -2, -4 },{ -4, 3, 1 },{ -2, 0, -1 },{ -1, -4, -4 },{ 2, 3, 0 },{ 3, -1, -3 },{ -2, 0, -4 },{ 3, -1, -1 },{ -2, 0, 2 } },
+		{ { 2, -4, 1 },{ -3, -1, -1 },{ 0, 0, 1 },{ -1, 3, -3 },{ -4, 2, -1 },{ 3, -2, 0 },{ -3, -4, -4 },{ 2, 2, 1 },{ 2, 2, -2 },{ -4, -4, -4 },{ 1, 0, 0 },{ 0, 3, 0 },{ -1, -1, -4 },{ -4, 2, 3 },{ 0, 3, 0 },{ -1, 0, 3 },{ 3, -2, -3 },{ -3, -4, 0 },{ -4, 0, 2 },{ 2, 1, -3 },{ -2, 2, 0 },{ -4, -4, 2 },{ -1, 2, 3 },{ 2, -4, -1 },{ 0, -3, -4 },{ -3, 3, 3 },{ -3, -3, -2 },{ 3, 1, -4 },{ 0, -2, 3 },{ 2, 2, -1 },{ 0, 0, -2 },{ 3, -2, -4 },{ -2, -2, 2 },{ 0, 3, -1 },{ 1, -4, 3 },{ 2, -2, -3 },{ -4, 2, 1 },{ -2, -4, 0 },{ -3, -1, -3 },{ -1, -4, 3 },{ -4, 3, -2 },{ 1, -1, 0 },{ 0, 2, 2 },{ -2, -3, 0 },{ -4, -1, -4 },{ 3, -2, 1 },{ 1, 1, 1 },{ -3, -1, -3 },{ 2, 0, -3 },{ -1, -4, -1 },{ -3, -2, -4 },{ 2, 0, 3 },{ -4, 3, -1 },{ 2, -1, 1 },{ -4, 2, -2 },{ 0, 0, 3 },{ -1, -3, 0 },{ 3, -1, -3 },{ 0, 1, -2 },{ -4, -3, 0 },{ -3, -4, 1 },{ -1, 2, 3 },{ -3, -3, 0 },{ -1, 3, -2 } },
+		{ { 3, 1, 3 },{ 0, 3, 2 },{ -4, 0, -4 },{ -1, -1, 3 },{ 1, -4, -2 },{ 1, 0, -1 },{ -2, -1, 3 },{ -2, 0, -1 },{ 0, 0, 2 },{ 1, 1, 3 },{ -2, -3, -2 },{ -3, -2, 1 },{ 3, 0, -4 },{ 2, -2, -3 },{ 1, 1, 1 },{ -3, -4, -3 },{ 2, 2, 2 },{ -1, 3, -2 },{ 1, -3, 1 },{ 0, -2, -4 },{ -1, -3, 1 },{ 3, -1, -4 },{ 1, -1, -2 },{ 3, 1, 1 },{ -4, -2, -3 },{ -2, 0, 1 },{ 1, 2, -1 },{ -1, 0, -3 },{ -4, -3, 1 },{ -3, -3, -3 },{ 1, 3, 1 },{ -4, -4, 2 },{ 2, -1, -2 },{ 3, 1, 1 },{ -1, 0, 3 },{ -2, -3, 0 },{ 0, -1, -3 },{ 3, 0, 2 },{ -1, 3, -1 },{ 2, 1, 3 },{ 1, 2, -2 },{ -3, -1, 1 },{ -3, 1, -4 },{ 2, 0, -2 },{ 1, 3, 2 },{ -3, 0, -3 },{ 0, -4, -2 },{ -1, 3, 3 },{ 2, -3, -1 },{ 0, 2, 1 },{ -4, 0, -2 },{ -1, -2, 0 },{ 0, 3, -4 },{ 0, -3, 2 },{ -1, 0, -4 },{ 1, -4, -1 },{ -3, -1, -3 },{ 2, 2, 1 },{ -2, 1, 3 },{ 2, 0, 2 },{ 1, -2, -1 },{ 0, 1, -3 },{ 2, -4, -4 },{ -4, -2, -2 } },
+		{ { 0, -3, 2 },{ -2, 1, -1 },{ 2, -3, -3 },{ -2, -3, 0 },{ 3, 1, -4 },{ -4, 3, 1 },{ 3, 1, -2 },{ 0, -2, -4 },{ -3, -4, 0 },{ 3, 3, -2 },{ -4, 1, -3 },{ -1, 2, -1 },{ 0, -3, 3 },{ -4, -4, 2 },{ -2, 1, -1 },{ -3, -3, -4 },{ 1, 0, 1 },{ -2, -1, -1 },{ 3, 1, -1 },{ -3, 3, 3 },{ -4, 0, -3 },{ 0, 3, -1 },{ -3, 0, 0 },{ 1, -2, -3 },{ -2, 2, 3 },{ -1, -4, -1 },{ 3, -1, 2 },{ 0, -1, -2 },{ -2, -4, 3 },{ -1, 1, -4 },{ 2, 0, 0 },{ -2, 3, 3 },{ -4, -3, -1 },{ 0, 0, -3 },{ -3, 2, -2 },{ 3, -1, -4 },{ -4, -3, -1 },{ 1, 2, -2 },{ -2, -2, -4 },{ -4, 0, 1 },{ -2, -3, -3 },{ 3, -2, -1 },{ -1, -4, 3 },{ 2, 1, -1 },{ -4, -2, 1 },{ 3, 0, 0 },{ -2, -3, -1 },{ -4, 2, 2 },{ -3, -1, 0 },{ 3, 3, -4 },{ 1, -4, 3 },{ -2, 1, 2 },{ 3, -3, -3 },{ 3, 2, 1 },{ -2, -3, 0 },{ 2, 1, 1 },{ -3, 2, 2 },{ 1, -4, -4 },{ -4, -2, -2 },{ -1, 3, -4 },{ -3, 3, 1 },{ 3, 0, -1 },{ -1, -1, 1 },{ -4, 2, -3 } },
+		{ { 1, 0, -3 },{ 1, -4, -2 },{ -3, 2, 1 },{ -1, 2, 3 },{ 0, -1, 2 },{ -3, -2, 1 },{ -1, -3, -3 },{ -4, 3, 2 },{ -1, -3, 1 },{ 1, -1, -4 },{ 3, -2, 2 },{ -2, -4, 0 },{ 1, 3, -1 },{ -1, -1, -2 },{ 2, 2, 0 },{ -1, -2, 3 },{ 3, -3, -2 },{ -4, 3, -4 },{ 0, -4, 0 },{ 2, -2, 2 },{ 2, -3, 0 },{ -2, 2, 2 },{ 3, -4, 3 },{ -1, -3, -1 },{ 0, 3, 2 },{ 2, 1, -4 },{ -4, -3, 2 },{ 1, 2, 0 },{ 3, 3, 1 },{ -3, -1, -1 },{ -1, 0, -2 },{ 1, 2, 2 },{ -3, -2, -4 },{ 1, -4, 1 },{ -2, 2, 2 },{ 1, -2, 0 },{ -1, 3, 2 },{ 2, 1, 3 },{ 1, -4, 0 },{ 0, -2, 2 },{ 0, 3, -2 },{ 3, -1, 2 },{ -1, 2, 2 },{ -2, -4, -3 },{ 0, 3, -2 },{ -1, -3, 3 },{ 1, 1, -3 },{ 0, -2, -4 },{ -2, -1, 2 },{ 1, 1, -2 },{ -4, -4, -1 },{ -2, -1, 1 },{ 1, 1, -1 },{ -3, 0, -2 },{ -4, -2, -3 },{ 0, 3, 3 },{ 3, -2, -1 },{ -2, 0, 3 },{ 0, -3, 1 },{ 3, -4, -1 },{ -2, -1, -3 },{ 1, -3, 3 },{ -2, 2, 2 },{ 2, -1, 0 } },
+		{ { -1, -2, -2 },{ -4, -1, 3 },{ 3, 3, -4 },{ 1, -2, 0 },{ -2, -4, -1 },{ 2, 0, -2 },{ 2, 2, 3 },{ 2, -4, -1 },{ 1, 0, -1 },{ -2, 2, 3 },{ 0, -1, -3 },{ -4, 0, 1 },{ 2, 2, -4 },{ 3, 1, 1 },{ -3, -1, -3 },{ 0, 3, 0 },{ -2, 2, 2 },{ 1, 0, 3 },{ -3, 1, -3 },{ -1, -1, -2 },{ -4, -4, -3 },{ 1, 1, 1 },{ -3, -2, -4 },{ -4, -1, -2 },{ 2, 2, -2 },{ -1, 0, 0 },{ -3, -3, -4 },{ -2, -2, -3 },{ 0, 1, -1 },{ 2, -2, 3 },{ 0, -4, -4 },{ 3, -3, 0 },{ -1, -1, -1 },{ 3, 1, -3 },{ -4, 3, 3 },{ 2, -4, -2 },{ 0, 1, -2 },{ -3, -3, -3 },{ -3, -1, 1 },{ 2, 2, -3 },{ -1, -4, -4 },{ -3, 1, 0 },{ -4, 0, -3 },{ 1, -1, -4 },{ 3, -2, 1 },{ -3, 3, 2 },{ 2, 0, -4 },{ 3, 2, 1 },{ -1, -4, 3 },{ -1, 3, -3 },{ 2, -2, 0 },{ 2, 2, -4 },{ -1, -1, 3 },{ -3, 3, 2 },{ 1, -4, -2 },{ -2, -1, -4 },{ -1, 1, -1 },{ 1, 3, -3 },{ -3, -1, 0 },{ 1, 0, -4 },{ -4, 2, 2 },{ 0, 1, -2 },{ -3, -4, -4 },{ 2, 3, 0 } },
+		{ { 0, -3, 2 },{ -2, 1, -1 },{ 3, 0, 1 },{ -4, -3, -2 },{ 1, 1, -3 },{ -2, 3, -4 },{ -3, -1, 2 },{ 0, 1, -2 },{ -4, -2, -3 },{ -3, 3, 2 },{ 2, 1, 0 },{ -1, -3, -2 },{ -2, -2, 2 },{ 0, -4, 3 },{ -4, 0, -4 },{ 2, -3, 1 },{ -1, -4, -1 },{ -4, -2, 1 },{ 3, 2, -2 },{ 1, -3, 2 },{ -1, 3, -4 },{ 3, 0, -1 },{ 0, 1, 2 },{ 1, -1, 0 },{ -2, 3, -3 },{ -3, -4, 1 },{ 1, 1, 3 },{ 3, 3, 1 },{ -4, -4, -3 },{ -3, 0, -3 },{ -4, 2, 1 },{ -2, 3, -2 },{ 2, 1, 3 },{ -3, -3, -1 },{ -1, 0, 0 },{ 2, -2, -4 },{ -2, -1, 1 },{ -4, 2, -1 },{ 3, 0, 1 },{ -1, 0, -1 },{ -4, 2, 3 },{ 1, -3, -1 },{ 2, 3, 1 },{ 0, -3, 3 },{ -2, 1, -1 },{ -4, -4, -2 },{ -2, -1, 0 },{ -4, -3, -1 },{ 1, -2, -2 },{ -3, 0, 2 },{ -3, 0, 0 },{ 0, -3, -3 },{ -4, -2, -4 },{ 3, -4, 0 },{ 2, 0, 1 },{ 0, 2, 0 },{ 3, -3, 2 },{ -4, -4, -2 },{ -1, 1, 3 },{ 3, 2, 1 },{ 2, -2, 3 },{ -1, -3, -2 },{ 3, 3, -1 },{ -3, 0, 1 } },
+		{ { 1, -2, 3 },{ -1, 3, -3 },{ -3, 0, 0 },{ 0, -4, 2 },{ -4, 3, 0 },{ -1, -2, 3 },{ 3, -3, 1 },{ 1, -1, 0 },{ -2, -4, -2 },{ 3, 0, 0 },{ 0, -3, -4 },{ -4, 3, -1 },{ 3, 0, -3 },{ 1, -2, 0 },{ -3, 2, -2 },{ 2, 1, -2 },{ -2, -1, -4 },{ 2, 0, -3 },{ 0, -2, 0 },{ -1, 2, 3 },{ -2, -1, 1 },{ -4, -3, 0 },{ 1, 2, -3 },{ -1, -3, 3 },{ 3, -4, 2 },{ 2, 0, -1 },{ 0, -2, -2 },{ -1, -1, 2 },{ 2, 1, 0 },{ 1, -3, 2 },{ 0, -1, 3 },{ -3, -2, 1 },{ -2, 1, -3 },{ 1, -3, 2 },{ 0, 0, -4 },{ -3, 2, 1 },{ 3, -4, 3 },{ 1, -3, 0 },{ 0, 3, -4 },{ 2, -4, 3 },{ -2, -1, 2 },{ 3, -2, -4 },{ -3, -4, -2 },{ 3, 0, 0 },{ -1, 1, 1 },{ 1, -2, -4 },{ 2, 2, 3 },{ -2, 3, 0 },{ 3, 1, -3 },{ 0, -3, 1 },{ -2, 2, 2 },{ 3, 3, -1 },{ -1, 1, 1 },{ 0, 1, -1 },{ -2, -3, 3 },{ -3, 3, -3 },{ -4, 0, 2 },{ 2, -2, -4 },{ 0, 3, -1 },{ -2, -1, -3 },{ -4, -4, 0 },{ 0, -1, -3 },{ -2, -2, 2 },{ -4, 2, -4 } },
+		{ { 3, -1, -1 },{ -1, -3, -4 },{ 2, 1, -2 },{ 2, -1, 3 },{ 3, 2, -4 },{ 0, 0, -1 },{ -3, 1, -3 },{ 0, 2, -4 },{ -2, -1, 3 },{ 2, -4, 1 },{ -1, 2, 3 },{ 1, -1, 2 },{ -3, -1, -1 },{ -1, -4, 2 },{ 1, 3, 0 },{ 3, -3, 2 },{ -3, 1, 3 },{ -4, -4, 2 },{ -2, 3, -4 },{ -3, 1, -1 },{ 3, -4, 2 },{ 2, 0, -2 },{ -2, -2, -4 },{ -3, 1, 0 },{ -4, 2, -1 },{ 0, -2, -4 },{ 1, 2, 3 },{ -3, 2, -4 },{ -2, -3, -1 },{ 3, 3, 0 },{ -1, 0, -2 },{ 3, -4, -4 },{ 2, 2, -3 },{ -4, -4, -1 },{ 3, 3, 2 },{ -4, -1, -2 },{ 0, 1, -3 },{ -1, -2, 2 },{ -2, 0, -2 },{ -4, -2, -2 },{ 1, 1, 0 },{ -1, 2, -1 },{ -2, -1, -3 },{ -4, 2, 3 },{ 2, 3, -3 },{ -3, -1, -2 },{ 0, 0, 2 },{ -1, -4, 3 },{ 2, 1, -3 },{ -4, -2, -4 },{ 2, -4, -2 },{ 1, -1, 3 },{ 1, -4, -3 },{ -4, 2, -2 },{ 2, -2, -4 },{ -1, -1, -1 },{ 1, 1, -2 },{ -1, -2, 1 },{ -3, 0, 2 },{ 2, -3, -4 },{ -1, 3, 1 },{ -3, 1, 0 },{ 1, 0, -2 },{ 2, -4, 2 } },
+		{ { -3, 1, -3 },{ 0, 2, -1 },{ -4, -4, 1 },{ -3, -2, 2 },{ -1, -1, -2 },{ -2, -4, 0 },{ 2, -3, 3 },{ -4, 3, 2 },{ 2, -3, -3 },{ -3, 3, -1 },{ -4, 1, -3 },{ -2, -2, -4 },{ 3, 3, 1 },{ -4, 1, 3 },{ -2, 0, -4 },{ -1, -1, -1 },{ 0, 2, 0 },{ 3, 3, -2 },{ 1, -3, 1 },{ 2, -1, -3 },{ -3, -2, -2 },{ 0, 2, 2 },{ -1, 3, -4 },{ 2, 0, 1 },{ -2, -1, 1 },{ -2, 3, -3 },{ -4, -4, 0 },{ 2, 0, 3 },{ -4, -1, -2 },{ 1, 1, -4 },{ -3, -2, -1 },{ 1, -2, 2 },{ 0, 0, 0 },{ -1, 2, 3 },{ -2, -2, 0 },{ 1, -3, -1 },{ -3, 0, -3 },{ 2, 3, 0 },{ 1, 2, -4 },{ -3, -3, 2 },{ 3, 3, -3 },{ 0, 0, 3 },{ -3, -3, 1 },{ 0, 2, 2 },{ 3, -4, 0 },{ 0, -2, -1 },{ -2, -3, -4 },{ -4, -1, 1 },{ 1, 3, -2 },{ -3, -1, -1 },{ -1, 0, 0 },{ -2, 1, 2 },{ -1, -1, -3 },{ -3, 0, 1 },{ 0, 3, 3 },{ 3, -4, 0 },{ -2, 1, -4 },{ 3, -4, 3 },{ 1, 2, 0 },{ -3, 0, -1 },{ 1, 1, -3 },{ 3, -3, 3 },{ -1, -3, -2 },{ -4, 2, 1 } },
+		{ { 0, -2, 3 },{ -2, 3, 1 },{ 3, 0, -4 },{ -1, 2, -2 },{ 1, 1, -3 },{ -3, -2, 1 },{ 3, 0, -2 },{ -1, 1, -1 },{ -1, -1, 1 },{ 3, 1, 2 },{ 1, -2, -2 },{ 0, -4, 0 },{ 2, -3, -2 },{ 2, -3, -3 },{ 0, 2, -1 },{ -4, -4, -3 },{ 1, -2, 1 },{ -3, 0, -3 },{ -1, -1, 3 },{ 0, 0, -1 },{ 2, 2, 0 },{ -4, -4, 3 },{ 1, -2, -1 },{ 3, -4, 3 },{ 1, -3, -2 },{ 3, -3, -1 },{ -1, 1, -2 },{ 0, -2, 1 },{ 2, -4, 2 },{ -1, 3, 1 },{ -2, -4, -3 },{ -4, 2, 3 },{ -2, -1, 1 },{ 3, -1, -2 },{ 1, 3, -4 },{ -1, -3, 3 },{ 3, 1, 1 },{ -4, -4, 2 },{ -2, -1, -1 },{ 2, -4, 1 },{ -1, 1, 0 },{ 1, -1, -2 },{ -2, -3, -3 },{ 2, -2, -4 },{ -4, 0, -2 },{ -1, 2, 2 },{ 2, 1, -3 },{ 3, 1, 0 },{ -2, -4, 2 },{ 0, 2, 3 },{ 3, -3, -4 },{ -4, 2, 0 },{ 3, -2, -2 },{ 2, -4, 2 },{ 0, 2, 1 },{ -4, -1, 2 },{ -2, -3, -3 },{ -4, 3, -2 },{ 2, -1, 2 },{ -2, -4, -2 },{ -3, -1, -4 },{ 2, 3, 2 },{ -2, 2, 0 },{ 1, -1, -3 } },
+		{ { 2, -2, 0 },{ 1, -4, 3 },{ 2, 0, 0 },{ -4, -3, 2 },{ 1, 3, 1 },{ -4, -4, 3 },{ 1, 2, -4 },{ -3, -4, -3 },{ 0, -1, 0 },{ 1, -3, -2 },{ -2, 0, -4 },{ -3, 3, 3 },{ -1, 0, 1 },{ -3, 1, -4 },{ 2, 0, 3 },{ -2, 3, 2 },{ 3, -2, -2 },{ -4, -4, 0 },{ -1, 1, 2 },{ 3, -3, 0 },{ -4, 3, -4 },{ -2, 0, 1 },{ -1, -1, 0 },{ -3, 3, -3 },{ 0, 2, 2 },{ -3, 0, 3 },{ 1, -4, -4 },{ -2, 2, -3 },{ -4, 0, 2 },{ -1, 1, -2 },{ 2, 3, 3 },{ 3, 1, 0 },{ 1, -3, -4 },{ -3, -4, -1 },{ -3, 1, 1 },{ 0, -2, -2 },{ -2, 2, -4 },{ 3, 2, 3 },{ 0, 0, -2 },{ 2, -2, 3 },{ -4, 2, -4 },{ -3, -4, 1 },{ 3, 3, -1 },{ -1, 1, 0 },{ -3, -4, 3 },{ 1, 3, -2 },{ -3, -1, 3 },{ 1, -3, -1 },{ -3, -2, 1 },{ 0, 3, -3 },{ 2, 0, 1 },{ -2, -4, 3 },{ 1, 3, -1 },{ -2, -2, -4 },{ -3, 1, -1 },{ 2, 0, -3 },{ 1, 0, -1 },{ 0, 2, 3 },{ -1, -2, 1 },{ 3, 2, -1 },{ -4, -2, 3 },{ 0, -2, -1 },{ -1, 0, -4 },{ -3, -4, -1 } },
+		{ { -4, 1, -2 },{ -1, 3, -3 },{ -2, -2, -2 },{ 0, -1, -1 },{ 3, -1, -4 },{ -2, 3, -1 },{ 2, 1, 0 },{ 0, -2, 2 },{ -2, 3, 1 },{ -3, 2, 3 },{ -4, -4, 1 },{ 3, 2, 0 },{ 0, -1, 2 },{ 1, -2, -1 },{ -4, -1, 0 },{ 1, -3, 2 },{ -2, 1, -4 },{ 2, 3, -3 },{ 1, -1, -1 },{ -3, -2, -4 },{ 0, 1, -2 },{ -2, -4, -3 },{ 2, 1, -2 },{ 3, -2, 0 },{ -4, -1, -4 },{ -2, 1, 1 },{ 2, 3, 0 },{ 3, 2, -1 },{ 1, -1, 0 },{ 3, -3, -4 },{ -3, -2, -1 },{ 0, -1, -4 },{ -1, 0, -2 },{ 0, 2, 2 },{ 2, 1, -3 },{ -4, -4, 1 },{ 1, -1, -1 },{ -1, -3, -3 },{ -3, -2, -2 },{ 0, 3, -1 },{ -1, 0, -3 },{ 1, 2, 3 },{ -2, -2, 2 },{ 0, -1, -4 },{ 3, 0, -1 },{ 2, 1, 1 },{ -1, -3, -4 },{ -4, 2, 0 },{ 3, 0, -4 },{ 1, -2, -2 },{ -4, 1, -1 },{ 0, -2, -3 },{ -3, 0, 0 },{ -1, 3, -2 },{ 3, -3, 3 },{ -1, 1, 1 },{ -3, -3, -1 },{ 3, -4, 0 },{ -2, 0, -4 },{ 0, 3, -3 },{ 1, 1, 0 },{ 3, -4, -2 },{ -4, 2, 2 },{ 3, 0, 1 } },
+		{ { 2, -3, 2 },{ -2, 2, -4 },{ -3, -4, 0 },{ 0, 2, 3 },{ -3, -3, 2 },{ -1, -3, -2 },{ 1, -1, 3 },{ -4, -3, -3 },{ 3, 1, -1 },{ 2, 0, -4 },{ 3, -3, -3 },{ 0, -1, -1 },{ -1, 2, -3 },{ -2, -4, -2 },{ 3, 3, -4 },{ -1, -3, -2 },{ 0, 2, 0 },{ 0, 0, 3 },{ -3, -4, 2 },{ -2, -3, 3 },{ 3, 2, 1 },{ 2, 0, 2 },{ 0, -3, 3 },{ -3, 2, -1 },{ -1, 0, -1 },{ 1, -4, -3 },{ -4, -2, 2 },{ -1, -2, 3 },{ -3, -3, -3 },{ 0, 0, 2 },{ -4, 2, 1 },{ -2, -4, 1 },{ -4, 3, 2 },{ -2, -3, 0 },{ 3, -2, 3 },{ -1, 3, -4 },{ 2, 0, 2 },{ -3, -3, 0 },{ -2, 1, 2 },{ 1, -3, 1 },{ 2, -4, 0 },{ 3, 1, -2 },{ -4, 0, -3 },{ 1, -3, 1 },{ -4, 2, 0 },{ -2, -4, -3 },{ 0, -2, 0 },{ -2, -1, 2 },{ 2, 3, -1 },{ -1, -4, 3 },{ -1, -1, -2 },{ 3, 2, 2 },{ -4, -3, 1 },{ 2, -1, 2 },{ -4, -4, -4 },{ 1, -1, 0 },{ -1, 2, -4 },{ 2, -2, 2 },{ -3, -3, -2 },{ -4, -1, 1 },{ -2, -3, 3 },{ -3, -1, 0 },{ -1, 3, 1 },{ 0, -3, -3 } },
+		{ { -3, -1, -1 },{ 1, 0, 1 },{ 1, 0, 2 },{ 3, 1, -3 },{ 2, 2, -3 },{ -1, 0, -1 },{ -3, 0, 1 },{ 2, 3, -2 },{ -1, -4, 2 },{ -4, -2, 0 },{ -1, 3, -1 },{ -2, 1, 2 },{ 2, -4, 3 },{ -4, 0, 0 },{ 2, 1, 1 },{ -3, -1, 3 },{ -3, -1, -3 },{ 3, 2, 1 },{ -4, 1, -3 },{ 1, 2, -2 },{ -1, -1, -1 },{ -3, -3, -3 },{ -4, 3, 1 },{ 1, -4, -4 },{ 2, 3, 3 },{ 3, -3, -2 },{ 0, -1, 1 },{ 0, 1, -4 },{ -2, 3, -2 },{ 2, -4, 0 },{ 1, 2, -3 },{ 2, 0, -1 },{ 3, -1, -2 },{ 1, -2, -3 },{ -1, 1, 0 },{ -4, 0, -3 },{ 1, -1, 3 },{ 0, 3, -1 },{ 3, 2, -4 },{ -4, -1, 3 },{ -1, 0, -3 },{ -3, -3, -1 },{ -2, -1, 2 },{ -1, 3, -2 },{ 0, -2, 3 },{ -3, 1, 3 },{ 3, -4, -2 },{ 1, 2, 2 },{ -4, 1, -3 },{ -3, -3, 3 },{ -2, 3, 0 },{ 2, -4, -4 },{ -1, 0, -2 },{ 1, 2, -3 },{ -2, 2, 0 },{ 0, -2, -2 },{ -4, 3, 2 },{ 3, 1, -3 },{ 0, 0, -1 },{ 2, 3, 2 },{ 1, 2, -3 },{ 3, 0, -2 },{ 2, 1, -4 },{ -1, 2, 3 } },
+		{ { 0, -2, -4 },{ 3, 3, 0 },{ -1, -4, -2 },{ -4, -2, -1 },{ -4, -2, 2 },{ 1, 3, 0 },{ 3, -4, -4 },{ -2, -1, -3 },{ 1, 2, 3 },{ 0, 2, -4 },{ -3, 0, -2 },{ 1, -3, 1 },{ -3, -2, -4 },{ 0, 2, -3 },{ 1, -2, -1 },{ 3, -4, 1 },{ -2, -2, -2 },{ 2, -3, 0 },{ 2, -4, 1 },{ 0, 3, -1 },{ -4, -1, 3 },{ 3, 1, -4 },{ 0, 0, 0 },{ -2, -1, -2 },{ -3, -2, 1 },{ -1, 0, 2 },{ -3, 1, -1 },{ 3, -4, -4 },{ -4, 2, 1 },{ 2, -2, 3 },{ -1, 1, -4 },{ -3, -3, 3 },{ -2, 1, 2 },{ 2, 2, -1 },{ 0, -4, 0 },{ -3, -3, 2 },{ 3, 2, -2 },{ 1, -4, 1 },{ -2, 1, 0 },{ -3, 3, -4 },{ 2, -2, -2 },{ 0, 3, 2 },{ 3, 2, -4 },{ 2, -4, 0 },{ 3, 0, -3 },{ -3, 3, -4 },{ 2, 0, -2 },{ -1, -3, 0 },{ 0, -1, -3 },{ 3, -2, -1 },{ 0, 1, 1 },{ 1, 2, 2 },{ -4, -2, 3 },{ 2, -1, -1 },{ 0, -4, 1 },{ -3, 1, 3 },{ 1, -1, -2 },{ -3, -3, 1 },{ 0, -4, 3 },{ -1, -1, 0 },{ -3, -3, -4 },{ 0, -4, 0 },{ -4, -2, 2 },{ -2, -4, -1 } },
+		{ { -4, -1, 1 },{ -1, 1, -3 },{ -2, -3, 3 },{ 3, 3, -4 },{ 0, -1, 1 },{ -2, -4, 1 },{ 0, 1, 3 },{ -3, -3, 0 },{ 3, -1, 2 },{ -1, -2, 0 },{ -4, -4, -3 },{ 2, 0, 2 },{ 3, -1, -2 },{ -1, 3, 2 },{ -2, 0, 0 },{ 0, 2, -4 },{ -4, 3, 3 },{ -1, 1, -4 },{ -1, 0, -2 },{ 3, -2, -4 },{ -2, -4, 2 },{ 0, -2, 1 },{ 2, 2, -2 },{ 3, 1, 0 },{ -2, -3, -3 },{ 1, 2, 2 },{ -4, 3, -3 },{ 1, -1, 3 },{ -1, -3, -1 },{ -3, 0, -2 },{ 3, -1, 0 },{ -4, 3, 1 },{ 0, -4, -2 },{ -3, 3, -4 },{ -2, 0, 1 },{ 2, 1, -4 },{ -4, -2, -1 },{ -2, -2, -3 },{ -1, -4, 2 },{ 2, -3, -1 },{ 0, 0, 3 },{ -1, -4, 1 },{ -3, -1, 0 },{ 1, 1, 1 },{ -4, -2, -1 },{ -1, -1, 2 },{ -4, -3, 1 },{ 2, 2, 2 },{ -1, 2, -4 },{ -3, 0, 1 },{ 3, -4, -2 },{ -2, 3, -4 },{ -3, 1, -3 },{ 1, -2, 2 },{ -2, 3, -4 },{ 3, 0, -1 },{ 2, -3, -3 },{ -1, 1, 0 },{ -4, -2, -4 },{ 2, 3, -1 },{ -2, -2, 1 },{ 1, 2, -2 },{ -3, 3, 3 },{ 3, 1, -1 } },
+		{ { 2, 2, 1 },{ 0, -4, -3 },{ -3, -1, 3 },{ 1, 1, -2 },{ 2, -3, -1 },{ -1, 2, -3 },{ -4, -2, -2 },{ 0, 1, -1 },{ 2, 3, -4 },{ -2, -3, 1 },{ 3, 1, -1 },{ 0, 3, 3 },{ -2, 1, 1 },{ -4, -4, -4 },{ 2, -3, 3 },{ -3, -2, -2 },{ 1, 1, -1 },{ 1, -1, 2 },{ -3, 0, 2 },{ -4, 3, 0 },{ 1, 2, -3 },{ -3, -3, -1 },{ -1, 3, 3 },{ -4, -4, 2 },{ 0, 0, -4 },{ -2, -4, -1 },{ 3, -2, 0 },{ 2, 1, -2 },{ 0, 0, 1 },{ -2, -3, 2 },{ 1, 3, -3 },{ -1, -4, -3 },{ 2, -2, 3 },{ 1, -1, 2 },{ 3, -3, -1 },{ -1, 3, -2 },{ 1, -1, 3 },{ 0, 3, 1 },{ -4, 2, -4 },{ 3, -1, -2 },{ -3, 2, 0 },{ -4, -2, -3 },{ 2, 1, -4 },{ -2, -3, -2 },{ 0, 2, -1 },{ 0, 0, 3 },{ 1, 3, -3 },{ -2, -4, 0 },{ -3, -1, -2 },{ 2, -2, 3 },{ -4, 0, 2 },{ -1, -4, 0 },{ 3, -1, -2 },{ -1, -3, 0 },{ -4, 0, 0 },{ 3, -4, 1 },{ -1, -1, 3 },{ -2, 3, -3 },{ 3, 2, -1 },{ -3, 0, 3 },{ 3, -4, 2 },{ -1, 1, -3 },{ 2, 0, -3 },{ 1, -3, 2 } },
+		{ { -3, -2, -4 },{ -2, 3, -1 },{ 2, 1, 0 },{ -4, -1, 2 },{ -3, 0, -4 },{ 2, 3, 3 },{ 3, 0, 2 },{ -3, 2, 1 },{ -1, -3, -2 },{ 1, 0, 3 },{ -4, 2, -3 },{ 1, -2, -4 },{ -3, -3, -1 },{ 3, 0, 0 },{ -1, -1, 2 },{ 3, 2, -3 },{ -2, -4, 1 },{ 0, -3, -1 },{ 3, -3, -3 },{ -2, -2, 0 },{ -1, 1, 3 },{ 2, -1, -4 },{ 1, 0, -3 },{ 3, -2, 1 },{ -4, -1, -2 },{ 1, 2, 0 },{ -1, -1, 3 },{ -3, -4, 2 },{ -4, 2, -4 },{ 1, 1, -1 },{ -3, -2, 1 },{ 0, 0, 0 },{ 2, 2, -1 },{ -4, 0, -4 },{ -2, -4, 3 },{ -2, 1, -3 },{ 2, -3, 0 },{ -3, 0, 1 },{ -1, -3, 3 },{ 2, -2, -1 },{ 1, 1, 2 },{ 0, -1, -2 },{ -1, 3, 3 },{ 1, -4, 2 },{ -3, -2, 1 },{ 3, 1, -3 },{ 2, -2, -4 },{ -3, -1, 1 },{ 3, 1, -1 },{ 0, 3, -3 },{ 1, 2, 0 },{ -4, -1, -1 },{ 0, -3, 3 },{ -2, 2, -3 },{ 0, 2, -2 },{ -3, 3, -4 },{ 0, -2, 2 },{ -4, 0, 1 },{ 1, -4, -2 },{ 0, -1, -4 },{ -2, 1, 0 },{ 1, -3, -1 },{ -4, -1, 0 },{ -1, 0, -2 } },
+		{ { 1, -2, 1 },{ 3, 0, 2 },{ -4, -4, -2 },{ 1, 2, -3 },{ -1, -2, 0 },{ -1, -4, -2 },{ 1, -4, -4 },{ -4, -1, 0 },{ -2, 2, -3 },{ -3, -1, 2 },{ 0, -2, -1 },{ -1, -4, 0 },{ 2, 1, -3 },{ 1, 3, 1 },{ 0, -2, -2 },{ -4, 0, 0 },{ 2, 3, -2 },{ -1, 2, 3 },{ -3, -1, 1 },{ 3, 3, -3 },{ 2, 0, -2 },{ -4, -4, 1 },{ -1, 2, -1 },{ -3, -3, 3 },{ 0, 1, -3 },{ 2, 0, -1 },{ -1, 3, -4 },{ -2, -3, -2 },{ 3, 3, -3 },{ 2, -2, 0 },{ 3, -1, 3 },{ -2, 2, -4 },{ -3, -2, 1 },{ -1, 3, -2 },{ 3, 0, 0 },{ 1, -2, 2 },{ -4, 2, -4 },{ 3, -1, -2 },{ 0, 1, -3 },{ -4, 0, -4 },{ -2, 3, 1 },{ -3, -4, 2 },{ 3, 2, -4 },{ 2, -1, 0 },{ -2, 3, 1 },{ -4, -4, -2 },{ 0, 1, 0 },{ -1, -4, 3 },{ -2, -3, -2 },{ 1, 1, 2 },{ -2, -3, -3 },{ 2, 3, -4 },{ 3, 1, 1 },{ -3, 0, 2 },{ 1, -3, 3 },{ 2, -1, -1 },{ -3, 1, -3 },{ 1, 1, 0 },{ 2, -3, 3 },{ -1, 3, -3 },{ -4, -2, 1 },{ -3, 3, 3 },{ 0, -4, -4 },{ -2, 2, 3 } },
+		{ { 2, -1, -3 },{ -1, -3, 3 },{ 0, 3, -1 },{ -2, -2, 3 },{ 3, -3, 1 },{ -2, 2, 2 },{ 2, 1, -1 },{ 0, -1, 1 },{ 3, -3, -4 },{ 1, -4, 2 },{ 3, 2, -2 },{ -4, 0, 2 },{ -3, -3, 3 },{ -2, 2, -2 },{ -1, -1, 3 },{ -4, -4, -4 },{ 2, -2, 2 },{ 0, 1, -4 },{ -4, 0, -2 },{ 1, -2, 3 },{ 0, -4, 2 },{ -2, 3, -1 },{ 2, 1, 0 },{ -2, 3, -4 },{ -3, -4, 2 },{ 3, -3, 1 },{ 2, 1, 1 },{ -4, -1, 0 },{ 0, -4, 3 },{ -1, 1, 2 },{ -4, -4, -2 },{ 1, 1, -2 },{ 2, -3, 2 },{ 0, -3, 3 },{ -4, 1, -3 },{ 0, -2, -1 },{ -3, 2, 1 },{ -2, -4, 2 },{ 0, 3, 0 },{ 1, -4, -1 },{ 3, -2, 3 },{ -1, -3, -1 },{ -4, 0, -3 },{ 1, 0, -1 },{ -3, -3, -4 },{ -1, 0, 3 },{ 2, 2, 2 },{ -4, 3, -1 },{ -2, -1, -4 },{ 3, -2, 0 },{ -4, 0, 3 },{ -1, -4, 1 },{ -3, -2, -1 },{ 1, 0, -3 },{ -4, -4, 1 },{ -1, -2, -2 },{ -2, -3, -4 },{ 3, 2, 2 },{ -2, -4, 0 },{ -1, -1, -2 },{ 2, 0, -2 },{ 1, 2, 2 },{ 3, -4, -1 },{ -4, 1, 0 } },
+		{ { 2, 3, -4 },{ -3, 1, -2 },{ 3, -4, -4 },{ 0, 2, 1 },{ -4, 1, -1 },{ -3, 0, -3 },{ 0, -3, -3 },{ -4, 3, 3 },{ -2, 0, 0 },{ 2, 3, -2 },{ 0, 1, 1 },{ -1, -1, -4 },{ 2, 3, 0 },{ 3, -4, -4 },{ -3, 3, 1 },{ -2, 1, -1 },{ 3, 0, -3 },{ -2, -4, 0 },{ 1, -3, -1 },{ -1, 2, 0 },{ -3, -2, -4 },{ -4, -1, -2 },{ 0, -3, 2 },{ 2, -1, -3 },{ 1, -1, -2 },{ -4, -2, 3 },{ -1, 2, -3 },{ -2, 0, -3 },{ 1, -1, 1 },{ -3, 2, -1 },{ 0, -3, 1 },{ -2, 3, -4 },{ -3, -1, 0 },{ 3, -4, -1 },{ -3, 3, -4 },{ 2, -1, 3 },{ -1, -3, -1 },{ 1, 0, -3 },{ 3, -2, 2 },{ -2, -1, -4 },{ -4, 1, 1 },{ -2, 3, -3 },{ 1, -3, 0 },{ 3, -2, 2 },{ -3, 2, -1 },{ 0, -1, -2 },{ 3, -2, -3 },{ 1, 0, 1 },{ 0, 2, 2 },{ 2, -4, -2 },{ -1, 1, -2 },{ 2, 3, -4 },{ -2, -1, 0 },{ 0, 1, -4 },{ 2, 3, 0 },{ 3, 3, 3 },{ -1, -1, 1 },{ -4, 1, -1 },{ -3, 3, -4 },{ 2, -3, 3 },{ -4, 1, -1 },{ 3, -2, -3 },{ -2, 0, 2 },{ 0, 0, 1 } },
+		{ { -1, -3, 3 },{ -4, -2, 0 },{ -3, 0, -3 },{ -1, -1, 2 },{ 1, -1, -4 },{ 2, 3, 3 },{ -1, 1, 1 },{ 3, -3, -1 },{ -1, -2, -4 },{ -4, 1, 3 },{ -3, -2, -1 },{ 1, -4, 3 },{ -2, 0, -1 },{ 0, -2, -3 },{ 1, -3, 2 },{ 1, -1, 0 },{ 2, 2, 2 },{ -3, -2, 3 },{ -1, 1, -3 },{ 2, 3, 2 },{ 2, 0, -1 },{ 3, -3, 3 },{ -1, 1, 1 },{ -1, 0, -1 },{ 3, 2, 0 },{ -3, 3, -2 },{ 0, -4, 0 },{ 1, -2, -1 },{ 3, -2, -4 },{ -1, 3, -2 },{ 3, 0, 3 },{ 2, -2, -3 },{ -1, 2, 1 },{ -2, 0, -2 },{ 1, 2, 1 },{ 2, -4, 1 },{ -1, 3, -2 },{ -4, 0, 0 },{ -3, 2, -2 },{ 2, 2, 3 },{ -1, -3, -2 },{ 2, -1, 0 },{ 0, 1, 3 },{ -2, 2, -2 },{ 0, -4, 2 },{ 2, 3, 1 },{ -2, -3, -4 },{ -3, -2, 0 },{ -1, 2, -3 },{ -4, -3, 0 },{ -3, -1, 2 },{ 0, 2, 3 },{ 3, -2, -1 },{ -4, -3, 3 },{ 0, 2, -3 },{ -2, 0, -1 },{ 1, -4, 1 },{ 0, -2, -2 },{ 1, 0, 0 },{ 0, -4, 2 },{ -2, 2, -4 },{ -1, -3, 0 },{ 1, -3, -4 },{ -3, -1, -2 } },
+		{ { 3, 1, -1 },{ 1, 3, 1 },{ 2, 2, 2 },{ -1, -3, -2 },{ 3, -4, 0 },{ -2, -2, 0 },{ -3, -4, -2 },{ 1, -1, 2 },{ 1, 2, -3 },{ -2, -4, 0 },{ 2, -3, -3 },{ 3, 2, -3 },{ -1, 0, -1 },{ -4, 2, 2 },{ -4, 1, 0 },{ -1, -3, -2 },{ 0, 3, -2 },{ -4, -1, -4 },{ -3, -4, 1 },{ 3, -1, 0 },{ -2, 1, -2 },{ 1, 3, -4 },{ -3, -4, -3 },{ -2, 2, 0 },{ -4, -4, 3 },{ 1, 0, -4 },{ -2, -3, 3 },{ 2, 1, 2 },{ -4, 2, 2 },{ -4, -3, 0 },{ 1, 1, -3 },{ -3, -4, 2 },{ 1, -1, -1 },{ -4, 1, 3 },{ 0, -2, -3 },{ -2, -1, 0 },{ 3, 1, -4 },{ -3, -3, 2 },{ 0, -2, -3 },{ 0, 0, 1 },{ 2, -4, -1 },{ -3, 3, -4 },{ -3, -1, 1 },{ 3, -4, -4 },{ -4, -1, -3 },{ 1, 1, 1 },{ -4, 1, 3 },{ 1, -4, -2 },{ 2, 0, 3 },{ 3, 0, -3 },{ 0, -4, -1 },{ 1, 3, 1 },{ -3, 0, -2 },{ -1, -4, 2 },{ 2, -1, -2 },{ -3, -2, -4 },{ -4, -3, 2 },{ 3, 2, -3 },{ -2, -2, -2 },{ 3, 0, 1 },{ 1, 3, 3 },{ -3, -1, -1 },{ -4, 3, 2 },{ 0, 2, 1 } },
+		{ { -2, 0, -1 },{ -4, -4, -4 },{ 0, -2, 3 },{ -2, 2, -1 },{ -4, 1, -3 },{ 1, 3, 2 },{ -4, 0, -4 },{ 3, 3, -1 },{ -3, -1, -2 },{ 0, 0, 2 },{ -3, 3, 1 },{ 1, -1, 0 },{ 0, 1, 1 },{ 3, -2, 3 },{ 2, -4, -4 },{ -2, 2, -3 },{ 3, -2, 3 },{ 1, 0, 1 },{ 0, 2, -2 },{ -4, -4, -4 },{ -1, -1, 3 },{ 0, -3, 1 },{ -3, -2, 2 },{ 2, 0, -4 },{ 2, -2, 2 },{ 0, 3, -2 },{ 3, 1, 1 },{ -3, -1, -1 },{ -2, -4, -4 },{ -1, 0, 3 },{ 3, 3, 0 },{ -2, -1, 1 },{ -1, 1, -4 },{ 3, -3, 2 },{ -3, -2, -3 },{ -4, 0, 3 },{ 0, -4, -1 },{ 1, -2, 3 },{ 3, 3, 0 },{ -4, -1, 2 },{ -2, 2, -3 },{ 1, -3, 2 },{ -1, 1, -1 },{ -1, 0, 0 },{ 2, -3, -1 },{ -3, 3, -3 },{ -1, -1, 0 },{ 3, 2, -1 },{ -2, 3, 2 },{ -4, -1, -4 },{ -2, 1, 2 },{ -1, -3, -3 },{ 2, 0, -4 },{ -2, 1, 0 },{ 1, 1, 1 },{ 2, 3, -1 },{ -1, 1, 3 },{ 2, 2, 0 },{ -3, -1, -1 },{ -4, 1, -3 },{ 2, -4, -2 },{ -1, 1, 0 },{ 2, -4, -3 },{ 3, -2, -3 } },
+		{ { -1, -3, 2 },{ 2, -1, -2 },{ 1, 3, 0 },{ -3, -3, 1 },{ 2, 0, -3 },{ 0, -1, 1 },{ -2, -2, 3 },{ -1, -3, 1 },{ 3, 2, 0 },{ 2, -2, 3 },{ -4, 1, -4 },{ -3, -3, -2 },{ -2, -4, -4 },{ -3, 2, -2 },{ -1, -1, -1 },{ -4, 0, 2 },{ -2, -3, -1 },{ 2, 3, 2 },{ 0, 1, -1 },{ -2, -2, 3 },{ 1, 2, -3 },{ -4, 1, 0 },{ 3, 3, -1 },{ 1, 1, 3 },{ -1, -1, -1 },{ -2, -3, -3 },{ -3, 0, -3 },{ 3, 3, 0 },{ 0, -2, -1 },{ 2, -1, -3 },{ 0, -3, -2 },{ -4, -2, -2 },{ 1, -4, 0 },{ 0, 3, -1 },{ 2, 2, -2 },{ 2, 3, 1 },{ -1, 2, -2 },{ -1, 1, -4 },{ -2, 1, -2 },{ 1, -4, -4 },{ 0, 0, 0 },{ -4, -2, 3 },{ 3, 3, -2 },{ 1, -2, 1 },{ -2, 2, 3 },{ 0, -2, -1 },{ -1, 0, 2 },{ 2, -3, -4 },{ -3, -2, 0 },{ 0, -3, 1 },{ 1, 3, -2 },{ 3, -2, 3 },{ -4, -2, -1 },{ -1, 3, 2 },{ 3, -4, 0 },{ -4, -1, -3 },{ 0, -3, 2 },{ -2, -4, -4 },{ -1, -3, 2 },{ -4, 3, 3 },{ 2, -2, -4 },{ -1, -1, 1 },{ -2, 0, 3 },{ 0, 1, 0 } },
+		{ { -3, 3, 3 },{ -2, -1, -3 },{ 3, 0, -4 },{ -3, -4, 3 },{ -1, 2, 0 },{ 1, 1, -2 },{ 2, -4, -2 },{ -4, 1, -4 },{ -1, 1, -3 },{ 0, -4, -2 },{ -1, 0, 0 },{ 3, -2, 2 },{ 0, 3, 2 },{ 2, -2, 0 },{ 1, 1, 1 },{ 0, 3, -3 },{ 3, -4, 0 },{ -3, -1, -4 },{ -1, -3, -3 },{ 3, 0, 1 },{ 2, -4, 0 },{ 0, 2, -3 },{ -3, -3, -2 },{ -2, -4, -4 },{ -4, 2, 1 },{ 0, -4, 1 },{ 1, -1, 2 },{ -1, -3, -4 },{ 1, 2, 3 },{ -2, 3, 1 },{ -3, 1, 2 },{ 2, 2, 3 },{ -4, 2, -4 },{ -1, 0, 2 },{ -2, -4, -3 },{ -3, -3, 0 },{ -4, -1, 2 },{ 2, -2, 1 },{ -3, -3, -1 },{ -2, 2, 0 },{ 0, -3, 1 },{ 3, 1, -3 },{ -3, -1, -4 },{ 1, -3, 2 },{ -4, 3, -3 },{ 3, -4, -4 },{ -3, -4, -2 },{ 0, 2, 3 },{ -4, 1, -3 },{ 3, 0, -2 },{ 1, 2, 0 },{ -3, -1, 0 },{ 0, 1, -3 },{ -2, -4, 3 },{ 1, 2, -4 },{ -3, -1, -2 },{ 0, 3, 0 },{ 2, 0, -1 },{ 3, 2, 1 },{ 0, -2, -3 },{ 0, 0, 1 },{ -3, 3, -1 },{ 3, -4, -4 },{ -4, 2, -2 } },
+		{ { 1, -2, -1 },{ -4, -3, 1 },{ -1, 1, 1 },{ 1, -2, -1 },{ 3, 0, -4 },{ -3, -1, 2 },{ 0, 3, -1 },{ -2, -3, 0 },{ 1, -1, 3 },{ 2, 3, 2 },{ -2, -3, -1 },{ 2, 2, -3 },{ -4, 0, -1 },{ 1, 0, 3 },{ -3, -4, -3 },{ -1, 1, 1 },{ 1, -2, 3 },{ -4, 2, -1 },{ 1, -3, 3 },{ -3, 3, 2 },{ -2, 0, -1 },{ -1, -1, 2 },{ 2, -2, 0 },{ 3, 0, 3 },{ 1, 3, -2 },{ 3, 0, -1 },{ -4, 2, 3 },{ -3, -2, 0 },{ 0, -4, -2 },{ -4, 0, -4 },{ 3, -4, 0 },{ -1, 0, -3 },{ 2, -2, -1 },{ 1, -1, 1 },{ 3, 1, 2 },{ 0, 0, -4 },{ 3, -4, -1 },{ 1, 3, -3 },{ -4, 0, 3 },{ 3, -1, -2 },{ 2, 3, -1 },{ -2, 2, 3 },{ -3, -4, 1 },{ 0, 2, -2 },{ -2, -1, 0 },{ 2, 0, 2 },{ 2, 1, 1 },{ -2, -1, 0 },{ 1, 3, -1 },{ -1, -1, 3 },{ -4, -4, 1 },{ -2, -3, -4 },{ 2, 2, -2 },{ 0, 0, 1 },{ -3, -3, -1 },{ 3, -2, 3 },{ -2, 0, 1 },{ -2, -1, -4 },{ 1, -4, -2 },{ -3, 1, 2 },{ -1, -3, -2 },{ -2, 2, -1 },{ 2, -1, 2 },{ 1, -3, 0 } },
+		{ { -1, 1, -3 },{ 2, 3, 3 },{ 0, -2, -1 },{ -4, 3, 2 },{ -1, -4, -2 },{ -4, -3, 1 },{ 2, 2, 3 },{ 3, 0, -3 },{ -3, -2, -1 },{ -3, 2, 1 },{ -4, -4, -4 },{ 1, -1, 1 },{ -1, 3, 0 },{ -3, -3, -4 },{ 3, 2, -2 },{ -4, -1, -4 },{ -2, 3, -2 },{ -1, -1, 0 },{ 2, 1, -4 },{ 1, -2, -2 },{ -3, 1, -4 },{ 1, -4, 2 },{ -4, 3, 0 },{ -2, -1, -3 },{ -3, 1, 2 },{ 0, -3, -4 },{ 2, 2, 0 },{ -2, 1, -3 },{ 3, -1, -1 },{ -3, 3, 3 },{ 1, -2, -1 },{ -2, -3, 0 },{ -3, 3, -2 },{ -1, -4, 3 },{ -3, -2, -2 },{ -4, 3, 1 },{ 1, 1, 3 },{ -1, -1, 0 },{ 0, -4, 2 },{ -1, 1, -4 },{ -4, -2, 2 },{ -1, -4, 0 },{ 2, 0, -2 },{ 1, -1, -3 },{ -1, 1, 0 },{ -4, -2, 3 },{ 0, 3, -2 },{ -3, -3, -4 },{ 3, -2, -1 },{ 0, -4, 2 },{ -2, 3, -4 },{ 3, -1, 2 },{ 2, 0, 1 },{ -4, -2, 2 },{ 3, 1, -3 },{ -1, 2, 0 },{ 2, -4, -3 },{ -4, 3, 3 },{ -4, -2, 0 },{ 1, -1, 3 },{ 3, 1, 0 },{ 1, -2, -3 },{ -4, -4, 3 },{ 0, 2, -4 } },
+		{ { 3, -3, -2 },{ -3, 0, -2 },{ -2, -4, -3 },{ 2, 2, 2 },{ 2, -1, -4 },{ -2, 1, -3 },{ 0, -2, -1 },{ -1, 3, 2 },{ 0, -1, 0 },{ 1, 1, -2 },{ -1, 0, 3 },{ 3, -4, -3 },{ 0, -2, 3 },{ -2, -1, -1 },{ -1, -3, 2 },{ 3, -2, 1 },{ 2, 0, 3 },{ 0, -4, -1 },{ -2, 3, 0 },{ 3, -4, 1 },{ -4, 2, -2 },{ 0, -3, -3 },{ 3, 1, 3 },{ -1, -3, -1 },{ -4, -2, -4 },{ 2, -2, -2 },{ -2, -1, 1 },{ 1, -3, 2 },{ -1, 1, 1 },{ 2, -2, -3 },{ 0, 2, 1 },{ 1, -1, 2 },{ -4, 1, -4 },{ 0, 0, 0 },{ 2, 2, -1 },{ -1, -2, -4 },{ -2, -3, -1 },{ -3, 2, -3 },{ 2, -1, 1 },{ 3, 2, -2 },{ -2, -3, -4 },{ 1, 0, -1 },{ -4, -3, 3 },{ 0, 3, 2 },{ 3, -3, -4 },{ -1, -4, -1 },{ 1, -1, 2 },{ -2, 2, 1 },{ 2, -3, -3 },{ -1, 1, 1 },{ -4, 1, -3 },{ 1, 2, -1 },{ -1, -4, -2 },{ -2, 3, -1 },{ -4, 1, -4 },{ 1, -1, 2 },{ 1, -3, -2 },{ 0, 1, -3 },{ 2, 2, 1 },{ -2, 3, -4 },{ -1, -4, -2 },{ -3, 0, 1 },{ -2, 3, -1 },{ 3, 0, 2 } },
+		{ { -1, -2, -4 },{ 1, -1, 2 },{ -3, 1, 0 },{ 1, -1, 0 },{ 0, 1, 1 },{ 3, -2, -1 },{ -4, -4, 3 },{ -2, 0, -3 },{ 3, -4, -4 },{ -2, 1, -2 },{ 2, -3, 2 },{ -4, 3, 0 },{ 1, 1, -2 },{ 2, 1, -3 },{ 0, 3, 2 },{ 1, 2, -1 },{ -4, 0, -3 },{ -3, -3, 2 },{ -1, 1, -3 },{ 0, -2, 1 },{ 2, 0, 3 },{ -2, -1, -1 },{ 2, 2, -4 },{ 1, -4, 1 },{ 0, 1, 0 },{ -1, 3, 3 },{ -3, -4, -1 },{ 3, 0, -3 },{ -4, 3, 2 },{ -2, -4, -4 },{ -2, 1, 0 },{ 3, 0, -3 },{ -1, -3, -3 },{ -3, -3, 3 },{ 3, 2, 2 },{ 2, -1, -2 },{ 0, 0, 3 },{ 1, -4, -4 },{ -3, -2, -1 },{ -3, 3, 3 },{ 1, -2, 0 },{ 3, 3, 2 },{ -3, -1, -3 },{ -2, 2, 1 },{ 2, 2, 0 },{ -3, 1, -2 },{ -4, 0, -3 },{ 1, 3, 3 },{ -4, 0, 0 },{ 3, -2, -2 },{ 0, 0, 3 },{ -3, -2, 0 },{ 0, -3, 0 },{ 1, -1, 3 },{ 0, -4, 1 },{ -2, -2, -1 },{ -3, 2, 1 },{ -1, -3, 2 },{ 0, -1, -4 },{ 3, -3, -1 },{ -4, 2, 3 },{ 2, 1, -3 },{ 0, -1, 2 },{ -3, -4, 0 } },
+		{ { -4, 2, 3 },{ -2, 3, 1 },{ 3, 0, -4 },{ -4, -3, 3 },{ -1, 3, -2 },{ -3, 2, 0 },{ 1, 2, -4 },{ 2, -3, 1 },{ -4, 3, 2 },{ 1, -2, 1 },{ -3, -1, -1 },{ -1, 2, -4 },{ -2, -1, -1 },{ -3, -2, 0 },{ -4, -4, -4 },{ 0, 2, 0 },{ -2, -3, 3 },{ 3, -1, -2 },{ 1, 2, -4 },{ -4, -2, 2 },{ -1, 3, 0 },{ -3, -3, -2 },{ 1, 0, 2 },{ -3, 2, -3 },{ 3, 0, -2 },{ -4, -1, 2 },{ 2, 3, 0 },{ 0, 2, -4 },{ 0, -3, -1 },{ 2, -1, -2 },{ 0, -4, 3 },{ -4, -2, 1 },{ 3, 3, -1 },{ 1, 0, 1 },{ -2, -4, -3 },{ -4, -3, 1 },{ -2, 3, 1 },{ 3, 2, -2 },{ -4, 1, 0 },{ 0, -3, 2 },{ -1, 0, -3 },{ 2, 1, -1 },{ -1, -4, -4 },{ 1, -1, -2 },{ -4, -2, -1 },{ 1, -3, 3 },{ 3, -2, -4 },{ 0, -4, -1 },{ -3, 1, -2 },{ -2, 3, 2 },{ -2, -4, 2 },{ 3, 3, -4 },{ 2, 2, -3 },{ -3, 0, 1 },{ 3, 3, -4 },{ -4, 1, -2 },{ 3, -1, -1 },{ 2, 0, 3 },{ -2, -4, 0 },{ -3, 0, 2 },{ 1, -1, 0 },{ -2, -2, -4 },{ 0, 2, -2 },{ 1, 1, 1 } },
+		{ { -1, 0, -3 },{ 0, -4, -1 },{ 2, -3, -2 },{ 0, -2, -1 },{ -2, -4, 2 },{ 2, 0, 2 },{ -3, -1, -2 },{ -1, 1, -1 },{ 0, -1, 0 },{ -3, -2, -3 },{ 2, 2, 3 },{ -4, -4, 2 },{ 2, -3, 1 },{ 3, 3, 2 },{ -1, 0, -3 },{ 2, -1, 1 },{ -3, -4, -2 },{ 2, 3, 0 },{ 1, -3, 3 },{ -2, 1, -3 },{ 3, -1, -4 },{ -2, -4, 3 },{ -1, 3, 0 },{ -4, -2, 1 },{ -2, -4, 3 },{ 1, -1, -4 },{ -1, -3, -2 },{ -3, -2, 3 },{ -4, 0, 0 },{ 1, 1, 2 },{ -3, 3, -2 },{ -1, 1, -1 },{ -2, -1, 2 },{ 0, 2, 0 },{ -3, -1, -2 },{ 2, 1, -4 },{ 0, 0, 2 },{ 2, -1, 0 },{ -1, -4, -3 },{ -2, -1, 1 },{ 3, 2, -2 },{ -4, -4, -1 },{ -3, 0, 3 },{ 0, -3, 1 },{ 2, 1, -3 },{ -2, 3, 2 },{ -1, 1, 0 },{ 2, -2, 1 },{ -1, -1, -4 },{ 1, -3, -2 },{ 2, -1, -4 },{ -4, 1, -1 },{ -1, -2, 2 },{ -3, -3, -2 },{ 2, 0, 3 },{ -1, -4, 0 },{ 1, -2, -3 },{ -4, 3, -4 },{ 1, 2, -3 },{ 0, -4, -2 },{ -1, 1, 2 },{ 2, -3, -2 },{ -3, -2, 0 },{ 2, -3, -1 } },
+		{ { -2, 1, 0 },{ -3, -1, 2 },{ -1, 1, -3 },{ 3, 2, 3 },{ -4, -1, -4 },{ 1, -2, -3 },{ 0, -4, 1 },{ 3, 3, 3 },{ -1, 2, -4 },{ 3, -3, -2 },{ 0, 0, -1 },{ -1, 0, -3 },{ 0, 1, 3 },{ 3, -3, -4 },{ -2, -2, 3 },{ -1, 1, -1 },{ -4, 1, -4 },{ 0, 3, 1 },{ -1, -1, -1 },{ -4, 1, 1 },{ 2, -3, -1 },{ 3, 1, -3 },{ 0, -1, -1 },{ 2, -2, -4 },{ 2, 3, -3 },{ -2, 1, -1 },{ 1, 1, 1 },{ 3, -4, -3 },{ -2, 2, 3 },{ -1, 3, -1 },{ 3, -2, -3 },{ 2, -3, -4 },{ -4, -4, 0 },{ 2, 2, -4 },{ 1, -2, 3 },{ -1, 3, 0 },{ -3, -4, -1 },{ -4, -2, -2 },{ 2, 3, 3 },{ 0, 1, -4 },{ -3, -2, 1 },{ 2, 3, 0 },{ -2, -2, 3 },{ 3, 3, -4 },{ -1, -4, 0 },{ -3, 0, 2 },{ 0, 2, -3 },{ -4, -1, -1 },{ 3, 2, 3 },{ -1, 0, 1 },{ -4, -3, 2 },{ 0, 2, 0 },{ 2, -4, 1 },{ 0, 1, -3 },{ -2, 3, -1 },{ -2, -3, 2 },{ 0, -1, 3 },{ -3, 1, 1 },{ -1, 3, 0 },{ -4, -2, 3 },{ 3, 3, -3 },{ -4, 0, 1 },{ -2, 3, 3 },{ 3, -4, -4 } },
+		{ { 1, 0, -2 },{ 2, 3, 1 },{ -3, 2, -4 },{ 0, -3, 1 },{ -2, 3, -1 },{ 2, 1, 0 },{ -2, -3, -1 },{ -3, 0, 3 },{ -4, -2, 0 },{ 1, -4, 2 },{ -2, 2, 1 },{ 3, -2, -4 },{ -4, 3, 0 },{ -3, 2, -2 },{ 1, 0, -1 },{ 1, -4, 2 },{ 2, -2, 3 },{ 3, 0, 0 },{ -3, -2, -3 },{ -3, -4, -2 },{ 0, 2, 2 },{ -4, 0, 0 },{ -3, 2, 3 },{ -1, -1, 1 },{ -3, -3, 2 },{ 3, 2, -1 },{ 0, 0, 0 },{ -4, -2, -3 },{ 2, -1, -4 },{ 1, -4, 1 },{ -2, 0, 0 },{ 0, 2, 3 },{ -3, -1, -2 },{ -2, 0, 2 },{ 3, -3, -1 },{ -1, 1, -3 },{ -2, -3, -4 },{ 3, 1, 2 },{ 1, 2, -3 },{ -1, -4, -1 },{ 0, -1, 2 },{ 1, -3, -4 },{ 0, 2, -2 },{ -4, 1, 1 },{ 1, -1, -1 },{ 3, -1, -2 },{ -2, -3, -4 },{ 2, -4, 2 },{ -3, 3, 0 },{ 1, -2, -1 },{ 3, 0, -3 },{ -2, 3, 0 },{ -1, -2, 3 },{ 3, -1, -4 },{ 1, 2, 0 },{ -4, 2, -4 },{ 2, -4, -2 },{ 2, 0, -1 },{ 3, -1, -1 },{ -2, -3, -2 },{ 0, -2, -4 },{ 2, 2, 0 },{ 1, -1, -1 },{ -4, 2, 2 } },
+		{ { 0, -2, 3 },{ -2, -4, 0 },{ 3, -2, 0 },{ 1, -1, -2 },{ -4, 0, 2 },{ 3, 1, -2 },{ -1, 2, -4 },{ 2, -3, -3 },{ 0, 1, -2 },{ 1, 3, -4 },{ -3, -1, 1 },{ -1, -2, 2 },{ 1, -1, -2 },{ -2, -4, 0 },{ 0, 3, 1 },{ -4, 2, -4 },{ -1, -3, -2 },{ -2, 0, 0 },{ -1, 2, -4 },{ 2, -1, 3 },{ 1, 3, -2 },{ 3, -2, 2 },{ -2, -4, -3 },{ 1, 1, -2 },{ 0, -4, 2 },{ -4, 2, -2 },{ -1, -3, 1 },{ 2, 3, 2 },{ -3, 2, -2 },{ 0, -3, 1 },{ -4, -1, -3 },{ 2, 1, 2 },{ -1, -2, 1 },{ 0, 3, -2 },{ -4, -3, 3 },{ 3, 2, 1 },{ -2, -1, 3 },{ 0, 0, 1 },{ -4, -3, 0 },{ -3, 0, -2 },{ 2, -1, 3 },{ -4, 2, -1 },{ -2, 0, 2 },{ 2, -3, -3 },{ -3, -3, 3 },{ 0, 3, 0 },{ 3, -2, 3 },{ 1, 1, -2 },{ -4, -4, -3 },{ -2, 2, -4 },{ -2, -3, 3 },{ 2, 1, -2 },{ -3, -4, -3 },{ -4, 0, -1 },{ 1, -3, 1 },{ -2, -2, 2 },{ -3, 1, -3 },{ 0, -3, 1 },{ -2, -4, -4 },{ 1, 1, 3 },{ 0, 2, 1 },{ -3, -4, 2 },{ -1, -1, -3 },{ -1, -3, -4 } },
+		{ { 0, 1, -1 },{ -4, 0, -4 },{ -1, 0, 3 },{ -3, -3, -3 },{ 1, -1, 2 },{ -3, -4, 0 },{ 0, -2, 2 },{ -3, -1, 1 },{ 3, 0, 2 },{ -2, -3, -1 },{ -4, 2, 0 },{ 2, 1, -2 },{ -1, -4, 3 },{ 2, 0, -3 },{ 3, -2, 0 },{ 1, -1, -3 },{ -4, 2, 2 },{ 1, -3, -1 },{ 3, 3, 2 },{ 0, -4, 1 },{ -2, -2, -4 },{ -4, -3, -4 },{ -1, 3, -1 },{ 1, 0, 0 },{ 3, 0, -4 },{ -2, -1, -4 },{ -3, -3, 3 },{ 0, 1, -1 },{ -1, -4, -1 },{ 3, 0, 3 },{ -1, 3, -2 },{ 3, -4, -1 },{ -3, -1, -4 },{ 2, -4, 0 },{ 1, 1, -4 },{ -4, -1, -1 },{ 2, 3, -2 },{ 1, -4, -4 },{ -1, -2, 2 },{ 3, 2, -3 },{ -2, -3, -4 },{ 1, 3, 1 },{ 3, -4, 0 },{ -1, -1, -2 },{ -1, 3, 1 },{ -4, 0, -4 },{ -2, 2, 1 },{ 0, 0, 0 },{ -1, 1, 3 },{ 2, -1, 1 },{ 0, -3, -2 },{ -4, 0, 1 },{ 0, 3, 2 },{ -2, 1, 3 },{ 3, -2, -1 },{ -1, 0, -2 },{ 3, 3, 3 },{ -1, 1, 0 },{ -4, 3, 2 },{ 2, -2, 1 },{ -4, -1, -1 },{ 3, 1, -3 },{ -3, -3, 1 },{ 3, 3, -2 } },
+		{ { -2, -2, 2 },{ 3, -4, -2 },{ 1, 3, 1 },{ 2, 2, -1 },{ -2, 2, -4 },{ -1, -4, -1 },{ -4, 3, 3 },{ 3, 2, -4 },{ 1, 1, -1 },{ -2, -4, 3 },{ 0, 3, -3 },{ 3, 0, -4 },{ -4, -3, 1 },{ -3, 1, 2 },{ -3, 2, -1 },{ -2, -3, 3 },{ 0, 1, -4 },{ 2, -1, -2 },{ -3, -1, -3 },{ -3, 1, 3 },{ 0, 0, 0 },{ 3, 1, -1 },{ -3, 2, 3 },{ 2, -2, 1 },{ -4, -2, 3 },{ -2, 3, 0 },{ 1, -2, -3 },{ 2, -1, 0 },{ -2, -2, -4 },{ -4, 0, 2 },{ -3, 1, -4 },{ 1, -3, 3 },{ -2, 2, -1 },{ -1, 3, 2 },{ 0, 0, -3 },{ -3, -2, 2 },{ -1, -4, -2 },{ 2, 2, 0 },{ -4, 3, -1 },{ 2, 1, 3 },{ -3, -2, 0 },{ -1, 1, -2 },{ 0, -2, -4 },{ -3, 1, 2 },{ 2, 2, -3 },{ 2, -4, -1 },{ -1, -2, 2 },{ -3, -3, -3 },{ 3, 2, -1 },{ -3, -1, 2 },{ 3, 3, -3 },{ 1, -2, 0 },{ 1, -4, -4 },{ 2, 1, -1 },{ -1, -1, -3 },{ 1, 3, 0 },{ -4, -1, -4 },{ 1, -4, -2 },{ -3, 2, -3 },{ -1, 0, -4 },{ 2, 3, -2 },{ 0, -4, 0 },{ -4, 0, 3 },{ 1, 2, 1 } },
+		{ { 2, -1, -1 },{ -4, 1, 0 },{ -3, -3, -3 },{ 2, -2, 3 },{ 0, 1, 1 },{ 3, 0, -2 },{ 1, -2, -3 },{ -1, -4, 0 },{ -4, 0, -3 },{ -1, -3, 1 },{ 1, -2, -2 },{ 2, -1, 2 },{ -1, 2, -1 },{ 0, 3, -4 },{ 1, -2, -2 },{ 3, -4, 1 },{ -2, 0, 1 },{ 0, 3, -1 },{ -4, -4, 1 },{ -2, -2, -3 },{ 1, 2, 0 },{ -3, -3, 2 },{ 0, -4, -3 },{ -1, 2, -2 },{ 0, 1, 1 },{ 2, -4, -2 },{ 3, 1, 1 },{ -1, 2, 3 },{ 2, 2, -2 },{ 0, -3, 1 },{ 1, 3, 0 },{ 2, -2, 0 },{ -4, 0, -3 },{ 3, -3, 1 },{ -2, -3, 0 },{ -1, 2, -1 },{ 3, 0, 1 },{ -2, -1, -3 },{ 0, -3, 2 },{ 0, 0, 1 },{ -4, -1, -2 },{ 2, 2, 3 },{ 3, -4, 2 },{ -3, -1, 0 },{ 1, -3, -3 },{ 0, 1, 3 },{ -4, 3, -1 },{ 2, -1, -2 },{ 1, -3, -4 },{ -1, -4, 2 },{ -2, 1, -4 },{ -1, 2, 3 },{ -3, -1, 0 },{ -4, -3, -2 },{ -2, 2, 1 },{ -3, -4, 2 },{ 2, -3, 2 },{ 0, -1, 3 },{ 3, -2, -1 },{ -2, -3, 3 },{ -2, -3, 0 },{ -1, -2, 2 },{ 2, 1, -4 },{ -2, -3, -3 } },
+		{ { -1, -2, 3 },{ 0, 2, -2 },{ -1, -1, 2 },{ -3, 3, -3 },{ -1, -3, -1 },{ -4, 1, 3 },{ -2, -1, -2 },{ 2, 3, 1 },{ 2, -1, 2 },{ -3, 2, -4 },{ 0, 3, 0 },{ -2, -4, 3 },{ -3, -1, 0 },{ -1, -3, -3 },{ 2, 0, 3 },{ -4, 3, 0 },{ 2, -4, -3 },{ -1, -2, 2 },{ 3, 1, -4 },{ 2, 2, -2 },{ 1, -1, 2 },{ 3, 3, -2 },{ -4, -1, 3 },{ 2, -3, -3 },{ -2, 0, -4 },{ -3, -3, 2 },{ -4, 3, -1 },{ 0, -4, -3 },{ -4, -1, 2 },{ -3, 2, -2 },{ 3, -4, -4 },{ -2, -1, 2 },{ 0, 2, -2 },{ -3, -1, 3 },{ 2, 1, -4 },{ 1, 3, -2 },{ -3, -2, 2 },{ 1, 1, 3 },{ -3, -2, -3 },{ 3, -3, -4 },{ 1, -4, 0 },{ -2, 1, -3 },{ 0, 3, -1 },{ -4, 0, -2 },{ -2, 0, 1 },{ 3, -2, -4 },{ -3, -4, 1 },{ -2, 1, 3 },{ 1, 0, 0 },{ -4, 3, -1 },{ -3, 0, -1 },{ 2, -2, 1 },{ -1, -4, -3 },{ 0, 3, 3 },{ 3, 0, -3 },{ 0, 1, -4 },{ -2, -2, -1 },{ -4, 0, 1 },{ 1, 1, -3 },{ 2, 2, 1 },{ 0, -1, -4 },{ -4, 1, -2 },{ 3, 3, 2 },{ 0, 0, 0 } },
+		{ { -4, 3, -1 },{ 3, -4, -4 },{ -2, 0, 2 },{ 2, -4, 0 },{ 3, -1, -4 },{ -3, 0, 2 },{ 0, -3, 0 },{ 0, 2, -4 },{ 3, -4, 3 },{ -1, -2, -1 },{ -4, 1, 1 },{ 3, 1, -3 },{ 1, -2, -2 },{ -4, 2, 2 },{ 1, 1, 0 },{ -1, -1, -4 },{ -2, 2, -2 },{ -3, -1, 3 },{ 1, 0, 0 },{ -1, -3, 3 },{ -2, -4, -3 },{ -4, 0, 1 },{ -1, -2, -4 },{ 1, 3, 0 },{ 3, 1, 0 },{ 0, 2, 3 },{ -1, -1, -4 },{ -3, 0, 0 },{ 1, -2, 3 },{ 2, -1, -3 },{ -1, 0, -1 },{ -1, 1, 2 },{ -4, -2, -3 },{ 1, -2, 1 },{ -1, -4, -2 },{ 0, -1, 3 },{ -4, -4, -4 },{ -2, 2, 0 },{ 3, 2, -2 },{ -1, 3, -1 },{ -2, -1, 2 },{ 2, -2, 1 },{ -3, -3, -4 },{ 3, -3, 3 },{ -1, 2, 2 },{ 0, 3, -1 },{ -1, 0, 0 },{ 3, -2, -3 },{ 0, 2, 1 },{ -2, -3, -2 },{ 2, -2, 2 },{ 1, 2, -4 },{ 3, 1, 2 },{ 1, 3, -1 },{ -4, -2, 2 },{ -1, 0, 0 },{ 3, 2, -2 },{ -3, 3, -4 },{ 0, -4, 0 },{ -1, 1, 2 },{ -3, 3, -2 },{ 1, -1, -1 },{ -3, -4, 1 },{ 1, -3, -3 } },
+		{ { 2, -2, 2 },{ -3, 3, 1 },{ 1, -1, -1 },{ 0, 1, 3 },{ 1, -2, -3 },{ -2, 2, -1 },{ 1, -2, 1 },{ -4, 3, -2 },{ -2, 0, -1 },{ -3, -3, -3 },{ 0, -1, -2 },{ 2, 2, 3 },{ -2, -4, 0 },{ 3, 0, -1 },{ 0, -2, 1 },{ -3, -3, -2 },{ 2, 1, 2 },{ 0, -3, -1 },{ 0, 3, -1 },{ -4, -3, -4 },{ -1, 1, -1 },{ 2, 2, 1 },{ 0, -1, -1 },{ -3, -4, 2 },{ -2, -1, -1 },{ 1, -2, -2 },{ -1, -3, -1 },{ 3, 3, 1 },{ -2, 1, -2 },{ 1, -4, 1 },{ -2, -3, 3 },{ -3, 3, -1 },{ 3, -4, 0 },{ 1, 1, -4 },{ -4, 2, 0 },{ 3, 3, 1 },{ 2, -1, -3 },{ -1, 0, -1 },{ 0, -4, 1 },{ -4, 0, -2 },{ -3, 2, 3 },{ -1, 1, 0 },{ 1, 3, -3 },{ -4, 0, -1 },{ 1, -1, 1 },{ 2, -4, -3 },{ -3, -1, -2 },{ 1, 1, 2 },{ -4, -4, -3 },{ -1, -1, 3 },{ 3, 0, 0 },{ -4, -4, -2 },{ -2, -1, -2 },{ -3, -3, 0 },{ 2, -2, -3 },{ 2, -4, 1 },{ -2, 1, 3 },{ 1, -3, 2 },{ 3, -2, -3 },{ -3, 0, 3 },{ 3, -4, -1 },{ 2, -2, 1 },{ -2, 2, 3 },{ 0, 0, -4 } },
+		{ { 2, 1, 0 },{ -1, -3, -3 },{ -2, 1, -2 },{ -4, 2, 1 },{ 2, 3, -2 },{ -4, -4, -4 },{ -1, -4, 2 },{ 3, 0, -3 },{ 1, -2, 1 },{ 1, 1, 2 },{ 2, 3, 0 },{ -1, 0, -4 },{ -3, -3, 2 },{ -2, -1, -4 },{ 0, 3, 3 },{ 3, 1, -4 },{ -4, -4, -3 },{ 3, 2, 1 },{ -3, -1, -3 },{ 3, 0, 1 },{ -3, -2, 2 },{ 1, 3, -3 },{ 3, -3, 3 },{ -2, 1, -3 },{ -4, 2, 2 },{ 3, 0, 1 },{ 2, -4, -3 },{ -3, -2, 2 },{ 0, 3, 0 },{ -4, 1, -4 },{ 3, 2, -2 },{ 0, 0, 1 },{ 2, -3, -3 },{ -1, 3, 3 },{ -2, 0, 2 },{ -3, -3, -1 },{ 0, -2, 1 },{ -3, 1, 3 },{ 2, -3, 2 },{ 1, -2, -4 },{ 3, -4, -3 },{ -1, -1, -2 },{ 0, -2, 0 },{ 2, -4, -4 },{ -2, 1, 2 },{ -3, 3, -2 },{ -4, -3, -4 },{ 0, 3, 1 },{ 2, -1, -1 },{ -2, 2, -4 },{ 0, 3, -3 },{ -3, 1, 1 },{ -1, -2, 3 },{ 0, 0, -4 },{ -3, 2, 1 },{ -4, -1, -3 },{ 0, -3, -2 },{ -2, -1, -1 },{ -4, 2, 0 },{ -1, -3, -4 },{ 1, 3, -3 },{ -2, 0, -3 },{ -1, -1, 0 },{ -3, 1, -2 } },
+		{ { -4, -4, 1 },{ 1, -1, 3 },{ 3, -3, 1 },{ -3, -2, -4 },{ 1, 0, 3 },{ 3, -1, 0 },{ -2, 1, 3 },{ 0, 3, 2 },{ -4, 1, -4 },{ -2, -4, -1 },{ -4, -2, 2 },{ 3, -4, 1 },{ 1, 2, -3 },{ -4, 3, -2 },{ 2, -2, -1 },{ -2, -4, 0 },{ -1, 0, 2 },{ -2, -2, 3 },{ 1, 3, -2 },{ -2, -4, 0 },{ 2, -2, 3 },{ -1, 1, -2 },{ -3, -3, 0 },{ 1, 2, -4 },{ 0, -4, -2 },{ -4, -1, 3 },{ -1, 2, -3 },{ -2, 2, -1 },{ 1, 0, -4 },{ 2, -2, 2 },{ -1, -1, 3 },{ -2, 3, -4 },{ -3, -1, -1 },{ 2, -2, 0 },{ 0, 1, -3 },{ 1, -4, -2 },{ -1, 0, -3 },{ 3, 3, -4 },{ -4, -1, 0 },{ 0, 3, 2 },{ -2, 0, 1 },{ 2, -3, 3 },{ -4, 2, 1 },{ -2, -1, 3 },{ 0, 2, -1 },{ 3, -2, 0 },{ -1, -4, 3 },{ 3, 0, -1 },{ -2, -3, 2 },{ -3, -3, 0 },{ 1, -1, 2 },{ 1, -4, 1 },{ 2, 3, -1 },{ 3, -3, -2 },{ 1, 2, 2 },{ 1, 1, 0 },{ -1, 3, 3 },{ 2, -2, -4 },{ 2, 0, 1 },{ 0, 1, -1 },{ -4, -2, 2 },{ 2, 2, 3 },{ -4, -4, -1 },{ 3, 3, 2 } },
+		{ { -1, 0, -3 },{ 0, 2, -4 },{ -3, -1, -1 },{ -1, -4, 2 },{ -1, 1, 0 },{ 0, -3, -1 },{ -3, -2, -2 },{ 2, 2, -4 },{ 2, -3, 0 },{ -3, -1, 3 },{ 0, 2, -2 },{ -2, 1, -3 },{ -1, -2, 0 },{ 3, -3, 2 },{ 1, 0, 3 },{ -3, 1, -3 },{ 1, 2, -1 },{ 0, -3, -4 },{ 2, 0, 1 },{ -4, 1, -3 },{ 0, 2, -4 },{ -4, -4, -2 },{ -2, -1, 1 },{ 3, 0, -1 },{ 0, 3, -4 },{ 1, -2, 2 },{ -3, 1, 0 },{ 3, -3, 3 },{ 0, -4, -1 },{ -3, -3, -2 },{ -4, 1, 0 },{ 1, -4, 1 },{ 0, -3, 2 },{ -4, 1, 3 },{ -2, -1, -4 },{ 3, -3, 2 },{ -4, -1, 3 },{ -2, 2, 0 },{ -3, 1, -2 },{ 1, -2, -1 },{ -2, 1, -1 },{ 3, -3, -3 },{ -3, 3, -4 },{ -1, 0, -2 },{ 2, -2, 1 },{ 1, 1, -3 },{ -1, -1, 3 },{ 1, 2, 1 },{ -4, 2, -2 },{ -1, 1, -2 },{ 3, -2, -4 },{ -3, 2, -1 },{ -1, 0, -3 },{ -4, -1, 2 },{ -2, -4, -1 },{ 3, -2, -3 },{ -4, 0, -2 },{ 1, 3, 2 },{ -2, -1, 0 },{ -3, -4, -2 },{ 0, 1, 1 },{ -1, -3, -2 },{ 0, -1, -4 },{ 2, -3, -2 } },
+		{ { 0, -2, 3 },{ -4, 3, -1 },{ 3, 0, 0 },{ 2, 2, -2 },{ -4, 3, -3 },{ -2, 1, -3 },{ 3, 0, 1 },{ -2, -1, -2 },{ -1, -4, 1 },{ -1, 3, -3 },{ 3, -2, -1 },{ 1, -1, 3 },{ -4, 0, -1 },{ -1, 3, -3 },{ -2, -3, 1 },{ 0, -1, -2 },{ 3, 3, 1 },{ -4, -1, 2 },{ -1, -3, -1 },{ 3, 3, 2 },{ 1, -1, 0 },{ -1, 0, 1 },{ 2, 3, 2 },{ -3, -2, 3 },{ 2, -4, 0 },{ -1, 1, -1 },{ 2, -2, -2 },{ -4, 0, 1 },{ -2, 3, -3 },{ 1, -1, 2 },{ 3, 2, -3 },{ -2, 0, -2 },{ 3, 2, -1 },{ -4, -4, -4 },{ 2, 3, 0 },{ 1, 2, 1 },{ -1, 0, -1 },{ 1, -4, -3 },{ 2, -3, 3 },{ -1, -4, 1 },{ -4, 3, -3 },{ 1, -1, 2 },{ 3, 0, 0 },{ 0, -4, 2 },{ -4, -3, -3 },{ -2, 3, -2 },{ -3, 0, 0 },{ 2, -4, -4 },{ 0, -2, -3 },{ 2, 0, 3 },{ 0, -4, 3 },{ -4, 1, 1 },{ 2, -2, -4 },{ 0, 1, 3 },{ -2, 0, -4 },{ -1, -4, 1 },{ -3, 1, 0 },{ 0, -3, -4 },{ 3, -4, 3 },{ -3, 3, -3 },{ 3, -1, 1 },{ 1, 0, 0 },{ -3, 2, 2 },{ -2, 1, 0 } },
+		{ { 1, 0, 3 },{ -2, -3, 1 },{ 1, -2, -4 },{ -2, -4, 2 },{ 2, -1, 3 },{ -3, -3, -4 },{ 0, 2, 2 },{ 1, -3, 3 },{ -4, 0, -1 },{ 2, 2, 2 },{ 1, 1, -4 },{ -3, -4, 1 },{ 0, -3, 0 },{ 2, -1, -4 },{ -3, 1, 2 },{ -3, -4, -1 },{ 2, -4, -4 },{ 0, 2, 0 },{ -3, 0, -3 },{ -3, -4, 3 },{ -2, -2, -1 },{ 0, 2, -3 },{ 3, -3, -4 },{ -3, 0, 0 },{ -4, 3, -3 },{ 0, -1, 1 },{ -2, -4, -3 },{ 2, 2, 3 },{ 0, 1, -4 },{ -3, -2, 1 },{ -1, 3, 0 },{ -1, 0, 3 },{ 1, -3, -3 },{ -2, 2, 2 },{ -1, -2, -2 },{ 0, 1, -2 },{ -3, -2, 2 },{ 0, -2, -4 },{ 3, 2, 1 },{ -3, 0, -4 },{ 1, 1, 3 },{ -3, -2, -4 },{ -2, 2, 0 },{ 2, -1, -1 },{ 0, 1, 1 },{ 3, 3, -4 },{ -4, -1, 2 },{ 0, -4, -1 },{ -2, 2, 2 },{ -3, 3, 0 },{ -2, -3, -2 },{ -1, 2, 1 },{ 1, -4, -2 },{ -3, 3, 0 },{ 2, 3, -1 },{ 3, -3, 1 },{ 0, 2, 3 },{ -3, 0, -1 },{ 2, -2, -3 },{ -2, 2, -1 },{ -1, -2, 3 },{ 1, 3, -4 },{ -3, -4, -1 },{ 3, -4, -3 } },
+		{ { 2, -1, -4 },{ -4, 1, -2 },{ -1, 2, -1 },{ 0, 1, 1 },{ 1, -1, 0 },{ 2, -4, 1 },{ -1, 0, -4 },{ -3, 3, -1 },{ 0, -2, -3 },{ -4, -1, -2 },{ -2, 3, 2 },{ -2, -3, 0 },{ 3, 2, -2 },{ -1, 2, 3 },{ 3, 3, -2 },{ -4, -2, -1 },{ -1, 1, 3 },{ -2, 2, 1 },{ 1, -2, -2 },{ 2, 0, -4 },{ 1, -2, 2 },{ 3, -4, 3 },{ -4, 1, -2 },{ 0, -1, -1 },{ -2, -3, 3 },{ 3, 2, -4 },{ -1, -3, 0 },{ -3, 0, 2 },{ 3, -2, -1 },{ 1, -3, 2 },{ -4, -4, -4 },{ 2, -1, -2 },{ -3, -2, 1 },{ 0, -1, -1 },{ 2, -4, 1 },{ -3, -3, -3 },{ -2, 1, 3 },{ 2, 3, -1 },{ -4, 0, 2 },{ 0, -3, 0 },{ 2, -4, -2 },{ -1, 2, 1 },{ 0, -2, 3 },{ -3, -4, -2 },{ -1, 2, 0 },{ -3, -2, 3 },{ 2, -3, -2 },{ -1, 0, 1 },{ 3, -1, -2 },{ 1, 1, -4 },{ 3, -1, -1 },{ -2, -1, -3 },{ 3, 0, 2 },{ 1, -2, 0 },{ -2, -3, 3 },{ -4, 1, -3 },{ 1, -1, -2 },{ -1, 3, 0 },{ 1, 0, 1 },{ -4, -3, -2 },{ -4, 1, 3 },{ 2, -1, -2 },{ -2, 0, 1 },{ -1, 3, 2 } },
+		{ { -3, -3, -1 },{ 0, -2, 2 },{ 3, 3, 1 },{ -3, -3, -3 },{ -4, 3, -2 },{ -2, -2, -1 },{ 3, 2, 2 },{ 1, 1, 0 },{ 3, -3, 3 },{ -1, -4, 1 },{ 3, 0, -1 },{ 1, -1, -4 },{ -4, 0, 3 },{ 1, -4, -3 },{ 0, -2, 0 },{ 1, 0, 2 },{ 2, -1, -3 },{ 3, -3, -3 },{ -1, 2, 0 },{ -4, 1, 2 },{ -2, 3, 0 },{ -3, 2, -1 },{ -1, -3, -4 },{ 1, 1, 2 },{ 2, -2, 1 },{ -4, 0, -2 },{ 1, 3, -3 },{ 0, -4, -1 },{ -2, -1, -2 },{ 2, 2, 0 },{ -3, 1, -3 },{ 3, 3, 1 },{ -3, 1, 3 },{ 1, 0, -3 },{ -4, 3, 3 },{ 3, 2, -4 },{ 3, -1, 0 },{ -1, -4, -2 },{ -3, 3, -2 },{ -1, -1, 3 },{ -2, 3, -1 },{ 3, -1, 0 },{ -4, 1, -3 },{ 2, 0, -4 },{ 3, -3, 2 },{ -1, -1, -3 },{ 1, 1, 0 },{ -3, 3, -3 },{ -4, -2, 2 },{ 1, -3, 1 },{ -3, 3, 3 },{ -4, -4, -4 },{ 0, 2, -1 },{ -1, 1, -2 },{ -4, -1, -4 },{ 2, -1, 2 },{ -2, -4, -3 },{ -3, -2, 2 },{ 3, 1, -4 },{ 2, -4, 2 },{ -1, 3, -4 },{ 0, -2, -3 },{ 3, -3, 0 },{ -4, 1, -2 } },
+		{ { 1, 2, -3 },{ 3, -4, 0 },{ -3, 0, 3 },{ -1, -1, -4 },{ 3, 1, 0 },{ -2, 0, 3 },{ -3, -4, -3 },{ -4, -2, -2 },{ -2, 1, -4 },{ 0, 2, 0 },{ 2, -3, -2 },{ -3, 3, -3 },{ 2, 1, 1 },{ -3, -1, -1 },{ -2, -3, 0 },{ -2, 1, 2 },{ -3, 3, -1 },{ -4, -4, 1 },{ 3, 0, -4 },{ 0, -3, -2 },{ -3, -1, 1 },{ 1, -2, -3 },{ 2, 0, 0 },{ 0, -1, -2 },{ -2, 3, 2 },{ -1, -4, 0 },{ -3, 1, 3 },{ 1, -1, 2 },{ -4, 3, -4 },{ -1, 2, 3 },{ 0, -4, -1 },{ -2, 0, 0 },{ 3, -3, -4 },{ 1, -2, -2 },{ -1, -4, -1 },{ -4, 0, 0 },{ 0, 0, 1 },{ 1, 1, -3 },{ -2, -1, -1 },{ 3, -3, -4 },{ 1, 1, -3 },{ -3, 0, 2 },{ 1, -3, -2 },{ -2, 3, -1 },{ -4, 3, 3 },{ 1, 0, -4 },{ -2, -4, -1 },{ 3, 2, 3 },{ -1, 0, -1 },{ 0, 1, 0 },{ -1, 0, -3 },{ 2, -2, 1 },{ -3, -3, 3 },{ 3, 3, -2 },{ 1, -4, 1 },{ -1, 2, -1 },{ 3, 3, 0 },{ 0, 0, -2 },{ -3, -3, 0 },{ 0, 1, 0 },{ -2, 2, -1 },{ 1, 0, 1 },{ -3, -2, 3 },{ 0, 3, 2 } },
+		{ { -1, -1, -4 },{ 1, -4, -3 },{ -2, -2, -1 },{ 2, 2, 2 },{ 0, -3, -4 },{ 1, -1, 2 },{ 0, 3, 1 },{ 2, -1, -2 },{ 2, 3, 2 },{ -1, 0, 3 },{ -4, -2, -3 },{ 0, 1, 2 },{ -2, -2, 1 },{ -1, -4, -4 },{ 2, 2, -2 },{ 3, 2, -4 },{ 0, -3, -3 },{ -3, -1, 3 },{ -2, 3, 3 },{ 2, -4, -1 },{ -1, 1, -2 },{ 3, 2, 3 },{ -2, -4, 1 },{ -4, 3, -4 },{ 1, -3, -2 },{ 2, 1, -3 },{ 3, 2, -1 },{ -2, -3, -4 },{ 2, -2, 1 },{ 3, -1, 1 },{ -2, -3, -2 },{ 0, -2, -3 },{ -4, 2, 2 },{ -1, 2, 1 },{ -2, 3, 3 },{ 1, -2, -4 },{ -2, -3, 2 },{ 0, -3, 2 },{ -4, -2, 3 },{ 2, 2, 1 },{ -4, -4, 1 },{ 0, -4, 0 },{ -1, -2, -2 },{ 2, 2, 2 },{ -2, -2, 1 },{ 0, -1, 0 },{ -4, -3, 1 },{ 2, -2, -2 },{ -3, -4, -4 },{ -2, 2, 2 },{ 3, -2, -2 },{ 1, 2, 0 },{ -4, -4, 2 },{ 0, 1, -4 },{ -3, 0, 1 },{ -2, -2, 3 },{ 1, 1, 2 },{ -4, -3, -2 },{ -2, 2, 3 },{ 2, -2, -3 },{ -1, -1, 2 },{ 3, -4, -4 },{ -2, -3, -1 },{ 2, 2, 0 } },
+		{ { -1, -2, 1 },{ -4, 0, 3 },{ -2, 3, 1 },{ -4, 2, -2 },{ 1, -3, -1 },{ -1, 0, -3 },{ -4, 1, -1 },{ 0, -4, 3 },{ -2, -2, -4 },{ -3, 2, -1 },{ 1, -4, 0 },{ 3, -1, -1 },{ 0, 3, 0 },{ 2, 1, 3 },{ 0, -2, 2 },{ -4, -1, 1 },{ 1, -2, -1 },{ -1, 0, 0 },{ 0, 1, 0 },{ 1, -2, -3 },{ -3, -3, 2 },{ -2, -1, -3 },{ 0, 2, 1 },{ 3, 0, 3 },{ -3, -4, 0 },{ -1, -1, 1 },{ -4, -2, 0 },{ 0, 0, -3 },{ -1, -3, 3 },{ -3, 3, -2 },{ 1, 1, 2 },{ 2, 0, 3 },{ -3, -4, -3 },{ 2, -1, 0 },{ 3, 1, -1 },{ -3, -1, -2 },{ 2, 2, -3 },{ -1, 2, -1 },{ 2, 3, 0 },{ -3, 1, -4 },{ 1, -1, 3 },{ 3, 2, -4 },{ -3, 0, 3 },{ 3, -1, -1 },{ 0, -4, -4 },{ -3, 1, -2 },{ 3, 2, -3 },{ -1, 3, 1 },{ 0, -1, 3 },{ 2, -3, 0 },{ -4, 3, -3 },{ -2, -1, -2 },{ 3, 0, -1 },{ -2, 2, 0 },{ 2, -2, -3 },{ -1, -3, -3 },{ -4, 3, -1 },{ 1, -1, -4 },{ 3, -1, 1 },{ -1, 3, -1 },{ -3, -3, -3 },{ -4, 3, 2 },{ 0, 0, 0 },{ -3, 1, -2 } },
+		{ { 3, 3, -2 },{ 0, -1, -1 },{ 2, -2, -3 },{ 3, 1, 0 },{ -1, -4, 3 },{ -3, 2, -3 },{ 3, 3, 1 },{ -2, -3, 0 },{ 1, -3, -3 },{ 3, 0, 1 },{ -4, 0, 3 },{ -1, -3, -2 },{ -3, -4, -3 },{ -3, 0, -4 },{ -4, 3, -1 },{ -1, -4, 1 },{ 3, 2, -3 },{ 2, 3, -2 },{ -4, -2, 2 },{ 3, 0, -4 },{ -4, 3, 1 },{ 0, -3, -1 },{ 1, -1, -4 },{ -4, -2, -1 },{ 2, 1, -3 },{ 1, -3, 3 },{ -2, 3, 2 },{ 2, 2, -1 },{ -4, 0, -3 },{ 1, -4, -1 },{ -4, 1, -4 },{ 3, 3, -1 },{ -3, -2, 0 },{ 1, -3, -2 },{ 0, 1, -4 },{ -4, -4, 1 },{ 0, 0, 3 },{ -3, -4, 0 },{ 3, 0, -2 },{ -1, -3, -2 },{ -1, -2, -1 },{ -2, 3, 1 },{ 1, -3, -3 },{ -4, 3, -3 },{ -1, -3, 1 },{ 2, 2, 3 },{ -2, 0, 2 },{ 1, 1, 0 },{ -4, -2, -2 },{ -2, 1, -4 },{ 0, -4, 3 },{ 1, 1, 1 },{ -1, -3, 2 },{ -3, 3, -4 },{ 1, -4, -1 },{ 2, -1, 2 },{ -1, 1, 1 },{ 3, -4, -4 },{ 0, 0, 3 },{ -4, -4, 1 },{ 1, 2, -2 },{ 3, 1, 3 },{ -2, -1, -4 },{ 2, -3, 3 } },
+		{ { 1, -3, 0 },{ -3, -4, 3 },{ 0, 1, -4 },{ -3, 0, 2 },{ 1, -3, 0 },{ -2, -2, 2 },{ 3, 0, -4 },{ -4, -1, -2 },{ -1, 1, 0 },{ 0, 2, 2 },{ -2, 3, -4 },{ 2, -1, 1 },{ 3, 2, 2 },{ 1, -2, -1 },{ 1, -3, -2 },{ -2, -1, 3 },{ -3, 0, -4 },{ -2, -4, 3 },{ 1, -1, -2 },{ -1, -4, 0 },{ -1, 2, 3 },{ 2, 1, -2 },{ -2, -3, 2 },{ -1, 3, 0 },{ -1, 0, -2 },{ -3, 2, -2 },{ 0, -4, -4 },{ 3, -1, 0 },{ -1, -2, 1 },{ 2, 0, 2 },{ -2, -3, 0 },{ 0, -1, 3 },{ -2, -1, -3 },{ -1, 2, 3 },{ -2, 0, 2 },{ 3, -2, -3 },{ -2, 3, 1 },{ 1, -2, -4 },{ 0, -1, 1 },{ -4, 1, 2 },{ -2, -2, -3 },{ 0, 2, 0 },{ -3, -2, 1 },{ 1, 1, 2 },{ -2, 0, -1 },{ 2, -2, -4 },{ -4, -4, -2 },{ -1, -3, -3 },{ 2, -1, -1 },{ 3, 3, 2 },{ 1, 0, 1 },{ -3, -3, -3 },{ 2, 2, -2 },{ 0, -2, 3 },{ 3, 0, 1 },{ -4, 3, -2 },{ 0, 2, 0 },{ -3, -2, 0 },{ -2, 2, -3 },{ 2, -3, -1 },{ 0, 0, 0 },{ 1, -2, -4 },{ -1, -4, 1 },{ -4, 3, -3 } },
+		{ { 3, 0, 2 },{ -2, 2, -4 },{ -2, -3, 1 },{ 2, 3, -2 },{ -4, -1, -2 },{ 0, -2, 2 },{ 2, 2, -1 },{ 1, -4, 3 },{ 2, 3, -3 },{ -3, -2, -2 },{ 1, -4, -1 },{ -1, 0, -4 },{ -4, 1, 0 },{ 0, 3, 2 },{ -2, 1, -3 },{ 3, -3, 0 },{ 0, 2, 2 },{ -4, 1, -1 },{ 2, -3, -3 },{ 3, 2, 1 },{ -3, 0, 0 },{ -4, -2, -3 },{ 2, 3, 3 },{ 0, -4, 1 },{ 3, 1, 2 },{ 2, -2, -4 },{ -4, 1, 1 },{ -2, -3, 3 },{ 3, 3, -3 },{ -3, 2, -4 },{ 1, -2, -2 },{ -1, 2, 1 },{ 3, -4, -4 },{ 2, 3, 1 },{ -4, 1, -2 },{ 1, -3, 0 },{ 2, -1, -1 },{ -2, 2, 3 },{ -3, -4, -4 },{ 2, 3, 0 },{ 3, -4, 3 },{ 2, 0, -2 },{ -1, -1, 3 },{ 3, -4, 0 },{ 0, 2, -1 },{ -3, -3, 2 },{ 3, 0, 0 },{ 0, 3, 1 },{ -3, -2, 3 },{ -2, 2, -3 },{ -3, -4, -1 },{ 0, -1, 3 },{ -4, 3, 0 },{ -2, 1, 1 },{ -2, -1, -2 },{ -3, -3, -4 },{ -1, -3, 2 },{ 2, 0, 3 },{ 1, -2, -2 },{ -3, 3, -3 },{ -2, 1, 2 },{ -3, 2, 2 },{ -1, -2, -1 },{ -4, 2, 0 } },
+		{ { 1, 0, -2 },{ 0, -2, -1 },{ -1, -4, 3 },{ 2, 2, 0 },{ 3, 0, -3 },{ -2, 3, -4 },{ -1, 1, 1 },{ -4, -3, -1 },{ -1, -1, 1 },{ -4, -2, -2 },{ 3, -3, 3 },{ 0, 2, 1 },{ 2, -3, -2 },{ -4, -1, 3 },{ -1, -4, -4 },{ 1, 3, 1 },{ 2, -2, -3 },{ -1, 1, -1 },{ 0, -2, 1 },{ -2, 3, 3 },{ 1, -4, -4 },{ 0, -2, -2 },{ 3, 0, -1 },{ -3, -4, -4 },{ -4, 0, -3 },{ 1, -1, -1 },{ 0, 3, 2 },{ -3, -1, -1 },{ 0, -4, -2 },{ -1, 1, 1 },{ -4, 3, -1 },{ 2, -1, -3 },{ -4, 0, 2 },{ -3, -4, -1 },{ 0, -2, -4 },{ -1, -1, 3 },{ -4, 3, -3 },{ 0, 0, 2 },{ 2, -3, -3 },{ -1, 1, -1 },{ -4, -1, 1 },{ 1, 3, -4 },{ -4, -4, -2 },{ 3, 0, -4 },{ -4, 1, -3 },{ -1, 3, 1 },{ -3, -1, -4 },{ 1, 1, -2 },{ -1, -3, 2 },{ 0, -1, -4 },{ 2, 1, 0 },{ 3, -2, -4 },{ -1, -3, -1 },{ 2, -4, -4 },{ 1, 0, 3 },{ 1, 1, -1 },{ 3, 3, -3 },{ -4, 2, -2 },{ -1, -4, 2 },{ 3, -1, 1 },{ -4, 0, -4 },{ 2, -3, -2 },{ 3, -1, -1 },{ 0, 1, -3 } },
+		{ { -3, -1, 2 },{ -4, 3, -3 },{ 2, -1, -2 },{ -4, 1, -1 },{ 1, -4, 2 },{ -3, -3, 3 },{ 0, -1, -3 },{ 3, 0, 0 },{ 0, 3, 2 },{ -2, 2, 3 },{ 1, 0, -4 },{ -3, 1, 0 },{ -2, -2, -1 },{ 3, -2, -3 },{ 2, 0, 1 },{ -3, 0, -2 },{ -3, -3, 0 },{ 1, 3, 3 },{ -4, -1, -4 },{ -3, -1, -3 },{ 3, 1, 2 },{ -2, 2, -1 },{ -4, -1, 1 },{ -1, 3, 1 },{ 1, -2, 3 },{ -2, 2, 0 },{ 3, -3, 0 },{ -1, 0, -3 },{ 1, -2, 2 },{ 2, -3, 2 },{ 3, -4, 0 },{ -2, 0, 3 },{ 0, -2, -1 },{ 1, -3, 0 },{ -3, 1, 2 },{ 3, 2, -2 },{ -3, -2, 1 },{ 3, -4, -1 },{ -3, 2, 0 },{ 0, 0, 2 },{ 1, -2, -3 },{ -3, 2, -1 },{ -2, -3, 2 },{ -1, 2, 1 },{ 1, -2, 3 },{ 2, -3, 0 },{ 0, -4, -1 },{ 3, 2, 3 },{ -2, 1, -3 },{ -4, -4, 1 },{ -1, 3, -2 },{ 1, 0, 2 },{ -1, 2, 2 },{ -2, 2, -3 },{ -4, -2, 0 },{ 0, -4, 2 },{ 2, -1, 0 },{ -2, -3, 1 },{ 2, 1, -4 },{ 1, -2, -1 },{ 0, -4, 0 },{ -3, 3, 3 },{ 1, -3, 1 },{ -2, -4, 3 } },
+		{ { 3, 3, -4 },{ -1, -3, 0 },{ 0, 0, 2 },{ -3, -2, -4 },{ -2, 1, 0 },{ -1, -4, -2 },{ 1, 2, -1 },{ -3, -2, -4 },{ 2, 1, -4 },{ 3, -4, -1 },{ -4, -1, 1 },{ -1, 3, -3 },{ -2, -4, 2 },{ 1, 2, 3 },{ -1, 2, -1 },{ -4, -1, -1 },{ 3, -4, 2 },{ -2, 1, -2 },{ 3, -3, 0 },{ 1, -4, -1 },{ -1, 1, 2 },{ 2, -2, 0 },{ -2, -3, -4 },{ 1, 2, -2 },{ -2, -3, -3 },{ 2, -1, 3 },{ -3, -4, -4 },{ 2, 2, -2 },{ -4, 3, 3 },{ -2, 1, -2 },{ -3, -1, -4 },{ 1, 3, -3 },{ -1, 1, 2 },{ 3, 2, -3 },{ -2, 3, 3 },{ 2, -4, -4 },{ -1, 0, -2 },{ -2, 1, 3 },{ 2, -2, -4 },{ -1, -3, -2 },{ -3, 2, 1 },{ 3, -2, 3 },{ 0, 0, -1 },{ 2, 1, -2 },{ -3, -2, -3 },{ -2, -1, -1 },{ -4, 0, -2 },{ 2, 3, 2 },{ 0, -2, -1 },{ 3, 0, 0 },{ -4, -3, -2 },{ -3, 1, 3 },{ 2, -3, -1 },{ 3, 0, 0 },{ 0, 3, 1 },{ -3, -2, -2 },{ -1, 1, -4 },{ -4, 3, 3 },{ 0, 0, 0 },{ -2, 2, 3 },{ 3, 1, -2 },{ -1, -2, -4 },{ -4, 2, -3 },{ 2, 2, 1 } },
+		{ { -2, -4, -3 },{ -2, -2, 1 },{ 2, 1, 3 },{ 3, 2, -4 },{ 1, -1, 2 },{ -4, 0, 1 },{ 2, 3, 1 },{ -3, -2, 3 },{ -2, 1, 2 },{ 0, -3, -2 },{ 0, -3, -1 },{ 2, 0, 3 },{ 3, -2, -4 },{ -3, 1, 0 },{ 0, -3, -4 },{ -2, 3, -2 },{ 0, -2, 3 },{ 2, 0, -3 },{ -2, 2, -4 },{ 0, 0, 3 },{ -4, 3, 0 },{ 0, -4, -3 },{ 0, 0, 3 },{ 3, 0, 0 },{ -3, 2, -2 },{ 0, 1, 2 },{ -4, 1, -1 },{ 3, -2, 1 },{ 0, 0, -3 },{ 0, 2, -4 },{ 2, -4, 1 },{ -1, -2, 0 },{ -4, 0, -2 },{ 2, -3, -4 },{ -4, -1, -1 },{ 0, 0, 0 },{ 1, -3, 1 },{ -4, 3, -3 },{ 0, -1, 2 },{ 1, 0, 0 },{ 2, -4, -3 },{ -2, 3, 2 },{ -4, -4, -3 },{ 1, 0, -4 },{ -1, 3, 1 },{ -2, -4, 3 },{ 1, 1, 1 },{ -1, -2, -4 },{ -3, 2, 0 },{ 1, -1, -3 },{ 2, 2, 3 },{ 0, -2, -4 },{ -3, -4, -3 },{ -4, -1, -2 },{ -2, 2, 3 },{ 2, 0, -1 },{ -3, -4, 2 },{ 3, -2, -3 },{ -3, -3, -3 },{ 0, -1, 2 },{ -2, 3, 1 },{ -3, 0, 2 },{ 2, -2, 0 },{ 0, 0, -1 } },
+		{ { -4, 0, -2 },{ 0, 3, 1 },{ -3, -4, -2 },{ -2, 3, -1 },{ 0, -3, -2 },{ 3, -2, -3 },{ -1, 0, -1 },{ -1, -1, -3 },{ 1, -4, 0 },{ -3, 3, 1 },{ -1, 1, -3 },{ -4, 3, 1 },{ 1, -4, -2 },{ -4, 2, 2 },{ 2, 0, 1 },{ 3, -1, -3 },{ -1, 1, 2 },{ -4, 3, 0 },{ -3, -3, -1 },{ 1, -1, 1 },{ 2, 2, -2 },{ -4, -2, -3 },{ -3, 3, 3 },{ 3, -3, -1 },{ -1, -2, -4 },{ 1, -4, 1 },{ -2, 3, 2 },{ -1, -1, -1 },{ -2, -3, 0 },{ 3, -2, 0 },{ -4, 1, 2 },{ 1, 3, 3 },{ 2, -2, 1 },{ -2, -4, 1 },{ 0, 2, 3 },{ -3, -2, 0 },{ 3, 1, 2 },{ 1, -4, -2 },{ -4, 2, 3 },{ -3, -1, -1 },{ -1, 3, -4 },{ 3, -1, 0 },{ 0, 1, 3 },{ -3, -1, 0 },{ 3, 2, 2 },{ 0, -3, -2 },{ 2, 0, -4 },{ -4, -4, 3 },{ 3, -3, -2 },{ -2, 3, 2 },{ 0, -4, 1 },{ -2, 3, -1 },{ -1, -1, 1 },{ 1, 1, 2 },{ 3, -3, -3 },{ 0, -3, -4 },{ 1, 0, 1 },{ 2, 3, -1 },{ 0, 1, -2 },{ -4, -4, -1 },{ 3, 0, -3 },{ 1, -3, -4 },{ -1, -4, -1 },{ 1, 1, 3 } }
+	},
+	{
+		{ { 0, -2, 1 },{ -3, -1, 0 },{ 3, -3, 0 },{ -4, 0, -3 },{ 1, 2, 3 },{ 3, -4, -4 },{ 0, 3, 1 },{ -4, -2, 0 },{ 3, 1, -1 },{ 1, -1, 2 },{ -2, 2, 1 },{ -4, -2, 3 },{ -2, -1, -4 },{ 1, 2, 2 },{ 0, 2, -2 },{ -1, -4, 3 },{ 3, 0, 0 },{ -2, 3, 3 },{ -4, -1, -3 },{ 2, -3, 1 },{ 1, 1, -1 },{ -2, -3, 2 },{ -1, -4, -4 },{ 2, -1, -1 },{ -4, 3, 3 },{ 0, 2, -1 },{ -4, 1, 3 },{ -2, 2, 0 },{ -3, 2, -3 },{ 3, 1, 3 },{ -2, -4, 0 },{ -4, 2, -2 },{ 3, -4, 0 },{ -4, -3, 3 },{ 2, 2, -3 },{ 1, -1, -1 },{ -1, 1, 3 },{ -2, -2, 2 },{ 0, -3, -3 },{ -3, -4, 1 },{ 3, 2, -2 },{ 2, 3, 3 },{ -4, -2, -3 },{ 2, -2, 1 },{ -2, 1, -2 },{ -1, 2, -4 },{ -4, 0, 2 },{ 3, -2, -2 },{ 1, 0, -1 },{ -3, -4, 0 },{ -2, 1, -2 },{ 2, 2, 0 },{ -4, 3, 2 },{ 3, -2, -2 },{ -2, 0, 0 },{ 3, -4, -2 },{ 1, -2, 3 },{ -4, 0, 1 },{ 0, -3, -3 },{ 2, -1, -2 },{ 0, 0, -2 },{ 2, -2, 3 },{ -2, -4, -3 },{ -2, 2, -2 } },
+		{ { 1, -3, -4 },{ -2, 3, -1 },{ 2, 2, -2 },{ 0, 0, 2 },{ -1, -2, -1 },{ -4, 1, 3 },{ -1, -1, -2 },{ 2, -3, -3 },{ -2, 3, -1 },{ -4, 2, 2 },{ -1, -3, -4 },{ 3, 1, -1 },{ -3, -4, 2 },{ -1, -3, -3 },{ 3, 3, 1 },{ -4, -3, -2 },{ 2, 0, -3 },{ -1, -2, -1 },{ -2, 1, 1 },{ 3, 2, 2 },{ -3, -2, -2 },{ 2, -1, -3 },{ 3, 3, -4 },{ 0, 0, 2 },{ -2, 1, -2 },{ -1, -1, -4 },{ 2, -3, 2 },{ -1, -1, 1 },{ 1, -3, -4 },{ -3, -2, 1 },{ 2, 3, -1 },{ 0, -1, -4 },{ 0, 1, -4 },{ -3, -2, -1 },{ -2, 3, 1 },{ 0, -4, -4 },{ -4, -1, -2 },{ 2, 1, -4 },{ -1, 3, -1 },{ 1, -2, 3 },{ -4, 1, 0 },{ -1, -4, -1 },{ -1, 0, -4 },{ 3, -1, -1 },{ -3, 2, 0 },{ 2, -4, -3 },{ 1, 3, 0 },{ -2, -2, 2 },{ -1, -4, -3 },{ 0, 3, -4 },{ -2, 0, -1 },{ 1, -1, 3 },{ -3, -4, -4 },{ -1, 1, -1 },{ 0, 2, 3 },{ -3, -3, -1 },{ 2, 3, -3 },{ -1, 1, 2 },{ 3, 1, 0 },{ -2, 3, 1 },{ -4, -4, 2 },{ 3, 3, -1 },{ -4, 1, 1 },{ 3, 0, 2 } },
+		{ { -3, -1, -3 },{ -1, -4, 3 },{ -2, 2, 2 },{ 3, -4, -4 },{ -3, -3, -2 },{ 2, -1, 0 },{ -2, 1, -3 },{ 3, 0, 2 },{ -3, -4, 0 },{ 0, 0, -2 },{ 2, -2, -3 },{ 1, 3, 0 },{ 2, -1, 3 },{ -2, 1, -1 },{ 0, -2, -3 },{ -3, 1, 2 },{ 1, 3, -4 },{ -3, -4, 3 },{ 0, -2, -2 },{ 1, 0, -4 },{ 0, -4, 0 },{ -3, 1, 3 },{ -4, -1, 1 },{ 3, -4, -3 },{ 0, -3, 1 },{ -3, -2, 0 },{ 3, -4, -2 },{ 1, 3, -1 },{ -2, 0, -3 },{ -4, 2, -2 },{ 2, 0, 2 },{ -1, -3, 1 },{ 2, 0, 2 },{ -1, 1, 1 },{ 1, -2, -2 },{ 3, 2, 0 },{ -4, -3, 1 },{ 2, 3, -3 },{ -2, -4, 1 },{ 3, -1, -4 },{ -3, -3, -2 },{ 1, -2, -3 },{ -2, 1, 3 },{ 1, -3, 2 },{ 0, -3, 1 },{ 0, -1, 3 },{ -4, 0, -2 },{ -3, 1, 1 },{ 3, -1, 3 },{ -4, 2, 1 },{ 2, -3, 1 },{ 0, 1, -3 },{ -3, -2, 1 },{ 3, -3, 2 },{ 1, -1, -4 },{ -1, 1, -3 },{ -4, -4, 3 },{ -2, -2, -1 },{ 1, -1, -4 },{ 1, -4, -3 },{ -1, 1, 0 },{ -3, -3, -4 },{ -1, 2, -2 },{ 1, 1, 0 } },
+		{ { 2, -2, -4 },{ -4, 1, -1 },{ 1, -2, 1 },{ -4, -1, -3 },{ 2, 2, 0 },{ 0, 3, 1 },{ -3, -4, 3 },{ 1, 3, -4 },{ -1, -2, 1 },{ 1, -1, 3 },{ -1, -4, 1 },{ -4, 3, 0 },{ -3, -3, -2 },{ 0, 0, -1 },{ 2, -1, 3 },{ -4, -1, 0 },{ 1, -4, 1 },{ 3, 2, 0 },{ -4, 0, -3 },{ -1, 3, 1 },{ -2, -3, 3 },{ -1, 2, -2 },{ -2, 2, 0 },{ 1, 0, -1 },{ 2, 1, 3 },{ -2, 3, -4 },{ 0, 2, -1 },{ -4, 0, 2 },{ -1, -2, 0 },{ 0, -4, 2 },{ 3, -1, 3 },{ -3, -3, -3 },{ -4, -1, -1 },{ 3, 2, 3 },{ -3, 0, -2 },{ -1, -4, 3 },{ 0, -1, 2 },{ 1, 0, 2 },{ -3, 0, -1 },{ 0, 2, 3 },{ 2, 0, 0 },{ -1, 3, 2 },{ 3, 1, 1 },{ -4, 3, -4 },{ -3, 0, -2 },{ -2, 2, -4 },{ 2, -3, -1 },{ 2, 3, -3 },{ -1, -3, -2 },{ -3, -1, 0 },{ 3, -4, 2 },{ -1, 3, -2 },{ 2, 2, -2 },{ -4, -1, -1 },{ -2, 3, 1 },{ 2, -2, 1 },{ 3, 0, 0 },{ 0, -1, -2 },{ -3, 3, 2 },{ -4, 2, 3 },{ 0, -2, -1 },{ 2, -1, -3 },{ -3, -1, 3 },{ 0, -3, 1 } },
+		{ { 0, 1, 2 },{ 3, 0, -1 },{ -1, 3, -2 },{ -2, -4, 1 },{ 0, 0, 3 },{ -2, -2, -1 },{ 3, 1, -2 },{ -1, -2, 2 },{ -4, -3, -1 },{ 3, 2, -3 },{ -2, 2, -4 },{ 0, 1, 2 },{ 3, -3, -4 },{ -4, 2, -3 },{ 3, -4, 2 },{ -2, 3, -4 },{ -1, -3, -1 },{ 2, 1, -1 },{ 0, -3, 2 },{ 2, -1, -4 },{ 3, 3, -1 },{ 1, -2, -3 },{ -4, -2, 2 },{ -1, -3, -2 },{ -3, 3, 2 },{ -4, -2, -3 },{ 1, -1, 1 },{ 2, 1, 3 },{ 3, -3, -4 },{ 0, 1, -3 },{ -3, 2, 0 },{ -2, 3, -2 },{ 1, -4, -4 },{ 0, -3, -3 },{ -2, -1, 0 },{ 2, 3, -4 },{ -2, 2, -3 },{ -3, -2, -1 },{ 1, -4, -2 },{ -1, 2, -4 },{ -4, -1, 2 },{ -3, -4, -3 },{ 0, -2, -1 },{ -2, -4, -2 },{ 2, -1, 0 },{ 3, -2, 3 },{ -1, -4, 0 },{ 0, 1, -4 },{ 1, 0, 3 },{ 1, 2, -1 },{ -4, -2, -4 },{ -2, 0, 3 },{ 1, -3, 0 },{ -4, 0, -4 },{ 0, -4, 3 },{ -3, 2, -2 },{ -2, -3, -4 },{ 0, 2, 1 },{ 2, -4, -1 },{ -2, 0, -4 },{ 2, -3, 1 },{ 3, 0, 2 },{ -1, 3, -2 },{ -2, -4, 0 } },
+		{ { -4, 3, -3 },{ -3, -3, 3 },{ 2, 2, -4 },{ -3, -1, 2 },{ 1, 0, -4 },{ 1, -3, -1 },{ -4, 2, -3 },{ 0, -1, -4 },{ 2, 3, 3 },{ -3, 0, -2 },{ -3, -1, -1 },{ 0, -2, 3 },{ 1, -1, 1 },{ -1, 2, 1 },{ -3, 1, 0 },{ 1, 0, -3 },{ -2, 2, -2 },{ -4, -2, 2 },{ -3, 2, 3 },{ -2, -1, -1 },{ -4, 1, 1 },{ 0, -4, 2 },{ 3, 0, -1 },{ 2, -1, -4 },{ 0, -4, 3 },{ 3, 0, 0 },{ -2, -4, -2 },{ -3, -2, -3 },{ -3, 3, -1 },{ 1, -1, -2 },{ 2, -2, 1 },{ -1, 1, 0 },{ 1, 3, 2 },{ 3, 0, 3 },{ -4, 1, 1 },{ 2, -3, -1 },{ -1, -2, 2 },{ 3, 1, -2 },{ 2, -3, 1 },{ -2, -2, 0 },{ 1, 3, -1 },{ 3, 0, -3 },{ 2, -1, 1 },{ -1, 2, 0 },{ 1, 3, 2 },{ -4, -2, -1 },{ -3, 2, 2 },{ -2, 0, 1 },{ 3, -4, -3 },{ -3, 2, 0 },{ 0, -1, -3 },{ 0, 1, 1 },{ 3, -4, 0 },{ -2, 2, -3 },{ 1, -2, 2 },{ 2, 3, 0 },{ -1, -2, -3 },{ -4, 1, 3 },{ 3, -3, 0 },{ -1, 3, -2 },{ -3, 1, 3 },{ 1, -4, -1 },{ -4, 2, -2 },{ 1, -2, 2 } },
+		{ { 2, -1, -4 },{ -1, -3, 0 },{ 0, 1, 0 },{ 3, -4, -2 },{ -1, 3, -3 },{ -4, -3, 2 },{ -2, 2, 1 },{ 3, -4, 0 },{ -2, 1, 0 },{ 1, -3, 2 },{ 3, 1, -3 },{ -1, -4, -1 },{ 2, 3, -3 },{ -2, -2, -2 },{ 2, -3, -1 },{ 3, -1, 3 },{ 0, -3, 1 },{ 1, 0, -3 },{ 3, 3, -4 },{ -1, -4, -2 },{ 2, -3, -3 },{ -3, 2, 0 },{ -2, 0, -4 },{ 0, 2, -1 },{ -3, 1, 0 },{ 1, 2, -2 },{ -1, -3, 2 },{ 1, 3, 3 },{ -4, -4, 1 },{ -2, 2, 2 },{ 3, -2, 3 },{ -4, 0, -4 },{ -3, -3, -2 },{ -1, -2, -2 },{ 0, 3, -1 },{ 1, -4, 2 },{ -4, 1, -3 },{ -1, 3, 0 },{ -4, 0, 3 },{ 0, 2, -3 },{ 0, 1, 2 },{ -2, -3, 3 },{ -4, -3, -4 },{ 2, 1, 2 },{ 0, 1, -3 },{ 0, -3, -3 },{ 1, -2, 0 },{ -2, 1, -2 },{ -4, -1, 2 },{ 2, -3, 2 },{ -1, -3, -1 },{ -3, 3, 3 },{ 2, -1, -1 },{ -1, 1, 2 },{ -4, -3, -2 },{ 3, -1, -1 },{ 1, 0, 3 },{ -3, -4, 2 },{ 1, -1, -3 },{ -2, 0, 0 },{ -4, -2, 1 },{ -2, 3, -4 },{ 0, 1, -3 },{ 3, 0, 1 } },
+		{ { -1, -4, 3 },{ -4, 2, -3 },{ 3, -2, -1 },{ -4, 3, 3 },{ 0, 1, 1 },{ 2, -1, -1 },{ 2, 0, -4 },{ 0, -4, 3 },{ -3, 2, -2 },{ -1, -2, 1 },{ -4, -3, 2 },{ 1, 0, 0 },{ -4, 2, 2 },{ -2, -4, -4 },{ 0, -2, 3 },{ -4, 3, 2 },{ -1, 1, -3 },{ 2, -4, 0 },{ -3, -2, 1 },{ 1, 0, 2 },{ 0, 1, 3 },{ -1, -3, -2 },{ 1, 3, 2 },{ -2, -2, 3 },{ -4, -3, 1 },{ 2, 3, -3 },{ -2, 0, -4 },{ 3, 0, -1 },{ 0, 1, -4 },{ -1, 0, -1 },{ 2, -3, -3 },{ -2, -4, 1 },{ 2, 2, 1 },{ -2, -1, -4 },{ -3, 2, 0 },{ 3, -1, 3 },{ -3, -2, -4 },{ 1, 0, 0 },{ -3, -1, -4 },{ 3, -4, 1 },{ 1, -2, -1 },{ -3, 3, -2 },{ -1, 0, 1 },{ -3, -1, 3 },{ -2, -4, -2 },{ -3, 3, -4 },{ 3, -1, 3 },{ -1, 3, -1 },{ 3, -2, -2 },{ -1, 3, 1 },{ 1, 0, -4 },{ -2, 2, -2 },{ 3, -4, -4 },{ -1, -1, -3 },{ -3, 3, 0 },{ 0, 1, 1 },{ -3, -4, -4 },{ 1, 3, -1 },{ 0, 2, -2 },{ 3, 2, 2 },{ 2, -4, -3 },{ 2, -3, 0 },{ 0, -1, 0 },{ -3, -3, -1 } },
+		{ { 0, 3, 1 },{ 1, 0, 2 },{ -2, -1, -2 },{ -2, -4, 2 },{ 1, -2, -3 },{ -3, 0, 0 },{ -2, -2, -2 },{ -4, -2, 1 },{ 1, 3, -3 },{ 0, 0, -4 },{ 2, 3, -2 },{ 0, -1, -4 },{ -3, 1, 3 },{ 3, 0, -2 },{ 2, 1, 0 },{ -4, 3, -4 },{ -3, -1, -1 },{ 1, -1, 3 },{ -2, 3, 0 },{ -4, 2, -1 },{ 3, -1, -3 },{ -4, -2, 0 },{ 2, 1, 1 },{ 1, -4, -2 },{ 3, -1, -3 },{ -1, -2, 1 },{ -4, -1, 0 },{ 2, -4, 3 },{ -3, -1, 0 },{ 1, -3, -3 },{ -4, 3, 0 },{ 0, 1, -1 },{ 0, 0, 3 },{ 3, -4, 2 },{ 1, -3, -3 },{ -2, 1, -2 },{ 0, -3, 1 },{ 2, 3, -2 },{ -1, -4, -3 },{ -2, 2, 2 },{ -4, 0, -4 },{ 3, -1, 0 },{ 0, -4, -4 },{ 1, 3, 0 },{ 3, 1, -1 },{ 2, -1, 1 },{ 0, -3, 0 },{ -4, 2, -4 },{ 1, -4, 3 },{ 2, 1, -3 },{ -4, -3, 0 },{ 1, -2, 1 },{ -4, 3, 3 },{ 0, 0, 3 },{ 1, -3, -4 },{ 2, 2, 1 },{ -2, 0, -2 },{ -1, -3, 0 },{ -4, -1, -4 },{ -1, 1, 3 },{ -1, -2, -1 },{ -3, 0, 2 },{ 3, 2, 3 },{ -2, 1, -2 } },
+		{ { 2, 1, 0 },{ -3, -4, -4 },{ 3, -1, 0 },{ 1, 2, -4 },{ 2, -3, 2 },{ -1, 2, -3 },{ 3, 3, 3 },{ 1, 1, -1 },{ 3, -1, -1 },{ -3, 1, 1 },{ -2, -4, 3 },{ 3, -3, -1 },{ -2, -1, -1 },{ -1, 2, 0 },{ 1, -4, 1 },{ 3, -2, -1 },{ -1, 2, -3 },{ 0, -3, -2 },{ 3, -3, 2 },{ -2, -4, -4 },{ 2, -1, -1 },{ -1, 2, 2 },{ -3, -4, -4 },{ -1, -1, -3 },{ -3, 2, 3 },{ 0, 1, -1 },{ 1, 2, -2 },{ 0, -2, -2 },{ -2, 1, 2 },{ 3, 2, 2 },{ -3, -2, -2 },{ 2, -1, 0 },{ -4, 3, -4 },{ 1, 3, -3 },{ -3, -2, 1 },{ -4, 2, -1 },{ 0, 1, 2 },{ 3, -2, 3 },{ 2, -3, -1 },{ -3, 1, 2 },{ 0, -2, -2 },{ 2, 2, 1 },{ -1, -3, -3 },{ -2, 2, 2 },{ -4, -2, -1 },{ 0, 0, 3 },{ -1, -4, -3 },{ -3, 0, 2 },{ -3, 2, -1 },{ -2, 0, 0 },{ 0, -1, 2 },{ -2, -4, -1 },{ 2, 1, 0 },{ 0, -2, -2 },{ -4, 0, 0 },{ 3, -2, -3 },{ -4, 3, 2 },{ 3, -2, 2 },{ 2, -3, -1 },{ -3, 1, 1 },{ 1, -4, -2 },{ -4, 3, -4 },{ -1, -1, 2 },{ 1, -2, -3 } },
+		{ { -2, 2, -3 },{ -1, -3, -1 },{ -3, 3, 1 },{ -1, 0, 3 },{ -4, 1, -1 },{ 0, -4, 1 },{ -2, -1, -4 },{ -4, -3, 2 },{ -1, -4, 3 },{ -2, 0, 0 },{ 2, -2, -3 },{ 1, 3, 1 },{ -4, 1, 2 },{ 0, -3, -3 },{ 1, -1, -3 },{ -3, -4, 3 },{ -2, 0, 1 },{ -4, 2, 1 },{ 0, 1, -4 },{ -3, 0, -2 },{ 0, 3, 1 },{ 1, -2, -2 },{ -4, 1, 3 },{ 0, 0, -1 },{ 3, -3, 0 },{ -2, 3, 2 },{ -3, -4, -4 },{ 2, -3, 1 },{ -4, 3, -3 },{ -1, 0, -4 },{ -1, -2, 3 },{ 0, -4, 2 },{ -2, -3, -1 },{ -1, -1, -1 },{ 2, 0, 3 },{ -1, -4, 0 },{ -2, 0, -4 },{ -4, 2, 1 },{ 1, -1, -3 },{ -1, 3, 0 },{ 1, -3, 3 },{ -2, -1, -1 },{ -4, 0, 3 },{ 1, -2, -3 },{ 2, -4, -2 },{ -4, 2, 2 },{ 1, 1, -4 },{ 2, -3, 1 },{ 3, -2, -2 },{ 0, -2, 3 },{ 3, 3, -3 },{ -3, 2, -2 },{ -1, 2, -4 },{ -2, 1, 2 },{ 1, -4, -1 },{ -2, -1, 3 },{ -1, -4, -1 },{ 0, 1, -3 },{ 1, 3, -2 },{ -2, 0, -4 },{ 3, 2, 0 },{ 0, -3, -3 },{ 2, -4, -1 },{ -4, -2, 3 } },
+		{ { 1, -3, 2 },{ -1, 1, 2 },{ 2, -1, -2 },{ 0, -2, 0 },{ 3, 3, -3 },{ -3, -3, 1 },{ 1, 1, -2 },{ 2, 3, 0 },{ 3, 0, -4 },{ 0, 2, 0 },{ -4, 2, -2 },{ -1, -1, -4 },{ 3, -2, 1 },{ -3, 3, -2 },{ -2, 0, 3 },{ 2, 3, -4 },{ 2, 1, -1 },{ 3, -2, 2 },{ 1, -1, 0 },{ 2, -3, 3 },{ -2, 0, 3 },{ 3, -4, -3 },{ -2, 3, 1 },{ 2, 1, -2 },{ -4, -2, 2 },{ -1, 0, -4 },{ -4, 0, 3 },{ 3, -1, 0 },{ 0, 2, -1 },{ 1, -4, 1 },{ 2, 1, -2 },{ 3, 0, -4 },{ -3, 2, 1 },{ 1, -2, -3 },{ 3, 1, 2 },{ 2, 3, -4 },{ -3, -3, -2 },{ 0, -2, -3 },{ -2, 0, -1 },{ -3, 0, -4 },{ 3, -4, 1 },{ 2, 1, -4 },{ -3, 3, 1 },{ 3, 1, 2 },{ -2, -1, -4 },{ -1, 3, 0 },{ 3, -1, 0 },{ -1, 3, -3 },{ -4, -4, -1 },{ -1, 0, -4 },{ 1, -3, 1 },{ -3, -1, 3 },{ 2, -3, -3 },{ 3, -1, 1 },{ -1, 3, -2 },{ -3, 1, -4 },{ 2, 2, 0 },{ -3, -1, 3 },{ -4, 0, 1 },{ 2, -2, 2 },{ -2, -2, 3 },{ -1, 1, 1 },{ -3, 3, -2 },{ 3, 0, -4 } },
+		{ { 3, -4, 1 },{ 2, 2, -2 },{ -4, -4, -1 },{ -2, 2, -4 },{ 3, -2, 0 },{ -3, 0, 3 },{ -1, -1, -1 },{ 0, -2, 2 },{ -3, -3, -3 },{ 0, -4, -2 },{ -2, -2, 2 },{ 1, -3, 3 },{ -3, 1, -1 },{ 2, -4, -4 },{ 0, 1, 2 },{ -2, -2, 0 },{ -4, -3, -2 },{ -1, 3, -2 },{ -3, -4, -3 },{ -2, 3, 0 },{ -4, 2, -1 },{ 2, -2, 0 },{ -3, -3, -4 },{ 0, 3, -3 },{ 3, -4, -1 },{ 1, -2, -2 },{ -1, 1, 1 },{ 1, 3, -3 },{ -2, -2, -1 },{ -3, -3, 3 },{ -4, 3, 0 },{ -2, 0, -2 },{ 1, 1, 3 },{ 0, -4, 2 },{ -2, -1, -2 },{ -4, -3, 0 },{ 2, 1, 3 },{ 3, -4, 2 },{ -1, 2, 1 },{ 2, -3, 3 },{ -4, 1, -2 },{ -2, 3, 0 },{ -1, -2, -2 },{ 0, -4, -1 },{ 1, 2, 3 },{ -3, -2, -1 },{ -2, -3, -2 },{ 2, 2, 3 },{ -3, 1, 1 },{ -2, 3, -2 },{ 2, 1, 0 },{ -4, 0, 2 },{ 1, -4, 0 },{ -1, -2, -2 },{ -4, -3, 2 },{ 3, 2, 1 },{ 0, -3, -3 },{ 1, -4, 0 },{ -1, 3, -4 },{ 0, -1, -2 },{ -4, -3, -1 },{ 1, 0, 3 },{ 0, -1, 1 },{ -4, 2, 0 } },
+		{ { -2, 3, 3 },{ -3, 0, -3 },{ 0, -2, 1 },{ 1, 1, 3 },{ -2, 0, -3 },{ 2, -4, 2 },{ -4, 2, -4 },{ 1, 0, -2 },{ -1, 3, 3 },{ -4, 1, 1 },{ 3, -1, -1 },{ -1, 2, 2 },{ 2, 3, -2 },{ -4, 0, 0 },{ 3, -2, -1 },{ -1, 2, 2 },{ 1, -3, -3 },{ 0, 1, 1 },{ 3, 0, 2 },{ -1, -1, -3 },{ 1, -3, -2 },{ 0, 1, 2 },{ -1, -1, 1 },{ 1, -1, 3 },{ -2, -3, 1 },{ -3, 2, -3 },{ 0, -4, 0 },{ 3, -1, 3 },{ -4, -1, -2 },{ -1, 1, -4 },{ 2, -2, 2 },{ 3, -3, -1 },{ -3, -1, 1 },{ -4, 3, -4 },{ -1, 2, -1 },{ 1, 0, 0 },{ -1, 3, 2 },{ -4, -1, -2 },{ -2, 2, -1 },{ 0, -2, 0 },{ 0, -1, -3 },{ 2, -4, 3 },{ 1, -1, 0 },{ -4, -3, -3 },{ 3, 0, 2 },{ 0, -4, 1 },{ -4, -1, -4 },{ 1, 0, 2 },{ 3, -3, 2 },{ 0, -4, -4 },{ -2, -2, -2 },{ 2, 3, -1 },{ 0, 1, 1 },{ -3, 0, -4 },{ 1, 3, 3 },{ 2, 0, -1 },{ -2, -2, -3 },{ -4, -1, 2 },{ 3, 2, -2 },{ 0, -4, 0 },{ 3, 3, -4 },{ -3, 2, -3 },{ 1, -1, -2 },{ -1, -2, -4 } },
+		{ { 0, -1, -2 },{ -4, 1, 2 },{ 2, -3, -4 },{ -1, 3, -1 },{ -4, -3, 1 },{ 1, 1, -2 },{ 3, 3, 1 },{ -2, -1, 0 },{ 2, -4, -3 },{ 1, 1, -4 },{ 2, 0, 0 },{ -3, -3, -4 },{ 0, -2, -3 },{ -2, -4, 1 },{ 1, -1, 3 },{ -4, 1, -4 },{ 2, -1, 0 },{ -2, -2, 3 },{ -3, 2, -1 },{ 2, -4, -4 },{ 2, 1, 2 },{ -4, 2, -4 },{ -2, 0, -1 },{ 3, 2, -3 },{ -4, 1, 3 },{ 2, 0, -2 },{ -2, 3, -4 },{ 2, -3, 2 },{ 0, 0, 1 },{ 1, 2, 2 },{ -1, 3, -3 },{ 0, -4, -3 },{ -1, 1, 0 },{ 2, -3, -3 },{ 3, -3, 1 },{ -3, -2, -3 },{ 0, -4, -4 },{ 2, 1, -1 },{ 1, -2, -4 },{ 3, 3, 2 },{ -4, 1, -4 },{ -2, -2, 1 },{ 2, 2, -2 },{ -2, 1, 0 },{ -3, 3, -3 },{ -1, 1, 1 },{ 2, -2, -1 },{ 0, 3, -3 },{ -4, 2, 0 },{ 0, -2, -1 },{ -3, -1, 3 },{ 3, 2, -3 },{ -2, -4, -4 },{ -1, -1, 2 },{ 0, -2, -3 },{ -3, -4, 0 },{ -2, 2, 2 },{ 2, 1, -1 },{ -3, -3, 3 },{ -1, 1, 1 },{ -2, -2, 2 },{ 2, -3, -1 },{ -2, -4, 2 },{ 2, -3, 0 } },
+		{ { 1, 3, 0 },{ -2, -4, 3 },{ 1, 2, -1 },{ 3, -1, 0 },{ -3, -1, -3 },{ 0, -2, -4 },{ -1, -4, 2 },{ -3, 0, -1 },{ 0, -3, 3 },{ -4, -2, 1 },{ -1, 3, 2 },{ -2, -1, -1 },{ 0, 1, 3 },{ 3, -3, 1 },{ -3, 2, -3 },{ -2, 3, -2 },{ 3, -4, 1 },{ 1, 0, -4 },{ -4, 0, 0 },{ -1, 3, 1 },{ -2, -2, 3 },{ 3, -4, -2 },{ -3, 3, 0 },{ 0, -4, -1 },{ 1, 0, 1 },{ -1, -2, 2 },{ -4, -4, 0 },{ -3, 2, -4 },{ 1, 1, -2 },{ -3, -4, -1 },{ 2, -1, 0 },{ -4, 2, 3 },{ -2, 0, -2 },{ 2, -1, 3 },{ 0, 1, 1 },{ -2, 3, 3 },{ -3, -1, 0 },{ -4, 0, 3 },{ -1, -3, 0 },{ -3, -4, 2 },{ 1, 0, -2 },{ -3, 2, -1 },{ 3, -3, 2 },{ -1, -1, -4 },{ 1, 0, 3 },{ 3, -2, -2 },{ -3, 2, 0 },{ -1, -4, 3 },{ -2, -1, -3 },{ 3, 0, 2 },{ 1, 2, 1 },{ -1, -3, 3 },{ -4, 0, -1 },{ 2, 1, -1 },{ 3, 3, 0 },{ -1, 1, 3 },{ 1, -4, -4 },{ 3, -2, 1 },{ 0, 3, -2 },{ 1, -1, -3 },{ -4, 0, 0 },{ -1, 2, 3 },{ -4, 1, -4 },{ 3, 0, 1 } },
+		{ { -1, 2, -3 },{ -4, -2, -4 },{ 3, 0, -2 },{ -2, -4, 2 },{ -1, 2, 3 },{ 2, -2, -2 },{ -2, 1, 3 },{ -3, 3, -3 },{ 1, -2, 0 },{ 3, 2, -2 },{ -2, -4, -3 },{ -4, 0, 0 },{ 2, 3, -2 },{ -1, 0, -4 },{ 1, -4, -1 },{ -3, 0, 0 },{ -1, -3, -1 },{ 0, 3, 2 },{ -3, -3, -2 },{ 0, -1, -1 },{ 1, -2, 3 },{ -1, -1, -3 },{ 2, -3, 2 },{ -3, -2, -4 },{ 3, -3, -4 },{ -1, 2, 0 },{ 0, -1, 1 },{ 3, -2, -1 },{ -2, 0, -3 },{ -4, -2, 3 },{ 3, -3, -4 },{ 1, 0, -1 },{ -3, -2, 2 },{ -1, 3, -1 },{ -4, 1, -4 },{ 3, -4, -2 },{ 2, 2, -2 },{ 1, -3, 1 },{ 3, 3, -3 },{ -1, -1, -1 },{ -2, 2, 3 },{ 2, -4, 1 },{ 0, 0, -3 },{ -4, 3, 2 },{ 0, -4, -2 },{ -4, -3, 1 },{ 2, 1, -4 },{ 3, 0, 0 },{ -3, -3, -2 },{ -4, 0, -4 },{ -1, -4, 0 },{ 2, -3, -2 },{ -3, 3, 1 },{ 1, -1, -3 },{ -4, -3, 3 },{ -3, -1, -2 },{ 0, -2, -4 },{ -4, 0, -3 },{ -1, 2, 3 },{ -2, -4, -2 },{ 3, 1, -4 },{ 2, -2, 1 },{ 0, 3, -1 },{ -3, -1, -3 } },
+		{ { 2, -4, 0 },{ 0, 1, 1 },{ -2, -2, 3 },{ 1, 3, -3 },{ -4, 1, 0 },{ 1, -3, 1 },{ 2, 2, -1 },{ 3, 0, -4 },{ -1, -3, -2 },{ 0, 3, 3 },{ 2, -1, -1 },{ 1, -4, -3 },{ 3, -2, 2 },{ -4, 2, 2 },{ 2, -2, 3 },{ -1, 3, -3 },{ 1, -1, 3 },{ -4, 1, -3 },{ 2, -3, -1 },{ 3, 2, -3 },{ -3, 3, 1 },{ -4, 1, -3 },{ 1, 1, 0 },{ -1, 3, 3 },{ -3, 0, -1 },{ 2, 3, -3 },{ 2, 1, -2 },{ -2, -4, 3 },{ -1, 1, 1 },{ 1, 3, 0 },{ 0, 1, 1 },{ -2, -2, -2 },{ 3, 2, -4 },{ 0, -4, 0 },{ 1, -1, 2 },{ -1, -2, -3 },{ -2, 0, 2 },{ 2, 1, -1 },{ -3, -2, -4 },{ 0, 1, 0 },{ 1, 3, -3 },{ -1, -3, -4 },{ -3, 1, 0 },{ 2, -2, 0 },{ 1, -1, -1 },{ -2, 2, 3 },{ -3, -2, -4 },{ 0, 3, 1 },{ 1, 1, 2 },{ 1, 2, -1 },{ -2, 3, -4 },{ 0, 1, 2 },{ -2, -2, -3 },{ 3, -4, 1 },{ -2, 1, -1 },{ 2, 3, 2 },{ 2, 2, 0 },{ -3, 2, 0 },{ 1, -3, 1 },{ 1, -1, 2 },{ -3, -4, -1 },{ -1, 0, 2 },{ 1, -3, -2 },{ -2, -2, 3 } },
+		{ { 2, 3, 2 },{ -3, -1, -2 },{ -3, -3, 1 },{ 0, 2, -1 },{ 0, 0, -4 },{ -4, -4, -2 },{ -2, -3, 2 },{ -4, 1, 1 },{ 2, -1, 2 },{ -3, 1, -4 },{ -3, -1, 3 },{ -1, 2, 1 },{ -3, 1, 0 },{ 0, -1, -4 },{ 1, -3, -1 },{ -2, 0, 0 },{ 2, -4, 2 },{ 3, -2, -4 },{ -1, 1, 1 },{ -2, -4, 2 },{ 0, 0, 0 },{ 3, -4, -4 },{ 0, 2, 1 },{ -2, -1, -2 },{ -4, -4, 2 },{ 0, 0, 3 },{ -3, -3, -1 },{ -4, -2, 2 },{ 0, 3, -4 },{ 3, -1, -3 },{ -3, -4, -1 },{ -1, 2, 3 },{ 2, -3, 2 },{ -4, 0, -3 },{ -3, 1, 1 },{ -1, -1, -1 },{ -4, -3, -4 },{ 0, 3, 2 },{ -3, -4, 3 },{ 3, -1, -2 },{ -4, -2, 2 },{ 3, -2, 1 },{ -4, 0, -1 },{ -2, 2, 3 },{ 3, 0, -3 },{ 1, 3, 2 },{ -2, -3, -1 },{ 0, -1, -2 },{ -1, -4, 3 },{ -4, -2, -3 },{ 3, -2, 1 },{ 2, -1, -1 },{ -3, 0, 0 },{ 0, 2, -4 },{ 1, -1, -3 },{ -1, -3, -2 },{ 0, -4, 2 },{ -2, 0, -1 },{ 3, -3, -3 },{ -4, 3, -4 },{ 2, 1, 0 },{ -3, 3, -3 },{ 0, -4, 0 },{ -4, 0, -4 } },
+		{ { 3, 1, -1 },{ 1, -3, -2 },{ 2, 1, -4 },{ 3, -2, 0 },{ -1, -1, 3 },{ 3, 3, 1 },{ -2, -1, -3 },{ 1, -4, 0 },{ 0, -2, -2 },{ -4, 1, 0 },{ -1, -3, -4 },{ 3, -2, 1 },{ -2, 0, -3 },{ -3, -4, -2 },{ -1, 1, 1 },{ -4, 1, -2 },{ 0, 2, 1 },{ -3, 0, -2 },{ -2, 2, 3 },{ -4, -1, -2 },{ 2, -2, -1 },{ -2, 0, 3 },{ 2, -3, -2 },{ 1, 1, 0 },{ 3, -2, 0 },{ 1, -1, -3 },{ -2, 2, 1 },{ 2, 2, -4 },{ 1, -3, 0 },{ -4, -3, -2 },{ 1, -1, 2 },{ -4, 0, 1 },{ -1, 3, -3 },{ 1, -3, -1 },{ 3, 2, 0 },{ 3, 3, 3 },{ 0, -4, -2 },{ 1, 2, 0 },{ -1, 0, 1 },{ 0, -3, -3 },{ -2, 2, 0 },{ 1, 1, 3 },{ -1, -4, -4 },{ -3, -4, -2 },{ 2, -1, -4 },{ -1, 1, 1 },{ -4, -4, -3 },{ 2, 0, 0 },{ 3, 2, 0 },{ -2, -1, 3 },{ 2, -4, -2 },{ -3, 1, 2 },{ 0, 2, 2 },{ -4, -3, 3 },{ 2, 0, 0 },{ -4, 1, 1 },{ -3, -2, -4 },{ 3, 0, 3 },{ -2, -1, 1 },{ 0, 1, -1 },{ -1, -2, 3 },{ -2, -1, 2 },{ 3, 2, -3 },{ -1, -1, 3 } },
+		{ { -4, -4, 0 },{ -1, -1, -3 },{ -4, 2, 2 },{ -2, -4, 2 },{ -3, -2, -3 },{ -1, 1, -1 },{ 0, 2, -4 },{ 3, 3, 3 },{ -1, 0, 1 },{ 2, -4, -2 },{ 0, 3, -1 },{ 1, -3, 2 },{ 1, 3, -2 },{ 2, 2, 3 },{ 3, -2, 3 },{ -2, 3, -4 },{ 2, -3, 0 },{ 1, -4, -1 },{ 3, 3, -4 },{ 1, 1, 0 },{ -1, -3, -3 },{ -3, 3, 2 },{ -1, -2, -4 },{ -4, 2, -3 },{ -1, 3, 2 },{ 0, -4, -2 },{ -1, 1, 3 },{ 3, -2, -1 },{ -3, 0, 1 },{ -1, 1, 3 },{ 2, 2, -2 },{ 3, -4, -4 },{ -2, 0, 1 },{ -2, -2, -2 },{ 1, -3, 3 },{ -4, 0, -4 },{ -2, -1, -1 },{ 2, -2, -3 },{ -3, 1, 2 },{ -4, 3, -4 },{ 3, -1, -1 },{ 2, 0, -2 },{ 0, 3, 2 },{ 0, -2, 1 },{ -4, 3, 0 },{ 3, -3, 3 },{ 0, 2, 2 },{ -3, -1, -4 },{ -1, 3, -3 },{ 1, 1, 1 },{ -4, -3, -4 },{ 0, 3, -2 },{ -1, -4, -4 },{ -2, -2, -2 },{ 3, 3, 3 },{ -1, -2, 0 },{ 1, 1, -3 },{ 0, 3, -2 },{ -4, 2, 2 },{ 1, -4, -2 },{ 2, 0, 1 },{ -3, 2, -1 },{ 1, -3, -2 },{ 0, 3, 1 } },
+		{ { -2, -2, -4 },{ -2, 3, 3 },{ 0, 0, 0 },{ 1, 0, -2 },{ 2, 3, 1 },{ 2, -4, -2 },{ -4, 0, -1 },{ -3, -3, 2 },{ -2, 2, -3 },{ 3, 2, 0 },{ -4, 1, 3 },{ -2, -1, -3 },{ -4, 0, 0 },{ 0, -3, -1 },{ -1, -1, -4 },{ -4, -4, 2 },{ 0, 0, -1 },{ -3, -2, 3 },{ -1, -1, -3 },{ -4, -2, 2 },{ 3, 2, 1 },{ 0, 1, -1 },{ 3, -1, 1 },{ -3, -3, 3 },{ 2, 0, -4 },{ -3, -3, 0 },{ -4, 1, -3 },{ -1, -1, 1 },{ -3, -4, 2 },{ 1, 3, -4 },{ -2, -1, -3 },{ 0, -2, 0 },{ -3, 3, 2 },{ 2, 1, -4 },{ -1, -4, -3 },{ 0, 1, 2 },{ -3, 2, 1 },{ 3, -3, -1 },{ 1, 0, 0 },{ -2, -3, 3 },{ -1, -4, -3 },{ -3, -3, 0 },{ -2, 1, 1 },{ 2, -3, -1 },{ 1, 2, -3 },{ -1, -4, -2 },{ -3, 0, 2 },{ 2, -2, -2 },{ -4, -3, -1 },{ 0, -3, 2 },{ 1, 1, 0 },{ -1, 0, 3 },{ 3, -1, 0 },{ 1, -4, -1 },{ 1, -1, -3 },{ -2, 2, -1 },{ -3, -4, 2 },{ 2, -2, -1 },{ -1, -1, 0 },{ -2, -4, -4 },{ 3, -3, -3 },{ -3, -1, -4 },{ -4, -3, -1 },{ 2, 0, 1 } },
+		{ { 3, 1, -2 },{ 1, -3, 3 },{ 3, 2, -3 },{ -4, -4, -1 },{ -3, 1, 2 },{ -1, -3, 3 },{ 0, -2, 0 },{ 1, -1, -1 },{ -3, -2, -4 },{ 1, -3, 2 },{ 2, 0, -2 },{ -1, -4, -3 },{ 0, 2, 2 },{ -3, -2, 0 },{ 3, 1, -3 },{ 1, -1, 1 },{ 3, 3, -3 },{ -3, 2, 2 },{ 2, -4, 1 },{ -1, 1, -3 },{ -2, -4, 3 },{ 1, 0, -2 },{ -2, -4, -2 },{ 0, 0, -1 },{ 2, 3, 1 },{ -2, -1, -4 },{ 3, -4, -1 },{ 2, 2, -3 },{ 0, -2, -2 },{ 2, 0, -1 },{ -4, -3, 0 },{ 3, 1, 3 },{ -1, -1, -1 },{ 2, -1, 1 },{ -4, 3, 0 },{ 0, 0, -2 },{ 2, -4, 3 },{ -1, -2, -4 },{ -4, 2, 2 },{ 0, 2, -2 },{ 2, -1, 2 },{ -4, 3, -1 },{ -1, 1, -4 },{ 3, -1, -3 },{ -4, 0, 3 },{ -2, 3, 0 },{ 0, -1, -4 },{ 3, 0, 1 },{ 2, 3, 3 },{ -2, 2, -2 },{ -3, -2, -3 },{ 2, 0, 1 },{ -3, 3, -3 },{ -4, 1, 2 },{ -3, 2, -4 },{ 0, -3, 1 },{ 3, 0, 3 },{ -3, -3, -3 },{ 1, 1, -2 },{ -4, 2, 3 },{ 0, 3, 2 },{ 2, 0, 2 },{ 0, 1, 0 },{ -1, 2, 2 } },
+		{ { -3, -4, -1 },{ -3, -2, 0 },{ -1, -2, -4 },{ 0, -1, 1 },{ 2, -1, -4 },{ -3, 3, -4 },{ 3, 2, 2 },{ 2, 1, -3 },{ -2, -4, 1 },{ 0, -1, -1 },{ -4, 1, -1 },{ 3, -2, 1 },{ 2, 3, -4 },{ -2, -4, 1 },{ -4, 2, -2 },{ 0, 1, 0 },{ -2, -3, -4 },{ 1, 0, 0 },{ 2, -3, -2 },{ 0, 1, -1 },{ -4, -1, -1 },{ 2, 3, -4 },{ -4, -2, 3 },{ 0, -4, 0 },{ -2, 2, 2 },{ 1, -2, 3 },{ -4, 3, 2 },{ 1, -3, 0 },{ 0, 2, 3 },{ -2, -4, 1 },{ -3, -2, -3 },{ 0, 2, 2 },{ -4, -4, -2 },{ 1, -3, -1 },{ -2, -3, 2 },{ 3, 2, -3 },{ -2, -1, 0 },{ -3, 3, 3 },{ 1, -4, -3 },{ -1, -2, 0 },{ 3, 0, -4 },{ 1, -2, 1 },{ -2, -4, 3 },{ -3, 0, 2 },{ 3, -3, -4 },{ 0, 1, -1 },{ -4, -2, 1 },{ 1, -4, -3 },{ -2, 2, -1 },{ 3, -1, 3 },{ -4, -4, -4 },{ 1, -3, 0 },{ 2, 2, -1 },{ 0, -3, 1 },{ -1, 1, 3 },{ 2, -4, -2 },{ -4, 3, 0 },{ -1, 1, -4 },{ 3, -1, 2 },{ -2, 2, 0 },{ -3, -2, -1 },{ 1, -2, -3 },{ -2, -4, 3 },{ 1, -1, -4 } },
+		{ { 2, 3, -3 },{ 0, 2, 1 },{ -4, 1, 0 },{ 2, 3, 2 },{ -2, 0, -2 },{ 1, -3, 0 },{ -1, 0, 1 },{ -4, -4, -2 },{ 3, 3, 3 },{ -1, 3, 2 },{ -3, -3, -4 },{ -2, -1, 0 },{ 1, 2, 3 },{ 3, 0, -1 },{ -2, -4, 2 },{ 2, -2, 3 },{ -1, -2, -1 },{ -4, 2, -2 },{ -2, -1, 3 },{ 0, 3, -4 },{ -3, -3, 0 },{ -1, -1, 2 },{ 3, 2, 1 },{ -3, 1, -3 },{ 1, -2, -2 },{ 3, 0, -1 },{ -1, 1, -4 },{ -2, -1, -2 },{ -4, 3, -4 },{ 3, 0, 2 },{ 2, 1, -2 },{ 0, 3, -4 },{ -1, 0, 3 },{ 3, 2, -4 },{ -3, 0, 3 },{ 1, 1, -1 },{ -3, -2, -2 },{ 1, 0, -3 },{ 3, 1, -1 },{ -2, -3, 1 },{ -3, 1, 0 },{ 2, 2, -3 },{ 0, 3, -1 },{ 1, -2, 1 },{ 2, -3, -2 },{ -1, 3, 0 },{ 1, 1, 3 },{ -4, -1, -2 },{ -1, -3, 0 },{ 0, 1, -4 },{ -1, -1, 2 },{ 0, 3, -2 },{ -2, -2, 3 },{ 3, -1, -4 },{ -4, 0, 0 },{ 1, -1, -3 },{ 2, -2, -1 },{ -2, 0, 1 },{ 0, -3, -2 },{ 1, 0, 1 },{ 3, -4, -3 },{ -1, 3, 0 },{ 3, -1, 1 },{ -4, 2, -2 } },
+		{ { -2, -3, -1 },{ -1, 0, 3 },{ 3, -4, -2 },{ 1, -2, 3 },{ -1, -4, -3 },{ -3, 2, -1 },{ -2, 0, 3 },{ 0, -2, -4 },{ -4, -1, -3 },{ 1, 2, 0 },{ 2, 0, -2 },{ 0, -2, 3 },{ -4, -3, -3 },{ 0, -1, -2 },{ -1, 0, -3 },{ -3, 3, 0 },{ 1, 2, -3 },{ -3, -4, 1 },{ 3, 0, 2 },{ 2, -2, 1 },{ 3, 2, -3 },{ 1, 1, 2 },{ -2, -3, -4 },{ 2, 2, -1 },{ -4, -4, -3 },{ -3, 0, 3 },{ 0, -4, 1 },{ -3, -2, -1 },{ 2, -1, 1 },{ -1, 1, 0 },{ -2, -3, 0 },{ 1, -2, -1 },{ -3, -1, 0 },{ 0, -2, 1 },{ 2, 3, -3 },{ -1, -2, 1 },{ -4, -4, 1 },{ 2, -1, -4 },{ 0, 3, 2 },{ -4, 0, -2 },{ -1, -3, 3 },{ 1, -1, -2 },{ -4, -4, -3 },{ -3, 2, 2 },{ -1, 0, -2 },{ -3, -1, 3 },{ 3, 2, -3 },{ -2, -4, 2 },{ -3, 3, -2 },{ 2, 1, -1 },{ 3, -3, 1 },{ -4, 1, 1 },{ -2, -4, -2 },{ -1, -4, -2 },{ 3, 3, 2 },{ -2, 2, 0 },{ -3, 2, -4 },{ 0, -4, 3 },{ -4, 3, -3 },{ -3, -3, 3 },{ -1, 1, -4 },{ -3, -3, -2 },{ -4, 0, -1 },{ 2, 0, 2 } },
+		{ { 0, -3, -4 },{ -2, 1, 0 },{ -3, -1, -1 },{ -4, 2, -3 },{ 3, 1, 1 },{ 2, -3, 2 },{ 2, -1, -2 },{ -1, 2, 0 },{ 3, -3, -1 },{ -2, 1, 2 },{ 2, -4, -3 },{ -1, 2, 1 },{ -3, 1, -1 },{ 1, 3, 2 },{ -4, -3, -4 },{ 3, 0, 1 },{ 2, -2, 3 },{ 0, 3, -4 },{ -1, -4, -3 },{ -4, -1, -1 },{ -1, 0, 3 },{ 0, -4, -2 },{ -3, -2, -1 },{ 0, -1, 0 },{ -1, 3, 1 },{ 0, -3, 2 },{ 2, 3, -4 },{ 3, 1, -2 },{ -4, -4, 3 },{ 1, -3, -3 },{ -4, -1, -3 },{ 3, 2, 2 },{ -2, -4, 1 },{ -4, -1, -3 },{ 3, -4, -2 },{ -2, 1, -4 },{ 0, -3, 2 },{ -1, 2, 3 },{ -2, -2, -1 },{ 3, -4, -4 },{ 0, 3, 2 },{ -3, -2, -1 },{ 3, 1, 3 },{ 2, 2, -4 },{ -2, -1, 1 },{ 0, -4, -1 },{ 2, -3, -4 },{ 1, 0, 1 },{ 2, -2, 2 },{ -2, 0, -4 },{ -3, -2, 3 },{ 1, 3, -3 },{ 1, 2, -1 },{ -3, 1, 3 },{ 1, 0, -3 },{ -4, -3, 2 },{ 0, -4, 2 },{ 3, -1, -1 },{ 2, -1, -1 },{ 1, 2, 0 },{ 2, 0, -1 },{ -1, 3, 2 },{ 0, 2, 3 },{ 1, -2, 1 } },
+		{ { -3, -2, -4 },{ 1, 3, 2 },{ 2, 0, -3 },{ 0, -3, 2 },{ -4, 1, -2 },{ -2, 3, -4 },{ 1, -2, 2 },{ -3, 3, -2 },{ -2, -4, 1 },{ 1, 0, 3 },{ -4, -3, -4 },{ 3, 3, 1 },{ -2, -4, -2 },{ 3, -2, 0 },{ -2, -1, 2 },{ 0, 1, -1 },{ -4, -3, -1 },{ -2, -1, -2 },{ -2, 1, 0 },{ 1, 3, 0 },{ -3, -2, -2 },{ -4, 3, 2 },{ 2, 0, 0 },{ 3, 2, 3 },{ -4, -1, -4 },{ 2, -3, -1 },{ -2, 0, 0 },{ 1, 2, -2 },{ -1, 0, 3 },{ 2, 2, 1 },{ 0, 3, -4 },{ -1, 1, -2 },{ 2, -3, 3 },{ 1, 2, -1 },{ 0, 3, 2 },{ -3, 0, -1 },{ 2, 2, 0 },{ -3, 3, -3 },{ 2, -1, 1 },{ -4, 0, 0 },{ 1, 1, -3 },{ -2, -1, 1 },{ 3, -3, -4 },{ -1, -4, 0 },{ 1, -2, 2 },{ -4, 3, -3 },{ -2, 1, 0 },{ 0, -1, -3 },{ -1, 2, 3 },{ -4, -4, -2 },{ 0, -3, 0 },{ 3, -1, 1 },{ 2, 0, -4 },{ -2, -3, -1 },{ 0, -2, 0 },{ 2, 1, -2 },{ -1, 0, 1 },{ -1, 3, -3 },{ -2, 1, -4 },{ -2, -2, 1 },{ -4, -4, 3 },{ 2, -1, -4 },{ -2, -4, -3 },{ 3, 2, 0 } },
+		{ { -1, -1, 1 },{ -4, -4, 3 },{ 3, 3, -1 },{ -1, -1, 1 },{ 1, -4, -4 },{ -3, -1, 0 },{ 0, -4, 1 },{ -1, 0, -3 },{ 2, 1, -1 },{ -3, 3, -4 },{ -1, -2, -2 },{ -1, -1, 0 },{ 0, 2, 3 },{ 2, 0, -4 },{ -3, 2, -3 },{ -1, -4, -2 },{ 1, 2, 2 },{ 2, -2, 1 },{ 3, 1, 3 },{ -1, -4, -4 },{ 3, 2, 1 },{ 0, -3, -4 },{ -2, 1, -3 },{ 1, -4, 2 },{ -1, 2, -2 },{ -4, -2, 3 },{ -2, 1, -3 },{ -3, -3, 2 },{ -1, -2, 0 },{ -2, -2, -4 },{ -3, -4, 1 },{ 3, 0, 0 },{ -3, 1, -2 },{ -1, -3, -4 },{ -4, 0, 3 },{ 3, -4, -2 },{ -1, -3, 3 },{ 1, 0, -2 },{ -3, -3, -1 },{ 3, -4, -4 },{ -1, 2, 3 },{ -3, 2, 0 },{ -1, 0, -2 },{ -4, 3, -1 },{ 1, 1, 2 },{ -3, 2, -2 },{ 3, -2, 3 },{ -4, -3, 0 },{ 1, 2, -1 },{ 3, 3, -3 },{ -1, 1, -3 },{ -3, -2, 0 },{ -1, -1, 2 },{ -4, 2, 3 },{ 3, -3, -3 },{ -3, 3, -4 },{ 2, -2, 0 },{ -4, -3, 3 },{ 3, 1, -2 },{ 0, -3, 2 },{ 1, -1, -2 },{ 3, 1, 0 },{ -2, -2, -2 },{ -4, 1, -2 } },
+		{ { 1, -3, -3 },{ -2, 2, -1 },{ 0, 0, -4 },{ -1, -2, 0 },{ -3, 2, 3 },{ 1, 1, -1 },{ 3, -3, 3 },{ -4, 2, -3 },{ 0, -2, 2 },{ 1, -1, 0 },{ 3, 1, 3 },{ -4, -3, -3 },{ 1, 0, -1 },{ -4, -3, 2 },{ 0, -4, 3 },{ 3, 1, 0 },{ -3, 0, -4 },{ -3, -3, -3 },{ 0, 0, 2 },{ 2, -3, -3 },{ -2, 0, 1 },{ -3, -1, -1 },{ 3, -3, 1 },{ -3, -2, -2 },{ 1, 1, -3 },{ 0, -4, 0 },{ 3, -1, 1 },{ 2, 3, -4 },{ 0, 0, -1 },{ 3, 3, 2 },{ -4, -1, -1 },{ 1, 2, -3 },{ -3, -2, 2 },{ 2, 3, 1 },{ 0, -2, -4 },{ 1, -1, 1 },{ -4, 1, 0 },{ -2, -2, -3 },{ 0, 1, 3 },{ -3, 3, 2 },{ 1, -3, -2 },{ 2, -2, -4 },{ 0, -2, 3 },{ 0, -3, 0 },{ 3, 0, -3 },{ -1, -3, 1 },{ 2, -4, -2 },{ 0, 0, -4 },{ -3, -1, 1 },{ 1, -3, 2 },{ -2, 0, -1 },{ 0, 2, 3 },{ 2, -4, -4 },{ 0, 3, -2 },{ -2, -1, 1 },{ -4, 0, -1 },{ 1, -1, 2 },{ 1, -4, -1 },{ -3, 2, 1 },{ -1, 3, -4 },{ -3, -4, -1 },{ -4, 3, 2 },{ 0, -3, 1 },{ 2, 2, 3 } },
+		{ { -3, -2, 2 },{ 3, -4, 0 },{ -3, -1, -2 },{ 2, 1, 2 },{ -2, -2, -3 },{ 3, 3, -2 },{ 2, 0, 1 },{ -4, -3, -3 },{ 1, 2, 0 },{ -2, -3, -2 },{ 2, -4, 1 },{ -2, 2, -2 },{ 1, 3, 1 },{ -3, -1, -4 },{ 2, 1, -3 },{ -1, 3, 0 },{ 1, -2, -1 },{ -2, 3, 2 },{ -4, 2, 0 },{ 0, -1, -1 },{ -4, 3, 3 },{ -1, -2, -3 },{ 2, 2, 3 },{ -4, 0, 0 },{ -2, 3, 2 },{ 1, 3, -4 },{ -3, -3, -1 },{ -1, 1, 2 },{ -4, -4, -2 },{ 2, 1, 3 },{ -2, -3, -2 },{ 0, -4, 0 },{ -1, -1, 3 },{ 3, -4, -1 },{ -1, 1, 0 },{ -2, 2, -2 },{ 2, 3, -4 },{ 3, -4, 1 },{ -1, -1, -1 },{ 3, 1, 0 },{ -4, 0, -3 },{ 2, -4, 1 },{ -2, 1, 2 },{ -4, -1, -2 },{ 1, 2, -1 },{ -3, 3, -4 },{ -1, -1, 3 },{ -2, 1, -1 },{ 3, 3, 2 },{ -4, -4, -4 },{ 2, -2, 3 },{ -2, 0, -2 },{ -3, 2, 1 },{ 1, -4, 0 },{ 3, 1, 2 },{ 0, 3, -3 },{ -2, 2, -4 },{ -1, 0, 2 },{ 3, -2, -3 },{ 2, 0, 0 },{ 1, -2, -3 },{ -1, 0, 3 },{ 3, 0, -4 },{ 0, 3, -1 } },
+		{ { -4, 1, 3 },{ 2, 0, -4 },{ -1, 3, -2 },{ 3, -3, 3 },{ -4, -1, 1 },{ -1, -4, -1 },{ -1, 2, -4 },{ -2, 0, 2 },{ -3, -1, 3 },{ 0, 3, -4 },{ -4, 1, -1 },{ -1, 0, 2 },{ 3, -2, 0 },{ -2, -4, -1 },{ -2, -1, 3 },{ -4, -1, 1 },{ 3, -2, -2 },{ 1, 1, -3 },{ -2, -4, -2 },{ 3, -2, -4 },{ 1, -4, -2 },{ 1, 1, 2 },{ -1, 1, -1 },{ 2, -4, -4 },{ 0, -2, 1 },{ -1, 0, 1 },{ 3, -3, 3 },{ -4, -1, 0 },{ 1, -2, -3 },{ 0, 2, 1 },{ -2, 3, -4 },{ 3, 0, 2 },{ -4, 3, -3 },{ -2, 2, -3 },{ -3, -2, 1 },{ 1, -3, 3 },{ -3, -3, 2 },{ 0, 0, -3 },{ -4, -2, 1 },{ 0, 2, 2 },{ -2, -3, -2 },{ -1, 3, 3 },{ 3, -1, -1 },{ -3, 3, -4 },{ -2, 1, 3 },{ 2, -2, 1 },{ -4, -4, 0 },{ 2, 2, -3 },{ -1, -2, -2 },{ 0, -1, 0 },{ 3, 3, 1 },{ -3, -3, -1 },{ 3, 1, -3 },{ -4, -2, -4 },{ -1, -3, 3 },{ 2, -2, -1 },{ -3, -4, 0 },{ -1, -3, 3 },{ -4, 1, -2 },{ -3, -1, 3 },{ -2, 2, 1 },{ 2, -3, 0 },{ -3, -4, -3 },{ 1, -1, -1 } },
+		{ { -2, -3, -3 },{ 0, 2, 0 },{ -4, -3, 2 },{ 0, 2, -4 },{ 1, 0, -3 },{ -3, 1, 0 },{ 2, -1, 3 },{ 0, -4, -2 },{ 2, -2, -1 },{ 3, 0, -3 },{ 0, -2, 3 },{ -3, -3, -4 },{ 2, 3, -2 },{ -1, 1, 1 },{ 1, 2, -1 },{ 0, -3, -4 },{ -3, -4, 3 },{ 0, 1, 1 },{ 3, 2, 3 },{ -3, -1, 1 },{ -1, 3, 2 },{ -4, 0, -4 },{ -2, -3, -2 },{ 0, -1, -1 },{ -3, 2, -3 },{ 1, 2, -2 },{ 2, 0, -2 },{ -2, 2, -3 },{ 2, 1, -1 },{ -1, -4, 1 },{ -3, 0, -1 },{ 1, -2, -4 },{ 0, -3, 3 },{ 2, -1, 1 },{ -4, 0, -4 },{ 0, 1, -1 },{ 3, 3, -2 },{ -2, 0, -1 },{ -3, 3, 3 },{ 1, 1, -4 },{ 2, -4, -4 },{ -3, 2, -1 },{ 0, -2, 0 },{ 2, -4, -3 },{ 1, -3, -1 },{ 0, 0, 1 },{ 3, -1, -2 },{ -2, 1, 2 },{ 1, -3, 3 },{ -1, 1, -3 },{ -4, 2, -4 },{ -1, -1, 2 },{ 0, 0, -1 },{ -2, -1, 1 },{ 1, -1, 0 },{ -2, 0, -2 },{ 3, 1, -4 },{ 0, 3, 0 },{ 1, -3, 1 },{ 3, -4, -4 },{ 0, 3, -1 },{ -4, 1, -2 },{ -1, -1, -4 },{ -2, 2, 1 } },
+		{ { 3, -4, -2 },{ 1, 0, 3 },{ -2, -2, -1 },{ 1, -4, 1 },{ 0, 3, 2 },{ -3, -3, -2 },{ 3, -2, 1 },{ -4, 3, 0 },{ 1, 1, 1 },{ -1, -4, 2 },{ -3, 2, 0 },{ 1, 1, 1 },{ -4, -1, 3 },{ 3, -3, -3 },{ -3, 0, -3 },{ 2, 2, 2 },{ -4, 3, -2 },{ 2, 0, -1 },{ -1, -3, -3 },{ 0, -3, 0 },{ -3, 0, 0 },{ 2, -2, 1 },{ 3, 3, 0 },{ -3, -4, 2 },{ 3, -1, 3 },{ -4, -2, 1 },{ -3, -3, -4 },{ 0, -2, 2 },{ -3, 3, 0 },{ 3, -2, 2 },{ -2, -1, 3 },{ -1, 2, -2 },{ 3, -4, -1 },{ -3, 3, 0 },{ 2, 1, -2 },{ -1, -1, 2 },{ 1, -4, 0 },{ 2, -2, -4 },{ -1, -4, 0 },{ 3, -1, -2 },{ -3, -3, 1 },{ 0, 0, 0 },{ 3, 1, 1 },{ -1, -3, 2 },{ -4, 0, 3 },{ -2, 2, -3 },{ -1, -2, -1 },{ -4, 3, -4 },{ 3, 0, 0 },{ -3, -3, 0 },{ 1, 3, -2 },{ 2, -4, 1 },{ 1, -4, 3 },{ 3, 3, -2 },{ -3, 2, 2 },{ -4, 3, 1 },{ 2, -4, 2 },{ 1, 0, -2 },{ -4, -1, -1 },{ -2, 3, -3 },{ 0, -2, 2 },{ 2, -3, 2 },{ 3, 1, 3 },{ 1, -2, 1 } },
+		{ { 2, 3, 2 },{ -3, 2, -4 },{ -3, 0, -1 },{ 3, 1, -3 },{ -2, -1, 0 },{ 2, 3, -3 },{ -1, 0, -4 },{ 1, 1, -1 },{ -3, -3, -2 },{ -2, 0, -3 },{ 2, 2, -2 },{ 0, -1, -4 },{ -2, -4, 2 },{ 0, 0, -2 },{ -1, -2, 0 },{ 1, 1, 3 },{ -3, -2, 0 },{ -2, -1, -4 },{ 1, -2, 2 },{ -4, 2, -3 },{ 3, -1, -3 },{ 0, -2, -2 },{ 1, 2, 3 },{ -2, 1, -4 },{ 2, 1, -1 },{ -1, -4, 0 },{ 0, 3, -1 },{ -1, 1, 3 },{ 1, -4, -2 },{ -4, 0, -4 },{ 2, -3, -3 },{ 1, 1, -2 },{ -4, 1, 1 },{ 1, -4, 3 },{ 0, -2, -4 },{ -2, 2, -3 },{ -4, -1, 3 },{ -4, 2, 1 },{ 1, 1, 0 },{ -1, -1, 2 },{ -4, -2, -3 },{ -2, 1, 3 },{ 1, 3, -2 },{ -4, -1, -4 },{ 2, 3, -2 },{ 0, -4, 0 },{ -3, 1, 1 },{ 1, -3, 3 },{ 2, -4, -1 },{ 0, 2, 1 },{ -2, -1, 3 },{ -4, -2, 0 },{ -3, 2, -4 },{ -2, 1, -3 },{ 0, -2, -4 },{ 0, -3, -1 },{ -2, -1, 3 },{ -1, 2, -4 },{ -3, -2, 1 },{ 3, 1, 1 },{ -3, 0, 0 },{ -1, -4, -2 },{ -3, 3, -1 },{ -4, 0, -3 } },
+		{ { 0, -4, -3 },{ -1, -1, 0 },{ 2, -2, 1 },{ -1, -4, 3 },{ -4, -2, -2 },{ 3, -3, 2 },{ -4, 2, 3 },{ -1, -1, -4 },{ 2, -3, 3 },{ -4, 3, 2 },{ 3, -4, 0 },{ -1, -2, 3 },{ 3, 2, -1 },{ -2, 3, 1 },{ -4, -3, -3 },{ -1, -4, 0 },{ 3, 2, -4 },{ 0, -4, -1 },{ -4, 3, 2 },{ 2, 1, -1 },{ -1, 1, 3 },{ -2, -4, -4 },{ -4, -3, -1 },{ -1, 0, -3 },{ 1, 3, 2 },{ -2, -1, -4 },{ 3, -3, 2 },{ -4, 1, -3 },{ 2, -1, 1 },{ -3, 2, -1 },{ 0, 3, 1 },{ -1, -2, 2 },{ -3, 2, 0 },{ 3, 0, -3 },{ -2, -3, 0 },{ 3, 3, 2 },{ 0, -4, -1 },{ -3, 1, -3 },{ 0, 0, -4 },{ 2, 3, -1 },{ 0, 2, 2 },{ 3, -4, -3 },{ -3, -1, -4 },{ -1, -3, 2 },{ -2, 1, 0 },{ 3, -1, 3 },{ 2, -2, -3 },{ -2, 2, -4 },{ -1, -1, -1 },{ -3, 0, -3 },{ 3, 1, -4 },{ -1, -3, -2 },{ 1, 0, 0 },{ -1, -3, 3 },{ 3, -4, -1 },{ 2, 0, 0 },{ -1, -2, -3 },{ 3, 1, 0 },{ 2, -4, -3 },{ -2, -3, 3 },{ 1, 2, -4 },{ 2, -1, -4 },{ -2, 1, 0 },{ -1, -3, 2 } },
+		{ { 3, -2, -2 },{ -2, 1, 1 },{ -4, 2, -4 },{ 0, 3, -3 },{ 0, 0, -1 },{ -2, 2, 1 },{ 1, -4, 0 },{ -2, -1, -3 },{ -3, -2, 0 },{ 1, 1, 1 },{ 0, -1, -1 },{ -4, 0, -2 },{ -3, 3, -4 },{ 1, 1, 1 },{ 2, -1, -2 },{ -2, 2, 2 },{ 0, -1, 1 },{ 3, 0, -2 },{ -2, -3, 3 },{ -3, 2, 1 },{ 1, -4, 0 },{ 1, 3, 1 },{ -4, 0, 2 },{ 3, -1, 0 },{ -3, -2, 1 },{ 2, 2, -2 },{ -4, -4, -1 },{ 3, 0, 2 },{ 0, -3, -2 },{ -2, -1, -1 },{ 3, -2, 3 },{ -4, -1, -4 },{ -2, -4, -3 },{ -1, 0, 2 },{ 2, -2, -1 },{ -3, 2, 3 },{ 1, -3, 1 },{ -2, -2, -2 },{ 3, -3, 3 },{ -4, -4, 1 },{ -1, 2, -2 },{ 2, -2, 0 },{ 0, -3, -1 },{ 1, 2, 1 },{ 2, 0, -1 },{ -3, -4, -3 },{ -1, 3, 1 },{ -4, 0, 2 },{ 3, 3, -2 },{ -4, -4, 2 },{ 0, -2, 2 },{ 2, 3, -1 },{ 2, -1, 1 },{ -4, 2, 2 },{ -2, 3, -3 },{ -3, 0, 2 },{ -4, 3, 3 },{ -3, -1, -2 },{ 0, 2, 2 },{ -4, 3, -2 },{ 1, -4, 3 },{ 3, 0, 1 },{ -4, -2, -1 },{ 1, 2, 3 } },
+		{ { -2, 0, -3 },{ 2, -3, -1 },{ 1, 3, 3 },{ 3, -3, -1 },{ -1, -1, 2 },{ -3, 1, -4 },{ 3, -2, -1 },{ 2, 3, 3 },{ 0, -4, -1 },{ -2, 2, -3 },{ 2, -3, -4 },{ -2, -2, 2 },{ 2, -4, 0 },{ 3, -2, 3 },{ -4, -3, -4 },{ 1, 1, -1 },{ -3, 3, -3 },{ -1, -2, 2 },{ 2, 0, -3 },{ 0, -2, -4 },{ -1, 0, -2 },{ 2, -1, -1 },{ -2, 2, -3 },{ 2, -3, 3 },{ 0, -4, -2 },{ -3, 3, 3 },{ -2, 0, -3 },{ 1, -2, 0 },{ -2, 3, -4 },{ -1, -4, 3 },{ 1, 1, 0 },{ 2, 2, 1 },{ 1, -3, -2 },{ 0, 3, -2 },{ -4, 1, 0 },{ 1, -1, -4 },{ 2, 0, -2 },{ -1, 3, -1 },{ 2, 1, 2 },{ -2, -2, -4 },{ -3, 0, -2 },{ -2, 0, 1 },{ 3, -1, 2 },{ -4, 3, 3 },{ -1, 1, -4 },{ 0, -3, -2 },{ 1, -2, 3 },{ -2, -3, 0 },{ 0, 1, 0 },{ 1, -2, -3 },{ -2, 2, 3 },{ 0, 1, -2 },{ -3, -4, -4 },{ 0, 1, 1 },{ 3, -1, -1 },{ 1, -3, -4 },{ 2, 1, 1 },{ 1, -4, -4 },{ -2, -1, -1 },{ -1, -2, -1 },{ -3, 0, -3 },{ -1, 1, 0 },{ 0, -4, -4 },{ -3, 3, 3 } },
+		{ { -1, -1, 0 },{ -4, -4, 2 },{ -2, -2, -3 },{ 2, 0, 0 },{ -3, 1, -2 },{ 1, -3, 1 },{ 0, 2, 1 },{ -4, 0, -4 },{ 3, 1, -2 },{ -3, 3, 1 },{ 1, 0, 3 },{ -3, 1, -1 },{ 0, 2, -3 },{ -1, 0, 2 },{ -2, -4, -1 },{ 0, -2, 3 },{ 3, 0, 1 },{ -4, -4, 0 },{ -1, 2, -2 },{ -4, -1, 3 },{ 3, -4, 2 },{ -3, -2, 1 },{ 0, 2, -4 },{ 1, 0, -1 },{ -1, 1, -4 },{ -1, -1, 1 },{ 0, 1, 0 },{ 1, 2, 2 },{ -4, 2, -4 },{ 2, -4, 1 },{ -3, 1, -3 },{ -3, 0, -1 },{ 3, -4, 2 },{ -2, -1, 1 },{ 3, 1, 3 },{ -1, -4, -4 },{ -3, -3, 0 },{ -4, 0, 2 },{ 3, -1, -3 },{ 1, 3, 0 },{ 1, -4, 3 },{ -4, 1, -4 },{ -1, -2, -3 },{ -3, -4, -2 },{ -2, -2, 0 },{ 1, 0, 1 },{ -4, 2, -3 },{ 3, 1, -1 },{ 2, -1, -4 },{ 2, -4, 1 },{ -2, 2, 0 },{ -4, 0, -3 },{ 3, -3, 3 },{ -2, -2, -3 },{ -4, -2, -1 },{ -1, -4, -2 },{ -2, 3, 0 },{ 0, -3, 1 },{ 3, 1, 2 },{ 2, -3, 0 },{ 0, 3, -2 },{ -4, -3, 2 },{ 3, -1, -2 },{ 1, 2, -1 } },
+		{ { -3, 1, -4 },{ 0, 3, 1 },{ 0, 1, 2 },{ -4, -4, -2 },{ -1, -1, 3 },{ 2, 3, -3 },{ -4, -4, 2 },{ -2, -1, -2 },{ -1, -3, 3 },{ 1, -1, 2 },{ -1, -4, -1 },{ -4, -2, -4 },{ 0, -1, -2 },{ 3, 3, 0 },{ -4, 2, -3 },{ 2, 0, -2 },{ -2, 3, -4 },{ 1, 1, 0 },{ 1, -3, -3 },{ 2, 3, -1 },{ -3, 2, 0 },{ -1, 1, -3 },{ 3, -3, 3 },{ -4, 3, -2 },{ -2, -4, 2 },{ 2, -1, -3 },{ 3, -3, -1 },{ -3, -2, 2 },{ 0, -1, -3 },{ -2, 0, 0 },{ 0, -2, -2 },{ -1, 3, 3 },{ 0, 2, -4 },{ -4, -3, -1 },{ -3, -2, -3 },{ -1, 3, 1 },{ 3, -2, -1 },{ 0, 2, 3 },{ -1, -1, -2 },{ -3, -3, 2 },{ 0, 2, -1 },{ 3, -1, 1 },{ 2, 2, 0 },{ 0, 3, -4 },{ 3, -1, 2 },{ 2, -4, 0 },{ -3, 3, -2 },{ -1, -2, 3 },{ -3, 3, -3 },{ -4, 0, 2 },{ -1, -2, -1 },{ 1, -3, 0 },{ 1, 3, 1 },{ 2, 1, 0 },{ 0, 2, 2 },{ 3, 0, 3 },{ 0, -2, -3 },{ -4, 0, -3 },{ -2, 2, 3 },{ -3, -2, -4 },{ 1, 0, -3 },{ 2, 3, 1 },{ -2, -2, 2 },{ 2, -3, 0 } },
+		{ { 1, 2, -2 },{ 2, -2, -4 },{ 3, -2, -1 },{ -2, 0, 1 },{ 2, 2, -4 },{ -3, -2, 0 },{ -1, -3, -1 },{ 3, 0, 0 },{ 2, 2, -4 },{ -2, -2, 0 },{ 3, 3, -3 },{ 2, 2, 1 },{ -3, 1, 2 },{ 1, -3, 3 },{ -3, -3, 0 },{ -1, -1, 2 },{ -3, -4, 2 },{ 3, -2, 1 },{ -2, -1, 3 },{ 0, 1, 1 },{ -2, -1, -4 },{ 0, -4, -2 },{ 1, 0, 2 },{ -3, -2, 1 },{ 3, -2, 0 },{ -4, 2, -4 },{ -3, -4, 1 },{ -1, 1, -2 },{ 3, -3, 3 },{ 2, 3, -1 },{ -4, -3, 1 },{ 3, -2, -3 },{ 2, 0, 0 },{ 0, -1, 2 },{ 2, 1, -2 },{ 1, 0, 2 },{ 0, 3, -1 },{ -2, -4, -3 },{ -4, 1, -4 },{ 2, -2, 0 },{ -1, -4, -3 },{ -3, 3, -2 },{ -1, -3, 3 },{ -2, -1, -1 },{ -4, 1, 2 },{ 0, 1, -3 },{ -1, -3, -1 },{ -2, -4, 1 },{ 1, 0, 2 },{ 0, -3, -4 },{ 3, 3, -2 },{ -3, -1, 3 },{ -1, 0, -3 },{ -2, 2, -2 },{ -3, -4, -4 },{ -4, 0, 2 },{ -1, 3, 0 },{ 2, -1, -1 },{ 1, -4, -2 },{ -3, 2, 1 },{ -1, -4, 3 },{ -2, -1, -1 },{ -1, 1, -3 },{ -4, -4, 3 } },
+		{ { -1, -3, 2 },{ -3, -1, -2 },{ -4, 2, 3 },{ -1, 3, -3 },{ 3, -3, -1 },{ 1, 1, 2 },{ 0, 3, -3 },{ 0, -1, 1 },{ -4, 2, -4 },{ 1, -3, 2 },{ -4, 0, -2 },{ 0, -3, 1 },{ -2, 0, -4 },{ 3, -4, -2 },{ -1, 2, -4 },{ 1, 0, -1 },{ 2, 2, -2 },{ -3, -3, -4 },{ -4, 3, -1 },{ 1, -4, -4 },{ 2, 2, 3 },{ -4, -3, 0 },{ 2, -1, -1 },{ -2, 3, -3 },{ 0, 2, 3 },{ 1, 0, -2 },{ -1, 3, 3 },{ -4, 3, -3 },{ 1, -1, 0 },{ -1, 2, -4 },{ -2, 0, 2 },{ 1, -1, 1 },{ -4, 2, -1 },{ -2, -4, -3 },{ -1, 2, 3 },{ -4, -2, -4 },{ -3, -3, 0 },{ 2, 1, 1 },{ 3, -3, 3 },{ 1, 2, -1 },{ -3, 0, 2 },{ 0, 0, 3 },{ 2, -2, -3 },{ 1, -4, 1 },{ -3, 2, -3 },{ 1, 0, 3 },{ 3, -1, -4 },{ -4, 2, -2 },{ 3, -1, 0 },{ 2, 1, 2 },{ -2, -2, -1 },{ -4, 2, -4 },{ 2, -4, 1 },{ 1, -2, -1 },{ 0, -1, -1 },{ 2, -3, -4 },{ -2, 1, 1 },{ 3, -3, 2 },{ -4, -1, -1 },{ 0, 1, 1 },{ 3, 0, 0 },{ -4, 2, -2 },{ 1, 3, -4 },{ 3, 0, 0 } },
+		{ { 2, 3, 1 },{ -1, 0, -3 },{ 1, -4, 0 },{ -3, 0, -3 },{ 1, -3, 1 },{ -3, -1, 3 },{ -4, -4, -2 },{ 1, 0, 3 },{ -3, -4, -1 },{ -1, 1, 1 },{ -1, -1, 3 },{ -2, -2, -3 },{ 2, 1, -1 },{ -4, -2, 2 },{ 0, 3, 1 },{ -4, -2, -3 },{ 0, 0, 0 },{ -1, 3, 3 },{ 0, -2, -2 },{ 3, 0, 2 },{ -3, -2, -3 },{ -1, 3, 2 },{ 3, 1, 1 },{ -2, -4, -4 },{ -3, -1, -1 },{ 3, -3, 2 },{ 0, -2, -1 },{ 2, 0, -4 },{ -2, 1, 2 },{ -3, -3, 0 },{ 2, -4, -3 },{ -1, 1, 3 },{ -3, -4, -4 },{ 3, 3, 1 },{ 2, -3, 0 },{ 1, 0, -3 },{ -2, -1, -2 },{ -2, 3, 2 },{ 0, 0, -4 },{ -4, -4, -2 },{ -2, -2, -3 },{ 2, 1, 0 },{ -4, 1, -1 },{ 3, 3, 1 },{ -1, -3, -2 },{ 0, -2, -4 },{ -3, -3, 1 },{ 1, 2, 3 },{ -3, 1, -3 },{ 0, -3, -2 },{ -3, 1, 1 },{ -1, -4, 3 },{ 3, 3, -3 },{ -4, 1, 2 },{ -1, -1, 3 },{ 3, 3, 0 },{ -3, -4, -3 },{ 1, 1, -4 },{ -1, 3, 2 },{ -1, -2, -3 },{ 2, -3, -4 },{ 1, -4, 3 },{ -3, -1, 2 },{ 0, -2, -1 } },
+		{ { -4, -1, 3 },{ 2, -4, 0 },{ -2, 2, 2 },{ 0, -2, -1 },{ 3, 1, 0 },{ -2, 2, -4 },{ -2, 3, -2 },{ 2, -2, 0 },{ 3, -2, -3 },{ 0, 3, -2 },{ 2, -4, -1 },{ 3, 3, 0 },{ -3, 2, 0 },{ 1, 1, 3 },{ 3, -1, -1 },{ -2, -4, 3 },{ 3, 1, 0 },{ -2, -3, 2 },{ 2, 1, 1 },{ -2, -1, -1 },{ -1, 2, 0 },{ -4, 0, -2 },{ 1, -2, -2 },{ 0, -3, 3 },{ -1, 1, -3 },{ 2, 1, 0 },{ -2, -4, 1 },{ -4, -1, 0 },{ 3, -4, 1 },{ 0, 2, -2 },{ -4, -1, -1 },{ 1, 3, -2 },{ 0, -2, -1 },{ -2, -1, 2 },{ -3, 2, 3 },{ 0, -4, 1 },{ 3, 1, -1 },{ -1, -3, 2 },{ 2, -1, 0 },{ 1, 2, 1 },{ 3, 3, -4 },{ 0, -3, 3 },{ -3, -1, -4 },{ -1, -4, -1 },{ -2, 0, 2 },{ 2, 1, 0 },{ -2, 3, 2 },{ 2, -2, -1 },{ -1, -4, 0 },{ -2, 3, 2 },{ 1, -3, -3 },{ 0, -1, 0 },{ 2, -2, -1 },{ 0, 0, 1 },{ -3, -3, -3 },{ 1, 2, -2 },{ -4, -2, 3 },{ 0, -2, -2 },{ -3, 0, 3 },{ -2, 3, -2 },{ 2, -2, 0 },{ -3, 1, 1 },{ -1, 1, -2 },{ -2, -3, -3 } },
+		{ { -3, 2, -4 },{ 3, 1, -2 },{ 0, -2, -4 },{ -4, 3, 3 },{ 2, -1, -3 },{ 2, -2, 1 },{ -4, 1, 3 },{ 0, -3, -4 },{ -1, 2, 0 },{ -3, 1, 3 },{ -4, -1, -4 },{ 1, -2, 2 },{ -1, -3, -4 },{ -1, -3, -2 },{ -3, 0, -3 },{ 1, 2, -4 },{ -3, -4, -2 },{ -4, -1, -4 },{ 1, 1, -3 },{ -3, -4, -3 },{ 3, -4, 3 },{ 1, -1, -4 },{ 2, 2, 1 },{ -3, -1, 0 },{ -4, 3, -2 },{ -1, 0, 3 },{ 1, 2, -3 },{ -3, -2, -4 },{ 1, 1, -2 },{ -1, 3, 3 },{ 2, -2, 1 },{ 3, 0, 2 },{ -1, -3, -4 },{ 2, -1, -3 },{ 1, 1, -1 },{ 3, -2, -2 },{ -3, 0, -4 },{ 0, 2, 3 },{ -4, -2, -3 },{ -3, 1, 0 },{ -2, -4, -2 },{ -1, -1, 1 },{ 1, 2, 2 },{ -4, 3, -3 },{ 3, 1, -2 },{ -3, -1, 3 },{ 2, -4, -1 },{ 0, 0, -4 },{ -4, 0, 1 },{ 3, 2, -4 },{ 2, 0, 3 },{ -4, 2, 0 },{ -2, 3, -2 },{ -2, 1, -4 },{ 1, -4, 0 },{ 3, 2, -1 },{ -1, -1, 1 },{ 2, 2, -4 },{ 1, -4, 0 },{ 3, 2, -1 },{ -4, -3, 2 },{ 0, 2, -4 },{ 3, -2, -1 },{ 1, 3, 2 } },
+		{ { -2, -1, -2 },{ 0, -3, -1 },{ 1, 1, 1 },{ -3, -3, 2 },{ -1, 0, -2 },{ -1, -4, -1 },{ 1, 0, 1 },{ -3, -1, 2 },{ 3, -4, -1 },{ -2, -3, 1 },{ 0, 0, 2 },{ -3, 3, -3 },{ 0, 0, 1 },{ 2, -4, 1 },{ -2, 3, 2 },{ 2, -1, 2 },{ 0, -2, 1 },{ 3, 3, -1 },{ 2, 2, 2 },{ 0, 0, 3 },{ -4, 3, -1 },{ -2, -3, 0 },{ 0, 2, -3 },{ 3, -1, 2 },{ 1, -2, 1 },{ 2, -4, -4 },{ -3, 3, 2 },{ 3, -1, -1 },{ -2, -3, 3 },{ 2, 1, -3 },{ -3, -4, -4 },{ -4, 0, 0 },{ -2, 2, 3 },{ -3, 3, 0 },{ -4, 0, -4 },{ -1, 3, 2 },{ -4, -4, 0 },{ 1, -1, -2 },{ 3, -3, 1 },{ -1, 3, -1 },{ 2, 0, 3 },{ -4, -3, -3 },{ 2, -2, -1 },{ 1, -3, 1 },{ 0, -2, 0 },{ -4, 2, -4 },{ -1, -3, 1 },{ 1, 3, -3 },{ -2, -1, 3 },{ -3, -2, -2 },{ 3, -4, -1 },{ -1, -2, -4 },{ -3, -3, 2 },{ 3, -1, 3 },{ -1, -2, 2 },{ -4, 0, -3 },{ -2, -3, 1 },{ 0, 0, 2 },{ -4, -3, -3 },{ -2, -1, 1 },{ 0, 0, -3 },{ -1, 1, 3 },{ -4, 0, 0 },{ 1, -4, 1 } },
+		{ { 2, 3, 2 },{ -1, -2, -3 },{ -4, 2, 0 },{ -2, -4, 3 },{ 3, -1, -4 },{ -3, 2, 0 },{ 0, 3, -3 },{ 1, 1, -3 },{ -4, 3, -1 },{ 2, 2, -2 },{ 1, -1, -4 },{ 3, -4, -2 },{ -4, -1, 3 },{ 2, 2, -2 },{ -4, -2, 0 },{ 0, 2, -2 },{ -1, 0, -3 },{ -3, -3, 3 },{ -4, -3, 0 },{ 0, -2, -4 },{ 2, 1, -2 },{ -1, 1, 1 },{ -3, -3, -1 },{ -2, -4, 2 },{ -4, 1, -1 },{ 0, 2, -2 },{ -2, -3, -1 },{ -1, 0, 2 },{ -4, 2, 1 },{ 0, -2, -2 },{ -2, -1, 1 },{ 1, -4, -2 },{ 3, 1, -1 },{ 0, -3, 3 },{ 2, -4, -2 },{ -1, -2, 1 },{ 1, 1, -3 },{ -2, 3, 3 },{ -2, -2, -4 },{ 1, 0, -2 },{ 0, -4, 2 },{ -1, 2, -3 },{ 3, 0, 0 },{ -3, 3, 3 },{ -2, -4, -2 },{ 1, 1, -3 },{ 3, -2, 2 },{ -4, 1, -1 },{ 0, -4, 0 },{ 1, 3, 1 },{ 0, 1, 2 },{ -4, 0, -1 },{ 1, -3, -3 },{ 0, 2, 1 },{ -2, 3, -1 },{ 1, 1, -4 },{ 3, -4, 3 },{ -3, 3, -2 },{ 2, 1, -1 },{ 3, 3, 3 },{ -3, -2, -2 },{ 2, -3, 2 },{ 3, -4, -3 },{ -2, -1, 1 } },
+		{ { 2, 0, -4 },{ -3, -1, 3 },{ 3, 3, -3 },{ 2, 0, -1 },{ 1, 2, -2 },{ -4, -3, 3 },{ 3, -2, 2 },{ -2, -4, -4 },{ -1, 0, 3 },{ 2, -3, 2 },{ -3, 1, 1 },{ -2, -2, 0 },{ -1, 2, -1 },{ 3, 1, -4 },{ -2, -2, -1 },{ 1, -3, 0 },{ 3, 1, -4 },{ -2, -1, 1 },{ -1, 2, -2 },{ -2, 0, 1 },{ 3, -4, 0 },{ -4, -2, 3 },{ 1, 0, -3 },{ 3, 3, -4 },{ 0, -2, -3 },{ -3, 1, 3 },{ 2, -1, 0 },{ 3, -4, -4 },{ 1, 3, -3 },{ -1, 0, 0 },{ 3, 2, 3 },{ 0, 3, -1 },{ -3, -2, 2 },{ -1, 1, -3 },{ 3, -2, 0 },{ -2, 2, -1 },{ 2, 0, 1 },{ -3, -4, -1 },{ 2, -1, 0 },{ 0, 2, 1 },{ -4, -1, 2 },{ -3, 3, -4 },{ 2, 1, 1 },{ -1, -1, -4 },{ 0, 0, 3 },{ -3, 2, 0 },{ 1, -3, -2 },{ -1, -1, 3 },{ 3, 2, -4 },{ -2, -2, -3 },{ -1, 3, -1 },{ 2, -1, -3 },{ 3, 2, 3 },{ -3, 0, -2 },{ 2, -4, 0 },{ -3, -1, -3 },{ -4, 0, 2 },{ 0, -2, 0 },{ -1, -1, 0 },{ 1, -4, -4 },{ -3, 3, 0 },{ -2, 2, -4 },{ 0, 1, -2 },{ -4, 2, 0 } },
+		{ { -3, -4, 2 },{ 0, -2, -2 },{ 0, -4, 0 },{ -2, -1, 1 },{ 0, 1, -4 },{ -2, 1, -1 },{ 2, -1, 1 },{ -1, -2, 0 },{ -3, 0, -1 },{ 0, -2, -2 },{ -1, -4, -4 },{ 1, 3, 3 },{ -3, -1, 2 },{ 0, -4, -3 },{ -2, 0, 3 },{ -4, 3, 1 },{ 2, -4, -1 },{ -3, 3, 3 },{ 1, -4, -3 },{ 2, 2, 2 },{ -1, -1, -3 },{ 0, 3, -2 },{ 2, -1, 2 },{ -1, 2, 1 },{ -1, 0, 0 },{ -2, -3, 1 },{ 1, -1, -3 },{ -4, 2, 1 },{ -3, -3, 2 },{ 2, -2, -1 },{ -4, 1, -4 },{ 1, -1, -3 },{ -2, -3, 1 },{ 1, 0, -2 },{ -3, 2, -4 },{ -4, -1, 2 },{ 3, -3, 3 },{ -1, 2, -3 },{ 0, 1, -4 },{ -4, -4, 3 },{ 3, -3, -2 },{ -2, -2, 0 },{ 1, -3, -1 },{ -4, -4, -2 },{ 3, -2, -1 },{ 2, 0, 1 },{ -2, 3, -4 },{ -3, -3, 2 },{ 2, -4, -2 },{ -4, 0, 0 },{ -3, -3, 3 },{ 0, -4, 1 },{ -2, 1, 0 },{ -4, -2, -4 },{ 0, -3, 3 },{ 2, 3, -1 },{ 1, 2, 2 },{ 3, -2, -2 },{ -1, 2, -3 },{ -4, -3, 1 },{ 0, -1, -1 },{ 3, 0, 2 },{ -1, -2, 3 },{ 1, -3, -1 } },
+		{ { 3, 0, 3 },{ -1, 1, -2 },{ 2, 2, 1 },{ -4, -3, 2 },{ -3, 3, -3 },{ 3, -4, 2 },{ -4, -3, -2 },{ 1, 2, -3 },{ 3, 3, -2 },{ 1, 2, 2 },{ -4, 0, 1 },{ 2, 2, -3 },{ 2, -3, -2 },{ -3, -3, 0 },{ 1, 3, 2 },{ 3, -2, -4 },{ 0, -1, 0 },{ -4, 0, -1 },{ 3, 1, -3 },{ 1, -2, 0 },{ -3, -3, -1 },{ -3, 2, -4 },{ -4, -4, -1 },{ 3, -2, 3 },{ -3, -4, -2 },{ 2, 3, -1 },{ 3, 2, -4 },{ -2, 0, 2 },{ 0, -2, -2 },{ -1, 0, 3 },{ -3, -4, 0 },{ 0, -3, 2 },{ -4, 2, -3 },{ 2, 3, 3 },{ 0, -4, 1 },{ 1, 0, -4 },{ 0, -2, -2 },{ -3, -1, 0 },{ 1, 3, 2 },{ -2, 1, -1 },{ 2, 3, -3 },{ -1, 0, 2 },{ 1, 2, 3 },{ -2, 3, 0 },{ -4, 1, 2 },{ 0, -4, -3 },{ -4, -1, -1 },{ 0, 1, 1 },{ -1, 2, 0 },{ 3, -1, 2 },{ 1, 2, -4 },{ 2, -2, 2 },{ 1, 0, -2 },{ -1, 3, -3 },{ 3, 0, 1 },{ -2, -3, -4 },{ -2, 1, -2 },{ -3, -4, -4 },{ 2, 1, 3 },{ 0, 0, 3 },{ -2, 1, -2 },{ 1, -4, 1 },{ -4, 2, -2 },{ -1, 3, -4 } },
+		{ { -2, -3, 1 },{ -4, -2, -1 },{ 1, 1, -4 },{ -1, -2, 3 },{ 0, 0, -1 },{ -1, -2, 0 },{ 1, 2, -4 },{ -3, 0, 3 },{ -4, -4, 2 },{ -2, -1, 0 },{ -2, -3, -4 },{ -1, 1, -1 },{ 3, -1, -1 },{ -4, 0, 1 },{ -1, 2, -2 },{ -1, 1, -3 },{ -2, -3, 2 },{ 0, -2, 2 },{ -1, 3, -4 },{ -4, 1, 3 },{ 0, -1, 1 },{ 3, 1, 3 },{ -2, 0, -2 },{ 1, -3, 1 },{ 0, 2, -4 },{ -4, 1, 2 },{ -1, -4, 3 },{ -3, 1, -1 },{ 1, -3, -3 },{ 2, 3, -2 },{ 3, 2, 1 },{ -1, 0, 0 },{ 2, 1, -2 },{ -1, -4, 3 },{ -2, -2, -1 },{ -2, 3, 1 },{ 3, 1, -2 },{ -1, -4, -1 },{ -4, -2, 3 },{ 3, -3, 1 },{ -1, -1, -4 },{ -3, -4, -1 },{ 0, 0, -2 },{ 3, -1, -3 },{ -1, -3, -4 },{ 2, 3, 3 },{ -2, 2, 1 },{ 1, -2, -1 },{ -2, 0, -4 },{ 1, -3, -3 },{ -4, 1, -2 },{ -3, 3, -1 },{ -1, -1, 0 },{ -3, -4, 1 },{ 0, 2, 2 },{ 1, -1, 3 },{ -4, 0, 0 },{ -1, -2, 1 },{ 2, -1, 1 },{ -3, 3, -1 },{ 3, -3, 0 },{ 2, -2, -4 },{ -3, -1, -3 },{ 3, 1, 0 } },
+		{ { 2, 2, -3 },{ -2, -4, -4 },{ 1, 3, 2 },{ -3, -4, -3 },{ 3, 0, 0 },{ 2, 3, 3 },{ -2, -1, -1 },{ 0, 1, 1 },{ 2, -3, -3 },{ 3, -2, 0 },{ 0, 3, 3 },{ 1, -4, 2 },{ -2, 3, 3 },{ 0, -2, -4 },{ 1, -4, 0 },{ 2, 2, 3 },{ -3, 0, -2 },{ 3, 2, 0 },{ 2, -4, -2 },{ -2, -4, 1 },{ 2, 0, 0 },{ 1, -3, -4 },{ -1, 3, 2 },{ -4, 1, 0 },{ 1, -2, -3 },{ 3, -1, -2 },{ 0, -2, 0 },{ -2, -1, -4 },{ 3, 3, 0 },{ -4, -4, 1 },{ -3, -1, -4 },{ 0, -1, -1 },{ -4, -2, -4 },{ 3, 0, 0 },{ -3, 1, -3 },{ 2, -3, 0 },{ -4, 2, 3 },{ 1, -1, -3 },{ 0, 0, -3 },{ 1, 2, -2 },{ -3, 1, 1 },{ 2, 1, -3 },{ -4, 2, 2 },{ 2, -2, 3 },{ -1, -2, 0 },{ -3, 0, 0 },{ 3, -3, -2 },{ 3, -4, 3 },{ -4, 3, 3 },{ -1, 2, 1 },{ 0, -1, 2 },{ -2, -4, -3 },{ 2, -2, 3 },{ 3, 1, -4 },{ -4, -2, -1 },{ 0, -4, -2 },{ 3, 3, -1 },{ 1, 2, -4 },{ -2, -4, -3 },{ -4, -2, -3 },{ 0, 2, -2 },{ -2, 2, 2 },{ 1, -4, 1 },{ 0, -1, 3 } },
+		{ { 0, 3, 2 },{ -3, 0, 0 },{ 3, -1, -2 },{ 0, 1, 1 },{ -2, 2, -2 },{ -4, -3, -3 },{ -1, -4, -4 },{ 3, 1, 1 },{ -3, 3, -1 },{ -1, -1, -4 },{ -4, 0, -2 },{ 0, 2, -3 },{ -3, -2, 1 },{ -3, -1, -1 },{ 2, 0, -4 },{ -4, -4, 1 },{ -2, -3, -1 },{ 1, 1, -3 },{ -4, -1, 2 },{ -2, 2, -3 },{ 0, 3, -2 },{ -3, -2, -1 },{ 2, -1, -1 },{ -2, -4, -3 },{ -1, 0, 3 },{ -3, 3, 0 },{ 2, -3, 1 },{ 1, 2, -3 },{ -2, 0, 2 },{ 0, -2, 3 },{ 1, 1, -3 },{ -2, 3, 2 },{ 1, -4, 1 },{ 1, 3, 2 },{ -1, -1, -2 },{ 0, -3, 2 },{ 2, 3, -4 },{ -2, -4, 1 },{ -3, 1, -1 },{ 3, -3, 2 },{ -4, -4, 0 },{ 0, -1, 3 },{ -2, 3, -1 },{ -3, -4, -2 },{ 1, 1, 1 },{ -1, 2, -2 },{ 0, -1, -3 },{ -3, 1, -4 },{ -2, 0, -2 },{ 2, -2, 0 },{ 1, -3, -1 },{ 3, 1, -2 },{ -4, 0, 2 },{ 1, 2, 0 },{ -2, -3, -2 },{ -1, 0, -3 },{ 2, 1, 2 },{ -3, -3, 3 },{ 0, 0, 2 },{ 1, 1, 2 },{ -1, -1, 0 },{ -4, 3, 3 },{ -2, 0, -1 },{ -4, -3, -1 } },
+		{ { 2, -2, -2 },{ 1, 2, 3 },{ -4, -3, 0 },{ -1, -3, 2 },{ 1, 2, -4 },{ -3, -2, 2 },{ 1, 2, 3 },{ -2, -3, -2 },{ 0, -1, 2 },{ -2, -4, 3 },{ 2, 1, 0 },{ 3, 0, -2 },{ 2, -3, 2 },{ -2, 1, -3 },{ 3, 3, 2 },{ -1, -2, 3 },{ 1, 2, 1 },{ 0, -1, -4 },{ 3, -2, -1 },{ -3, 0, 3 },{ 3, -3, 2 },{ -4, 0, -4 },{ 0, 2, 2 },{ 2, -2, 1 },{ 0, 2, -2 },{ -3, -3, 2 },{ -1, 1, -4 },{ -4, -4, -2 },{ -1, 0, -1 },{ 2, 1, 2 },{ 3, -2, -1 },{ -1, -3, -2 },{ -3, 0, 0 },{ 2, 2, -4 },{ -3, -1, -1 },{ 3, -2, 1 },{ -4, 0, 3 },{ 0, 0, 0 },{ -1, -2, -2 },{ 2, 3, -2 },{ -1, -2, -4 },{ 1, 0, 1 },{ 3, -3, -4 },{ 1, -2, -1 },{ -4, -1, -4 },{ 2, 3, 2 },{ -4, -4, 0 },{ 2, -2, 2 },{ 0, 2, 1 },{ 0, -4, -3 },{ -3, 3, -4 },{ -2, 2, 1 },{ 2, -3, 3 },{ -1, 3, -4 },{ -3, 1, 3 },{ 3, -4, 1 },{ -2, -2, -1 },{ -3, -1, -2 },{ -1, 3, 0 },{ 3, -3, -2 },{ 1, -3, -4 },{ 2, -4, -2 },{ 3, 1, -3 },{ -1, -2, -4 } },
+		{ { -3, -4, 1 },{ -1, 1, -3 },{ 2, 0, -3 },{ -2, -1, 1 },{ 2, -1, -1 },{ 3, -4, -1 },{ 1, 0, 0 },{ -3, 3, -3 },{ 3, 0, -4 },{ -4, 3, 1 },{ 1, -2, 0 },{ -3, -4, -3 },{ -1, 1, 1 },{ -4, -3, -1 },{ 0, 3, -2 },{ -2, 0, -3 },{ -3, -3, -1 },{ -1, 3, 3 },{ 2, -4, 1 },{ 1, 3, -2 },{ 0, 1, 0 },{ -3, -4, 0 },{ -1, 1, -3 },{ 3, -3, 3 },{ -4, 1, -4 },{ 1, -1, -1 },{ 3, 2, 2 },{ 0, -1, 3 },{ -3, 3, 0 },{ 2, -4, -3 },{ -4, 2, -4 },{ -2, -1, 3 },{ -4, -3, -2 },{ 0, 1, 3 },{ 0, -4, -1 },{ -2, 3, -3 },{ 1, 2, -2 },{ -3, -3, -4 },{ 3, 2, 2 },{ -2, 0, 3 },{ -3, -1, 0 },{ -2, 2, 2 },{ 0, 1, -3 },{ -1, 3, 3 },{ 3, -3, 1 },{ -2, 0, 3 },{ 1, 2, -3 },{ -2, -3, -1 },{ -3, -1, 0 },{ 3, 1, 3 },{ -4, -1, -1 },{ 0, -1, -2 },{ 2, -3, 0 },{ -1, -1, -3 },{ 0, -2, 2 },{ 2, 0, 0 },{ 1, 2, -4 },{ 0, 2, 1 },{ 3, 1, -3 },{ -4, -2, -1 },{ -3, 2, 3 },{ -2, -1, 1 },{ 0, 1, 0 },{ 1, 3, 2 } },
+		{ { 0, -1, 1 },{ -2, 2, -1 },{ 3, -4, 2 },{ 0, 3, -4 },{ -3, 3, 3 },{ -1, 1, -3 },{ -4, -1, 2 },{ -1, -2, 0 },{ 2, -4, -1 },{ -1, -1, -2 },{ 0, 2, 2 },{ 3, -1, 3 },{ -2, 2, -4 },{ 1, -1, 0 },{ 3, -2, 0 },{ 0, -4, -4 },{ 3, 1, 2 },{ -3, -1, 0 },{ -4, 2, -4 },{ -1, -2, -1 },{ -2, -3, -4 },{ 2, -1, 1 },{ 1, 3, 1 },{ -3, 0, -2 },{ -2, -3, -1 },{ -1, -4, 1 },{ 3, 3, -3 },{ -4, -2, -4 },{ -2, -3, -1 },{ 0, -1, 1 },{ 1, 2, -2 },{ 1, -4, 0 },{ 3, 2, -3 },{ 2, 0, 1 },{ -2, -3, -4 },{ -1, 1, 2 },{ 3, -1, 0 },{ 1, -4, 3 },{ -4, 3, -1 },{ 2, -3, -4 },{ 2, -4, 1 },{ 1, 2, -2 },{ -4, -4, -2 },{ -3, -1, 2 },{ -3, 1, 0 },{ -1, -2, -3 },{ 0, -1, -1 },{ 3, 2, -2 },{ -1, 0, 2 },{ 1, -4, -4 },{ -2, 0, 3 },{ -1, 3, 2 },{ -4, -4, -3 },{ 1, 2, -1 },{ -2, 1, -2 },{ -4, 3, 0 },{ -4, -4, -3 },{ 2, -1, 3 },{ -3, -4, 1 },{ -1, -1, -4 },{ 1, 0, 2 },{ -4, -3, -1 },{ 2, 3, 3 },{ -3, -1, -2 } },
+		{ { 3, 0, -4 },{ -4, -3, 3 },{ -3, -2, -2 },{ 1, -2, -1 },{ -4, 0, 1 },{ 3, -3, -2 },{ 0, 2, -2 },{ -2, -2, 3 },{ 2, 1, -4 },{ -4, -3, 2 },{ -3, 2, -1 },{ 1, -3, -3 },{ -1, 0, -1 },{ -3, 3, 3 },{ 2, 0, 2 },{ -4, 2, 1 },{ 1, -3, -3 },{ -2, 0, -2 },{ 2, -4, 2 },{ 0, 1, -2 },{ -2, 0, 3 },{ 3, 3, -1 },{ -1, -2, -3 },{ -4, 1, 2 },{ 0, 3, 0 },{ 1, -1, -2 },{ -2, 0, 3 },{ 2, 1, 1 },{ -2, -3, -2 },{ 0, 1, 3 },{ -4, -1, 1 },{ -1, 0, 2 },{ -2, 3, -2 },{ -3, -2, 0 },{ -4, -2, 2 },{ 2, 3, -1 },{ -3, 0, -3 },{ -2, -3, 1 },{ 0, 1, -3 },{ -1, -1, -1 },{ -3, 1, 3 },{ -1, -2, -3 },{ 3, 0, 0 },{ 2, 2, -1 },{ 1, -3, -2 },{ 0, -4, -4 },{ 2, 3, 0 },{ -4, -2, 3 },{ -2, 3, -4 },{ 2, -3, 1 },{ 3, -2, -2 },{ 1, 2, 0 },{ -3, -2, 1 },{ -3, 0, -4 },{ 3, -3, 2 },{ 1, -2, 3 },{ -1, 0, -2 },{ 0, -3, 2 },{ -2, 1, -2 },{ 3, 3, 2 },{ 0, 2, -3 },{ 3, 1, -4 },{ -2, -4, 0 },{ -1, -3, -3 } },
+		{ { 1, 3, -1 },{ 0, 1, 1 },{ 2, 2, 0 },{ -2, 2, 0 },{ 0, -4, 2 },{ 2, 1, -4 },{ -2, -4, 0 },{ -3, 2, 1 },{ 1, 0, 1 },{ 3, 3, -2 },{ 0, -2, 0 },{ -2, 1, -4 },{ -4, -4, 1 },{ 2, -3, -2 },{ -3, -2, -3 },{ -2, -4, -1 },{ -1, 3, 3 },{ 1, -1, 0 },{ 3, 3, 1 },{ -3, -3, -3 },{ -4, 1, 2 },{ 1, -1, -2 },{ -3, -4, -4 },{ 2, -3, 3 },{ 2, 2, -3 },{ -4, -2, 1 },{ -3, -4, 0 },{ 1, 0, -2 },{ 3, 2, 0 },{ 3, 3, 2 },{ -3, -4, -4 },{ 2, -2, -1 },{ 1, -3, 2 },{ 0, 1, -4 },{ 3, -1, -3 },{ -1, -4, 3 },{ 1, 2, 1 },{ 2, -1, -2 },{ -2, -2, 2 },{ -4, 3, 1 },{ 3, -2, -3 },{ 1, -4, 3 },{ -4, 3, -4 },{ -2, 0, 0 },{ 3, -1, 3 },{ -4, 1, 2 },{ 2, 0, 1 },{ -3, -4, 1 },{ 0, 1, -2 },{ -3, 2, -3 },{ -4, -4, -1 },{ 0, 1, -1 },{ 3, -1, 3 },{ 2, 1, -2 },{ -1, -4, 1 },{ -2, 3, -3 },{ 3, -2, -1 },{ -3, 2, -1 },{ 2, 0, 0 },{ -4, -4, -3 },{ -1, -2, 0 },{ 1, -3, 1 },{ 2, 0, -2 },{ -4, 2, 2 } },
+		{ { 2, -4, -1 },{ -1, -1, -3 },{ 3, -3, -2 },{ -3, -1, 3 },{ -1, 0, -3 },{ -1, -2, 2 },{ 3, 3, -1 },{ 1, -1, -3 },{ 0, -3, -3 },{ -1, -4, -1 },{ -4, 0, 3 },{ 3, 1, 1 },{ 2, 3, 2 },{ -1, 0, -2 },{ 0, 2, 0 },{ 3, 1, -1 },{ -3, -1, -4 },{ 2, 1, 2 },{ 0, -3, 1 },{ -2, -1, -4 },{ 2, 2, 0 },{ 3, -4, 2 },{ -1, -2, 0 },{ -2, 0, -1 },{ 0, 1, 3 },{ 3, 3, -4 },{ -1, -3, 2 },{ -1, -2, -3 },{ 1, -1, -4 },{ -3, 0, -3 },{ -2, -2, -1 },{ -1, 2, -3 },{ 1, 3, 3 },{ -2, 0, 1 },{ 1, 2, -2 },{ -3, -3, -1 },{ -4, 1, -4 },{ -1, 0, 0 },{ 3, -3, -4 },{ 1, 2, -2 },{ -2, 0, 0 },{ 0, 1, 1 },{ 0, -2, 1 },{ -2, -3, -3 },{ -3, 2, 2 },{ 1, 3, -2 },{ -2, -2, -3 },{ -1, -3, -1 },{ 3, -1, 3 },{ 1, 3, 0 },{ -2, 0, 2 },{ 2, 0, -4 },{ -2, -3, -3 },{ -3, 3, -1 },{ 0, -1, 3 },{ -4, 2, -4 },{ 1, 1, 1 },{ -3, -1, -4 },{ 1, -2, 3 },{ 2, 1, 1 },{ -2, 0, -2 },{ -3, 3, 3 },{ -3, -2, -4 },{ -1, -2, 3 } },
+		{ { -4, 1, 1 },{ -3, 0, -4 },{ -2, -4, 2 },{ 2, 1, -4 },{ -3, 3, -1 },{ -4, -3, 1 },{ 2, -1, -4 },{ -4, 1, 3 },{ -2, 3, 0 },{ -3, -1, 2 },{ -2, 2, -3 },{ 1, -4, -1 },{ 0, -2, -4 },{ -3, -1, 3 },{ 1, 3, 2 },{ -4, -3, -4 },{ -1, -2, 3 },{ -4, 2, -2 },{ -1, -4, -3 },{ 0, -2, 3 },{ 1, 2, -1 },{ -4, 3, -3 },{ -1, 0, 1 },{ 1, 2, -3 },{ -3, -3, 1 },{ -2, 2, -2 },{ -3, -1, -1 },{ 0, 3, 3 },{ -4, -4, 1 },{ -1, 2, 3 },{ 2, 1, 2 },{ 3, -1, -2 },{ -4, -3, 0 },{ -4, -1, -3 },{ 2, -4, 0 },{ -1, 3, 2 },{ 0, -2, -2 },{ 0, 1, 3 },{ -4, 3, 2 },{ 2, -4, -1 },{ -1, -1, -4 },{ -3, -3, -1 },{ 2, 3, 3 },{ -1, -4, -4 },{ 3, 0, -1 },{ -1, -2, 0 },{ 1, 2, -4 },{ -4, -1, -2 },{ 2, 1, -3 },{ -1, -3, 1 },{ -1, -2, -2 },{ 0, -4, 2 },{ -4, 2, 1 },{ 1, -2, 2 },{ 3, -1, 0 },{ -1, -4, -1 },{ 2, 0, 2 },{ 0, -4, 1 },{ -2, -3, -2 },{ -4, 3, -4 },{ 2, -1, 2 },{ 0, 2, -1 },{ 3, -1, 0 },{ 0, 1, -2 } },
+		{ { -2, -3, 2 },{ 1, 2, 1 },{ 0, 3, 2 },{ 3, -2, -3 },{ 1, 0, -2 },{ 0, -2, 3 },{ -2, 2, 1 },{ 1, -4, -2 },{ 2, -2, 2 },{ 3, -3, -4 },{ 2, -1, -2 },{ -4, 2, 1 },{ 2, -1, 0 },{ -2, -3, -3 },{ 3, 0, -1 },{ 1, -4, 1 },{ 3, 0, 0 },{ -2, 3, -2 },{ 2, 1, 0 },{ -4, 0, -1 },{ -2, -3, 1 },{ 3, 1, -4 },{ 0, -3, 3 },{ -4, -2, -1 },{ 3, -4, 0 },{ 1, -1, 2 },{ 2, 0, -3 },{ -2, 1, 0 },{ 3, -2, 1 },{ -4, -4, -1 },{ 0, -3, 0 },{ 0, 0, -2 },{ -3, 2, 1 },{ -1, -2, -4 },{ 2, -1, 3 },{ 3, 0, -3 },{ -2, -4, -1 },{ 2, -2, -3 },{ -3, 0, 1 },{ -1, -4, 0 },{ -3, 2, -3 },{ 3, 0, 2 },{ -4, -1, -2 },{ 2, 1, -2 },{ 0, -4, 1 },{ -4, -3, 1 },{ 3, 0, 3 },{ 0, 3, 2 },{ -3, -2, 0 },{ 2, 1, 3 },{ -4, 3, -4 },{ 3, 2, -2 },{ 2, -3, 0 },{ -2, 1, -4 },{ -2, -3, -3 },{ 0, 0, -2 },{ -4, 3, -3 },{ -2, 2, 2 },{ 3, -2, -3 },{ 0, 1, -1 },{ -1, -3, 1 },{ 1, -4, -3 },{ -2, 2, -3 },{ 2, -3, 0 } },
+		{ { 3, -1, -2 },{ 1, 0, 0 },{ -4, -4, -1 },{ -4, 2, 3 },{ -1, -3, 0 },{ 3, 1, -2 },{ -3, 3, -4 },{ -1, 0, 0 },{ -4, 2, -1 },{ 0, 1, -2 },{ 1, 0, 3 },{ -1, 3, 2 },{ -1, -2, -4 },{ -2, 2, 2 },{ -4, 1, -2 },{ -1, 2, -3 },{ 0, -1, 2 },{ -3, -3, -1 },{ 1, -1, 3 },{ 3, 3, -4 },{ 0, -2, 2 },{ -2, -1, -2 },{ -3, 3, 3 },{ 2, -1, -4 },{ -1, 1, -1 },{ -4, 3, -3 },{ 0, -3, 3 },{ 2, -3, -4 },{ 1, 2, -2 },{ -2, 3, -3 },{ 2, 1, -4 },{ -2, -4, 3 },{ 1, 3, 1 },{ 3, -4, 2 },{ 0, 3, -1 },{ -3, 1, 1 },{ -2, -1, 2 },{ 1, 3, -4 },{ 3, 1, 3 },{ 0, -2, -2 },{ 2, 3, 2 },{ 1, 1, 3 },{ -1, -2, 0 },{ -2, 2, -1 },{ -3, 3, 3 },{ 2, -2, -4 },{ -2, 2, 2 },{ 0, -4, -2 },{ -2, -4, -3 },{ -2, 0, -1 },{ 1, -2, 0 },{ -3, -1, 2 },{ -1, 0, -2 },{ -3, 2, 3 },{ 3, 3, 2 },{ 0, -3, 3 },{ 2, -2, 0 },{ -3, 1, -1 },{ 1, 0, 0 },{ -4, 3, 3 },{ 3, -4, -2 },{ -3, 0, 2 },{ -4, 3, 3 },{ -3, -2, -4 } },
+		{ { -1, -1, -3 },{ -3, 3, -2 },{ 1, -2, -4 },{ 2, 1, 1 },{ -1, -1, -3 },{ 2, -4, 0 },{ -3, 0, 2 },{ 3, -2, 3 },{ -1, -3, -3 },{ -3, 3, 1 },{ -3, -3, 0 },{ 3, -4, -1 },{ -4, 1, -3 },{ 2, -3, 1 },{ 3, -4, 3 },{ -2, 3, -1 },{ 2, -2, -4 },{ -3, 1, 2 },{ -1, -4, -3 },{ -1, 0, 1 },{ -3, -2, 0 },{ 2, -4, -2 },{ 3, 1, -3 },{ -1, 0, 2 },{ 1, 2, -2 },{ -2, -4, 2 },{ -3, 0, 0 },{ -1, 3, 1 },{ -3, -2, 2 },{ -4, 0, 2 },{ 3, -1, -1 },{ -3, -1, -1 },{ 2, 1, -4 },{ -2, -3, -2 },{ -4, 2, -2 },{ -1, -3, -4 },{ 1, 2, 1 },{ -4, -3, -2 },{ -1, -1, 0 },{ -4, 0, -3 },{ -2, -3, 1 },{ 1, -4, -2 },{ -4, -3, -4 },{ 3, -1, -3 },{ 1, 0, -1 },{ -3, 1, -3 },{ -4, -1, -1 },{ 2, 1, 0 },{ 3, -1, 1 },{ 0, 1, -4 },{ -4, 3, 1 },{ 1, -4, -1 },{ -1, 1, -3 },{ 1, -2, -1 },{ 2, -4, 1 },{ -4, -1, -4 },{ -1, -1, -2 },{ 3, -4, 1 },{ -2, -1, 3 },{ 2, -3, -4 },{ -1, 2, -3 },{ 1, -2, 0 },{ 0, 0, 1 },{ 3, 1, 3 } },
+		{ { 2, -4, 2 },{ -1, 1, 3 },{ -2, -3, -4 },{ 0, 3, 2 },{ -3, -1, -1 },{ -2, 2, 1 },{ 0, -3, -2 },{ 1, 1, -4 },{ -2, -1, 3 },{ 0, -4, -4 },{ 2, 0, -3 },{ 0, 3, -2 },{ 0, 0, 0 },{ 1, -2, -1 },{ -3, 0, 0 },{ -4, -1, -4 },{ 0, -2, 1 },{ 1, 2, 0 },{ 3, -4, -2 },{ -4, 3, -4 },{ 0, 0, -1 },{ -2, 2, 3 },{ -4, 2, 0 },{ 1, -3, 0 },{ -3, -2, 1 },{ 3, -2, -3 },{ 3, -1, -4 },{ 2, -4, -1 },{ 0, 0, -2 },{ 1, -3, -3 },{ -1, -2, 3 },{ -1, 3, 1 },{ 1, 0, -3 },{ -2, 0, 2 },{ 0, -2, 0 },{ 3, 0, 3 },{ -3, -4, -3 },{ 3, 3, 0 },{ 2, 0, 2 },{ -2, 2, -1 },{ 0, -1, -4 },{ 0, 0, 2 },{ -3, 2, 0 },{ -1, 3, 2 },{ 0, -4, 1 },{ 3, -3, 3 },{ -1, -3, 0 },{ 1, 3, -4 },{ -3, 2, 3 },{ -1, -3, 2 },{ 2, -1, -3 },{ 3, -2, 3 },{ 0, -3, -4 },{ -4, 0, 1 },{ 0, 3, -3 },{ -2, 2, 2 },{ -3, 1, 0 },{ 1, 3, -4 },{ -1, -3, -1 },{ -3, 2, 2 },{ -3, 1, 1 },{ -1, -1, -4 },{ 1, -3, -1 },{ -4, 3, -1 } }
+	}
+};
diff --git a/GLideN64/src/BufferCopy/BlueNoiseTexture.h b/GLideN64/src/BufferCopy/BlueNoiseTexture.h
new file mode 100644
index 00000000..748361b8
--- /dev/null
+++ b/GLideN64/src/BufferCopy/BlueNoiseTexture.h
@@ -0,0 +1,8 @@
+#pragma once
+
+struct BlueNoiseItem
+{
+	signed char r, g, b;
+};
+
+extern const BlueNoiseItem blueNoiseTex[8][64][64];
diff --git a/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp b/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp
index 5345c4e9..d8784f76 100644
--- a/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp
+++ b/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp
@@ -27,6 +27,7 @@
 #include <Graphics/Parameters.h>
 #include <Graphics/ColorBufferReader.h>
 #include <DisplayWindow.h>
+#include "BlueNoiseTexture.h"
 
 using namespace graphics;
 
@@ -43,6 +44,8 @@ ColorBufferToRDRAM::ColorBufferToRDRAM()
 	m_allowedRealWidths[2] = 640;
 }
 
+u32 ColorBufferToRDRAM::m_blueNoiseIdx = 0;
+
 ColorBufferToRDRAM::~ColorBufferToRDRAM()
 {
 }
@@ -234,17 +237,59 @@ bool ColorBufferToRDRAM::_prepareCopy(u32& _startAddress)
 	return true;
 }
 
-u8 ColorBufferToRDRAM::_RGBAtoR8(u8 _c) {
+u8 ColorBufferToRDRAM::_RGBAtoR8(u8 _c, u32 x, u32 y) {
 	return _c;
 }
 
-u16 ColorBufferToRDRAM::_RGBAtoRGBA16(u32 _c) {
-	RGBA c;
+u16 ColorBufferToRDRAM::_RGBAtoRGBA16(u32 _c, u32 x, u32 y) {
+	// Precalculated 4x4 bayer matrix values for 5Bit
+	static const s32 thresholdMapBayer[4][4] = {
+		{ -4, 2, -3, 4 },
+		{ 0, -2, 2, -1 },
+		{ -3, 3, -4, 3 },
+		{ 1, -1, 1, -2 }
+	};
+
+	// Precalculated 4x4 magic square matrix values for 5Bit
+	static const s32 thresholdMapMagicSquare[4][4] = {
+		{ -4, 2, 2, -1 },
+		{ 3, -2, -3, 1 },
+		{ -3, 0, 4, -2 },
+		{ 3, -1, -4, 1 }
+	};
+
+	union RGBA c;
 	c.raw = _c;
-	return ((c.r >> 3) << 11) | ((c.g >> 3) << 6) | ((c.b >> 3) << 1) | (c.a == 0 ? 0 : 1);
+	
+	if (config.generalEmulation.enableDitheringPattern == 0 || config.frameBufferEmulation.nativeResFactor != 1) {
+		// Apply color dithering
+		switch (config.generalEmulation.rdramImageDitheringMode) {
+		case Config::BufferDitheringMode::bdmBayer:
+		case Config::BufferDitheringMode::bdmMagicSquare:
+		{
+			s32 threshold = config.generalEmulation.rdramImageDitheringMode == Config::BufferDitheringMode::bdmBayer ?
+				thresholdMapBayer[x & 3][y & 3] :
+				thresholdMapMagicSquare[x & 3][y & 3];
+			c.r = (u8)std::max(std::min((s32)c.r + threshold, 255), 0);
+			c.g = (u8)std::max(std::min((s32)c.g + threshold, 255), 0);
+			c.b = (u8)std::max(std::min((s32)c.b + threshold, 255), 0);
+		}
+		break;
+		case Config::BufferDitheringMode::bdmBlueNoise:
+		{
+			const BlueNoiseItem& threshold = blueNoiseTex[m_blueNoiseIdx & 7][x & 63][y & 63];
+			c.r = (u8)std::max(std::min((s32)c.r + threshold.r, 255), 0);
+			c.g = (u8)std::max(std::min((s32)c.g + threshold.g, 255), 0);
+			c.b = (u8)std::max(std::min((s32)c.b + threshold.b, 255), 0);
+		}
+		break;
+		}
+	}
+
+	return ((c.r >> 3) << 11) | ((c.g >> 3) << 6) | ((c.b >> 3) << 1) | (c.a == 0 ? 0 : 1);	
 }
 
-u32 ColorBufferToRDRAM::_RGBAtoRGBA32(u32 _c) {
+u32 ColorBufferToRDRAM::_RGBAtoRGBA32(u32 _c, u32 x, u32 y) {
 	RGBA c;
 	c.raw = _c;
 	return (c.r << 24) | (c.g << 16) | (c.b << 8) | c.a;
@@ -284,6 +329,7 @@ void ColorBufferToRDRAM::_copy(u32 _startAddress, u32 _endAddress, bool _sync)
 	} else if (m_pCurFrameBuffer->m_size == G_IM_SIZ_16b) {
 		u32 *ptr_src = (u32*)pPixels;
 		u16 *ptr_dst = (u16*)(RDRAM + _startAddress);
+		m_blueNoiseIdx++;
 
 		if (!FBInfo::fbInfo.isSupported() && config.frameBufferEmulation.copyFromRDRAM != 0) {
 			memset(ptr_dst, 0, numPixels * 2);
diff --git a/GLideN64/src/BufferCopy/ColorBufferToRDRAM.h b/GLideN64/src/BufferCopy/ColorBufferToRDRAM.h
index 3d8fc726..084c9e71 100644
--- a/GLideN64/src/BufferCopy/ColorBufferToRDRAM.h
+++ b/GLideN64/src/BufferCopy/ColorBufferToRDRAM.h
@@ -49,9 +49,9 @@ class ColorBufferToRDRAM
 	u32 _getRealWidth(u32 _viWidth);
 
 	// Convert pixel from video memory to N64 buffer format.
-	static u8 _RGBAtoR8(u8 _c);
-	static u16 _RGBAtoRGBA16(u32 _c);
-	static u32 _RGBAtoRGBA32(u32 _c);
+	static u8 _RGBAtoR8(u8 _c, u32 x, u32 y);
+	static u16 _RGBAtoRGBA16(u32 _c, u32 x, u32 y);
+	static u32 _RGBAtoRGBA32(u32 _c, u32 x, u32 y);
 
 	graphics::ObjectHandle m_FBO;
 	FrameBuffer * m_pCurFrameBuffer;
@@ -60,6 +60,8 @@ class ColorBufferToRDRAM
 
 	u32 m_lastBufferWidth;
 
+	static u32 m_blueNoiseIdx;
+
 	std::array<u32, 3> m_allowedRealWidths;
 	std::unique_ptr<graphics::ColorBufferReader> m_bufferReader;
 };
diff --git a/GLideN64/src/BufferCopy/DepthBufferToRDRAM.cpp b/GLideN64/src/BufferCopy/DepthBufferToRDRAM.cpp
index f1f77983..9defc6e0 100644
--- a/GLideN64/src/BufferCopy/DepthBufferToRDRAM.cpp
+++ b/GLideN64/src/BufferCopy/DepthBufferToRDRAM.cpp
@@ -205,7 +205,7 @@ bool DepthBufferToRDRAM::_prepareCopy(u32& _startAddress, bool _copyChunk)
 	return true;
 }
 
-u16 DepthBufferToRDRAM::_FloatToUInt16(f32 _z)
+u16 DepthBufferToRDRAM::_FloatToUInt16(f32 _z, u32 x, u32 y)
 {
 	static const u16 * const zLUT = depthBufferList().getZLUT();
 	u32 idx = 0x3FFFF;
diff --git a/GLideN64/src/BufferCopy/DepthBufferToRDRAM.h b/GLideN64/src/BufferCopy/DepthBufferToRDRAM.h
index 71841113..f25681fe 100644
--- a/GLideN64/src/BufferCopy/DepthBufferToRDRAM.h
+++ b/GLideN64/src/BufferCopy/DepthBufferToRDRAM.h
@@ -30,7 +30,7 @@ class DepthBufferToRDRAM
 	bool _copy(u32 _startAddress, u32 _endAddress);
 
 	// Convert pixel from video memory to N64 depth buffer format.
-	static u16 _FloatToUInt16(f32 _z);
+	static u16 _FloatToUInt16(f32 _z, u32 x, u32 y);
 
 	graphics::ObjectHandle m_FBO;
 	std::unique_ptr<graphics::PixelReadBuffer> m_pbuf;
diff --git a/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp b/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp
index c15315ba..f0bc76c3 100644
--- a/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp
+++ b/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp
@@ -72,6 +72,7 @@ void RDRAMtoColorBuffer::destroy()
 		m_pTexture = nullptr;
 	}
 	free(m_pbuf);
+	m_pbuf = nullptr;
 }
 
 void RDRAMtoColorBuffer::addAddress(u32 _address, u32 _size)
@@ -173,6 +174,7 @@ u32 RGBA32ToABGR32(u32 col, bool _fullAlpha)
 void RDRAMtoColorBuffer::_copyFromRDRAM(u32 _height, bool _fullAlpha)
 {
 	Cleaner cleaner(this);
+	ValueKeeper<u32> otherMode(gSP.clipRatio, 1U);
 	const u32 address = m_pCurBuffer->m_startAddress;
 	const u32 width = m_pCurBuffer->m_width;
 	const u32 height = _height;
@@ -302,9 +304,6 @@ void RDRAMtoColorBuffer::copyFromRDRAM(u32 _address, bool _bCFB)
 	if (m_pCurBuffer == nullptr || m_pCurBuffer->m_size < G_IM_SIZ_16b)
 		return;
 
-	if (m_pCurBuffer->m_startAddress == _address && gDP.colorImage.changed != 0)
-		return;
-
 	const u32 height = cutHeight(m_pCurBuffer->m_startAddress,
 		m_pCurBuffer->m_startAddress == _address ?
 			VI.real_height :
diff --git a/GLideN64/src/BufferCopy/WriteToRDRAM.h b/GLideN64/src/BufferCopy/WriteToRDRAM.h
index 477eee87..8e9d2487 100644
--- a/GLideN64/src/BufferCopy/WriteToRDRAM.h
+++ b/GLideN64/src/BufferCopy/WriteToRDRAM.h
@@ -5,7 +5,7 @@
 #include "../Types.h"
 
 template <typename TSrc, typename TDst>
-void writeToRdram(TSrc* _src, TDst* _dst, TDst(*converter)(TSrc _c), TSrc _testValue, u32 _xor, u32 _width, u32 _height, u32 _numPixels, u32 _startAddress, u32 _bufferAddress, u32 _bufferSize)
+void writeToRdram(TSrc* _src, TDst* _dst, TDst(*converter)(TSrc _c, u32 x, u32 y), TSrc _testValue, u32 _xor, u32 _width, u32 _height, u32 _numPixels, u32 _startAddress, u32 _bufferAddress, u32 _bufferSize)
 {
 	u32 chunkStart = ((_startAddress - _bufferAddress) >> (_bufferSize - 1)) % _width;
 	if (chunkStart % 2 != 0) {
@@ -21,7 +21,7 @@ void writeToRdram(TSrc* _src, TDst* _dst, TDst(*converter)(TSrc _c), TSrc _testV
 		for (u32 x = chunkStart; x < _width; ++x) {
 			c = _src[x];
 			if (c != _testValue)
-				_dst[numStored ^ _xor] = converter(c);
+				_dst[numStored ^ _xor] = converter(c, x, y);
 			++numStored;
 		}
 		++y;
@@ -33,7 +33,7 @@ void writeToRdram(TSrc* _src, TDst* _dst, TDst(*converter)(TSrc _c), TSrc _testV
 		for (u32 x = 0; x < _width && numStored < _numPixels; ++x) {
 			c = _src[x + y *_width];
 			if (c != _testValue)
-				_dst[(x + dsty*_width) ^ _xor] = converter(c);
+				_dst[(x + dsty*_width) ^ _xor] = converter(c, x, y);
 			++numStored;
 		}
 		++dsty;
diff --git a/GLideN64/src/CMakeLists.txt b/GLideN64/src/CMakeLists.txt
index bb209aab..c2b6ef5d 100644
--- a/GLideN64/src/CMakeLists.txt
+++ b/GLideN64/src/CMakeLists.txt
@@ -1,4 +1,4 @@
-cmake_minimum_required(VERSION 2.6)
+cmake_minimum_required(VERSION 3.9)
 
 option(EGL "Set to ON if targeting an EGL device" ${EGL})
 option(PANDORA "Set to ON if targeting an OpenPandora" ${PANDORA})
@@ -56,6 +56,7 @@ set(GLideN64_SOURCES
   Textures.cpp
   VI.cpp
   ZlutTexture.cpp
+  BufferCopy/BlueNoiseTexture.cpp
   BufferCopy/ColorBufferToRDRAM.cpp
   BufferCopy/DepthBufferToRDRAM.cpp
   BufferCopy/RDRAMtoColorBuffer.cpp
@@ -346,7 +347,6 @@ elseif(CRC_OPT)
   )
   list(APPEND GLideN64_SOURCES
     CRC_OPT.cpp
-    xxHash/xxhash.c
   )
 elseif(CRC_NEON)
   list(REMOVE_ITEM GLideN64_SOURCES
@@ -354,7 +354,6 @@ elseif(CRC_NEON)
   )
   list(APPEND GLideN64_SOURCES
     Neon/CRC_OPT_NEON.cpp
-    xxHash/xxhash.c
   )
 endif(CRC_ARMV8)
 
@@ -435,6 +434,8 @@ if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "GNU" OR "${CMAKE_CXX_COMPILER_ID}" STREQ
   set( CMAKE_SHARED_LINKER_FLAGS  "${CMAKE_SHARED_LINKER_FLAGS} ${GCC_STATIC_LINK_FLAGS}" )
 endif()
 
+set(CMAKE_CXX_STANDARD 11)
+
 add_library( ${GLideN64_DLL_NAME} SHARED ${GLideN64_SOURCES} ${PATH_REVISION})
 
 if( CMAKE_BUILD_TYPE STREQUAL "Debug")
@@ -462,15 +463,12 @@ if( CMAKE_BUILD_TYPE STREQUAL "Debug")
 endif( CMAKE_BUILD_TYPE STREQUAL "Debug")
 
 if( CMAKE_BUILD_TYPE STREQUAL "Release")
-  if ((${CMAKE_VERSION} VERSION_EQUAL 3.9) OR (${CMAKE_VERSION} VERSION_GREATER 3.9))
-    cmake_policy(SET CMP0069 NEW)
-    include(CheckIPOSupported)
-    check_ipo_supported(RESULT result)
-    if(result)
-      message("Interprocedural optimizations enabled")
-      set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)
-      set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -O3")
-    endif()
+  include(CheckIPOSupported)
+  check_ipo_supported(RESULT result)
+  if(result)
+    message("Interprocedural optimizations enabled")
+    set_property(TARGET ${GLideN64_DLL_NAME} PROPERTY INTERPROCEDURAL_OPTIMIZATION TRUE)
+    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -O3")
   endif()
 
   SET_TARGET_PROPERTIES(
diff --git a/GLideN64/src/CRC.h b/GLideN64/src/CRC.h
index 0592de2f..19cd3975 100644
--- a/GLideN64/src/CRC.h
+++ b/GLideN64/src/CRC.h
@@ -4,5 +4,5 @@
 void CRC_Init();
 
 u32 CRC_Calculate_Strict( u32 crc, const void *buffer, u32 count );
-u32 CRC_Calculate( u32 crc, const void *buffer, u32 count );
-u32 CRC_CalculatePalette( u32 crc, const void *buffer, u32 count );
+u64 CRC_Calculate( u64 crc, const void *buffer, u32 count );
+u64 CRC_CalculatePalette( u64 crc, const void *buffer, u32 count );
diff --git a/GLideN64/src/CRC32.cpp b/GLideN64/src/CRC32.cpp
index b0aca304..1b1b70b2 100644
--- a/GLideN64/src/CRC32.cpp
+++ b/GLideN64/src/CRC32.cpp
@@ -32,16 +32,17 @@ void CRC_Init()
 	}
 }
 
-u32 CRC_Calculate( u32 crc, const void * buffer, u32 count )
+u64 CRC_Calculate( u64 crc, const void * buffer, u32 count )
 {
 	u8 *p;
-	u32 orig = crc;
+	u32 crc32 = static_cast<u32>(crc);
+	u32 orig = crc32;
 
 	p = (u8*) buffer;
 	while (count--)
-		crc = (crc >> 8) ^ CRCTable[(crc & 0xFF) ^ *p++];
+		crc32 = (crc32 >> 8) ^ CRCTable[(crc32 & 0xFF) ^ *p++];
 
-	return crc ^ orig;
+	return crc32 ^ orig;
 }
 
 u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
@@ -49,18 +50,19 @@ u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
 	return CRC_Calculate(crc, buffer, count);
 }
 
-u32 CRC_CalculatePalette(u32 crc, const void * buffer, u32 count )
+u64 CRC_CalculatePalette(u64 crc, const void * buffer, u32 count )
 {
 	u8 *p;
-	u32 orig = crc;
+	u32 crc32 = static_cast<u32>(crc);
+	u32 orig = crc32;
 
 	p = (u8*) buffer;
 	while (count--) {
-		crc = (crc >> 8) ^ CRCTable[(crc & 0xFF) ^ *p++];
-		crc = (crc >> 8) ^ CRCTable[(crc & 0xFF) ^ *p++];
+		crc32 = (crc32 >> 8) ^ CRCTable[(crc32 & 0xFF) ^ *p++];
+		crc32 = (crc32 >> 8) ^ CRCTable[(crc32 & 0xFF) ^ *p++];
 
 		p += 6;
 	}
 
-	return crc ^ orig;
+	return crc32 ^ orig;
 }
diff --git a/GLideN64/src/CRC32_ARMV8.cpp b/GLideN64/src/CRC32_ARMV8.cpp
index 0eec43aa..226d6194 100644
--- a/GLideN64/src/CRC32_ARMV8.cpp
+++ b/GLideN64/src/CRC32_ARMV8.cpp
@@ -17,34 +17,35 @@ void CRC_Init()
 {
 }
 
-u32 CRC_Calculate( u32 crc, const void * buffer, u32 count )
+u64 CRC_Calculate( u64 crc, const void * buffer, u32 count )
 {
 	u8 *p;
-	u32 orig = crc;
+	u32 crc32 = static_cast<u32>(crc);
+	u32 orig = crc32;
 
 	p = (u8*) buffer;
 
 	// use eight byte crc intrinsic __crc32d if count is high enough.
 	// __crc32d, __crc32w, __crc32h and __crc32b use polynomial 0x04C11DB7
 	while (count >= 8) {
-		crc = __crc32d(crc, *((u64*)p));
+		crc32 = __crc32d(crc32, *((u64*)p));
 		p += 8;
 		count -= 8;
 	}
 	if (count >= 4) {
-		crc = __crc32w(crc, *((u32*)p));
+		crc32 = __crc32w(crc32, *((u32*)p));
 		p += 4;
 		count -= 4;
 	}
 	if (count >= 2) {
-		crc = __crc32h(crc, *((u16*)p));
+		crc32 = __crc32h(crc32, *((u16*)p));
 		p += 2;
 		count -= 2;
 	}
 	if (count == 1)
-		crc = __crc32b(crc, *p);
+		crc32 = __crc32b(crc32, *p);
 
-	return crc ^ orig;
+	return crc32 ^ orig;
 }
 
 u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
@@ -52,17 +53,18 @@ u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
 	return CRC_Calculate(crc, buffer, count);
 }
 
-u32 CRC_CalculatePalette(u32 crc, const void * buffer, u32 count )
+u64 CRC_CalculatePalette(u64 crc, const void * buffer, u32 count )
 {
 	u8 *p;
-	u32 orig = crc;
+	u32 crc32 = static_cast<u32>(crc);
+	u32 orig = crc32;
 
 	p = (u8*) buffer;
 	while (count--) {
 		// use two byte intrinsic __crc32h
-		crc = __crc32h(crc, *((u16*)p));
+		crc32 = __crc32h(crc32, *((u16*)p));
 		p += 8;
 	}
 
-	return crc ^ orig;
+	return crc32 ^ orig;
 }
diff --git a/GLideN64/src/CRC_OPT.cpp b/GLideN64/src/CRC_OPT.cpp
index 40c8fab6..6bbc7233 100644
--- a/GLideN64/src/CRC_OPT.cpp
+++ b/GLideN64/src/CRC_OPT.cpp
@@ -1,5 +1,5 @@
 #include "CRC.h"
-#include "xxHash/xxhash.h"
+#include "xxHash/xxh3.h"
 
 #define CRC32_POLYNOMIAL     0x04C11DB7
 
@@ -45,16 +45,16 @@ u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
 	return crc ^ orig;
 }
 
-u32 CRC_Calculate( u32 crc, const void * buffer, u32 count )
+u64 CRC_Calculate( u64 crc, const void * buffer, u32 count )
 {
-	return XXH32(buffer, count, crc);
+	return XXH3_64bits_withSeed(buffer, count, crc);
 }
 
-u32 CRC_CalculatePalette(u32 crc, const void * buffer, u32 count )
+u64 CRC_CalculatePalette( u64 crc, const void * buffer, u32 count )
 {
 	u8 *p = (u8*) buffer;
 	while (count--) {
-		crc = XXH32(p, 2, crc);
+		crc = XXH3_64bits_withSeed(p, 2, crc);
 		p += 8;
 	}
 	return crc;
diff --git a/GLideN64/src/Config.cpp b/GLideN64/src/Config.cpp
index d3112f23..ee545160 100644
--- a/GLideN64/src/Config.cpp
+++ b/GLideN64/src/Config.cpp
@@ -33,7 +33,10 @@ void Config::resetToDefaults()
 	texture.screenShotFormat = 0;
 
 	generalEmulation.enableLOD = 1;
-	generalEmulation.enableNoise = 1;
+	generalEmulation.enableHiresNoiseDithering = 0;
+	generalEmulation.enableDitheringPattern = 0;
+	generalEmulation.enableDitheringQuantization = 1;
+	generalEmulation.rdramImageDitheringMode = BufferDitheringMode::bdmBlueNoise;
 	generalEmulation.enableHWLighting = 0;
 	generalEmulation.enableCustomSettings = 1;
 	generalEmulation.enableShadersStorage = 1;
diff --git a/GLideN64/src/Config.h b/GLideN64/src/Config.h
index a4b3221c..fa86c963 100644
--- a/GLideN64/src/Config.h
+++ b/GLideN64/src/Config.h
@@ -5,7 +5,7 @@
 #include "Types.h"
 
 #define CONFIG_WITH_PROFILES 23U
-#define CONFIG_VERSION_CURRENT 27U
+#define CONFIG_VERSION_CURRENT 29U
 
 #define BILINEAR_3POINT   0
 #define BILINEAR_STANDARD 1
@@ -46,8 +46,18 @@ struct Config
 		tcForce
 	};
 
+	enum BufferDitheringMode {
+		bdmDisable = 0,
+		bdmBayer,
+		bdmMagicSquare,
+		bdmBlueNoise
+	};
+
 	struct {
-		u32 enableNoise;
+		u32 enableDitheringPattern;
+		u32 enableDitheringQuantization;
+		u32 enableHiresNoiseDithering;
+		u32 rdramImageDitheringMode;
 		u32 enableLOD;
 		u32 enableHWLighting;
 		u32 enableCustomSettings;
diff --git a/GLideN64/src/FrameBuffer.cpp b/GLideN64/src/FrameBuffer.cpp
index 43a41a07..1a776aa9 100644
--- a/GLideN64/src/FrameBuffer.cpp
+++ b/GLideN64/src/FrameBuffer.cpp
@@ -591,7 +591,7 @@ void FrameBufferList::setBufferChanged(f32 _maxY)
 void FrameBufferList::clearBuffersChanged()
 {
 	gDP.colorImage.changed = FALSE;
-	FrameBuffer * pBuffer = frameBufferList().findBuffer(*REG.VI_ORIGIN);
+	FrameBuffer * pBuffer = frameBufferList().findBuffer(*REG.VI_ORIGIN & 0xffffff);
 	if (pBuffer != nullptr)
 		pBuffer->m_changed = false;
 }
diff --git a/GLideN64/src/GBI.cpp b/GLideN64/src/GBI.cpp
index 898d225d..4400b580 100644
--- a/GLideN64/src/GBI.cpp
+++ b/GLideN64/src/GBI.cpp
@@ -195,6 +195,7 @@ void GBIInfo::_makeCurrent(MicrocodeInfo * _pCurrent)
 		RDP_Init();
 
 		G_TRI1 = G_TRI2 = G_TRIX = G_QUAD = -1; // For correct work of gSPFlushTriangles()
+		gSP.clipRatio = 1U;
 
 		switch (m_pCurrent->type) {
 			case F3D:
@@ -204,10 +205,12 @@ void GBIInfo::_makeCurrent(MicrocodeInfo * _pCurrent)
 			case F3DEX:
 				F3DEX_Init();
 				m_hwlSupported = true;
+				gSP.clipRatio = m_pCurrent->Rej ? 2U : 1U;
 			break;
 			case F3DEX2:
 				F3DEX2_Init();
 				m_hwlSupported = true;
+				gSP.clipRatio = 2U;
 			break;
 			case L3D:
 				L3D_Init();
@@ -216,10 +219,12 @@ void GBIInfo::_makeCurrent(MicrocodeInfo * _pCurrent)
 			case L3DEX:
 				L3DEX_Init();
 				m_hwlSupported = false;
+				gSP.clipRatio = m_pCurrent->Rej ? 2U : 1U;
 			break;
 			case L3DEX2:
 				L3DEX2_Init();
 				m_hwlSupported = false;
+				gSP.clipRatio = 2U;
 			break;
 			case S2DEX_1_03:
 				S2DEX_1_03_Init();
@@ -280,10 +285,12 @@ void GBIInfo::_makeCurrent(MicrocodeInfo * _pCurrent)
 			case F3DZEX2OOT:
 				F3DZEX2_Init();
 				m_hwlSupported = true;
+				gSP.clipRatio = 2U;
 			break;
 			case F3DZEX2MM:
 				F3DZEX2_Init();
 				m_hwlSupported = false;
+				gSP.clipRatio = 2U;
 			break;
 			case F3DTEXA:
 				F3DTEXA_Init();
@@ -296,6 +303,7 @@ void GBIInfo::_makeCurrent(MicrocodeInfo * _pCurrent)
 			case F3DEX2ACCLAIM:
 				F3DEX2ACCLAIM_Init();
 				m_hwlSupported = false;
+				gSP.clipRatio = 2U;
 			break;
 			case F5Rogue:
 				F5Rogue_Init();
@@ -304,6 +312,7 @@ void GBIInfo::_makeCurrent(MicrocodeInfo * _pCurrent)
 			case F3DFLX2:
 				F3DFLX2_Init();
 				m_hwlSupported = true;
+				gSP.clipRatio = 2U;
 			break;
 			case ZSortBOSS:
 				ZSortBOSS_Init();
@@ -397,6 +406,9 @@ void GBIInfo::loadMicrocode(u32 uc_start, u32 uc_dstart, u16 uc_dsize)
 			} else if (strncmp(&uc_str[4], "Gfx", 3) == 0) {
 				current.NoN = (strstr( uc_str + 4, ".NoN") != nullptr);
 				current.Rej = (strstr(uc_str + 4, ".Rej") != nullptr);
+				if (current.Rej)
+					// For the Z direction, a reject box can be done with the far plane, but not with the near plane.
+					current.NoN = true;
 
 				if (strncmp( &uc_str[14], "F3D", 3 ) == 0) {
 					if (uc_str[28] == '1' || strncmp(&uc_str[28], "0.95", 4) == 0 || strncmp(&uc_str[28], "0.96", 4) == 0)
diff --git a/GLideN64/src/GLideN64.rc b/GLideN64/src/GLideN64.rc
new file mode 100644
index 0000000000000000000000000000000000000000..7ca2c4138b3c925843710a9941449cd16cdea907
GIT binary patch
literal 2842
zcmds(T~8B16o%hx692={-bmEek6%Drtc|4@wna@y8beuZQWw)L;l|%CJZGi@*zPJ8
zE><&{o!PVJ%=voHnZ5eiR8vm-n(9PzohxUiT0lF3mg_=aG~=zUXAGw^ohoC_p)Xh`
z(B`Zrcfsz2z2nVJo9a6}4L#8oTAF^XL(TX)gL~q6YisfieO2v-JN0}ir+(B>eT_9z
z@8;|3SzS1$USi<+Ug#1VW;)jDmxi}C>M^e-NT&W|v$($0YxbH?yZWF63r6ao{{TA<
zwFkAset_1`P!gW|YC-9<kA9o))f>^exH=-Vp4*fto$DL^FUX3;VTjkCc=qtRjh_~e
zJ?O8Qt4R2B?k_zag4}K1qfOO|nptGl)xobJ<`l$iijC@fY2G@rn^E^OGL?e?r>EpR
z<1N;I!Y*`!Tss9Q$nVsYRhZNEFSRw{#9h4wRiUO5>SsiCwb48VU44d~`-9<1C5N1G
z2!_W<S?%w5t$nBis3X>{$7!SlKI;lSYW1C-b9Mq>3rdh#<*?2ZsyZORd?`nO)yEN@
zyhm&2pX&w1RUQ#*tIb!$teDgJ?=5`q`c7foZaIoO{;^&zyT0WwM9ieDuWX{D=%%T0
z8(2TT+iz;z4RdC;)P8GanMH3lwCHd3)O|k=w^Fn!ROI?yw2n55UHJ)*Q`6P#&#^~a
m1mZL_q~!R2t=EU$-G=Dj-`z2e)y{Z1-ZTDU?63B|m2(Xg8dD7b

literal 0
HcmV?d00001

diff --git a/GLideN64/src/GLideNUI-wtl/About.cpp b/GLideN64/src/GLideNUI-wtl/About.cpp
new file mode 100644
index 00000000..b2b7ef43
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/About.cpp
@@ -0,0 +1,403 @@
+#include "About.h"
+#include "resource.h"
+#include "Language.h"
+
+extern HINSTANCE hInstance;
+
+class CAboutContributersTab :
+	public CAboutTab
+{
+public:
+	BEGIN_MSG_MAP(CAboutContributersTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+	END_MSG_MAP()
+
+	CAboutContributersTab() :
+		CAboutTab(IDD_TAB_CONTRIBUTORS)
+	{
+	}
+
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+	{
+		const TCHAR Contributors[] =
+		{
+			L"Logan McNaughton\r\n\r\n"
+			L"Francisco Zurita\r\n\r\n"
+			L"gizmo98\r\n\r\n"
+			L"purplemarshmallow\r\n\r\n"
+			L"zilmar\r\n\r\n"
+			L"matthewharvey\r\n\r\n"
+			L"lioncash\r\n\r\n"
+			L"Predator82Germany\r\n\r\n"
+			L"AmbientMalice\r\n\r\n"
+			L"baptiste0602\r\n\r\n"
+			L"Gilles Siberlin\r\n\r\n"
+			L"Daniel Eck\r\n\r\n"
+			L"Vctor \"IlDucci\"\r\n\r\n"
+			L"orbea\r\n\r\n"
+			L"BenjaminSiskoo\r\n\r\n"
+			L"ptitSeb\r\n\r\n"
+			L"Kimberly J.Ortega\r\n\r\n"
+			L"Maxime Morel\r\n\r\n"
+			L"tony971\r\n\r\n"
+			L"SigmaVirus\r\n\r\n"
+			L"Jools Wills\r\n\r\n"
+			L"Nekokabu\r\n\r\n"
+			L"nicklauslittle\r\n\r\n"
+			L"Nebuleon\r\n\r\n"
+			L"sergiobenrocha2\r\n\r\n"
+			L"Micha Durak\r\n\r\n"
+			L"Mushman"
+		};
+		GetDlgItem(IDC_CONTRIBUTORS).SetWindowText(Contributors);
+		return true;
+	}
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if ((HWND)lParam == GetDlgItem(IDC_CONTRIBUTORS))
+		{
+			SetBkMode((HDC)wParam, TRANSPARENT);
+			return (LRESULT)GetSysColorBrush(COLOR_3DFACE);
+		}
+		return (LRESULT)GetStockObject(WHITE_BRUSH);
+	}
+};
+
+class CAboutFundersTab :
+	public CAboutTab
+{
+public:
+	BEGIN_MSG_MAP(CAboutFundersTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+	END_MSG_MAP()
+
+	CAboutFundersTab() :
+		CAboutTab(IDD_TAB_FUNDERS)
+	{
+	}
+
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+	{
+		const TCHAR Funders1[] =
+		{
+			L"zolcos\r\n"
+			L"Mush Man\r\n"
+			L"nesplayer4life\r\n"
+			L"neko9876\r\n"
+			L"AnthonyHeathcoat\r\n"
+			L"daman6009\r\n"
+			L"Paul Lamb\r\n"
+			L"zilmar\r\n"
+		};
+		std::wstring FundersList =
+		{
+			L"Ryan Rosser\r\n"
+			L"Amadeus Sterl\r\n"
+			L"Narann\r\n"
+			L"camara_luiz\r\n"
+			L"weinerschnitzel\r\n"
+			L"microdev\r\n"
+			L"Thomas Ginelli\r\n"
+			L"ace977\r\n"
+			L"patryk.szalanski\r\n"
+			L"Detomine\r\n"
+			L"itasovski\r\n"
+			L"keithclark1985\r\n"
+			L"josephrmoore\r\n"
+			L"fckyourlies\r\n"
+			L"dougforr\r\n"
+			L"camdenfurse\r\n"
+			L"grandslam810\r\n"
+			L"rictic\r\n"
+			L"Fred Lambes\r\n"
+			L"David Vercruyssen\r\n"
+			L"danielgormly\r\n"
+			L"lukecool\r\n"
+			L"rhilsky\r\n"
+			L"phillipstuerzl\r\n"
+			L"killjoy1337\r\n"
+			L"ratop46\r\n"
+			L"william.a.moore\r\n"
+			L"RSP16\r\n"
+			L"kzidek127\r\n"
+			L"Dan Holberg\r\n"
+			L"178amm\r\n"
+			L"peterchrjoergensen\r\n"
+			L"hill_jm\r\n"
+			L"petercullenbryan\r\n"
+			L"Christopher M Rock\r\n"
+			L"Kenny.R.Mitchell\r\n"
+			L"Kevin Grasso\r\n"
+			L"mtgyure\r\n"
+			L"Anthony Heathcoat\r\n"
+			L"Liam Burns\r\n"
+			L"Steven Impson\r\n"
+			L"Gwyn.Whieldon\r\n"
+			L"hipnotoad\r\n"
+			L"shmuklidooha\r\n"
+			L"bcanard123\r\n"
+			L"Ben Slater\r\n"
+			L"Mike Nagy\r\n"
+			L"littlegreendude55\r\n"
+			L"Jay Loring\r\n"
+			L"Damion D\r\n"
+			L"heranbago\r\n"
+			L"baptiste.guilbert\r\n"
+			L"shadowpower69\r\n"
+			L"j.mcguirk72\r\n"
+			L"Peter Greenwood\r\n"
+			L"fla56\r\n"
+			L"Sergio\r\n"
+			L"theboy_181\r\n"
+			L"Jindo Fox\r\n"
+			L"s1n.pcc\r\n"
+			L"rafaelvasco\r\n"
+			L"copileo\r\n"
+			L"hugues.fabien\r\n"
+			L"seanmcm157\r\n"
+			L"David Morris\r\n"
+			L"Jason Lightner\r\n"
+			L"olivier_crepin77\r\n"
+			L"Paul Lamb\r\n"
+			L"thegump2.0\r\n"
+			L"Bates\r\n"
+			L"cdoublejj\r\n"
+			L"buddybenj\r\n"
+			L"don.carmical\r\n"
+			L"kyussgreen\r\n"
+			L"info1092\r\n"
+			L"YQ\r\n"
+			L"Allan Nordhy\r\n"
+			L"christian010\r\n"
+			L"creuseur2patateradio\r\n"
+			L"chrisbevanlee\r\n"
+			L"theschklingen\r\n"
+			L"Thomas Lindstrm\r\n"
+			L"Djipi\r\n"
+			L"Dartus\r\n"
+			L"Oscar Abraham\r\n"
+			L"nwstrathdee\r\n"
+			L"will7046\r\n"
+			L"Richard42\r\n"
+			L"V1del\r\n"
+			L"AnthonyBentley\r\n"
+			L"buddybenj\r\n"
+			L"nickshooter251\r\n"
+			L"sicurella12\r\n"
+			L"jcspringer\r\n"
+			L"Gru So\r\n"
+			L"Vincius dos Santos Oliveira\r\n"
+			L"Jimmy Haugh\r\n"
+			L"Malcolm\r\n"
+			L"Alex Strange\r\n"
+			L"Espen Jensen\r\n"
+			L"m.johnsondelta\r\n"
+			L"alexzandar.toxic2\r\n"
+			L"Ben Slater\r\n"
+			L"WC-Predator\r\n"
+			L"Mush Man\r\n"
+			L"Ben Slater\r\n"
+			L"aznlucidx\r\n"
+			L"Nathan Dick\r\n"
+			L"paulanocom\r\n"
+			L"Ryan Rosser\r\n"
+			L"nekow42\r\n"
+			L"mgos1\r\n"
+			L"ian.macdonald996\r\n"
+			L"itasovski\r\n"
+			L"vikingpower1\r\n"
+			L"DukeX007X\r\n"
+			L"palaciosgabriel\r\n"
+			L"Franz-Josef Haider\r\n"
+			L"e-male\r\n"
+			L"aweath\r\n"
+			L"famicom4\r\n"
+			L"Keith_at_UMR\r\n"
+			L"sweatypickle\r\n"
+			L"jeremydmiller\r\n\r\n"
+		};
+		FundersList += wGS(ABOUT_AND_MORE);
+		CWindow Funders = GetDlgItem(IDC_FUNDERS);
+		Funders.SetWindowText(Funders1);
+		m_SubtitleFont.Apply(m_hWnd, CWindowFont::typeBold | CWindowFont::typeSubheading, IDC_FUNDERS);
+		GetDlgItem(IDC_FUNDERS_LIST).SetWindowText(FundersList.c_str());
+		return true;
+	};
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if ((HWND)lParam == GetDlgItem(IDC_FUNDERS_LIST))
+		{
+			SetBkMode((HDC)wParam, TRANSPARENT);
+			return (LRESULT)GetSysColorBrush(COLOR_3DFACE);
+		}
+		return (LRESULT)GetStockObject(WHITE_BRUSH);
+	}
+};
+
+class CAboutCreditsTab :
+	public CAboutTab
+{
+public:
+	BEGIN_MSG_MAP(CAboutCreditsTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+	END_MSG_MAP()
+
+	CAboutCreditsTab() :
+		CAboutTab(IDD_TAB_CREDITS)
+	{
+	}
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+	{
+		SetDlgItemTextW(IDC_TXT_AUTHOR_GLN64, wGS(ABOUT_AUTHOR_GLN64).c_str());
+		SetDlgItemTextW(IDC_TXT_AUTHOR_GLES2N64, wGS(ABOUT_AUTHOR_GLES2N64).c_str());
+		SetDlgItemTextW(IDC_TXT_AUTHOR_GLIDEHQ, wGS(ABOUT_AUTHOR_GLIDEHQ).c_str());
+		SetDlgItemTextW(IDC_TXT_AUTHOR_Z64, wGS(ABOUT_AUTHOR_Z64).c_str());
+
+		const UINT Creditors[] =
+		{
+			IDC_ORKIN,
+			IDC_YONGZH,
+			IDC_HIROSHI,
+			IDC_ZIGGY
+		};
+		for (const UINT &Creditor : Creditors) {
+		  m_SubtitleFont.Apply(m_hWnd, CWindowFont::typeBold | CWindowFont::typeSubheading, Creditor);
+		}
+		return true;
+	};
+};
+
+CAboutTab::CAboutTab(uint32_t _IDD) :
+	IDD(_IDD)
+{
+}
+
+CAboutTab::~CAboutTab()
+{
+}
+
+BOOL CAboutTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+{
+	SetDlgItemTextW(IDC_TXT_NEW_GEN, wGS(ABOUT_NEXT_GENERATION).c_str());
+	SetDlgItemTextW(IDC_TXT_AUTHORS, wGS(ABOUT_AUTHORS).c_str());
+	SetDlgItemTextW(IDC_TXT_DEVELOPER, wGS(ABOUT_DEVELOPER).c_str());
+	SetDlgItemTextW(IDC_TXT_BETA_TESTER, wGS(ABOUT_BETA_TESTER).c_str());
+	SetDlgItemTextW(IDC_TXT_GUI_DESIGNER, wGS(ABOUT_GUI_DESIGNER).c_str());
+
+	const UINT Authors[] =
+	{
+		IDC_SERGEY,
+		IDC_OLIVIER,
+		IDC_RYAN
+	};
+	for (const UINT &Author : Authors) {
+	  m_SubtitleFont.Apply(m_hWnd, CWindowFont::typeBold | CWindowFont::typeSubheading, Author);
+	}
+	return true;
+}
+
+LRESULT CAboutTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+CAboutDlg::~CAboutDlg()
+{
+	for (size_t i = 0, n = m_TabWindows.size(); i < n; i++)
+	{
+		delete m_TabWindows[i];
+	}
+	m_TabWindows.clear();
+}
+
+LRESULT CAboutDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/ , LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	SetWindowText(wGS(ABOUT_ABOUT_TITLE).c_str());
+
+	HICON hIcon = AtlLoadIconImage(IDI_APPICON, LR_DEFAULTCOLOR, ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON));
+	SetIcon(hIcon, TRUE);
+	HICON hIconSmall = AtlLoadIconImage(IDI_APPICON, LR_DEFAULTCOLOR, ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));
+	SetIcon(hIconSmall, FALSE);
+	SIZEF dpiScale = DpiScale(m_hWnd);
+	SIZE iconSz = { (LONG)(48 * dpiScale.cx), (LONG)(48 * dpiScale.cy) };
+
+	m_TitleFont.Apply(m_hWnd, CWindowFont::typeBold | CWindowFont::typeHeading, IDC_ABOUT_TITLE);
+	m_AboutIcon.SubclassWindow(GetDlgItem(IDC_ABOUT_ICON));
+	if (dpiScale.cx > 1.0 || dpiScale.cy > 1.0) {
+		m_AboutIcon.SetIcon(MAKEINTRESOURCE(IDI_APPICON), 256, 256); //load hi-def icon
+	}
+	else {
+		m_AboutIcon.SetIcon(MAKEINTRESOURCE(IDI_APPICON), 48, 48);   //load regular icon
+	}
+	m_AboutIcon.SetWindowPos(HWND_TOP, 0, 0, iconSz.cx, iconSz.cy, SWP_NOMOVE | SWP_NOZORDER);
+
+	m_Tabs.Attach(GetDlgItem(IDC_TABS));
+	AddTab(wGS(ABOUT_TAB_ABOUT).c_str(), new CAboutTab(IDD_TAB_ABOUT));
+	AddTab(wGS(ABOUT_TAB_CONTRIBUTORS).c_str(), new CAboutContributersTab);
+	AddTab(wGS(ABOUT_TAB_FUNDERS).c_str(), new CAboutFundersTab);
+	AddTab(wGS(ABOUT_TAB_CREDITS).c_str(), new CAboutCreditsTab);
+	return 0;
+}
+
+CRect CAboutDlg::GetTabRect()
+{
+	CRect TabRect;
+	m_Tabs.GetWindowRect(&TabRect);
+	ScreenToClient(&TabRect);
+	m_Tabs.AdjustRect(FALSE, &TabRect);
+	return TabRect;
+}
+
+void CAboutDlg::AddTab(const wchar_t * caption, CAboutTab * tab)
+{
+	m_Tabs.AddItem(caption);
+	tab->Create(m_hWnd, 0);
+	tab->SetWindowPos(m_hWnd, 0, 0, 0, 0, SWP_HIDEWINDOW);
+	m_TabWindows.push_back(tab);
+
+	if (m_TabWindows.size() == 1)
+	{
+		ShowTab(0);
+	}
+}
+
+void CAboutDlg::ShowTab(int nPage)
+{
+	for (size_t i = 0; i < m_TabWindows.size(); i++)
+	{
+		m_TabWindows[i]->ShowWindow(SW_HIDE);
+	}
+
+	CRect TabRect = GetTabRect();
+	m_TabWindows[nPage]->SetWindowPos(HWND_TOP, TabRect.left, TabRect.top, TabRect.Width(), TabRect.Height(), SWP_SHOWWINDOW);
+	
+	CRect WinRect, ClientRect;
+	m_TabWindows[nPage]->GetWindowRect(WinRect);
+	m_TabWindows[nPage]->GetClientRect(ClientRect);
+
+	m_Tabs.RedrawWindow();
+}
+
+LRESULT CAboutDlg::OnTabChange(NMHDR* /*pNMHDR*/)
+{
+	ShowTab(m_Tabs.GetCurSel());
+	return FALSE;
+}
+
+LRESULT CAboutDlg::OnOK(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	EndDialog(wID);
+	return 0;
+}
+
+LRESULT CAboutDlg::OnCancel(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	EndDialog(wID);
+	return 0;
+}
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/About.h b/GLideN64/src/GLideNUI-wtl/About.h
new file mode 100644
index 00000000..9274a883
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/About.h
@@ -0,0 +1,60 @@
+#pragma once
+#include "wtl.h"
+#include "wtl-WindowFont.h"
+#include "wtl-BitmapPicture.h"
+#include "resource.h"
+#include <vector>
+
+
+class CAboutTab :
+	public CDialogImpl<CAboutTab>
+{
+public:
+	CAboutTab(uint32_t _IDD);
+	virtual ~CAboutTab();
+
+	BEGIN_MSG_MAP(CAboutTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+	END_MSG_MAP()
+
+	uint32_t IDD;
+
+protected:
+	BOOL OnInitDialog(CWindow wndFocus, LPARAM lInitParam);
+	LRESULT OnColorStatic(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
+
+	CWindowFont m_SubtitleFont;
+};
+
+class CAboutDlg :
+	public CDialogImpl<CAboutDlg>
+{
+public:
+	~CAboutDlg();
+
+	enum { IDD = IDD_ABOUT };
+
+	BEGIN_MSG_MAP_EX(CAboutDlg)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_ID_HANDLER(IDOK, OnOK)
+		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
+		NOTIFY_HANDLER_EX(IDC_TABS, TCN_SELCHANGE, OnTabChange)
+	END_MSG_MAP()
+
+protected:
+	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
+	LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnTabChange(NMHDR* pNMHDR);
+
+	void AddTab(const wchar_t * caption, CAboutTab *);
+	void ShowTab(int nPage);
+	CRect GetTabRect();
+
+	CWindowFont m_TitleFont;
+	CBitmapPicture m_AboutIcon;
+	CTabCtrl m_Tabs;
+	std::vector<CAboutTab *> m_TabWindows;
+};
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp b/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp
new file mode 100644
index 00000000..2889704d
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp
@@ -0,0 +1,432 @@
+#pragma once
+#include "wtl.h"
+#include "ConfigDlg.h"
+#include "../Config.h"
+#include "Settings.h"
+#include "config-video.h"
+#include "config-emulation.h"
+#include "config-framebuffer.h"
+#include "config-texture.h"
+#include "config-osd.h"
+#include "config-debug.h"
+#include "util.h"
+#include "InputDialog.h"
+#include "Language.h"
+
+CConfigDlg::CConfigDlg() :
+	m_blockReInit(false),
+	m_EmulationTab(NULL),
+	m_Saved(false),
+	m_TabLeft(0),
+	m_ProfileLeft(0)
+{
+}
+
+CConfigDlg::~CConfigDlg() {
+	m_EmulationTab = NULL;
+	for (size_t i = 0; i < m_TabWindows.size(); i++)
+		delete m_TabWindows[i];
+	m_TabWindows.clear();
+}
+
+void CConfigDlg::setIniPath(const std::string & IniPath) {
+	m_strIniPath = IniPath;
+}
+
+void CConfigDlg::setRomName(const char * RomName) {
+	m_romName = RomName == NULL || strlen(RomName) == 0 ? NULL : RomName;
+}
+
+LRESULT CConfigDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/) {
+	HICON hIcon = AtlLoadIconImage(IDI_APPICON, LR_DEFAULTCOLOR, ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON));
+	SetIcon(hIcon, TRUE);
+	HICON hIconSmall = AtlLoadIconImage(IDI_APPICON, LR_DEFAULTCOLOR, ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));
+	SetIcon(hIconSmall, FALSE);
+
+	m_FrameBufferTab = new CFrameBufferTab();
+	m_VideoTab = new CVideoTab(*this, *m_FrameBufferTab, m_strIniPath.c_str());
+	m_EmulationTab = new CEmulationTab(*this);
+	m_OsdTab = new COsdTab();
+
+	m_Tabs.Attach(GetDlgItem(IDC_TABS));
+	AddTab(TAB_VIDEO, m_VideoTab);
+	AddTab(TAB_EMULATION, m_EmulationTab);
+	AddTab(TAB_FRAME_BUFFER, m_FrameBufferTab);
+	AddTab(TAB_TEXTURE_ENHANCEMENT, new CTextureEnhancementTab);
+	AddTab(TAB_OSD, m_OsdTab);
+#ifdef DEBUG_DUMP
+	AddTab(TAB_DEBUG, new CDebugTab);
+#endif
+
+	RECT Rect;
+	GetDlgItem(IDC_TABS).GetWindowRect(&Rect);
+	::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+	m_TabLeft = Rect.left;
+
+	if (m_romName != NULL) {
+		std::wstring RomName(ToUTF16(m_romName));
+		CWindow dlgItem = GetDlgItem(IDC_GAME_PROFILE_NAME);
+		CDC dc;
+		dc.CreateCompatibleDC(NULL);
+		dc.SelectFont(dlgItem.GetFont());
+		SIZE size;
+		dc.GetTextExtent(RomName.c_str(), RomName.length(), &size);
+
+		RECT Rect;
+		dlgItem.GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+		Rect.right = Rect.left + size.cx;
+		dlgItem.MoveWindow(&Rect);
+		dlgItem.SetWindowText(RomName.c_str());
+
+		m_ProfileLeft = Rect.right + 10;
+
+		CButton(GetDlgItem(IDC_GAME_PROFILE)).SetCheck(BST_CHECKED);
+		CButton(GetDlgItem(IDC_USE_PROFILE)).SetCheck(BST_UNCHECKED);
+	} else {
+		CButton(GetDlgItem(IDC_GAME_PROFILE)).SetCheck(BST_UNCHECKED);
+		CButton(GetDlgItem(IDC_USE_PROFILE)).SetCheck(BST_CHECKED);
+		GetDlgItem(IDC_SETTINGS_PROFILE_STATIC).GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+		m_ProfileLeft = Rect.left;
+	}
+
+	ProfileList Profiles = getProfiles(m_strIniPath.c_str());
+	std::string CurrentProfile = getCurrentProfile(m_strIniPath.c_str());
+	CComboBox profilesComboBox(GetDlgItem(IDC_PROFILE));
+	profilesComboBox.ResetContent();
+	for (ProfileList::const_iterator itr = Profiles.begin(); itr != Profiles.end(); itr++) {
+		int Index = profilesComboBox.AddString(ToUTF16(itr->c_str()).c_str());
+		if (CurrentProfile == *itr)
+			profilesComboBox.SetCurSel(Index);
+	}
+	profilesComboBox.AddString(L"New...");
+	GetDlgItem(IDC_REMOVE_PROFILE).EnableWindow(profilesComboBox.GetCount() > 2);
+	Init();
+	return 0;
+}
+
+void CConfigDlg::OnCustomSettingsToggled(bool checked) {
+	if (m_hWnd == NULL)
+		return;
+
+	checked = m_romName != NULL ? checked : false;
+	GetDlgItem(IDC_GAME_PROFILE).ShowWindow(checked ? SW_SHOWNORMAL : SW_HIDE);
+	GetDlgItem(IDC_SAVE_SETTINGS_STATIC).ShowWindow(checked ? SW_SHOWNORMAL : SW_HIDE);
+	GetDlgItem(IDC_GAME_PROFILE_NAME).ShowWindow(checked ? SW_SHOWNORMAL : SW_HIDE);
+	GetDlgItem(IDC_USE_PROFILE).ShowWindow(checked ? SW_SHOWNORMAL : SW_HIDE);
+
+	int32_t Move = 0;
+	if (checked) {
+		RECT Rect;
+		CWindow UseProfile = GetDlgItem(IDC_USE_PROFILE);
+		UseProfile.GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+		Move = Rect.left - m_ProfileLeft;
+		if (Move != 0) {
+			Rect.left -= Move;
+			Rect.right -= Move;
+			UseProfile.MoveWindow(&Rect);
+		}
+		uint32_t Left = Rect.right + 2;
+
+		CWindow ProfileStatic = GetDlgItem(IDC_SETTINGS_PROFILE_STATIC);
+		ProfileStatic.GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+		Move = Rect.left - Left;
+	} else {
+		RECT Rect;
+		GetDlgItem(IDC_SETTINGS_PROFILE_STATIC).GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+
+		Move = Rect.left - m_TabLeft;
+	}
+	if (Move != 0) {
+		int nID[] = {
+			IDC_SETTINGS_PROFILE_STATIC,
+			IDC_PROFILE,
+			IDC_REMOVE_PROFILE,
+		};
+
+		RECT Rect;
+		GetDlgItem(nID[0]).GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+
+		for (size_t i = 0, n = sizeof(nID) / sizeof(nID[0]); i < n; i++) {
+			CWindow window = GetDlgItem(nID[i]);
+			window.GetWindowRect(&Rect);
+			::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+
+			Rect.left -= Move;
+			Rect.right -= Move;
+			window.MoveWindow(&Rect);
+		}
+	}
+}
+
+LRESULT CConfigDlg::OnProfileChanged(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hwnd*/, BOOL& /*bHandled*/) {
+	CComboBox profilesComboBox(GetDlgItem(IDC_PROFILE));
+	int nIndex = profilesComboBox.GetCurSel();
+	if (nIndex < 0) { return 0; }
+
+	int nLen = profilesComboBox.GetLBTextLen(nIndex);
+	if (nLen == CB_ERR) { return FALSE; }
+
+	std::wstring Profile;
+	Profile.resize(nLen);
+	profilesComboBox.GetLBText(nIndex, (wchar_t *)Profile.data());
+
+	CButton(GetDlgItem(IDC_USE_PROFILE)).SetCheck(BST_CHECKED);
+	CButton(GetDlgItem(IDC_GAME_PROFILE)).SetCheck(BST_UNCHECKED);
+	if (Profile == L"New...") {
+		bool ok;
+		std::string switchToProfile = getCurrentProfile(m_strIniPath.c_str());
+		std::string newProfile = FromUTF16(CInputDialog::getText(L"New Profile", L"New profile name:", ok).c_str());
+		CComboBox profilesComboBox(GetDlgItem(IDC_PROFILE));
+		if (ok) {
+			ProfileList Profiles = getProfiles(m_strIniPath.c_str());
+			if (strcmp(newProfile.c_str(), "New...") == 0) {
+				MessageBox(L"New settings profiles cannot be called \"New...\".", L"New Profile", MB_OK | MB_ICONWARNING);
+			}
+			else if (newProfile.empty()) {
+				MessageBox(L"Please type a name for your new settings profile.", L"New Profile", MB_OK | MB_ICONWARNING);
+			}
+			else if (Profiles.find(newProfile.c_str()) != Profiles.end()) {
+				MessageBox(L"This settings profile already exists.", L"New Profile", MB_OK | MB_ICONWARNING);
+			} else {
+				profilesComboBox.AddString(ToUTF16(newProfile.c_str()).c_str());
+				addProfile(m_strIniPath.c_str(), newProfile.c_str());
+				GetDlgItem(IDC_REMOVE_PROFILE).EnableWindow(profilesComboBox.GetCount() > 2);
+				switchToProfile = newProfile;
+			}
+		}
+		for (int i = 0, n = profilesComboBox.GetCount(); i < n; ++i) {
+			std::wstring Profile;
+			Profile.resize(profilesComboBox.GetLBTextLen(i) + 1);
+			profilesComboBox.GetLBText(i, (wchar_t *)Profile.data());
+
+			if (strcmp(FromUTF16(Profile.c_str()).c_str(),switchToProfile.c_str()) == 0) {
+				profilesComboBox.SetCurSel(i);
+				break;
+			}
+		}
+		return 0;
+	}
+	changeProfile(m_strIniPath.c_str(), FromUTF16(Profile.c_str()).c_str());
+	Init(true);
+	return 0;
+}
+
+void CConfigDlg::SaveSettings() {
+	m_Saved = true;
+	for (size_t i = 0; i < m_TabWindows.size(); i++)
+		m_TabWindows[i]->SaveSettings();
+    
+	if (config.generalEmulation.enableCustomSettings && CButton(GetDlgItem(IDC_GAME_PROFILE)).GetCheck() == BST_CHECKED && m_romName != nullptr)
+		saveCustomRomSettings(m_strIniPath.c_str(), m_romName);
+    else
+        writeSettings(m_strIniPath.c_str());
+    
+}
+
+LRESULT CConfigDlg::OnRestoreDefaults(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/) {
+	int Res = MessageBox(L"Are you sure you want to reset all settings to default?", L"Restore Defaults?", MB_YESNO | MB_ICONWARNING);
+	if (Res == IDYES) {
+		const u32 enableCustomSettings = config.generalEmulation.enableCustomSettings;
+		config.resetToDefaults();
+		config.generalEmulation.enableCustomSettings = enableCustomSettings;
+		setRomName(m_romName);
+		Init();
+	}
+	return 0;
+}
+
+LRESULT CConfigDlg::OnGameProfile(UINT /*Code*/, int /*id*/, HWND /*ctl*/) {
+	CButton(GetDlgItem(IDC_USE_PROFILE)).SetCheck(BST_UNCHECKED);
+	Init(true, true);
+	return 0;
+}
+
+LRESULT CConfigDlg::OnUseProfile(UINT /*Code*/, int /*id*/, HWND /*ctl*/) {
+	CButton(GetDlgItem(IDC_GAME_PROFILE)).SetCheck(BST_UNCHECKED);
+	Init(true, true);
+	return 0;
+}
+
+LRESULT CConfigDlg::OnRemoveProfile(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/) {
+	CComboBox profilesComboBox(GetDlgItem(IDC_PROFILE));
+	if (profilesComboBox.GetCount() <= 2)
+		return 0;
+
+	int nIndex = profilesComboBox.GetCurSel();
+	std::wstring profile;
+	profile.resize(profilesComboBox.GetLBTextLen(nIndex) + 1);
+	profilesComboBox.GetLBText(nIndex, (wchar_t *)profile.data());
+
+	ProfileList Profiles = getProfiles(m_strIniPath.c_str());
+	if (Profiles.find(FromUTF16(profile.c_str()).c_str()) == Profiles.end())
+		return 0;
+
+	std::wstring msg = L"Are you sure you want to remove the settings profile \"";
+	msg += profile.c_str();
+	msg += L"\"?";
+	if (MessageBox(msg.c_str(), L"Remove Profile", MB_YESNO | MB_ICONWARNING) == IDYES) {
+		removeProfile(m_strIniPath.c_str(), FromUTF16(profile.c_str()).c_str());
+		for (int i = 0, n = profilesComboBox.GetCount(); i < n; ++i) {
+			std::wstring ProfileItem;
+			ProfileItem.resize(profilesComboBox.GetLBTextLen(i) + 1);
+			profilesComboBox.GetLBText(i, (wchar_t *)ProfileItem.data());
+
+			if (wcscmp(ProfileItem.c_str(),profile.c_str()) == 0) {
+				profilesComboBox.DeleteString(i);
+				break;
+			}
+		}
+		for (int i = 0, n = profilesComboBox.GetCount(); i < n; ++i) {
+			std::wstring ProfileItem;
+			ProfileItem.resize(profilesComboBox.GetLBTextLen(i) + 1);
+			profilesComboBox.GetLBText(i, (wchar_t *)ProfileItem.data());
+			if (wcscmp(ProfileItem.c_str(),L"New...") != 0) {
+				profilesComboBox.SetCurSel(i);
+				changeProfile(m_strIniPath.c_str(), FromUTF16(ProfileItem.c_str()).c_str());
+				Init(true);
+				break;
+			}
+		}
+		GetDlgItem(IDC_REMOVE_PROFILE).EnableWindow(profilesComboBox.GetCount() > 2);
+	}
+	return 0;
+}
+
+LRESULT CConfigDlg::OnSaveClose(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/) {
+	SaveSettings();
+	EndDialog(wID);
+	return 0;
+}
+
+LRESULT CConfigDlg::OnSave(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/) {
+	SaveSettings();
+	return 0;
+}
+
+LRESULT CConfigDlg::OnTabChange(NMHDR* /*pNMHDR*/) {
+	ShowTab(m_Tabs.GetCurSel());
+	return FALSE;
+}
+
+LRESULT CConfigDlg::OnCancel(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/) {
+	EndDialog(wID);
+	return 0;
+}
+
+void CConfigDlg::Init(bool reInit, bool blockCustomSettings) {
+	if (m_blockReInit)
+		return;
+
+	m_blockReInit = true;
+	bool CustomSettings = m_EmulationTab != NULL && CButton(m_EmulationTab->GetDlgItem(IDC_CHK_USE_PER_GAME)).GetCheck() == BST_CHECKED;
+
+	if (reInit && m_romName != NULL && CustomSettings && CButton(m_EmulationTab->GetDlgItem(IDC_GAME_PROFILE)).GetCheck() == BST_CHECKED) {
+		loadCustomRomSettings(m_strIniPath.c_str(), m_romName);
+	} else if (reInit) {
+		loadSettings(m_strIniPath.c_str());
+	}
+
+	for (size_t i = 0; i < m_TabWindows.size(); i++)
+		m_TabWindows[i]->LoadSettings(blockCustomSettings);
+
+	for (size_t i = 0; i < m_TabWindows.size(); i++)
+		m_TabWindows[i]->ApplyLanguage();
+	ApplyLanguage();
+	m_blockReInit = false;
+}
+
+CRect CConfigDlg::GetTabRect() {
+	CRect TabRect;
+	m_Tabs.GetWindowRect(&TabRect);
+	ScreenToClient(&TabRect);
+	m_Tabs.AdjustRect(FALSE, &TabRect);
+	return TabRect;
+}
+
+void CConfigDlg::AddTab(languageStringID caption, CConfigTab * tab) {
+	m_Tabs.AddItem(TCIF_TEXT | TCIF_PARAM, wGS(caption).c_str(), 0, caption);
+	tab->Create(m_hWnd, 0);
+	tab->SetWindowPos(m_hWnd, 0, 0, 0, 0, SWP_HIDEWINDOW);
+	m_TabWindows.push_back(tab);
+
+	if (m_TabWindows.size() == 1)
+		ShowTab(0);
+}
+
+void CConfigDlg::ShowTab(int nPage) {
+	if (nPage == 4 && !m_OsdTab->m_FontsLoaded) { // OSD tab
+		m_OsdTab->LoadFonts();
+	}
+
+	for (size_t i = 0; i < m_TabWindows.size(); i++)
+		m_TabWindows[i]->ShowWindow(SW_HIDE);
+
+	CRect TabRect = GetTabRect();
+	m_TabWindows[nPage]->SetWindowPos(HWND_TOP, TabRect.left, TabRect.top, TabRect.Width(), TabRect.Height(), SWP_SHOWWINDOW);
+
+	CRect WinRect, ClientRect;
+	m_TabWindows[nPage]->GetWindowRect(WinRect);
+	m_TabWindows[nPage]->GetClientRect(ClientRect);
+
+	m_Tabs.RedrawWindow();
+}
+
+void CConfigDlg::SetLanguage(const std::string & language) {
+	LoadCurrentStrings(m_strIniPath.c_str(), language);
+	for (int i = 0, n = m_Tabs.GetItemCount(); i < n; i++) {
+		TCITEM tci = { 0 };
+		tci.mask = TCIF_PARAM;
+		m_Tabs.GetItem(i, &tci);
+		if (tci.lParam != 0) {
+			tci.mask = TCIF_TEXT;
+			std::wstring caption = wGS((languageStringID)tci.lParam);
+			tci.pszText = (LPWSTR)caption.c_str();
+			m_Tabs.SetItem(i, &tci);
+		}
+	}
+	for (size_t i = 0; i < m_TabWindows.size(); i++) 
+		m_TabWindows[i]->ApplyLanguage();
+	ApplyLanguage();
+}
+
+void CConfigDlg::ApplyLanguage(void)
+{
+	SetDlgItemTextW(IDC_SAVE_SETTINGS_STATIC, wGS(CFG_SAVE_SETTINGS_FOR).c_str());
+	SetDlgItemTextW(IDC_SETTINGS_PROFILE_STATIC, wGS(CFG_SETTINGS_PROFILE).c_str());
+	SetDlgItemTextW(IDC_REMOVE_PROFILE, wGS(CFG_REMOVE).c_str());
+	SetDlgItemTextW(ID_RESTORE_DEFAULTS, wGS(CFG_RESTORE_DEFAULTS).c_str());
+	SetDlgItemTextW(ID_SAVECLOSE, wGS(CFG_SAVE_AND_CLOSE).c_str());
+	SetDlgItemTextW(ID_SAVE, wGS(CFG_SAVE).c_str());
+	SetDlgItemTextW(IDCANCEL, wGS(CFG_CLOSE).c_str());
+}
+
+class GlideN64WtlModule :
+	public CAppModule
+{
+public:
+	GlideN64WtlModule(HINSTANCE hinst) {
+		Init(NULL, hinst);
+	}
+	virtual ~GlideN64WtlModule(void) {
+		Term();
+	}
+};
+
+GlideN64WtlModule * WtlModule = NULL;
+
+void ConfigInit(void * hinst) {
+	WtlModule = new GlideN64WtlModule((HINSTANCE)hinst);
+}
+
+void ConfigCleanup(void) {
+	if (WtlModule) {
+		delete WtlModule;
+		WtlModule = NULL;
+	}
+}
diff --git a/GLideN64/src/GLideNUI-wtl/ConfigDlg.h b/GLideN64/src/GLideNUI-wtl/ConfigDlg.h
new file mode 100644
index 00000000..4874aa25
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/ConfigDlg.h
@@ -0,0 +1,77 @@
+#pragma once
+#include <string>
+#include "wtl.h"
+#include "config-tab.h"
+#include "language.h"
+#include "resource.h"
+#include <vector>
+
+class CFrameBufferTab;
+class CVideoTab;
+class CEmulationTab;
+class COsdTab;
+
+class CConfigDlg :
+	public CDialogImpl<CConfigDlg>
+{
+public:
+	CConfigDlg();
+	~CConfigDlg();
+
+	enum { IDD = IDD_CONFIG };
+
+	BEGIN_MSG_MAP_EX(CConfigDlg)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		NOTIFY_HANDLER_EX(IDC_TABS, TCN_SELCHANGE, OnTabChange)
+		COMMAND_HANDLER(IDC_PROFILE, CBN_SELCHANGE, OnProfileChanged)
+		COMMAND_HANDLER_EX(IDC_GAME_PROFILE, BN_CLICKED, OnGameProfile)
+		COMMAND_HANDLER_EX(IDC_USE_PROFILE, BN_CLICKED, OnUseProfile)
+		COMMAND_ID_HANDLER(IDC_REMOVE_PROFILE, OnRemoveProfile)		
+		COMMAND_ID_HANDLER(ID_RESTORE_DEFAULTS, OnRestoreDefaults)
+		COMMAND_ID_HANDLER(ID_SAVECLOSE, OnSaveClose)
+		COMMAND_ID_HANDLER(ID_SAVE, OnSave)
+		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
+	END_MSG_MAP()
+
+	void setIniPath(const std::string & IniPath);
+	void setRomName(const char * RomName);
+	bool Saved(void) const { return m_Saved; }
+	void OnCustomSettingsToggled(bool checked);
+	void SetLanguage(const std::string & language);
+
+protected:
+	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
+	LRESULT OnRemoveProfile(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnRestoreDefaults(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnSaveClose(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnSave(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnTabChange(NMHDR* pNMHDR);
+	LRESULT OnProfileChanged(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& bHandled);
+	LRESULT OnGameProfile(UINT /*Code*/, int id, HWND /*ctl*/);
+	LRESULT OnUseProfile(UINT /*Code*/, int id, HWND /*ctl*/);
+
+	void Init(bool reInit = false, bool blockCustomSettings = false);
+	void AddTab(languageStringID StringID, CConfigTab * tab);
+	void ShowTab(int nPage);
+	CRect GetTabRect();
+	void SaveSettings();
+	void ApplyLanguage();
+
+	CTabCtrl m_Tabs;
+	std::vector<CConfigTab *> m_TabWindows;
+	std::string m_strIniPath;
+	const char * m_romName;
+	bool m_blockReInit;
+	CFrameBufferTab * m_FrameBufferTab;
+	CVideoTab * m_VideoTab;
+	CEmulationTab * m_EmulationTab;
+	COsdTab * m_OsdTab;
+	uint32_t m_TabLeft, m_ProfileLeft;
+	bool m_Saved;
+};
+
+#ifdef _WIN32
+void ConfigInit(void * hinst);
+void ConfigCleanup(void);
+#endif
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/FileClass.cpp b/GLideN64/src/GLideNUI-wtl/FileClass.cpp
new file mode 100644
index 00000000..14098852
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/FileClass.cpp
@@ -0,0 +1,350 @@
+#include "FileClass.h"
+#ifdef _WIN32
+#include <io.h>
+#define USE_WINDOWS_API
+#include <Windows.h>
+#else
+#include <unistd.h>
+#endif
+
+#if defined(_MSC_VER)
+#include <crtdbg.h>
+#else
+#define _ASSERTE(expr)		  ((void)0)
+#endif
+
+CFile::CFile() :
+#ifdef USE_WINDOWS_API
+m_hFile(INVALID_HANDLE_VALUE),
+#else
+m_hFile(NULL),
+#endif
+m_bCloseOnDelete(false)
+{
+}
+
+CFile::CFile(void * hFile) :
+m_hFile(hFile),
+m_bCloseOnDelete(true)
+{
+	if (hFile == 0)
+	{
+		_ASSERTE(hFile != 0);
+	}
+}
+
+CFile::CFile(const char * lpszFileName, uint32_t nOpenFlags) :
+#ifdef USE_WINDOWS_API
+m_hFile(INVALID_HANDLE_VALUE),
+#else
+m_hFile(NULL),
+#endif
+m_bCloseOnDelete(true)
+{
+	Open(lpszFileName, nOpenFlags);
+}
+
+CFile::~CFile()
+{
+#ifdef USE_WINDOWS_API
+	if (m_hFile != INVALID_HANDLE_VALUE && m_bCloseOnDelete)
+#else
+	if (m_hFile != NULL && m_bCloseOnDelete)
+#endif
+	{
+		Close();
+}
+}
+
+bool CFile::Open(const char * lpszFileName, uint32_t nOpenFlags)
+{
+	if (!Close())
+	{
+		return false;
+	}
+
+	if (lpszFileName == NULL || strlen(lpszFileName) == 0)
+	{
+		return false;
+	}
+
+	m_bCloseOnDelete = true;
+#ifdef USE_WINDOWS_API
+	m_hFile = INVALID_HANDLE_VALUE;
+
+	ULONG dwAccess = 0;
+	switch (nOpenFlags & 3)
+	{
+	case modeRead:
+		dwAccess = GENERIC_READ;
+		break;
+	case modeWrite:
+		dwAccess = GENERIC_WRITE;
+		break;
+	case modeReadWrite:
+		dwAccess = GENERIC_READ | GENERIC_WRITE;
+		break;
+	default:
+		_ASSERTE(false);
+	}
+
+	// map share mode
+	ULONG dwShareMode = 0;
+
+	dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;
+	if ((nOpenFlags & shareDenyWrite) == shareDenyWrite) { dwShareMode &= ~FILE_SHARE_WRITE; }
+	if ((nOpenFlags & shareDenyRead) == shareDenyRead)   { dwShareMode &= ~FILE_SHARE_READ; }
+	if ((nOpenFlags & shareExclusive) == shareExclusive) { dwShareMode = 0; }
+
+	// map modeNoInherit flag
+	SECURITY_ATTRIBUTES sa;
+	sa.nLength = sizeof(sa);
+	sa.lpSecurityDescriptor = NULL;
+	sa.bInheritHandle = (nOpenFlags & modeNoInherit) == 0;
+
+	// map creation flags
+	ULONG dwCreateFlag = OPEN_EXISTING;
+	if (nOpenFlags & modeCreate)
+	{
+		dwCreateFlag = ((nOpenFlags & modeNoTruncate) != 0) ? OPEN_ALWAYS : CREATE_ALWAYS;
+	}
+
+	// attempt file creation
+	HANDLE hFile = ::CreateFileA(lpszFileName, dwAccess, dwShareMode, &sa, dwCreateFlag, FILE_ATTRIBUTE_NORMAL, NULL);
+	if (hFile == INVALID_HANDLE_VALUE)
+	{ //#define ERROR_PATH_NOT_FOUND			 3L
+		//ULONG err = GetLastError();
+		return false;
+	}
+	m_hFile = hFile;
+#else
+	if ((nOpenFlags & modeNoTruncate) == 0 && (nOpenFlags & CFileBase::modeCreate) == CFileBase::modeCreate)
+	{
+		CPath(lpszFileName).Delete();
+	}
+	if ((nOpenFlags & CFileBase::modeCreate) != CFileBase::modeCreate)
+	{
+		if (!CPath(lpszFileName).Exists())
+		{
+			return false;
+		}
+	}
+
+	if ((nOpenFlags & CFileBase::modeCreate) == CFileBase::modeCreate)
+	{
+		CPath file(lpszFileName);
+		if (!file.Exists())
+		{
+			FILE * fp = fopen(lpszFileName,"wb");
+			if (fp)
+			{
+				fclose(fp);
+			}
+			if (!file.Exists())
+			{
+				return false;
+			}
+		}
+	}
+
+	if ((nOpenFlags & CFileBase::modeWrite) == CFileBase::modeWrite ||
+		(nOpenFlags & CFileBase::modeReadWrite) == CFileBase::modeReadWrite)
+	{
+		m_hFile = fopen(lpszFileName, "rb+");
+		if (m_hFile != NULL)
+		{
+			SeekToBegin();
+		}
+	}
+	else if ((nOpenFlags & CFileBase::modeRead) == CFileBase::modeRead)
+	{
+		m_hFile = fopen(lpszFileName, "rb");
+		if (m_hFile != NULL)
+		{
+			SeekToBegin();
+		}
+	}
+	else
+	{
+		return false;
+	}
+#endif
+	m_bCloseOnDelete = true;
+	return true;
+}
+
+bool CFile::Close()
+{
+	bool bError = true;
+#ifdef USE_WINDOWS_API
+	if (m_hFile != INVALID_HANDLE_VALUE)
+	{
+		bError = !::CloseHandle(m_hFile);
+	}
+	m_hFile = INVALID_HANDLE_VALUE;
+#else
+	if (m_hFile != NULL)
+	{
+		fclose((FILE *)m_hFile);
+		m_hFile = NULL;
+	}
+#endif
+	m_bCloseOnDelete = false;
+	return bError;
+}
+
+uint32_t CFile::SeekToEnd(void)
+{
+	return Seek(0, CFile::end);
+}
+
+void CFile::SeekToBegin(void)
+{
+	Seek(0, CFile::begin);
+}
+
+bool CFile::IsOpen(void) const
+{
+#ifdef USE_WINDOWS_API
+	return m_hFile != INVALID_HANDLE_VALUE;
+#else
+	return m_hFile != NULL;
+#endif
+}
+
+bool CFile::Flush()
+{
+#ifdef USE_WINDOWS_API
+	if (m_hFile == INVALID_HANDLE_VALUE)
+	{
+		return true;
+	}
+
+	return ::FlushFileBuffers(m_hFile) != 0;
+#else
+	fflush((FILE *)m_hFile);
+	fsync(fileno((FILE *)m_hFile));
+	return true;
+#endif
+}
+
+bool CFile::Write(const void* lpBuf, uint32_t nCount)
+{
+	if (nCount == 0)
+	{
+		return true;	 // avoid Win32 "null-write" option
+	}
+
+#ifdef USE_WINDOWS_API
+	ULONG nWritten = 0;
+	if (!::WriteFile(m_hFile, lpBuf, nCount, &nWritten, NULL))
+	{
+		return false;
+	}
+
+	if (nWritten != nCount)
+	{
+		// Win32s will not return an error all the time (usually DISK_FULL)
+		return false;
+	}
+#else
+	if (fwrite(lpBuf, 1, nCount, (FILE *)m_hFile) != nCount)
+	{
+		return false;
+	}
+#endif
+	return true;
+}
+
+uint32_t CFile::Read(void* lpBuf, uint32_t nCount)
+{
+	if (nCount == 0)
+	{
+		return 0;   // avoid Win32 "null-read"
+	}
+
+#ifdef USE_WINDOWS_API
+	DWORD dwRead = 0;
+	if (!::ReadFile(m_hFile, lpBuf, nCount, &dwRead, NULL))
+	{
+		return 0;
+	}
+	return (uint32_t)dwRead;
+#else
+	uint32_t res = fread(lpBuf, sizeof(uint8_t), nCount, (FILE *)m_hFile);
+	return res;
+#endif
+}
+
+int32_t CFile::Seek(int32_t lOff, SeekPosition nFrom)
+{
+#ifdef USE_WINDOWS_API
+	ULONG dwNew = ::SetFilePointer(m_hFile, lOff, NULL, (ULONG)nFrom);
+	if (dwNew == (ULONG)-1)
+	{
+		return -1;
+	}
+	return dwNew;
+#else
+	if (m_hFile == NULL)
+	{
+		return -1;
+	}
+	int origin;
+
+	switch (nFrom)
+	{
+	case begin: origin = SEEK_SET; break;
+	case current: origin = SEEK_CUR; break;
+	case end: origin = SEEK_END; break;
+	default:
+		return -1;
+	}
+
+	Flush();
+	int res = fseek((FILE *)m_hFile, lOff, origin);
+	return res;
+#endif
+}
+
+uint32_t CFile::GetPosition() const
+{
+#ifdef USE_WINDOWS_API
+	return ::SetFilePointer(m_hFile, 0, NULL, FILE_CURRENT);
+#else
+	return (uint32_t)ftell((FILE *)m_hFile);
+#endif
+}
+
+bool CFile::SetLength(uint32_t dwNewLen)
+{
+	Seek((int32_t)dwNewLen, begin);
+	return SetEndOfFile();
+}
+
+uint32_t CFile::GetLength() const
+{
+#ifdef USE_WINDOWS_API
+	return GetFileSize(m_hFile, 0);
+#else
+	uint32_t pos = GetPosition();
+	fseek((FILE *)m_hFile, 0, SEEK_END);
+	uint32_t FileSize = GetPosition();
+	fseek((FILE *)m_hFile, (int32_t)pos, SEEK_SET);
+	return FileSize;
+#endif
+}
+
+bool CFile::SetEndOfFile()
+{
+#ifdef USE_WINDOWS_API
+	return ::SetEndOfFile(m_hFile) != 0;
+#else
+	Flush();
+#ifdef _WIN32
+	return _chsize(_fileno((FILE *)m_hFile),GetPosition()) == 0;
+#else
+	return ftruncate(fileno((FILE *)m_hFile),GetPosition()) == 0;
+#endif
+#endif
+}
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/FileClass.h b/GLideN64/src/GLideNUI-wtl/FileClass.h
new file mode 100644
index 00000000..81413424
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/FileClass.h
@@ -0,0 +1,81 @@
+#pragma once
+
+#include <stdint.h>
+
+class CFileBase
+{
+public:
+	enum OpenFlags
+	{
+		modeRead =		  0x0000,
+		modeWrite =		 0x0001,
+		modeReadWrite =	 0x0002,
+		shareCompat =	   0x0000,
+		shareExclusive =	0x0010,
+		shareDenyWrite =	0x0020,
+		shareDenyRead =	 0x0030,
+		shareDenyNone =	 0x0040,
+		modeNoInherit =	 0x0080,
+		modeCreate =		0x1000,
+		modeNoTruncate =	0x2000,
+	};
+
+	enum SeekPosition { begin = 0x0, current = 0x1, end = 0x2 };
+
+	virtual bool Open(const char * lpszFileName, uint32_t nOpenFlags ) = 0;
+
+	virtual uint32_t GetPosition() const = 0;
+	virtual int32_t Seek(int32_t lOff, SeekPosition nFrom) = 0;
+	virtual bool SetLength(uint32_t dwNewLen) = 0;
+	virtual uint32_t GetLength() const = 0;
+
+	virtual uint32_t Read(void* lpBuf, uint32_t nCount) = 0;
+	virtual bool Write(const void* lpBuf, uint32_t nCount) = 0;
+
+	virtual bool Flush() = 0;
+	virtual bool Close() = 0;
+	virtual bool IsOpen() const = 0;
+	virtual bool SetEndOfFile() = 0;
+};
+
+class CFile : public CFileBase
+{
+	// Attributes
+	void *  m_hFile;
+	bool	m_bCloseOnDelete;
+
+public:
+	// Flag values
+
+	// Constructors
+	CFile();
+	CFile(void * hFile);
+	CFile(const char * lpszFileName, uint32_t nOpenFlags);
+
+	// Deconstructors
+	virtual ~CFile();
+
+	// Operations
+	virtual bool Open(const char * lpszFileName, uint32_t nOpenFlags );
+
+	uint32_t SeekToEnd   ( void );
+	void  SeekToBegin ( void );
+
+	// Overridables
+	virtual uint32_t GetPosition() const;
+	virtual int32_t Seek(int32_t lOff, SeekPosition nFrom);
+	virtual bool SetLength(uint32_t dwNewLen);
+	virtual uint32_t GetLength() const;
+
+	virtual uint32_t Read(void* lpBuf, uint32_t nCount);
+	virtual bool Write(const void* lpBuf, uint32_t nCount);
+
+	virtual bool Flush();
+	virtual bool Close();
+	virtual bool IsOpen() const;
+	virtual bool SetEndOfFile();
+
+private:
+	CFile(const CFile&);				// Disable copy constructor
+	CFile& operator=(const CFile&);		// Disable assignment
+};
diff --git a/GLideN64/src/GLideNUI-wtl/FontInfo.cpp b/GLideN64/src/GLideNUI-wtl/FontInfo.cpp
new file mode 100644
index 00000000..9388c5b2
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/FontInfo.cpp
@@ -0,0 +1,166 @@
+#include "FontInfo.h"
+#include "FileClass.h"
+#include <stdint.h>
+#include <memory>
+#include <vector>
+#include <Windows.h>
+#include <Shlobj.h>
+
+#pragma warning(disable:4996)
+
+typedef struct _tagTT_OFFSET_TABLE 
+{
+	uint16_t uMajorVersion;
+	uint16_t uMinorVersion;
+	uint16_t uNumOfTables;
+	uint16_t uSearchRange;
+	uint16_t uEntrySelector;
+	uint16_t uRangeShift;
+} TT_OFFSET_TABLE;
+
+typedef struct _tagTT_TABLE_DIRECTORY 
+{
+	char szTag[4];	   //table name
+	uint32_t uCheckSum;  //Check sum
+	uint32_t uOffset;	//Offset from beginning of file
+	uint32_t uLength;	//length of the table in bytes
+} TT_TABLE_DIRECTORY;
+
+typedef struct _tagTT_NAME_TABLE_HEADER 
+{
+	uint16_t uFSelector;  //format selector. Always 0
+	uint16_t uNRCount;	//Name Records count
+	uint16_t uStorageOffset; //Offset for strings storage, from start of the table
+} TT_NAME_TABLE_HEADER;
+
+typedef struct _tagTT_NAME_RECORD 
+{
+	uint16_t uPlatformID;
+	uint16_t uEncodingID;
+	uint16_t uLanguageID;
+	uint16_t uNameID;
+	uint16_t uStringLength;
+	uint16_t uStringOffset;	//from start of storage area
+} TT_NAME_RECORD;
+
+#define SWAPWORD(x)		MAKEWORD(HIBYTE(x), LOBYTE(x))
+#define SWAPLONG(x)		MAKELONG(SWAPWORD(HIWORD(x)), SWAPWORD(LOWORD(x)))
+
+std::string GetFontNameFromFile(const char * FontFilePath)
+{
+	CFile f;
+
+	if (!f.Open(FontFilePath, CFile::modeRead | CFile::shareDenyWrite))
+	{
+		return std::string("");
+	}
+	TT_OFFSET_TABLE ttOffsetTable;
+	f.Read(&ttOffsetTable, sizeof(TT_OFFSET_TABLE));
+	ttOffsetTable.uNumOfTables = SWAPWORD(ttOffsetTable.uNumOfTables);
+	ttOffsetTable.uMajorVersion = SWAPWORD(ttOffsetTable.uMajorVersion);
+	ttOffsetTable.uMinorVersion = SWAPWORD(ttOffsetTable.uMinorVersion);
+
+	//check is this is a true type font and the version is 1.0
+	if (ttOffsetTable.uMajorVersion != 1 || ttOffsetTable.uMinorVersion != 0)
+	{
+		return std::string("");
+	}
+
+	TT_TABLE_DIRECTORY tblDir;
+	bool bFound = false;
+	for (int i = 0; i< ttOffsetTable.uNumOfTables; i++) 
+	{
+		f.Read(&tblDir, sizeof(TT_TABLE_DIRECTORY));
+		if (_strnicmp(tblDir.szTag, "name", 4) == 0)
+		{
+			bFound = true;
+			tblDir.uLength = SWAPLONG(tblDir.uLength);
+			tblDir.uOffset = SWAPLONG(tblDir.uOffset);
+			break;
+		}
+	}
+
+	std::string res;
+	if (bFound) 
+	{
+		f.Seek(tblDir.uOffset, CFile::begin);
+		TT_NAME_TABLE_HEADER ttNTHeader;
+		f.Read(&ttNTHeader, sizeof(TT_NAME_TABLE_HEADER));
+		ttNTHeader.uNRCount = SWAPWORD(ttNTHeader.uNRCount);
+		ttNTHeader.uStorageOffset = SWAPWORD(ttNTHeader.uStorageOffset);
+		TT_NAME_RECORD ttRecord;
+		bFound = false;
+
+		for (int i = 0; i<ttNTHeader.uNRCount; i++) 
+		{
+			f.Read(&ttRecord, sizeof(TT_NAME_RECORD));
+			ttRecord.uNameID = SWAPWORD(ttRecord.uNameID);
+			if (ttRecord.uNameID == 1) 
+			{
+				ttRecord.uStringLength = SWAPWORD(ttRecord.uStringLength);
+				ttRecord.uStringOffset = SWAPWORD(ttRecord.uStringOffset);
+				int nPos = f.GetPosition();
+				f.Seek(tblDir.uOffset + ttRecord.uStringOffset + ttNTHeader.uStorageOffset, CFile::begin);
+
+				std::vector<char> NameBuf;
+				NameBuf.resize(ttRecord.uStringLength + 1);
+				memset(NameBuf.data(), 0, ttRecord.uStringLength + 1);
+				f.Read(NameBuf.data(), ttRecord.uStringLength);
+				if (NameBuf[0] != '\0')
+				{
+					res = NameBuf.data();
+					break;
+				}
+				f.Seek(nPos, CFile::begin);
+			}
+		}
+	}
+	f.Close();
+	return res;
+}
+
+std::string GetFontFolder()
+{
+	char szFontPath[MAX_PATH];
+	if (SUCCEEDED(SHGetFolderPathA(NULL, CSIDL_FONTS, NULL, 0, szFontPath)))
+	{
+		return szFontPath;
+	}
+	return "";
+}
+
+FontList GetFontFiles()
+{
+	std::string FontFolder = GetFontFolder();
+	FontList fonts;
+
+	if (FontFolder.length() > 0)
+	{
+		std::string SearchQuery = FontFolder;
+		SearchQuery += "\\*.ttf";
+
+		WIN32_FIND_DATAA FindData;
+		HANDLE hFind = FindFirstFileA(SearchQuery.c_str(), &FindData);
+		if (hFind != INVALID_HANDLE_VALUE)
+		{
+			do 
+			{
+				std::string FontFile = FontFolder;
+				FontFile += "\\";
+				FontFile += FindData.cFileName;
+				std::string FontName = GetFontNameFromFile(FontFile.c_str());
+				if (FontName.length() > 0)
+				{
+					fonts.insert(FontList::value_type(FindData.cFileName, FontName));
+				}
+			} while (FindNextFileA(hFind, &FindData));
+			FindClose(hFind);
+		}
+	}
+
+	if (fonts.size() == 0)
+	{
+		fonts.insert(FontList::value_type("arial.ttf", "Arial"));
+	}
+	return fonts;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/FontInfo.h b/GLideN64/src/GLideNUI-wtl/FontInfo.h
new file mode 100644
index 00000000..2079dca1
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/FontInfo.h
@@ -0,0 +1,10 @@
+#pragma once
+#include <string>
+#include <map>
+
+typedef std::map<std::string, std::string> FontList;
+
+FontList GetFontFiles();
+std::string GetFontFolder();
+std::string GetFontNameFromFile(const char * FontFilePath);
+
diff --git a/GLideN64/src/GLideNUI-wtl/FullscreenResolutions.h b/GLideN64/src/GLideNUI-wtl/FullscreenResolutions.h
new file mode 100644
index 00000000..fd9f1714
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/FullscreenResolutions.h
@@ -0,0 +1,10 @@
+#pragma once
+#include <vector>
+#include <string>
+
+typedef std::vector<std::string> StringList;
+
+void fillFullscreenResolutionsList(StringList & _listResolutions, int & _resolutionIdx, StringList & _listRefreshRates, int & _rateIdx);
+void fillFullscreenRefreshRateList(int _resolutionIdx, StringList & _listRefreshRates, int & _rateIdx);
+void getFullscreenResolutions(int _idx, unsigned int & _width, unsigned int & _height);
+void getFullscreenRefreshRate(int _idx, unsigned int & _rate);
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/GLideNUI.cpp b/GLideN64/src/GLideNUI-wtl/GLideNUI.cpp
new file mode 100644
index 00000000..35ba2525
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/GLideNUI.cpp
@@ -0,0 +1,93 @@
+#include "About.h"
+
+#include <thread>
+
+#include "GLideNUI.h"
+#include "Settings.h"
+#include "../Config.h"
+#include "ConfigDlg.h"
+
+#ifdef QT_STATICPLUGIN
+#include <QtPlugin>
+Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)
+Q_IMPORT_PLUGIN(QICOPlugin)
+#endif
+
+//#define RUN_DIALOG_IN_THREAD
+
+static
+int openConfigDialog(const wchar_t * _strFileName, const char * _romName, bool & _accepted)
+{
+	std::string IniFolder;
+	uint32_t slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, NULL, 0, NULL, NULL);
+	IniFolder.resize(slength);
+	slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, (LPSTR)IniFolder.c_str(), slength, NULL, NULL);
+	IniFolder.resize(slength - 1); //Remove null end char
+
+	loadSettings(IniFolder.c_str());
+	if (config.generalEmulation.enableCustomSettings != 0 && _romName != nullptr && strlen(_romName) != 0)
+		loadCustomRomSettings(IniFolder.c_str(), _romName);
+
+	LoadCurrentStrings(IniFolder.c_str(), config.translationFile);
+
+	CConfigDlg Dlg;
+	Dlg.setIniPath(IniFolder.c_str());
+	Dlg.setRomName(_romName);
+	Dlg.DoModal();
+	_accepted = Dlg.Saved();
+	return 0;
+}
+
+bool runConfigThread(const wchar_t * _strFileName, const char * _romName) {
+	bool accepted = false;
+#ifdef RUN_DIALOG_IN_THREAD
+	std::thread configThread(openConfigDialog, _strFileName, std::ref(accepted));
+	configThread.join();
+#else
+	openConfigDialog(_strFileName, _romName, accepted);
+#endif
+	return accepted;
+
+}
+
+EXPORT bool CALL RunConfig(const wchar_t * _strFileName, const char * _romName)
+{
+	return runConfigThread(_strFileName, _romName);
+}
+
+EXPORT int CALL RunAbout(const wchar_t * _strFileName)
+{
+	std::string IniFolder;
+	uint32_t slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, NULL, 0, NULL, NULL);
+	IniFolder.resize(slength);
+	slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, (LPSTR)IniFolder.c_str(), slength, NULL, NULL);
+	IniFolder.resize(slength - 1); //Remove null end char
+
+	LoadCurrentStrings(IniFolder.c_str(), config.translationFile);
+
+	CAboutDlg Dlg;
+	Dlg.DoModal();
+	return 0;
+}
+
+EXPORT void CALL LoadConfig(const wchar_t * _strFileName)
+{
+	std::string IniFolder;
+	uint32_t slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, NULL, 0, NULL, NULL);
+	IniFolder.resize(slength);
+	slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, (LPSTR)IniFolder.c_str(), slength, NULL, NULL);
+	IniFolder.resize(slength - 1); //Remove null end char
+
+	loadSettings(IniFolder.c_str());
+}
+
+EXPORT void CALL LoadCustomRomSettings(const wchar_t * _strFileName, const char * _romName)
+{
+	std::string IniFolder;
+	uint32_t slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, NULL, 0, NULL, NULL);
+	IniFolder.resize(slength);
+	slength = WideCharToMultiByte(CP_ACP, 0, _strFileName, -1, (LPSTR)IniFolder.c_str(), slength, NULL, NULL);
+	IniFolder.resize(slength - 1); //Remove null end char
+
+	loadCustomRomSettings(IniFolder.c_str(), _romName);
+}
diff --git a/GLideN64/src/GLideNUI-wtl/GLideNUI.h b/GLideN64/src/GLideNUI-wtl/GLideNUI.h
new file mode 100644
index 00000000..4e945f3d
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/GLideNUI.h
@@ -0,0 +1,26 @@
+#ifndef GLIDENUII_H
+#define GLIDENUII_H
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#ifdef _WIN32
+#define EXPORT	__declspec(dllexport)
+#define CALL	  __cdecl
+#else
+#define EXPORT	__attribute__((visibility("default")))
+#define CALL
+#endif
+
+EXPORT bool CALL RunConfig(const wchar_t * _strFileName, const char * _romName);
+EXPORT int CALL RunAbout(const wchar_t * _strFileName);
+EXPORT void CALL LoadConfig(const wchar_t * _strFileName);
+EXPORT void CALL LoadCustomRomSettings(const wchar_t * _strFileName, const char * _romName);
+EXPORT void CALL SaveScreenshot(const wchar_t * _folder, const char * _name, int _width, int _height, const unsigned char * _data);
+
+#if defined(__cplusplus)
+}
+#endif
+
+#endif // GLIDENUII_H
diff --git a/GLideN64/src/GLideNUI-wtl/GLideNUI.rc b/GLideN64/src/GLideNUI-wtl/GLideNUI.rc
new file mode 100644
index 0000000000000000000000000000000000000000..e1dbb1b10480ba56d3d57a6a034514abf274c187
GIT binary patch
literal 53324
zcmeI5YjYFFn#c8etM)r+ofk`LlMpT;u<wj-xI(axZ4z=SRjvSmupx%U&Vi)%v+wTz
z*MB{9w=|=cWC=T`D3>+TXf)mZ+;9EN|NZaP!PUWV@a^Em;K|_4;ML$%|IY?zI`^H<
zoeq8<{4{u}PaA{((BE+IeDL$&ME`Ge{!GWGI`>9Le)qfHJ<<E2K5@4fgV(y|i^0DR
z{zao)O~+4k_C(*l)YVVZwQCc<|6=gVU@cwEFF#4wJxjmi-s^+?!QtR&@Nlp>*d6Q*
zjt2*WEuG!e`v-&jgCBI}P_N$(?&{2ay^ryk!{z&n*~M`<*b!XDVf;)`dNue>>pv58
zfWwhi{YbC7TJ?t32|TuR{<{9hG1A7t+XP?#u7>~RgILVS)bYDu1tmSxx)-C3fPCEd
zavfuKLt*zs{P$9rIu#8J2Umpi6MYIkJk&dL<>}zl4k|b;c<M!h*S}S~^;CCUA8d=N
z%u|QrpNHbE4UK#(>bkE#?)yLb8}|P4NcT7p4Ik@Q5A^#_)2R1#_JPhm)Nv=#X`JzO
zJG%F-c=g`kGu``8*WJ|_|7QG(V|{C`HU+SjehPp;zSBy+(Wsk$Ia$!n<v|l1`M)NZ
zbzeD5-`~~Rcao&w>fz|GTk`%m_;MtD!Ji?<uaGN?jL{|W*9MdFW^M4J<kpX(Xv_XQ
z%f1=iSa3%3j`K;9$4|v+$Qb`2Bf8|xB((*OE|*j(XTuEn9LJ%s{vzr9SCThzHrBDL
zZ#Tu=>q);p6ismbu0G!vm%-bQbmq&%$9}yo+PRTFbG(`Ehz9>bzd&Pciks2dTROL`
zdpt<@M8^1=Z*^`n-G5t>WnG$`U*+$&HTol+<LV#uUw((|;(lBDrO$t#M%&jt_a#U6
ztFs%r`@XKmu6R&=<2y4lG7VUaU%RH?K2BB;))VsVMUqMn2Dh|k({x_l?F5fCt%dm>
zCY}B=Sz4QVeXi?~gEs}o5|UpI-ig;4y_=)40JhV*kfe7t(<A+PEzs?nX8lrgJQYPV
z0=Q%ySP)y9@n^dGt-;qiUe`Nt_Ej4H+6Zew{r3|@u|DEVeO&8Ue~eaA&av*WtAFU=
zGmUX8&46(kot5*-dgJ~ZX*EZ}CbnIi&BwK3UECciJ=A^H^!kU^eI&Ymtku4foH<K2
z)k}?WJ^c#kGA8T4nN|-JI0IB}ons!ESB|w_ufcP&#>V;vABXxo){N178`4;r-aRX*
zhS_Gg)G|7F)9WrF-R99Rg==W;nvU1gTIb=>ZXPtRZHN|kwWdwo9j^7+NsdBtlw<lj
z&K@TU*%tN=1sCJ~zTkwV0d=gJuiEr}D2{rQyrVy~LU{kRsO?uB|EMSuDTj5mB}oNc
zflG57aKDz$eN|Cfd+fbr6aGVEF^50oS@ECw`#AB+uB@QlG<uACCyl=NxCa{NC-Kox
zD?+9qRo+zN9%z+Fml*MyRtR@3KIW#z_=o<HVy`F0I})uNiCU0@-{~KXv|p|H_K2Si
z>)Ufe`mRQVWAVc9d3mi@95X;Z!-dG8twhz}J;TA=7I2t%9@x>lngv$xsqp?>Sm>LH
zuQf~#^{XA>qn?W;?V@v8*E|^gt&Vkc;6;+M$Q0x1WbnCWTgC~V3wl2ZkH2UQPxReT
z?}-dN*JtSJnXZ1Lqjl&|qx`0CU+On!>6=qU7fL!0=(ED_1$+1m>NCyVN$|g&<Q$T{
z)GIr}4&Khbq{^PCC~FkIL%aX3QGXeY+coNX(zo~Y`vYMd9fJO}HoKEXy`xWzI$dgK
z9k;95pu>H~k23r`wh{Irwnq3c;~2IrbUf0|SQs_*jZa%B#wIojGzEVj%aVI2d4oNJ
zCkq8y+xc75#-5~7slmFgxYv8dc$}-$ruBW>G`6kT;@u$$us~ZD{735mn08y;Z4F&Y
ziyHE1fB)YZY5yCNR;6T`m2T_%Vlfd<Inv#+VQpu8CVI6joS$-+L6;@P*7s{uEOuYO
z;;%um7jKpRA#Fv>@K5Qjk_LZ}Mj;ya_Y`k~0&k4;)Qtf?2DU&+gKY{gwIlkTNC~k@
z?33%713oa80JhWXq(kwN^L3%&(d+h}iFbnM>(cQ=q_Y1QTE5h`=z6@!LtXECnX7KT
z*ZsDwYj3i>u07cwSn))q@(j?&-y|uY`4?@lJlI8)ANvRUju|);15^WA)9t5n#{DoW
zp>=&^9fvHM7h3l;PiK*^=*TO1{x2%%;SFMK5u?}@R4oDRXRiW=JA#;FG4}?4)2y)C
z-|3Zn)zA9Ow~zJyC;ivnT0hjV7Pd71zm4Yq^@x8Kh1{Q-!*l)B<Nsao+0h@qB2c=W
zUYAR0e-^xn&ApfWs*}V|c(RVsm3DcXuKqr{Cv(1&Y@};?Ejh5;0=DH#EMZ48nQoJy
zCmpf4p`+zh89n%Ci7Jjq5{VY#g`SCGknN}9EoAkowGGkI?x<pTNUhl74N-t2SVV#Q
zVvE`PSzUyWSzrg<5S>Ppv5xPxS9>UVK_nu$fe7|`iaHQIwZ22E_OEpIG0>Z2ImyG1
z$8YnvWPy>Y#8Tlm#|b@yTO-}%=zI7+?HL?sg~U0K<H$<lFV8d^yzsL`d)A7PF|@Dh
zd?B%DbTnEPf4Ic`*J*b1$CU%>)ELxU5YdAFe2<Y0d1Zl<$S*iwzN7P;Awt8MjrX$y
zZcrw#byQ|Py4=y7$rc<dqJXYLra8*JCNF|W0x-2zL4=xEZFu_BGLV6&<M%monqw7E
zvFX>G718QiZ_hV#xO{o@h7xUq1^0K)v2BTsOFisJYz-<yurtT;PW-LJc8!N|>|^no
zK7#__+er#=RY`Y@C?W{;NY15jHz0u2G40<;<827bV1F}F$-a(zid<30V(+c=m}(!t
z{3h}oaNmAqxzEPozX^_|EQ53Kw#d8@N1deN>zX}0!kX+q0KNJ7c}KG3w<K8}jNXMj
zWe$B@bSwy&zrYc81@mA&x6&u$t=q<k+z8QdY`DD{ERC;5-iud_ww=e)_~*`z%qLv}
z`lc&lPtHHio}n|HfpfeSq@QCNmV{-_h!`H(hePoMnIh=nsN#++NxM0EP1JAC;Z>zo
zGVMU45jjS0*iI+U!OX6U*J~NlmUG)lx4slrx{B^+aR+v}YqMTS)}cKdTd!qacq>GL
zu-lPwj+(IY(9m$Hp~tJG5HNM_@qzdOsktqmql^H6<ymCkM!M=)zn^6e&SiQIWLQ7b
zd{-+E+wjNYq1q0+hbpV6bnJ#TR7IAS$iuw^V=M|=V8GY;^P5RFEg#DLqu)yQ)y<@1
zLjOXM7Z2a>li%`G8t1KGT-J}aDf@d-CQ)m2B(cDtX*>n2C)aHRg@2vsd{q=a-&}4d
ze0VO-xAkG7)a#3A{5FNJi?Yd`K9L*=`bM5~Q}}w4pIf3FGOI{b!#SXgq(knl3eN5E
zvE5?)4<kj|I*(dSDowCVsimg+gu3U_x}h%O8^II{>mWfDU1+)egXkQuq~$Ge4{-C1
z<fikM*-xmg!i=w*1ucTTaXF8cM5o=?%*X%MG+Mbb;*`kBpHeOwZl(@_ymYNGW35M;
zFH#F1#~hq>>1tMMi_p|by~TX1-Ai`yo1}~J!MpI+Wy?(W@fN{aDM7~9k!_Hmf*NmR
zuc>!>p$t4xWUBk98z6pEu4rA?)fNpSp_lomj*plEG~+yWjMC<Z2cic@G1{}h2JuXg
zHui<vw2`l!#cw8ticdxz04s{f>b%^rogj%ErH;WK={rI8H+?3~JZ;TXa8qr~T0gDu
z5N9oK0|F)G2ITvWExFMREg)gI_;qo(d^?H|QLB!JNBp=A4XPmxjanDQ`HO=`<dM4R
zq^)!JWK%w?aBK=EGPIp2FyeHs7lGeqvlpjJ>zccXDxgoXqNvb6l#I6*Ol{Jd@PyBC
zCS0BBTk0c!(&t~L$H<Lft#iMlk&PY^E9?O@5ZStE+Q;>sj<`Zu*rP-bO1f@Ck{r|X
zv3#asNj7Om`h{o!o)=PUK4|vUhM3FNH0O6?I2?y4m77!vP)mz!Atv#4nv3yUdxLGc
zS>q4s4DN{aFJ4I+Jbq_{0ZYJI^0o1>2!|sLs1|!A+8T<o*wOSlNlG$smJsX=z^aI<
zFKWilWIg#?EDLs(@qPY17D!zQW{L<{L1*^FZYNwoePD)oTuFUxJ-V&g5&5RtZc=|b
z$_o`yJ!Brs_hdY4Q#^2N*3hU#1j~7}p^rWXnn02$=xcp?BA7TDTF$SQq{KsrEaK&3
z<L&Dcc4p87NAsm6T}`j;d3DLTt`Vt8ttB6^Lo~AEiS@Yi@=5oI7a{FfRah9yly}`L
zoRommp*p|3>mIjD>OtX-5Kl(Z+jMj{@fjS3Z$S-ci?Z*El99$#-VyC9Y1-L&M{$>-
zRlU=Wj2v@&TIq!Gc|@jxxCQgt)XWyM&PwfCOO>ePc4onQ7v}fuTnSRk+Z%#B^*UhU
ztg+4;k|uiz14j$55t-=PG-Na0hF`~5lh@zp@vw)<RWx0a8k-tlv@NOcjQj-qK3FgF
zN$UNi-z<@d<6cQLfc^cgto~X$6Q_2C>VfDuQ!tTk>nlgRC#B;&vDyAnT>mpmlnPEG
z2U61HBGIb0WM3Ek;XSag!qs6&f~ba~n*2=P^IF<U5pQ5W*S_QeyTZwip?8QBk{6qW
zO6T#^gL0u1WPaFJHN~`7Tt`^GlF$A)(eiNc-&!Y82z=;26J0qE(6#cfWQRiI$Es0c
z*DZd+t}6Z_eg}P(l-%b@#`%`ang>#0Z2&RXqnfVAxx5Xl@CLf`BepfMlX9H~dBva(
zSE9K>o2UacP3(S|Yt2;QwRTfQTO;02n17xqfPEIV<cPh}vA-JGVOx_|ED!H{IG^O0
zHcA<7pB~{puk4tf*ClIB?kUrGyOQi<eiup5UESX1!H0>zuoLi#K9_eMIsK^7L0(0z
z+GpZ2cAaJ}%oQhS<DB(hE+0m279D3l<9u?t%Ub$P>wGN;5dA}IdDUIg*}t}J=zY-a
zAla2(;%Kd95As7uY3E$a+;6GZ$MXpGT>Tobto_$E&D1(BC<lnW6BUvDCQ415Cuj%D
z>9M|}atb;NZOC=R2dFN;C%)g(k;*D82D(*rLI0lehe#o!MQBAl^~(uodykoB=Y=z#
zO4RN}yu|fV<Z8%pJ99&ZBP!^ElfC;6S|)Qv^!AG2PTr8X4OKhtyz+D`dL7!8jJWeW
z)OncJshoEQkjn}0uaZ5|2k*Amu`8H_t?zn$R}$298zoIbeU2DW(?s^q)dY1O25!p{
zQ>;sS*OQ!E+H`F`q@L3CS7e0XoNP~b+f?P;sqZ8&3|7BP`?Pajp)I}hwX<bx@CNUs
zOjOjA&nv<AM8EZJ3d`Z{l|t`S#u0xckMl%->=|%oXFOw*A#rU25+zQ;p6)xgY|n0}
z+1}$dJjIAR%?qO(*NvQwcj-)nRBelvRPks67Ux}`{qWd<S+6ekhxNs^!tx018=RK+
zZsIH23UM_R5Ouv2_B0e2nK9nmbBH`hy`#+<)K^5tn_XA<q9r}Fd9>uXS!PbX8&U-h
ztTQ^l%O-K<&573GYz}?HTz_nh_&~fIn$c^>R~+a&YH#SJM5h&?6FbKY9q7-rSgx@x
zH(dvct|?dR`cLekS{f1?B90dl(Y1d_#B$U&WH-dmaJM_F*=}VH&MmwdX*(<sEDCIr
z=sr+Wd}zFKzKjmMTsae!N#*?dBtV>RaZ0zxJ*g3<*>aKLwOobLp=(~tna;{r<@&!%
z+U%j$56?u65P8i^F&Du><s3gGr@(KH3IT&|K50{IA9pO;RVMHc<~=WGD{8sgj!saW
z4|k9~w%6lMh0geqpUPb1T64I|l|tAZZQhHTHM(%o=>+@r@hB?jj)>uR)|tQ(-$+Gr
zr$m{(Cz^FTM@+9J@KVc=w&c1l`AKIAR&SfQ+!uqN%N6vnL$kPp6#HRniH3bg#sui2
zVLYetI-52g4m1l}<#<Tla~mcMMSiv4_QBh-?c=y(>1jQYltdzO4Soc>lHN|lvypz$
zWuOlZmNvXb=P6q-v*l^#iF;#T<L!AzL+E~B<V>t_a4ThIgC8zSJ>ikKB}c&VDPqrt
zbrtaEEL?$4=Url0tz?JYBNL9qdOZ=o$hvbq-U?R#<H3LF6Wq&w!pRs7o}71=*+22l
z5YAmbKQ45bcZP&7SMzn7leWbr?-GU6Z-y!u$0W!|BC#BcpoSSJ_VHS6C*%r!I@aYr
zU+&gG=F&Emb#T-yBBPg64YZx81gdx{e6y;cfNn`qQi6A}*s>0*2A>}5jOx|Z_<QI~
zYow?Ss5MhtW3G!A-fFFMe`~J??ck25i>@c+8TPQ_jEm0vfw04_th&QgHy)rJ*Abt8
z-jS18blxSD>phlhqL;3YckI=(HM{w~8X7o8?l-!Yct1sHnYQ`(?udKom5?Q&Wgpc<
zksTf;iOL!L{>eyUxvJn}I?z%17FGhf&hjy|Uc?sR;jk~@W@OZ|YW(&jf0#AVQ)GCZ
z>$<Dixq~MA`0zltl7EO_GE1(jJKj+G6tVjKv@WkR^X-@KGkhi9+I$P8fE(iI=(Q65
z^_rkDd{#2Ocq-@NfS7&oZaw?ynWx;Xksgi@Q+*S$gpc{B^Yra%Q_7Y&H@d>X2khR8
zsODpRL*?zb6b+9Zj8d_QZO*PWs2v-<#9y19x;=64MeNF+!1-a9%%AfvIibvUdIfj2
zjzzse=X9_>?5mD@Lv3kGNAf4KK#@c4oAX>4p$@0Z6Qrjy_2I7l#Hw<(0ZW%%c;L-8
zseP7sZa{dLer7?=w2=cMj@`ApiSMSxFrgbPBIir;)pb2ofBh*VyGH|-Ir`-bjku}z
zCxd_2U5CjE&#>u-3f4N_Bpo$}vRlwvw(7A4`m-~@k|#Fs%i0IdbX`lPTuq$gny%Ti
z4Sij{(0o#RL$iIIJQaFGuoHr=#`qfGl+2Mm73}BCnXJ>bJ%J%SX~U7<UD1k&(UJXQ
zZ-p)J@H)X2l!7ge*BfyFXeL9Xj@JkOBVG1Wbr4ZpI?a}xk2PMdKO%E|$HgLc{c?g%
zyzrtu86p+sY}(wo-6IL{*s+OU3tG@;pO?}l4YB#Zmy|@?BQL%l*)i1dEZ=9(lw0Cu
zd=9QvrqYHPTo#`_>LQ@z&`(GPc$s(+&^Og1E%3>%3M<$=WDxuHSnbCIC2xyzGe7&8
z38C38mWt7E;3d=XyguB)2tNH1Bw|`O1vmCWa^)|A`iZnqH@xs+$xgfDC$SA`Pk<(!
zF~8A#OJ3{a_&C38&PV<d16&5oN}W|o-SfbV-J5jEXV3fPftmTg4`yw7nYCBm#R?_4
z%DbN<gO9tkSGR1<dWUyGeWi@EbR{Nif6;sSmoH&wpNV@&eOM`bew_7Ff4{}i!dXfE
zT{v^CC3`Qx*D7(=nu+t|mknp;li4lnE0X{3l2wm(j4TULZfw6vFCzAf);3>6Z9KX=
zqGuUKf0O7FW8T9DGVk3^k-X*Oah93jgAqAmHu#P1D1KRN97mL09oElj_-)?DQ~Ivi
za*3F0jgykI&@%Yw-q~}Jni*a?zh=%ky3iSYQH#(mWo1?u6zg1Dx7~cPHVrW~c*tFm
zh=I;)2WI_T(wgNskptoaekwxj5iRYVE~sVgS4vXv6d|)g{I;JeFB+cS-#iY_=~2q4
zjpE5}M2xta?4F+i6#40oG0XGBEOSJ>Z+BX7J)U0fMO=F-<NB(`T-b+EF+ikXyaK9i
zJ(1;%{mk7~PdzFzQubML_CO=LdLni;6FXYImaIn%8{e@9B=LvQg>6`FN&1j`ceQj_
zDcw-*=DL8VGjHxWv3z*;jqRSbu08SC9|p3>;Mu!aoG+tD)Ex~3x4=2{LMp9^_FOi_
zvBaIRXV~8|9+PksI3m=274!I#js?9_wBkVf@`!kM(NAr|hRuYwa&JHSc_7D`x&6qC
z(@I1wkO9t~VX-c@(}umfIWLf5MIRFK3S}<0mYD$`Dp=XiVjb6&r@hG7ZonyI*`jcY
z2qP77SlGmMv4+Thu}9Dm9?m(wNVJzHGa#FCbe;Hy^AcSaQY|frmsul(CV=+fNnriq
zc6M~f%mc0wH}8gPTRWF<sO1e>$2nrE^ejcte)GwYz+0{T$?TZE%khJv$MrD2Dzyj8
z%}%;5)hmqW($!XaTMr(Iy0T4^SLJu)0>^ctpYazfqT4W)dc+oM=-b+GU6i9y^?ue_
z>y(3nyGD$AfM@XQ+LQ45ps?vx%OxeWyDxvCOkJI;n>M$*f(mv0(MdYy230b%a_sr>
zl;uDRQ}ii>F5&&@xT1Os9k2{+b&ooZFGd7MA0A`f^Bc!mp5Jn?_EcF8x+t}9wyC@Z
z5w14ItizXqv92*E@#S7!A0A&_vzx?L%&rStZEG<k{j-z-d?_q-)!;sn{&r5gZ7)*m
z6`Afn{lW9!yL1Tky8Fr7ch&~4pL(zlQ^nh-v+?1`b6}ZA=eGG{L)3W!k2kWS*`fC$
z)lTxn4C*<Z#d#?^Co-|Ir{~IhOPtyS>ZcF%TSqi=_wTI5rok53P3M-f&fMc)q)l%4
zI##qed^07l&ekmZafBYU_fKW?Ww9|0PuD#x4$sYz+`cNBC4)hQP|eTXo{iyhBx!En
zCZyQ1?Le<Gp7LNRIL?)A8{<$b`%^1yc^=uvtG!_OaU3dL)?<c887)G}WlN>DC6VVj
z!xPT~ZuP+r?G;#v{C^x{hiQBtSn8iu+|e>HW<{nab|ked&eiNRoqYu#au*#LIVdx-
zVfI(XZQr(DX5YK3>00z=&0+sIaxp~t==&DA$6q_OZGQI9I4m<&UYuSqr8$?ixD+EJ
zgY`)~%=L;jx0cZBvPi%bRw=T~PoOAav+Syx$UvQMy(gnx8Iuw_=z~lx6^>M<cC9+^
zGC7vzb4w9GYS))5!HwT;txrs6GkJ@6jL0m<b*L9(kHDcmf6M@_HUqRT&Y=f;?29ew
zgg%ONX=b+~v2o{m&<V)9h^fx|EVpt5<Jdj%@CnJSZ)-e8@O~?2YW-Trx7tyS{*lmX
zVOb!>mwkVB-$eHUYE$6?S8*(JEOyRB*Op1xMV5PcYb(bK2(EUNE;ufKM6#pwyF>>}
z!qGh*mWj7=yny3sN9ls&v=Q5ui*qCNW?@g`P+Yq&Sy6IaM2!8-^0f*Q0={yTecUIQ
ze+4`N<f>$0*BbclP-89I5+IUHyusB}=U;<6n8kitXJ5M3!wxm?FGYT=VqMN1+dDn~
zy2xYZs0#5bTYB^Nvl@R!QyHrc@2T&&eC)e>R_w5@GaU0%FffUVuE_kh;Dp6n?-KRS
zQF^o2PqVsMNX3(_v)xh7r=3fqLJ%4%xdHpv^p7k-Ph!)Ml_z`5zTbMcej6iQcemW&
z$xEl=HSqDXb{7+AeVgKp{N_k!=*2+=)S;|jx&ot*cxs^i>bQdLNZz4ObdNqr=&t%2
zI^NMAiHtlQNbjeeGIUC+uZySSxto%&cAp?$=SV5q>Ohvb_mJi%YjpLQ>Wi&LWsYqT
z=VEvgcZtK<qd4P{mq&sCIXe0Z`<Zt!o@-T&+r@HpK_mJ8SgVW(h4@(_P!E*D6Tmrp
zF_Dt4nJyL+ff9JS3LUpLwJQyZ3mVH^xEAZv<^H?@F*JiAHXkM6?|TPdO$%^nRG&~|
z<F3x80@vKsRIr#2QI8T&s&H1AoTw>dz7>^{BfKKVBd|TT#KDG>y|1YKHQkL@54Abz
zwKC)7i2I^w?(Yh7u){d6qhlS@J#}OQ)UqS_LPvY|XxY)(M>+$B;}s5pQ|MDdOqY8T
z4|VTZe(esO&|lEAWs$!je)&lE<x`etmO9v*)C3YU$WqGJxt{c48jo3(WBS+5{fGbQ
zCze7>_q8&ry_spA5ps;4u2lFB_3xc@*d^!j*4z3eqV@EEq0`alIz}%zSJ_a{Rbn=*
z@QBaj-=G_oZ}UMhXiVs6eoH2@$KFMe{R+B0Q90!LHu}A~vaQ=r&#QFR6}8i36_;(f
z5%={vBN|e2`#gB0f}CC?&SnwI#c~6S?)ym&k=-WP^rsq=CmWJoBwmxxagQge;ONe`
zW~jiabOL}+E;i;Hy3+C>C}z5x8GpiIOWNE?F`i+PIUglWNuiPLiHyLw#}oOZafs(g
zUD!axupJk4gyf>EpZ=L%HXF!KVYa2%W&JFUo6ug_LbX4Gth#L2$#cDI_;FQsmhiT_
zmcu<cDx7iT=VExg%Z8<LzLyP85x)#gyi7cm5!#F?%eouMHok0_s%L!JaAlci$kjey
zx5mfg^s|xJ^_D$~md3|#!2(6+`<aTRrQh-{+@B1KG4ES!dmp}QnHwqn4{~U%WM6a2
zUJ2P{_WU}pR(><-uZ&;2CW!FlWIO<#n~Y>ywP%9eNF1MMq};3GQ??w|w90SZ`yIT;
zCcyjl-U3(E;jNZ(wEuo_*NtTDW9Pnne|O;FU4q!K_^N2pY2&p0VY<AzTCaXKI&=tZ
z@ofB0&cT_(I(jv$*3Oje`#CC+@7jtT0l%7OICJ&V{>AL#2nSPR;hix7-}sgz|DTA$
zpQ*Bi?pwpeEATO~CpgCaWxh)^2i*C^j=sfeCF03l8KZx!?q>`|1p@U4em)zLq?A95
z6t;5rJ>uK2Z`_x3C(Vhw)lYhjtFxXRzaG1w`!~dg_Z5L4I?=j+sU60DfxT0YP}5h;
zF`(m4a>p8Xbx^A1M9iQcN^~cvWA*WyZYb521aa*&C?UJ*E@ZPoDaQhKM{<*BIyr%5
zQ`SEZ%*abbPHGj9s__`u|7%hg`8y;Oz1){iQ-6I(ng56z^K7kU^IV-xXj2jvaQAPz
z<y0+~<Nnj+6#D_|5oVK9WEs$&*gDIG(!5l}8oF2B4W;>|Io?|>FK2^N+2=HB;yywv
z=yKdb$X-<4&+;RMWh-(VW)YE%ihbyEvM<U<2=+tJ+0%~@>W2_=-uc>(Q0j-$ct&A<
zSWVX{ITBFExaJ=x<nOY4PNHaa1~*3N*1z4ldYY9&&1UIKXGrCDpUC^CnvF<6j8B|n
zws-({=l`!18Ch4XiQdm;#DRSMx@sL9kBAk;>Oy;DUmWPna+mJtg|VJ-z&J6+q~E{#
zvHHB{)sI~JpsOFxU39{eTitl2KeW10f>yFuvHG#b<@M@Eob(1(KW3jzz50=7vrJb%
z58HREA17N$%O5M`_~q12F}pYpr30QQ+jR0?qw>w<w?kE=v6Ji<>1fxdQL{wt7CMB=
zC9+mL8G=3rex8}16-VbNp8d_W?xTtB=P44@OY=+%_ApWlMt7Llt46I<JumMIh#s7$
z`lY{ThZ}e2u8hH2xGPVEpj#ES*?h}$YQIP;W5&DE#pLODj;-Zp*dde0_7(MS)>6lv
z9|u3aKb~r>PxSdmMXK&=zGOchq^t(#4)lqqPXH0ueQ`GM^118-s>Gh_pS}|>byvg2
z`9W|MD~g%sF8%e);!|7~pIgUet;p4Hv&^68KhWm_OPbo#`tM@q|Gl73?+@?4=wC(D
z_}Ze*yUyx0z&S0-tADW^EF6i_UW*FJznx8?rFs?hOv+Cevx<jW!|WKy@&9t>7mERU
zz&w{codpNs{nfM2pDqRmv(r!?{9^?dGyi!oP<p&w9DOk>xGP>h(;poYX2(XkmcT%H
zyqLA{9ILmIu5GR^=U?uAjWt}%{7YO+qpbee$Cg(AJXu1g$<DeW3ju9|^+NUdq26I3
zVJ&>B&$0h6+YMp2U0&NWtV@or1o5uMS!+Qq=gOE>z&?&c*)7<lRP-Bb;E*2ta4WVj
zJ4=Sj?y^6HdNC@W*q4cSGE^nfB!+Fj#%KY{%MFu$dOu0h3lEI_<<o0`SnK}-JP<*o

literal 0
HcmV?d00001

diff --git a/GLideN64/src/GLideNUI-wtl/GlSettings.cpp b/GLideN64/src/GLideNUI-wtl/GlSettings.cpp
new file mode 100644
index 00000000..6f9c910a
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/GlSettings.cpp
@@ -0,0 +1,261 @@
+#include "GlSettings.h"
+
+GlColor::GlColor(uint8_t Red, uint8_t Green, uint8_t Blue, uint8_t Alpha) :
+	m_Red(Red),
+	m_Green(Green),
+	m_Blue(Blue),
+	m_Alpha(Alpha)
+{
+}
+
+GlSettings::GlSettings(const char * IniFile) :
+	m_IniFile(IniFile)
+{
+	m_IniFile.SetAutoFlush(false);
+	m_CurrentSection = "General";
+}
+
+GlSettingValue GlSettings::value(const char * Key)
+{
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection+"\\"+ Key : Key;
+	std::string value = m_IniFile.GetString(m_CurrentSection.c_str(), SectionKey.c_str(), "");
+	GlSettingValue SettingsValue(value.c_str());
+	return SettingsValue;
+}
+
+GlSettingValue GlSettings::value(const char * Key, int32_t DefaultValue)
+{
+	char szDefaultValue[400];
+	sprintf_s(szDefaultValue, sizeof(szDefaultValue), "%d", DefaultValue);
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	std::string value = m_IniFile.GetString(m_CurrentSection.c_str(), SectionKey.c_str(), szDefaultValue);
+	GlSettingValue SettingsValue(value.c_str());
+	return SettingsValue;
+}
+
+GlSettingValue GlSettings::value(const char * Key, uint32_t DefaultValue)
+{
+	char szDefaultValue[400];
+	sprintf_s(szDefaultValue, sizeof(szDefaultValue), "%d", DefaultValue);
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	std::string value = m_IniFile.GetString(m_CurrentSection.c_str(), SectionKey.c_str(), szDefaultValue);
+	GlSettingValue SettingsValue(value.c_str());
+	return SettingsValue;
+}
+
+GlSettingValue GlSettings::value(const char * Key, float DefaultValue)
+{
+	char szDefaultValue[400];
+	sprintf_s(szDefaultValue, sizeof(szDefaultValue), "%f", DefaultValue);
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	std::string value = m_IniFile.GetString(m_CurrentSection.c_str(), SectionKey.c_str(), szDefaultValue);
+	GlSettingValue SettingsValue(value.c_str());
+	return SettingsValue;
+}
+
+GlSettingValue GlSettings::value(const char * Key, const char * DefaultValue)
+{
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	std::string value = m_IniFile.GetString(m_CurrentSection.c_str(), SectionKey.c_str(), DefaultValue);
+	GlSettingValue SettingsValue(value.c_str());
+	return SettingsValue;
+}
+
+GlSettingValue GlSettings::value(const char * Key, const GlColor & DefaultValue)
+{
+	char szDefaultValue[400];
+#pragma warning(disable: 4996)
+	sprintf(szDefaultValue, "@Variant(\\0\\0\\x43\\x1\\xff\\xff\\x%x\\x%x\\x%x\\x%x\\x%x\\x%x\\x%x\\x%x)", DefaultValue.Red(), DefaultValue.Red(), DefaultValue.Green(), DefaultValue.Green(), DefaultValue.Blue(), DefaultValue.Blue(), DefaultValue.Alpha(), DefaultValue.Alpha());
+#pragma warning(default: 4996)
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	std::string value = m_IniFile.GetString(m_CurrentSection.c_str(), SectionKey.c_str(), szDefaultValue);
+	GlSettingValue SettingsValue(value.c_str());
+	return SettingsValue;
+}
+
+void GlSettings::setValue(const char * Key, float value)
+{
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	char text[400];
+#pragma warning(disable: 4996)
+	sprintf(text, "%f", value);
+#pragma warning(default: 4996)
+	m_IniFile.SaveString(m_CurrentSection.c_str(), SectionKey.c_str(), text);
+}
+
+void GlSettings::setValue(const char * Key, int32_t value)
+{
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	m_IniFile.SaveNumber(m_CurrentSection.c_str(), SectionKey.c_str(), value);
+}
+
+void GlSettings::setValue(const char * Key, uint32_t value)
+{
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	m_IniFile.SaveNumber(m_CurrentSection.c_str(), SectionKey.c_str(), value);
+}
+
+void GlSettings::setValue(const char * Key, const char * value)
+{
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	m_IniFile.SaveString(m_CurrentSection.c_str(), SectionKey.c_str(), value);
+}
+
+void GlSettings::setValue(const char * Key, const GlColor & value)
+{
+	char txValue[400];
+#pragma warning(disable: 4996)
+	sprintf(txValue, "@Variant(\\0\\0\\x43\\x1\\xff\\xff\\x%x\\x%x\\x%x\\x%x\\x%x\\x%x\\x%x\\x%x)", value.Red(), value.Red(), value.Green(), value.Green(), value.Blue(), value.Blue(), value.Alpha(), value.Alpha());
+#pragma warning(default: 4996)
+	std::string SectionKey = !m_SubSection.empty() ? m_SubSection + "\\" + Key : Key;
+	m_IniFile.SaveString(m_CurrentSection.c_str(), SectionKey.c_str(), txValue);
+}
+
+void GlSettings::clear(void)
+{
+	CIniFile::SectionList sections;
+	m_IniFile.GetVectorOfSections(sections);
+	for (CIniFile::SectionList::const_iterator itr = sections.begin(); itr != sections.end(); itr++)
+	{
+		m_IniFile.DeleteSection(itr->c_str());
+	}
+}
+
+void GlSettings::remove(const char * section)
+{
+	m_IniFile.DeleteSection(section);
+}
+
+void GlSettings::beginGroup(const char * section)
+{
+	if (strcmp(m_CurrentSection.c_str(), "General") == 0)
+	{
+		m_CurrentSection = section;
+	}
+	else
+	{
+		m_SubSection = section;
+	}
+}
+
+void GlSettings::endGroup(void)
+{
+	if (!m_SubSection.empty())
+	{
+		m_SubSection = "";
+	}
+	else
+	{
+		m_CurrentSection = "General";
+		m_IniFile.FlushChanges();
+	}
+}
+
+GlSettings::sections GlSettings::childGroups()
+{
+	CIniFile::SectionList Children;
+	m_IniFile.GetVectorOfSections(Children);
+
+	sections Sections;
+	for (CIniFile::SectionList::iterator itr = Children.begin(); itr != Children.end(); itr++)
+	{
+#pragma warning(disable: 4996)
+		if (stricmp("General", itr->c_str()) == 0)
+		{
+			continue;
+		}
+#pragma warning(default: 4996)
+		Sections.insert(itr->c_str());
+	}
+	return Sections;
+}
+
+
+GlSettingValue::GlSettingValue(const char * value) :
+	m_Value(value != NULL ? value : "")
+{
+}
+
+GlSettingValue::GlSettingValue(const GlSettingValue& rhs) :
+	m_Value(rhs.m_Value)
+{
+}
+
+GlSettingValue& GlSettingValue::operator=(const GlSettingValue&rhs)
+{
+	m_Value = rhs.m_Value;
+	return *this;
+}
+
+int32_t GlSettingValue::toInt() const
+{
+	uint32_t Value = 0;
+#pragma warning(disable: 4996)
+	sscanf(m_Value.c_str(), "%d", &Value);
+#pragma warning(default: 4996)
+	return Value;
+}
+
+float GlSettingValue::toFloat() const
+{
+	float Value = 0.0;
+#pragma warning(disable: 4996)
+	sscanf(m_Value.c_str(), "%f", &Value);
+#pragma warning(default: 4996)
+	return Value;
+}
+
+std::string GlSettingValue::toString() const
+{
+	return m_Value;
+}
+
+GlColor GlSettingValue::toGlColor() const
+{
+	uint8_t Red = 0, Green = 0, Blue = 0, Alpha = 0;
+
+	if (strncmp("@Variant(", m_Value.c_str(), 9) == 0)
+	{
+		std::vector<std::string> tokens;
+
+		std::string value = m_Value.substr(9);
+		char delimiter = '\\';
+		std::string::size_type lastPos = value.find_first_not_of(delimiter, 0);
+		std::string::size_type pos = value.find_first_of(delimiter, lastPos);
+		while (std::string::npos != pos)
+		{
+			tokens.push_back(value.substr(lastPos, pos - lastPos));
+			lastPos = pos + 1;
+			pos = value.find_first_of(delimiter, lastPos);
+		}
+		if (std::string::npos != lastPos)
+		{
+			tokens.push_back(value.substr(lastPos));
+		}
+
+		if (tokens.size() >= 14)
+		{
+			Red = ParseGlColor(tokens[7].c_str());
+			Green = ParseGlColor(tokens[9].c_str());
+			Blue = ParseGlColor(tokens[11].c_str());
+			Alpha = ParseGlColor(tokens[13].c_str());
+		}
+	}
+
+	return GlColor(Red, Green, Blue, Alpha);
+}
+
+uint8_t GlSettingValue::ParseGlColor(const char * color)
+{
+	if (color == NULL) { return 0; }
+	if (color[0] == '0') { return 0; }
+	if (color[0] == 'x')
+	{
+		uint32_t Value = 0;
+#pragma warning(disable: 4996)
+		sscanf(&color[1], "%X", &Value);
+#pragma warning(default: 4996)
+		return (uint8_t)Value;
+	}
+	return 0;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/GlSettings.h b/GLideN64/src/GLideNUI-wtl/GlSettings.h
new file mode 100644
index 00000000..522ded6d
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/GlSettings.h
@@ -0,0 +1,75 @@
+#pragma once
+#include "IniFileClass.h"
+#include <set>
+
+class GlColor
+{
+public:
+	GlColor(uint8_t Red, uint8_t Green, uint8_t Blue, uint8_t Alpha = 0);
+
+	inline uint8_t Red(void) const { return m_Red; }
+	inline uint8_t Green(void) const { return m_Green; }
+	inline uint8_t Blue(void) const { return m_Blue; }
+	inline uint8_t Alpha(void) const { return m_Alpha; }
+private:
+	GlColor();
+
+	uint8_t m_Red, m_Green, m_Blue, m_Alpha;
+};
+
+class GlSettingValue
+{
+public:
+	GlSettingValue(const char *);
+	GlSettingValue(const GlSettingValue&);
+	GlSettingValue& operator=(const GlSettingValue&);
+
+	int32_t toInt() const;
+	float toFloat() const;
+	std::string toString() const;
+	GlColor toGlColor() const;
+
+private:
+	GlSettingValue();
+
+	static uint8_t ParseGlColor(const char *);
+
+	std::string m_Value;
+};
+
+class GlSettings
+{
+public:
+	typedef std::set<std::string> sections;
+	
+	GlSettings(const char * IniFile);
+
+	GlSettingValue value(const char * Key);
+	GlSettingValue value(const char * Key, int32_t DefaultValue);
+	GlSettingValue value(const char * Key, uint32_t DefaultValue);
+	GlSettingValue value(const char * Key, float DefaultValue);
+	GlSettingValue value(const char * Key, const char * DefaultValue);
+	GlSettingValue value(const char * Key, const GlColor & DefaultValue);
+
+	void setValue(const char * Key, int32_t value);
+	void setValue(const char * Key, uint32_t value);
+	void setValue(const char * Key, float value);
+	void setValue(const char * Key, const char * value);
+	void setValue(const char * Key, const GlColor & value);
+
+	sections childGroups();
+
+	void clear(void);
+	void remove(const char * section);
+	void beginGroup(const char * section);
+	void endGroup(void);
+
+private:
+	GlSettings();
+	GlSettings(const GlSettings&);
+	GlSettings& operator=(const GlSettings&);
+  
+	CIniFile m_IniFile;
+	std::string m_CurrentSection;
+	std::string m_SubSection;
+};
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/IniFileClass.cpp b/GLideN64/src/GLideNUI-wtl/IniFileClass.cpp
new file mode 100644
index 00000000..4daa9f7a
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/IniFileClass.cpp
@@ -0,0 +1,879 @@
+#include "IniFileClass.h"
+#include <stdlib.h>
+#include <stdarg.h>
+
+#pragma warning(disable:4996)
+
+CIniFileBase::CIniFileBase(CFileBase & FileObject, const char * FileName) :
+	m_lastSectionSearch(0),
+	m_CurrentSectionFilePos(0),
+	m_LineFeed("\r\n"),
+	m_ReadOnly(true),
+	m_InstantFlush(true),
+	m_File(FileObject),
+	m_FileName(FileName),
+	m_CurrentSectionDirty(false),
+	m_SortFunction(NULL)
+{
+}
+
+CIniFileBase::~CIniFileBase(void)
+{
+	SaveCurrentSection();
+}
+
+void CIniFileBase::fInsertSpaces(int Pos, int NoOfSpaces)
+{
+	enum { fIS_MvSize = 0x2000 };
+
+	unsigned char Data[fIS_MvSize + 1];
+	int SizeToRead, result;
+	long end, WritePos;
+
+	m_File.Seek(0, CFileBase::end);
+	end = m_File.GetPosition();
+
+	if (NoOfSpaces > 0)
+	{
+		std::string SpaceBuffer = FormatStr("%*c", NoOfSpaces, ' ');
+
+		do
+		{
+			SizeToRead = end - Pos;
+			if (SizeToRead > fIS_MvSize) { SizeToRead = fIS_MvSize; }
+			if (SizeToRead > 0)
+			{
+				m_File.Seek(SizeToRead * -1, CFileBase::current);
+				WritePos = m_File.GetPosition();
+				memset(Data, 0, sizeof(Data));
+				result = m_File.Read(Data, SizeToRead);
+				m_File.Seek(WritePos, CFileBase::begin);
+				end = WritePos;
+
+				m_File.Write(SpaceBuffer.c_str(), (uint32_t)SpaceBuffer.length());
+				m_File.Write(Data, result);
+				m_File.Seek(WritePos, CFileBase::begin);
+			}
+		} while (SizeToRead > 0);
+	}
+	if (NoOfSpaces < 0)
+	{
+		int ReadPos = Pos + (NoOfSpaces * -1);
+		WritePos = Pos;
+
+		do
+		{
+			SizeToRead = end - ReadPos;
+			if (SizeToRead > fIS_MvSize) { SizeToRead = fIS_MvSize; }
+			m_File.Seek(ReadPos, CFileBase::begin);
+			m_File.Read(Data, SizeToRead);
+			m_File.Seek(WritePos, CFileBase::begin);
+			m_File.Write(Data, SizeToRead);
+			ReadPos += SizeToRead;
+			WritePos += SizeToRead;
+		} while (SizeToRead > 0);
+
+		m_File.Seek(WritePos, CFileBase::begin);
+		std::string SpaceBuffer = FormatStr("%*c", (NoOfSpaces * -1), ' ');
+		m_File.Write(SpaceBuffer.c_str(), (uint32_t)SpaceBuffer.length());
+
+		m_File.Seek(WritePos, CFileBase::begin);
+		m_File.SetEndOfFile();
+		m_File.Seek(0, CFileBase::begin);
+	}
+}
+
+int CIniFileBase::GetStringFromFile(char * & String, std::unique_ptr<char> &Data, int & MaxDataSize, int & DataSize, int & ReadPos)
+{
+	enum { BufferIncrease = 0x2000 };
+	if (MaxDataSize == 0)
+	{
+		ReadPos = 0;
+		MaxDataSize = BufferIncrease;
+		Data.reset(new char[MaxDataSize]);
+		DataSize = m_File.Read(&Data.get()[DataSize], MaxDataSize);
+	}
+
+	for (;;)
+	{
+		int count;
+
+		for (count = ReadPos; count < DataSize; count++)
+		{
+			if (Data.get()[count] == '\n')
+			{
+				int len = (count - ReadPos) + 1;
+				String = &Data.get()[ReadPos];
+				String[len - 1] = 0;
+				ReadPos = count + 1;
+				return len;
+			}
+		}
+
+		if (ReadPos != 0)
+		{
+			if ((DataSize - ReadPos) > 0)
+			{
+				memmove(Data.get(), &Data.get()[ReadPos], DataSize - ReadPos);
+			}
+			DataSize -= ReadPos;
+			ReadPos = 0;
+		}
+		else
+		{
+			//Increase buffer size
+			int NewMaxDataSize = MaxDataSize + BufferIncrease;
+			char * NewBuffer = new char[NewMaxDataSize];
+			if (NewBuffer == NULL)
+			{
+				return -1;
+			}
+			memcpy(NewBuffer, Data.get(), DataSize);
+			MaxDataSize = NewMaxDataSize;
+			Data.reset(NewBuffer);
+		}
+
+		int dwRead = m_File.Read(&Data.get()[DataSize], MaxDataSize - DataSize);
+		if (dwRead == 0)
+		{
+			if (DataSize > 0)
+			{
+				int len = DataSize + 1;
+				String = &Data.get()[ReadPos];
+				String[len - 1] = 0;
+				DataSize = 0;
+				ReadPos = 0;
+				return len;
+			}
+			return -1;
+		}
+		DataSize += dwRead;
+	}
+}
+
+void CIniFileBase::SaveCurrentSection(void)
+{
+	if (!m_CurrentSectionDirty)
+	{
+		return;
+	}
+	m_CurrentSectionDirty = false;
+	if (m_CurrentSection.length() == 0)
+	{
+		m_CurrentSection = "default";
+	}
+
+	int lineFeedLen = (int)strlen(m_LineFeed);
+
+	if (m_CurrentSectionFilePos == -1)
+	{
+		//Section has not been added yet
+		m_File.Seek(0, CFileBase::end);
+
+		int len = (int)m_CurrentSection.length() + (lineFeedLen * 2) + 5;
+		std::unique_ptr<char> SectionName(new char[len]);
+		if (m_File.GetLength() < (int)strlen(m_LineFeed))
+		{
+			sprintf(SectionName.get(), "[%s]%s", m_CurrentSection.c_str(), m_LineFeed);
+		}
+		else
+		{
+			sprintf(SectionName.get(), "%s[%s]%s", m_LineFeed, m_CurrentSection.c_str(), m_LineFeed);
+		}
+		m_File.Write(SectionName.get(), (int)strlen(SectionName.get()));
+		m_CurrentSectionFilePos = m_File.GetPosition();
+		m_SectionsPos.insert(FILELOC::value_type(m_CurrentSection, m_CurrentSectionFilePos));
+	}
+	else
+	{
+		//increase/decrease space needed
+		int NeededBufferLen = 0;
+		{
+			std::unique_ptr<char> LineData;
+			int len = 0;
+
+			for (KeyValueList::iterator iter = m_CurrentSectionData.begin(); iter != m_CurrentSectionData.end(); iter++)
+			{
+				int newLen = (int)iter->first.length() + (int)iter->second.length() + lineFeedLen + 5;
+				if (newLen > len)
+				{
+					LineData.reset(new char[newLen]);
+					len = newLen;
+				}
+				sprintf(LineData.get(), "%s=%s%s", iter->first.c_str(), iter->second.c_str(), m_LineFeed);
+				NeededBufferLen += (int)strlen(LineData.get());
+			}
+		}
+		int currentLen = 0;
+
+		m_File.Seek(m_CurrentSectionFilePos, CFileBase::begin);
+
+		int MaxDataSize = 0, DataSize = 0, ReadPos = 0, result;
+		std::unique_ptr<char> Data;
+		char *Input = NULL;
+
+		//Skip first line as it is the section name
+		int StartPos = m_CurrentSectionFilePos;
+		int EndPos = StartPos;
+		do
+		{
+			result = GetStringFromFile(Input, Data, MaxDataSize, DataSize, ReadPos);
+			if (result <= 1) { continue; }
+			if (strlen(CleanLine(Input)) <= 1 || Input[0] != '[')
+			{
+				EndPos = ((m_File.GetPosition() - DataSize) + ReadPos);
+
+				continue;
+			}
+			if (Input[0] == '[')
+			{
+				NeededBufferLen += lineFeedLen;
+			}
+			break;
+		} while (result >= 0);
+		currentLen = EndPos - StartPos;
+
+		if (NeededBufferLen != currentLen)
+		{
+			fInsertSpaces(StartPos, NeededBufferLen - currentLen);
+			m_File.Flush();
+			ClearSectionPosList(StartPos);
+		}
+		//set pointer to beginning of the start pos
+		m_File.Seek(StartPos, CFileBase::begin);
+	}
+
+	{
+		std::unique_ptr<char> LineData;
+		int len = 0;
+
+		if (m_SortFunction != NULL)
+		{
+			KeyValueVector data;
+			for (KeyValueList::iterator iter = m_CurrentSectionData.begin(); iter != m_CurrentSectionData.end(); iter++)
+			{
+				data.push_back(KeyValueItem(&iter->first, &iter->second));
+			}
+			m_SortFunction(data);
+			for (size_t i = 0, n = data.size(); i < n; i++)
+			{
+				KeyValueItem & item = data[i];
+				int newLen = (int)(item.first->length()) + (int)item.second->length() + lineFeedLen + 5;
+				if (newLen > len)
+				{
+					LineData.reset(new char[newLen]);
+					len = newLen;
+				}
+				sprintf(LineData.get(), "%s=%s%s", item.first->c_str(), item.second->c_str(), m_LineFeed);
+				m_File.Write(LineData.get(), (int)strlen(LineData.get()));
+			}
+		}
+		else
+		{
+			for (KeyValueList::iterator iter = m_CurrentSectionData.begin(); iter != m_CurrentSectionData.end(); iter++)
+			{
+				int newLen = (int)iter->first.length() + (int)iter->second.length() + lineFeedLen + 5;
+				if (newLen > len)
+				{
+					LineData.reset(new char[newLen]);
+					len = newLen;
+				}
+				sprintf(LineData.get(), "%s=%s%s", iter->first.c_str(), iter->second.c_str(), m_LineFeed);
+				m_File.Write(LineData.get(), (int)strlen(LineData.get()));
+			}
+		}
+	}
+	m_File.Flush();
+}
+
+bool CIniFileBase::MoveToSectionNameData(const char * lpSectionName, bool ChangeCurrentSection)
+{
+	if (strcmp(lpSectionName, m_CurrentSection.c_str()) == 0)
+	{
+		return true;
+	}
+	if (ChangeCurrentSection)
+	{
+		SaveCurrentSection();
+		m_CurrentSection = "";
+	}
+
+	std::unique_ptr<char> Data;
+	char *Input = NULL;
+	int MaxDataSize = 0, DataSize = 0, ReadPos = 0, result;
+
+	FILELOC_ITR iter = m_SectionsPos.find(std::string(lpSectionName));
+	bool bFoundSection = false;
+	if (iter != m_SectionsPos.end())
+	{
+		if (ChangeCurrentSection)
+		{
+			m_CurrentSection = iter->first;
+			m_CurrentSectionFilePos = iter->second;
+		}
+		m_File.Seek(iter->second, CFileBase::begin);
+		bFoundSection = true;
+	}
+	else
+	{
+		m_File.Seek(m_lastSectionSearch, CFileBase::begin);
+
+		//long Fpos;
+		uint8_t pUTF8[3];
+		pUTF8[0] = 0xef;
+		pUTF8[1] = 0xbb;
+		pUTF8[2] = 0xbf;
+
+		do
+		{
+			result = GetStringFromFile(Input, Data, MaxDataSize, DataSize, ReadPos);
+			if (result <= 1) { continue; }
+			if (strlen(CleanLine(Input)) <= 1) { continue; }
+
+			//We Only care about sections
+			char * CurrentSection = Input;
+
+			if (m_lastSectionSearch == 0 && !memcmp(CurrentSection, pUTF8, 3))
+			{
+				CurrentSection += 3;
+			}
+
+			if (CurrentSection[0] != '[') { continue; }
+			int lineEndPos = (int)strlen(CurrentSection) - 1;
+			if (CurrentSection[lineEndPos] != ']') { continue; }
+			//take off the ']' from the end of the string
+			CurrentSection[lineEndPos] = 0;
+			CurrentSection += 1;
+			m_lastSectionSearch = (m_File.GetPosition() - DataSize) + ReadPos;
+			m_SectionsPos.insert(FILELOC::value_type(CurrentSection, m_lastSectionSearch));
+
+			if (_stricmp(lpSectionName, CurrentSection) != 0)
+			{
+				continue;
+			}
+
+			if (ChangeCurrentSection)
+			{
+				m_CurrentSection = lpSectionName;
+				m_CurrentSectionFilePos = m_lastSectionSearch;
+			}
+			else
+			{
+				m_File.Seek(m_lastSectionSearch, CFileBase::begin);
+			}
+			bFoundSection = true;
+			break;
+		} while (result >= 0);
+	}
+
+	if (!bFoundSection && strcmp(lpSectionName, "default") == 0)
+	{
+		m_SectionsPos.insert(FILELOC::value_type(lpSectionName, 0));
+		if (ChangeCurrentSection)
+		{
+			m_CurrentSection = lpSectionName;
+			m_CurrentSectionFilePos = 0;
+		}
+		m_File.Seek(m_lastSectionSearch, CFileBase::begin);
+		bFoundSection = true;
+	}
+
+	if (bFoundSection && ChangeCurrentSection)
+	{
+		m_CurrentSectionData.clear();
+		do
+		{
+			result = GetStringFromFile(Input, Data, MaxDataSize, DataSize, ReadPos);
+			if (result <= 1) { continue; }
+			if (strlen(CleanLine(Input)) <= 1) { continue; }
+			if (Input[0] == '[') { break; }
+			char * Pos = strchr(Input, '=');
+			if (Pos == NULL) { continue; }
+			char * Value = &Pos[1];
+
+			char * Pos1 = Pos - 1;
+			while (((*Pos1 == ' ') || (*Pos1 == '\t')) && (Pos1 > Input))
+			{
+				Pos1--;
+			}
+			Pos1[1] = 0;
+
+			m_CurrentSectionData.insert(KeyValueList::value_type(Input, Value));
+		} while (result >= 0);
+	}
+
+	return bFoundSection;
+}
+
+const char * CIniFileBase::CleanLine(char * Line)
+{
+	char * Pos = Line;
+
+	//Remove any comment from the line
+	while (Pos != NULL)
+	{
+		Pos = strchr(Pos, '/');
+		if (Pos != NULL)
+		{
+			if (Pos[1] == '/')
+			{
+				if (Pos > Line)
+				{
+					char * Pos_1 = Pos - 1;
+
+					if (Pos_1[0] != ':')
+					{
+						Pos[0] = 0;
+					}
+					else
+						Pos += 1;
+				}
+				else
+				{
+					Pos[0] = 0;
+				}
+			}
+			else
+			{
+				Pos += 1;
+			}
+		}
+	}
+
+	//strip any spaces or line feeds from the end of the line
+	for (int count = (int)strlen(&Line[0]) - 1; count >= 0; count--)
+	{
+		if (Line[count] != ' ' && Line[count] != '\r') { break; }
+		Line[count] = 0;
+	}
+	return Line;
+}
+
+void CIniFileBase::OpenIniFileReadOnly()
+{
+	if (m_File.Open(m_FileName.c_str(), CFileBase::modeRead))
+	{
+		m_ReadOnly = true;
+		m_File.Seek(0, CFileBase::begin);
+	}
+}
+
+void CIniFileBase::OpenIniFile(bool bCreate)
+{
+	//Open for reading/Writing
+	m_ReadOnly = false;
+	if (!m_File.Open(m_FileName.c_str(), CFileBase::modeReadWrite | CFileBase::shareDenyWrite))
+	{
+		if (!m_File.Open(m_FileName.c_str(), CFileBase::modeRead))
+		{
+			if (bCreate)
+			{
+				if (!m_File.Open(m_FileName.c_str(), CFileBase::modeReadWrite | CFileBase::modeCreate | CFileBase::shareDenyWrite))
+				{
+					return;
+				}
+			}
+		}
+		else
+		{
+			m_ReadOnly = true;
+		}
+	}
+	m_File.Seek(0, CFileBase::begin);
+}
+
+bool CIniFileBase::IsEmpty()
+{
+	if (m_File.GetLength() == 0)
+		return true;
+	return false;
+}
+
+bool CIniFileBase::IsFileOpen(void)
+{
+	return m_File.IsOpen();
+}
+
+bool CIniFileBase::DeleteSection(const char * lpSectionName)
+{
+	if (!m_File.IsOpen()) { return false; }
+	
+	SaveCurrentSection();
+	if (!MoveToSectionNameData(lpSectionName, true))
+	{
+		return false;
+	}
+	m_File.Seek(m_CurrentSectionFilePos, CFileBase::begin);
+	long DeleteSectionStart = m_CurrentSectionFilePos - (strlen(lpSectionName) + strlen(m_LineFeed) + 2);
+	long NextSectionStart = -1;
+
+	{
+		int MaxDataSize = 0, DataSize = 0, ReadPos = 0, NextLine = 0, result;
+		std::unique_ptr <char> Data;
+		char *Input = NULL;
+		do
+		{
+			result = GetStringFromFile(Input, Data, MaxDataSize, DataSize, ReadPos);
+			if (result <= 1) { continue; }
+			if (strlen(CleanLine(Input)) <= 1) { continue; }
+
+			if (Input[0] != '[') 
+			{ 
+				NextLine = (m_File.GetPosition() - DataSize) + ReadPos;
+				continue; 
+			}
+			NextSectionStart = NextLine != 0 ? NextLine : (m_File.GetPosition() - DataSize) + ReadPos;
+			break;
+		} while (result >= 0);
+	}
+
+	if (NextSectionStart != -1)
+	{
+		m_File.Seek(0, CFileBase::end);
+		long end = m_File.GetPosition();
+		long ReadPos = NextSectionStart;
+		long WritePos = DeleteSectionStart;
+
+		enum { fIS_MvSize = 0x2000 };
+		unsigned char Data[fIS_MvSize + 1];
+		int SizeToRead;
+		do
+		{
+			SizeToRead = end - ReadPos;
+			if (SizeToRead > fIS_MvSize) { SizeToRead = fIS_MvSize; }
+			m_File.Seek(ReadPos, CFileBase::begin);
+			m_File.Read(Data, SizeToRead);
+			m_File.Seek(WritePos, CFileBase::begin);
+			m_File.Write(Data, SizeToRead);
+			ReadPos += SizeToRead;
+			WritePos += SizeToRead;
+		} while (SizeToRead > 0);
+		m_File.Seek(DeleteSectionStart + (end - NextSectionStart), CFileBase::begin);
+		m_File.Flush();
+		m_File.SetEndOfFile();
+	}
+	else
+	{
+		m_File.Seek(DeleteSectionStart, CFileBase::begin);
+		m_File.Flush();
+		m_File.SetEndOfFile();
+	}
+	m_File.Flush();
+	ClearSectionPosList(0);
+	m_CurrentSection = "";
+	m_CurrentSectionData.clear();
+	m_CurrentSectionFilePos = -1;
+	return true;
+}
+
+bool CIniFileBase::GetString(const char * lpSectionName, const char * lpKeyName, const char * lpDefault, std::string & Value)
+{
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		lpSectionName = "default";
+	}
+
+	if (m_File.IsOpen() && MoveToSectionNameData(lpSectionName, true))
+	{
+		KeyValueList::iterator iter = m_CurrentSectionData.find(lpKeyName);
+		if (iter != m_CurrentSectionData.end())
+		{
+			Value = iter->second.c_str();
+			return true;
+		}
+	}
+	Value = lpDefault;
+	return false;
+}
+
+std::string CIniFileBase::GetString(const char * lpSectionName, const char * lpKeyName, const char * lpDefault)
+{
+	std::string Value;
+	GetString(lpSectionName, lpKeyName, lpDefault, Value);
+	return Value;
+}
+
+uint32_t CIniFileBase::GetString(const char * lpSectionName, const char * lpKeyName, const char * lpDefault, char * lpReturnedString, uint32_t nSize)
+{
+	std::string strSection;
+
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		strSection = "default";
+	}
+	else
+	{
+		strSection = lpSectionName;
+	}
+
+	if (m_File.IsOpen() && MoveToSectionNameData(strSection.c_str(), true))
+	{
+		KeyValueList::iterator iter = m_CurrentSectionData.find(lpKeyName);
+		if (iter != m_CurrentSectionData.end())
+		{
+			strncpy(lpReturnedString, iter->second.c_str(), nSize - 1);
+			lpReturnedString[nSize - 1] = 0;
+			return (uint32_t)strlen(lpReturnedString);
+		}
+	}
+	strncpy(lpReturnedString, lpDefault, nSize - 1);
+	lpReturnedString[nSize - 1] = 0;
+	return (uint32_t)strlen(lpReturnedString);
+}
+
+uint32_t CIniFileBase::GetNumber(const char * lpSectionName, const char * lpKeyName, uint32_t nDefault)
+{
+	uint32_t Value;
+	GetNumber(lpSectionName, lpKeyName, nDefault, Value);
+	return Value;
+}
+
+bool CIniFileBase::GetNumber(const char * lpSectionName, const char * lpKeyName, uint32_t nDefault, uint32_t & Value)
+{
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		lpSectionName = "default";
+	}
+
+	if (m_File.IsOpen() && MoveToSectionNameData(lpSectionName, true))
+	{
+		KeyValueList::iterator iter = m_CurrentSectionData.find(lpKeyName);
+		if (iter != m_CurrentSectionData.end())
+		{
+			Value = 0;
+			sscanf(iter->second.c_str(), "%u", &Value);
+			return true;
+		}
+	}
+	Value = nDefault;
+	return false;
+}
+
+void  CIniFileBase::SaveString(const char * lpSectionName, const char * lpKeyName, const char * lpString)
+{
+	if (!m_File.IsOpen())
+	{
+		if (lpString)
+		{
+			OpenIniFile();
+		}
+		if (!m_File.IsOpen())
+		{
+			return;
+		}
+	}
+	std::string strSection;
+
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		strSection = "default";
+	}
+	else
+	{
+		strSection = lpSectionName;
+	}
+
+	if (!MoveToSectionNameData(strSection.c_str(), true))
+	{
+		m_CurrentSection = strSection;
+		m_CurrentSectionData.clear();
+		m_CurrentSectionFilePos = -1;
+	}
+
+	KeyValueList::iterator iter = m_CurrentSectionData.find(lpKeyName);
+	if (iter != m_CurrentSectionData.end())
+	{
+		if (lpString)
+		{
+			if (iter->second != lpString)
+			{
+				iter->second = lpString;
+				m_CurrentSectionDirty = true;
+			}
+		}
+		else
+		{
+			m_CurrentSectionData.erase(iter);
+			m_CurrentSectionDirty = true;
+		}
+	}
+	else
+	{
+		if (lpString)
+		{
+			m_CurrentSectionData.insert(KeyValueList::value_type(lpKeyName, lpString));
+			m_CurrentSectionDirty = true;
+		}
+	}
+
+	if (m_InstantFlush)
+	{
+		SaveCurrentSection();
+	}
+}
+
+void CIniFileBase::SaveNumber(const char * lpSectionName, const char * lpKeyName, int32_t Value)
+{
+	//translate the string to an ascii version and save as text
+	SaveString(lpSectionName, lpKeyName, FormatStr("%d", Value).c_str());
+}
+
+bool CIniFileBase::EntryExists(const char * lpSectionName, const char * lpKeyName)
+{
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		lpSectionName = "default";
+	}
+
+	if (m_File.IsOpen() && MoveToSectionNameData(lpSectionName, true))
+	{
+		KeyValueList::iterator iter = m_CurrentSectionData.find(lpKeyName);
+		if (iter != m_CurrentSectionData.end())
+		{
+			return true;
+		}
+	}
+	return false;
+}
+
+void CIniFileBase::FlushChanges(void)
+{
+	SaveCurrentSection();
+}
+
+void CIniFileBase::SetAutoFlush(bool AutoFlush)
+{
+	m_InstantFlush = AutoFlush;
+	if (AutoFlush)
+	{
+		FlushChanges();
+	}
+}
+
+void CIniFileBase::GetKeyList(const char * lpSectionName, strlist &List)
+{
+	List.clear();
+
+	if (!m_File.IsOpen())
+	{
+		return;
+	}
+
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		lpSectionName = "default";
+	}
+
+	if (MoveToSectionNameData(lpSectionName, true))
+	{
+		for (KeyValueList::iterator iter = m_CurrentSectionData.begin(); iter != m_CurrentSectionData.end(); iter++)
+		{
+			List.push_back(iter->first);
+		}
+	}
+}
+
+void CIniFileBase::GetKeyValueData(const char * lpSectionName, KeyValueData & List)
+{
+	if (!m_File.IsOpen())
+	{
+		return;
+	}
+
+	std::string strSection;
+
+	if (lpSectionName == NULL || strlen(lpSectionName) == 0)
+	{
+		strSection = "default";
+	}
+	else
+	{
+		strSection = lpSectionName;
+	}
+
+	if (!MoveToSectionNameData(strSection.c_str(), false)) { return; }
+
+	int MaxDataSize = 0, DataSize = 0, ReadPos = 0, result;
+	std::unique_ptr <char> Data;
+	char *Input = NULL;
+	do
+	{
+		result = GetStringFromFile(Input, Data, MaxDataSize, DataSize, ReadPos);
+		if (result <= 1) { continue; }
+		if (strlen(CleanLine(Input)) <= 1) { continue; }
+		if (Input[0] == '[') { break; }
+		char * Pos = strchr(Input, '=');
+		if (Pos == NULL) { continue; }
+		Pos[0] = 0;
+
+		List.insert(KeyValueData::value_type(Input, &Pos[1]));
+	} while (result >= 0);
+}
+
+void CIniFileBase::SetCustomSort(SortData SortFunction)
+{
+	m_SortFunction = SortFunction;
+}
+
+void CIniFileBase::ClearSectionPosList(long FilePos)
+{
+	if (FilePos <= 0)
+	{
+		m_SectionsPos.clear();
+		m_lastSectionSearch = 0;
+	}
+	else
+	{
+		FILELOC::iterator iter = m_SectionsPos.begin();
+		while (iter != m_SectionsPos.end())
+		{
+			FILELOC::iterator CurrentIter = iter;
+			iter++;
+			long TestFilePos = CurrentIter->second;
+			if (TestFilePos > FilePos)
+			{
+				m_SectionsPos.erase(CurrentIter);
+			}
+		}
+		m_lastSectionSearch = FilePos;
+	}
+}
+
+void CIniFileBase::GetVectorOfSections(SectionList & sections)
+{
+	sections.clear();
+
+	if (!m_File.IsOpen())
+	{
+		return;
+	}
+
+	{
+		std::string DoesNotExist = FormatStr("DoesNotExist%d%d%d", rand(), rand(), rand());
+		MoveToSectionNameData(DoesNotExist.c_str(), false);
+	}
+
+	for (FILELOC::const_iterator iter = m_SectionsPos.begin(); iter != m_SectionsPos.end(); iter++)
+	{
+		sections.push_back(iter->first);
+	}
+}
+
+std::string CIniFileBase::FormatStr(const char * strFormat, ...)
+{
+	std::string FormatedStr;
+	va_list args;
+	va_start(args, strFormat);
+
+	size_t nlen = _vscprintf(strFormat, args) + 1;
+	char * buffer = (char *)alloca(nlen * sizeof(char));
+	buffer[nlen - 1] = 0;
+	if (buffer != NULL)
+	{
+		vsprintf(buffer, strFormat, args);
+		FormatedStr = buffer;
+	}
+
+	va_end(args);
+	return FormatedStr;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/IniFileClass.h b/GLideN64/src/GLideNUI-wtl/IniFileClass.h
new file mode 100644
index 00000000..10572b5e
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/IniFileClass.h
@@ -0,0 +1,127 @@
+#pragma once
+
+#ifndef _WIN32
+#include <strings.h>
+#endif
+
+#include "FileClass.h"
+#include <string>
+#include <map>
+#include <vector>
+#include <list>
+#include <memory>
+
+class CIniFileBase
+{
+public:
+	typedef std::map<std::string, std::string> KeyValueData;
+	typedef std::vector<std::string> SectionList;
+	typedef std::list<std::string> strlist;
+	typedef std::pair<const std::string *, const std::string *> KeyValueItem;
+	typedef std::vector<KeyValueItem> KeyValueVector;
+	typedef void(*SortData)(KeyValueVector &);
+
+	CIniFileBase(CFileBase & FileObject, const char * FileName);
+	virtual ~CIniFileBase(void);
+
+	bool IsEmpty();
+	bool IsFileOpen(void);
+	bool DeleteSection(const char * lpSectionName);
+	bool GetString(const char * lpSectionName, const char * lpKeyName, const char * lpDefault, std::string & Value);
+	std::string GetString(const char * lpSectionName, const char * lpKeyName, const char * lpDefault);
+	uint32_t GetString(const char * lpSectionName, const char * lpKeyName, const char * lpDefault, char * lpReturnedString, uint32_t nSize);
+	uint32_t GetNumber(const char * lpSectionName, const char * lpKeyName, uint32_t nDefault);
+	bool GetNumber(const char * lpSectionName, const char * lpKeyName, uint32_t nDefault, uint32_t & Value);
+
+	virtual void SaveString(const char * lpSectionName, const char * lpKeyName, const char * lpString);
+	virtual void SaveNumber(const char * lpSectionName, const char * lpKeyName, int32_t Value);
+	void SetAutoFlush(bool AutoFlush);
+	void FlushChanges(void);
+	bool EntryExists(const char * lpSectionName, const char * lpKeyName);
+	void GetKeyList(const char * lpSectionName, strlist &List);
+	void GetKeyValueData(const char * lpSectionName, KeyValueData & List);
+	void SetCustomSort(SortData SortFunction);
+
+	void GetVectorOfSections(SectionList & sections);
+	const std::string &GetFileName() { return m_FileName; }
+
+protected:
+	void OpenIniFileReadOnly();
+	void OpenIniFile(bool bCreate = true);
+	void SaveCurrentSection(void);
+
+	std::string FormatStr(const char * strFormat, ...);
+
+	CFileBase & m_File;
+	std::string m_FileName;
+
+private:
+	struct insensitive_compare
+	{
+		bool operator() (const std::string & a, const std::string & b) const
+		{
+			return _stricmp(a.c_str(), b.c_str()) < 0;
+		}
+	};
+
+	typedef std::map<std::string, long> FILELOC;
+	typedef FILELOC::iterator FILELOC_ITR;
+	typedef std::map<std::string, std::string, insensitive_compare> KeyValueList;
+	
+	std::string m_CurrentSection;
+	bool m_CurrentSectionDirty;
+	int m_CurrentSectionFilePos; // Where in the file is the current Section
+	KeyValueList m_CurrentSectionData;
+
+	long m_lastSectionSearch; // When Scanning for a section, what was the last scanned pos
+
+	bool m_ReadOnly;
+	bool m_InstantFlush;
+	const char * m_LineFeed;
+
+	FILELOC m_SectionsPos;
+	SortData m_SortFunction;
+
+	void fInsertSpaces(int Pos, int NoOfSpaces);
+	int GetStringFromFile(char * & String, std::unique_ptr<char> &Data, int & MaxDataSize, int & DataSize, int & ReadPos);
+	bool MoveToSectionNameData(const char * lpSectionName, bool ChangeCurrentSection);
+	const char * CleanLine(char * Line);
+	void ClearSectionPosList(long FilePos);
+
+};
+
+template <class CFileStorage>
+class CIniFileT :
+	public CIniFileBase
+{
+public:
+	CIniFileT(const char * FileName) :
+		CIniFileBase(m_FileObject, FileName)
+	{
+		//Try to open file for reading
+		OpenIniFile();
+	}
+
+	CIniFileT(const char * FileName, bool bCreate, bool bReadOnly) :
+		CIniFileBase(m_FileObject, FileName)
+	{
+		if (bReadOnly)
+		{
+			OpenIniFileReadOnly();
+		}
+		else
+		{
+			//Try to open file for reading
+			OpenIniFile(bCreate);
+		}
+	}
+	virtual ~CIniFileT(void)
+	{
+		SaveCurrentSection();
+	}
+
+protected:
+	CFileStorage  m_FileObject;
+};
+
+typedef CIniFileT<CFile>   CIniFile;
diff --git a/GLideN64/src/GLideNUI-wtl/InputDialog.cpp b/GLideN64/src/GLideNUI-wtl/InputDialog.cpp
new file mode 100644
index 00000000..0e4a79b9
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/InputDialog.cpp
@@ -0,0 +1,46 @@
+#include "InputDialog.h"
+
+CInputDialog::CInputDialog(wchar_t * DlgTitle, wchar_t * Message, bool & ok) :
+	m_DlgTitle(DlgTitle != NULL ? DlgTitle : L""),
+	m_Message(Message != NULL ? Message : L""),
+	m_ok(ok)
+{
+	m_ok = false;
+}
+
+std::wstring CInputDialog::getText(wchar_t * DlgTitle, wchar_t * Message, bool & ok)
+{
+	CInputDialog Dlg(DlgTitle, Message, ok);
+	Dlg.DoModal();
+	return Dlg.GetInput();
+}
+
+LRESULT CInputDialog::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	HICON hIcon = AtlLoadIconImage(IDI_APPICON, LR_DEFAULTCOLOR, ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON));
+	SetIcon(hIcon, TRUE);
+	HICON hIconSmall = AtlLoadIconImage(IDI_APPICON, LR_DEFAULTCOLOR, ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON));
+	SetIcon(hIconSmall, FALSE);
+	
+	SetWindowText(m_DlgTitle.c_str());
+	GetDlgItem(IDC_INFO).SetWindowText(m_Message.c_str());
+	GetDlgItem(IDC_INPUT).SetFocus();
+	return 0;
+}
+
+LRESULT CInputDialog::OnOk(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	CWindow InputWnd = GetDlgItem(IDC_INPUT);
+	m_Input.resize(InputWnd.GetWindowTextLength() + 1);
+	InputWnd.GetWindowText((wchar_t *)m_Input.data(), m_Input.size());
+	
+	m_ok = true;
+	EndDialog(wID);
+	return 0;
+}
+
+LRESULT CInputDialog::OnCancel(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	EndDialog(wID);
+	return 0;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/InputDialog.h b/GLideN64/src/GLideNUI-wtl/InputDialog.h
new file mode 100644
index 00000000..aaa9b150
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/InputDialog.h
@@ -0,0 +1,34 @@
+#pragma once
+#include <string>
+#include "wtl.h"
+#include "resource.h"
+
+class CInputDialog :
+	public CDialogImpl<CInputDialog>
+{
+public:
+	static std::wstring getText(wchar_t * DlgTitle, wchar_t * Message, bool & ok);
+
+	CInputDialog(wchar_t * DlgTitle, wchar_t * Message, bool & ok);
+
+	enum { IDD = IDD_INPUT_DIALOG };
+
+	BEGIN_MSG_MAP_EX(CInputDialog)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_ID_HANDLER(IDOK, OnOk)
+		COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
+	END_MSG_MAP()
+
+	const std::wstring & GetInput() const { return m_Input; }
+
+protected:
+	LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
+	LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+	LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
+
+private:
+	CInputDialog(void);
+
+	std::wstring m_DlgTitle, m_Message, m_Input;
+	bool & m_ok;
+};
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/Language.cpp b/GLideN64/src/GLideNUI-wtl/Language.cpp
new file mode 100644
index 00000000..7430726e
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/Language.cpp
@@ -0,0 +1,410 @@
+#include "Language.h"
+#include "util.h"
+#include <windows.h>
+#include <algorithm>
+#include <map>
+#include "../Config.h"
+
+typedef std::map<int32_t, std::string> LANG_STRINGS;
+typedef LANG_STRINGS::value_type LANG_STR;
+
+bool g_debugLang = false;
+LANG_STRINGS g_currentStrings, g_defaultStrings;
+
+void loadDefaultStrings(void)
+{
+	//Config Dialog
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TAB_VIDEO, "Video"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TAB_EMULATION, "Emulation"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TAB_FRAME_BUFFER, "Frame buffer"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TAB_TEXTURE_ENHANCEMENT, "Texture enhancement"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TAB_OSD, "OSD"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TAB_DEBUG, "Debug"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_SAVE_SETTINGS_FOR, "Save settings for:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_SETTINGS_PROFILE, "Settings profile:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_REMOVE, "Remove"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_RESTORE_DEFAULTS, "Restore Defaults"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_SAVE_AND_CLOSE, "Save and Close"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_SAVE, "Save"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(CFG_CLOSE, "Close"));
+	
+	//Video Tab
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_GROUP, "Video"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_FULL_SCREEN_RES, "Full screen resolution:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_FULL_SCREEN_RES_TOOLTIP, "All the resolutions that your video card/monitor supports should be displayed.\n\n[Recommended: Maximum resolution for your monitor unless performance becomes an issue]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_REFRESH_RATE, "Refresh rate:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_REFRESH_RATE_TOOLTIP, ""));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_WINDOWED_RESOLUTION, "Windowed resolution:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_WINDOWED_RESOLUTION_TOOLTIP, "This option selects the resolution for windowed mode. You also may select Custom and enter your own window size.\n\n[Recommended: 640 x 480, 800 x 600, 1024 x 768, 1280 x 960]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ASPECT_RATIO, "Aspect ratio:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ASPECT_RATIO_TOOLTIP, "This setting adjusts the aspect ratio of the video output. All N64 games support 4:3. Some games support 16:9 within game settings. Use Stretch to fill the screen without pillar or letterboxing.\nTry to adjust game to fit tries to adjust the viewing space to fit without stretching. Many games work well adjusted, but some don't."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ASPECT_4_3, "4:3 (recommended)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ASPECT_16_19, "16:9"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ASPECT_STRETCH, "Stretch"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ASPECT_ADJUST, "Try to adjust game to fit"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_VSYNC, "Enable VSync"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_VSYNC_TOOLTIP, "Vertical sync, or VSync, can improve the image by syncing the game's frame rate to your monitor's refresh rate.This prevents image tearing, but may cause performance problems.\n[Recommended:Usually off, on if you have image tearing problems]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_THREADED_VIDEO, "Enable threaded video"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_THREADED_VIDEO_TOOLTIP, "Threaded video can improve performance with poor OpenGL drivers at the cost of very marginal input lag, usually less than half a frame.\n[Recommended: Usually off, unless there are performance issues]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_OVERSCAN, "Overscan"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_OVERSCAN_TOOLTIP, "When enabled, the image is cropped by values specified in N64 pixels. Useful to remove black borders in some games."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_NTSC, "NTSC"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_PAL, "PAL"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ANTI_ALIASING, "Anti-aliasing"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_NO_ANTI_ALIASING, "No anti-aliasing"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_FAST_ANTI_ALIASING, "Fast approximate anti-aliasing (FXAA)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_MULTISAMPLE_ANTI_ALIASING, "Multisample anti-aliasing (MSAA):"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_AA_OFF, "Off"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_AA_HIGH, "High"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_AA_TOOLTIP, "GLideN64 offers two methods to smooth jagged polygons:\nFast approximate anti-aliasing (FXAA): FXAA is a post-processing filter that can provide a decent result, but as good as MSAA. The main reason to use FXAA is to use with N64-style depth compare. FXAA adds some blurriness to the output image, causing some textures like text to possibly look worse.\nMultisample anti-aliasing (MSAA): MSAA is a standard anti-aliasing technique used in computer graphics to improve image quality. Most modern GPUs support 2, 4, 8, and 16 samples. More samples mean better quality, but are slower. There are two downsides: it's incompatible with N64-style depth compare and may cause minor glitches in some games.\nRecommendation: [Usually 16x MSAA, or FXAA with N64-style depth compare]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_AA_INFO, "Multisample anti-aliasing is not compatible with N64-style depth compare."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_FILTERING_GROUP, "Filtering"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ANISOTROPIC, "Anisotropic filtering:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ANISOTROPIC_OFF, "Off"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_ANISOTROPIC_HIGH, "High"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_BILINEAR, "Bilinear filtering:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_BILINEAR_STANDARD, "Standard"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_BILINEAR_3POINT, "N64-style 3 point"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_BILINEAR_TOOLTIP, "Bilinear filtering: Textures will use standard PC-style bilinear filtering.\nN64-style 3 point: Textures will be filtered more like the N64. The result is less smooth but more accurate."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_GROUP, "Dithering"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_PATTERN, "Pattern (RDRAM):"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_APPLY_TO_OUTPUT, "Apply to final output"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_APPLY_TO_OUTPUT_TOOLTIP, "This setting enables game controlled ordered grid dithering. Enable it for accurate representation. Default = disabled."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_5BIT_QUANTIZATION, "Enable 5-bit quantization"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_5BIT_QUANTIZATION_TOOLTIP, "Like real hardware this setting reduces the number of colors if dithering is used. Removes undesired dithering fragments. Default = enabled."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_HIRES_NOISE, "High resolution noise"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_HIRES_NOISE_TOOLTIP, "This setting doubles noise resolution to get a finer noise effect at higher resolutions. Default = disabled."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_MODE_TOOLTIP, "RDRAM dithering prevents color banding in games with framebuffer effects.\nSettings: Disabled, Bayer ordered grid dithering, Magic Square ordered grid dithering or blue noise dithering. Blue noise dithering produces unobtrusive results. Default = blue noise dithering."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_DISABLE, "disable"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_BAYER, "Bayer"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_MAGIC_SQUARE, "Magic square"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_DITHERING_BLUE_NOISE, "Blue noise"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(VIDEO_LANGUAGE, "Language:"));
+
+	//Emulation Tab
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_USE_PER_GAME, "Use per-game settings"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_USE_PER_GAME_TOOLTIP, "When enabled, all non-default values of settings are stored individually for each game.\nWhen a game is running, settings are displayed and saved for the currently running game.\nNote: GLideN64 already contains settings for the optimal performance of most games. Be careful when altering options on 'Emulation' and 'Frame buffer' tab.\n[Recommended: Checked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_N64_STYLE_MIP_MAPPING, "Enable N64-style mip-mapping"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_N64_STYLE_MIP_MAPPING_TOOLTIP, "The N64 uses a unique method of mip-mapping that's difficult to reproduce correctly on PCs. When checked, this option emulates N64-accurate mip-mapping. When unchecked, some games have sharper distant textures.\n[Recommended: Checked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_HWLIGHTING, "Enable per-pixel lighting (better quality, HLE only)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_HWLIGHTING_TOOLTIP, "In N64 games lighting is calculated per vertex. This option enables Phong shading, which provides smoother and more realistic lighting.\n\n[Recommended: Your preference]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_SHADERS_STORAGE, "Store compiled shaders for performance (recommended)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_SHADERS_STORAGE_TOOLTIP, "Use persistent storage for compiled shader programs.\nEach game uses a set of combiners. A combiner is an equation that defines how to build output color from various color inputs. GLideN64 translates shaders, and compiles shader programs on the fly. Shaders are large and complex. If the game uses several new combiners, compiling new shaders will take time and result in stuttering. When this option is checked, these shaders are saved so they're not recompiled the next time you run the game.\n[Recommended: Checked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_INTERNAL_RES, "Internal resolution"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_INTERNAL_RES_TOOLTIP, "This option sets the output render buffer size. By default, the render buffer is set to the Same as output resolution, but you can set it to the Original N64 resolution or a Multiple of N64 resolution."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_FACTOR0X, "Same as output resolution"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_FACTOR1X, "Original N64 resolution (most accurate)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_FACTORXX, "Multiple of N64 resolution:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_GAMMA, "Gamma"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_GAMMA_TOOLTIP, "Gamma correction.\nSome N64 games use gamma correction. Gamma correction makes image brighter. N64 applies gamma correction in its Video Interface. \nGLideN64 emulates gamma correction as post-processing effect. That is, it works only when frame buffer emulation enabled. Gamma correction enabled automatically for games, which use it on real N64. You may force gamma correction for all games. Default level of gamma correction is 2, as on N64.\n[Recommended: use defaults]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_GAMMA_CORRECTION, "Custom gamma correction level:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_GAMMA_INFO, "Selecting this option overrides gamma correction specified by the game."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_2D_ELEMENTS, "2D elements"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_RENDER_2D_ELEMENTS, "Render 2D elements in N64 resolution (best quality, can be slow):"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_RENDER_2D_TOOLTIP, "When checked, 2D elements are rendered at the N64s resolution before copying them to output. This usually eliminates display issues with 2D elements, but it can be slow. This option uses heuristics to detect adjacent 2D elements that doesn't work for every game.\n[Recommended: Checked, unless you have performance problems]"));	
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_RENDER_DISABLE, "Disable"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_RENDER_ENABLE_OPTIMIZED, "Enable optimized"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_RENDER_ENABLE_UNOPTIMIZED, "Enable unoptimized"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_HALOS_REMOVAL, "Try to remove colored halos around transparent objects"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_FIX_BLACK_LINES, "Fix black lines between 2D elements:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_FIX_BLACK_LINES_TOOLTIP, "In some games the coordinates for parts of 2D elements are not aligned: there is a half-pixel split between adjacent elements. When rendering at the N64's original resolution it isn't visible, but when the image is scaled up it results in black lines. This option attempts to connect these 2D elements.\nFor adjacent 2D elements: Apply the correction only for polygons that need it. Select this option for games that have issues with black lines.\nAlways: Apply the correction for every 2D element. Select this option when For adjacent 2D elements doesn't help.\nNever: Don't attempt to correct black lines between 2D elements.\n[Recommended: Game dependent, mostly Never]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_ADJACENT_2D_ELEMENTS, "For adjacent 2D elements"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_ALWAYS, "Always"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_NEVER, "Never"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_BACKGROUND, "Background rendering mode (HLE only):"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_BACKGROUND_TOOLTIP, "Background is a complex macro command used to render large (normally full screen) images. Since background images usually don't fit texture memory, the microcode splits them on narrow strips and renders them one by one. HLE code has two modes to emulate background commands:\nOne piece: The whole background image rendred as one textured rectangle. This method is normally much faster, but the result is not always correct.\nStripped: This method emulates background commands as close as possible to actual microcode implementation. It's slower but more precise. Another problem: some games may have gaps between rendered strips in high resolution. Use \"Render 2D elements in N64 resolution\" option to remove the gaps.\n[Recommended: Game dependent, mostly Stripped]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_ONE_PIECE, "One piece"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(EMULATION_STRIPPED, "Stripped"));
+
+	//Frame Buffer Tab
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_ENABLE, "Emulate frame buffer"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_ENABLE_INFO, "Unchecking this option disables many effects including cropping, aspect ratio, N64 resolution factor, N64-style depth compare and more. Don't uncheck this option unless you have performance issues."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_AUX_BUFFERS, "Copy auxiliary color buffers to N64 memory (sometimes slow, fewer game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_AUX_BUFFERS_TOOLTIP, "When checked, the auxiliary color buffer is copied to N64 memory right after rendering to it is finished. This option helps to correctly emulate frame buffer effects in some games. This option may noticeably reduce performance.\n[Recommended: Usually unchecked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_SWAP, "Frame buffer swap on:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_SWAP_TOOLTIP, "This option controls how often GLideN64 updates the main frame buffer.\nVertical interrupt : Update the buffer as quickly as possible, every vertical interrupt per second(50 for PAL and 60 for NTSC games).This option is the most compatible.Use this mode unless you have performance problems.\nVI origin change : The VI origin changes corresponding to the game's actual FPS. N64 games typically run between 20 to 30 FPS so the buffers swap less often than the first mode. This mode does not work for games that use single buffering, which is rare.\nColor buffer change: This option checks to see if the frame buffer has been changed. There are some games where this doesn't work."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_VERTICAL_INTERRUPT, "Vertical interrupt (recommended, fewest game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_VI_ORIGIN_CHANGE, "VI origin change (faster, few game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COLOR_BUFFER_CHANGE, "Color buffer change (fastest, some game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_INFO_ENABLE, "Use emulator help to read/write frame buffers"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_INFO_ENABLE_TOOLTIP, "Some emulators do a poor job of detecting when to read/write frame buffers. You can disable emulator help to let GLideN64 read/write frame buffers itself.\n[Recommended: Usually unchecked, but for some games/emulators it may be faster checked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_READ_COLOR_CHUNK, "Read color buffer in 4 KB chunks"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_READ_COLOR_CHUNK_TOOLTIP, "When checked, the color buffer will be read in chunks. Otherwise, the buffer will be read in its entirety. If a game needs to read the entire buffer, selecting this option may be slow.\n[Recommended: Usually unchecked, because the color buffer is usually read entirely]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_READ_DEPTH_CHUNK, "Read depth buffer in 4 KB chunks"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_READ_DEPTH_CHUNK_TOOLTIP, "When checked, the depth buffer will be read in chunks. Otherwise the buffer will be read in its entirety. If a game needs to read the entire buffer, selecting this option may be slow.\n[Recommended: Checked, because the depth buffer is not often read entirely]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_COLOR_BUFFER, "Copy video card frame buffer to N64 memory:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_COLOR_BUFFER_TOOLTIP, "In some games GLideN64 can't detect when the game uses the frame buffer. With these options, you can have GLideN64 copy each frame of your video card's frame buffer to N64 memory.\nNever: Disable copying buffers from video card.\nSynchronous: Effects are detected for all games, but it can be slow. Use for games where Asynchronous doesn't work.\nAsynchronous: Effects are detected for most games. [Recommended: Usually Asynchronous]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_NEVER, "Never (fastest, many game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_SYNCHRONOUS, "Synchronous (slowest, fewest game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_ASYNCHRONOUS, "Asynchronous (fast, few game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_BUFFER, "Copy video card depth buffer to N64 memory:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_BUFFER_TOOLTIP, "The depth buffer is used to emulate some effects (e.g. coronas):\nNever: Depth buffer is disabled.\nFrom VRAM: Your video card's depth buffer is copied to N64 memory each frame, which can be slow on some games.\nIn software: Generally faster than copying from VRAM, but the result can be imperfect.\n[Recommended: In software]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_NEVER, "Never (fastest, most game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_VRAM, "From VRAM (slow, some game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_SOFTWARE, "In software (fast, fewest game issues)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_N64_DEPTH_COMPARE, "N64-style depth compare (experimental, disables MSAA)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_N64_DEPTH_COMPARE_TOOLTIP, "The N64 uses a unique method of calculating depth to the camera. When enabled, GlideN64 uses shaders to try to emulate these calculations correctly. Not compatible with anti-aliasing. Experimental!\nFast mode requires OpenGL 4.2 and fragment shader interlock extensions.\nCompatible mode requires only core OpenGL 4.2 Can be slow!\n[Recommended: Sometimes checked, for several games]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_N64_DEPTH_DISABLE, "Disable"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_N64_DEPTH_FAST, "Fast"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_N64_DEPTH_COMPATIBLE, "Compatible"));   
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_FORCE_DEPTH_BUFFER_CLEAR, "Force depth buffer clear"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_FORCE_DEPTH_BUFFER_CLEAR_TOOLTIP, "Enable force depth buffer clear. A hack. Necessary for Eikou no Saint Andrews.\n[Recommended: except for Eikou no Saint Andrews]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_RENDER_FRAMEBUFFER, "Render N64 frame buffer to output"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_RENDER_FRAMEBUFFER_TOOLTIP, "When this option is checked, the frame buffer is rendered directly to the screen. This prevents some graphic problems but may cause slowdowns or visual quality problems.\n[Recommended: Usually unchecked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_TO_MAIN, "Copy depth to main depth buffer"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(FRAMEBUFFER_COPY_DEPTH_TO_MAIN_TOOLTIP, "This option is required for some Reshade depth dependant effects, such as SSAO and depth of field.\n[Recommended: only if you use Reshade and need depth dependant effects]"));
+
+	//Texture enhancement
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_TEXTURES_GROUP, "N64 textures"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER, "Filter:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_TOOLTIP, "This filter smooths or sharpens textures. There are four smoothing filters and two sharpening filters. The higher the number, the stronger the effect. Performance may be affected depending on the game and/or your PC.\n[Recommended: Your preference]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_NONE, "None"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_SMOOTH1, "Smooth filtering 1"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_SMOOTH2, "Smooth filtering 2"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_SMOOTH3, "Smooth filtering 3"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_SMOOTH4, "Smooth filtering 4"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_SHARP1, "Sharp filtering 1"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_N64_FILTER_SHARP2, "Sharp filtering 2"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_ENHANCEMENT, "Enhancement:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_ENHANCEMENT_TOOLTIP, "There are 12 distinct filters to select. Depending on which filter, they may cause performance problems.\nWhen Store is selected, textures are saved to the cache as-is. This improves performance in games that load many textures. Uncheck Disable for backgrounds for the best performance.\n[Recommended: Your preference]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_ENHANCEMENT_NONE, "None"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_ENHANCEMENT_STORE, "Store"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_DECREASE_COLOR, "Decrease color banding (recommended for xBRZ enhancement)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_DECREASE_COLOR_TOOLTIP, "This option enables a pre-processing step that reduces posterization issues on enhanced textures.\n[Recommended: Checked for xBRZ]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_IGNORE_BACKGROUNDS, "Disable for backgrounds"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_IGNORE_BACKGROUNDS_TOOLTIP, "This option skips texture enhancements for long, narrow textures that are usually used for backgrounds. This may save texture memory and improve performance.\n[Recommended: Checked, unless Enhancement is set to Store]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_USE_FILE_STORAGE, "Use file storage instead of memory cache"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_USE_TEXTURE_PACK, "Use texture pack"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_TEXTURE_PACK, "Texture pack path:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_TEXTURE_PACK_TOOLTIP, "Select path to the folder with texture packs.\nDefault: Plugin / hires_texture"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_CACHE_PATH, "Texture cache path:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_DUMP_PATH, "Texture dump path:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_USE_FULL_TRANSPARENCIES, "Use full transparencies (recommended for newer texture packs)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_USE_FULL_TRANSPARENCIES_TOOLTIP, "When this option is cleared, textures will be loaded as they are when using Rice Video: transparencies either on or off. When this option is selected, GlideN64 will check how the texture's alpha channel was designed and will select the most appropriate format. This gives texture pack designers freedom to use semi-transparent textures.\nClear this option for older or poorly designed texture packs.\n[Recommended: Texture pack dependent]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_ALTERNATIVE_CRC, "Alternative CRC calculation (for old Rice Video packs)"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_ALTERNATIVE_CRC_TOOLTIP, "This option emulates a palette CRC calculation bug in Rice Video. If you have problems loading textures, try checking or unchecking this option.\n[Recommended: Mostly unchecked, checked for old texture packs]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_FILE_STORAGE, "Use file storage instead of memory cache"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_DUMP_EDIT, "Dump/edit textures"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_DUMP_EDIT_TOOLTIP, "This option dumps textures on screen to a texture pack folder. You can also reload textures while the game is running to see how they look instantlybig time saver!\nHotkeys:\nUse R to reload textures from the texture pack\nUse D to toggle texture dumping on or off"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_SIZE_OF_MEMORY_CACHE, "Size of memory cache for enhanced textures:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_SIZE_OF_MEMORY_CACHE_TOOLTIP, "Enhanced and filtered textures can be cached to improve performance. This option adjusts how much memory is dedicated to the texture cache. This can improve performance if there are many requests for the same texture, which is usually the case. Normally 128 MB should be more than enough, but the best option is different for each game. Super Mario 64 may not need more than 32 MB, but Conker's Bad Fur Day can take advantage of 256 MB+. Adjust accordingly if you are having performance problems. Setting this option to 0 disables the cache.\n[Recommended: PC and game dependent]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_SAVE_ENHANCED, "Save enhanced texture cache to hard disk"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_SAVE_ENHANCED_TOOLTIP, "This option saves all previously loaded and enhanced textures to your PC. When the game is next launched, textures don't have to be recreated, causing smoother performance.\nWhen using texture packs, loading packs will take only a few seconds when the game is launched as opposed to the 5-60 seconds that loading usually takes. However, if you change the texture pack you'll have to manually delete the texture cache. Saved cache files are saved to a folder called Cache within the plugins folder.\n[Recommended: Checked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_COMPRESS_CACHE, "Compress texture cache"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_COMPRESS_CACHE_TOOLTIP, "Textures will be compressed so more textures can be held in the cache. The compression ratio varies per texture, but the compression is typically 1/5 of the original size.\n[Recommended: Checked]"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_CONVERT_16BPP, "Convert textures to 16 bpp"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(TEXTURE_CONVERT_16BPP_TOOLTIP, "This option halves the space used by textures in the texture cache and video card memory to improve performance. When reducing the color, GLideN64 tries to perserve the original quality as much as possible. On most textures it's hardly noticeable, but some textures, like skies, can look noticeably worse.\n[Recommended: Unchecked]"));
+
+	//On-screen display
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_POSITION, "Position"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_DISPLAY_FPS, "Display FPS"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_DISPLAY_VI, "Display VI/s"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_DISPLAY_PERCENTAGE, "Display percentage"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_DISPLAY_INTERNAL_RESOLUTION, "Display internal resolution"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_DISPLAY_RENDERING_RESOLUTION, "Display rendering resolution"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_FONT, "Font"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_SIZE, "Size:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_PX, "px"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_COLOR, "Color:"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(OSD_PREVIEW, "Preview"));
+
+	//Debug tab
+	g_defaultStrings.insert(LANG_STRINGS::value_type(DEBUG_DUMP_LOWLEVEL_INFO, "Dump low-level info"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(DEBUG_DUMP_DISPLAY_LIST, "Dump display list commands"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(DEBUG_DUMP_DETAILED_INFO, "Dump detailed info (matrices, vertices, etc.)"));
+
+	//About
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_ABOUT_TITLE, "About GLideN64"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_TAB_ABOUT, "About"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_TAB_CONTRIBUTORS, "Contributors"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_TAB_FUNDERS, "Funders"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_TAB_CREDITS, "Credits"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_NEXT_GENERATION, "The next generation open source graphics plugin for N64 emulators."));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_AUTHORS, "Authors"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_DEVELOPER, "Developer"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_BETA_TESTER, "Beta tester"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_GUI_DESIGNER, "GUI designer"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_AND_MORE, "... and more"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_AUTHOR_GLN64, "Author of the original glN64 graphics plugin"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_AUTHOR_GLES2N64, "Author of gles2n64, a port of glN64 to GL ES 2.0"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_AUTHOR_GLIDEHQ, "Author of the GlideHQ texture library"));
+	g_defaultStrings.insert(LANG_STRINGS::value_type(ABOUT_AUTHOR_Z64, "Author of z64, an OpenGL LLE plugin"));
+}
+
+LANG_STR GetNextLangString(FILE * file)
+{
+	if (feof(file))
+		return LANG_STR(0, "");
+
+	char token = 0;
+	while (token != '#' && !feof(file))
+		fread(&token, 1, 1, file);
+
+	if (feof(file))
+		return LANG_STR(0, "");
+
+	int32_t StringID;
+	fscanf_s(file, "%d", &StringID);
+
+	token = 0;
+	while (token != '#' && !feof(file))
+		fread(&token, 1, 1, file);
+
+	if (feof(file))
+		return LANG_STR(0, "");
+
+	while (token != '"' && !feof(file))
+		fread(&token, 1, 1, file);
+
+	if (feof(file))
+		return LANG_STR(0, "");
+
+	fread(&token, 1, 1, file);
+	std::string text;
+	while (token != '"' && !feof(file)) {
+		text += token;
+		fread(&token, 1, 1, file);
+	}
+
+	std::string::size_type pos = text.find("\\n");
+	while (pos != std::string::npos) {
+		text.replace(pos, 2, "\n");
+		pos = text.find("\\n", pos + 1);
+	}
+	return LANG_STR(StringID, text);
+}
+
+bool LoadLanguageFile(const std::string & langFile)
+{
+	if (g_defaultStrings.size() == 0)
+		loadDefaultStrings();
+
+	g_currentStrings.clear();
+	if (g_debugLang)
+		return true;
+
+	FILE *file = NULL;
+	if (fopen_s(&file, langFile.c_str(), "rb") != 0 || file == NULL)
+		return false;
+
+	uint8_t utf_bom[3];
+	if (fread(&utf_bom, sizeof(utf_bom), 1, file) != 1 || utf_bom[0] != 0xEF || utf_bom[1] != 0xBB || utf_bom[2] != 0xBF) {
+		fclose(file);
+		return false;
+	}
+
+	while (!feof(file))
+		g_currentStrings.insert(GetNextLangString(file));
+
+	fclose(file);
+	return true;
+}
+
+void LoadCurrentStrings(const char * path, const std::string & lang)
+{
+	std::string translationsFolder(path);
+	std::replace(translationsFolder.begin(), translationsFolder.end(), '/', '\\');
+	if (translationsFolder[translationsFolder.length() - 1] != '\\')
+	{
+		translationsFolder += '\\';
+	}
+	translationsFolder += "translations\\";
+	if (lang.length() > 0)
+	{
+		std::string langFile = translationsFolder + lang;
+		if (LoadLanguageFile(langFile))
+		{
+			return;
+		}
+	} // default: attempt to use gliden64_en.Lang
+	std::string langFile = translationsFolder + "gliden64_en.Lang";
+	LoadLanguageFile(langFile);
+}
+
+
+std::string getLangString(const char * FileName, languageStringID ID)
+{
+	FILE *file = NULL;
+	if (fopen_s(&file, FileName, "rb") != 0 || file == NULL)
+		return "";
+
+	uint8_t utf_bom[3];
+	if (fread(&utf_bom, sizeof(utf_bom), 1, file) != 1 ||
+		utf_bom[0] != 0xEF ||
+		utf_bom[1] != 0xBB ||
+		utf_bom[2] != 0xBF)
+	{
+		fclose(file);
+		return "";
+	}
+
+	while (!feof(file)) {
+		LANG_STR String = GetNextLangString(file);
+		if (String.first == ID) {
+			fclose(file);
+			return String.second;
+		}
+	}
+	fclose(file);
+	return "";
+}
+
+LanguageList GetLanguageList(const char * path)
+{
+	std::string pluginFolder(path);
+	std::replace(pluginFolder.begin(), pluginFolder.end(), '/', '\\');
+	if (pluginFolder[pluginFolder.length() - 1] != '\\')
+	{
+		pluginFolder += '\\';
+	}
+	pluginFolder += "translations\\";
+	std::string nameFilters = pluginFolder + "gliden64_*.Lang";
+
+	WIN32_FIND_DATAA FindData;
+	HANDLE hFindFile = FindFirstFileA(nameFilters.c_str(), &FindData); // Find anything
+	LanguageList languages;
+	if (hFindFile != INVALID_HANDLE_VALUE) {
+		do {
+			std::string langFile = pluginFolder + FindData.cFileName;
+			LanguageFile file; 
+
+			file.Filename = FindData.cFileName;
+			file.LanguageName = getLangString(langFile.c_str(), LANGUAGE_NAME);
+
+			if (file.LanguageName.length() == 0)
+				continue;
+
+			languages.push_back(file);
+		} while (FindNextFileA(hFindFile, &FindData));
+		FindClose(hFindFile);
+	}
+	return languages;
+}
+
+const std::string & getString(languageStringID stringID)
+{
+	LANG_STRINGS::iterator currentString = g_currentStrings.find(stringID);
+	if (currentString != g_currentStrings.end())
+		return currentString->second;
+
+	if (g_debugLang) {
+		char debugStr[300];
+		sprintf_s(debugStr, "#%d#", stringID);
+		std::pair<LANG_STRINGS::iterator, bool> ret = g_currentStrings.insert(LANG_STRINGS::value_type(stringID, debugStr));
+		if (ret.second)
+			return ret.first->second;
+	}
+
+	LANG_STRINGS::iterator DefString = g_defaultStrings.find(stringID);
+	if (DefString != g_defaultStrings.end())
+	{
+		return DefString->second;
+	}
+	static std::string emptyString;
+	return emptyString;
+}
+
+std::wstring wGS(languageStringID StringID)
+{
+	return ToUTF16(getString(StringID).c_str());
+}
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/Language.h b/GLideN64/src/GLideNUI-wtl/Language.h
new file mode 100644
index 00000000..0db2d5b9
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/Language.h
@@ -0,0 +1,255 @@
+#pragma once
+#include <list>
+#include <string>
+
+enum languageStringID
+{
+	/*********************************************************************************
+	* Meta Information															   *
+	*********************************************************************************/
+	LANGUAGE_NAME = 1,
+
+	/*********************************************************************************
+	* Config Dialog																  *
+	*********************************************************************************/
+	TAB_VIDEO = 1000,
+	TAB_EMULATION = 1001,
+	TAB_FRAME_BUFFER = 1002,
+	TAB_TEXTURE_ENHANCEMENT = 1003,
+	TAB_OSD = 1004,
+	TAB_DEBUG = 1005,
+	CFG_SAVE_SETTINGS_FOR = 1010,
+	CFG_SETTINGS_PROFILE = 1011,
+	CFG_REMOVE = 1012,
+	CFG_RESTORE_DEFAULTS = 1013,
+	CFG_SAVE_AND_CLOSE = 1014,
+	CFG_SAVE = 1015,
+	CFG_CLOSE = 1016,
+
+	/*********************************************************************************
+	* Video Tab																	  *
+	*********************************************************************************/
+	VIDEO_GROUP = 2000,
+	VIDEO_FULL_SCREEN_RES = 2001,
+	VIDEO_FULL_SCREEN_RES_TOOLTIP = 2002,
+	VIDEO_REFRESH_RATE = 2003,
+	VIDEO_REFRESH_RATE_TOOLTIP = 2004,
+	VIDEO_WINDOWED_RESOLUTION = 2005,
+	VIDEO_WINDOWED_RESOLUTION_TOOLTIP = 2006,
+	VIDEO_ASPECT_RATIO = 2007,
+	VIDEO_ASPECT_RATIO_TOOLTIP = 2008,
+	VIDEO_ASPECT_4_3 = 2009,
+	VIDEO_ASPECT_16_19 = 2010,
+	VIDEO_ASPECT_STRETCH = 2011,
+	VIDEO_ASPECT_ADJUST = 2012,
+	VIDEO_VSYNC = 2013,
+	VIDEO_VSYNC_TOOLTIP = 2014,
+	VIDEO_THREADED_VIDEO = 2015,
+	VIDEO_THREADED_VIDEO_TOOLTIP = 2016,
+	VIDEO_OVERSCAN = 2017,
+	VIDEO_OVERSCAN_TOOLTIP = 2018,
+	VIDEO_NTSC = 2019,
+	VIDEO_PAL = 2020,
+	VIDEO_ANTI_ALIASING = 2021,
+	VIDEO_NO_ANTI_ALIASING = 2022,
+	VIDEO_FAST_ANTI_ALIASING = 2023,
+	VIDEO_MULTISAMPLE_ANTI_ALIASING = 2024,
+	VIDEO_AA_OFF = 2025,
+	VIDEO_AA_HIGH = 2026,
+	VIDEO_AA_TOOLTIP = 2027,
+	VIDEO_AA_INFO = 2028,
+	VIDEO_FILTERING_GROUP = 2029,
+	VIDEO_ANISOTROPIC = 2030,
+	VIDEO_ANISOTROPIC_OFF = 2031,
+	VIDEO_ANISOTROPIC_HIGH = 2032,
+	VIDEO_BILINEAR = 2033,
+	VIDEO_BILINEAR_STANDARD = 2034,
+	VIDEO_BILINEAR_3POINT = 2035,
+	VIDEO_BILINEAR_TOOLTIP = 2036,
+	VIDEO_DITHERING_GROUP = 2037,
+	VIDEO_PATTERN = 2038,
+	VIDEO_DITHERING_APPLY_TO_OUTPUT = 2039,
+	VIDEO_DITHERING_APPLY_TO_OUTPUT_TOOLTIP = 2040,
+	VIDEO_DITHERING_5BIT_QUANTIZATION = 2041,
+	VIDEO_DITHERING_5BIT_QUANTIZATION_TOOLTIP = 2042,
+	VIDEO_DITHERING_HIRES_NOISE = 2043,
+	VIDEO_DITHERING_HIRES_NOISE_TOOLTIP = 2044,
+	VIDEO_DITHERING_MODE_TOOLTIP = 2045,
+	VIDEO_DITHERING_DISABLE = 2046,
+	VIDEO_DITHERING_BAYER = 2047,
+	VIDEO_DITHERING_MAGIC_SQUARE = 2048,
+	VIDEO_DITHERING_BLUE_NOISE = 2049,
+	VIDEO_LANGUAGE = 2050,
+
+	/*********************************************************************************
+	* Emulation Tab																  *
+	*********************************************************************************/
+	EMULATION_USE_PER_GAME = 3000,
+	EMULATION_USE_PER_GAME_TOOLTIP = 3001,
+	EMULATION_N64_STYLE_MIP_MAPPING = 3002,
+	EMULATION_N64_STYLE_MIP_MAPPING_TOOLTIP = 3003,
+	EMULATION_HWLIGHTING = 3004,
+	EMULATION_HWLIGHTING_TOOLTIP = 3005,
+	EMULATION_SHADERS_STORAGE = 3006,
+	EMULATION_SHADERS_STORAGE_TOOLTIP = 3007,
+	EMULATION_INTERNAL_RES = 3008,
+	EMULATION_INTERNAL_RES_TOOLTIP = 3009,
+	EMULATION_FACTOR0X = 3010,
+	EMULATION_FACTOR1X = 3011,
+	EMULATION_FACTORXX = 3012,
+	EMULATION_GAMMA = 3013,
+	EMULATION_GAMMA_TOOLTIP = 3014,
+	EMULATION_GAMMA_CORRECTION = 3015,
+	EMULATION_GAMMA_INFO = 3016,
+	EMULATION_2D_ELEMENTS = 3017,
+	EMULATION_RENDER_2D_ELEMENTS = 3018,
+	EMULATION_RENDER_2D_TOOLTIP = 3019,
+	EMULATION_RENDER_DISABLE = 3020,
+	EMULATION_RENDER_ENABLE_OPTIMIZED = 3021,
+	EMULATION_RENDER_ENABLE_UNOPTIMIZED = 3022,
+	EMULATION_HALOS_REMOVAL = 3023,
+	EMULATION_FIX_BLACK_LINES = 3024,
+	EMULATION_FIX_BLACK_LINES_TOOLTIP = 3025,
+	EMULATION_ADJACENT_2D_ELEMENTS = 3026,
+	EMULATION_ALWAYS = 3027,
+	EMULATION_NEVER = 3028,
+	EMULATION_BACKGROUND = 3029,
+	EMULATION_BACKGROUND_TOOLTIP = 3030,
+	EMULATION_ONE_PIECE = 3031,
+	EMULATION_STRIPPED = 3032,
+
+	/*********************************************************************************
+	* Frame Buffer Tab															   *
+	*********************************************************************************/
+	FRAMEBUFFER_ENABLE = 4000,
+	FRAMEBUFFER_ENABLE_INFO = 4001,
+	FRAMEBUFFER_COPY_AUX_BUFFERS = 4002,
+	FRAMEBUFFER_COPY_AUX_BUFFERS_TOOLTIP = 4003,
+	FRAMEBUFFER_SWAP = 4004,
+	FRAMEBUFFER_SWAP_TOOLTIP = 4005,
+	FRAMEBUFFER_VERTICAL_INTERRUPT = 4006,
+	FRAMEBUFFER_VI_ORIGIN_CHANGE = 4007,
+	FRAMEBUFFER_COLOR_BUFFER_CHANGE = 4008,
+	FRAMEBUFFER_INFO_ENABLE = 4009,
+	FRAMEBUFFER_INFO_ENABLE_TOOLTIP = 4010,
+	FRAMEBUFFER_READ_COLOR_CHUNK = 4011,
+	FRAMEBUFFER_READ_COLOR_CHUNK_TOOLTIP = 4012,
+	FRAMEBUFFER_READ_DEPTH_CHUNK = 4013,
+	FRAMEBUFFER_READ_DEPTH_CHUNK_TOOLTIP = 4014,
+	FRAMEBUFFER_COPY_COLOR_BUFFER = 4015,
+	FRAMEBUFFER_COPY_COLOR_BUFFER_TOOLTIP = 4016,
+	FRAMEBUFFER_COPY_NEVER = 4017,
+	FRAMEBUFFER_COPY_SYNCHRONOUS = 4018,
+	FRAMEBUFFER_COPY_ASYNCHRONOUS = 4019,
+	FRAMEBUFFER_COPY_DEPTH_BUFFER = 4020,
+	FRAMEBUFFER_COPY_DEPTH_BUFFER_TOOLTIP = 4021,
+	FRAMEBUFFER_COPY_DEPTH_NEVER = 4022,
+	FRAMEBUFFER_COPY_DEPTH_VRAM = 4023,
+	FRAMEBUFFER_COPY_DEPTH_SOFTWARE = 4024,
+	FRAMEBUFFER_N64_DEPTH_COMPARE = 4025,
+	FRAMEBUFFER_N64_DEPTH_COMPARE_TOOLTIP = 4026,
+	FRAMEBUFFER_N64_DEPTH_DISABLE = 4027,
+	FRAMEBUFFER_N64_DEPTH_FAST = 4028,
+	FRAMEBUFFER_N64_DEPTH_COMPATIBLE = 4029,
+	FRAMEBUFFER_FORCE_DEPTH_BUFFER_CLEAR = 4030,
+	FRAMEBUFFER_FORCE_DEPTH_BUFFER_CLEAR_TOOLTIP = 4031,
+	FRAMEBUFFER_RENDER_FRAMEBUFFER = 4032,
+	FRAMEBUFFER_RENDER_FRAMEBUFFER_TOOLTIP = 4033,
+	FRAMEBUFFER_COPY_DEPTH_TO_MAIN = 4034,
+	FRAMEBUFFER_COPY_DEPTH_TO_MAIN_TOOLTIP = 4035,
+
+	/*********************************************************************************
+	* Texture Enhancement Tab														*
+	*********************************************************************************/
+	TEXTURE_N64_TEXTURES_GROUP = 5000,
+	TEXTURE_N64_FILTER = 5001,
+	TEXTURE_N64_FILTER_TOOLTIP = 5002,
+	TEXTURE_N64_FILTER_NONE = 5003,
+	TEXTURE_N64_FILTER_SMOOTH1 = 5004,
+	TEXTURE_N64_FILTER_SMOOTH2 = 5005,
+	TEXTURE_N64_FILTER_SMOOTH3 = 5006,
+	TEXTURE_N64_FILTER_SMOOTH4 = 5007,
+	TEXTURE_N64_FILTER_SHARP1 = 5008,
+	TEXTURE_N64_FILTER_SHARP2 = 5009,
+	TEXTURE_ENHANCEMENT = 5010,
+	TEXTURE_ENHANCEMENT_TOOLTIP = 5011,
+	TEXTURE_ENHANCEMENT_NONE = 5012,
+	TEXTURE_ENHANCEMENT_STORE = 5013,
+	TEXTURE_DECREASE_COLOR = 5014,
+	TEXTURE_DECREASE_COLOR_TOOLTIP = 5015,
+	TEXTURE_IGNORE_BACKGROUNDS = 5016,
+	TEXTURE_IGNORE_BACKGROUNDS_TOOLTIP = 5017,
+	TEXTURE_USE_FILE_STORAGE = 5018,
+	TEXTURE_USE_TEXTURE_PACK = 5019,
+	TEXTURE_TEXTURE_PACK = 5020,
+	TEXTURE_TEXTURE_PACK_TOOLTIP = 5021,
+	TEXTURE_CACHE_PATH = 5022,
+	TEXTURE_DUMP_PATH = 5023,
+	TEXTURE_USE_FULL_TRANSPARENCIES = 5024,
+	TEXTURE_USE_FULL_TRANSPARENCIES_TOOLTIP = 5025,
+	TEXTURE_ALTERNATIVE_CRC = 5026,
+	TEXTURE_ALTERNATIVE_CRC_TOOLTIP = 5027,
+	TEXTURE_FILE_STORAGE = 5028,
+	TEXTURE_DUMP_EDIT = 5029,
+	TEXTURE_DUMP_EDIT_TOOLTIP = 5030,
+	TEXTURE_SIZE_OF_MEMORY_CACHE = 5031,
+	TEXTURE_SIZE_OF_MEMORY_CACHE_TOOLTIP = 5032,
+	TEXTURE_SAVE_ENHANCED = 5033,
+	TEXTURE_SAVE_ENHANCED_TOOLTIP = 5034,
+	TEXTURE_COMPRESS_CACHE = 5035,
+	TEXTURE_COMPRESS_CACHE_TOOLTIP = 5036,
+	TEXTURE_CONVERT_16BPP = 5037,
+	TEXTURE_CONVERT_16BPP_TOOLTIP = 5038,
+
+	/*********************************************************************************
+	* On-screen display															  *
+	*********************************************************************************/
+	OSD_POSITION = 6000,
+	OSD_DISPLAY_FPS = 6001,
+	OSD_DISPLAY_VI = 6002,
+	OSD_DISPLAY_PERCENTAGE = 6003,
+	OSD_DISPLAY_INTERNAL_RESOLUTION = 6004,
+	OSD_DISPLAY_RENDERING_RESOLUTION = 6005,
+	OSD_FONT = 6006,
+	OSD_SIZE = 6007,
+	OSD_PX = 6008,
+	OSD_COLOR = 6009,
+	OSD_PREVIEW = 6010,
+
+	/*********************************************************************************
+	* Debug																		  *
+	*********************************************************************************/
+	DEBUG_DUMP_LOWLEVEL_INFO = 7000,
+	DEBUG_DUMP_DISPLAY_LIST = 7001,
+	DEBUG_DUMP_DETAILED_INFO = 7002,
+
+	/*********************************************************************************
+	* About																		  *
+	*********************************************************************************/
+	ABOUT_ABOUT_TITLE = 9000,
+	ABOUT_TAB_ABOUT = 9001,
+	ABOUT_TAB_CONTRIBUTORS = 9002,
+	ABOUT_TAB_FUNDERS = 9003,
+	ABOUT_TAB_CREDITS = 9004,
+	ABOUT_NEXT_GENERATION = 9005,
+	ABOUT_AUTHORS = 9006,
+	ABOUT_DEVELOPER = 9007,
+	ABOUT_BETA_TESTER = 9008,
+	ABOUT_GUI_DESIGNER = 9009,
+	ABOUT_AND_MORE = 9010,
+	ABOUT_AUTHOR_GLN64 = 9011,
+	ABOUT_AUTHOR_GLES2N64 = 9012,
+	ABOUT_AUTHOR_GLIDEHQ = 9013,
+	ABOUT_AUTHOR_Z64 = 9014,
+};
+
+struct LanguageFile
+{
+	std::string Filename;
+	std::string LanguageName;
+};
+typedef std::list<LanguageFile> LanguageList;
+
+void LoadCurrentStrings(const char * path, const std::string & lang);
+LanguageList GetLanguageList(const char * path);
+std::wstring wGS(languageStringID StringID);
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/ScreenShot.cpp b/GLideN64/src/GLideNUI-wtl/ScreenShot.cpp
new file mode 100644
index 00000000..e6443487
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/ScreenShot.cpp
@@ -0,0 +1,122 @@
+#include "GLideNUI.h"
+#include "../Config.h"
+#include "util.h"
+#include <Windows.h>
+#include "../GLideNHQ/inc/png.h"
+
+void write_png_file(const wchar_t * file_name, int width, int height, const uint8_t *buffer)
+{
+#pragma warning(disable: 4996)
+	FILE *fp = _wfopen(file_name, L"wb");
+#pragma warning(default: 4996)
+	if (!fp) return;
+
+	png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
+	if (png_ptr == NULL) {
+		fclose(fp);
+		return;
+	}
+
+	png_infop info_ptr = png_create_info_struct(png_ptr);
+	if (info_ptr == NULL) {
+		png_destroy_read_struct(&png_ptr, NULL, NULL);
+		fclose(fp);
+		return;
+	}
+
+	if (setjmp(png_jmpbuf(png_ptr))) {
+		png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+		fclose(fp);
+		return;
+	}
+
+	png_init_io(png_ptr, fp);
+
+	if (setjmp(png_jmpbuf(png_ptr))) {
+		png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+		fclose(fp);
+		return;
+	}
+
+	png_byte bit_depth = 8;
+	png_byte color_type = PNG_COLOR_TYPE_RGB;
+	png_set_IHDR(png_ptr, info_ptr, width, height, bit_depth, color_type, PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);
+
+	png_write_info(png_ptr, info_ptr);
+
+	if (setjmp(png_jmpbuf(png_ptr))) {
+		png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+		fclose(fp);
+		return;
+	}
+
+	int pixel_size = 3;
+	int p = 0;
+	png_bytep * row_pointers = (png_bytep*)malloc(sizeof(png_bytep)* height);
+	for (int y = height - 1; y >= 0; y--) {
+		row_pointers[y] = (png_byte*)malloc(width*pixel_size);
+		for (int x = 0; x < width; x++) {
+			row_pointers[y][x*pixel_size + 0] = buffer[p++];
+			row_pointers[y][x*pixel_size + 1] = buffer[p++];
+			row_pointers[y][x*pixel_size + 2] = buffer[p++];
+		}
+	}
+	png_write_image(png_ptr, row_pointers);
+
+	for (int y = 0; y < height; y++) {
+		free(row_pointers[y]);
+	}
+	free(row_pointers);
+
+	if (setjmp(png_jmpbuf(png_ptr))) {
+		png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
+		fclose(fp);
+		return;
+	}
+	png_write_end(png_ptr, NULL);
+	fclose(fp);
+}
+
+EXPORT void CALL SaveScreenshot(const wchar_t * _folder, const char * _name, int _width, int _height, const unsigned char * _data)
+{
+	const wchar_t * fileExt = L"png";
+
+	std::wstring folder = _folder;
+	if (folder.size() > 1 && folder[folder.size() - 1] == L'\\') folder.resize(folder.size() - 1);
+
+	WIN32_FIND_DATA	FindData = { 0 };
+	HANDLE hFindFile = FindFirstFile(folder.c_str(), &FindData); // Find anything
+	if (hFindFile == INVALID_HANDLE_VALUE) {
+		::CreateDirectory(folder.c_str(), NULL);
+		hFindFile = FindFirstFile(folder.c_str(), &FindData);
+	}
+	if (hFindFile != INVALID_HANDLE_VALUE)
+		FindClose(hFindFile);
+
+	if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0)
+		return;
+
+	std::wstring romName = ToUTF16(_name);
+	for (size_t i = 0, n = romName.size(); i < n; i++) {
+		if (romName[i] == L' ') romName[i] = L'_';
+		if (romName[i] == L':') romName[i] = L';';
+	}
+
+	wchar_t fileName[MAX_PATH];
+	int i;
+	for (i = 0; i < 1000; ++i) {
+#pragma warning(disable: 4996)
+		swprintf(fileName, L"%ls\\GLideN64_%ls_%03i.%s", folder.c_str(), romName.c_str(), i, fileExt);
+#pragma warning(default: 4996)
+		hFindFile = FindFirstFile(fileName, &FindData);
+		if (hFindFile == INVALID_HANDLE_VALUE)
+		{
+			break;
+		}
+		FindClose(hFindFile);
+	}
+	if (i == 1000)
+		return;
+	
+	write_png_file(fileName, _width, _height, _data);
+}
diff --git a/GLideN64/src/GLideNUI-wtl/Settings.cpp b/GLideN64/src/GLideNUI-wtl/Settings.cpp
new file mode 100644
index 00000000..c6a15564
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/Settings.cpp
@@ -0,0 +1,564 @@
+#ifdef _WIN32
+#include <windows.h>
+#else
+#include "../winlnxdefs.h"
+#endif
+#include "../GBI.h"
+#include "../Config.h"
+
+#include "Settings.h"
+#include "GlSettings.h"
+#include "util.h"
+#include <algorithm>
+#include <memory>
+
+static const char * strIniFileName = "GLideN64.ini";
+static const char * strCustomSettingsFileName = "GLideN64.custom.ini";
+static const char * strUserProfile = "User";
+
+static
+void _loadSettings(GlSettings & settings)
+{
+	config.version = settings.value("version").toInt();
+
+	settings.beginGroup("video");
+	config.video.fullscreenWidth = settings.value("fullscreenWidth", config.video.fullscreenWidth).toInt();
+	config.video.fullscreenHeight = settings.value("fullscreenHeight", config.video.fullscreenHeight).toInt();
+	config.video.windowedWidth = settings.value("windowedWidth", config.video.windowedWidth).toInt();
+	config.video.windowedHeight = settings.value("windowedHeight", config.video.windowedHeight).toInt();
+	config.video.fullscreenRefresh = settings.value("fullscreenRefresh", config.video.fullscreenRefresh).toInt();
+	config.video.multisampling = settings.value("multisampling", config.video.multisampling).toInt();
+	config.video.fxaa= settings.value("fxaa", config.video.fxaa).toInt();
+	config.video.verticalSync = settings.value("verticalSync", config.video.verticalSync).toInt();
+	config.video.threadedVideo = settings.value("threadedVideo", config.video.threadedVideo).toInt();
+	settings.endGroup();
+
+	settings.beginGroup("texture");
+	config.texture.maxAnisotropy = settings.value("maxAnisotropy", config.texture.maxAnisotropy).toInt();
+	config.texture.bilinearMode = settings.value("bilinearMode", config.texture.bilinearMode).toInt();
+	config.texture.enableHalosRemoval = settings.value("enableHalosRemoval", config.texture.enableHalosRemoval).toInt();
+	config.texture.screenShotFormat = settings.value("screenShotFormat", config.texture.screenShotFormat).toInt();
+	settings.endGroup();
+
+	settings.beginGroup("generalEmulation");
+	config.generalEmulation.enableDitheringPattern = settings.value("enableDitheringPattern", config.generalEmulation.enableDitheringPattern).toInt();
+	config.generalEmulation.enableDitheringQuantization = settings.value("enableDitheringQuantization", config.generalEmulation.enableDitheringQuantization).toInt();
+	config.generalEmulation.enableHiresNoiseDithering = settings.value("enableHiresNoiseDithering", config.generalEmulation.enableHiresNoiseDithering).toInt();
+	config.generalEmulation.rdramImageDitheringMode = settings.value("rdramImageDitheringMode", config.generalEmulation.rdramImageDitheringMode).toInt();
+	config.generalEmulation.enableLOD = settings.value("enableLOD", config.generalEmulation.enableLOD).toInt();
+	config.generalEmulation.enableHWLighting = settings.value("enableHWLighting", config.generalEmulation.enableHWLighting).toInt();
+	config.generalEmulation.enableShadersStorage = settings.value("enableShadersStorage", config.generalEmulation.enableShadersStorage).toInt();
+	config.generalEmulation.enableCustomSettings = settings.value("enableCustomSettings", config.generalEmulation.enableCustomSettings).toInt();
+	settings.endGroup();
+
+	settings.beginGroup("graphics2D");
+	config.graphics2D.correctTexrectCoords = settings.value("correctTexrectCoords", config.graphics2D.correctTexrectCoords).toInt();
+	config.graphics2D.enableNativeResTexrects = settings.value("enableNativeResTexrects", config.graphics2D.enableNativeResTexrects).toInt();
+	config.graphics2D.bgMode = settings.value("bgMode", config.graphics2D.bgMode).toInt();
+	settings.endGroup();
+
+	settings.beginGroup("frameBufferEmulation");
+	config.frameBufferEmulation.enable = settings.value("enable", config.frameBufferEmulation.enable).toInt();
+	config.frameBufferEmulation.aspect = settings.value("aspect", config.frameBufferEmulation.aspect).toInt();
+	config.frameBufferEmulation.nativeResFactor = settings.value("nativeResFactor", config.frameBufferEmulation.nativeResFactor).toInt();
+	config.frameBufferEmulation.bufferSwapMode = settings.value("bufferSwapMode", config.frameBufferEmulation.bufferSwapMode).toInt();
+	config.frameBufferEmulation.N64DepthCompare = settings.value("N64DepthCompare", config.frameBufferEmulation.N64DepthCompare).toInt();
+	config.frameBufferEmulation.forceDepthBufferClear = settings.value("forceDepthBufferClear", config.frameBufferEmulation.forceDepthBufferClear).toInt();
+	config.frameBufferEmulation.copyAuxToRDRAM = settings.value("copyAuxToRDRAM", config.frameBufferEmulation.copyAuxToRDRAM).toInt();
+	config.frameBufferEmulation.copyToRDRAM = settings.value("copyToRDRAM", config.frameBufferEmulation.copyToRDRAM).toInt();
+	config.frameBufferEmulation.copyDepthToRDRAM = settings.value("copyDepthToRDRAM", config.frameBufferEmulation.copyDepthToRDRAM).toInt();
+	config.frameBufferEmulation.copyFromRDRAM = settings.value("copyFromRDRAM", config.frameBufferEmulation.copyFromRDRAM).toInt();
+	config.frameBufferEmulation.fbInfoDisabled = settings.value("fbInfoDisabled", config.frameBufferEmulation.fbInfoDisabled).toInt();
+	config.frameBufferEmulation.fbInfoReadColorChunk = settings.value("fbInfoReadColorChunk", config.frameBufferEmulation.fbInfoReadColorChunk).toInt();
+	config.frameBufferEmulation.fbInfoReadDepthChunk = settings.value("fbInfoReadDepthChunk", config.frameBufferEmulation.fbInfoReadDepthChunk).toInt();
+	config.frameBufferEmulation.copyDepthToMainDepthBuffer = settings.value("copyDepthToMainDepthBuffer", config.frameBufferEmulation.copyDepthToMainDepthBuffer).toInt();
+	config.frameBufferEmulation.enableOverscan = settings.value("enableOverscan", config.frameBufferEmulation.enableOverscan).toInt();
+	config.frameBufferEmulation.overscanPAL.left = settings.value("overscanPalLeft", config.frameBufferEmulation.overscanPAL.left).toInt();
+	config.frameBufferEmulation.overscanPAL.right = settings.value("overscanPalRight", config.frameBufferEmulation.overscanPAL.right).toInt();
+	config.frameBufferEmulation.overscanPAL.top = settings.value("overscanPalTop", config.frameBufferEmulation.overscanPAL.top).toInt();
+	config.frameBufferEmulation.overscanPAL.bottom= settings.value("overscanPalBottom", config.frameBufferEmulation.overscanPAL.bottom).toInt();
+	config.frameBufferEmulation.overscanNTSC.left = settings.value("overscanNtscLeft", config.frameBufferEmulation.overscanNTSC.left).toInt();
+	config.frameBufferEmulation.overscanNTSC.right = settings.value("overscanNtscRight", config.frameBufferEmulation.overscanNTSC.right).toInt();
+	config.frameBufferEmulation.overscanNTSC.top = settings.value("overscanNtscTop", config.frameBufferEmulation.overscanNTSC.top).toInt();
+	config.frameBufferEmulation.overscanNTSC.bottom = settings.value("overscanNtscBottom", config.frameBufferEmulation.overscanNTSC.bottom).toInt();
+	settings.endGroup();
+
+	settings.beginGroup("textureFilter");
+	config.textureFilter.txFilterMode = settings.value("txFilterMode", config.textureFilter.txFilterMode).toInt();
+	config.textureFilter.txEnhancementMode = settings.value("txEnhancementMode", config.textureFilter.txEnhancementMode).toInt();
+	config.textureFilter.txDeposterize = settings.value("txDeposterize", config.textureFilter.txDeposterize).toInt();
+	config.textureFilter.txFilterIgnoreBG = settings.value("txFilterIgnoreBG", config.textureFilter.txFilterIgnoreBG).toInt();
+	config.textureFilter.txCacheSize = settings.value("txCacheSize", config.textureFilter.txCacheSize).toInt();
+	config.textureFilter.txHiresEnable = settings.value("txHiresEnable", config.textureFilter.txHiresEnable).toInt();
+	config.textureFilter.txHiresFullAlphaChannel = settings.value("txHiresFullAlphaChannel", config.textureFilter.txHiresFullAlphaChannel).toInt();
+	config.textureFilter.txHresAltCRC = settings.value("txHresAltCRC", config.textureFilter.txHresAltCRC).toInt();
+	config.textureFilter.txDump = settings.value("txDump", config.textureFilter.txDump).toInt();
+	config.textureFilter.txForce16bpp = settings.value("txForce16bpp", config.textureFilter.txForce16bpp).toInt();
+	config.textureFilter.txCacheCompression = settings.value("txCacheCompression", config.textureFilter.txCacheCompression).toInt();
+	config.textureFilter.txSaveCache = settings.value("txSaveCache", config.textureFilter.txSaveCache).toInt();
+	config.textureFilter.txEnhancedTextureFileStorage = settings.value("txEnhancedTextureFileStorage", config.textureFilter.txEnhancedTextureFileStorage).toInt();
+	config.textureFilter.txHiresTextureFileStorage = settings.value("txHiresTextureFileStorage", config.textureFilter.txHiresTextureFileStorage).toInt();
+	wcscpy_s(config.textureFilter.txPath, ToUTF16(settings.value("txPath", FromUTF16(config.textureFilter.txPath).c_str()).toString().c_str()).c_str());
+	wcscpy_s(config.textureFilter.txCachePath, ToUTF16(settings.value("txCachePath", FromUTF16(config.textureFilter.txPath).c_str()).toString().c_str()).c_str());
+	wcscpy_s(config.textureFilter.txDumpPath, ToUTF16(settings.value("txDumpPath", FromUTF16(config.textureFilter.txPath).c_str()).toString().c_str()).c_str());
+	settings.endGroup();
+
+	settings.beginGroup("font");
+	config.font.name = settings.value("name", config.font.name.c_str()).toString();
+	config.font.size = settings.value("size", config.font.size).toInt();
+	GlColor fontColor = settings.value("color", GlColor(config.font.color[0], config.font.color[1], config.font.color[2])).toGlColor();
+	config.font.color[0] = fontColor.Red();
+	config.font.color[1] = fontColor.Green();
+	config.font.color[2] = fontColor.Blue();
+	config.font.color[3] = fontColor.Alpha();
+	config.font.colorf[0] = _FIXED2FLOAT(config.font.color[0], 8);
+	config.font.colorf[1] = _FIXED2FLOAT(config.font.color[1], 8);
+	config.font.colorf[2] = _FIXED2FLOAT(config.font.color[2], 8);
+	config.font.colorf[3] = config.font.color[3] == 0 ? 1.0f : _FIXED2FLOAT(config.font.color[3], 8);
+	settings.endGroup();
+
+	settings.beginGroup("gammaCorrection");
+	config.gammaCorrection.force = settings.value("force", config.gammaCorrection.force).toInt();
+	config.gammaCorrection.level = settings.value("level", config.gammaCorrection.level).toFloat();
+	settings.endGroup();
+
+	settings.beginGroup("onScreenDisplay");
+	config.onScreenDisplay.fps = settings.value("showFPS", config.onScreenDisplay.fps).toInt();
+	config.onScreenDisplay.vis = settings.value("showVIS", config.onScreenDisplay.vis).toInt();
+	config.onScreenDisplay.percent = settings.value("showPercent", config.onScreenDisplay.percent).toInt();
+	config.onScreenDisplay.internalResolution = settings.value("showInternalResolution", config.onScreenDisplay.internalResolution).toInt();
+	config.onScreenDisplay.renderingResolution = settings.value("showRenderingResolution", config.onScreenDisplay.renderingResolution).toInt();
+	config.onScreenDisplay.pos = settings.value("osdPos", config.onScreenDisplay.pos).toInt();
+	settings.endGroup();
+
+	settings.beginGroup("debug");
+	config.debug.dumpMode = settings.value("dumpMode", config.debug.dumpMode).toInt();
+	settings.endGroup();
+}
+
+void loadSettings(const char * _strIniFolder)
+{
+	std::string IniFileName = _strIniFolder;
+	IniFileName += "/";
+	IniFileName += strIniFileName;
+
+	bool rewriteSettings = false;
+	{
+		const u32 hacks = config.generalEmulation.hacks;
+		GlSettings settings(IniFileName.c_str());
+		const u32 configVersion = settings.value("version", 0).toInt();
+		config.resetToDefaults();
+		config.generalEmulation.hacks = hacks;
+		config.translationFile = settings.value("translation", config.translationFile.c_str()).toString();
+		if (configVersion < CONFIG_WITH_PROFILES) {
+			_loadSettings(settings);
+			config.version = CONFIG_VERSION_CURRENT;
+			settings.clear();
+			settings.setValue("version", CONFIG_VERSION_CURRENT);
+			settings.setValue("profile", strUserProfile);
+			settings.setValue("translation", config.translationFile.c_str());
+			settings.beginGroup(strUserProfile);
+			writeSettings(_strIniFolder);
+			settings.endGroup();
+		} else {
+			std::string profile = settings.value("profile", strUserProfile).toString();
+			GlSettings::sections childGroups = settings.childGroups();
+			if (childGroups.find(profile.c_str()) != childGroups.end()) {
+				settings.beginGroup(profile.c_str());
+				_loadSettings(settings);
+				settings.endGroup();
+			} else
+				rewriteSettings = true;
+			if (config.version != CONFIG_VERSION_CURRENT)
+				rewriteSettings = true;
+		}
+	}
+	if (rewriteSettings) {
+		// Keep settings up-to-date
+		{
+			GlSettings settings(IniFileName.c_str());
+			std::string profile = settings.value("profile", strUserProfile).toString();
+			settings.remove(profile.c_str());
+		}
+		config.version = CONFIG_VERSION_CURRENT;
+		writeSettings(_strIniFolder);
+	}
+}
+
+void writeSettings(const char * _strIniFolder)
+{
+	std::string IniFileName = _strIniFolder;
+	IniFileName += "/";
+	IniFileName += strIniFileName;
+
+	GlSettings settings(IniFileName.c_str());
+	settings.setValue("version", config.version);
+	settings.setValue("translation", config.translationFile.c_str());
+	std::string profile = settings.value("profile", strUserProfile).toString();
+	if (profile.length() > 0)
+	{
+		settings.beginGroup(profile.c_str());
+		settings.setValue("version", config.version);
+
+		settings.beginGroup("video");
+		settings.setValue("fullscreenWidth", config.video.fullscreenWidth);
+		settings.setValue("fullscreenHeight", config.video.fullscreenHeight);
+		settings.setValue("windowedWidth", config.video.windowedWidth);
+		settings.setValue("windowedHeight", config.video.windowedHeight);
+		settings.setValue("fullscreenRefresh", config.video.fullscreenRefresh);
+		settings.setValue("multisampling", config.video.multisampling);
+		settings.setValue("fxaa", config.video.fxaa);
+		settings.setValue("verticalSync", config.video.verticalSync);
+		settings.setValue("threadedVideo", config.video.threadedVideo);
+		settings.endGroup();
+
+		settings.beginGroup("texture");
+		settings.setValue("maxAnisotropy", config.texture.maxAnisotropy);
+		settings.setValue("bilinearMode", config.texture.bilinearMode);
+		settings.setValue("enableHalosRemoval", config.texture.enableHalosRemoval);
+		settings.setValue("screenShotFormat", config.texture.screenShotFormat);
+		settings.endGroup();
+
+		settings.beginGroup("generalEmulation");
+		settings.setValue("enableDitheringPattern", config.generalEmulation.enableDitheringPattern);
+		settings.setValue("enableDitheringQuantization", config.generalEmulation.enableDitheringQuantization);
+		settings.setValue("enableHiresNoiseDithering", config.generalEmulation.enableHiresNoiseDithering);
+		settings.setValue("rdramImageDitheringMode", config.generalEmulation.rdramImageDitheringMode);
+		settings.setValue("enableLOD", config.generalEmulation.enableLOD);
+		settings.setValue("enableHWLighting", config.generalEmulation.enableHWLighting);
+		settings.setValue("enableShadersStorage", config.generalEmulation.enableShadersStorage);
+		settings.setValue("enableCustomSettings", config.generalEmulation.enableCustomSettings);
+		settings.endGroup();
+
+		settings.beginGroup("graphics2D");
+		settings.setValue("correctTexrectCoords", config.graphics2D.correctTexrectCoords);
+		settings.setValue("enableNativeResTexrects", config.graphics2D.enableNativeResTexrects);
+		settings.setValue("bgMode", config.graphics2D.bgMode);
+		settings.endGroup();
+
+		settings.beginGroup("frameBufferEmulation");
+		settings.setValue("enable", config.frameBufferEmulation.enable);
+		settings.setValue("aspect", config.frameBufferEmulation.aspect);
+		settings.setValue("nativeResFactor", config.frameBufferEmulation.nativeResFactor);
+		settings.setValue("bufferSwapMode", config.frameBufferEmulation.bufferSwapMode);
+		settings.setValue("N64DepthCompare", config.frameBufferEmulation.N64DepthCompare);
+		settings.setValue("forceDepthBufferClear", config.frameBufferEmulation.forceDepthBufferClear);
+		settings.setValue("copyAuxToRDRAM", config.frameBufferEmulation.copyAuxToRDRAM);
+		settings.setValue("copyFromRDRAM", config.frameBufferEmulation.copyFromRDRAM);
+		settings.setValue("copyToRDRAM", config.frameBufferEmulation.copyToRDRAM);
+		settings.setValue("copyDepthToRDRAM", config.frameBufferEmulation.copyDepthToRDRAM);
+		settings.setValue("fbInfoDisabled", config.frameBufferEmulation.fbInfoDisabled);
+		settings.setValue("fbInfoReadColorChunk", config.frameBufferEmulation.fbInfoReadColorChunk);
+		settings.setValue("fbInfoReadDepthChunk", config.frameBufferEmulation.fbInfoReadDepthChunk);
+		settings.setValue("copyDepthToMainDepthBuffer", config.frameBufferEmulation.copyDepthToMainDepthBuffer);
+		settings.setValue("enableOverscan", config.frameBufferEmulation.enableOverscan);
+		settings.setValue("overscanPalLeft", config.frameBufferEmulation.overscanPAL.left);
+		settings.setValue("overscanPalRight", config.frameBufferEmulation.overscanPAL.right);
+		settings.setValue("overscanPalTop", config.frameBufferEmulation.overscanPAL.top);
+		settings.setValue("overscanPalBottom", config.frameBufferEmulation.overscanPAL.bottom);
+		settings.setValue("overscanNtscLeft", config.frameBufferEmulation.overscanNTSC.left);
+		settings.setValue("overscanNtscRight", config.frameBufferEmulation.overscanNTSC.right);
+		settings.setValue("overscanNtscTop", config.frameBufferEmulation.overscanNTSC.top);
+		settings.setValue("overscanNtscBottom", config.frameBufferEmulation.overscanNTSC.bottom);
+		settings.endGroup();
+
+		settings.beginGroup("textureFilter");
+		settings.setValue("txFilterMode", config.textureFilter.txFilterMode);
+		settings.setValue("txEnhancementMode", config.textureFilter.txEnhancementMode);
+		settings.setValue("txDeposterize", config.textureFilter.txDeposterize);
+		settings.setValue("txFilterIgnoreBG", config.textureFilter.txFilterIgnoreBG);
+		settings.setValue("txCacheSize", config.textureFilter.txCacheSize);
+		settings.setValue("txHiresEnable", config.textureFilter.txHiresEnable);
+		settings.setValue("txHiresFullAlphaChannel", config.textureFilter.txHiresFullAlphaChannel);
+		settings.setValue("txHresAltCRC", config.textureFilter.txHresAltCRC);
+		settings.setValue("txDump", config.textureFilter.txDump);
+		settings.setValue("txForce16bpp", config.textureFilter.txForce16bpp);
+		settings.setValue("txCacheCompression", config.textureFilter.txCacheCompression);
+		settings.setValue("txSaveCache", config.textureFilter.txSaveCache);
+		settings.setValue("txEnhancedTextureFileStorage", config.textureFilter.txEnhancedTextureFileStorage);
+		settings.setValue("txHiresTextureFileStorage", config.textureFilter.txHiresTextureFileStorage);
+		settings.setValue("txPath", FromUTF16(config.textureFilter.txPath).c_str());
+		settings.setValue("txCachePath", FromUTF16(config.textureFilter.txCachePath).c_str());
+		settings.setValue("txDumpPath", FromUTF16(config.textureFilter.txDumpPath).c_str());
+		settings.endGroup();
+
+		settings.beginGroup("font");
+		settings.setValue("name", config.font.name.c_str());
+		settings.setValue("size", config.font.size);
+		settings.setValue("color", GlColor(config.font.color[0], config.font.color[1], config.font.color[2], config.font.color[3]));
+		settings.endGroup();
+
+		settings.beginGroup("gammaCorrection");
+		settings.setValue("force", config.gammaCorrection.force);
+		settings.setValue("level", config.gammaCorrection.level);
+		settings.endGroup();
+
+		settings.beginGroup("onScreenDisplay");
+		settings.setValue("showFPS", config.onScreenDisplay.fps);
+		settings.setValue("showVIS", config.onScreenDisplay.vis);
+		settings.setValue("showPercent", config.onScreenDisplay.percent);
+		settings.setValue("showInternalResolution", config.onScreenDisplay.internalResolution);
+		settings.setValue("showRenderingResolution", config.onScreenDisplay.renderingResolution);
+		settings.setValue("osdPos", config.onScreenDisplay.pos);
+		settings.endGroup();
+
+		settings.beginGroup("debug");
+		settings.setValue("dumpMode", config.debug.dumpMode);
+		settings.endGroup();
+
+		settings.endGroup();
+	}
+}
+
+static
+std::string _getRomName(const char * _strRomName)
+{
+	std::string RomName;
+
+	enum { CP_SHIFT_JIS = 932 };
+	int utf16size = MultiByteToWideChar(CP_SHIFT_JIS, MB_ERR_INVALID_CHARS, _strRomName, -1, 0, 0);
+	if (utf16size != 0)
+	{
+		std::unique_ptr<wchar_t> pUTF16(new WCHAR[utf16size]);
+		if (MultiByteToWideChar(CP_SHIFT_JIS, 0, (LPCCH)_strRomName, -1, pUTF16.get(), utf16size) != 0)
+		{
+			std::wstring wsRomName(pUTF16.get(), utf16size);
+			std::transform(wsRomName.begin(), wsRomName.end(), wsRomName.begin(), (int(*)(int)) toupper);
+			std::string::size_type pos = wsRomName.find(L" ");
+			std::wstring replace = L"%20";
+			while (pos != std::string::npos)
+			{
+				wsRomName.replace(pos, 1, replace);
+				pos = wsRomName.find(L" ", pos + replace.length());
+			}
+
+			int utf8size = ::WideCharToMultiByte(CP_UTF8, 0, wsRomName.c_str(), -1, 0, 0, 0, 0);
+			if (utf8size != 0)
+			{
+				std::unique_ptr<char> pUTF8(new char[utf8size]);
+				if (::WideCharToMultiByte(CP_UTF8, 0, wsRomName.c_str(), -1, pUTF8.get(), utf8size, 0, 0) != 0)
+				{
+					RomName = std::string(pUTF8.get());
+				}
+			}
+		}
+	}
+	return RomName;
+}
+
+void loadCustomRomSettings(const char * _strIniFolder, const char * _strRomName)
+{
+	std::string CustomIniFileName = _strIniFolder;
+	CustomIniFileName += "/";
+	CustomIniFileName += strCustomSettingsFileName;
+
+	GlSettings settings(CustomIniFileName.c_str());
+	GlSettings::sections childGroups = settings.childGroups();
+	const std::string romName = _getRomName(_strRomName);
+	if (childGroups.find(romName.c_str()) == childGroups.end())
+		return;
+
+	settings.beginGroup(romName.c_str());
+	_loadSettings(settings);
+	settings.endGroup();
+	config.version = CONFIG_VERSION_CURRENT;
+}
+
+void saveCustomRomSettings(const char * _strIniFolder, const char * _strRomName)
+{
+	Config origConfig;
+	origConfig.resetToDefaults();
+	std::swap(config, origConfig);
+	loadSettings(_strIniFolder);
+	std::swap(config, origConfig);
+
+	std::string CustomIniFileName = _strIniFolder;
+	CustomIniFileName += "/";
+	CustomIniFileName += strCustomSettingsFileName;
+
+	GlSettings settings(CustomIniFileName.c_str());
+	const std::string romName = _getRomName(_strRomName);
+
+#define WriteCustomSetting(G, S) \
+	if (origConfig.G.S  != config.G.S || \
+		origConfig.G.S != settings.value(#S, config.G.S).toInt()) \
+		settings.setValue(#S, config.G.S)
+#define WriteCustomSetting2(G, N, S) \
+	if (origConfig.G.S  != config.G.S || \
+		origConfig.G.S != settings.value(#N, config.G.S).toInt()) \
+		settings.setValue(#N, config.G.S)
+#define WriteCustomSettingF(G, S) \
+	if (origConfig.G.S  != config.G.S || \
+		origConfig.G.S != settings.value(#S, config.G.S).toFloat()) \
+		settings.setValue(#S, config.G.S)
+#define WriteCustomSettingS(S) \
+	const std::string new##S = FromUTF16(config.textureFilter.txPath); \
+	const std::string orig##S = FromUTF16(origConfig.textureFilter.txPath); \
+	if (orig##S != new##S || \
+		orig##S != settings.value(#S, new##S.c_str()).toString()) \
+		settings.setValue(#S, new##S.c_str())
+
+	settings.beginGroup(romName.c_str());
+
+	settings.beginGroup("video");
+	WriteCustomSetting(video, fullscreenWidth);
+	WriteCustomSetting(video, fullscreenHeight);
+	WriteCustomSetting(video, windowedWidth);
+	WriteCustomSetting(video, windowedHeight);
+	WriteCustomSetting(video, fullscreenRefresh);
+	WriteCustomSetting(video, multisampling);
+	WriteCustomSetting(video, fxaa);
+	WriteCustomSetting(video, verticalSync);
+	settings.endGroup();
+
+	settings.beginGroup("texture");
+	WriteCustomSetting(texture, maxAnisotropy);
+	WriteCustomSetting(texture, bilinearMode);
+	WriteCustomSetting(texture, enableHalosRemoval);
+	WriteCustomSetting(texture, screenShotFormat);
+	settings.endGroup();
+
+	settings.beginGroup("generalEmulation");
+	WriteCustomSetting(generalEmulation, enableDitheringPattern);
+	WriteCustomSetting(generalEmulation, enableDitheringQuantization);
+	WriteCustomSetting(generalEmulation, enableHiresNoiseDithering);
+	WriteCustomSetting(generalEmulation, rdramImageDitheringMode);
+	WriteCustomSetting(generalEmulation, enableLOD);
+	WriteCustomSetting(generalEmulation, enableHWLighting);
+	WriteCustomSetting(generalEmulation, enableShadersStorage);
+	settings.endGroup();
+
+	settings.beginGroup("graphics2D");
+	WriteCustomSetting(graphics2D, correctTexrectCoords);
+	WriteCustomSetting(graphics2D, enableNativeResTexrects);
+	WriteCustomSetting(graphics2D, bgMode);
+	settings.endGroup();
+
+	settings.beginGroup("frameBufferEmulation");
+	WriteCustomSetting(frameBufferEmulation, enable);
+	WriteCustomSetting(frameBufferEmulation, aspect);
+	WriteCustomSetting(frameBufferEmulation, nativeResFactor);
+	WriteCustomSetting(frameBufferEmulation, bufferSwapMode);
+	WriteCustomSetting(frameBufferEmulation, N64DepthCompare);
+	WriteCustomSetting(frameBufferEmulation, forceDepthBufferClear);
+	WriteCustomSetting(frameBufferEmulation, copyAuxToRDRAM);
+	WriteCustomSetting(frameBufferEmulation, copyFromRDRAM);
+	WriteCustomSetting(frameBufferEmulation, copyToRDRAM);
+	WriteCustomSetting(frameBufferEmulation, copyDepthToRDRAM);
+	WriteCustomSetting(frameBufferEmulation, fbInfoDisabled);
+	WriteCustomSetting(frameBufferEmulation, fbInfoReadColorChunk);
+	WriteCustomSetting(frameBufferEmulation, fbInfoReadDepthChunk);
+	WriteCustomSetting(frameBufferEmulation, copyDepthToMainDepthBuffer);
+	WriteCustomSetting(frameBufferEmulation, enableOverscan);
+	WriteCustomSetting2(frameBufferEmulation, overscanPalLeft, overscanPAL.left);
+	WriteCustomSetting2(frameBufferEmulation, overscanPalRight, overscanPAL.right);
+	WriteCustomSetting2(frameBufferEmulation, overscanPalTop, overscanPAL.top);
+	WriteCustomSetting2(frameBufferEmulation, overscanPalBottom, overscanPAL.bottom);
+	WriteCustomSetting2(frameBufferEmulation, overscanNtscLeft, overscanNTSC.left);
+	WriteCustomSetting2(frameBufferEmulation, overscanNtscRight, overscanNTSC.right);
+	WriteCustomSetting2(frameBufferEmulation, overscanNtscTop, overscanNTSC.top);
+	WriteCustomSetting2(frameBufferEmulation, overscanNtscBottom, overscanNTSC.bottom);
+	settings.endGroup();
+
+	settings.beginGroup("textureFilter");
+	WriteCustomSetting(textureFilter, txFilterMode);
+	WriteCustomSetting(textureFilter, txEnhancementMode);
+	WriteCustomSetting(textureFilter, txDeposterize);
+	WriteCustomSetting(textureFilter, txFilterIgnoreBG);
+	WriteCustomSetting(textureFilter, txCacheSize);
+	WriteCustomSetting(textureFilter, txEnhancedTextureFileStorage);
+	WriteCustomSetting(textureFilter, txHiresTextureFileStorage);
+	WriteCustomSetting(textureFilter, txHiresEnable);
+	WriteCustomSetting(textureFilter, txHiresFullAlphaChannel);
+	WriteCustomSetting(textureFilter, txHresAltCRC);
+	WriteCustomSetting(textureFilter, txDump);
+	WriteCustomSetting(textureFilter, txForce16bpp);
+	WriteCustomSetting(textureFilter, txCacheCompression);
+	WriteCustomSetting(textureFilter, txSaveCache);
+	WriteCustomSettingS(txPath);
+	WriteCustomSettingS(txCachePath);
+	WriteCustomSettingS(txDumpPath);
+	settings.endGroup();
+
+	settings.beginGroup("gammaCorrection");
+	WriteCustomSetting(gammaCorrection, force);
+	WriteCustomSettingF(gammaCorrection, level);
+	settings.endGroup();
+
+	settings.beginGroup("onScreenDisplay");
+	WriteCustomSetting2(onScreenDisplay, showFPS, fps);
+	WriteCustomSetting2(onScreenDisplay, showVIS, vis);
+	WriteCustomSetting2(onScreenDisplay, showPercent, percent);
+	WriteCustomSetting2(onScreenDisplay, showInternalResolution, internalResolution);
+	WriteCustomSetting2(onScreenDisplay, showRenderingResolution, renderingResolution);
+	WriteCustomSetting2(onScreenDisplay, osdPos, pos);
+	settings.endGroup();
+
+	settings.endGroup();
+}
+
+std::string getTranslationFile()
+{
+	return config.translationFile.c_str();
+}
+
+ProfileList getProfiles(const char * _strIniFolder)
+{
+	std::string IniFileName = _strIniFolder;
+	IniFileName += "/";
+	IniFileName += strIniFileName;
+	GlSettings settings(IniFileName.c_str());
+	GlSettings::sections children = settings.childGroups();
+
+	ProfileList profiles;
+	for (GlSettings::sections::const_iterator itr = children.begin(); itr != children.end(); itr++)
+	{
+		profiles.insert(itr->c_str());
+	}
+	return profiles;
+}
+
+std::string getCurrentProfile(const char * _strIniFolder)
+{
+	std::string IniFileName = _strIniFolder;
+	IniFileName += "/";
+	IniFileName += strIniFileName;
+	GlSettings settings(IniFileName.c_str());
+	return settings.value("profile", strUserProfile).toString();
+}
+
+void changeProfile(const char * _strIniFolder, const char * _strProfile)
+{
+	{
+		std::string IniFileName = _strIniFolder;
+		IniFileName += "/";
+		IniFileName += strIniFileName;
+
+		GlSettings settings(IniFileName.c_str());
+		settings.setValue("profile", _strProfile);
+	}
+	loadSettings(_strIniFolder);
+}
+
+void addProfile(const char * _strIniFolder, const char * _strProfile)
+{
+	{
+		std::string IniFileName = _strIniFolder;
+		IniFileName += "/";
+		IniFileName += strIniFileName;
+
+		GlSettings settings(IniFileName.c_str());
+		settings.setValue("profile", _strProfile);
+	}
+	writeSettings(_strIniFolder);
+}
+
+void removeProfile(const char * _strIniFolder, const char * _strProfile)
+{
+	std::string IniFileName = _strIniFolder;
+	IniFileName += "/";
+	IniFileName += strIniFileName;
+
+	GlSettings settings(IniFileName.c_str());
+	settings.remove(_strProfile);
+}
diff --git a/GLideN64/src/GLideNUI-wtl/Settings.h b/GLideN64/src/GLideNUI-wtl/Settings.h
new file mode 100644
index 00000000..97a81a2d
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/Settings.h
@@ -0,0 +1,15 @@
+#pragma once
+#include <string>
+#include <set>
+typedef std::set<std::string> ProfileList;
+
+void loadSettings(const char * _strIniFolder);
+void writeSettings(const char * _strIniFolder);
+void loadCustomRomSettings(const char * _strIniFolder, const char * _strRomName);
+void saveCustomRomSettings(const char * _strIniFolder, const char * _strRomName);
+std::string getTranslationFile();
+ProfileList getProfiles(const char * _strIniFolder);
+std::string getCurrentProfile(const char * _strIniFolder);
+void changeProfile(const char * _strIniFolder, const char * _strProfile);
+void addProfile(const char * _strIniFolder, const char * _strProfile);
+void removeProfile(const char * _strIniFolder, const char * _strProfile);
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlapp.h b/GLideN64/src/GLideNUI-wtl/WTL/atlapp.h
new file mode 100644
index 00000000..742a6f68
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlapp.h
@@ -0,0 +1,2125 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLAPP_H__
+#define __ATLAPP_H__
+
+#pragma once
+
+#ifndef __cplusplus
+	#error WTL requires C++ compilation (use a .cpp suffix)
+#endif
+
+#ifndef __ATLBASE_H__
+	#error atlapp.h requires atlbase.h to be included first
+#endif
+
+#ifndef _WIN32_WCE
+  #if (WINVER < 0x0400)
+	#error WTL requires Windows version 4.0 or higher
+  #endif
+
+  #if (_WIN32_IE < 0x0300)
+	#error WTL requires IE version 3.0 or higher
+  #endif
+#endif
+
+#ifdef _ATL_NO_COMMODULE
+	#error WTL requires that _ATL_NO_COMMODULE is not defined
+#endif
+
+#if (_ATL_VER >= 0x0900) && defined(_ATL_MIN_CRT)
+	#error _ATL_MIN_CRT is not supported with ATL 9.0 and higher
+#endif
+
+#if defined(_WIN32_WCE) && defined(_ATL_MIN_CRT)
+	#pragma message("Warning: WTL for Windows CE doesn't use _ATL_MIN_CRT")
+#endif
+
+#include <limits.h>
+#if !defined(_ATL_MIN_CRT) && defined(_MT) && !defined(_WIN32_WCE)
+  #include <process.h>	// for _beginthreadex
+#endif
+
+#if (_ATL_VER < 0x0800) && !defined(_DEBUG)
+  #include <stdio.h>
+#endif
+
+#include <commctrl.h>
+#ifndef _WIN32_WCE
+  #pragma comment(lib, "comctl32.lib")
+#endif
+
+#ifndef _WIN32_WCE
+  #include "atlres.h"
+#else // CE specific
+  #include "atlresce.h"
+#endif // _WIN32_WCE
+
+// We need to disable this warning because of template class arguments
+#pragma warning(disable: 4127)
+
+#if (_ATL_VER >= 0x0900) && !defined(_SECURE_ATL)
+  #define _SECURE_ATL	1
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// WTL version number
+
+#define _WTL_VER	0x0810
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CMessageFilter
+// CIdleHandler
+// CMessageLoop
+//
+// CAppModule
+// CServerAppModule
+//
+// CRegKeyEx
+//
+// Global functions:
+//   AtlGetDefaultGuiFont()
+//   AtlCreateControlFont()
+//   AtlCreateBoldFont()
+//   AtlInitCommonControls()
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Global support for Windows CE
+
+#ifdef _WIN32_WCE
+
+#ifndef SW_SHOWDEFAULT
+  #define SW_SHOWDEFAULT	SW_SHOWNORMAL
+#endif // !SW_SHOWDEFAULT
+
+// These get's OR-ed in a constant and will have no effect.
+// Defining them reduces the number of #ifdefs required for CE.
+#define LR_DEFAULTSIZE      0
+#define LR_LOADFROMFILE     0
+
+#ifndef SM_CXCURSOR
+  #define SM_CXCURSOR             13
+#endif
+#ifndef SM_CYCURSOR
+  #define SM_CYCURSOR             14
+#endif
+
+inline BOOL IsMenu(HMENU hMenu)
+{
+	MENUITEMINFO mii = { sizeof(MENUITEMINFO) };
+	::SetLastError(0);
+	BOOL bRet = ::GetMenuItemInfo(hMenu, 0, TRUE, &mii);
+	if(!bRet)
+		bRet = (::GetLastError() != ERROR_INVALID_MENU_HANDLE) ? TRUE : FALSE;
+	return bRet;
+}
+
+#if (_WIN32_WCE >= 410)
+extern "C" void WINAPI ListView_SetItemSpacing(HWND hwndLV, int iHeight);
+#endif // (_WIN32_WCE >= 410)
+
+inline int MulDiv(IN int nNumber, IN int nNumerator, IN int nDenominator)
+{
+	__int64 multiple = nNumber * nNumerator;
+	return static_cast<int>(multiple / nDenominator);
+}
+
+#if (_ATL_VER >= 0x0800)
+
+#ifndef _WTL_KEEP_WS_OVERLAPPEDWINDOW
+  #ifdef WS_OVERLAPPEDWINDOW
+    #undef WS_OVERLAPPEDWINDOW
+    #define WS_OVERLAPPEDWINDOW	0
+  #endif // WS_OVERLAPPEDWINDOW
+#endif // !_WTL_KEEP_WS_OVERLAPPEDWINDOW
+
+#ifndef RDW_FRAME
+  #define RDW_FRAME	0
+#endif // !RDW_FRAME
+
+#ifndef WM_WINDOWPOSCHANGING
+  #define WM_WINDOWPOSCHANGING	0
+#endif // !WM_WINDOWPOSCHANGING
+
+#define FreeResource(x)
+#define UnlockResource(x)
+
+namespace ATL
+{
+  inline HRESULT CComModule::RegisterClassObjects(DWORD /*dwClsContext*/, DWORD /*dwFlags*/) throw()
+  { return E_NOTIMPL; }
+  inline HRESULT CComModule::RevokeClassObjects() throw()
+  { return E_NOTIMPL; }
+}; // namespace ATL
+
+#ifndef lstrlenW
+  #define lstrlenW	(int)ATL::lstrlenW
+#endif // lstrlenW
+
+inline int WINAPI lstrlenA(LPCSTR lpszString)
+{ return ATL::lstrlenA(lpszString); }
+
+#ifdef lstrcpyn
+  #undef lstrcpyn
+  #define lstrcpyn	ATL::lstrcpynW
+#endif // lstrcpyn
+
+#ifndef SetWindowLongPtrW
+  inline LONG_PTR tmp_SetWindowLongPtrW( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
+  {
+	return( ::SetWindowLongW( hWnd, nIndex, LONG( dwNewLong ) ) );
+  }
+  #define SetWindowLongPtrW tmp_SetWindowLongPtrW
+#endif
+
+#ifndef GetWindowLongPtrW
+  inline LONG_PTR tmp_GetWindowLongPtrW( HWND hWnd, int nIndex )
+  {
+	return( ::GetWindowLongW( hWnd, nIndex ) );
+  }
+  #define GetWindowLongPtrW tmp_GetWindowLongPtrW
+#endif
+
+#ifndef LongToPtr
+  #define LongToPtr(x) ((void*)x)
+#endif
+
+#ifndef PtrToInt
+  #define PtrToInt( p ) ((INT)(INT_PTR) (p) )
+#endif
+
+#else // !(_ATL_VER >= 0x0800)
+
+#ifdef lstrlenW
+  #undef lstrlenW
+  #define lstrlenW (int)::wcslen
+#endif // lstrlenW
+
+#define lstrlenA (int)strlen
+
+#ifndef lstrcpyn
+  inline LPTSTR lstrcpyn(LPTSTR lpstrDest, LPCTSTR lpstrSrc, int nLength)
+  {
+	if(lpstrDest == NULL || lpstrSrc == NULL || nLength <= 0)
+		return NULL;
+	int nLen = min(lstrlen(lpstrSrc), nLength - 1);
+	LPTSTR lpstrRet = (LPTSTR)memcpy(lpstrDest, lpstrSrc, nLen * sizeof(TCHAR));
+	lpstrDest[nLen] = 0;
+	return lpstrRet;
+  }
+#endif // !lstrcpyn
+
+#ifndef lstrcpynW
+  inline LPWSTR lstrcpynW(LPWSTR lpstrDest, LPCWSTR lpstrSrc, int nLength)
+  {
+	return lstrcpyn(lpstrDest, lpstrSrc, nLength);   // WinCE is Unicode only
+  }
+#endif // !lstrcpynW
+
+#ifndef lstrcpynA
+  inline LPSTR lstrcpynA(LPSTR lpstrDest, LPCSTR lpstrSrc, int nLength)
+  {
+	if(lpstrDest == NULL || lpstrSrc == NULL || nLength <= 0)
+		return NULL;
+	int nLen = min(lstrlenA(lpstrSrc), nLength - 1);
+	LPSTR lpstrRet = (LPSTR)memcpy(lpstrDest, lpstrSrc, nLen * sizeof(char));
+	lpstrDest[nLen] = 0;
+	return lpstrRet;
+  }
+#endif // !lstrcpyn
+
+#ifdef TrackPopupMenu
+  #undef TrackPopupMenu
+#endif // TrackPopupMenu
+
+#define DECLARE_WND_CLASS_EX(WndClassName, style, bkgnd) \
+static CWndClassInfo& GetWndClassInfo() \
+{ \
+	static CWndClassInfo wc = \
+	{ \
+		{ style, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName }, \
+		NULL, NULL, IDC_ARROW, TRUE, 0, _T("") \
+	}; \
+	return wc; \
+}
+
+#ifndef _MAX_FNAME
+  #define _MAX_FNAME	_MAX_PATH
+#endif // _MAX_FNAME
+
+#if (_WIN32_WCE < 400)
+  #define MAKEINTATOM(i)  (LPTSTR)((ULONG_PTR)((WORD)(i)))
+#endif // (_WIN32_WCE < 400)
+
+#if (_WIN32_WCE < 410)
+  #define WHEEL_PAGESCROLL                (UINT_MAX)
+  #define WHEEL_DELTA                     120
+#endif // (_WIN32_WCE < 410)
+
+#ifdef DrawIcon
+  #undef DrawIcon
+#endif
+
+#ifndef VARCMP_LT
+  #define VARCMP_LT   0
+#endif
+#ifndef VARCMP_EQ
+  #define VARCMP_EQ   1
+#endif
+#ifndef VARCMP_GT
+  #define VARCMP_GT   2
+#endif
+#ifndef VARCMP_NULL
+  #define VARCMP_NULL 3
+#endif
+
+#ifndef RDW_ALLCHILDREN
+  #define RDW_ALLCHILDREN   0
+#endif
+
+#endif // !(_ATL_VER >= 0x0800)
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Global support for using original VC++ 6.0 headers with WTL
+
+#ifndef _ATL_NO_OLD_HEADERS_WIN64
+#if !defined(_WIN64) && (_ATL_VER < 0x0700)
+
+  #ifndef PSM_INSERTPAGE
+    #define PSM_INSERTPAGE          (WM_USER + 119)
+  #endif // !PSM_INSERTPAGE
+
+  #ifndef GetClassLongPtr
+    #define GetClassLongPtrA   GetClassLongA
+    #define GetClassLongPtrW   GetClassLongW
+    #ifdef UNICODE
+      #define GetClassLongPtr  GetClassLongPtrW
+    #else
+      #define GetClassLongPtr  GetClassLongPtrA
+    #endif // !UNICODE
+  #endif // !GetClassLongPtr
+
+  #ifndef GCLP_HICONSM
+    #define GCLP_HICONSM        (-34)
+  #endif // !GCLP_HICONSM
+
+  #ifndef GetWindowLongPtr
+    #define GetWindowLongPtrA   GetWindowLongA
+    #define GetWindowLongPtrW   GetWindowLongW
+    #ifdef UNICODE
+      #define GetWindowLongPtr  GetWindowLongPtrW
+    #else
+      #define GetWindowLongPtr  GetWindowLongPtrA
+    #endif // !UNICODE
+  #endif // !GetWindowLongPtr
+
+  #ifndef SetWindowLongPtr
+    #define SetWindowLongPtrA   SetWindowLongA
+    #define SetWindowLongPtrW   SetWindowLongW
+    #ifdef UNICODE
+      #define SetWindowLongPtr  SetWindowLongPtrW
+    #else
+      #define SetWindowLongPtr  SetWindowLongPtrA
+    #endif // !UNICODE
+  #endif // !SetWindowLongPtr
+
+  #ifndef GWLP_WNDPROC
+    #define GWLP_WNDPROC        (-4)
+  #endif
+  #ifndef GWLP_HINSTANCE
+    #define GWLP_HINSTANCE      (-6)
+  #endif
+  #ifndef GWLP_HWNDPARENT
+    #define GWLP_HWNDPARENT     (-8)
+  #endif
+  #ifndef GWLP_USERDATA
+    #define GWLP_USERDATA       (-21)
+  #endif
+  #ifndef GWLP_ID
+    #define GWLP_ID             (-12)
+  #endif
+
+  #ifndef DWLP_MSGRESULT
+    #define DWLP_MSGRESULT  0
+  #endif
+
+  typedef long LONG_PTR;
+  typedef unsigned long ULONG_PTR;
+  typedef ULONG_PTR DWORD_PTR;
+
+  #ifndef HandleToUlong
+    #define HandleToUlong( h ) ((ULONG)(ULONG_PTR)(h) )
+  #endif
+  #ifndef HandleToLong
+    #define HandleToLong( h ) ((LONG)(LONG_PTR) (h) )
+  #endif
+  #ifndef LongToHandle
+    #define LongToHandle( h) ((HANDLE)(LONG_PTR) (h))
+  #endif
+  #ifndef PtrToUlong
+    #define PtrToUlong( p ) ((ULONG)(ULONG_PTR) (p) )
+  #endif
+  #ifndef PtrToLong
+    #define PtrToLong( p ) ((LONG)(LONG_PTR) (p) )
+  #endif
+  #ifndef PtrToUint
+    #define PtrToUint( p ) ((UINT)(UINT_PTR) (p) )
+  #endif
+  #ifndef PtrToInt
+    #define PtrToInt( p ) ((INT)(INT_PTR) (p) )
+  #endif
+  #ifndef PtrToUshort
+    #define PtrToUshort( p ) ((unsigned short)(ULONG_PTR)(p) )
+  #endif
+  #ifndef PtrToShort
+    #define PtrToShort( p ) ((short)(LONG_PTR)(p) )
+  #endif
+  #ifndef IntToPtr
+    #define IntToPtr( i )    ((VOID *)(INT_PTR)((int)i))
+  #endif
+  #ifndef UIntToPtr
+    #define UIntToPtr( ui )  ((VOID *)(UINT_PTR)((unsigned int)ui))
+  #endif
+  #ifndef LongToPtr
+    #define LongToPtr( l )   ((VOID *)(LONG_PTR)((long)l))
+  #endif
+  #ifndef ULongToPtr
+    #define ULongToPtr( ul )  ((VOID *)(ULONG_PTR)((unsigned long)ul))
+  #endif
+
+#endif // !defined(_WIN64) && (_ATL_VER < 0x0700)
+#endif // !_ATL_NO_OLD_HEADERS_WIN64
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Global support for SecureHelper functions
+
+#ifndef _TRUNCATE
+  #define _TRUNCATE ((size_t)-1)
+#endif
+
+#ifndef _ERRCODE_DEFINED
+  #define _ERRCODE_DEFINED
+  typedef int errno_t;
+#endif
+
+#ifndef _SECURECRT_ERRCODE_VALUES_DEFINED
+  #define _SECURECRT_ERRCODE_VALUES_DEFINED
+  #define EINVAL          22
+  #define STRUNCATE       80
+#endif
+
+#ifndef _countof
+  #define _countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Miscellaneous global support
+
+// define useful macros from winuser.h
+#ifndef IS_INTRESOURCE
+  #define IS_INTRESOURCE(_r) (((ULONG_PTR)(_r) >> 16) == 0)
+#endif // IS_INTRESOURCE
+
+// protect template members from windowsx.h macros
+#ifdef _INC_WINDOWSX
+  #undef SubclassWindow
+#endif // _INC_WINDOWSX
+
+// define useful macros from windowsx.h
+#ifndef GET_X_LPARAM
+  #define GET_X_LPARAM(lParam)	((int)(short)LOWORD(lParam))
+#endif
+#ifndef GET_Y_LPARAM
+  #define GET_Y_LPARAM(lParam)	((int)(short)HIWORD(lParam))
+#endif
+
+// Dummy structs for compiling with /CLR
+#if (_MSC_VER >= 1300) && defined(_MANAGED)
+  __if_not_exists(_IMAGELIST::_IMAGELIST) { struct _IMAGELIST { }; }
+  __if_not_exists(_TREEITEM::_TREEITEM) { struct _TREEITEM { }; }
+  __if_not_exists(_PSP::_PSP) { struct _PSP { }; }
+#endif
+
+// Define ATLVERIFY macro for ATL3
+#if (_ATL_VER < 0x0700)
+  #ifndef ATLVERIFY
+    #ifdef _DEBUG
+      #define ATLVERIFY(expr) ATLASSERT(expr)
+    #else
+      #define ATLVERIFY(expr) (expr)
+    #endif // DEBUG
+  #endif // ATLVERIFY
+#endif // (_ATL_VER < 0x0700)
+
+// Forward declaration for ATL3 and ATL11 fix
+#if (((_ATL_VER < 0x0700) && defined(_ATL_DLL)) || (_ATL_VER >= 0x0B00)) && !defined(_WIN32_WCE)
+  namespace ATL { HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor); };
+#endif
+
+#ifndef WM_MOUSEHWHEEL
+  #define WM_MOUSEHWHEEL                  0x020E
+#endif
+
+
+namespace WTL
+{
+
+#if (_ATL_VER >= 0x0700)
+  DECLARE_TRACE_CATEGORY(atlTraceUI);
+  #ifdef _DEBUG
+    __declspec(selectany) ATL::CTraceCategory atlTraceUI(_T("atlTraceUI"));
+  #endif // _DEBUG
+#else // !(_ATL_VER >= 0x0700)
+  enum wtlTraceFlags
+  {
+	atlTraceUI = 0x10000000
+  };
+#endif // !(_ATL_VER >= 0x0700)
+
+// Windows version helper
+inline bool AtlIsOldWindows()
+{
+	OSVERSIONINFO ovi = { 0 };
+	ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+	BOOL bRet = ::GetVersionEx(&ovi);
+	return (!bRet || !((ovi.dwMajorVersion >= 5) || (ovi.dwMajorVersion == 4 && ovi.dwMinorVersion >= 90)));
+}
+
+// Default GUI font helper - "MS Shell Dlg" stock font
+inline HFONT AtlGetDefaultGuiFont()
+{
+#ifndef _WIN32_WCE
+	return (HFONT)::GetStockObject(DEFAULT_GUI_FONT);
+#else // CE specific
+	return (HFONT)::GetStockObject(SYSTEM_FONT);
+#endif // _WIN32_WCE
+}
+
+// Control font helper - default font for controls not in a dialog
+// (NOTE: Caller owns the font, and should destroy it when it's no longer needed)
+inline HFONT AtlCreateControlFont()
+{
+#ifndef _WIN32_WCE
+	LOGFONT lf = { 0 };
+	ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0) != FALSE);
+	HFONT hFont = ::CreateFontIndirect(&lf);
+	ATLASSERT(hFont != NULL);
+	return hFont;
+#else // CE specific
+	return (HFONT)::GetStockObject(SYSTEM_FONT);
+#endif // _WIN32_WCE
+}
+
+// Bold font helper
+// (NOTE: Caller owns the font, and should destroy it when it's no longer needed)
+inline HFONT AtlCreateBoldFont(HFONT hFont = NULL)
+{
+	LOGFONT lf = { 0 };
+#ifndef _WIN32_WCE
+	if(hFont == NULL)
+		ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0) != FALSE);
+	else
+		ATLVERIFY(::GetObject(hFont, sizeof(LOGFONT), &lf) == sizeof(LOGFONT));
+#else // CE specific
+	if(hFont == NULL)
+		hFont = (HFONT)::GetStockObject(SYSTEM_FONT);
+	ATLVERIFY(::GetObject(hFont, sizeof(LOGFONT), &lf) == sizeof(LOGFONT));
+#endif // _WIN32_WCE
+	lf.lfWeight = FW_BOLD;
+	HFONT hFontBold =  ::CreateFontIndirect(&lf);
+	ATLASSERT(hFontBold != NULL);
+	return hFontBold;
+}
+
+// Common Controls initialization helper
+inline BOOL AtlInitCommonControls(DWORD dwFlags)
+{
+	INITCOMMONCONTROLSEX iccx = { sizeof(INITCOMMONCONTROLSEX), dwFlags };
+	BOOL bRet = ::InitCommonControlsEx(&iccx);
+	ATLASSERT(bRet);
+	return bRet;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// RunTimeHelper - helper functions for Windows version and structure sizes
+
+// Not for Windows CE
+#if defined(_WIN32_WCE) && !defined(_WTL_NO_RUNTIME_STRUCT_SIZE)
+  #define _WTL_NO_RUNTIME_STRUCT_SIZE
+#endif
+
+#ifndef _WTL_NO_RUNTIME_STRUCT_SIZE
+
+#ifndef _SIZEOF_STRUCT
+  #define _SIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
+#endif
+
+#if (_WIN32_WINNT >= 0x0600) && !defined(REBARBANDINFO_V6_SIZE)
+  #define REBARBANDINFO_V6_SIZE   _SIZEOF_STRUCT(REBARBANDINFO, cxHeader)
+#endif // (_WIN32_WINNT >= 0x0600) && !defined(REBARBANDINFO_V6_SIZE)
+
+#if (_WIN32_WINNT >= 0x0600) && !defined(LVGROUP_V5_SIZE)
+  #define LVGROUP_V5_SIZE   _SIZEOF_STRUCT(LVGROUP, uAlign)
+#endif // (_WIN32_WINNT >= 0x0600) && !defined(LVGROUP_V5_SIZE)
+
+#if (_WIN32_WINNT >= 0x0600) && !defined(LVTILEINFO_V5_SIZE)
+  #define LVTILEINFO_V5_SIZE   _SIZEOF_STRUCT(LVTILEINFO, puColumns)
+#endif // (_WIN32_WINNT >= 0x0600) && !defined(LVTILEINFO_V5_SIZE)
+
+#if defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN) && !defined(MCHITTESTINFO_V1_SIZE)
+  #define MCHITTESTINFO_V1_SIZE   _SIZEOF_STRUCT(MCHITTESTINFO, st)
+#endif // defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN) && !defined(MCHITTESTINFO_V1_SIZE)
+
+#if !defined(_WIN32_WCE) && (WINVER >= 0x0600) && !defined(NONCLIENTMETRICS_V1_SIZE)
+  #define NONCLIENTMETRICS_V1_SIZE   _SIZEOF_STRUCT(NONCLIENTMETRICS, lfMessageFont)
+#endif // !defined(_WIN32_WCE) && (WINVER >= 0x0600) && !defined(NONCLIENTMETRICS_V1_SIZE)
+
+#endif // !_WTL_NO_RUNTIME_STRUCT_SIZE
+
+namespace RunTimeHelper
+{
+#ifndef _WIN32_WCE
+	inline bool IsCommCtrl6()
+	{
+		DWORD dwMajor = 0, dwMinor = 0;
+		HRESULT hRet = ATL::AtlGetCommCtrlVersion(&dwMajor, &dwMinor);
+		return (SUCCEEDED(hRet) && (dwMajor >= 6));
+	}
+
+	inline bool IsVista()
+	{
+		OSVERSIONINFO ovi = { sizeof(OSVERSIONINFO) };
+		BOOL bRet = ::GetVersionEx(&ovi);
+		return ((bRet != FALSE) && (ovi.dwMajorVersion >= 6));
+	}
+
+	inline bool IsThemeAvailable()
+	{
+		bool bRet = false;
+
+		if(IsCommCtrl6())
+		{
+			HMODULE hThemeDLL = ::LoadLibrary(_T("uxtheme.dll"));
+			if(hThemeDLL != NULL)
+			{
+				typedef BOOL (STDAPICALLTYPE *PFN_IsThemeActive)();
+				PFN_IsThemeActive pfnIsThemeActive = (PFN_IsThemeActive)::GetProcAddress(hThemeDLL, "IsThemeActive");
+				ATLASSERT(pfnIsThemeActive != NULL);
+				bRet = (pfnIsThemeActive != NULL) && (pfnIsThemeActive() != FALSE);
+				if(bRet)
+				{
+					typedef BOOL (STDAPICALLTYPE *PFN_IsAppThemed)();
+					PFN_IsAppThemed pfnIsAppThemed = (PFN_IsAppThemed)::GetProcAddress(hThemeDLL, "IsAppThemed");
+					ATLASSERT(pfnIsAppThemed != NULL);
+					bRet = (pfnIsAppThemed != NULL) && (pfnIsAppThemed() != FALSE);
+				}
+
+				::FreeLibrary(hThemeDLL);
+			}
+		}
+
+		return bRet;
+	}
+
+	inline bool IsWin7()
+	{
+		OSVERSIONINFO ovi = { sizeof(OSVERSIONINFO) };
+		BOOL bRet = ::GetVersionEx(&ovi);
+		return ((bRet != FALSE) && (ovi.dwMajorVersion == 6) && (ovi.dwMinorVersion >= 1));
+	}
+
+	inline bool IsRibbonUIAvailable()
+	{
+		static INT iRibbonUI = -1;
+
+#if defined(NTDDI_WIN7) && (NTDDI_VERSION >= NTDDI_WIN7)
+		if (iRibbonUI == -1)
+		{
+			HMODULE hRibbonDLL = ::LoadLibrary(_T("propsys.dll"));
+			if (hRibbonDLL != NULL)
+			{
+				const GUID CLSID_UIRibbonFramework = { 0x926749fa, 0x2615, 0x4987, { 0x88, 0x45, 0xc3, 0x3e, 0x65, 0xf2, 0xb9, 0x57 } };
+				// block - create instance
+				{
+					ATL::CComPtr<IUnknown> pIUIFramework;
+					iRibbonUI = SUCCEEDED(pIUIFramework.CoCreateInstance(CLSID_UIRibbonFramework)) ? 1 : 0;
+				}
+				::FreeLibrary(hRibbonDLL);
+			}
+			else
+			{
+				iRibbonUI = 0;
+			}
+		}
+#endif // defined(NTDDI_WIN7) && (NTDDI_VERSION >= NTDDI_WIN7)
+
+		return (iRibbonUI == 1);
+	}
+
+#endif // !_WIN32_WCE
+
+	inline int SizeOf_REBARBANDINFO()
+	{
+		int nSize = sizeof(REBARBANDINFO);
+#if !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (_WIN32_WINNT >= 0x0600)
+		if(!(IsVista() && IsCommCtrl6()))
+			nSize = REBARBANDINFO_V6_SIZE;
+#endif // !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (_WIN32_WINNT >= 0x0600)
+		return nSize;
+	}
+
+#if (_WIN32_WINNT >= 0x501)
+  	inline int SizeOf_LVGROUP()
+	{
+		int nSize = sizeof(LVGROUP);
+#if !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (_WIN32_WINNT >= 0x0600)
+		if(!IsVista())
+			nSize = LVGROUP_V5_SIZE;
+#endif // !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (_WIN32_WINNT >= 0x0600)
+		return nSize;
+	}
+
+	inline int SizeOf_LVTILEINFO()
+	{
+		int nSize = sizeof(LVTILEINFO);
+#if !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (_WIN32_WINNT >= 0x0600)
+		if(!IsVista())
+			nSize = LVTILEINFO_V5_SIZE;
+#endif // !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (_WIN32_WINNT >= 0x0600)
+		return nSize;
+	}
+#endif // (_WIN32_WINNT >= 0x501)
+
+	inline int SizeOf_MCHITTESTINFO()
+	{
+		int nSize = sizeof(MCHITTESTINFO);
+#if !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+		if(!(IsVista() && IsCommCtrl6()))
+			nSize = MCHITTESTINFO_V1_SIZE;
+#endif // !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+		return nSize;
+	}
+
+#ifndef _WIN32_WCE
+	inline int SizeOf_NONCLIENTMETRICS()
+	{
+		int nSize = sizeof(NONCLIENTMETRICS);
+#if !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (WINVER >= 0x0600)
+		if(!IsVista())
+			nSize = NONCLIENTMETRICS_V1_SIZE;
+#endif // !defined(_WTL_NO_RUNTIME_STRUCT_SIZE) && (WINVER >= 0x0600)
+		return nSize;
+	}
+#endif // !_WIN32_WCE
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// ModuleHelper - helper functions for ATL3 and ATL7 module classes
+
+namespace ModuleHelper
+{
+	inline HINSTANCE GetModuleInstance()
+	{
+#if (_ATL_VER >= 0x0700)
+		return ATL::_AtlBaseModule.GetModuleInstance();
+#else // !(_ATL_VER >= 0x0700)
+		return ATL::_pModule->GetModuleInstance();
+#endif // !(_ATL_VER >= 0x0700)
+	}
+
+	inline HINSTANCE GetResourceInstance()
+	{
+#if (_ATL_VER >= 0x0700)
+		return ATL::_AtlBaseModule.GetResourceInstance();
+#else // !(_ATL_VER >= 0x0700)
+		return ATL::_pModule->GetResourceInstance();
+#endif // !(_ATL_VER >= 0x0700)
+	}
+
+	inline void AddCreateWndData(ATL::_AtlCreateWndData* pData, void* pObject)
+	{
+#if (_ATL_VER >= 0x0700)
+		ATL::_AtlWinModule.AddCreateWndData(pData, pObject);
+#else // !(_ATL_VER >= 0x0700)
+		ATL::_pModule->AddCreateWndData(pData, pObject);
+#endif // !(_ATL_VER >= 0x0700)
+	}
+
+	inline void* ExtractCreateWndData()
+	{
+#if (_ATL_VER >= 0x0700)
+		return ATL::_AtlWinModule.ExtractCreateWndData();
+#else // !(_ATL_VER >= 0x0700)
+		return ATL::_pModule->ExtractCreateWndData();
+#endif // !(_ATL_VER >= 0x0700)
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// SecureHelper - helper functions for VS2005 secure CRT
+
+namespace SecureHelper
+{
+	inline void strcpyA_x(char* lpstrDest, size_t cchDest, const char* lpstrSrc)
+	{
+#if _SECURE_ATL
+		ATL::Checked::strcpy_s(lpstrDest, cchDest, lpstrSrc);
+#else
+		if(cchDest > (size_t)lstrlenA(lpstrSrc))
+			ATLVERIFY(lstrcpyA(lpstrDest, lpstrSrc) != NULL);
+		else
+			ATLASSERT(FALSE);
+#endif
+	}
+
+	inline void strcpyW_x(wchar_t* lpstrDest, size_t cchDest, const wchar_t* lpstrSrc)
+	{
+#if _SECURE_ATL
+		ATL::Checked::wcscpy_s(lpstrDest, cchDest, lpstrSrc);
+#else
+		if(cchDest > (size_t)lstrlenW(lpstrSrc))
+			ATLVERIFY(lstrcpyW(lpstrDest, lpstrSrc) != NULL);
+		else
+			ATLASSERT(FALSE);
+#endif
+	}
+
+	inline void strcpy_x(LPTSTR lpstrDest, size_t cchDest, LPCTSTR lpstrSrc)
+	{
+#ifdef _UNICODE
+		strcpyW_x(lpstrDest, cchDest, lpstrSrc);
+#else
+		strcpyA_x(lpstrDest, cchDest, lpstrSrc);
+#endif
+	}
+
+	inline errno_t strncpyA_x(char* lpstrDest, size_t cchDest, const char* lpstrSrc, size_t cchCount)
+	{
+#if _SECURE_ATL
+		return ATL::Checked::strncpy_s(lpstrDest, cchDest, lpstrSrc, cchCount);
+#else
+		errno_t nRet = 0;
+		if(lpstrDest == NULL || cchDest == 0 || lpstrSrc == NULL)
+		{
+			nRet = EINVAL;
+		}
+		else if(cchCount == _TRUNCATE)
+		{
+			cchCount = min(cchDest - 1, size_t(lstrlenA(lpstrSrc)));
+			nRet = STRUNCATE;
+		}
+		else if(cchDest <= cchCount)
+		{
+			lpstrDest[0] = 0;
+			nRet = EINVAL;
+		}
+		if(nRet == 0 || nRet == STRUNCATE)
+			nRet = (lstrcpynA(lpstrDest, lpstrSrc, (int)cchCount + 1) != NULL) ? nRet : EINVAL;
+		ATLASSERT(nRet == 0 || nRet == STRUNCATE);
+		return nRet;
+#endif
+	}
+
+	inline errno_t strncpyW_x(wchar_t* lpstrDest, size_t cchDest, const wchar_t* lpstrSrc, size_t cchCount)
+	{
+#if _SECURE_ATL
+		return ATL::Checked::wcsncpy_s(lpstrDest, cchDest, lpstrSrc, cchCount);
+#else
+		errno_t nRet = 0;
+		if(lpstrDest == NULL || cchDest == 0 || lpstrSrc == NULL)
+		{
+			nRet = EINVAL;
+		}
+		else if(cchCount == _TRUNCATE)
+		{
+			cchCount = min(cchDest - 1, size_t(lstrlenW(lpstrSrc)));
+			nRet = STRUNCATE;
+		}
+		else if(cchDest <= cchCount)
+		{
+			lpstrDest[0] = 0;
+			nRet = EINVAL;
+		}
+		if(nRet == 0 || nRet == STRUNCATE)
+			nRet = (lstrcpynW(lpstrDest, lpstrSrc, (int)cchCount + 1) != NULL) ? nRet : EINVAL;
+		ATLASSERT(nRet == 0 || nRet == STRUNCATE);
+		return nRet;
+#endif
+	}
+
+	inline errno_t strncpy_x(LPTSTR lpstrDest, size_t cchDest, LPCTSTR lpstrSrc, size_t cchCount)
+	{
+#ifdef _UNICODE
+		return strncpyW_x(lpstrDest, cchDest, lpstrSrc, cchCount);
+#else
+		return strncpyA_x(lpstrDest, cchDest, lpstrSrc, cchCount);
+#endif
+	}
+
+	inline void strcatA_x(char* lpstrDest, size_t cchDest, const char* lpstrSrc)
+	{
+#if _SECURE_ATL
+		ATL::Checked::strcat_s(lpstrDest, cchDest, lpstrSrc);
+#else
+		if(cchDest > (size_t)lstrlenA(lpstrSrc))
+			ATLVERIFY(lstrcatA(lpstrDest, lpstrSrc) != NULL);
+		else
+			ATLASSERT(FALSE);
+#endif
+	}
+
+	inline void strcatW_x(wchar_t* lpstrDest, size_t cchDest, const wchar_t* lpstrSrc)
+	{
+#if _SECURE_ATL
+		ATL::Checked::wcscat_s(lpstrDest, cchDest, lpstrSrc);
+#else
+		if(cchDest > (size_t)lstrlenW(lpstrSrc))
+			ATLVERIFY(lstrcatW(lpstrDest, lpstrSrc) != NULL);
+		else
+			ATLASSERT(FALSE);
+#endif
+	}
+
+	inline void strcat_x(LPTSTR lpstrDest, size_t cchDest, LPCTSTR lpstrSrc)
+	{
+#ifdef _UNICODE
+		strcatW_x(lpstrDest, cchDest, lpstrSrc);
+#else
+		strcatA_x(lpstrDest, cchDest, lpstrSrc);
+#endif
+	}
+
+	inline void memcpy_x(void* pDest, size_t cbDest, const void* pSrc, size_t cbSrc)
+	{
+#if _SECURE_ATL
+		ATL::Checked::memcpy_s(pDest, cbDest, pSrc, cbSrc);
+#else
+		if(cbDest >= cbSrc)
+			memcpy(pDest, pSrc, cbSrc);
+		else
+			ATLASSERT(FALSE);
+#endif
+	}
+
+	inline void memmove_x(void* pDest, size_t cbDest, const void* pSrc, size_t cbSrc)
+	{
+#if _SECURE_ATL
+		ATL::Checked::memmove_s(pDest, cbDest, pSrc, cbSrc);
+#else
+		if(cbDest >= cbSrc)
+			memmove(pDest, pSrc, cbSrc);
+		else
+			ATLASSERT(FALSE);
+#endif
+	}
+
+	inline int vsprintf_x(LPTSTR lpstrBuff, size_t cchBuff, LPCTSTR lpstrFormat, va_list args)
+	{
+#if _SECURE_ATL && !defined(_ATL_MIN_CRT) && !defined(_WIN32_WCE)
+		return _vstprintf_s(lpstrBuff, cchBuff, lpstrFormat, args);
+#else
+		cchBuff;   // Avoid unused argument warning
+#pragma warning(disable: 4996)
+		return _vstprintf(lpstrBuff, lpstrFormat, args);
+#pragma warning(default: 4996)
+#endif
+	}
+
+	inline int wvsprintf_x(LPTSTR lpstrBuff, size_t cchBuff, LPCTSTR lpstrFormat, va_list args)
+	{
+#if _SECURE_ATL && !defined(_ATL_MIN_CRT) && !defined(_WIN32_WCE)
+		return _vstprintf_s(lpstrBuff, cchBuff, lpstrFormat, args);
+#else
+		cchBuff;   // Avoid unused argument warning
+		return ::wvsprintf(lpstrBuff, lpstrFormat, args);
+#endif
+	}
+
+	inline int sprintf_x(LPTSTR lpstrBuff, size_t cchBuff, LPCTSTR lpstrFormat, ...)
+	{
+		va_list args;
+		va_start(args, lpstrFormat);
+		int nRes = vsprintf_x(lpstrBuff, cchBuff, lpstrFormat, args);
+		va_end(args);
+		return nRes;
+	}
+
+	inline int wsprintf_x(LPTSTR lpstrBuff, size_t cchBuff, LPCTSTR lpstrFormat, ...)
+	{
+		va_list args;
+		va_start(args, lpstrFormat);
+		int nRes = wvsprintf_x(lpstrBuff, cchBuff, lpstrFormat, args);
+		va_end(args);
+		return nRes;
+	}
+}; // namespace SecureHelper
+
+
+///////////////////////////////////////////////////////////////////////////////
+// MinCrtHelper - helper functions for using _ATL_MIN_CRT
+
+namespace MinCrtHelper
+{
+	inline int _isspace(TCHAR ch)
+	{
+#ifndef _ATL_MIN_CRT
+		return _istspace(ch);
+#else // _ATL_MIN_CRT
+		WORD type = 0;
+		::GetStringTypeEx(::GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
+		return (type & C1_SPACE) == C1_SPACE;
+#endif // _ATL_MIN_CRT
+	}
+
+	inline int _isdigit(TCHAR ch)
+	{
+#ifndef _ATL_MIN_CRT
+		return _istdigit(ch);
+#else // _ATL_MIN_CRT
+		WORD type = 0;
+		::GetStringTypeEx(::GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
+		return (type & C1_DIGIT) == C1_DIGIT;
+#endif // _ATL_MIN_CRT
+	}
+
+	inline int _atoi(LPCTSTR str)
+	{
+#ifndef _ATL_MIN_CRT
+		return _ttoi(str);
+#else // _ATL_MIN_CRT
+		while(_isspace(*str) != 0)
+			++str;
+
+		TCHAR ch = *str++;
+		TCHAR sign = ch;   // save sign indication
+		if(ch == _T('-') || ch == _T('+'))
+			ch = *str++;   // skip sign
+
+		int total = 0;
+		while(_isdigit(ch) != 0)
+		{
+			total = 10 * total + (ch - '0');   // accumulate digit
+			ch = *str++;        // get next char
+		}
+
+		return (sign == '-') ? -total : total;   // return result, negated if necessary
+#endif // _ATL_MIN_CRT
+	}
+
+	inline LPCTSTR _strrchr(LPCTSTR str, TCHAR ch)
+	{
+#ifndef _ATL_MIN_CRT
+		return _tcsrchr(str, ch);
+#else // _ATL_MIN_CRT
+		LPCTSTR lpsz = NULL;
+		while(*str != 0)
+		{
+			if(*str == ch)
+				lpsz = str;
+			str = ::CharNext(str);
+		}
+		return lpsz;
+#endif // _ATL_MIN_CRT
+	}
+
+	inline LPTSTR _strrchr(LPTSTR str, TCHAR ch)
+	{
+#ifndef _ATL_MIN_CRT
+		return _tcsrchr(str, ch);
+#else // _ATL_MIN_CRT
+		LPTSTR lpsz = NULL;
+		while(*str != 0)
+		{
+			if(*str == ch)
+				lpsz = str;
+			str = ::CharNext(str);
+		}
+		return lpsz;
+#endif // _ATL_MIN_CRT
+	}
+}; // namespace MinCrtHelper
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMessageFilter - Interface for message filter support
+
+class CMessageFilter
+{
+public:
+	virtual BOOL PreTranslateMessage(MSG* pMsg) = 0;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CIdleHandler - Interface for idle processing
+
+class CIdleHandler
+{
+public:
+	virtual BOOL OnIdle() = 0;
+};
+
+#ifndef _ATL_NO_OLD_NAMES
+  // for compatilibility with old names only
+  typedef CIdleHandler CUpdateUIObject;
+  #define DoUpdate OnIdle
+#endif // !_ATL_NO_OLD_NAMES
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMessageLoop - message loop implementation
+
+class CMessageLoop
+{
+public:
+	ATL::CSimpleArray<CMessageFilter*> m_aMsgFilter;
+	ATL::CSimpleArray<CIdleHandler*> m_aIdleHandler;
+	MSG m_msg;
+
+// Message filter operations
+	BOOL AddMessageFilter(CMessageFilter* pMessageFilter)
+	{
+		return m_aMsgFilter.Add(pMessageFilter);
+	}
+
+	BOOL RemoveMessageFilter(CMessageFilter* pMessageFilter)
+	{
+		return m_aMsgFilter.Remove(pMessageFilter);
+	}
+
+// Idle handler operations
+	BOOL AddIdleHandler(CIdleHandler* pIdleHandler)
+	{
+		return m_aIdleHandler.Add(pIdleHandler);
+	}
+
+	BOOL RemoveIdleHandler(CIdleHandler* pIdleHandler)
+	{
+		return m_aIdleHandler.Remove(pIdleHandler);
+	}
+
+#ifndef _ATL_NO_OLD_NAMES
+	// for compatilibility with old names only
+	BOOL AddUpdateUI(CIdleHandler* pIdleHandler)
+	{
+		ATLTRACE2(atlTraceUI, 0, _T("CUpdateUIObject and AddUpdateUI are deprecated. Please change your code to use CIdleHandler and OnIdle\n"));
+		return AddIdleHandler(pIdleHandler);
+	}
+
+	BOOL RemoveUpdateUI(CIdleHandler* pIdleHandler)
+	{
+		ATLTRACE2(atlTraceUI, 0, _T("CUpdateUIObject and RemoveUpdateUI are deprecated. Please change your code to use CIdleHandler and OnIdle\n"));
+		return RemoveIdleHandler(pIdleHandler);
+	}
+#endif // !_ATL_NO_OLD_NAMES
+
+// message loop
+	int Run()
+	{
+		BOOL bDoIdle = TRUE;
+		int nIdleCount = 0;
+		BOOL bRet;
+
+		for(;;)
+		{
+			while(bDoIdle && !::PeekMessage(&m_msg, NULL, 0, 0, PM_NOREMOVE))
+			{
+				if(!OnIdle(nIdleCount++))
+					bDoIdle = FALSE;
+			}
+
+			bRet = ::GetMessage(&m_msg, NULL, 0, 0);
+
+			if(bRet == -1)
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("::GetMessage returned -1 (error)\n"));
+				continue;   // error, don't process
+			}
+			else if(!bRet)
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("CMessageLoop::Run - exiting\n"));
+				break;   // WM_QUIT, exit message loop
+			}
+
+			if(!PreTranslateMessage(&m_msg))
+			{
+				::TranslateMessage(&m_msg);
+				::DispatchMessage(&m_msg);
+			}
+
+			if(IsIdleMessage(&m_msg))
+			{
+				bDoIdle = TRUE;
+				nIdleCount = 0;
+			}
+		}
+
+		return (int)m_msg.wParam;
+	}
+
+	static BOOL IsIdleMessage(MSG* pMsg)
+	{
+		// These messages should NOT cause idle processing
+		switch(pMsg->message)
+		{
+		case WM_MOUSEMOVE:
+#ifndef _WIN32_WCE
+		case WM_NCMOUSEMOVE:
+#endif // !_WIN32_WCE
+		case WM_PAINT:
+		case 0x0118:	// WM_SYSTIMER (caret blink)
+			return FALSE;
+		}
+
+		return TRUE;
+	}
+
+// Overrideables
+	// Override to change message filtering
+	virtual BOOL PreTranslateMessage(MSG* pMsg)
+	{
+		// loop backwards
+		for(int i = m_aMsgFilter.GetSize() - 1; i >= 0; i--)
+		{
+			CMessageFilter* pMessageFilter = m_aMsgFilter[i];
+			if(pMessageFilter != NULL && pMessageFilter->PreTranslateMessage(pMsg))
+				return TRUE;
+		}
+		return FALSE;   // not translated
+	}
+
+	// override to change idle processing
+	virtual BOOL OnIdle(int /*nIdleCount*/)
+	{
+		for(int i = 0; i < m_aIdleHandler.GetSize(); i++)
+		{
+			CIdleHandler* pIdleHandler = m_aIdleHandler[i];
+			if(pIdleHandler != NULL)
+				pIdleHandler->OnIdle();
+		}
+		return FALSE;   // don't continue
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CStaticDataInitCriticalSectionLock and CWindowCreateCriticalSectionLock
+// internal classes to manage critical sections for both ATL3 and ATL7
+
+class CStaticDataInitCriticalSectionLock
+{
+public:
+#if (_ATL_VER >= 0x0700)
+	ATL::CComCritSecLock<ATL::CComCriticalSection> m_cslock;
+
+	CStaticDataInitCriticalSectionLock() : m_cslock(ATL::_pAtlModule->m_csStaticDataInitAndTypeInfo, false)
+	{ }
+#endif // (_ATL_VER >= 0x0700)
+
+	HRESULT Lock()
+	{
+#if (_ATL_VER >= 0x0700)
+		return m_cslock.Lock();
+#else // !(_ATL_VER >= 0x0700)
+		::EnterCriticalSection(&ATL::_pModule->m_csStaticDataInit);
+		return S_OK;
+#endif // !(_ATL_VER >= 0x0700)
+	}
+
+	void Unlock()
+	{
+#if (_ATL_VER >= 0x0700)
+		m_cslock.Unlock();
+#else // !(_ATL_VER >= 0x0700)
+		::LeaveCriticalSection(&ATL::_pModule->m_csStaticDataInit);
+#endif // !(_ATL_VER >= 0x0700)
+	}
+};
+
+
+class CWindowCreateCriticalSectionLock
+{
+public:
+#if (_ATL_VER >= 0x0700)
+	ATL::CComCritSecLock<ATL::CComCriticalSection> m_cslock;
+
+	CWindowCreateCriticalSectionLock() : m_cslock(ATL::_AtlWinModule.m_csWindowCreate, false)
+	{ }
+#endif // (_ATL_VER >= 0x0700)
+
+	HRESULT Lock()
+	{
+#if (_ATL_VER >= 0x0700)
+		return m_cslock.Lock();
+#else // !(_ATL_VER >= 0x0700)
+		::EnterCriticalSection(&ATL::_pModule->m_csWindowCreate);
+		return S_OK;
+#endif // !(_ATL_VER >= 0x0700)
+	}
+
+	void Unlock()
+	{
+#if (_ATL_VER >= 0x0700)
+		m_cslock.Unlock();
+#else // !(_ATL_VER >= 0x0700)
+		::LeaveCriticalSection(&ATL::_pModule->m_csWindowCreate);
+#endif // !(_ATL_VER >= 0x0700)
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTempBuffer - helper class for stack allocations for ATL3
+
+#ifndef _WTL_STACK_ALLOC_THRESHOLD
+  #define _WTL_STACK_ALLOC_THRESHOLD   512
+#endif
+
+#if (_ATL_VER >= 0x0700)
+
+using ATL::CTempBuffer;
+
+#else // !(_ATL_VER >= 0x0700)
+
+#ifndef SIZE_MAX
+  #ifdef _WIN64 
+    #define SIZE_MAX _UI64_MAX
+  #else
+    #define SIZE_MAX UINT_MAX
+  #endif
+#endif
+
+#pragma warning(disable: 4284)   // warning for operator ->
+
+template<typename T, int t_nFixedBytes = 128>
+class CTempBuffer
+{
+public:
+	CTempBuffer() : m_p(NULL)
+	{
+	}
+
+	CTempBuffer(size_t nElements) : m_p(NULL)
+	{
+		Allocate(nElements);
+	}
+
+	~CTempBuffer()
+	{
+		if(m_p != reinterpret_cast<T*>(m_abFixedBuffer))
+			free(m_p);
+	}
+
+	operator T*() const
+	{
+		return m_p;
+	}
+
+	T* operator ->() const
+	{
+		ATLASSERT(m_p != NULL);
+		return m_p;
+	}
+
+	T* Allocate(size_t nElements)
+	{
+		ATLASSERT(nElements <= (SIZE_MAX / sizeof(T)));
+		return AllocateBytes(nElements * sizeof(T));
+	}
+
+	T* AllocateBytes(size_t nBytes)
+	{
+		ATLASSERT(m_p == NULL);
+		if(nBytes > t_nFixedBytes)
+			m_p = static_cast<T*>(malloc(nBytes));
+		else
+			m_p = reinterpret_cast<T*>(m_abFixedBuffer);
+
+		return m_p;
+	}
+
+private:
+	T* m_p;
+	BYTE m_abFixedBuffer[t_nFixedBytes];
+};
+
+#pragma warning(default: 4284)
+
+#endif // !(_ATL_VER >= 0x0700)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppModule - module class for an application
+
+class CAppModule : public ATL::CComModule
+{
+public:
+	DWORD m_dwMainThreadID;
+	ATL::CSimpleMap<DWORD, CMessageLoop*>* m_pMsgLoopMap;
+	ATL::CSimpleArray<HWND>* m_pSettingChangeNotify;
+
+// Overrides of CComModule::Init and Term
+	HRESULT Init(ATL::_ATL_OBJMAP_ENTRY* pObjMap, HINSTANCE hInstance, const GUID* pLibID = NULL)
+	{
+		HRESULT hRet = CComModule::Init(pObjMap, hInstance, pLibID);
+		if(FAILED(hRet))
+			return hRet;
+
+		m_dwMainThreadID = ::GetCurrentThreadId();
+		typedef ATL::CSimpleMap<DWORD, CMessageLoop*>   _mapClass;
+		m_pMsgLoopMap = NULL;
+		ATLTRY(m_pMsgLoopMap = new _mapClass);
+		if(m_pMsgLoopMap == NULL)
+			return E_OUTOFMEMORY;
+		m_pSettingChangeNotify = NULL;
+
+		return hRet;
+	}
+
+	void Term()
+	{
+		TermSettingChangeNotify();
+		delete m_pMsgLoopMap;
+		CComModule::Term();
+	}
+
+// Message loop map methods
+	BOOL AddMessageLoop(CMessageLoop* pMsgLoop)
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::AddMessageLoop.\n"));
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		ATLASSERT(pMsgLoop != NULL);
+		ATLASSERT(m_pMsgLoopMap->Lookup(::GetCurrentThreadId()) == NULL);   // not in map yet
+
+		BOOL bRet = m_pMsgLoopMap->Add(::GetCurrentThreadId(), pMsgLoop);
+
+		lock.Unlock();
+
+		return bRet;
+	}
+
+	BOOL RemoveMessageLoop()
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::RemoveMessageLoop.\n"));
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		BOOL bRet = m_pMsgLoopMap->Remove(::GetCurrentThreadId());
+
+		lock.Unlock();
+
+		return bRet;
+	}
+
+	CMessageLoop* GetMessageLoop(DWORD dwThreadID = ::GetCurrentThreadId()) const
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::GetMessageLoop.\n"));
+			ATLASSERT(FALSE);
+			return NULL;
+		}
+
+		CMessageLoop* pLoop =  m_pMsgLoopMap->Lookup(dwThreadID);
+
+		lock.Unlock();
+
+		return pLoop;
+	}
+
+// Setting change notify methods
+	// Note: Call this from the main thread for MSDI apps
+	BOOL InitSettingChangeNotify(DLGPROC pfnDlgProc = _SettingChangeDlgProc)
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::InitSettingChangeNotify.\n"));
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		if(m_pSettingChangeNotify == NULL)
+		{
+			typedef ATL::CSimpleArray<HWND>   _notifyClass;
+			ATLTRY(m_pSettingChangeNotify = new _notifyClass);
+			ATLASSERT(m_pSettingChangeNotify != NULL);
+		}
+
+		BOOL bRet = (m_pSettingChangeNotify != NULL);
+		if(bRet && m_pSettingChangeNotify->GetSize() == 0)
+		{
+			// init everything
+			_ATL_EMPTY_DLGTEMPLATE templ;
+			HWND hNtfWnd = ::CreateDialogIndirect(GetModuleInstance(), &templ, NULL, pfnDlgProc);
+			ATLASSERT(::IsWindow(hNtfWnd));
+			if(::IsWindow(hNtfWnd))
+			{
+// need conditional code because types don't match in winuser.h
+#ifdef _WIN64
+				::SetWindowLongPtr(hNtfWnd, GWLP_USERDATA, (LONG_PTR)this);
+#else
+				::SetWindowLongPtr(hNtfWnd, GWLP_USERDATA, PtrToLong(this));
+#endif
+				bRet = m_pSettingChangeNotify->Add(hNtfWnd);
+			}
+			else
+			{
+				bRet = FALSE;
+			}
+		}
+
+		lock.Unlock();
+
+		return bRet;
+	}
+
+	void TermSettingChangeNotify()
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::TermSettingChangeNotify.\n"));
+			ATLASSERT(FALSE);
+			return;
+		}
+
+		if(m_pSettingChangeNotify != NULL && m_pSettingChangeNotify->GetSize() > 0)
+			::DestroyWindow((*m_pSettingChangeNotify)[0]);
+		delete m_pSettingChangeNotify;
+		m_pSettingChangeNotify = NULL;
+
+		lock.Unlock();
+	}
+
+	BOOL AddSettingChangeNotify(HWND hWnd)
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::AddSettingChangeNotify.\n"));
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		ATLASSERT(::IsWindow(hWnd));
+		BOOL bRet = FALSE;
+		if(InitSettingChangeNotify() != FALSE)
+			bRet = m_pSettingChangeNotify->Add(hWnd);
+
+		lock.Unlock();
+
+		return bRet;
+	}
+
+	BOOL RemoveSettingChangeNotify(HWND hWnd)
+	{
+		CStaticDataInitCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CAppModule::RemoveSettingChangeNotify.\n"));
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		BOOL bRet = FALSE;
+		if(m_pSettingChangeNotify != NULL)
+			bRet = m_pSettingChangeNotify->Remove(hWnd);
+
+		lock.Unlock();
+
+		return bRet;
+	}
+
+// Implementation - setting change notify dialog template and dialog procedure
+	struct _ATL_EMPTY_DLGTEMPLATE : DLGTEMPLATE
+	{
+		_ATL_EMPTY_DLGTEMPLATE()
+		{
+			memset(this, 0, sizeof(_ATL_EMPTY_DLGTEMPLATE));
+			style = WS_POPUP;
+		}
+		WORD wMenu, wClass, wTitle;
+	};
+
+#ifdef _WIN64
+	static INT_PTR CALLBACK _SettingChangeDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+#else
+	static BOOL CALLBACK _SettingChangeDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+#endif
+	{
+		if(uMsg == WM_SETTINGCHANGE)
+		{
+// need conditional code because types don't match in winuser.h
+#ifdef _WIN64
+			CAppModule* pModule = (CAppModule*)::GetWindowLongPtr(hWnd, GWLP_USERDATA);
+#else
+			CAppModule* pModule = (CAppModule*)LongToPtr(::GetWindowLongPtr(hWnd, GWLP_USERDATA));
+#endif
+			ATLASSERT(pModule != NULL);
+			ATLASSERT(pModule->m_pSettingChangeNotify != NULL);
+			const UINT uTimeout = 1500;   // ms
+			for(int i = 1; i < pModule->m_pSettingChangeNotify->GetSize(); i++)
+			{
+#if !defined(_WIN32_WCE)
+				::SendMessageTimeout((*pModule->m_pSettingChangeNotify)[i], uMsg, wParam, lParam, SMTO_ABORTIFHUNG, uTimeout, NULL);
+#elif(_WIN32_WCE >= 400) // CE specific
+				::SendMessageTimeout((*pModule->m_pSettingChangeNotify)[i], uMsg, wParam, lParam, SMTO_NORMAL, uTimeout, NULL);
+#else // _WIN32_WCE < 400 specific
+				uTimeout;
+				::SendMessage((*pModule->m_pSettingChangeNotify)[i], uMsg, wParam, lParam);
+#endif
+			}
+			return TRUE;
+		}
+		return FALSE;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CServerAppModule - module class for a COM server application
+
+class CServerAppModule : public CAppModule
+{
+public:
+	HANDLE m_hEventShutdown;
+	bool m_bActivity;
+	DWORD m_dwTimeOut;
+	DWORD m_dwPause;
+
+// Override of CAppModule::Init
+	HRESULT Init(ATL::_ATL_OBJMAP_ENTRY* pObjMap, HINSTANCE hInstance, const GUID* pLibID = NULL)
+	{
+		m_dwTimeOut = 5000;
+		m_dwPause = 1000;
+		return CAppModule::Init(pObjMap, hInstance, pLibID);
+	}
+
+	void Term()
+	{
+		if(m_hEventShutdown != NULL && ::CloseHandle(m_hEventShutdown))
+			m_hEventShutdown = NULL;
+		CAppModule::Term();
+	}
+
+// COM Server methods
+	LONG Unlock()
+	{
+		LONG lRet = CComModule::Unlock();
+		if(lRet == 0)
+		{
+			m_bActivity = true;
+			::SetEvent(m_hEventShutdown); // tell monitor that we transitioned to zero
+		}
+		return lRet;
+	}
+
+	void MonitorShutdown()
+	{
+		for(;;)
+		{
+			::WaitForSingleObject(m_hEventShutdown, INFINITE);
+			DWORD dwWait = 0;
+			do
+			{
+				m_bActivity = false;
+				dwWait = ::WaitForSingleObject(m_hEventShutdown, m_dwTimeOut);
+			}
+			while(dwWait == WAIT_OBJECT_0);
+			// timed out
+			if(!m_bActivity && m_nLockCnt == 0) // if no activity let's really bail
+			{
+#if ((_WIN32_WINNT >= 0x0400 ) || defined(_WIN32_DCOM)) && defined(_ATL_FREE_THREADED) && !defined(_WIN32_WCE)
+				::CoSuspendClassObjects();
+				if(!m_bActivity && m_nLockCnt == 0)
+#endif
+					break;
+			}
+		}
+		// This handle should be valid now. If it isn't, 
+		// check if _Module.Term was called first (it shouldn't)
+		if(::CloseHandle(m_hEventShutdown))
+			m_hEventShutdown = NULL;
+		::PostThreadMessage(m_dwMainThreadID, WM_QUIT, 0, 0);
+	}
+
+	bool StartMonitor()
+	{
+		m_hEventShutdown = ::CreateEvent(NULL, false, false, NULL);
+		if(m_hEventShutdown == NULL)
+			return false;
+		DWORD dwThreadID = 0;
+#if !defined(_ATL_MIN_CRT) && defined(_MT) && !defined(_WIN32_WCE)
+		HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, (UINT (WINAPI*)(void*))MonitorProc, this, 0, (UINT*)&dwThreadID);
+#else
+		HANDLE hThread = ::CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
+#endif
+		bool bRet = (hThread != NULL);
+		if(bRet)
+			::CloseHandle(hThread);
+		return bRet;
+	}
+
+	static DWORD WINAPI MonitorProc(void* pv)
+	{
+		CServerAppModule* p = (CServerAppModule*)pv;
+		p->MonitorShutdown();
+		return 0;
+	}
+
+#if (_ATL_VER < 0x0700)
+	// search for an occurence of string p2 in string p1
+	static LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
+	{
+		while(p1 != NULL && *p1 != NULL)
+		{
+			LPCTSTR p = p2;
+			while(p != NULL && *p != NULL)
+			{
+				if(*p1 == *p)
+					return ::CharNext(p1);
+				p = ::CharNext(p);
+			}
+			p1 = ::CharNext(p1);
+		}
+		return NULL;
+	}
+#endif // (_ATL_VER < 0x0700)
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRegKeyEx - adds type-specific methods to ATL3 CRegKey
+
+#if (_ATL_VER < 0x0700)
+
+class CRegKeyEx : public ATL::CRegKey
+{
+public:
+// Constructors and operators
+	CRegKeyEx(HKEY hKey = NULL)
+	{
+		m_hKey = hKey;
+	}
+
+	CRegKeyEx(CRegKeyEx& key)
+	{
+		Attach(key.Detach());
+	}
+
+	CRegKeyEx& operator =(CRegKeyEx& key)
+	{
+		Close();
+		Attach(key.Detach());
+		return *this;
+	}
+
+// Methods
+	LONG SetValue(LPCTSTR pszValueName, DWORD dwType, const void* pValue, ULONG nBytes)
+	{
+		ATLASSERT(m_hKey != NULL);
+		return ::RegSetValueEx(m_hKey, pszValueName, NULL, dwType, static_cast<const BYTE*>(pValue), nBytes);
+	}
+
+	LONG SetGUIDValue(LPCTSTR pszValueName, REFGUID guidValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+
+		OLECHAR szGUID[64] = { 0 };
+		::StringFromGUID2(guidValue, szGUID, 64);
+
+		USES_CONVERSION;
+		LPCTSTR lpstr = OLE2CT(szGUID);
+#ifndef _UNICODE
+		if(lpstr == NULL) 
+			return E_OUTOFMEMORY;
+#endif	
+		return SetStringValue(pszValueName, lpstr);
+	}
+
+	LONG SetBinaryValue(LPCTSTR pszValueName, const void* pValue, ULONG nBytes)
+	{
+		ATLASSERT(m_hKey != NULL);
+		return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_BINARY, reinterpret_cast<const BYTE*>(pValue), nBytes);
+	}
+
+	LONG SetDWORDValue(LPCTSTR pszValueName, DWORD dwValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+		return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_DWORD, reinterpret_cast<const BYTE*>(&dwValue), sizeof(DWORD));
+	}
+
+#ifndef _WIN32_WCE
+	LONG SetQWORDValue(LPCTSTR pszValueName, ULONGLONG qwValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+		return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_QWORD, reinterpret_cast<const BYTE*>(&qwValue), sizeof(ULONGLONG));
+	}
+#endif
+
+	LONG SetStringValue(LPCTSTR pszValueName, LPCTSTR pszValue, DWORD dwType = REG_SZ)
+	{
+		ATLASSERT(m_hKey != NULL);
+		if(pszValue == NULL)
+		{
+			ATLASSERT(FALSE);
+			return ERROR_INVALID_DATA;
+		}
+		ATLASSERT((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ));
+
+		return ::RegSetValueEx(m_hKey, pszValueName, NULL, dwType, reinterpret_cast<const BYTE*>(pszValue), (lstrlen(pszValue) + 1) * sizeof(TCHAR));
+	}
+
+	LONG SetMultiStringValue(LPCTSTR pszValueName, LPCTSTR pszValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+		if(pszValue == NULL)
+		{
+			ATLASSERT(FALSE);
+			return ERROR_INVALID_DATA;
+		}
+
+		ULONG nBytes = 0;
+		ULONG nLength = 0;
+		LPCTSTR pszTemp = pszValue;
+		do
+		{
+			nLength = lstrlen(pszTemp) + 1;
+			pszTemp += nLength;
+			nBytes += nLength * sizeof(TCHAR);
+		} while (nLength != 1);
+
+		return ::RegSetValueEx(m_hKey, pszValueName, NULL, REG_MULTI_SZ, reinterpret_cast<const BYTE*>(pszValue), nBytes);
+	}
+
+	LONG QueryValue(LPCTSTR pszValueName, DWORD* pdwType, void* pData, ULONG* pnBytes)
+	{
+		ATLASSERT(m_hKey != NULL);
+		return ::RegQueryValueEx(m_hKey, pszValueName, NULL, pdwType, static_cast<LPBYTE>(pData), pnBytes);
+	}
+
+	LONG QueryGUIDValue(LPCTSTR pszValueName, GUID& guidValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+
+		guidValue = GUID_NULL;
+
+		TCHAR szGUID[64] = { 0 };
+		ULONG nCount = 64;
+		LONG lRes = QueryStringValue(pszValueName, szGUID, &nCount);
+
+		if (lRes != ERROR_SUCCESS)
+			return lRes;
+
+		if(szGUID[0] != _T('{'))
+			return ERROR_INVALID_DATA;
+
+		USES_CONVERSION;
+		LPOLESTR lpstr = T2OLE(szGUID);
+#ifndef _UNICODE
+		if(lpstr == NULL) 
+			return E_OUTOFMEMORY;
+#endif	
+		
+		HRESULT hr = ::CLSIDFromString(lpstr, &guidValue);
+		if (FAILED(hr))
+			return ERROR_INVALID_DATA;
+
+		return ERROR_SUCCESS;
+	}
+
+	LONG QueryBinaryValue(LPCTSTR pszValueName, void* pValue, ULONG* pnBytes)
+	{
+		ATLASSERT(pnBytes != NULL);
+		ATLASSERT(m_hKey != NULL);
+
+		DWORD dwType = 0;
+		LONG lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pValue), pnBytes);
+		if (lRes != ERROR_SUCCESS)
+			return lRes;
+		if (dwType != REG_BINARY)
+			return ERROR_INVALID_DATA;
+
+		return ERROR_SUCCESS;
+	}
+
+	LONG QueryDWORDValue(LPCTSTR pszValueName, DWORD& dwValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+
+		ULONG nBytes = sizeof(DWORD);
+		DWORD dwType = 0;
+		LONG lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&dwValue), &nBytes);
+		if (lRes != ERROR_SUCCESS)
+			return lRes;
+		if (dwType != REG_DWORD)
+			return ERROR_INVALID_DATA;
+
+		return ERROR_SUCCESS;
+	}
+
+	LONG QueryQWORDValue(LPCTSTR pszValueName, ULONGLONG& qwValue)
+	{
+		ATLASSERT(m_hKey != NULL);
+
+		ULONG nBytes = sizeof(ULONGLONG);
+		DWORD dwType = 0;
+		LONG lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(&qwValue), &nBytes);
+		if (lRes != ERROR_SUCCESS)
+			return lRes;
+		if (dwType != REG_QWORD)
+			return ERROR_INVALID_DATA;
+
+		return ERROR_SUCCESS;
+	}
+
+	LONG QueryStringValue(LPCTSTR pszValueName, LPTSTR pszValue, ULONG* pnChars)
+	{
+		ATLASSERT(m_hKey != NULL);
+		ATLASSERT(pnChars != NULL);
+
+		ULONG nBytes = (*pnChars) * sizeof(TCHAR);
+		DWORD dwType = 0;
+		*pnChars = 0;
+		LONG lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue), &nBytes);
+	
+		if (lRes != ERROR_SUCCESS)
+		{
+			return lRes;
+		}
+
+		if(dwType != REG_SZ && dwType != REG_EXPAND_SZ)
+		{
+			return ERROR_INVALID_DATA;
+		}
+
+		if (pszValue != NULL)
+		{
+			if(nBytes != 0)
+			{
+				if ((nBytes % sizeof(TCHAR) != 0) || (pszValue[nBytes / sizeof(TCHAR) -1] != 0))
+					return ERROR_INVALID_DATA;
+			}
+			else
+			{
+				pszValue[0] = _T('\0');
+			}
+		}
+
+		*pnChars = nBytes / sizeof(TCHAR);
+
+		return ERROR_SUCCESS;
+	}
+
+	LONG QueryMultiStringValue(LPCTSTR pszValueName, LPTSTR pszValue, ULONG* pnChars)
+	{
+		ATLASSERT(m_hKey != NULL);
+		ATLASSERT(pnChars != NULL);
+
+		if (pszValue != NULL && *pnChars < 2)
+			return ERROR_INSUFFICIENT_BUFFER;
+		
+		ULONG nBytes = (*pnChars) * sizeof(TCHAR);
+		DWORD dwType = 0;
+		*pnChars = 0;
+		LONG lRes = ::RegQueryValueEx(m_hKey, pszValueName, NULL, &dwType, reinterpret_cast<LPBYTE>(pszValue), &nBytes);
+		if (lRes != ERROR_SUCCESS)
+			return lRes;
+		if (dwType != REG_MULTI_SZ)
+			return ERROR_INVALID_DATA;
+		if (pszValue != NULL && (nBytes % sizeof(TCHAR) != 0 || nBytes / sizeof(TCHAR) < 1 || pszValue[nBytes / sizeof(TCHAR) - 1] != 0 || ((nBytes / sizeof(TCHAR)) > 1 && pszValue[nBytes / sizeof(TCHAR) - 2] != 0)))
+			return ERROR_INVALID_DATA;
+
+		*pnChars = nBytes / sizeof(TCHAR);
+
+		return ERROR_SUCCESS;
+	}
+};
+
+#else // !(_ATL_VER < 0x0700)
+
+typedef ATL::CRegKey CRegKeyEx;
+
+#endif // !(_ATL_VER < 0x0700)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CString forward reference (enables CString use in atluser.h and atlgdi.h)
+
+#if defined(_WTL_FORWARD_DECLARE_CSTRING) && !defined(_WTL_USE_CSTRING)
+  #define _WTL_USE_CSTRING
+#endif // defined(_WTL_FORWARD_DECLARE_CSTRING) && !defined(_WTL_USE_CSTRING)
+
+#ifdef _WTL_USE_CSTRING
+  class CString;   // forward declaration (include atlmisc.h for the whole class)
+#endif // _WTL_USE_CSTRING
+
+// CString namespace
+#ifndef _CSTRING_NS
+  #ifdef __ATLSTR_H__
+    #define _CSTRING_NS	ATL
+  #else
+    #define _CSTRING_NS	WTL
+  #endif
+#endif // _CSTRING_NS
+
+// Type classes namespace
+#ifndef _WTYPES_NS
+  #ifdef __ATLTYPES_H__
+    #define _WTYPES_NS
+  #else
+    #define _WTYPES_NS	WTL
+  #endif
+#endif // _WTYPES_NS
+
+}; // namespace WTL
+
+
+///////////////////////////////////////////////////////////////////////////////
+// General DLL version helpers
+// (ATL3: excluded from atlbase.h if _ATL_DLL is defined; ATL11: removed)
+
+#if (((_ATL_VER < 0x0700) && defined(_ATL_DLL)) || (_ATL_VER >= 0x0B00)) && !defined(_WIN32_WCE)
+
+namespace ATL
+{
+
+inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
+{
+	ATLASSERT(pDllVersionInfo != NULL);
+	if(pDllVersionInfo == NULL)
+		return E_INVALIDARG;
+
+	// We must get this function explicitly because some DLLs don't implement it.
+	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
+	if(pfnDllGetVersion == NULL)
+		return E_NOTIMPL;
+
+	return (*pfnDllGetVersion)(pDllVersionInfo);
+}
+
+inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
+{
+	HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
+	if(hInstDLL == NULL)
+		return E_FAIL;
+	HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
+	::FreeLibrary(hInstDLL);
+	return hRet;
+}
+
+// Common Control Versions:
+//   Win95/WinNT 4.0    maj=4 min=00
+//   IE 3.x     maj=4 min=70
+//   IE 4.0     maj=4 min=71
+inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
+{
+	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
+	if(pdwMajor == NULL || pdwMinor == NULL)
+		return E_INVALIDARG;
+
+	DLLVERSIONINFO dvi;
+	::ZeroMemory(&dvi, sizeof(dvi));
+	dvi.cbSize = sizeof(dvi);
+	HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);
+
+	if(SUCCEEDED(hRet))
+	{
+		*pdwMajor = dvi.dwMajorVersion;
+		*pdwMinor = dvi.dwMinorVersion;
+	}
+	else if(hRet == E_NOTIMPL)
+	{
+		// If DllGetVersion is not there, then the DLL is a version
+		// previous to the one shipped with IE 3.x
+		*pdwMajor = 4;
+		*pdwMinor = 0;
+		hRet = S_OK;
+	}
+
+	return hRet;
+}
+
+// Shell Versions:
+//   Win95/WinNT 4.0                    maj=4 min=00
+//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
+//   IE 4.0 with Web Integrated Desktop         maj=4 min=71
+//   IE 4.01 with Web Integrated Desktop        maj=4 min=72
+inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
+{
+	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
+	if(pdwMajor == NULL || pdwMinor == NULL)
+		return E_INVALIDARG;
+
+	DLLVERSIONINFO dvi;
+	::ZeroMemory(&dvi, sizeof(dvi));
+	dvi.cbSize = sizeof(dvi);
+	HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);
+
+	if(SUCCEEDED(hRet))
+	{
+		*pdwMajor = dvi.dwMajorVersion;
+		*pdwMinor = dvi.dwMinorVersion;
+	}
+	else if(hRet == E_NOTIMPL)
+	{
+		// If DllGetVersion is not there, then the DLL is a version
+		// previous to the one shipped with IE 4.x
+		*pdwMajor = 4;
+		*pdwMinor = 0;
+		hRet = S_OK;
+	}
+
+	return hRet;
+}
+
+}; // namespace ATL
+
+#endif // (_ATL_VER < 0x0700) && defined(_ATL_DLL) && !defined(_WIN32_WCE)
+
+
+// These are always included
+#include "atlwinx.h"
+#include "atluser.h"
+#include "atlgdi.h"
+
+#ifndef _WTL_NO_AUTOMATIC_NAMESPACE
+using namespace WTL;
+#endif // !_WTL_NO_AUTOMATIC_NAMESPACE
+
+#endif // __ATLAPP_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlcrack.h b/GLideN64/src/GLideNUI-wtl/WTL/atlcrack.h
new file mode 100644
index 00000000..7f4a2bae
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlcrack.h
@@ -0,0 +1,2384 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLCRACK_H__
+#define __ATLCRACK_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlcrack.h requires atlapp.h to be included first
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Message map macro for cracked handlers
+
+// Note about message maps with cracked handlers:
+// For ATL 3.0, a message map using cracked handlers MUST use BEGIN_MSG_MAP_EX.
+// For ATL 7.0 or higher, you can use BEGIN_MSG_MAP for CWindowImpl/CDialogImpl derived classes,
+// but must use BEGIN_MSG_MAP_EX for classes that don't derive from CWindowImpl/CDialogImpl.
+
+#define BEGIN_MSG_MAP_EX(theClass) \
+public: \
+	BOOL m_bMsgHandled; \
+	/* "handled" management for cracked handlers */ \
+	BOOL IsMsgHandled() const \
+	{ \
+		return m_bMsgHandled; \
+	} \
+	void SetMsgHandled(BOOL bHandled) \
+	{ \
+		m_bMsgHandled = bHandled; \
+	} \
+	BOOL ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID = 0) \
+	{ \
+		BOOL bOldMsgHandled = m_bMsgHandled; \
+		BOOL bRet = _ProcessWindowMessage(hWnd, uMsg, wParam, lParam, lResult, dwMsgMapID); \
+		m_bMsgHandled = bOldMsgHandled; \
+		return bRet; \
+	} \
+	BOOL _ProcessWindowMessage(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT& lResult, DWORD dwMsgMapID) \
+	{ \
+		BOOL bHandled = TRUE; \
+		hWnd; \
+		uMsg; \
+		wParam; \
+		lParam; \
+		lResult; \
+		bHandled; \
+		switch(dwMsgMapID) \
+		{ \
+		case 0:
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Standard Windows message macros
+
+// int OnCreate(LPCREATESTRUCT lpCreateStruct)
+#define MSG_WM_CREATE(func) \
+	if (uMsg == WM_CREATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((LPCREATESTRUCT)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnInitDialog(CWindow wndFocus, LPARAM lInitParam)
+#define MSG_WM_INITDIALOG(func) \
+	if (uMsg == WM_INITDIALOG) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HWND)wParam, lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnCopyData(CWindow wnd, PCOPYDATASTRUCT pCopyDataStruct)
+#define MSG_WM_COPYDATA(func) \
+	if (uMsg == WM_COPYDATA) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HWND)wParam, (PCOPYDATASTRUCT)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDestroy()
+#define MSG_WM_DESTROY(func) \
+	if (uMsg == WM_DESTROY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMove(CPoint ptPos)
+#define MSG_WM_MOVE(func) \
+	if (uMsg == WM_MOVE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(_WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSize(UINT nType, CSize size)
+#define MSG_WM_SIZE(func) \
+	if (uMsg == WM_SIZE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnActivate(UINT nState, BOOL bMinimized, CWindow wndOther)
+#define MSG_WM_ACTIVATE(func) \
+	if (uMsg == WM_ACTIVATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)LOWORD(wParam), (BOOL)HIWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSetFocus(CWindow wndOld)
+#define MSG_WM_SETFOCUS(func) \
+	if (uMsg == WM_SETFOCUS) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnKillFocus(CWindow wndFocus)
+#define MSG_WM_KILLFOCUS(func) \
+	if (uMsg == WM_KILLFOCUS) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnEnable(BOOL bEnable)
+#define MSG_WM_ENABLE(func) \
+	if (uMsg == WM_ENABLE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPaint(CDCHandle dc)
+#define MSG_WM_PAINT(func) \
+	if (uMsg == WM_PAINT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HDC)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnClose()
+#define MSG_WM_CLOSE(func) \
+	if (uMsg == WM_CLOSE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnQueryEndSession(UINT nSource, UINT uLogOff)
+#define MSG_WM_QUERYENDSESSION(func) \
+	if (uMsg == WM_QUERYENDSESSION) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)wParam, (UINT)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnQueryOpen()
+#define MSG_WM_QUERYOPEN(func) \
+	if (uMsg == WM_QUERYOPEN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnEraseBkgnd(CDCHandle dc)
+#define MSG_WM_ERASEBKGND(func) \
+	if (uMsg == WM_ERASEBKGND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSysColorChange()
+#define MSG_WM_SYSCOLORCHANGE(func) \
+	if (uMsg == WM_SYSCOLORCHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnEndSession(BOOL bEnding, UINT uLogOff)
+#define MSG_WM_ENDSESSION(func) \
+	if (uMsg == WM_ENDSESSION) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam, (UINT)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnShowWindow(BOOL bShow, UINT nStatus)
+#define MSG_WM_SHOWWINDOW(func) \
+	if (uMsg == WM_SHOWWINDOW) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam, (int)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnCtlColorEdit(CDCHandle dc, CEdit edit)
+#define MSG_WM_CTLCOLOREDIT(func) \
+	if (uMsg == WM_CTLCOLOREDIT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnCtlColorListBox(CDCHandle dc, CListBox listBox)
+#define MSG_WM_CTLCOLORLISTBOX(func) \
+	if (uMsg == WM_CTLCOLORLISTBOX) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnCtlColorBtn(CDCHandle dc, CButton button)
+#define MSG_WM_CTLCOLORBTN(func) \
+	if (uMsg == WM_CTLCOLORBTN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnCtlColorDlg(CDCHandle dc, CWindow wnd)
+#define MSG_WM_CTLCOLORDLG(func) \
+	if (uMsg == WM_CTLCOLORDLG) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnCtlColorScrollBar(CDCHandle dc, CScrollBar scrollBar)
+#define MSG_WM_CTLCOLORSCROLLBAR(func) \
+	if (uMsg == WM_CTLCOLORSCROLLBAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnCtlColorStatic(CDCHandle dc, CStatic wndStatic)
+#define MSG_WM_CTLCOLORSTATIC(func) \
+	if (uMsg == WM_CTLCOLORSTATIC) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSettingChange(UINT uFlags, LPCTSTR lpszSection)
+#define MSG_WM_SETTINGCHANGE(func) \
+	if (uMsg == WM_SETTINGCHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPCTSTR)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDevModeChange(LPCTSTR lpDeviceName)
+#define MSG_WM_DEVMODECHANGE(func) \
+	if (uMsg == WM_DEVMODECHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((LPCTSTR)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnActivateApp(BOOL bActive, DWORD dwThreadID)
+#define MSG_WM_ACTIVATEAPP(func) \
+	if (uMsg == WM_ACTIVATEAPP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam, (DWORD)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnFontChange()
+#define MSG_WM_FONTCHANGE(func) \
+	if (uMsg == WM_FONTCHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnTimeChange()
+#define MSG_WM_TIMECHANGE(func) \
+	if (uMsg == WM_TIMECHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCancelMode()
+#define MSG_WM_CANCELMODE(func) \
+	if (uMsg == WM_CANCELMODE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnSetCursor(CWindow wnd, UINT nHitTest, UINT message)
+#define MSG_WM_SETCURSOR(func) \
+	if (uMsg == WM_SETCURSOR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnMouseActivate(CWindow wndTopLevel, UINT nHitTest, UINT message)
+#define MSG_WM_MOUSEACTIVATE(func) \
+	if (uMsg == WM_MOUSEACTIVATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnChildActivate()
+#define MSG_WM_CHILDACTIVATE(func) \
+	if (uMsg == WM_CHILDACTIVATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnGetMinMaxInfo(LPMINMAXINFO lpMMI)
+#define MSG_WM_GETMINMAXINFO(func) \
+	if (uMsg == WM_GETMINMAXINFO) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((LPMINMAXINFO)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnIconEraseBkgnd(CDCHandle dc)
+#define MSG_WM_ICONERASEBKGND(func) \
+	if (uMsg == WM_ICONERASEBKGND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HDC)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSpoolerStatus(UINT nStatus, UINT nJobs)
+#define MSG_WM_SPOOLERSTATUS(func) \
+	if (uMsg == WM_SPOOLERSTATUS) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (UINT)LOWORD(lParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
+#define MSG_WM_DRAWITEM(func) \
+	if (uMsg == WM_DRAWITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPDRAWITEMSTRUCT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
+#define MSG_WM_MEASUREITEM(func) \
+	if (uMsg == WM_MEASUREITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDeleteItem(int nIDCtl, LPDELETEITEMSTRUCT lpDeleteItemStruct)
+#define MSG_WM_DELETEITEM(func) \
+	if (uMsg == WM_DELETEITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPDELETEITEMSTRUCT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+//int OnCharToItem(UINT nChar, UINT nIndex, CListBox listBox)
+#define MSG_WM_CHARTOITEM(func) \
+	if (uMsg == WM_CHARTOITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnVKeyToItem(UINT nKey, UINT nIndex, CListBox listBox)
+#define MSG_WM_VKEYTOITEM(func) \
+	if (uMsg == WM_VKEYTOITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HCURSOR OnQueryDragIcon()
+#define MSG_WM_QUERYDRAGICON(func) \
+	if (uMsg == WM_QUERYDRAGICON) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct)
+#define MSG_WM_COMPAREITEM(func) \
+	if (uMsg == WM_COMPAREITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)wParam, (LPCOMPAREITEMSTRUCT)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCompacting(UINT nCpuTime)
+#define MSG_WM_COMPACTING(func) \
+	if (uMsg == WM_COMPACTING) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct)
+#define MSG_WM_NCCREATE(func) \
+	if (uMsg == WM_NCCREATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((LPCREATESTRUCT)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcDestroy()
+#define MSG_WM_NCDESTROY(func) \
+	if (uMsg == WM_NCDESTROY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNcCalcSize(BOOL bCalcValidRects, LPARAM lParam)
+#define MSG_WM_NCCALCSIZE(func) \
+	if (uMsg == WM_NCCALCSIZE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((BOOL)wParam, lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// UINT OnNcHitTest(CPoint point)
+#define MSG_WM_NCHITTEST(func) \
+	if (uMsg == WM_NCHITTEST) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func(_WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcPaint(CRgnHandle rgn)
+#define MSG_WM_NCPAINT(func) \
+	if (uMsg == WM_NCPAINT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HRGN)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnNcActivate(BOOL bActive)
+#define MSG_WM_NCACTIVATE(func) \
+	if (uMsg == WM_NCACTIVATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((BOOL)wParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// UINT OnGetDlgCode(LPMSG lpMsg)
+#define MSG_WM_GETDLGCODE(func) \
+	if (uMsg == WM_GETDLGCODE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((LPMSG)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcMouseMove(UINT nHitTest, CPoint point)
+#define MSG_WM_NCMOUSEMOVE(func) \
+	if (uMsg == WM_NCMOUSEMOVE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcLButtonDown(UINT nHitTest, CPoint point)
+#define MSG_WM_NCLBUTTONDOWN(func) \
+	if (uMsg == WM_NCLBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcLButtonUp(UINT nHitTest, CPoint point)
+#define MSG_WM_NCLBUTTONUP(func) \
+	if (uMsg == WM_NCLBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcLButtonDblClk(UINT nHitTest, CPoint point)
+#define MSG_WM_NCLBUTTONDBLCLK(func) \
+	if (uMsg == WM_NCLBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcRButtonDown(UINT nHitTest, CPoint point)
+#define MSG_WM_NCRBUTTONDOWN(func) \
+	if (uMsg == WM_NCRBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcRButtonUp(UINT nHitTest, CPoint point)
+#define MSG_WM_NCRBUTTONUP(func) \
+	if (uMsg == WM_NCRBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcRButtonDblClk(UINT nHitTest, CPoint point)
+#define MSG_WM_NCRBUTTONDBLCLK(func) \
+	if (uMsg == WM_NCRBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcMButtonDown(UINT nHitTest, CPoint point)
+#define MSG_WM_NCMBUTTONDOWN(func) \
+	if (uMsg == WM_NCMBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcMButtonUp(UINT nHitTest, CPoint point)
+#define MSG_WM_NCMBUTTONUP(func) \
+	if (uMsg == WM_NCMBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNcMButtonDblClk(UINT nHitTest, CPoint point)
+#define MSG_WM_NCMBUTTONDBLCLK(func) \
+	if (uMsg == WM_NCMBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_KEYDOWN(func) \
+	if (uMsg == WM_KEYDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_KEYUP(func) \
+	if (uMsg == WM_KEYUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_CHAR(func) \
+	if (uMsg == WM_CHAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_DEADCHAR(func) \
+	if (uMsg == WM_DEADCHAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_SYSKEYDOWN(func) \
+	if (uMsg == WM_SYSKEYDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_SYSKEYUP(func) \
+	if (uMsg == WM_SYSKEYUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_SYSCHAR(func) \
+	if (uMsg == WM_SYSCHAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSysDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_SYSDEADCHAR(func) \
+	if (uMsg == WM_SYSDEADCHAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSysCommand(UINT nID, CPoint point)
+#define MSG_WM_SYSCOMMAND(func) \
+	if (uMsg == WM_SYSCOMMAND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnTCard(UINT idAction, DWORD dwActionData)
+#define MSG_WM_TCARD(func) \
+	if (uMsg == WM_TCARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (DWORD)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnTimer(UINT_PTR nIDEvent)
+#define MSG_WM_TIMER(func) \
+	if (uMsg == WM_TIMER) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT_PTR)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar pScrollBar)
+#define MSG_WM_HSCROLL(func) \
+	if (uMsg == WM_HSCROLL) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar pScrollBar)
+#define MSG_WM_VSCROLL(func) \
+	if (uMsg == WM_VSCROLL) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnInitMenu(CMenuHandle menu)
+#define MSG_WM_INITMENU(func) \
+	if (uMsg == WM_INITMENU) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HMENU)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnInitMenuPopup(CMenuHandle menuPopup, UINT nIndex, BOOL bSysMenu)
+#define MSG_WM_INITMENUPOPUP(func) \
+	if (uMsg == WM_INITMENUPOPUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HMENU)wParam, (UINT)LOWORD(lParam), (BOOL)HIWORD(lParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMenuSelect(UINT nItemID, UINT nFlags, CMenuHandle menu)
+#define MSG_WM_MENUSELECT(func) \
+	if (uMsg == WM_MENUSELECT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HMENU)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenuHandle menu)
+#define MSG_WM_MENUCHAR(func) \
+	if (uMsg == WM_MENUCHAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((TCHAR)LOWORD(wParam), (UINT)HIWORD(wParam), (HMENU)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNotify(int idCtrl, LPNMHDR pnmh)
+#define MSG_WM_NOTIFY(func) \
+	if (uMsg == WM_NOTIFY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((int)wParam, (LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnEnterIdle(UINT nWhy, CWindow wndWho)
+#define MSG_WM_ENTERIDLE(func) \
+	if (uMsg == WM_ENTERIDLE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMouseMove(UINT nFlags, CPoint point)
+#define MSG_WM_MOUSEMOVE(func) \
+	if (uMsg == WM_MOUSEMOVE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnMouseWheel(UINT nFlags, short zDelta, CPoint pt)
+#define MSG_WM_MOUSEWHEEL(func) \
+	if (uMsg == WM_MOUSEWHEEL) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)LOWORD(wParam), (short)HIWORD(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnLButtonDown(UINT nFlags, CPoint point)
+#define MSG_WM_LBUTTONDOWN(func) \
+	if (uMsg == WM_LBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnLButtonUp(UINT nFlags, CPoint point)
+#define MSG_WM_LBUTTONUP(func) \
+	if (uMsg == WM_LBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnLButtonDblClk(UINT nFlags, CPoint point)
+#define MSG_WM_LBUTTONDBLCLK(func) \
+	if (uMsg == WM_LBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnRButtonDown(UINT nFlags, CPoint point)
+#define MSG_WM_RBUTTONDOWN(func) \
+	if (uMsg == WM_RBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnRButtonUp(UINT nFlags, CPoint point)
+#define MSG_WM_RBUTTONUP(func) \
+	if (uMsg == WM_RBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnRButtonDblClk(UINT nFlags, CPoint point)
+#define MSG_WM_RBUTTONDBLCLK(func) \
+	if (uMsg == WM_RBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMButtonDown(UINT nFlags, CPoint point)
+#define MSG_WM_MBUTTONDOWN(func) \
+	if (uMsg == WM_MBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMButtonUp(UINT nFlags, CPoint point)
+#define MSG_WM_MBUTTONUP(func) \
+	if (uMsg == WM_MBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMButtonDblClk(UINT nFlags, CPoint point)
+#define MSG_WM_MBUTTONDBLCLK(func) \
+	if (uMsg == WM_MBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnParentNotify(UINT message, UINT nChildID, LPARAM lParam)
+#define MSG_WM_PARENTNOTIFY(func) \
+	if (uMsg == WM_PARENTNOTIFY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMDIActivate(CWindow wndActivate, CWindow wndDeactivate)
+#define MSG_WM_MDIACTIVATE(func) \
+	if (uMsg == WM_MDIACTIVATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnRenderFormat(UINT nFormat)
+#define MSG_WM_RENDERFORMAT(func) \
+	if (uMsg == WM_RENDERFORMAT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnRenderAllFormats()
+#define MSG_WM_RENDERALLFORMATS(func) \
+	if (uMsg == WM_RENDERALLFORMATS) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDestroyClipboard()
+#define MSG_WM_DESTROYCLIPBOARD(func) \
+	if (uMsg == WM_DESTROYCLIPBOARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDrawClipboard()
+#define MSG_WM_DRAWCLIPBOARD(func) \
+	if (uMsg == WM_DRAWCLIPBOARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPaintClipboard(CWindow wndViewer, const LPPAINTSTRUCT lpPaintStruct)
+#define MSG_WM_PAINTCLIPBOARD(func) \
+	if (uMsg == WM_PAINTCLIPBOARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, (const LPPAINTSTRUCT)::GlobalLock((HGLOBAL)lParam)); \
+		::GlobalUnlock((HGLOBAL)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnVScrollClipboard(CWindow wndViewer, UINT nSBCode, UINT nPos)
+#define MSG_WM_VSCROLLCLIPBOARD(func) \
+	if (uMsg == WM_VSCROLLCLIPBOARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnContextMenu(CWindow wnd, CPoint point)
+#define MSG_WM_CONTEXTMENU(func) \
+	if (uMsg == WM_CONTEXTMENU) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSizeClipboard(CWindow wndViewer, const LPRECT lpRect)
+#define MSG_WM_SIZECLIPBOARD(func) \
+	if (uMsg == WM_SIZECLIPBOARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, (const LPRECT)::GlobalLock((HGLOBAL)lParam)); \
+		::GlobalUnlock((HGLOBAL)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnAskCbFormatName(UINT nMaxCount, LPTSTR lpszString)
+#define MSG_WM_ASKCBFORMATNAME(func) \
+	if (uMsg == WM_ASKCBFORMATNAME) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((DWORD)wParam, (LPTSTR)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnChangeCbChain(CWindow wndRemove, CWindow wndAfter)
+#define MSG_WM_CHANGECBCHAIN(func) \
+	if (uMsg == WM_CHANGECBCHAIN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnHScrollClipboard(CWindow wndViewer, UINT nSBCode, UINT nPos)
+#define MSG_WM_HSCROLLCLIPBOARD(func) \
+	if (uMsg == WM_HSCROLLCLIPBOARD) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnQueryNewPalette()
+#define MSG_WM_QUERYNEWPALETTE(func) \
+	if (uMsg == WM_QUERYNEWPALETTE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPaletteChanged(CWindow wndFocus)
+#define MSG_WM_PALETTECHANGED(func) \
+	if (uMsg == WM_PALETTECHANGED) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPaletteIsChanging(CWindow wndPalChg)
+#define MSG_WM_PALETTEISCHANGING(func) \
+	if (uMsg == WM_PALETTEISCHANGING) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDropFiles(HDROP hDropInfo)
+#define MSG_WM_DROPFILES(func) \
+	if (uMsg == WM_DROPFILES) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HDROP)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnWindowPosChanging(LPWINDOWPOS lpWndPos)
+#define MSG_WM_WINDOWPOSCHANGING(func) \
+	if (uMsg == WM_WINDOWPOSCHANGING) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((LPWINDOWPOS)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnWindowPosChanged(LPWINDOWPOS lpWndPos)
+#define MSG_WM_WINDOWPOSCHANGED(func) \
+	if (uMsg == WM_WINDOWPOSCHANGED) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((LPWINDOWPOS)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnExitMenuLoop(BOOL fIsTrackPopupMenu)
+#define MSG_WM_EXITMENULOOP(func) \
+	if (uMsg == WM_EXITMENULOOP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnEnterMenuLoop(BOOL fIsTrackPopupMenu)
+#define MSG_WM_ENTERMENULOOP(func) \
+	if (uMsg == WM_ENTERMENULOOP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
+#define MSG_WM_STYLECHANGED(func) \
+	if (uMsg == WM_STYLECHANGED) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPSTYLESTRUCT)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnStyleChanging(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
+#define MSG_WM_STYLECHANGING(func) \
+	if (uMsg == WM_STYLECHANGING) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPSTYLESTRUCT)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSizing(UINT fwSide, LPRECT pRect)
+#define MSG_WM_SIZING(func) \
+	if (uMsg == WM_SIZING) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPRECT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMoving(UINT fwSide, LPRECT pRect)
+#define MSG_WM_MOVING(func) \
+	if (uMsg == WM_MOVING) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPRECT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCaptureChanged(CWindow wnd)
+#define MSG_WM_CAPTURECHANGED(func) \
+	if (uMsg == WM_CAPTURECHANGED) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnDeviceChange(UINT nEventType, DWORD dwData)
+#define MSG_WM_DEVICECHANGE(func) \
+	if (uMsg == WM_DEVICECHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)wParam, (DWORD)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCommand(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define MSG_WM_COMMAND(func) \
+	if (uMsg == WM_COMMAND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDisplayChange(UINT uBitsPerPixel, CSize sizeScreen)
+#define MSG_WM_DISPLAYCHANGE(func) \
+	if (uMsg == WM_DISPLAYCHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, _WTYPES_NS::CSize(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnEnterSizeMove()
+#define MSG_WM_ENTERSIZEMOVE(func) \
+	if (uMsg == WM_ENTERSIZEMOVE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnExitSizeMove()
+#define MSG_WM_EXITSIZEMOVE(func) \
+	if (uMsg == WM_EXITSIZEMOVE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HFONT OnGetFont()
+#define MSG_WM_GETFONT(func) \
+	if (uMsg == WM_GETFONT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnGetHotKey()
+#define MSG_WM_GETHOTKEY(func) \
+	if (uMsg == WM_GETHOTKEY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HICON OnGetIcon()
+#define MSG_WM_GETICON(func) \
+	if (uMsg == WM_GETICON) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)wParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnGetText(int cchTextMax, LPTSTR lpszText)
+#define MSG_WM_GETTEXT(func) \
+	if (uMsg == WM_GETTEXT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((int)wParam, (LPTSTR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnGetTextLength()
+#define MSG_WM_GETTEXTLENGTH(func) \
+	if (uMsg == WM_GETTEXTLENGTH) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnHelp(LPHELPINFO lpHelpInfo)
+#define MSG_WM_HELP(func) \
+	if (uMsg == WM_HELP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((LPHELPINFO)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnHotKey(int nHotKeyID, UINT uModifiers, UINT uVirtKey)
+#define MSG_WM_HOTKEY(func) \
+	if (uMsg == WM_HOTKEY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((int)wParam, (UINT)LOWORD(lParam), (UINT)HIWORD(lParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnInputLangChange(DWORD dwCharSet, HKL hKbdLayout)
+#define MSG_WM_INPUTLANGCHANGE(func) \
+	if (uMsg == WM_INPUTLANGCHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((DWORD)wParam, (HKL)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnInputLangChangeRequest(BOOL bSysCharSet, HKL hKbdLayout)
+#define MSG_WM_INPUTLANGCHANGEREQUEST(func) \
+	if (uMsg == WM_INPUTLANGCHANGEREQUEST) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam, (HKL)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNextDlgCtl(BOOL bHandle, WPARAM wCtlFocus)
+#define MSG_WM_NEXTDLGCTL(func) \
+	if (uMsg == WM_NEXTDLGCTL) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)LOWORD(lParam), wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNextMenu(int nVirtKey, LPMDINEXTMENU lpMdiNextMenu)
+#define MSG_WM_NEXTMENU(func) \
+	if (uMsg == WM_NEXTMENU) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((int)wParam, (LPMDINEXTMENU)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnNotifyFormat(CWindow wndFrom, int nCommand)
+#define MSG_WM_NOTIFYFORMAT(func) \
+	if (uMsg == WM_NOTIFYFORMAT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HWND)wParam, (int)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// BOOL OnPowerBroadcast(DWORD dwPowerEvent, DWORD dwData)
+#define MSG_WM_POWERBROADCAST(func) \
+	if (uMsg == WM_POWERBROADCAST) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((DWORD)wParam, (DWORD)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPrint(CDCHandle dc, UINT uFlags)
+#define MSG_WM_PRINT(func) \
+	if (uMsg == WM_PRINT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HDC)wParam, (UINT)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPrintClient(CDCHandle dc, UINT uFlags)
+#define MSG_WM_PRINTCLIENT(func) \
+	if (uMsg == WM_PRINTCLIENT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HDC)wParam, (UINT)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnRasDialEvent(RASCONNSTATE rasconnstate, DWORD dwError)
+#define MSG_WM_RASDIALEVENT(func) \
+	if (uMsg == WM_RASDIALEVENT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((RASCONNSTATE)wParam, (DWORD)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSetFont(CFontHandle font, BOOL bRedraw)
+#define MSG_WM_SETFONT(func) \
+	if (uMsg == WM_SETFONT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((HFONT)wParam, (BOOL)LOWORD(lParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnSetHotKey(int nVirtKey, UINT uFlags)
+#define MSG_WM_SETHOTKEY(func) \
+	if (uMsg == WM_SETHOTKEY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((int)LOBYTE(LOWORD(wParam)), (UINT)HIBYTE(LOWORD(wParam))); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HICON OnSetIcon(UINT uType, HICON hIcon)
+#define MSG_WM_SETICON(func) \
+	if (uMsg == WM_SETICON) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)wParam, (HICON)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnSetRedraw(BOOL bRedraw)
+#define MSG_WM_SETREDRAW(func) \
+	if (uMsg == WM_SETREDRAW) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((BOOL)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnSetText(LPCTSTR lpstrText)
+#define MSG_WM_SETTEXT(func) \
+	if (uMsg == WM_SETTEXT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((LPCTSTR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnUserChanged()
+#define MSG_WM_USERCHANGED(func) \
+	if (uMsg == WM_USERCHANGED) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// New NT4 & NT5 messages
+
+#if(_WIN32_WINNT >= 0x0400)
+
+// void OnMouseHover(WPARAM wParam, CPoint ptPos)
+#define MSG_WM_MOUSEHOVER(func) \
+	if (uMsg == WM_MOUSEHOVER) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(wParam, _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMouseLeave()
+#define MSG_WM_MOUSELEAVE(func) \
+	if (uMsg == WM_MOUSELEAVE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+#endif /* _WIN32_WINNT >= 0x0400 */
+
+#if(WINVER >= 0x0500)
+
+// void OnMenuRButtonUp(WPARAM wParam, CMenuHandle menu)
+#define MSG_WM_MENURBUTTONUP(func) \
+	if (uMsg == WM_MENURBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(wParam, (HMENU)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnMenuDrag(WPARAM wParam, CMenuHandle menu)
+#define MSG_WM_MENUDRAG(func) \
+	if (uMsg == WM_MENUDRAG) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func(wParam, (HMENU)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnMenuGetObject(PMENUGETOBJECTINFO info)
+#define MSG_WM_MENUGETOBJECT(func) \
+	if (uMsg == WM_MENUGETOBJECT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((PMENUGETOBJECTINFO)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnUnInitMenuPopup(UINT nID, CMenuHandle menu)
+#define MSG_WM_UNINITMENUPOPUP(func) \
+	if (uMsg == WM_UNINITMENUPOPUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(lParam), (HMENU)wParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnMenuCommand(WPARAM nIndex, CMenuHandle menu)
+#define MSG_WM_MENUCOMMAND(func) \
+	if (uMsg == WM_MENUCOMMAND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(wParam, (HMENU)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+#endif /* WINVER >= 0x0500 */
+
+#if(_WIN32_WINNT >= 0x0500)
+
+// BOOL OnAppCommand(CWindow wndFocus, short cmd, WORD uDevice, int dwKeys)
+#define MSG_WM_APPCOMMAND(func) \
+	if (uMsg == WM_APPCOMMAND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HWND)wParam, GET_APPCOMMAND_LPARAM(lParam), GET_DEVICE_LPARAM(lParam), GET_KEYSTATE_LPARAM(lParam)); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNCXButtonDown(int fwButton, short nHittest, CPoint ptPos)
+#define MSG_WM_NCXBUTTONDOWN(func) \
+	if (uMsg == WM_NCXBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_XBUTTON_WPARAM(wParam), GET_NCHITTEST_WPARAM(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNCXButtonUp(int fwButton, short nHittest, CPoint ptPos)
+#define MSG_WM_NCXBUTTONUP(func) \
+	if (uMsg == WM_NCXBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_XBUTTON_WPARAM(wParam), GET_NCHITTEST_WPARAM(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnNCXButtonDblClk(int fwButton, short nHittest, CPoint ptPos)
+#define MSG_WM_NCXBUTTONDBLCLK(func) \
+	if (uMsg == WM_NCXBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_XBUTTON_WPARAM(wParam), GET_NCHITTEST_WPARAM(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnXButtonDown(int fwButton, int dwKeys, CPoint ptPos)
+#define MSG_WM_XBUTTONDOWN(func) \
+	if (uMsg == WM_XBUTTONDOWN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_XBUTTON_WPARAM(wParam), GET_KEYSTATE_WPARAM(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnXButtonUp(int fwButton, int dwKeys, CPoint ptPos)
+#define MSG_WM_XBUTTONUP(func) \
+	if (uMsg == WM_XBUTTONUP) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_XBUTTON_WPARAM(wParam), GET_KEYSTATE_WPARAM(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnXButtonDblClk(int fwButton, int dwKeys, CPoint ptPos)
+#define MSG_WM_XBUTTONDBLCLK(func) \
+	if (uMsg == WM_XBUTTONDBLCLK) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_XBUTTON_WPARAM(wParam), GET_KEYSTATE_WPARAM(wParam), _WTYPES_NS::CPoint(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnChangeUIState(WORD nAction, WORD nState)
+#define MSG_WM_CHANGEUISTATE(func) \
+	if (uMsg == WM_CHANGEUISTATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(LOWORD(wParam), HIWORD(wParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnUpdateUIState(WORD nAction, WORD nState)
+#define MSG_WM_UPDATEUISTATE(func) \
+	if (uMsg == WM_UPDATEUISTATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(LOWORD(wParam), HIWORD(wParam)); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnQueryUIState()
+#define MSG_WM_QUERYUISTATE(func) \
+	if (uMsg == WM_QUERYUISTATE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+#endif // (_WIN32_WINNT >= 0x0500)
+
+#if(_WIN32_WINNT >= 0x0501)
+
+// void OnInput(WPARAM RawInputCode, HRAWINPUT hRawInput)
+#define MSG_WM_INPUT(func) \
+	if (uMsg == WM_INPUT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(GET_RAWINPUT_CODE_WPARAM(wParam), (HRAWINPUT)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnUniChar(TCHAR nChar, UINT nRepCnt, UINT nFlags)
+#define MSG_WM_UNICHAR(func) \
+	if (uMsg == WM_UNICHAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((TCHAR)wParam, (UINT)lParam & 0xFFFF, (UINT)((lParam & 0xFFFF0000) >> 16)); \
+		if(IsMsgHandled()) \
+		{ \
+			lResult = (wParam == UNICODE_NOCHAR) ? TRUE : FALSE; \
+			return TRUE; \
+		} \
+	}
+
+// void OnWTSSessionChange(WPARAM nStatusCode, PWTSSESSION_NOTIFICATION nSessionID)
+#define MSG_WM_WTSSESSION_CHANGE(func) \
+	if (uMsg == WM_WTSSESSION_CHANGE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(wParam, (PWTSSESSION_NOTIFICATION)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// OnThemeChanged()
+#define MSG_WM_THEMECHANGED(func) \
+	if (uMsg == WM_THEMECHANGED) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+#endif /* _WIN32_WINNT >= 0x0501 */
+
+///////////////////////////////////////////////////////////////////////////////
+// ATL defined messages
+
+// BOOL OnForwardMsg(LPMSG Msg, DWORD nUserData)
+#define MSG_WM_FORWARDMSG(func) \
+	if (uMsg == WM_FORWARDMSG) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((LPMSG)lParam, (DWORD)wParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// Dialog specific messages
+
+// LRESULT OnDMGetDefID()
+#define MSG_DM_GETDEFID(func) \
+	if (uMsg == DM_GETDEFID) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func(); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDMSetDefID(UINT DefID)
+#define MSG_DM_SETDEFID(func) \
+	if (uMsg == DM_SETDEFID) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnDMReposition()
+#define MSG_DM_REPOSITION(func) \
+	if (uMsg == DM_REPOSITION) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// Reflected messages
+
+// void OnReflectedCommand(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define MSG_OCM_COMMAND(func) \
+	if (uMsg == OCM_COMMAND) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedNotify(int idCtrl, LPNMHDR pnmh)
+#define MSG_OCM_NOTIFY(func) \
+	if (uMsg == OCM_NOTIFY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((int)wParam, (LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedParentNotify(UINT message, UINT nChildID, LPARAM lParam)
+#define MSG_OCM_PARENTNOTIFY(func) \
+	if (uMsg == OCM_PARENTNOTIFY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct)
+#define MSG_OCM_DRAWITEM(func) \
+	if (uMsg == OCM_DRAWITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPDRAWITEMSTRUCT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct)
+#define MSG_OCM_MEASUREITEM(func) \
+	if (uMsg == OCM_MEASUREITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPMEASUREITEMSTRUCT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnReflectedCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct)
+#define MSG_OCM_COMPAREITEM(func) \
+	if (uMsg == OCM_COMPAREITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)wParam, (LPCOMPAREITEMSTRUCT)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedDeleteItem(int nIDCtl, LPDELETEITEMSTRUCT lpDeleteItemStruct)
+#define MSG_OCM_DELETEITEM(func) \
+	if (uMsg == OCM_DELETEITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)wParam, (LPDELETEITEMSTRUCT)lParam); \
+		lResult = TRUE; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// int OnReflectedVKeyToItem(UINT nKey, UINT nIndex, CListBox listBox)
+#define MSG_OCM_VKEYTOITEM(func) \
+	if (uMsg == OCM_VKEYTOITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+//int OnReflectedCharToItem(UINT nChar, UINT nIndex, CListBox listBox)
+#define MSG_OCM_CHARTOITEM(func) \
+	if (uMsg == OCM_CHARTOITEM) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((UINT)LOWORD(wParam), (UINT)HIWORD(wParam), (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedHScroll(UINT nSBCode, UINT nPos, CScrollBar pScrollBar)
+#define MSG_OCM_HSCROLL(func) \
+	if (uMsg == OCM_HSCROLL) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedVScroll(UINT nSBCode, UINT nPos, CScrollBar pScrollBar)
+#define MSG_OCM_VSCROLL(func) \
+	if (uMsg == OCM_VSCROLL) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((int)LOWORD(wParam), (short)HIWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnReflectedCtlColorEdit(CDCHandle dc, CEdit edit)
+#define MSG_OCM_CTLCOLOREDIT(func) \
+	if (uMsg == OCM_CTLCOLOREDIT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnReflectedCtlColorListBox(CDCHandle dc, CListBox listBox)
+#define MSG_OCM_CTLCOLORLISTBOX(func) \
+	if (uMsg == OCM_CTLCOLORLISTBOX) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnReflectedCtlColorBtn(CDCHandle dc, CButton button)
+#define MSG_OCM_CTLCOLORBTN(func) \
+	if (uMsg == OCM_CTLCOLORBTN) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnReflectedCtlColorDlg(CDCHandle dc, CWindow wnd)
+#define MSG_OCM_CTLCOLORDLG(func) \
+	if (uMsg == OCM_CTLCOLORDLG) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnReflectedCtlColorScrollBar(CDCHandle dc, CScrollBar scrollBar)
+#define MSG_OCM_CTLCOLORSCROLLBAR(func) \
+	if (uMsg == OCM_CTLCOLORSCROLLBAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// HBRUSH OnReflectedCtlColorStatic(CDCHandle dc, CStatic wndStatic)
+#define MSG_OCM_CTLCOLORSTATIC(func) \
+	if (uMsg == OCM_CTLCOLORSTATIC) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = (LRESULT)func((HDC)wParam, (HWND)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// Edit specific messages
+
+// void OnClear()
+#define MSG_WM_CLEAR(func) \
+	if (uMsg == WM_CLEAR) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCopy()
+#define MSG_WM_COPY(func) \
+	if (uMsg == WM_COPY) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCut()
+#define MSG_WM_CUT(func) \
+	if (uMsg == WM_CUT) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnPaste()
+#define MSG_WM_PASTE(func) \
+	if (uMsg == WM_PASTE) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnUndo()
+#define MSG_WM_UNDO(func) \
+	if (uMsg == WM_UNDO) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func(); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// Generic message handlers
+
+// LRESULT OnMessageHandlerEX(UINT uMsg, WPARAM wParam, LPARAM lParam)
+#define MESSAGE_HANDLER_EX(msg, func) \
+	if(uMsg == msg) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func(uMsg, wParam, lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnMessageRangeHandlerEX(UINT uMsg, WPARAM wParam, LPARAM lParam)
+#define MESSAGE_RANGE_HANDLER_EX(msgFirst, msgLast, func) \
+	if(uMsg >= msgFirst && uMsg <= msgLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func(uMsg, wParam, lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// Commands and notifications
+
+// void OnCommandHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define COMMAND_HANDLER_EX(id, code, func) \
+	if (uMsg == WM_COMMAND && code == HIWORD(wParam) && id == LOWORD(wParam)) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCommandIDHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define COMMAND_ID_HANDLER_EX(id, func) \
+	if (uMsg == WM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCommandCodeHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define COMMAND_CODE_HANDLER_EX(code, func) \
+	if (uMsg == WM_COMMAND && code == HIWORD(wParam)) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNotifyHandlerEX(LPNMHDR pnmh)
+#define NOTIFY_HANDLER_EX(id, cd, func) \
+	if (uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && id == ((LPNMHDR)lParam)->idFrom) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNotifyIDHandlerEX(LPNMHDR pnmh)
+#define NOTIFY_ID_HANDLER_EX(id, func) \
+	if (uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNotifyCodeHandlerEX(LPNMHDR pnmh)
+#define NOTIFY_CODE_HANDLER_EX(cd, func) \
+	if (uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCommandRangeHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define COMMAND_RANGE_HANDLER_EX(idFirst, idLast, func) \
+	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst && LOWORD(wParam) <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnCommandRangeCodeHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define COMMAND_RANGE_CODE_HANDLER_EX(idFirst, idLast, code, func) \
+	if(uMsg == WM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst && LOWORD(wParam) <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNotifyRangeHandlerEX(LPNMHDR pnmh)
+#define NOTIFY_RANGE_HANDLER_EX(idFirst, idLast, func) \
+	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnNotifyRangeCodeHandlerEX(LPNMHDR pnmh)
+#define NOTIFY_RANGE_CODE_HANDLER_EX(idFirst, idLast, cd, func) \
+	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedCommandHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define REFLECTED_COMMAND_HANDLER_EX(id, code, func) \
+	if (uMsg == OCM_COMMAND && code == HIWORD(wParam) && id == LOWORD(wParam)) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedCommandIDHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define REFLECTED_COMMAND_ID_HANDLER_EX(id, func) \
+	if (uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedCommandCodeHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define REFLECTED_COMMAND_CODE_HANDLER_EX(code, func) \
+	if (uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedNotifyHandlerEX(LPNMHDR pnmh)
+#define REFLECTED_NOTIFY_HANDLER_EX(id, cd, func) \
+	if (uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && id == ((LPNMHDR)lParam)->idFrom) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedNotifyIDHandlerEX(LPNMHDR pnmh)
+#define REFLECTED_NOTIFY_ID_HANDLER_EX(id, func) \
+	if (uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedNotifyCodeHandlerEX(LPNMHDR pnmh)
+#define REFLECTED_NOTIFY_CODE_HANDLER_EX(cd, func) \
+	if (uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedCommandRangeHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define REFLECTED_COMMAND_RANGE_HANDLER_EX(idFirst, idLast, func) \
+	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst && LOWORD(wParam) <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// void OnReflectedCommandRangeCodeHandlerEX(UINT uNotifyCode, int nID, CWindow wndCtl)
+#define REFLECTED_COMMAND_RANGE_CODE_HANDLER_EX(idFirst, idLast, code, func) \
+	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst && LOWORD(wParam) <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		func((UINT)HIWORD(wParam), (int)LOWORD(wParam), (HWND)lParam); \
+		lResult = 0; \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedNotifyRangeHandlerEX(LPNMHDR pnmh)
+#define REFLECTED_NOTIFY_RANGE_HANDLER_EX(idFirst, idLast, func) \
+	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+// LRESULT OnReflectedNotifyRangeCodeHandlerEX(LPNMHDR pnmh)
+#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER_EX(idFirst, idLast, cd, func) \
+	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		SetMsgHandled(TRUE); \
+		lResult = func((LPNMHDR)lParam); \
+		if(IsMsgHandled()) \
+			return TRUE; \
+	}
+
+#endif // __ATLCRACK_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlctrls.h b/GLideN64/src/GLideNUI-wtl/WTL/atlctrls.h
new file mode 100644
index 00000000..776672bf
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlctrls.h
@@ -0,0 +1,10071 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLCTRLS_H__
+#define __ATLCTRLS_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlctrls.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atlctrls.h requires atlwin.h to be included first
+#endif
+
+#ifndef _WIN32_WCE
+  #include <richedit.h>
+  #include <richole.h>
+#elif defined(WIN32_PLATFORM_WFSP) && !defined(_WINUSERM_H_)
+  #include <winuserm.h>
+#endif // !_WIN32_WCE
+
+// protect template members from windowsx.h macros
+#ifdef _INC_WINDOWSX
+  #undef GetNextSibling
+  #undef GetPrevSibling
+#endif // _INC_WINDOWSX
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CStaticT<TBase> - CStatic
+// CButtonT<TBase> - CButton
+// CListBoxT<TBase> - CListBox
+// CComboBoxT<TBase> - CComboBox
+// CEditT<TBase> - CEdit
+// CEditCommands<T>
+// CScrollBarT<TBase> - CScrollBar
+//
+// CImageList
+// CListViewCtrlT<TBase> - CListViewCtrl
+// CTreeViewCtrlT<TBase> - CTreeViewCtrl
+// CTreeItemT<TBase> - CTreeItem
+// CTreeViewCtrlExT<TBase> - CTreeViewCtrlEx
+// CHeaderCtrlT<TBase> - CHeaderCtrl
+// CToolBarCtrlT<TBase> - CToolBarCtrl
+// CStatusBarCtrlT<TBase> - CStatusBarCtrl
+// CTabCtrlT<TBase> - CTabCtrl
+// CToolInfo
+// CToolTipCtrlT<TBase> - CToolTipCtrl
+// CTrackBarCtrlT<TBase> - CTrackBarCtrl
+// CUpDownCtrlT<TBase> - CUpDownCtrl
+// CProgressBarCtrlT<TBase> - CProgressBarCtrl
+// CHotKeyCtrlT<TBase> - CHotKeyCtrl
+// CAnimateCtrlT<TBase> - CAnimateCtrl
+// CRichEditCtrlT<TBase> - CRichEditCtrl
+// CRichEditCommands<T>
+// CDragListBoxT<TBase> - CDragListBox
+// CDragListNotifyImpl<T>
+// CReBarCtrlT<TBase> - CReBarCtrl
+// CComboBoxExT<TBase> - CComboBoxEx
+// CDateTimePickerCtrlT<TBase> - CDateTimePickerCtrl
+// CMonthCalendarCtrlT<TBase> - CMonthCalendarCtrl
+// CFlatScrollBarImpl<T>
+// CFlatScrollBarT<TBase> - CFlatScrollBar
+// CIPAddressCtrlT<TBase> - CIPAddressCtrl
+// CPagerCtrlT<TBase> - CPagerCtrl
+// CLinkCtrlT<TBase> - CLinkCtrl
+//
+// CCustomDraw<T>
+//
+// CCECommandBarCtrlT<TBase> - CCECommandBarCtrl
+// CCECommandBandsCtrlT<TBase> - CCECommandBandsCtrl
+
+
+namespace WTL
+{
+
+// These are wrapper classes for Windows standard and common controls.
+// To implement a window based on a control, use following:
+// Example: Implementing a window based on a list box
+//
+// class CMyListBox : CWindowImpl<CMyListBox, CListBox>
+// {
+// public:
+//      BEGIN_MSG_MAP(CMyListBox)
+//          // put your message handler entries here
+//      END_MSG_MAP()
+// };
+
+
+
+// --- Standard Windows controls ---
+
+///////////////////////////////////////////////////////////////////////////////
+// CStatic - client side for a Windows STATIC control
+
+template <class TBase>
+class CStaticT : public TBase
+{
+public:
+// Constructors
+	CStaticT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CStaticT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return _T("STATIC");
+	}
+
+#ifndef _WIN32_WCE
+	HICON GetIcon() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L);
+	}
+
+	HICON SetIcon(HICON hIcon)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L);
+	}
+
+	HENHMETAFILE GetEnhMetaFile() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HENHMETAFILE)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ENHMETAFILE, 0L);
+	}
+
+	HENHMETAFILE SetEnhMetaFile(HENHMETAFILE hMetaFile)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HENHMETAFILE)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ENHMETAFILE, (LPARAM)hMetaFile);
+	}
+#else // CE specific
+	HICON GetIcon() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HICON)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_ICON, 0L);
+	}
+
+	HICON SetIcon(HICON hIcon)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HICON)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
+	}
+#endif // _WIN32_WCE
+
+	CBitmapHandle GetBitmap() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_BITMAP, 0L));
+	}
+
+	CBitmapHandle SetBitmap(HBITMAP hBitmap)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap));
+	}
+
+	HCURSOR GetCursor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HCURSOR)::SendMessage(m_hWnd, STM_GETIMAGE, IMAGE_CURSOR, 0L);
+	}
+
+	HCURSOR SetCursor(HCURSOR hCursor)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HCURSOR)::SendMessage(m_hWnd, STM_SETIMAGE, IMAGE_CURSOR, (LPARAM)hCursor);
+	}
+};
+
+typedef CStaticT<ATL::CWindow>   CStatic;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CButton - client side for a Windows BUTTON control
+
+template <class TBase>
+class CButtonT : public TBase
+{
+public:
+// Constructors
+	CButtonT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CButtonT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return _T("BUTTON");
+	}
+
+	UINT GetState() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0L);
+	}
+
+	void SetState(BOOL bHighlight)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0L);
+	}
+
+	int GetCheck() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0L);
+	}
+
+	void SetCheck(int nCheck)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0L);
+	}
+
+	UINT GetButtonStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::GetWindowLong(m_hWnd, GWL_STYLE) & 0xFFFF;
+	}
+
+	void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw);
+	}
+
+#ifndef _WIN32_WCE
+	HICON GetIcon() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HICON)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_ICON, 0L);
+	}
+
+	HICON SetIcon(HICON hIcon)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HICON)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_ICON, (LPARAM)hIcon);
+	}
+
+	CBitmapHandle GetBitmap() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, BM_GETIMAGE, IMAGE_BITMAP, 0L));
+	}
+
+	CBitmapHandle SetBitmap(HBITMAP hBitmap)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CBitmapHandle((HBITMAP)::SendMessage(m_hWnd, BM_SETIMAGE, IMAGE_BITMAP, (LPARAM)hBitmap));
+	}
+#endif // !_WIN32_WCE
+
+#if (_WIN32_WINNT >= 0x0501)
+	BOOL GetIdealSize(LPSIZE lpSize) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, BCM_GETIDEALSIZE, 0, (LPARAM)lpSize);
+	}
+
+	BOOL GetImageList(PBUTTON_IMAGELIST pButtonImagelist) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, BCM_GETIMAGELIST, 0, (LPARAM)pButtonImagelist);
+	}
+
+	BOOL SetImageList(PBUTTON_IMAGELIST pButtonImagelist)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, BCM_SETIMAGELIST, 0, (LPARAM)pButtonImagelist);
+	}
+
+	BOOL GetTextMargin(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, BCM_GETTEXTMARGIN, 0, (LPARAM)lpRect);
+	}
+
+	BOOL SetTextMargin(LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, BCM_SETTEXTMARGIN, 0, (LPARAM)lpRect);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (WINVER >= 0x0600)
+	void SetDontClick(BOOL bDontClick)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, BM_SETDONTCLICK, (WPARAM)bDontClick, 0L);
+	}
+#endif // (WINVER >= 0x0600)
+
+#if (_WIN32_WINNT >= 0x0600)
+	BOOL SetDropDownState(BOOL bDropDown)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (BS_SPLITBUTTON | BS_DEFSPLITBUTTON)) != 0);
+		return (BOOL)::SendMessage(m_hWnd, BCM_SETDROPDOWNSTATE, (WPARAM)bDropDown, 0L);
+	}
+
+	BOOL GetSplitInfo(PBUTTON_SPLITINFO pSplitInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (BS_SPLITBUTTON | BS_DEFSPLITBUTTON)) != 0);
+		return (BOOL)::SendMessage(m_hWnd, BCM_GETSPLITINFO, 0, (LPARAM)pSplitInfo);
+	}
+
+	BOOL SetSplitInfo(PBUTTON_SPLITINFO pSplitInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (BS_SPLITBUTTON | BS_DEFSPLITBUTTON)) != 0);
+		return (BOOL)::SendMessage(m_hWnd, BCM_SETSPLITINFO, 0, (LPARAM)pSplitInfo);
+	}
+
+	int GetNoteLength() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (BS_COMMANDLINK | BS_DEFCOMMANDLINK)) != 0);
+		return (int)::SendMessage(m_hWnd, BCM_GETNOTELENGTH, 0, 0L);
+	}
+
+	BOOL GetNote(LPWSTR lpstrNoteText, int cchNoteText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (BS_COMMANDLINK | BS_DEFCOMMANDLINK)) != 0);
+		return (BOOL)::SendMessage(m_hWnd, BCM_GETNOTE, cchNoteText, (LPARAM)lpstrNoteText);
+	}
+
+	BOOL SetNote(LPCWSTR lpstrNoteText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (BS_COMMANDLINK | BS_DEFCOMMANDLINK)) != 0);
+		return (BOOL)::SendMessage(m_hWnd, BCM_SETNOTE, 0, (LPARAM)lpstrNoteText);
+	}
+
+	LRESULT SetElevationRequiredState(BOOL bSet)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::SendMessage(m_hWnd, BCM_SETSHIELD, 0, (LPARAM)bSet);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+// Operations
+	void Click()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, BM_CLICK, 0, 0L);
+	}
+};
+
+typedef CButtonT<ATL::CWindow>   CButton;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CListBox - client side for a Windows LISTBOX control
+
+template <class TBase>
+class CListBoxT : public TBase
+{
+public:
+// Constructors
+	CListBoxT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CListBoxT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return _T("LISTBOX");
+	}
+
+	// for entire listbox
+	int GetCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0L);
+	}
+
+#ifndef _WIN32_WCE
+	int SetCount(int cItems)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(((GetStyle() & LBS_NODATA) != 0) && ((GetStyle() & LBS_HASSTRINGS) == 0));
+		return (int)::SendMessage(m_hWnd, LB_SETCOUNT, cItems, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	int GetHorizontalExtent() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT, 0, 0L);
+	}
+
+	void SetHorizontalExtent(int cxExtent)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0L);
+	}
+
+	int GetTopIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0L);
+	}
+
+	int SetTopIndex(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0L);
+	}
+
+	LCID GetLocale() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LCID)::SendMessage(m_hWnd, LB_GETLOCALE, 0, 0L);
+	}
+
+	LCID SetLocale(LCID nNewLocale)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LCID)::SendMessage(m_hWnd, LB_SETLOCALE, (WPARAM)nNewLocale, 0L);
+	}
+
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+	DWORD GetListBoxInfo() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+#if (_WIN32_WINNT >= 0x0501)
+		return (DWORD)::SendMessage(m_hWnd, LB_GETLISTBOXINFO, 0, 0L);
+#else // !(_WIN32_WINNT >= 0x0501)
+		return ::GetListBoxInfo(m_hWnd);
+#endif // !(_WIN32_WINNT >= 0x0501)
+	}
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+
+	// for single-selection listboxes
+	int GetCurSel() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
+		return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0L);
+	}
+
+	int SetCurSel(int nSelect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
+		return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0L);
+	}
+
+	// for multiple-selection listboxes
+	int GetSel(int nIndex) const           // also works for single-selection
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0L);
+	}
+
+	int SetSel(int nIndex, BOOL bSelect = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
+		return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex);
+	}
+
+	int GetSelCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
+		return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0L);
+	}
+
+	int GetSelItems(int nMaxItems, LPINT rgIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
+		return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex);
+	}
+
+	int GetAnchorIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
+		return (int)::SendMessage(m_hWnd, LB_GETANCHORINDEX, 0, 0L);
+	}
+
+	void SetAnchorIndex(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
+		::SendMessage(m_hWnd, LB_SETANCHORINDEX, nIndex, 0L);
+	}
+
+	int GetCaretIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0);
+	}
+
+	int SetCaretIndex(int nIndex, BOOL bScroll = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0));
+	}
+
+	// for listbox items
+	DWORD_PTR GetItemData(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD_PTR)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
+	}
+
+	int SetItemData(int nIndex, DWORD_PTR dwItemData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
+	}
+
+	void* GetItemDataPtr(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (void*)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0L);
+	}
+
+	int SetItemDataPtr(int nIndex, void* pData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItemData(nIndex, (DWORD_PTR)pData);
+	}
+
+	int GetItemRect(int nIndex, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect);
+	}
+
+	int GetText(int nIndex, LPTSTR lpszBuffer) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer);
+	}
+
+#ifndef _ATL_NO_COM
+#ifdef _OLEAUTO_H_
+	BOOL GetTextBSTR(int nIndex, BSTR& bstrText) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrText == NULL);
+
+		int nLen = GetTextLen(nIndex);
+		if(nLen == LB_ERR)
+			return FALSE;
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrText = buff.Allocate(nLen + 1);
+		if(lpstrText == NULL)
+			return FALSE;
+
+		if(GetText(nIndex, lpstrText) == LB_ERR)
+			return FALSE;
+
+		bstrText = ::SysAllocString(T2OLE(lpstrText));
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // _OLEAUTO_H_
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetText(int nIndex, _CSTRING_NS::CString& strText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int cchLen = GetTextLen(nIndex);
+		if(cchLen == LB_ERR)
+			return LB_ERR;
+		int nRet = LB_ERR;
+		LPTSTR lpstr = strText.GetBufferSetLength(cchLen);
+		if(lpstr != NULL)
+		{
+			nRet = GetText(nIndex, lpstr);
+			strText.ReleaseBuffer();
+		}
+		return nRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	int GetTextLen(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0L);
+	}
+
+	int GetItemHeight(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L);
+	}
+
+	int SetItemHeight(int nIndex, UINT cyItemHeight)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
+	}
+
+	// Settable only attributes
+	void SetColumnWidth(int cxWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0L);
+	}
+
+	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
+		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
+	}
+
+	BOOL SetTabStops()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
+		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0L);
+	}
+
+	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LBS_USETABSTOPS) != 0);
+		return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
+	}
+
+// Operations
+	int InitStorage(int nItems, UINT nBytes)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_INITSTORAGE, (WPARAM)nItems, nBytes);
+	}
+
+	void ResetContent()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0L);
+	}
+
+	UINT ItemFromPoint(POINT pt, BOOL& bOutside) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dw = (DWORD)::SendMessage(m_hWnd, LB_ITEMFROMPOINT, 0, MAKELPARAM(pt.x, pt.y));
+		bOutside = (BOOL)HIWORD(dw);
+		return (UINT)LOWORD(dw);
+	}
+
+	// manipulating listbox items
+	int AddString(LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem);
+	}
+
+	int AddStringW(LPCWSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessageW(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem);
+	}
+
+    int DeleteString(UINT nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0L);
+	}
+
+	int InsertString(int nIndex, LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem);
+	}
+
+	int InsertStringW(int nIndex, LPCWSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessageW(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem);
+	}
+
+#ifndef _WIN32_WCE
+	int Dir(UINT attr, LPCTSTR lpszWildCard)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard);
+	}
+
+	int AddFile(LPCTSTR lpstrFileName)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_ADDFILE, 0, (LPARAM)lpstrFileName);
+	}
+#endif // !_WIN32_WCE
+
+	// selection helpers
+	int FindString(int nStartAfter, LPCTSTR lpszItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_FINDSTRING, nStartAfter, (LPARAM)lpszItem);
+	}
+
+	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
+	}
+
+	int SelectString(int nStartAfter, LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LB_SELECTSTRING, nStartAfter, (LPARAM)lpszItem);
+	}
+
+	int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) != 0);
+		ATLASSERT(nFirstItem <= nLastItem);
+		return bSelect ? (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nFirstItem, nLastItem) : (int)::SendMessage(m_hWnd, LB_SELITEMRANGEEX, nLastItem, nFirstItem);
+	}
+
+#ifdef WIN32_PLATFORM_WFSP   // SmartPhone only messages
+	DWORD GetInputMode(BOOL bCurrentMode = TRUE)
+	{
+		return SendMessage(LB_GETINPUTMODE, 0, (LPARAM)bCurrentMode);
+	}
+
+	BOOL SetInputMode(DWORD dwMode)
+	{
+		return SendMessage(LB_SETINPUTMODE, 0, (LPARAM)dwMode);
+	}
+#endif // WIN32_PLATFORM_WFSP
+};
+
+typedef CListBoxT<ATL::CWindow>   CListBox;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CComboBox - client side for a Windows COMBOBOX control
+
+#ifndef WIN32_PLATFORM_WFSP   // No COMBOBOX on SmartPhones
+
+template <class TBase>
+class CComboBoxT : public TBase
+{
+public:
+// Constructors
+	CComboBoxT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CComboBoxT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return _T("COMBOBOX");
+	}
+
+	// for entire combo box
+	int GetCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0L);
+	}
+
+	int GetCurSel() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0L);
+	}
+
+	int SetCurSel(int nSelect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0L);
+	}
+
+	LCID GetLocale() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LCID)::SendMessage(m_hWnd, CB_GETLOCALE, 0, 0L);
+	}
+
+	LCID SetLocale(LCID nNewLocale)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LCID)::SendMessage(m_hWnd, CB_SETLOCALE, (WPARAM)nNewLocale, 0L);
+	}
+
+	int GetTopIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETTOPINDEX, 0, 0L);
+	}
+
+	int SetTopIndex(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SETTOPINDEX, nIndex, 0L);
+	}
+
+	UINT GetHorizontalExtent() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, CB_GETHORIZONTALEXTENT, 0, 0L);
+	}
+
+	void SetHorizontalExtent(UINT nExtent)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, CB_SETHORIZONTALEXTENT, nExtent, 0L);
+	}
+
+	int GetDroppedWidth() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETDROPPEDWIDTH, 0, 0L);
+	}
+
+	int SetDroppedWidth(UINT nWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SETDROPPEDWIDTH, nWidth, 0L);
+	}
+
+#if ((WINVER >= 0x0500) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 420))
+	BOOL GetComboBoxInfo(PCOMBOBOXINFO pComboBoxInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+#if ((_WIN32_WINNT >= 0x0501) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 420))
+		return (BOOL)::SendMessage(m_hWnd, CB_GETCOMBOBOXINFO, 0, (LPARAM)pComboBoxInfo);
+#else // !((_WIN32_WINNT >= 0x0501) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 420))
+		return ::GetComboBoxInfo(m_hWnd, pComboBoxInfo);
+#endif // !((_WIN32_WINNT >= 0x0501) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 420))
+	}
+#endif // ((WINVER >= 0x0500) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 420))
+
+	// for edit control
+	DWORD GetEditSel() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0L);
+	}
+
+	BOOL SetEditSel(int nStartChar, int nEndChar)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar));
+	}
+
+	// for combobox item
+	DWORD_PTR GetItemData(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD_PTR)::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0L);
+	}
+
+	int SetItemData(int nIndex, DWORD_PTR dwItemData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData);
+	}
+
+	void* GetItemDataPtr(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (void*)GetItemData(nIndex);
+	}
+
+	int SetItemDataPtr(int nIndex, void* pData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItemData(nIndex, (DWORD_PTR)pData);
+	}
+
+	int GetLBText(int nIndex, LPTSTR lpszText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText);
+	}
+
+#ifndef _ATL_NO_COM
+	BOOL GetLBTextBSTR(int nIndex, BSTR& bstrText) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrText == NULL);
+
+		int nLen = GetLBTextLen(nIndex);
+		if(nLen == CB_ERR)
+			return FALSE;
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrText = buff.Allocate(nLen + 1);
+		if(lpstrText == NULL)
+			return FALSE;
+
+		if(GetLBText(nIndex, lpstrText) == CB_ERR)
+			return FALSE;
+
+		bstrText = ::SysAllocString(T2OLE(lpstrText));
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetLBText(int nIndex, _CSTRING_NS::CString& strText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int cchLen = GetLBTextLen(nIndex);
+		if(cchLen == CB_ERR)
+			return CB_ERR;
+		int nRet = CB_ERR;
+		LPTSTR lpstr = strText.GetBufferSetLength(cchLen);
+		if(lpstr != NULL)
+		{
+			nRet = GetLBText(nIndex, lpstr);
+			strText.ReleaseBuffer();
+		}
+		return nRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	int GetLBTextLen(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0L);
+	}
+
+	int GetItemHeight(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L);
+	}
+
+	int SetItemHeight(int nIndex, UINT cyItemHeight)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0));
+	}
+
+	BOOL GetExtendedUI() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L);
+	}
+
+	int SetExtendedUI(BOOL bExtended = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L);
+	}
+
+	void GetDroppedControlRect(LPRECT lprect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (LPARAM)lprect);
+	}
+
+	BOOL GetDroppedState() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L);
+	}
+
+#if (_WIN32_WINNT >= 0x0501)
+	int GetMinVisible() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_GETMINVISIBLE, 0, 0L);
+	}
+
+	BOOL SetMinVisible(int nMinVisible)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_SETMINVISIBLE, nMinVisible, 0L);
+	}
+
+	// Vista only
+	BOOL GetCueBannerText(LPWSTR lpwText, int cchText) const
+	{
+#ifndef CB_GETCUEBANNER
+		const UINT CB_GETCUEBANNER = (CBM_FIRST + 4);
+#endif
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_GETCUEBANNER, (WPARAM)lpwText, cchText);
+	}
+
+	// Vista only
+	BOOL SetCueBannerText(LPCWSTR lpcwText)
+	{
+#ifndef CB_SETCUEBANNER
+		const UINT CB_SETCUEBANNER = (CBM_FIRST + 3);
+#endif
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_SETCUEBANNER, 0, (LPARAM)lpcwText);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+// Operations
+	int InitStorage(int nItems, UINT nBytes)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_INITSTORAGE, (WPARAM)nItems, nBytes);
+	}
+
+	void ResetContent()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0L);
+	}
+
+	// for edit control
+	BOOL LimitText(int nMaxChars)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0L);
+	}
+
+	// for drop-down combo boxes
+	void ShowDropDown(BOOL bShowIt = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0L);
+	}
+
+	// manipulating listbox items
+	int AddString(LPCTSTR lpszString)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString);
+	}
+
+	int AddStringW(LPCWSTR lpszString)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessageW(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString);
+	}
+
+    int DeleteString(UINT nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0L);
+	}
+
+	int InsertString(int nIndex, LPCTSTR lpszString)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString);
+	}
+
+#ifndef _WIN32_WCE
+	int Dir(UINT attr, LPCTSTR lpszWildCard)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard);
+	}
+#endif // !_WIN32_WCE
+
+	// selection helpers
+	int FindString(int nStartAfter, LPCTSTR lpszString) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter, (LPARAM)lpszString);
+	}
+
+	int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind);
+	}
+
+	int SelectString(int nStartAfter, LPCTSTR lpszString)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CB_SELECTSTRING, nStartAfter, (LPARAM)lpszString);
+	}
+
+	// Clipboard operations
+	void Clear()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
+	}
+
+	void Copy()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
+	}
+
+	void Cut()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
+	}
+
+	void Paste()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
+	}
+};
+
+typedef CComboBoxT<ATL::CWindow>   CComboBox;
+
+#endif // !WIN32_PLATFORM_WFSP
+
+///////////////////////////////////////////////////////////////////////////////
+// CEdit - client side for a Windows EDIT control
+
+template <class TBase>
+class CEditT : public TBase
+{
+public:
+// Constructors
+	CEditT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CEditT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return _T("EDIT");
+	}
+
+	BOOL CanUndo() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
+	}
+
+	int GetLineCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
+	}
+
+	BOOL GetModify() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
+	}
+
+	void SetModify(BOOL bModified = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
+	}
+
+	void GetRect(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
+	}
+
+	DWORD GetSel() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_GETSEL, 0, 0L);
+	}
+
+	void GetSel(int& nStartChar, int& nEndChar) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
+	}
+
+#ifndef _WIN32_WCE
+	HLOCAL GetHandle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0L);
+	}
+
+	void SetHandle(HLOCAL hBuffer)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	DWORD GetMargins() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_GETMARGINS, 0, 0L);
+	}
+
+	void SetMargins(UINT nLeft, UINT nRight)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETMARGINS, EC_LEFTMARGIN|EC_RIGHTMARGIN, MAKELONG(nLeft, nRight));
+	}
+
+	UINT GetLimitText() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
+	}
+
+	void SetLimitText(UINT nMax)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETLIMITTEXT, nMax, 0L);
+	}
+
+	POINT PosFromChar(UINT nChar) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_POSFROMCHAR, nChar, 0);
+		POINT point = { GET_X_LPARAM(dwRet), GET_Y_LPARAM(dwRet) };
+		return point;
+	}
+
+	int CharFromPos(POINT pt, int* pLine = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, MAKELPARAM(pt.x, pt.y));
+		if(pLine != NULL)
+			*pLine = (int)(short)HIWORD(dwRet);
+		return (int)(short)LOWORD(dwRet);
+	}
+
+	// NOTE: first word in lpszBuffer must contain the size of the buffer!
+	int GetLine(int nIndex, LPTSTR lpszBuffer) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
+	}
+
+	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		*(LPWORD)lpszBuffer = (WORD)nMaxLength;
+		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
+	}
+
+	TCHAR GetPasswordChar() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (TCHAR)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L);
+	}
+
+	void SetPasswordChar(TCHAR ch)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0L);
+	}
+
+#ifndef _WIN32_WCE
+	EDITWORDBREAKPROC GetWordBreakProc() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (EDITWORDBREAKPROC)::SendMessage(m_hWnd, EM_GETWORDBREAKPROC, 0, 0L);
+	}
+
+	void SetWordBreakProc(EDITWORDBREAKPROC ewbprc)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETWORDBREAKPROC, 0, (LPARAM)ewbprc);
+	}
+#endif // !_WIN32_WCE
+
+	int GetFirstVisibleLine() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
+	}
+
+#ifndef _WIN32_WCE
+	int GetThumb() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & ES_MULTILINE) != 0);
+		return (int)::SendMessage(m_hWnd, EM_GETTHUMB, 0, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL SetReadOnly(BOOL bReadOnly = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
+	}
+
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+	UINT GetImeStatus(UINT uStatus) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETIMESTATUS, uStatus, 0L);
+	}
+
+	UINT SetImeStatus(UINT uStatus, UINT uData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_SETIMESTATUS, uStatus, uData);
+	}
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0501)
+	BOOL GetCueBannerText(LPCWSTR lpstrText, int cchText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_GETCUEBANNER, (WPARAM)lpstrText, cchText);
+	}
+
+	// bKeepWithFocus - Vista only
+	BOOL SetCueBannerText(LPCWSTR lpstrText, BOOL bKeepWithFocus = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCUEBANNER, (WPARAM)bKeepWithFocus, (LPARAM)(lpstrText));
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+// Operations
+	void EmptyUndoBuffer()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
+	}
+
+	BOOL FmtLines(BOOL bAddEOL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0L);
+	}
+
+	void LimitText(int nChars = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0L);
+	}
+
+	int LineFromChar(int nIndex = -1) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0L);
+	}
+
+	int LineIndex(int nLine = -1) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
+	}
+
+	int LineLength(int nLine = -1) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
+	}
+
+	void LineScroll(int nLines, int nChars = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
+	}
+
+	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
+	}
+
+	void SetRect(LPCRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
+	}
+
+	void SetRectNP(LPCRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect);
+	}
+
+	void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETSEL, LOWORD(dwSelection), HIWORD(dwSelection));
+		if(!bNoScroll)
+			::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
+	}
+
+	void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
+		if(!bNoScroll)
+			::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
+	}
+
+	void SetSelAll(BOOL bNoScroll = FALSE)
+	{
+		SetSel(0, -1, bNoScroll);
+	}
+
+	void SetSelNone(BOOL bNoScroll = FALSE)
+	{
+		SetSel(-1, 0, bNoScroll);
+	}
+
+	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
+	}
+
+	BOOL SetTabStops()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0L);
+	}
+
+	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
+	}
+
+	void ScrollCaret()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
+	}
+
+	int Scroll(int nScrollAction)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & ES_MULTILINE) != 0);
+		LRESULT lRet = ::SendMessage(m_hWnd, EM_SCROLL, nScrollAction, 0L);
+		if(!(BOOL)HIWORD(lRet))
+			return -1;   // failed
+		return (int)(short)LOWORD(lRet);
+		
+	}
+
+	void InsertText(int nInsertAfterChar, LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
+	{
+		SetSel(nInsertAfterChar, nInsertAfterChar, bNoScroll);
+		ReplaceSel(lpstrText, bCanUndo);
+	}
+
+	void AppendText(LPCTSTR lpstrText, BOOL bNoScroll = FALSE, BOOL bCanUndo = FALSE)
+	{
+		InsertText(GetWindowTextLength(), lpstrText, bNoScroll, bCanUndo);
+	}
+
+#if (_WIN32_WINNT >= 0x0501)
+	BOOL ShowBalloonTip(PEDITBALLOONTIP pEditBaloonTip)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SHOWBALLOONTIP, 0, (LPARAM)pEditBaloonTip);
+	}
+
+	BOOL HideBalloonTip()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_HIDEBALLOONTIP, 0, 0L);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_WINNT >= 0x0600)
+	DWORD GetHilite() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_GETHILITE, 0, 0L);
+	}
+
+	void GetHilite(int& nStartChar, int& nEndChar) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, EM_GETHILITE, 0, 0L);
+		nStartChar = (int)(short)LOWORD(dwRet);
+		nEndChar = (int)(short)HIWORD(dwRet);
+	}
+
+	void SetHilite(int nStartChar, int nEndChar)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETHILITE, nStartChar, nEndChar);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+	// Clipboard operations
+	BOOL Undo()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
+	}
+
+	void Clear()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
+	}
+
+	void Copy()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
+	}
+
+	void Cut()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
+	}
+
+	void Paste()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
+	}
+
+#ifdef WIN32_PLATFORM_WFSP   // SmartPhone only messages
+	DWORD GetExtendedStyle()
+	{
+		return SendMessage(EM_GETEXTENDEDSTYLE);
+	}
+
+	DWORD SetExtendedStyle(DWORD dwMask, DWORD dwExStyle)
+	{
+		return SendMessage(EM_SETEXTENDEDSTYLE, (WPARAM)dwMask, (LPARAM)dwExStyle);
+	}
+
+	DWORD GetInputMode(BOOL bCurrentMode = TRUE)
+	{
+		return SendMessage(EM_GETINPUTMODE, 0, (LPARAM)bCurrentMode);
+	}
+
+	BOOL SetInputMode(DWORD dwMode)
+	{
+		return SendMessage(EM_SETINPUTMODE, 0, (LPARAM)dwMode);
+	}
+
+	BOOL SetSymbols(LPCTSTR szSymbols)
+	{
+		return SendMessage(EM_SETSYMBOLS, 0, (LPARAM)szSymbols);
+	}
+
+	BOOL ResetSymbols()
+	{
+		return SendMessage(EM_SETSYMBOLS);
+	}
+#endif // WIN32_PLATFORM_WFSP
+};
+
+typedef CEditT<ATL::CWindow>   CEdit;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CEditCommands - message handlers for standard EDIT commands
+
+// Chain to CEditCommands message map. Your class must also derive from CEdit.
+// Example:
+// class CMyEdit : public CWindowImpl<CMyEdit, CEdit>,
+//                 public CEditCommands<CMyEdit>
+// {
+// public:
+//      BEGIN_MSG_MAP(CMyEdit)
+//              // your handlers...
+//              CHAIN_MSG_MAP_ALT(CEditCommands<CMyEdit>, 1)
+//      END_MSG_MAP()
+//      // other stuff...
+// };
+
+template <class T>
+class CEditCommands
+{
+public:
+	BEGIN_MSG_MAP(CEditCommands< T >)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_EDIT_CLEAR, OnEditClear)
+		COMMAND_ID_HANDLER(ID_EDIT_CLEAR_ALL, OnEditClearAll)
+		COMMAND_ID_HANDLER(ID_EDIT_COPY, OnEditCopy)
+		COMMAND_ID_HANDLER(ID_EDIT_CUT, OnEditCut)
+		COMMAND_ID_HANDLER(ID_EDIT_PASTE, OnEditPaste)
+		COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, OnEditSelectAll)
+		COMMAND_ID_HANDLER(ID_EDIT_UNDO, OnEditUndo)
+	END_MSG_MAP()
+
+	LRESULT OnEditClear(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Clear();
+		return 0;
+	}
+
+	LRESULT OnEditClearAll(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetSel(0, -1);
+		pT->Clear();
+		return 0;
+	}
+
+	LRESULT OnEditCopy(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Copy();
+		return 0;
+	}
+
+	LRESULT OnEditCut(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Cut();
+		return 0;
+	}
+
+	LRESULT OnEditPaste(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Paste();
+		return 0;
+	}
+
+	LRESULT OnEditSelectAll(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetSel(0, -1);
+		return 0;
+	}
+
+	LRESULT OnEditUndo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Undo();
+		return 0;
+	}
+
+// State (update UI) helpers
+	BOOL CanCut() const
+	{ return HasSelection(); }
+
+	BOOL CanCopy() const
+	{ return HasSelection(); }
+
+	BOOL CanClear() const
+	{ return HasSelection(); }
+
+	BOOL CanSelectAll() const
+	{ return HasText(); }
+
+	BOOL CanFind() const
+	{ return HasText(); }
+
+	BOOL CanRepeat() const
+	{ return HasText(); }
+
+	BOOL CanReplace() const
+	{ return HasText(); }
+
+	BOOL CanClearAll() const
+	{ return HasText(); }
+
+// Implementation
+	BOOL HasSelection() const
+	{
+		const T* pT = static_cast<const T*>(this);
+		int nMin, nMax;
+		::SendMessage(pT->m_hWnd, EM_GETSEL, (WPARAM)&nMin, (LPARAM)&nMax);
+		return (nMin != nMax);
+	}
+
+	BOOL HasText() const
+	{
+		const T* pT = static_cast<const T*>(this);
+		return (pT->GetWindowTextLength() > 0);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CScrollBar - client side for a Windows SCROLLBAR control
+
+template <class TBase>
+class CScrollBarT : public TBase
+{
+public:
+// Constructors
+	CScrollBarT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CScrollBarT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return _T("SCROLLBAR");
+	}
+
+#ifndef _WIN32_WCE
+	int GetScrollPos() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::GetScrollPos(m_hWnd, SB_CTL);
+	}
+#endif // !_WIN32_WCE
+
+	int SetScrollPos(int nPos, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw);
+	}
+
+#ifndef _WIN32_WCE
+	void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos);
+	}
+#endif // !_WIN32_WCE
+
+	void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw);
+	}
+
+	BOOL GetScrollInfo(LPSCROLLINFO lpScrollInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::GetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo);
+	}
+
+	int SetScrollInfo(LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::SetScrollInfo(m_hWnd, SB_CTL, lpScrollInfo, bRedraw);
+	}
+
+#ifndef _WIN32_WCE
+	int GetScrollLimit() const
+	{
+		int nMin = 0, nMax = 0;
+		::GetScrollRange(m_hWnd, SB_CTL, &nMin, &nMax);
+		SCROLLINFO info = { 0 };
+		info.cbSize = sizeof(SCROLLINFO);
+		info.fMask = SIF_PAGE;
+		if(::GetScrollInfo(m_hWnd, SB_CTL, &info))
+			nMax -= ((info.nPage - 1) > 0) ? (info.nPage - 1) : 0;
+
+		return nMax;
+	}
+
+#if (WINVER >= 0x0500)
+	BOOL GetScrollBarInfo(PSCROLLBARINFO pScrollBarInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+#if (_WIN32_WINNT >= 0x0501)
+		return (BOOL)::SendMessage(m_hWnd, SBM_GETSCROLLBARINFO, 0, (LPARAM)pScrollBarInfo);
+#else // !(_WIN32_WINNT >= 0x0501)
+		return ::GetScrollBarInfo(m_hWnd, OBJID_CLIENT, pScrollBarInfo);
+#endif // !(_WIN32_WINNT >= 0x0501)
+	}
+#endif // (WINVER >= 0x0500)
+
+// Operations
+	void ShowScrollBar(BOOL bShow = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::ShowScrollBar(m_hWnd, SB_CTL, bShow);
+	}
+
+	BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags);
+	}
+#endif // !_WIN32_WCE
+};
+
+typedef CScrollBarT<ATL::CWindow>   CScrollBar;
+
+
+// --- Windows Common Controls ---
+
+///////////////////////////////////////////////////////////////////////////////
+// CImageList
+
+class CImageList
+{
+public:
+	HIMAGELIST m_hImageList;
+
+// Constructor
+	CImageList(HIMAGELIST hImageList = NULL) : m_hImageList(hImageList)
+	{ }
+
+// Operators, etc.
+	CImageList& operator =(HIMAGELIST hImageList)
+	{
+		m_hImageList = hImageList;
+		return *this;
+	}
+
+	operator HIMAGELIST() const { return m_hImageList; }
+
+	void Attach(HIMAGELIST hImageList)
+	{
+		ATLASSERT(m_hImageList == NULL);
+		ATLASSERT(hImageList != NULL);
+		m_hImageList = hImageList;
+	}
+
+	HIMAGELIST Detach()
+	{
+		HIMAGELIST hImageList = m_hImageList;
+		m_hImageList = NULL;
+		return hImageList;
+	}
+
+	bool IsNull() const { return (m_hImageList == NULL); }
+
+// Attributes
+	int GetImageCount() const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_GetImageCount(m_hImageList);
+	}
+
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_GetBkColor(m_hImageList);
+	}
+
+	COLORREF SetBkColor(COLORREF cr)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetBkColor(m_hImageList, cr);
+	}
+
+	BOOL GetImageInfo(int nImage, IMAGEINFO* pImageInfo) const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_GetImageInfo(m_hImageList, nImage, pImageInfo);
+	}
+
+	HICON GetIcon(int nIndex, UINT uFlags = ILD_NORMAL) const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_GetIcon(m_hImageList, nIndex, uFlags);
+	}
+
+	BOOL GetIconSize(int& cx, int& cy) const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_GetIconSize(m_hImageList, &cx, &cy);
+	}
+
+	BOOL GetIconSize(SIZE& size) const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_GetIconSize(m_hImageList, (int*)&size.cx, (int*)&size.cy);
+	}
+
+	BOOL SetIconSize(int cx, int cy)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetIconSize(m_hImageList, cx, cy);
+	}
+
+	BOOL SetIconSize(SIZE size)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetIconSize(m_hImageList, size.cx, size.cy);
+	}
+
+	BOOL SetImageCount(UINT uNewCount)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetImageCount(m_hImageList, uNewCount);
+	}
+
+	BOOL SetOverlayImage(int nImage, int nOverlay)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetOverlayImage(m_hImageList, nImage, nOverlay);
+	}
+
+// Operations
+	BOOL Create(int cx, int cy, UINT nFlags, int nInitial, int nGrow)
+	{
+		ATLASSERT(m_hImageList == NULL);
+		m_hImageList = ImageList_Create(cx, cy, nFlags, nInitial, nGrow);
+		return (m_hImageList != NULL) ? TRUE : FALSE;
+	}
+
+	BOOL Create(ATL::_U_STRINGorID bitmap, int cx, int nGrow, COLORREF crMask)
+	{
+		ATLASSERT(m_hImageList == NULL);
+		m_hImageList = ImageList_LoadBitmap(ModuleHelper::GetResourceInstance(), bitmap.m_lpstr, cx, nGrow, crMask);
+		return (m_hImageList != NULL) ? TRUE : FALSE;
+	}
+
+	BOOL CreateFromImage(ATL::_U_STRINGorID image, int cx, int nGrow, COLORREF crMask, UINT uType, UINT uFlags = LR_DEFAULTCOLOR | LR_DEFAULTSIZE)
+	{
+		ATLASSERT(m_hImageList == NULL);
+		m_hImageList = ImageList_LoadImage(ModuleHelper::GetResourceInstance(), image.m_lpstr, cx, nGrow, crMask, uType, uFlags);
+		return (m_hImageList != NULL) ? TRUE : FALSE;
+	}
+
+	BOOL Merge(HIMAGELIST hImageList1, int nImage1, HIMAGELIST hImageList2, int nImage2, int dx, int dy)
+	{
+		ATLASSERT(m_hImageList == NULL);
+		m_hImageList = ImageList_Merge(hImageList1, nImage1, hImageList2, nImage2, dx, dy);
+		return (m_hImageList != NULL) ? TRUE : FALSE;
+	}
+
+#ifndef _WIN32_WCE
+#ifdef __IStream_INTERFACE_DEFINED__
+	BOOL CreateFromStream(LPSTREAM lpStream)
+	{
+		ATLASSERT(m_hImageList == NULL);
+		m_hImageList = ImageList_Read(lpStream);
+		return (m_hImageList != NULL) ? TRUE : FALSE;
+	}
+#endif // __IStream_INTERFACE_DEFINED__
+#endif // !_WIN32_WCE
+
+	BOOL Destroy()
+	{
+		if (m_hImageList == NULL)
+			return FALSE;
+		BOOL bRet = ImageList_Destroy(m_hImageList);
+		if(bRet)
+			m_hImageList = NULL;
+		return bRet;
+	}
+
+	int Add(HBITMAP hBitmap, HBITMAP hBitmapMask = NULL)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_Add(m_hImageList, hBitmap, hBitmapMask);
+	}
+
+	int Add(HBITMAP hBitmap, COLORREF crMask)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_AddMasked(m_hImageList, hBitmap, crMask);
+	}
+
+	BOOL Remove(int nImage)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_Remove(m_hImageList, nImage);
+	}
+
+	BOOL RemoveAll()
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_RemoveAll(m_hImageList);
+	}
+
+	BOOL Replace(int nImage, HBITMAP hBitmap, HBITMAP hBitmapMask)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_Replace(m_hImageList, nImage, hBitmap, hBitmapMask);
+	}
+
+	int AddIcon(HICON hIcon)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_AddIcon(m_hImageList, hIcon);
+	}
+
+	int ReplaceIcon(int nImage, HICON hIcon)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_ReplaceIcon(m_hImageList, nImage, hIcon);
+	}
+
+	HICON ExtractIcon(int nImage)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_ExtractIcon(NULL, m_hImageList, nImage);
+	}
+
+	BOOL Draw(HDC hDC, int nImage, int x, int y, UINT nStyle)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		ATLASSERT(hDC != NULL);
+		return ImageList_Draw(m_hImageList, nImage, hDC, x, y, nStyle);
+	}
+
+	BOOL Draw(HDC hDC, int nImage, POINT pt, UINT nStyle)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		ATLASSERT(hDC != NULL);
+		return ImageList_Draw(m_hImageList, nImage, hDC, pt.x, pt.y, nStyle);
+	}
+
+	BOOL DrawEx(int nImage, HDC hDC, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		ATLASSERT(hDC != NULL);
+		return ImageList_DrawEx(m_hImageList, nImage, hDC, x, y, dx, dy, rgbBk, rgbFg, fStyle);
+	}
+
+	BOOL DrawEx(int nImage, HDC hDC, RECT& rect, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		ATLASSERT(hDC != NULL);
+		return ImageList_DrawEx(m_hImageList, nImage, hDC, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, rgbBk, rgbFg, fStyle);
+	}
+
+	static BOOL DrawIndirect(IMAGELISTDRAWPARAMS* pimldp)
+	{
+		return ImageList_DrawIndirect(pimldp);
+	}
+
+	BOOL Copy(int nSrc, int nDst, UINT uFlags = ILCF_MOVE)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_Copy(m_hImageList, nDst, m_hImageList, nSrc, uFlags);
+	}
+
+#ifdef __IStream_INTERFACE_DEFINED__
+#ifndef _WIN32_WCE
+	static HIMAGELIST Read(LPSTREAM lpStream)
+	{
+		return ImageList_Read(lpStream);
+	}
+
+	BOOL Write(LPSTREAM lpStream)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_Write(m_hImageList, lpStream);
+	}
+#endif // !_WIN32_WCE
+
+#if (_WIN32_WINNT >= 0x0501)
+	static HRESULT ReadEx(DWORD dwFlags, LPSTREAM lpStream, REFIID riid, PVOID* ppv)
+	{
+		return ImageList_ReadEx(dwFlags, lpStream, riid, ppv);
+	}
+
+	HRESULT WriteEx(DWORD dwFlags, LPSTREAM lpStream)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_WriteEx(m_hImageList, dwFlags, lpStream);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+#endif // __IStream_INTERFACE_DEFINED__
+
+	// Drag operations
+	BOOL BeginDrag(int nImage, POINT ptHotSpot)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_BeginDrag(m_hImageList, nImage, ptHotSpot.x, ptHotSpot.y);
+	}
+
+	BOOL BeginDrag(int nImage, int xHotSpot, int yHotSpot)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_BeginDrag(m_hImageList, nImage, xHotSpot, yHotSpot);
+	}
+
+	static void EndDrag()
+	{
+		ImageList_EndDrag();
+	}
+
+	static BOOL DragMove(POINT pt)
+	{
+		return ImageList_DragMove(pt.x, pt.y);
+	}
+
+	static BOOL DragMove(int x, int y)
+	{
+		return ImageList_DragMove(x, y);
+	}
+
+	BOOL SetDragCursorImage(int nDrag, POINT ptHotSpot)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetDragCursorImage(m_hImageList, nDrag, ptHotSpot.x, ptHotSpot.y);
+	}
+
+	BOOL SetDragCursorImage(int nDrag, int xHotSpot, int yHotSpot)
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return ImageList_SetDragCursorImage(m_hImageList, nDrag, xHotSpot, yHotSpot);
+	}
+
+	static BOOL DragShowNolock(BOOL bShow = TRUE)
+	{
+		return ImageList_DragShowNolock(bShow);
+	}
+
+	static CImageList GetDragImage(LPPOINT lpPoint, LPPOINT lpPointHotSpot)
+	{
+		return CImageList(ImageList_GetDragImage(lpPoint, lpPointHotSpot));
+	}
+
+	static BOOL DragEnter(HWND hWnd, POINT point)
+	{
+		return ImageList_DragEnter(hWnd, point.x, point.y);
+	}
+
+	static BOOL DragEnter(HWND hWnd, int x, int y)
+	{
+		return ImageList_DragEnter(hWnd, x, y);
+	}
+
+	static BOOL DragLeave(HWND hWnd)
+	{
+		return ImageList_DragLeave(hWnd);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	CImageList Duplicate() const
+	{
+		ATLASSERT(m_hImageList != NULL);
+		return CImageList(ImageList_Duplicate(m_hImageList));
+	}
+
+	static CImageList Duplicate(HIMAGELIST hImageList)
+	{
+		ATLASSERT(hImageList != NULL);
+		return CImageList(ImageList_Duplicate(hImageList));
+	}
+#endif // (_WIN32_IE >= 0x0400)
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CToolTipCtrl
+
+#ifndef _WIN32_WCE
+
+class CToolInfo : public TOOLINFO
+{
+public:
+	CToolInfo(UINT nFlags, HWND hWnd, UINT nIDTool = 0, LPRECT lpRect = NULL, LPTSTR lpstrText = LPSTR_TEXTCALLBACK, LPARAM lUserParam = NULL)
+	{
+		Init(nFlags, hWnd, nIDTool, lpRect, lpstrText, lUserParam);
+	}
+
+	operator LPTOOLINFO() { return this; }
+
+	operator LPARAM() { return (LPARAM)this; }
+
+	void Init(UINT nFlags, HWND hWnd, UINT nIDTool = 0, LPRECT lpRect = NULL, LPTSTR lpstrText = LPSTR_TEXTCALLBACK, LPARAM lUserParam = NULL)
+	{
+		ATLASSERT(::IsWindow(hWnd));
+		memset(this, 0, sizeof(TOOLINFO));
+		cbSize = sizeof(TOOLINFO);
+		uFlags = nFlags;
+		if(nIDTool == 0)
+		{
+			hwnd = ::GetParent(hWnd);
+			uFlags |= TTF_IDISHWND;
+			uId = (UINT_PTR)hWnd;
+		}
+		else
+		{
+			hwnd = hWnd;
+			uId = nIDTool;
+		}
+		if(lpRect != NULL)
+			rect = *lpRect;
+		hinst = ModuleHelper::GetResourceInstance();
+		lpszText = lpstrText;
+		lParam = lUserParam;
+	}
+};
+
+template <class TBase>
+class CToolTipCtrlT : public TBase
+{
+public:
+// Constructors
+	CToolTipCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CToolTipCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return TOOLTIPS_CLASS;
+	}
+
+	void GetText(LPTOOLINFO lpToolInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_GETTEXT, 0, (LPARAM)&lpToolInfo);
+	}
+
+	void GetText(LPTSTR lpstrText, HWND hWnd, UINT nIDTool = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+		CToolInfo ti(0, hWnd, nIDTool, NULL, lpstrText);
+		::SendMessage(m_hWnd, TTM_GETTEXT, 0, ti);
+	}
+
+	BOOL GetToolInfo(LPTOOLINFO lpToolInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, (LPARAM)lpToolInfo);
+	}
+
+	BOOL GetToolInfo(HWND hWnd, UINT nIDTool, UINT* puFlags, LPRECT lpRect, LPTSTR lpstrText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+		ATLASSERT(puFlags != NULL);
+		ATLASSERT(lpRect != NULL);
+		CToolInfo ti(0, hWnd, nIDTool, NULL, lpstrText);
+		BOOL bRet = (BOOL)::SendMessage(m_hWnd, TTM_GETTOOLINFO, 0, ti);
+		if(bRet != FALSE)
+		{
+			*puFlags = ti.uFlags;
+			*lpRect = ti.rect;
+		}
+		return bRet;
+	}
+
+	void SetToolInfo(LPTOOLINFO lpToolInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_SETTOOLINFO, 0, (LPARAM)lpToolInfo);
+	}
+
+	void SetToolRect(LPTOOLINFO lpToolInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, (LPARAM)lpToolInfo);
+	}
+
+	void SetToolRect(HWND hWnd, UINT nIDTool, LPCRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+		ATLASSERT(nIDTool != 0);
+
+		CToolInfo ti(0, hWnd, nIDTool, (LPRECT)lpRect, NULL);
+		::SendMessage(m_hWnd, TTM_NEWTOOLRECT, 0, ti);
+	}
+
+	int GetToolCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TTM_GETTOOLCOUNT, 0, 0L);
+	}
+
+	int GetDelayTime(DWORD dwType) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TTM_GETDELAYTIME, dwType, 0L);
+	}
+
+	void SetDelayTime(DWORD dwType, int nTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_SETDELAYTIME, dwType, MAKELPARAM(nTime, 0));
+	}
+
+	void GetMargin(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_GETMARGIN, 0, (LPARAM)lpRect);
+	}
+
+	void SetMargin(LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_SETMARGIN, 0, (LPARAM)lpRect);
+	}
+
+	int GetMaxTipWidth() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TTM_GETMAXTIPWIDTH, 0, 0L);
+	}
+
+	int SetMaxTipWidth(int nWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TTM_SETMAXTIPWIDTH, 0, nWidth);
+	}
+
+	COLORREF GetTipBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPBKCOLOR, 0, 0L);
+	}
+
+	void SetTipBkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_SETTIPBKCOLOR, (WPARAM)clr, 0L);
+	}
+
+	COLORREF GetTipTextColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TTM_GETTIPTEXTCOLOR, 0, 0L);
+	}
+
+	void SetTipTextColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_SETTIPTEXTCOLOR, (WPARAM)clr, 0L);
+	}
+
+	BOOL GetCurrentTool(LPTOOLINFO lpToolInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_GETCURRENTTOOL, 0, (LPARAM)lpToolInfo);
+	}
+
+#if (_WIN32_IE >= 0x0500)
+	SIZE GetBubbleSize(LPTOOLINFO lpToolInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TTM_GETBUBBLESIZE, 0, (LPARAM)lpToolInfo);
+		SIZE size = { GET_X_LPARAM(dwRet), GET_Y_LPARAM(dwRet) };
+		return size;
+	}
+
+	BOOL SetTitle(UINT uIcon, LPCTSTR lpstrTitle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_SETTITLE, uIcon, (LPARAM)lpstrTitle);
+	}
+#endif // (_WIN32_IE >= 0x0500)
+
+#if (_WIN32_WINNT >= 0x0501)
+	void GetTitle(PTTGETTITLE pTTGetTitle) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_GETTITLE, 0, (LPARAM)pTTGetTitle);
+	}
+
+	void SetWindowTheme(LPCWSTR lpstrTheme)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_SETWINDOWTHEME, 0, (LPARAM)lpstrTheme);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+// Operations
+	void Activate(BOOL bActivate)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_ACTIVATE, bActivate, 0L);
+	}
+
+	BOOL AddTool(LPTOOLINFO lpToolInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, (LPARAM)lpToolInfo);
+	}
+
+	BOOL AddTool(HWND hWnd, ATL::_U_STRINGorID text = LPSTR_TEXTCALLBACK, LPCRECT lpRectTool = NULL, UINT nIDTool = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+		// the toolrect and toolid must both be zero or both valid
+		ATLASSERT((lpRectTool != NULL && nIDTool != 0) || (lpRectTool == NULL && nIDTool == 0));
+
+		CToolInfo ti(0, hWnd, nIDTool, (LPRECT)lpRectTool, (LPTSTR)text.m_lpstr);
+		return (BOOL)::SendMessage(m_hWnd, TTM_ADDTOOL, 0, ti);
+	}
+
+	void DelTool(LPTOOLINFO lpToolInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_DELTOOL, 0, (LPARAM)lpToolInfo);
+	}
+
+	void DelTool(HWND hWnd, UINT nIDTool = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+
+		CToolInfo ti(0, hWnd, nIDTool, NULL, NULL);
+		::SendMessage(m_hWnd, TTM_DELTOOL, 0, ti);
+	}
+
+	BOOL HitTest(LPTTHITTESTINFO lpHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)lpHitTestInfo);
+	}
+
+	BOOL HitTest(HWND hWnd, POINT pt, LPTOOLINFO lpToolInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+		ATLASSERT(lpToolInfo != NULL);
+
+		TTHITTESTINFO hti = { 0 };
+		hti.ti.cbSize = sizeof(TOOLINFO);
+		hti.hwnd = hWnd;
+		hti.pt.x = pt.x;
+		hti.pt.y = pt.y;
+		if((BOOL)::SendMessage(m_hWnd, TTM_HITTEST, 0, (LPARAM)&hti) != FALSE)
+		{
+			*lpToolInfo = hti.ti;
+			return TRUE;
+		}
+		return FALSE;
+	}
+
+	void RelayEvent(LPMSG lpMsg)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_RELAYEVENT, 0, (LPARAM)lpMsg);
+	}
+
+	void UpdateTipText(LPTOOLINFO lpToolInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, (LPARAM)lpToolInfo);
+	}
+
+	void UpdateTipText(ATL::_U_STRINGorID text, HWND hWnd, UINT nIDTool = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hWnd != NULL);
+
+		CToolInfo ti(0, hWnd, nIDTool, NULL, (LPTSTR)text.m_lpstr);
+		::SendMessage(m_hWnd, TTM_UPDATETIPTEXT, 0, ti);
+	}
+
+	BOOL EnumTools(UINT nTool, LPTOOLINFO lpToolInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_ENUMTOOLS, nTool, (LPARAM)lpToolInfo);
+	}
+
+	void Pop()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_POP, 0, 0L);
+	}
+
+	void TrackActivate(LPTOOLINFO lpToolInfo, BOOL bActivate)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_TRACKACTIVATE, bActivate, (LPARAM)lpToolInfo);
+	}
+
+	void TrackPosition(int xPos, int yPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_TRACKPOSITION, 0, MAKELPARAM(xPos, yPos));
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	void Update()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_UPDATE, 0, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500)
+	BOOL AdjustRect(LPRECT lpRect, BOOL bLarger /*= TRUE*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TTM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
+	}
+#endif // (_WIN32_IE >= 0x0500)
+
+#if (_WIN32_WINNT >= 0x0501)
+	void Popup()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TTM_POPUP, 0, 0L);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+};
+
+typedef CToolTipCtrlT<ATL::CWindow>   CToolTipCtrl;
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CHeaderCtrl
+
+template <class TBase>
+class CHeaderCtrlT : public TBase
+{
+public:
+// Constructors
+	CHeaderCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CHeaderCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_HEADER;
+	}
+
+	int GetItemCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_GETITEMCOUNT, 0, 0L);
+	}
+
+	BOOL GetItem(int nIndex, LPHDITEM pHeaderItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEM, nIndex, (LPARAM)pHeaderItem);
+	}
+
+	BOOL SetItem(int nIndex, LPHDITEM pHeaderItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_SETITEM, nIndex, (LPARAM)pHeaderItem);
+	}
+
+	CImageList GetImageList() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_GETIMAGELIST, 0, 0L));
+	}
+
+	CImageList SetImageList(HIMAGELIST hImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_SETIMAGELIST, 0, (LPARAM)hImageList));
+	}
+
+	BOOL GetOrderArray(int nSize, int* lpnArray) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_GETORDERARRAY, nSize, (LPARAM)lpnArray);
+	}
+
+	BOOL SetOrderArray(int nSize, int* lpnArray)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_SETORDERARRAY, nSize, (LPARAM)lpnArray);
+	}
+
+	BOOL GetItemRect(int nIndex, LPRECT lpItemRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMRECT, nIndex, (LPARAM)lpItemRect);
+	}
+
+	int SetHotDivider(BOOL bPos, DWORD dwInputValue)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_SETHOTDIVIDER, bPos, dwInputValue);
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	int GetBitmapMargin() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_GETBITMAPMARGIN, 0, 0L);
+	}
+
+	int SetBitmapMargin(int nWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_SETBITMAPMARGIN, nWidth, 0L);
+	}
+
+	int SetFilterChangeTimeout(DWORD dwTimeOut)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_SETFILTERCHANGETIMEOUT, 0, dwTimeOut);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0600)
+	BOOL GetItemDropDownRect(int nIndex, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_GETITEMDROPDOWNRECT, nIndex, (LPARAM)lpRect);
+	}
+
+	BOOL GetOverflowRect(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_GETOVERFLOWRECT, 0, (LPARAM)lpRect);
+	}
+
+	int GetFocusedItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_GETFOCUSEDITEM, 0, 0L);
+	}
+
+	BOOL SetFocusedItem(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_SETFOCUSEDITEM, 0, nIndex);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+// Operations
+	int InsertItem(int nIndex, LPHDITEM phdi)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_INSERTITEM, nIndex, (LPARAM)phdi);
+	}
+
+	int AddItem(LPHDITEM phdi)
+	{
+		return InsertItem(GetItemCount(), phdi);
+	}
+
+	BOOL DeleteItem(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_DELETEITEM, nIndex, 0L);
+	}
+
+	BOOL Layout(HD_LAYOUT* pHeaderLayout)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, HDM_LAYOUT, 0, (LPARAM)pHeaderLayout);
+	}
+
+	int HitTest(LPHDHITTESTINFO lpHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_HITTEST, 0, (LPARAM)lpHitTestInfo);
+	}
+
+	int OrderToIndex(int nOrder)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_ORDERTOINDEX, nOrder, 0L);
+	}
+
+	CImageList CreateDragImage(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, HDM_CREATEDRAGIMAGE, nIndex, 0L));
+	}
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	int EditFilter(int nColumn, BOOL bDiscardChanges)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_EDITFILTER, nColumn, MAKELPARAM(bDiscardChanges, 0));
+	}
+
+	int ClearFilter(int nColumn)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_CLEARFILTER, nColumn, 0L);
+	}
+
+	int ClearAllFilters()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, HDM_CLEARFILTER, (WPARAM)-1, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+};
+
+typedef CHeaderCtrlT<ATL::CWindow>   CHeaderCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CListViewCtrl
+
+template <class TBase>
+class CListViewCtrlT : public TBase
+{
+public:
+// Constructors
+	CListViewCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CListViewCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_LISTVIEW;
+	}
+
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_GETBKCOLOR, 0, 0L);
+	}
+
+	BOOL SetBkColor(COLORREF cr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETBKCOLOR, 0, cr);
+	}
+
+	CImageList GetImageList(int nImageListType) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_GETIMAGELIST, nImageListType, 0L));
+	}
+
+	CImageList SetImageList(HIMAGELIST hImageList, int nImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, nImageList, (LPARAM)hImageList));
+	}
+
+	int GetItemCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETITEMCOUNT, 0, 0L);
+	}
+
+	BOOL SetItemCount(int nItems)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, 0L);
+	}
+
+	BOOL GetItem(LPLVITEM pItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
+	}
+
+	BOOL SetItem(const LVITEM* pItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)pItem);
+	}
+
+	BOOL SetItem(int nItem, int nSubItem, UINT nMask, LPCTSTR lpszItem,
+		int nImage, UINT nState, UINT nStateMask, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvi = { 0 };
+		lvi.mask = nMask;
+		lvi.iItem = nItem;
+		lvi.iSubItem = nSubItem;
+		lvi.stateMask = nStateMask;
+		lvi.state = nState;
+		lvi.pszText = (LPTSTR) lpszItem;
+		lvi.iImage = nImage;
+		lvi.lParam = lParam;
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEM, 0, (LPARAM)&lvi);
+	}
+
+	UINT GetItemState(int nItem, UINT nMask) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, LVM_GETITEMSTATE, nItem, nMask);
+	}
+
+	BOOL SetItemState(int nItem, UINT nState, UINT nStateMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvi = { 0 };
+		lvi.state = nState;
+		lvi.stateMask = nStateMask;
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)&lvi);
+	}
+
+	BOOL SetItemState(int nItem, LPLVITEM pItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMSTATE, nItem, (LPARAM)pItem);
+	}
+
+#ifndef _ATL_NO_COM
+	BOOL GetItemText(int nItem, int nSubItem, BSTR& bstrText) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrText == NULL);
+		LVITEM lvi = { 0 };
+		lvi.iSubItem = nSubItem;
+
+		LPTSTR lpstrText = NULL;
+		int nRes = 0;
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			ATLTRY(lpstrText = new TCHAR[nLen]);
+			if(lpstrText == NULL)
+				break;
+			lpstrText[0] = NULL;
+			lvi.cchTextMax = nLen;
+			lvi.pszText = lpstrText;
+			nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
+			if(nRes < nLen - 1)
+				break;
+			delete [] lpstrText;
+			lpstrText = NULL;
+		}
+
+		if(lpstrText != NULL)
+		{
+			if(nRes != 0)
+				bstrText = ::SysAllocString(T2OLE(lpstrText));
+			delete [] lpstrText;
+		}
+
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetItemText(int nItem, int nSubItem, _CSTRING_NS::CString& strText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvi = { 0 };
+		lvi.iSubItem = nSubItem;
+
+		strText.Empty();
+		int nRes = 0;
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			lvi.cchTextMax = nLen;
+			lvi.pszText = strText.GetBufferSetLength(nLen);
+			if(lvi.pszText == NULL)
+			{
+				nRes = 0;
+				break;
+			}
+			nRes  = (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
+			if(nRes < nLen - 1)
+				break;
+		}
+		strText.ReleaseBuffer();
+		return nRes;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	int GetItemText(int nItem, int nSubItem, LPTSTR lpszText, int nLen) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvi = { 0 };
+		lvi.iSubItem = nSubItem;
+		lvi.cchTextMax = nLen;
+		lvi.pszText = lpszText;
+		return (int)::SendMessage(m_hWnd, LVM_GETITEMTEXT, (WPARAM)nItem, (LPARAM)&lvi);
+	}
+
+	BOOL SetItemText(int nItem, int nSubItem, LPCTSTR lpszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(nItem, nSubItem, LVIF_TEXT, lpszText, 0, 0, 0, 0);
+	}
+
+	DWORD_PTR GetItemData(int nItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvi = { 0 };
+		lvi.iItem = nItem;
+		lvi.mask = LVIF_PARAM;
+		BOOL bRet = (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)&lvi);
+		return (DWORD_PTR)(bRet ? lvi.lParam : NULL);
+	}
+
+	BOOL SetItemData(int nItem, DWORD_PTR dwData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(nItem, 0, LVIF_PARAM, NULL, 0, 0, 0, (LPARAM)dwData);
+	}
+
+	UINT GetCallbackMask() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, LVM_GETCALLBACKMASK, 0, 0L);
+	}
+
+	BOOL SetCallbackMask(UINT nMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETCALLBACKMASK, nMask, 0L);
+	}
+
+	BOOL GetItemPosition(int nItem, LPPOINT lpPoint) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMPOSITION, nItem, (LPARAM)lpPoint);
+	}
+
+	BOOL SetItemPosition(int nItem, POINT pt)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(((GetStyle() & LVS_TYPEMASK) == LVS_ICON) || ((GetStyle() & LVS_TYPEMASK) == LVS_SMALLICON));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
+	}
+
+	BOOL SetItemPosition(int nItem, int x, int y)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(((GetStyle() & LVS_TYPEMASK) == LVS_ICON) || ((GetStyle() & LVS_TYPEMASK) == LVS_SMALLICON));
+		POINT pt = { x, y };
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMPOSITION32, nItem, (LPARAM)&pt);
+	}
+
+	int GetStringWidth(LPCTSTR lpsz) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETSTRINGWIDTH, 0, (LPARAM)lpsz);
+	}
+
+	CEdit GetEditControl() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CEdit((HWND)::SendMessage(m_hWnd, LVM_GETEDITCONTROL, 0, 0L));
+	}
+
+	BOOL GetColumn(int nCol, LVCOLUMN* pColumn) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMN, nCol, (LPARAM)pColumn);
+	}
+
+	BOOL SetColumn(int nCol, const LVCOLUMN* pColumn)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMN, nCol, (LPARAM)pColumn);
+	}
+
+	int GetColumnWidth(int nCol) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETCOLUMNWIDTH, nCol, 0L);
+	}
+
+	BOOL SetColumnWidth(int nCol, int cx)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNWIDTH, nCol, MAKELPARAM(cx, 0));
+	}
+
+	BOOL GetViewRect(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETVIEWRECT, 0, (LPARAM)lpRect);
+	}
+
+	COLORREF GetTextColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTCOLOR, 0, 0L);
+	}
+
+	BOOL SetTextColor(COLORREF cr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTCOLOR, 0, cr);
+	}
+
+	COLORREF GetTextBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_GETTEXTBKCOLOR, 0, 0L);
+	}
+
+	BOOL SetTextBkColor(COLORREF cr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETTEXTBKCOLOR, 0, cr);
+	}
+
+	int GetTopIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETTOPINDEX, 0, 0L);
+	}
+
+	int GetCountPerPage() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETCOUNTPERPAGE, 0, 0L);
+	}
+
+	BOOL GetOrigin(LPPOINT lpPoint) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETORIGIN, 0, (LPARAM)lpPoint);
+	}
+
+	UINT GetSelectedCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, LVM_GETSELECTEDCOUNT, 0, 0L);
+	}
+
+	BOOL GetItemRect(int nItem, LPRECT lpRect, UINT nCode) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		lpRect->left = nCode;
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMRECT, (WPARAM)nItem, (LPARAM)lpRect);
+	}
+
+#ifndef _WIN32_WCE
+	HCURSOR GetHotCursor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HCURSOR)::SendMessage(m_hWnd, LVM_GETHOTCURSOR, 0, 0L);
+	}
+
+	HCURSOR SetHotCursor(HCURSOR hHotCursor)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HCURSOR)::SendMessage(m_hWnd, LVM_SETHOTCURSOR, 0, (LPARAM)hHotCursor);
+	}
+
+	int GetHotItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETHOTITEM, 0, 0L);
+	}
+
+	int SetHotItem(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SETHOTITEM, nIndex, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL GetColumnOrderArray(int nCount, int* lpnArray) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
+	}
+
+	BOOL SetColumnOrderArray(int nCount, int* lpnArray)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETCOLUMNORDERARRAY, nCount, (LPARAM)lpnArray);
+	}
+
+	CHeaderCtrl GetHeader() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CHeaderCtrl((HWND)::SendMessage(m_hWnd, LVM_GETHEADER, 0, 0L));
+	}
+
+	BOOL GetSubItemRect(int nItem, int nSubItem, int nFlag, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LVS_TYPEMASK) == LVS_REPORT);
+		ATLASSERT(lpRect != NULL);
+		lpRect->top = nSubItem;
+		lpRect->left = nFlag;
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETSUBITEMRECT, nItem, (LPARAM)lpRect);
+	}
+
+	DWORD SetIconSpacing(int cx, int cy)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LVS_TYPEMASK) == LVS_ICON);
+		return (DWORD)::SendMessage(m_hWnd, LVM_SETICONSPACING, 0, MAKELPARAM(cx, cy));
+	}
+
+	int GetISearchString(LPTSTR lpstr) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETISEARCHSTRING, 0, (LPARAM)lpstr);
+	}
+
+	void GetItemSpacing(SIZE& sizeSpacing, BOOL bSmallIconView = FALSE) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, LVM_GETITEMSPACING, bSmallIconView, 0L);
+		sizeSpacing.cx = GET_X_LPARAM(dwRet);
+		sizeSpacing.cy = GET_Y_LPARAM(dwRet);
+	}
+
+#if (_WIN32_WCE >= 410)
+	void SetItemSpacing(INT cySpacing)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ListView_SetItemSpacing(m_hWnd, cySpacing);
+	}
+#endif // (_WIN32_WCE >= 410)
+
+	// single-selection only
+	int GetSelectedIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);
+		return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, (WPARAM)-1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
+	}
+
+	BOOL GetSelectedItem(LPLVITEM pItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & LVS_SINGLESEL) != 0);
+		ATLASSERT(pItem != NULL);
+		pItem->iItem = (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, (WPARAM)-1, MAKELPARAM(LVNI_ALL | LVNI_SELECTED, 0));
+		if(pItem->iItem == -1)
+			return FALSE;
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEM, 0, (LPARAM)pItem);
+	}
+
+	// extended list view styles
+	DWORD GetExtendedListViewStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, LVM_GETEXTENDEDLISTVIEWSTYLE, 0, 0L);
+	}
+
+	// dwExMask = 0 means all styles
+	DWORD SetExtendedListViewStyle(DWORD dwExStyle, DWORD dwExMask = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, LVM_SETEXTENDEDLISTVIEWSTYLE, dwExMask, dwExStyle);
+	}
+
+	// checkboxes only
+	BOOL GetCheckState(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetExtendedListViewStyle() & LVS_EX_CHECKBOXES) != 0);
+		UINT uRet = GetItemState(nIndex, LVIS_STATEIMAGEMASK);
+		return (uRet >> 12) - 1;
+	}
+
+	BOOL SetCheckState(int nItem, BOOL bCheck)
+	{
+		int nCheck = bCheck ? 2 : 1;   // one based index
+		return SetItemState(nItem, INDEXTOSTATEIMAGEMASK(nCheck), LVIS_STATEIMAGEMASK);
+	}
+
+	// view type
+	DWORD GetViewType() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (GetStyle() & LVS_TYPEMASK);
+	}
+
+	DWORD SetViewType(DWORD dwType)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(dwType == LVS_ICON || dwType == LVS_SMALLICON || dwType == LVS_LIST || dwType == LVS_REPORT);
+		DWORD dwOldType = GetViewType();
+		if(dwType != dwOldType)
+			ModifyStyle(LVS_TYPEMASK, (dwType & LVS_TYPEMASK));
+		return dwOldType;
+	}
+
+#if (_WIN32_IE >= 0x0400)
+#ifndef _WIN32_WCE
+	BOOL GetBkImage(LPLVBKIMAGE plvbki) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETBKIMAGE, 0, (LPARAM)plvbki);
+	}
+
+	BOOL SetBkImage(LPLVBKIMAGE plvbki)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETBKIMAGE, 0, (LPARAM)plvbki);
+	}
+#endif // !_WIN32_WCE
+
+	int GetSelectionMark() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETSELECTIONMARK, 0, 0L);
+	}
+
+	int SetSelectionMark(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SETSELECTIONMARK, 0, nIndex);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetWorkAreas(int nWorkAreas, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
+	}
+
+	BOOL SetWorkAreas(int nWorkAreas, LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETWORKAREAS, nWorkAreas, (LPARAM)lpRect);
+	}
+
+	DWORD GetHoverTime() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE)) != 0);
+		return (DWORD)::SendMessage(m_hWnd, LVM_GETHOVERTIME, 0, 0L);
+	}
+
+	DWORD SetHoverTime(DWORD dwHoverTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetExtendedListViewStyle() & (LVS_EX_TRACKSELECT | LVS_EX_ONECLICKACTIVATE | LVS_EX_TWOCLICKACTIVATE)) != 0);
+		return (DWORD)::SendMessage(m_hWnd, LVM_SETHOVERTIME, 0, dwHoverTime);
+	}
+
+	BOOL GetNumberOfWorkAreas(int* pnWorkAreas) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETNUMBEROFWORKAREAS, 0, (LPARAM)pnWorkAreas);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL SetItemCountEx(int nItems, DWORD dwFlags)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(((GetStyle() & LVS_OWNERDATA) != 0) && (((GetStyle() & LVS_TYPEMASK) == LVS_REPORT) || ((GetStyle() & LVS_TYPEMASK) == LVS_LIST)));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMCOUNT, nItems, dwFlags);
+	}
+
+#ifndef _WIN32_WCE
+	CToolTipCtrl GetToolTips() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, LVM_GETTOOLTIPS, 0, 0L));
+	}
+
+	CToolTipCtrl SetToolTips(HWND hWndTT)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, LVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L));
+	}
+
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_WINNT >= 0x0501)
+	int GetSelectedColumn() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETSELECTEDCOLUMN, 0, 0L);
+	}
+
+	void SetSelectedColumn(int nColumn)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_SETSELECTEDCOLUMN, nColumn, 0L);
+	}
+
+	DWORD GetView() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, LVM_GETVIEW, 0, 0L);
+	}
+
+	int SetView(DWORD dwView)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SETVIEW, dwView, 0L);
+	}
+
+	BOOL IsGroupViewEnabled() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_ISGROUPVIEWENABLED, 0, 0L);
+	}
+
+	int GetGroupInfo(int nGroupID, PLVGROUP pGroup) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETGROUPINFO, nGroupID, (LPARAM)pGroup);
+	}
+
+	int SetGroupInfo(int nGroupID, PLVGROUP pGroup)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SETGROUPINFO, nGroupID, (LPARAM)pGroup);
+	}
+
+	void GetGroupMetrics(PLVGROUPMETRICS pGroupMetrics) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_GETGROUPMETRICS, 0, (LPARAM)pGroupMetrics);
+	}
+
+	void SetGroupMetrics(PLVGROUPMETRICS pGroupMetrics)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_SETGROUPMETRICS, 0, (LPARAM)pGroupMetrics);
+	}
+
+	void GetTileViewInfo(PLVTILEVIEWINFO pTileViewInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_GETTILEVIEWINFO, 0, (LPARAM)pTileViewInfo);
+	}
+
+	BOOL SetTileViewInfo(PLVTILEVIEWINFO pTileViewInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETTILEVIEWINFO, 0, (LPARAM)pTileViewInfo);
+	}
+
+	void GetTileInfo(PLVTILEINFO pTileInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_GETTILEINFO, 0, (LPARAM)pTileInfo);
+	}
+
+	BOOL SetTileInfo(PLVTILEINFO pTileInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETTILEINFO, 0, (LPARAM)pTileInfo);
+	}
+
+	BOOL GetInsertMark(LPLVINSERTMARK pInsertMark) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETINSERTMARK, 0, (LPARAM)pInsertMark);
+	}
+
+	BOOL SetInsertMark(LPLVINSERTMARK pInsertMark)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETINSERTMARK, 0, (LPARAM)pInsertMark);
+	}
+
+	int GetInsertMarkRect(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETINSERTMARKRECT, 0, (LPARAM)lpRect);
+	}
+
+	COLORREF GetInsertMarkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_GETINSERTMARKCOLOR, 0, 0L);
+	}
+
+	COLORREF SetInsertMarkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_SETINSERTMARKCOLOR, 0, clr);
+	}
+
+	COLORREF GetOutlineColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_GETOUTLINECOLOR, 0, 0L);
+	}
+
+	COLORREF SetOutlineColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, LVM_SETOUTLINECOLOR, 0, clr);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_WINNT >= 0x0600)
+	int GetGroupCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETGROUPCOUNT, 0, 0L);
+	}
+
+	BOOL GetGroupInfoByIndex(int nIndex, PLVGROUP pGroup) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETGROUPINFOBYINDEX, nIndex, (LPARAM)pGroup);
+	}
+
+	BOOL GetGroupRect(int nGroupID, int nType, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpRect != NULL);
+		if(lpRect != NULL)
+			lpRect->top = nType;
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETGROUPRECT, nGroupID, (LPARAM)lpRect);
+	}
+
+	UINT GetGroupState(int nGroupID, UINT uMask) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, LVM_GETGROUPSTATE, nGroupID, (LPARAM)uMask);
+	}
+
+	int GetFocusedGroup() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETFOCUSEDGROUP, 0, 0L);
+	}
+
+	BOOL GetEmptyText(LPWSTR lpstrText, int cchText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETEMPTYTEXT, cchText, (LPARAM)lpstrText);
+	}
+
+	BOOL GetFooterRect(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETFOOTERRECT, 0, (LPARAM)lpRect);
+	}
+
+	BOOL GetFooterInfo(LPLVFOOTERINFO lpFooterInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETFOOTERINFO, 0, (LPARAM)lpFooterInfo);
+	}
+
+	BOOL GetFooterItemRect(int nItem, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETFOOTERITEMRECT, nItem, (LPARAM)lpRect);
+	}
+
+	BOOL GetFooterItem(int nItem, LPLVFOOTERITEM lpFooterItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETFOOTERITEM, nItem, (LPARAM)lpFooterItem);
+	}
+
+	BOOL GetItemIndexRect(PLVITEMINDEX pItemIndex, int nSubItem, int nType, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pItemIndex != NULL);
+		ATLASSERT(lpRect != NULL);
+		if(lpRect != NULL)
+		{
+			lpRect->top = nSubItem;
+			lpRect->left = nType;
+		}
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETITEMINDEXRECT, (WPARAM)pItemIndex, (LPARAM)lpRect);
+	}
+
+	BOOL SetItemIndexState(PLVITEMINDEX pItemIndex, UINT uState, UINT dwMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvi = { 0 };
+		lvi.state = uState;
+		lvi.stateMask = dwMask;
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETITEMINDEXSTATE, (WPARAM)pItemIndex, (LPARAM)&lvi);
+	}
+
+	BOOL GetNextItemIndex(PLVITEMINDEX pItemIndex, WORD wFlags) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_GETNEXTITEMINDEX, (WPARAM)pItemIndex, MAKELPARAM(wFlags, 0));
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+// Operations
+	int InsertColumn(int nCol, const LVCOLUMN* pColumn)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_INSERTCOLUMN, nCol, (LPARAM)pColumn);
+	}
+
+	int InsertColumn(int nCol, LPCTSTR lpszColumnHeading, int nFormat = LVCFMT_LEFT, 
+			int nWidth = -1, int nSubItem = -1, int iImage = -1, int iOrder = -1)
+	{
+		LVCOLUMN column = { 0 };
+		column.mask = LVCF_TEXT|LVCF_FMT;
+		column.pszText = (LPTSTR)lpszColumnHeading;
+		column.fmt = nFormat;
+		if (nWidth != -1)
+		{
+			column.mask |= LVCF_WIDTH;
+			column.cx = nWidth;
+		}
+		if (nSubItem != -1)
+		{
+			column.mask |= LVCF_SUBITEM;
+			column.iSubItem = nSubItem;
+		}
+		if (iImage != -1)
+		{
+			column.mask |= LVCF_IMAGE;
+			column.iImage = iImage;
+		}
+		if (iOrder != -1)
+		{
+			column.mask |= LVCF_ORDER;
+			column.iOrder = iOrder;
+		}
+		return InsertColumn(nCol, &column);
+	}
+
+	BOOL DeleteColumn(int nCol)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_DELETECOLUMN, nCol, 0L);
+	}
+
+	int InsertItem(UINT nMask, int nItem, LPCTSTR lpszItem, UINT nState, UINT nStateMask, int nImage, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM item = { 0 };
+		item.mask = nMask;
+		item.iItem = nItem;
+		item.iSubItem = 0;
+		item.pszText = (LPTSTR)lpszItem;
+		item.state = nState;
+		item.stateMask = nStateMask;
+		item.iImage = nImage;
+		item.lParam = lParam;
+		return InsertItem(&item);
+	}
+
+	int InsertItem(const LVITEM* pItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_INSERTITEM, 0, (LPARAM)pItem);
+	}
+
+	int InsertItem(int nItem, LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return InsertItem(LVIF_TEXT, nItem, lpszItem, 0, 0, 0, 0);
+	}
+
+	int InsertItem(int nItem, LPCTSTR lpszItem, int nImage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return InsertItem(LVIF_TEXT|LVIF_IMAGE, nItem, lpszItem, 0, 0, nImage, 0);
+	}
+
+	int GetNextItem(int nItem, int nFlags) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_GETNEXTITEM, nItem, MAKELPARAM(nFlags, 0));
+	}
+
+	BOOL DeleteItem(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_DELETEITEM, nItem, 0L);
+	}
+
+	BOOL DeleteAllItems()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_DELETEALLITEMS, 0, 0L);
+	}
+
+	int FindItem(LVFINDINFO* pFindInfo, int nStart) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_FINDITEM, nStart, (LPARAM)pFindInfo);
+	}
+
+	int HitTest(LVHITTESTINFO* pHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)pHitTestInfo);
+	}
+
+	int HitTest(POINT pt, UINT* pFlags) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVHITTESTINFO hti = { 0 };
+		hti.pt = pt;
+		int nRes = (int)::SendMessage(m_hWnd, LVM_HITTEST, 0, (LPARAM)&hti);
+		if (pFlags != NULL)
+			*pFlags = hti.flags;
+		return nRes;
+	}
+
+	BOOL EnsureVisible(int nItem, BOOL bPartialOK)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_ENSUREVISIBLE, nItem, MAKELPARAM(bPartialOK, 0));
+	}
+
+	BOOL Scroll(SIZE size)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SCROLL, size.cx, size.cy);
+	}
+
+	BOOL RedrawItems(int nFirst, int nLast)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_REDRAWITEMS, nFirst, nLast);
+	}
+
+	BOOL Arrange(UINT nCode)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_ARRANGE, nCode, 0L);
+	}
+
+	CEdit EditLabel(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CEdit((HWND)::SendMessage(m_hWnd, LVM_EDITLABEL, nItem, 0L));
+	}
+
+	BOOL Update(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_UPDATE, nItem, 0L);
+	}
+
+	BOOL SortItems(PFNLVCOMPARE pfnCompare, LPARAM lParamSort)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SORTITEMS, (WPARAM)lParamSort, (LPARAM)pfnCompare);
+	}
+
+	CImageList RemoveImageList(int nImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_SETIMAGELIST, (WPARAM)nImageList, NULL));
+	}
+
+	CImageList CreateDragImage(int nItem, LPPOINT lpPoint)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, LVM_CREATEDRAGIMAGE, nItem, (LPARAM)lpPoint));
+	}
+
+	DWORD ApproximateViewRect(int cx = -1, int cy = -1, int nCount = -1)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, LVM_APPROXIMATEVIEWRECT, nCount, MAKELPARAM(cx, cy));
+	}
+
+	int SubItemHitTest(LPLVHITTESTINFO lpInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, 0, (LPARAM)lpInfo);
+	}
+
+	int AddColumn(LPCTSTR strItem, int nItem, int nSubItem = -1,
+			int nMask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM,
+			int nFmt = LVCFMT_LEFT)
+	{
+		const int cxOffset = 15;
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVCOLUMN lvc = { 0 };
+		lvc.mask = nMask;
+		lvc.fmt = nFmt;
+		lvc.pszText = (LPTSTR)strItem;
+		lvc.cx = GetStringWidth(lvc.pszText) + cxOffset;
+		if(nMask & LVCF_SUBITEM)
+			lvc.iSubItem = (nSubItem != -1) ? nSubItem : nItem;
+		return InsertColumn(nItem, &lvc);
+	}
+
+	int AddItem(int nItem, int nSubItem, LPCTSTR strItem, int nImageIndex = -1)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVITEM lvItem = { 0 };
+		lvItem.mask = LVIF_TEXT;
+		lvItem.iItem = nItem;
+		lvItem.iSubItem = nSubItem;
+		lvItem.pszText = (LPTSTR)strItem;
+		if(nImageIndex != -1)
+		{
+			lvItem.mask |= LVIF_IMAGE;
+			lvItem.iImage = nImageIndex;
+		}
+		if(nSubItem == 0)
+			return InsertItem(&lvItem);
+		return SetItem(&lvItem) ? nItem : -1;
+	}
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	BOOL SortItemsEx(PFNLVCOMPARE pfnCompare, LPARAM lParamSort)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SORTITEMSEX, (WPARAM)lParamSort, (LPARAM)pfnCompare);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0501)
+	int InsertGroup(int nItem, PLVGROUP pGroup)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_INSERTGROUP, nItem, (LPARAM)pGroup);
+	}
+
+	int AddGroup(PLVGROUP pGroup)
+	{
+		return InsertGroup(-1, pGroup);
+	}
+
+	int RemoveGroup(int nGroupID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_REMOVEGROUP, nGroupID, 0L);
+	}
+
+	void MoveGroup(int nGroupID, int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_MOVEGROUP, nGroupID, nItem);
+	}
+
+	void MoveItemToGroup(int nItem, int nGroupID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_MOVEITEMTOGROUP, nItem, nGroupID);
+	}
+
+	int EnableGroupView(BOOL bEnable)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_ENABLEGROUPVIEW, bEnable, 0L);
+	}
+
+	int SortGroups(PFNLVGROUPCOMPARE pCompareFunc, LPVOID lpVoid = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SORTGROUPS, (WPARAM)pCompareFunc, (LPARAM)lpVoid);
+	}
+
+	void InsertGroupSorted(PLVINSERTGROUPSORTED pInsertGroupSorted)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_INSERTGROUPSORTED, (WPARAM)pInsertGroupSorted, 0L);
+	}
+
+	void RemoveAllGroups()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_REMOVEALLGROUPS, 0, 0L);
+	}
+
+	BOOL HasGroup(int nGroupID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_HASGROUP, nGroupID, 0L);
+	}
+
+	BOOL InsertMarkHitTest(LPPOINT lpPoint, LPLVINSERTMARK pInsertMark) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_INSERTMARKHITTEST, (WPARAM)lpPoint, (LPARAM)pInsertMark);
+	}
+
+	BOOL SetInfoTip(PLVSETINFOTIP pSetInfoTip)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LVM_SETINFOTIP, 0, (LPARAM)pSetInfoTip);
+	}
+
+	void CancelEditLabel()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, LVM_CANCELEDITLABEL, 0, 0L);
+	}
+
+	UINT MapIndexToID(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, LVM_MAPINDEXTOID, nIndex, 0L);
+	}
+
+	int MapIDToIndex(UINT uID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_MAPIDTOINDEX, uID, 0L);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_WINNT >= 0x0600)
+	int HitTestEx(LPLVHITTESTINFO lpHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_HITTEST, (WPARAM)-1, (LPARAM)lpHitTestInfo);
+	}
+
+	int HitTestEx(POINT pt, UINT* pFlags) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LVHITTESTINFO hti = { 0 };
+		hti.pt = pt;
+		int nRes = (int)::SendMessage(m_hWnd, LVM_HITTEST, (WPARAM)-1, (LPARAM)&hti);
+		if (pFlags != NULL)
+			*pFlags = hti.flags;
+		return nRes;
+	}
+
+	int SubItemHitTestEx(LPLVHITTESTINFO lpHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LVM_SUBITEMHITTEST, (WPARAM)-1, (LPARAM)lpHitTestInfo);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+	// Note: selects only one item
+	BOOL SelectItem(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		// multi-selection only: de-select all items
+		if((GetStyle() & LVS_SINGLESEL) == 0)
+			SetItemState(-1, 0, LVIS_SELECTED);
+
+		BOOL bRet = SetItemState(nIndex, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
+		if(bRet)
+			bRet = EnsureVisible(nIndex, FALSE);
+
+		return bRet;
+	}
+};
+
+typedef CListViewCtrlT<ATL::CWindow>   CListViewCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTreeViewCtrl
+
+template <class TBase>
+class CTreeViewCtrlT : public TBase
+{
+public:
+// Constructors
+	CTreeViewCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CTreeViewCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_TREEVIEW;
+	}
+
+	UINT GetCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, TVM_GETCOUNT, 0, 0L);
+	}
+
+	UINT GetIndent() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, TVM_GETINDENT, 0, 0L);
+	}
+
+	void SetIndent(UINT nIndent)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TVM_SETINDENT, nIndent, 0L);
+	}
+
+	CImageList GetImageList(int nImageListType = TVSIL_NORMAL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_GETIMAGELIST, (WPARAM)nImageListType, 0L));
+	}
+
+	CImageList SetImageList(HIMAGELIST hImageList, int nImageListType = TVSIL_NORMAL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageListType, (LPARAM)hImageList));
+	}
+
+	BOOL GetItem(LPTVITEM pItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem);
+	}
+
+	BOOL SetItem(LPTVITEM pItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem);
+	}
+
+	BOOL SetItem(HTREEITEM hItem, UINT nMask, LPCTSTR lpszItem, int nImage,
+		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = nMask;
+		item.pszText = (LPTSTR) lpszItem;
+		item.iImage = nImage;
+		item.iSelectedImage = nSelectedImage;
+		item.state = nState;
+		item.stateMask = nStateMask;
+		item.lParam = lParam;
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)&item);
+	}
+
+	BOOL GetItemText(HTREEITEM hItem, LPTSTR lpstrText, int nLen) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpstrText != NULL);
+
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_TEXT;
+		item.pszText = lpstrText;
+		item.cchTextMax = nLen;
+
+		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+	}
+
+#ifndef _ATL_NO_COM
+	BOOL GetItemText(HTREEITEM hItem, BSTR& bstrText) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrText == NULL);
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_TEXT;
+
+		LPTSTR lpstrText = NULL;
+		BOOL bRet = FALSE;
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			ATLTRY(lpstrText = new TCHAR[nLen]);
+			if(lpstrText == NULL)
+				break;
+			lpstrText[0] = NULL;
+			item.pszText = lpstrText;
+			item.cchTextMax = nLen;
+			bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+			if(!bRet || (lstrlen(item.pszText) < nLen - 1))
+				break;
+			delete [] lpstrText;
+			lpstrText = NULL;
+		}
+
+		if(lpstrText != NULL)
+		{
+			if(bRet)
+				bstrText = ::SysAllocString(T2OLE(lpstrText));
+			delete [] lpstrText;
+		}
+
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	BOOL GetItemText(HTREEITEM hItem, _CSTRING_NS::CString& strText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_TEXT;
+
+		strText.Empty();
+		BOOL bRet = FALSE;
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			item.pszText = strText.GetBufferSetLength(nLen);
+			if(item.pszText == NULL)
+			{
+				bRet = FALSE;
+				break;
+			}
+			item.cchTextMax = nLen;
+			bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+			if(!bRet || (lstrlen(item.pszText) < nLen - 1))
+				break;
+		}
+		strText.ReleaseBuffer();
+		return bRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	BOOL SetItemText(HTREEITEM hItem, LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(hItem, TVIF_TEXT, lpszItem, 0, 0, 0, 0, NULL);
+	}
+
+	BOOL GetItemImage(HTREEITEM hItem, int& nImage, int& nSelectedImage) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_IMAGE|TVIF_SELECTEDIMAGE;
+		BOOL bRes = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+		if (bRes)
+		{
+			nImage = item.iImage;
+			nSelectedImage = item.iSelectedImage;
+		}
+		return bRes;
+	}
+
+	BOOL SetItemImage(HTREEITEM hItem, int nImage, int nSelectedImage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(hItem, TVIF_IMAGE|TVIF_SELECTEDIMAGE, NULL, nImage, nSelectedImage, 0, 0, NULL);
+	}
+
+	UINT GetItemState(HTREEITEM hItem, UINT nStateMask) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+		return (((UINT)::SendMessage(m_hWnd, TVM_GETITEMSTATE, (WPARAM)hItem, (LPARAM)nStateMask)) & nStateMask);
+#else // !((_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE))
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_STATE;
+		item.state = 0;
+		item.stateMask = nStateMask;
+		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+		return (item.state & nStateMask);
+#endif // !((_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE))
+	}
+
+	BOOL SetItemState(HTREEITEM hItem, UINT nState, UINT nStateMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(hItem, TVIF_STATE, NULL, 0, 0, nState, nStateMask, NULL);
+	}
+
+	DWORD_PTR GetItemData(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_PARAM;
+		BOOL bRet = (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+		return (DWORD_PTR)(bRet ? item.lParam : NULL);
+	}
+
+	BOOL SetItemData(HTREEITEM hItem, DWORD_PTR dwData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(hItem, TVIF_PARAM, NULL, 0, 0, 0, 0, (LPARAM)dwData);
+	}
+
+	CEdit GetEditControl() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CEdit((HWND)::SendMessage(m_hWnd, TVM_GETEDITCONTROL, 0, 0L));
+	}
+
+	UINT GetVisibleCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, TVM_GETVISIBLECOUNT, 0, 0L);
+	}
+
+	BOOL GetItemRect(HTREEITEM hItem, LPRECT lpRect, BOOL bTextOnly) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		*(HTREEITEM*)lpRect = hItem;
+		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEMRECT, (WPARAM)bTextOnly, (LPARAM)lpRect);
+	}
+
+	BOOL ItemHasChildren(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVITEM item = { 0 };
+		item.hItem = hItem;
+		item.mask = TVIF_CHILDREN;
+		::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)&item);
+		return item.cChildren;
+	}
+
+#ifndef _WIN32_WCE
+	CToolTipCtrl GetToolTips() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TVM_GETTOOLTIPS, 0, 0L));
+	}
+
+	CToolTipCtrl SetToolTips(HWND hWndTT)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TVM_SETTOOLTIPS, (WPARAM)hWndTT, 0L));
+	}
+#endif // !_WIN32_WCE
+
+	int GetISearchString(LPTSTR lpstr) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TVM_GETISEARCHSTRING, 0, (LPARAM)lpstr);
+	}
+
+	// checkboxes only
+	BOOL GetCheckState(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & TVS_CHECKBOXES) != 0);
+		UINT uRet = GetItemState(hItem, TVIS_STATEIMAGEMASK);
+		return (uRet >> 12) - 1;
+	}
+
+	BOOL SetCheckState(HTREEITEM hItem, BOOL bCheck)
+	{
+		int nCheck = bCheck ? 2 : 1;   // one based index
+		return SetItemState(hItem, INDEXTOSTATEIMAGEMASK(nCheck), TVIS_STATEIMAGEMASK);
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_GETBKCOLOR, 0, 0L);
+	}
+
+	COLORREF SetBkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_SETBKCOLOR, 0, (LPARAM)clr);
+	}
+
+	COLORREF GetInsertMarkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_GETINSERTMARKCOLOR, 0, 0L);
+	}
+
+	COLORREF SetInsertMarkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_SETINSERTMARKCOLOR, 0, (LPARAM)clr);
+	}
+
+	int GetItemHeight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TVM_GETITEMHEIGHT, 0, 0L);
+	}
+
+	int SetItemHeight(int cyHeight)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TVM_SETITEMHEIGHT, cyHeight, 0L);
+	}
+
+	int GetScrollTime() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TVM_GETSCROLLTIME, 0, 0L);
+	}
+
+	int SetScrollTime(int nScrollTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TVM_SETSCROLLTIME, nScrollTime, 0L);
+	}
+
+	COLORREF GetTextColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_GETTEXTCOLOR, 0, 0L);
+	}
+
+	COLORREF SetTextColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_SETTEXTCOLOR, 0, (LPARAM)clr);
+	}
+
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	COLORREF GetLineColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_GETLINECOLOR, 0, 0L);
+	}
+
+	COLORREF SetLineColor(COLORREF clrNew /*= CLR_DEFAULT*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TVM_SETLINECOLOR, 0, (LPARAM)clrNew);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL GetItem(LPTVITEMEX pItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEM, 0, (LPARAM)pItem);
+	}
+
+	BOOL SetItem(LPTVITEMEX pItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETITEM, 0, (LPARAM)pItem);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+	DWORD GetExtendedStyle() const
+	{
+#ifndef TVM_GETEXTENDEDSTYLE
+		const UINT TVM_GETEXTENDEDSTYLE = (TV_FIRST + 45);
+#endif
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TVM_GETEXTENDEDSTYLE, 0, 0L);
+	}
+
+	DWORD SetExtendedStyle(DWORD dwStyle, DWORD dwMask)
+	{
+#ifndef TVM_SETEXTENDEDSTYLE
+		const UINT TVM_SETEXTENDEDSTYLE = (TV_FIRST + 44);
+#endif
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TVM_SETEXTENDEDSTYLE, dwMask, dwStyle);
+	}
+
+#if (_WIN32_WINNT >= 0x0600)
+	BOOL SetAutoScrollInfo(UINT uPixPerSec, UINT uUpdateTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETAUTOSCROLLINFO, (WPARAM)uPixPerSec, (LPARAM)uUpdateTime);
+	}
+
+	DWORD GetSelectedCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TVM_GETSELECTEDCOUNT, 0, 0L);
+	}
+
+	BOOL GetItemPartRect(HTREEITEM hItem, TVITEMPART partID, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVGETITEMPARTRECTINFO gipri = { hItem, lpRect, partID };
+		return (BOOL)::SendMessage(m_hWnd, TVM_GETITEMPARTRECT, 0, (LPARAM)&gipri);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+// Operations
+	HTREEITEM InsertItem(LPTVINSERTSTRUCT lpInsertStruct)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
+	}
+
+	HTREEITEM InsertItem(LPCTSTR lpszItem, int nImage,
+		int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); 
+	}
+
+	HTREEITEM InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
+	}
+
+	HTREEITEM InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
+		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
+		HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVINSERTSTRUCT tvis = { 0 };
+		tvis.hParent = hParent;
+		tvis.hInsertAfter = hInsertAfter;
+		tvis.item.mask = nMask;
+		tvis.item.pszText = (LPTSTR) lpszItem;
+		tvis.item.iImage = nImage;
+		tvis.item.iSelectedImage = nSelectedImage;
+		tvis.item.state = nState;
+		tvis.item.stateMask = nStateMask;
+		tvis.item.lParam = lParam;
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
+	}
+
+	HTREEITEM InsertItemW(UINT nMask, LPCWSTR lpszItem, int nImage,
+		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
+		HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVINSERTSTRUCTW tvis = { 0 };
+		tvis.hParent = hParent;
+		tvis.hInsertAfter = hInsertAfter;
+		tvis.item.mask = nMask;
+		tvis.item.pszText = (LPWSTR) lpszItem;
+		tvis.item.iImage = nImage;
+		tvis.item.iSelectedImage = nSelectedImage;
+		tvis.item.state = nState;
+		tvis.item.stateMask = nStateMask;
+		tvis.item.lParam = lParam;
+		return (HTREEITEM)::SendMessageW(m_hWnd, TVM_INSERTITEMW, 0, (LPARAM)&tvis);
+	}
+
+    BOOL DeleteItem(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)hItem);
+	}
+
+	BOOL DeleteAllItems()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_DELETEITEM, 0, (LPARAM)TVI_ROOT);
+	}
+
+	BOOL Expand(HTREEITEM hItem, UINT nCode = TVE_EXPAND)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_EXPAND, nCode, (LPARAM)hItem);
+	}
+
+	HTREEITEM GetNextItem(HTREEITEM hItem, UINT nCode) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
+	}
+
+	HTREEITEM GetChildItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
+	}
+
+	HTREEITEM GetNextSiblingItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); 
+	}
+
+	HTREEITEM GetPrevSiblingItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
+	}
+
+	HTREEITEM GetParentItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); 
+	}
+
+	HTREEITEM GetFirstVisibleItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
+	}
+
+	HTREEITEM GetNextVisibleItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
+	}
+
+	HTREEITEM GetPrevVisibleItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
+	}
+
+	HTREEITEM GetSelectedItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
+	}
+
+	HTREEITEM GetDropHilightItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
+	}
+
+	HTREEITEM GetRootItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
+	}
+
+#if !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+	HTREEITEM GetLastVisibleItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0L);
+	}
+#endif // !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0600)
+	HTREEITEM GetNextSelectedItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0600)
+
+	BOOL Select(HTREEITEM hItem, UINT nCode)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, nCode, (LPARAM)hItem);
+	}
+
+	BOOL SelectItem(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_CARET, (LPARAM)hItem);
+	}
+
+	BOOL SelectDropTarget(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_DROPHILITE, (LPARAM)hItem);
+	}
+
+	BOOL SelectSetFirstVisible(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SELECTITEM, TVGN_FIRSTVISIBLE, (LPARAM)hItem);
+	}
+
+	CEdit EditLabel(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CEdit((HWND)::SendMessage(m_hWnd, TVM_EDITLABEL, 0, (LPARAM)hItem));
+	}
+
+	BOOL EndEditLabelNow(BOOL bCancel)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_ENDEDITLABELNOW, bCancel, 0L);
+	}
+
+	HTREEITEM HitTest(TVHITTESTINFO* pHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
+	}
+
+	HTREEITEM HitTest(POINT pt, UINT* pFlags) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVHITTESTINFO hti = { 0 };
+		hti.pt = pt;
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
+		if (pFlags != NULL)
+			*pFlags = hti.flags;
+		return hTreeItem;
+	}
+
+	BOOL SortChildren(HTREEITEM hItem, BOOL bRecurse = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDREN, (WPARAM)bRecurse, (LPARAM)hItem);
+	}
+
+	BOOL EnsureVisible(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_ENSUREVISIBLE, 0, (LPARAM)hItem);
+	}
+
+	BOOL SortChildrenCB(LPTVSORTCB pSort, BOOL bRecurse = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SORTCHILDRENCB, (WPARAM)bRecurse, (LPARAM)pSort);
+	}
+
+	CImageList RemoveImageList(int nImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_SETIMAGELIST, (WPARAM)nImageList, NULL));
+	}
+
+	CImageList CreateDragImage(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TVM_CREATEDRAGIMAGE, 0, (LPARAM)hItem));
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL SetInsertMark(HTREEITEM hTreeItem, BOOL bAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETINSERTMARK, bAfter, (LPARAM)hTreeItem);
+	}
+
+	BOOL RemoveInsertMark()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TVM_SETINSERTMARK, 0, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0501)
+	HTREEITEM MapAccIDToHTREEITEM(UINT uID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HTREEITEM)::SendMessage(m_hWnd, TVM_MAPACCIDTOHTREEITEM, uID, 0L);
+	}
+
+	UINT MapHTREEITEMToAccID(HTREEITEM hTreeItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, TVM_MAPHTREEITEMTOACCID, (WPARAM)hTreeItem, 0L);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_WINNT >= 0x0600)
+	void ShowInfoTip(HTREEITEM hItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TVM_SHOWINFOTIP, 0, (LPARAM)hItem);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+};
+
+typedef CTreeViewCtrlT<ATL::CWindow>   CTreeViewCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTreeViewCtrlEx
+
+// forward declaration
+template <class TBase> class CTreeViewCtrlExT;
+
+// Note: TBase here is for CTreeViewCtrlExT, and not for CTreeItemT itself
+template <class TBase>
+class CTreeItemT
+{
+public:
+	HTREEITEM m_hTreeItem;
+	CTreeViewCtrlExT<TBase>* m_pTreeView;
+
+// Construction
+	CTreeItemT(HTREEITEM hTreeItem = NULL, CTreeViewCtrlExT<TBase>* pTreeView = NULL) : m_hTreeItem(hTreeItem), m_pTreeView(pTreeView)
+	{ }
+ 
+	CTreeItemT(const CTreeItemT<TBase>& posSrc)
+	{
+		*this = posSrc;
+	}
+
+	operator HTREEITEM() { return m_hTreeItem; }
+
+	CTreeItemT<TBase>& operator =(const CTreeItemT<TBase>& itemSrc)
+	{
+		m_hTreeItem = itemSrc.m_hTreeItem;
+		m_pTreeView = itemSrc.m_pTreeView;
+		return *this;
+	}
+
+// Attributes
+	CTreeViewCtrlExT<TBase>* GetTreeView() const { return m_pTreeView; }
+
+	BOOL operator !() const { return m_hTreeItem == NULL; }
+
+	BOOL IsNull() const { return m_hTreeItem == NULL; }
+	
+	BOOL GetRect(LPRECT lpRect, BOOL bTextOnly) const;
+	BOOL GetText(LPTSTR lpstrText, int nLen) const;
+#ifndef _ATL_NO_COM
+	BOOL GetText(BSTR& bstrText) const;
+#endif // !_ATL_NO_COM
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	BOOL GetText(_CSTRING_NS::CString& strText) const;
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	BOOL SetText(LPCTSTR lpszItem);
+	BOOL GetImage(int& nImage, int& nSelectedImage) const;
+	BOOL SetImage(int nImage, int nSelectedImage);
+	UINT GetState(UINT nStateMask) const;
+	BOOL SetState(UINT nState, UINT nStateMask);
+	DWORD_PTR GetData() const;
+	BOOL SetData(DWORD_PTR dwData);
+	BOOL SetItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam);
+
+// Operations
+	CTreeItemT<TBase> InsertAfter(LPCTSTR lpstrItem, HTREEITEM hItemAfter, int nImageIndex)
+	{
+		return _Insert(lpstrItem, nImageIndex, hItemAfter);
+	}
+
+	CTreeItemT<TBase> AddHead(LPCTSTR lpstrItem, int nImageIndex)
+	{
+		return _Insert(lpstrItem, nImageIndex, TVI_FIRST);
+	}
+
+	CTreeItemT<TBase> AddTail(LPCTSTR lpstrItem, int nImageIndex)
+	{
+		return _Insert(lpstrItem, nImageIndex, TVI_LAST);
+	}
+
+	CTreeItemT<TBase> GetChild() const;
+	CTreeItemT<TBase> GetNext(UINT nCode) const;
+	CTreeItemT<TBase> GetNextSibling() const;
+	CTreeItemT<TBase> GetPrevSibling() const;
+	CTreeItemT<TBase> GetParent() const;
+	CTreeItemT<TBase> GetFirstVisible() const;
+	CTreeItemT<TBase> GetNextVisible() const;
+	CTreeItemT<TBase> GetPrevVisible() const;
+	CTreeItemT<TBase> GetSelected() const;
+	CTreeItemT<TBase> GetDropHilight() const;
+	CTreeItemT<TBase> GetRoot() const;
+#if !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+	CTreeItemT<TBase> GetLastVisible() const;
+#endif // !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+#if (_WIN32_IE >= 0x0600)
+	CTreeItemT<TBase> GetNextSelected() const;
+#endif // (_WIN32_IE >= 0x0600)
+	BOOL HasChildren() const;
+	BOOL Delete();
+	BOOL Expand(UINT nCode = TVE_EXPAND);
+	BOOL Select(UINT nCode);
+	BOOL Select();
+	BOOL SelectDropTarget();
+	BOOL SelectSetFirstVisible();
+	HWND EditLabel();
+	HIMAGELIST CreateDragImage();
+	BOOL SortChildren(BOOL bRecurse = FALSE);
+	BOOL EnsureVisible();
+	CTreeItemT<TBase> _Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter);
+	int GetImageIndex() const;
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL SetInsertMark(BOOL bAfter);
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+#if (_WIN32_WINNT >= 0x0501)
+	UINT MapHTREEITEMToAccID() const;
+#endif // (_WIN32_WINNT >= 0x0501)
+#if (_WIN32_WINNT >= 0x0600)
+	void ShowInfoTip();
+	BOOL GetPartRect(TVITEMPART partID, LPRECT lpRect) const;
+#endif // (_WIN32_WINNT >= 0x0600)
+};
+
+typedef CTreeItemT<ATL::CWindow>   CTreeItem;
+
+
+template <class TBase>
+class CTreeViewCtrlExT : public CTreeViewCtrlT< TBase >
+{
+public:
+// Constructors
+	CTreeViewCtrlExT(HWND hWnd = NULL) : CTreeViewCtrlT< TBase >(hWnd)
+	{ }
+
+	CTreeViewCtrlExT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Operations (overides that return CTreeItem)
+	CTreeItemT<TBase> InsertItem(LPTVINSERTSTRUCT lpInsertStruct)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)lpInsertStruct);
+		return CTreeItemT<TBase>(hTreeItem, this);
+	}
+
+	CTreeItemT<TBase> InsertItem(LPCTSTR lpszItem, int nImage,
+		int nSelectedImage, HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return InsertItem(TVIF_TEXT | TVIF_IMAGE | TVIF_SELECTEDIMAGE, lpszItem, nImage, nSelectedImage, 0, 0, 0, hParent, hInsertAfter); 
+	}
+
+	CTreeItemT<TBase> InsertItem(LPCTSTR lpszItem, HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return InsertItem(TVIF_TEXT, lpszItem, 0, 0, 0, 0, 0, hParent, hInsertAfter);
+	}
+
+	CTreeItemT<TBase> GetNextItem(HTREEITEM hItem, UINT nCode) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, nCode, (LPARAM)hItem);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetChildItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CHILD, (LPARAM)hItem);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this); 
+	}
+
+	CTreeItemT<TBase> GetNextSiblingItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXT, (LPARAM)hItem); 
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetPrevSiblingItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUS, (LPARAM)hItem);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetParentItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PARENT, (LPARAM)hItem); 
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetFirstVisibleItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd)); 
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_FIRSTVISIBLE, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetNextVisibleItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTVISIBLE, (LPARAM)hItem);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetPrevVisibleItem(HTREEITEM hItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_PREVIOUSVISIBLE, (LPARAM)hItem);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetSelectedItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_CARET, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetDropHilightItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_DROPHILITE, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> GetRootItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_ROOT, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+#if !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+	CTreeItemT<TBase> GetLastVisibleItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_LASTVISIBLE, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+#endif // !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0600)
+	CTreeItemT<TBase> GetNextSelectedItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_GETNEXTITEM, TVGN_NEXTSELECTED, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+#endif // (_WIN32_IE >= 0x0600)
+
+	CTreeItemT<TBase> HitTest(TVHITTESTINFO* pHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)pHitTestInfo);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+	CTreeItemT<TBase> InsertItem(UINT nMask, LPCTSTR lpszItem, int nImage,
+		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam,
+		HTREEITEM hParent, HTREEITEM hInsertAfter)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVINSERTSTRUCT tvis = { 0 };
+		tvis.hParent = hParent;
+		tvis.hInsertAfter = hInsertAfter;
+		tvis.item.mask = nMask;
+		tvis.item.pszText = (LPTSTR) lpszItem;
+		tvis.item.iImage = nImage;
+		tvis.item.iSelectedImage = nSelectedImage;
+		tvis.item.state = nState;
+		tvis.item.stateMask = nStateMask;
+		tvis.item.lParam = lParam;
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_INSERTITEM, 0, (LPARAM)&tvis);
+		return CTreeItemT<TBase>(hTreeItem, this);
+	}
+
+	CTreeItemT<TBase> HitTest(POINT pt, UINT* pFlags) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TVHITTESTINFO hti = { 0 };
+		hti.pt = pt;
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_HITTEST, 0, (LPARAM)&hti);
+		if (pFlags != NULL)
+			*pFlags = hti.flags;
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+
+#if (_WIN32_WINNT >= 0x0501)
+	CTreeItemT<TBase> MapAccIDToHTREEITEM(UINT uID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HTREEITEM hTreeItem = (HTREEITEM)::SendMessage(m_hWnd, TVM_MAPACCIDTOHTREEITEM, uID, 0L);
+		return CTreeItemT<TBase>(hTreeItem, (CTreeViewCtrlExT<TBase>*)this);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+};
+
+typedef CTreeViewCtrlExT<ATL::CWindow>   CTreeViewCtrlEx;
+
+
+// CTreeItem inline methods
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::GetRect(LPRECT lpRect, BOOL bTextOnly) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemRect(m_hTreeItem,lpRect,bTextOnly);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetNext(UINT nCode) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetNextItem(m_hTreeItem,nCode);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetChild() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetChildItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetNextSibling() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetNextSiblingItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetPrevSibling() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetPrevSiblingItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetParent() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetParentItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetFirstVisible() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetFirstVisibleItem();
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetNextVisible() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetNextVisibleItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetPrevVisible() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetPrevVisibleItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetSelected() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetSelectedItem();
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetDropHilight() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetDropHilightItem();
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetRoot() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetRootItem();
+}
+
+#if !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetLastVisible() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetLastVisibleItem();
+}
+#endif // !defined(_WIN32_WCE) && (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0600)
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::GetNextSelected() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetNextSelectedItem();
+}
+#endif // (_WIN32_IE >= 0x0600)
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::GetText(LPTSTR lpstrText, int nLen) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemText(m_hTreeItem, lpstrText, nLen);
+}
+
+#ifndef _ATL_NO_COM
+#ifdef _OLEAUTO_H_
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::GetText(BSTR& bstrText) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemText(m_hTreeItem, bstrText);
+}
+#endif // _OLEAUTO_H_
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::GetText(_CSTRING_NS::CString& strText) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemText(m_hTreeItem, strText);
+}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::GetImage(int& nImage, int& nSelectedImage) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemImage(m_hTreeItem,nImage,nSelectedImage);
+}
+
+template <class TBase>
+inline UINT CTreeItemT<TBase>::GetState(UINT nStateMask) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemState(m_hTreeItem,nStateMask);
+}
+
+template <class TBase>
+inline DWORD_PTR CTreeItemT<TBase>::GetData() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemData(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SetItem(UINT nMask, LPCTSTR lpszItem, int nImage,
+		int nSelectedImage, UINT nState, UINT nStateMask, LPARAM lParam)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SetItem(m_hTreeItem, nMask, lpszItem, nImage, nSelectedImage, nState, nStateMask, lParam);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SetText(LPCTSTR lpszItem)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SetItemText(m_hTreeItem,lpszItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SetImage(int nImage, int nSelectedImage)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SetItemImage(m_hTreeItem,nImage,nSelectedImage);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SetState(UINT nState, UINT nStateMask)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SetItemState(m_hTreeItem,nState,nStateMask);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SetData(DWORD_PTR dwData)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SetItemData(m_hTreeItem,dwData);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::HasChildren() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->ItemHasChildren(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::Delete()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->DeleteItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::Expand(UINT nCode /*= TVE_EXPAND*/)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->Expand(m_hTreeItem,nCode);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::Select(UINT nCode)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->Select(m_hTreeItem,nCode);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::Select()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SelectItem(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SelectDropTarget()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SelectDropTarget(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SelectSetFirstVisible()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SelectSetFirstVisible(m_hTreeItem);
+}
+
+template <class TBase>
+inline HWND CTreeItemT<TBase>::EditLabel()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->EditLabel(m_hTreeItem);
+}
+
+template <class TBase>
+inline HIMAGELIST CTreeItemT<TBase>::CreateDragImage()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->CreateDragImage(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SortChildren(BOOL bRecurse /*= FALSE*/)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SortChildren(m_hTreeItem, bRecurse);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::EnsureVisible()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->EnsureVisible(m_hTreeItem);
+}
+
+template <class TBase>
+inline CTreeItemT<TBase> CTreeItemT<TBase>::_Insert(LPCTSTR lpstrItem, int nImageIndex, HTREEITEM hItemAfter)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	TVINSERTSTRUCT ins = { 0 };
+	ins.hParent = m_hTreeItem;
+	ins.hInsertAfter = hItemAfter;
+	ins.item.mask = TVIF_TEXT;
+	ins.item.pszText = (LPTSTR)lpstrItem;
+	if(nImageIndex != -1)
+	{
+		ins.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
+		ins.item.iImage = nImageIndex;
+		ins.item.iSelectedImage = nImageIndex;
+	}
+	return CTreeItemT<TBase>(m_pTreeView->InsertItem(&ins), m_pTreeView);
+}
+
+template <class TBase>
+inline int CTreeItemT<TBase>::GetImageIndex() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	TVITEM item = { 0 };
+	item.mask = TVIF_HANDLE | TVIF_IMAGE;
+	item.hItem = m_hTreeItem;
+	m_pTreeView->GetItem(&item);
+	return item.iImage;
+}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::SetInsertMark(BOOL bAfter)
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->SetInsertMark(m_hTreeItem, bAfter);
+}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0501)
+template <class TBase>
+inline UINT CTreeItemT<TBase>::MapHTREEITEMToAccID() const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->MapHTREEITEMToAccID(m_hTreeItem);
+}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_WINNT >= 0x0600)
+template <class TBase>
+inline void CTreeItemT<TBase>::ShowInfoTip()
+{
+	ATLASSERT(m_pTreeView != NULL);
+	m_pTreeView->ShowInfoTip(m_hTreeItem);
+}
+
+template <class TBase>
+inline BOOL CTreeItemT<TBase>::GetPartRect(TVITEMPART partID, LPRECT lpRect) const
+{
+	ATLASSERT(m_pTreeView != NULL);
+	return m_pTreeView->GetItemPartRect(m_hTreeItem, partID, lpRect);
+}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CToolBarCtrl
+
+template <class TBase>
+class CToolBarCtrlT : public TBase
+{
+public:
+// Construction
+	CToolBarCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CToolBarCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return TOOLBARCLASSNAME;
+	}
+
+	BOOL IsButtonEnabled(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONENABLED, nID, 0L);
+	}
+
+	BOOL IsButtonChecked(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONCHECKED, nID, 0L);
+	}
+
+	BOOL IsButtonPressed(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONPRESSED, nID, 0L);
+	}
+
+	BOOL IsButtonHidden(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return(BOOL) ::SendMessage(m_hWnd, TB_ISBUTTONHIDDEN, nID, 0L);
+	}
+
+	BOOL IsButtonIndeterminate(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONINDETERMINATE, nID, 0L);
+	}
+
+	int GetState(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETSTATE, nID, 0L);
+	}
+
+	BOOL SetState(int nID, UINT nState)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETSTATE, nID, MAKELPARAM(nState, 0));
+	}
+
+	BOOL GetButton(int nIndex, LPTBBUTTON lpButton) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETBUTTON, nIndex, (LPARAM)lpButton);
+	}
+
+	int GetButtonCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_BUTTONCOUNT, 0, 0L);
+	}
+
+	BOOL GetItemRect(int nIndex, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETITEMRECT, nIndex, (LPARAM)lpRect);
+	}
+
+	void SetButtonStructSize(int nSize = sizeof(TBBUTTON))
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_BUTTONSTRUCTSIZE, nSize, 0L);
+	}
+
+	BOOL SetButtonSize(SIZE size)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(size.cx, size.cy));
+	}
+
+	BOOL SetButtonSize(int cx, int cy)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONSIZE, 0, MAKELPARAM(cx, cy));
+	}
+
+	BOOL SetBitmapSize(SIZE size)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(size.cx, size.cy));
+	}
+
+	BOOL SetBitmapSize(int cx, int cy)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBITMAPSIZE, 0, MAKELPARAM(cx, cy));
+	}
+
+#ifndef _WIN32_WCE
+	CToolTipCtrl GetToolTips() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TB_GETTOOLTIPS, 0, 0L));
+	}
+
+	void SetToolTips(HWND hWndToolTip)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	void SetNotifyWnd(HWND hWnd)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETPARENT, (WPARAM)hWnd, 0L);
+	}
+
+	int GetRows() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETROWS, 0, 0L);
+	}
+
+	void SetRows(int nRows, BOOL bLarger, LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETROWS, MAKELPARAM(nRows, bLarger), (LPARAM)lpRect);
+	}
+
+	BOOL SetCmdID(int nIndex, UINT nID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETCMDID, nIndex, nID);
+	}
+
+	DWORD GetBitmapFlags() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TB_GETBITMAPFLAGS, 0, 0L);
+	}
+
+	int GetBitmap(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETBITMAP, nID, 0L);
+	}
+
+	int GetButtonText(int nID, LPTSTR lpstrText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETBUTTONTEXT, nID, (LPARAM)lpstrText);
+	}
+
+	// nIndex - IE5 or higher only
+	CImageList GetImageList(int nIndex = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETIMAGELIST, nIndex, 0L));
+	}
+
+	// nIndex - IE5 or higher only
+	CImageList SetImageList(HIMAGELIST hImageList, int nIndex = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETIMAGELIST, nIndex, (LPARAM)hImageList));
+	}
+
+	// nIndex - IE5 or higher only
+	CImageList GetDisabledImageList(int nIndex = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETDISABLEDIMAGELIST, nIndex, 0L));
+	}
+
+	// nIndex - IE5 or higher only
+	CImageList SetDisabledImageList(HIMAGELIST hImageList, int nIndex = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETDISABLEDIMAGELIST, nIndex, (LPARAM)hImageList));
+	}
+
+#ifndef _WIN32_WCE
+	// nIndex - IE5 or higher only
+	CImageList GetHotImageList(int nIndex = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETHOTIMAGELIST, nIndex, 0L));
+	}
+
+	// nIndex - IE5 or higher only
+	CImageList SetHotImageList(HIMAGELIST hImageList, int nIndex = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETHOTIMAGELIST, nIndex, (LPARAM)hImageList));
+	}
+#endif // !_WIN32_WCE
+
+	DWORD GetStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TB_GETSTYLE, 0, 0L);
+	}
+
+	void SetStyle(DWORD dwStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETSTYLE, 0, dwStyle);
+	}
+
+	DWORD GetButtonSize() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L);
+	}
+
+	void GetButtonSize(SIZE& size) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_GETBUTTONSIZE, 0, 0L);
+		size.cx = LOWORD(dwRet);
+		size.cy = HIWORD(dwRet);
+	}
+
+	BOOL GetRect(int nID, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETRECT, nID, (LPARAM)lpRect);
+	}
+
+	int GetTextRows() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETTEXTROWS, 0, 0L);
+	}
+
+	BOOL SetButtonWidth(int cxMin, int cxMax)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONWIDTH, 0, MAKELPARAM(cxMin, cxMax));
+	}
+
+	BOOL SetIndent(int nIndent)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETINDENT, nIndent, 0L);
+	}
+
+	BOOL SetMaxTextRows(int nMaxTextRows)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETMAXTEXTROWS, nMaxTextRows, 0L);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+#ifndef _WIN32_WCE
+	BOOL GetAnchorHighlight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETANCHORHIGHLIGHT, 0, 0L);
+	}
+
+	BOOL SetAnchorHighlight(BOOL bEnable = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETANCHORHIGHLIGHT, bEnable, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	int GetButtonInfo(int nID, LPTBBUTTONINFO lptbbi) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETBUTTONINFO, nID, (LPARAM)lptbbi);
+	}
+
+	BOOL SetButtonInfo(int nID, LPTBBUTTONINFO lptbbi)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)lptbbi);
+	}
+
+	BOOL SetButtonInfo(int nID, DWORD dwMask, BYTE Style, BYTE State, LPCTSTR lpszItem, 
+	                   int iImage, WORD cx, int iCommand, DWORD_PTR lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TBBUTTONINFO tbbi = { 0 };
+		tbbi.cbSize = sizeof(TBBUTTONINFO);
+		tbbi.dwMask = dwMask;
+		tbbi.idCommand = iCommand;
+		tbbi.iImage = iImage;
+		tbbi.fsState = State;
+		tbbi.fsStyle = Style;
+		tbbi.cx = cx;
+		tbbi.pszText = (LPTSTR) lpszItem;
+		tbbi.lParam = lParam;
+		return (BOOL)::SendMessage(m_hWnd, TB_SETBUTTONINFO, nID, (LPARAM)&tbbi);
+	}
+
+#ifndef _WIN32_WCE
+	int GetHotItem() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETHOTITEM, 0, 0L);
+	}
+
+	int SetHotItem(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_SETHOTITEM, nItem, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL IsButtonHighlighted(int nButtonID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ISBUTTONHIGHLIGHTED, nButtonID, 0L);
+	}
+
+	DWORD SetDrawTextFlags(DWORD dwMask, DWORD dwFlags)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TB_SETDRAWTEXTFLAGS, dwMask, dwFlags);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetColorScheme(LPCOLORSCHEME lpcs) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETCOLORSCHEME, 0, (LPARAM)lpcs);
+	}
+
+	void SetColorScheme(LPCOLORSCHEME lpcs)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETCOLORSCHEME, 0, (LPARAM)lpcs);
+	}
+
+	DWORD GetExtendedStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TB_GETEXTENDEDSTYLE, 0, 0L);
+	}
+
+	DWORD SetExtendedStyle(DWORD dwStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TB_SETEXTENDEDSTYLE, 0, dwStyle);
+	}
+
+	void GetInsertMark(LPTBINSERTMARK lptbim) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_GETINSERTMARK, 0, (LPARAM)lptbim);
+	}
+
+	void SetInsertMark(LPTBINSERTMARK lptbim)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETINSERTMARK, 0, (LPARAM)lptbim);
+	}
+
+	COLORREF GetInsertMarkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TB_GETINSERTMARKCOLOR, 0, 0L);
+	}
+
+	COLORREF SetInsertMarkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, TB_SETINSERTMARKCOLOR, 0, (LPARAM)clr);
+	}
+
+	BOOL GetMaxSize(LPSIZE lpSize) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETMAXSIZE, 0, (LPARAM)lpSize);
+	}
+
+	void GetPadding(LPSIZE lpSizePadding) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpSizePadding != NULL);
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_GETPADDING, 0, 0L);
+		lpSizePadding->cx = GET_X_LPARAM(dwRet);
+		lpSizePadding->cy = GET_Y_LPARAM(dwRet);
+	}
+
+	void SetPadding(int cx, int cy, LPSIZE lpSizePadding = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, TB_SETPADDING, 0, MAKELPARAM(cx, cy));
+		if(lpSizePadding != NULL)
+		{
+			lpSizePadding->cx = GET_X_LPARAM(dwRet);
+			lpSizePadding->cy = GET_Y_LPARAM(dwRet);
+		}
+	}
+
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	int GetString(int nString, LPTSTR lpstrString, int cchMaxLen) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(cchMaxLen, nString), (LPARAM)lpstrString);
+	}
+
+	int GetStringBSTR(int nString, BSTR& bstrString) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrString == NULL);
+		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
+		if(nLength != -1)
+		{
+			CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+			LPTSTR lpstrText = buff.Allocate(nLength + 1);
+			if(lpstrText != NULL)
+			{
+				nLength = (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)lpstrText);
+				if(nLength != -1)
+					bstrString = ::SysAllocString(T2OLE(lpstrText));
+			}
+			else
+			{
+				nLength = -1;
+			}
+		}
+
+		return nLength;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetString(int nString, _CSTRING_NS::CString& str) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(0, nString), NULL));
+		if(nLength != -1)
+		{
+			LPTSTR lpstr = str.GetBufferSetLength(nLength + 1);
+			if(lpstr != NULL)
+				nLength = (int)::SendMessage(m_hWnd, TB_GETSTRING, MAKEWPARAM(nLength + 1, nString), (LPARAM)lpstr);
+			else
+				nLength = -1;
+			str.ReleaseBuffer();
+		}
+		return nLength;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0501)
+	void GetMetrics(LPTBMETRICS lptbm) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_GETMETRICS, 0, (LPARAM)lptbm);
+	}
+
+	void SetMetrics(LPTBMETRICS lptbm)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETMETRICS, 0, (LPARAM)lptbm);
+	}
+
+	void SetWindowTheme(LPCWSTR lpstrTheme)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_SETWINDOWTHEME, 0, (LPARAM)lpstrTheme);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_WINNT >= 0x0600)
+	CImageList GetPressedImageList(int nIndex = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_GETPRESSEDIMAGELIST, nIndex, 0L));
+	}
+
+	CImageList SetPressedImageList(HIMAGELIST hImageList, int nIndex = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TB_SETPRESSEDIMAGELIST, nIndex, (LPARAM)hImageList));
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+// Operations
+	BOOL EnableButton(int nID, BOOL bEnable = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ENABLEBUTTON, nID, MAKELPARAM(bEnable, 0));
+	}
+
+	BOOL CheckButton(int nID, BOOL bCheck = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_CHECKBUTTON, nID, MAKELPARAM(bCheck, 0));
+	}
+
+	BOOL PressButton(int nID, BOOL bPress = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_PRESSBUTTON, nID, MAKELPARAM(bPress, 0));
+	}
+
+	BOOL HideButton(int nID, BOOL bHide = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_HIDEBUTTON, nID, MAKELPARAM(bHide, 0));
+	}
+
+	BOOL Indeterminate(int nID, BOOL bIndeterminate = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_INDETERMINATE, nID, MAKELPARAM(bIndeterminate, 0));
+	}
+
+	int AddBitmap(int nNumButtons, UINT nBitmapID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TBADDBITMAP tbab = { 0 };
+		tbab.hInst = ModuleHelper::GetResourceInstance();
+		ATLASSERT(tbab.hInst != NULL);
+		tbab.nID = nBitmapID;
+		return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
+	}
+
+	int AddBitmap(int nNumButtons, HBITMAP hBitmap)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TBADDBITMAP tbab = { 0 };
+		tbab.hInst = NULL;
+		tbab.nID = (UINT_PTR)hBitmap;
+		return (int)::SendMessage(m_hWnd, TB_ADDBITMAP, (WPARAM)nNumButtons, (LPARAM)&tbab);
+	}
+
+	BOOL AddButtons(int nNumButtons, LPTBBUTTON lpButtons)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_ADDBUTTONS, nNumButtons, (LPARAM)lpButtons);
+	}
+
+	BOOL InsertButton(int nIndex, LPTBBUTTON lpButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)lpButton);
+	}
+
+	BOOL InsertButton(int nIndex, int iCommand, BYTE Style, BYTE State, int iBitmap, 
+	                  INT_PTR iString, DWORD_PTR lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TBBUTTON tbb = { 0 };
+		tbb.fsStyle = Style;
+		tbb.fsState = State;
+		tbb.idCommand = iCommand;
+		tbb.iBitmap = iBitmap;
+		tbb.iString = iString;
+		tbb.dwData = lParam;
+		return (BOOL)::SendMessage(m_hWnd, TB_INSERTBUTTON, nIndex, (LPARAM)&tbb);
+	}
+
+	BOOL InsertButton(int nIndex, int iCommand, BYTE Style, BYTE State, int iBitmap, 
+	                  LPCTSTR lpszItem, DWORD_PTR lParam)
+	{
+		return InsertButton(nIndex, iCommand, Style, State, iBitmap, (INT_PTR)lpszItem, lParam);
+	}
+
+	BOOL AddButton(LPTBBUTTON lpButton)
+	{
+		return InsertButton(-1, lpButton);
+	}
+
+	BOOL AddButton(int iCommand, BYTE Style, BYTE State, int iBitmap, INT_PTR iString, DWORD_PTR lParam)
+	{
+		return InsertButton(-1, iCommand, Style, State, iBitmap, iString, lParam);
+	}
+
+	BOOL AddButton(int iCommand, BYTE Style, BYTE State, int iBitmap, LPCTSTR lpszItem, DWORD_PTR lParam)
+	{
+		return InsertButton(-1, iCommand, Style, State, iBitmap, lpszItem, lParam);
+	}
+
+	BOOL DeleteButton(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_DELETEBUTTON, nIndex, 0L);
+	}
+
+	UINT CommandToIndex(UINT nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, TB_COMMANDTOINDEX, nID, 0L);
+	}
+
+#ifndef _WIN32_WCE
+	void SaveState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TBSAVEPARAMS tbs = { 0 };
+		tbs.hkr = hKeyRoot;
+		tbs.pszSubKey = lpszSubKey;
+		tbs.pszValueName = lpszValueName;
+		::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)TRUE, (LPARAM)&tbs);
+	}
+
+	void RestoreState(HKEY hKeyRoot, LPCTSTR lpszSubKey, LPCTSTR lpszValueName)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TBSAVEPARAMS tbs = { 0 };
+		tbs.hkr = hKeyRoot;
+		tbs.pszSubKey = lpszSubKey;
+		tbs.pszValueName = lpszValueName;
+		::SendMessage(m_hWnd, TB_SAVERESTORE, (WPARAM)FALSE, (LPARAM)&tbs);
+	}
+
+	void Customize()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_CUSTOMIZE, 0, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	int AddString(UINT nStringID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_ADDSTRING, (WPARAM)ModuleHelper::GetResourceInstance(), (LPARAM)nStringID);
+	}
+
+	int AddStrings(LPCTSTR lpszStrings)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_ADDSTRING, 0, (LPARAM)lpszStrings);
+	}
+
+	void AutoSize()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TB_AUTOSIZE, 0, 0L);
+	}
+
+	BOOL ChangeBitmap(int nID, int nBitmap)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_CHANGEBITMAP, nID, MAKELPARAM(nBitmap, 0));
+	}
+
+	int LoadImages(int nBitmapID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)ModuleHelper::GetResourceInstance());
+	}
+
+	int LoadStdImages(int nBitmapID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_LOADIMAGES, nBitmapID, (LPARAM)HINST_COMMCTRL);
+	}
+
+	BOOL ReplaceBitmap(LPTBREPLACEBITMAP ptbrb)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_REPLACEBITMAP, 0, (LPARAM)ptbrb);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	int HitTest(LPPOINT lpPoint) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TB_HITTEST, 0, (LPARAM)lpPoint);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL InsertMarkHitTest(LPPOINT lpPoint, LPTBINSERTMARK lptbim) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)lpPoint, (LPARAM)lptbim);
+	}
+
+	BOOL InsertMarkHitTest(int x, int y, LPTBINSERTMARK lptbim) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		POINT pt = { x, y };
+		return (BOOL)::SendMessage(m_hWnd, TB_INSERTMARKHITTEST, (WPARAM)&pt, (LPARAM)lptbim);
+	}
+
+	BOOL MapAccelerator(TCHAR chAccel, int& nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_MAPACCELERATOR, (WPARAM)chAccel, (LPARAM)&nID);
+	}
+
+	BOOL MarkButton(int nID, BOOL bHighlight = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_MARKBUTTON, nID, MAKELPARAM(bHighlight, 0));
+	}
+
+	BOOL MoveButton(int nOldPos, int nNewPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TB_MOVEBUTTON, nOldPos, nNewPos);
+	}
+
+	HRESULT GetObject(REFIID iid, LPVOID* ppvObject)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HRESULT)::SendMessage(m_hWnd, TB_GETOBJECT, (WPARAM)&iid, (LPARAM)ppvObject);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+};
+
+typedef CToolBarCtrlT<ATL::CWindow>   CToolBarCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CStatusBarCtrl
+
+template <class TBase>
+class CStatusBarCtrlT : public TBase
+{
+public:
+// Constructors
+	CStatusBarCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CStatusBarCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Methods
+	static LPCTSTR GetWndClassName()
+	{
+		return STATUSCLASSNAME;
+	}
+
+	int GetParts(int nParts, int* pParts) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, SB_GETPARTS, nParts, (LPARAM)pParts);
+	}
+
+	BOOL SetParts(int nParts, int* pWidths)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, SB_SETPARTS, nParts, (LPARAM)pWidths);
+	}
+
+	int GetTextLength(int nPane, int* pType = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L);
+		if (pType != NULL)
+			*pType = (int)(short)HIWORD(dwRet);
+		return (int)(short)LOWORD(dwRet);
+	}
+
+	int GetText(int nPane, LPTSTR lpszText, int* pType = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, SB_GETTEXT, (WPARAM)nPane, (LPARAM)lpszText);
+		if(pType != NULL)
+			*pType = (int)(short)HIWORD(dwRet);
+		return (int)(short)LOWORD(dwRet);
+	}
+
+#ifndef _ATL_NO_COM
+	BOOL GetTextBSTR(int nPane, BSTR& bstrText, int* pType = NULL) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		ATLASSERT(bstrText == NULL);
+		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
+		if(nLength == 0)
+			return FALSE;
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrText = buff.Allocate(nLength + 1);
+		if(lpstrText == NULL)
+			return FALSE;
+
+		if(!GetText(nPane, lpstrText, pType))
+			return FALSE;
+
+		bstrText = ::SysAllocString(T2OLE(lpstrText));
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetText(int nPane, _CSTRING_NS::CString& strText, int* pType = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		int nLength = (int)(short)LOWORD(::SendMessage(m_hWnd, SB_GETTEXTLENGTH, (WPARAM)nPane, 0L));
+		if(nLength == 0)
+			return 0;
+
+		LPTSTR lpstr = strText.GetBufferSetLength(nLength);
+		if(lpstr == NULL)
+			return 0;
+		return GetText(nPane, lpstr, pType);
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	BOOL SetText(int nPane, LPCTSTR lpszText, int nType = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		return (BOOL)::SendMessage(m_hWnd, SB_SETTEXT, (nPane | nType), (LPARAM)lpszText);
+	}
+
+	BOOL GetRect(int nPane, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		return (BOOL)::SendMessage(m_hWnd, SB_GETRECT, nPane, (LPARAM)lpRect);
+	}
+
+	BOOL GetBorders(int* pBorders) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)pBorders);
+	}
+
+	BOOL GetBorders(int& nHorz, int& nVert, int& nSpacing) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int borders[3] = { 0, 0, 0 };
+		BOOL bResult = (BOOL)::SendMessage(m_hWnd, SB_GETBORDERS, 0, (LPARAM)&borders);
+		if(bResult)
+		{
+			nHorz = borders[0];
+			nVert = borders[1];
+			nSpacing = borders[2];
+		}
+		return bResult;
+	}
+
+	void SetMinHeight(int nMin)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, SB_SETMINHEIGHT, nMin, 0L);
+	}
+
+	BOOL SetSimple(BOOL bSimple = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, SB_SIMPLE, bSimple, 0L);
+	}
+
+	BOOL IsSimple() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, SB_ISSIMPLE, 0, 0L);
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, SB_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, SB_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+
+	void GetTipText(int nPane, LPTSTR lpstrText, int nSize) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		::SendMessage(m_hWnd, SB_GETTIPTEXT, MAKEWPARAM(nPane, nSize), (LPARAM)lpstrText);
+	}
+
+	void SetTipText(int nPane, LPCTSTR lpstrText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		::SendMessage(m_hWnd, SB_SETTIPTEXT, nPane, (LPARAM)lpstrText);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if ((_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 0x0500))
+	COLORREF SetBkColor(COLORREF clrBk)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, SB_SETBKCOLOR, 0, (LPARAM)clrBk);
+	}
+
+	HICON GetIcon(int nPane) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		return (HICON)::SendMessage(m_hWnd, SB_GETICON, nPane, 0L);
+	}
+
+	BOOL SetIcon(int nPane, HICON hIcon)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPane < 256);
+		return (BOOL)::SendMessage(m_hWnd, SB_SETICON, nPane, (LPARAM)hIcon);
+	}
+#endif // ((_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 0x0500))
+};
+
+typedef CStatusBarCtrlT<ATL::CWindow>   CStatusBarCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTabCtrl
+
+template <class TBase>
+class CTabCtrlT : public TBase
+{
+public:
+// Constructors
+	CTabCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CTabCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_TABCONTROL;
+	}
+
+	CImageList GetImageList() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TCM_GETIMAGELIST, 0, 0L));
+	}
+
+	CImageList SetImageList(HIMAGELIST hImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, TCM_SETIMAGELIST, 0, (LPARAM)hImageList));
+	}
+
+	int GetItemCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_GETITEMCOUNT, 0, 0L);
+	}
+
+	BOOL GetItem(int nItem, LPTCITEM pTabCtrlItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_GETITEM, nItem, (LPARAM)pTabCtrlItem);
+	}
+
+	BOOL SetItem(int nItem, LPTCITEM pTabCtrlItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)pTabCtrlItem);
+	}
+
+	int SetItem(int nItem, UINT mask, LPCTSTR lpszItem, DWORD dwState, DWORD dwStateMask, int iImage, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TCITEM tci = { 0 };
+		tci.mask = mask;
+		tci.pszText = (LPTSTR) lpszItem;
+		tci.dwState = dwState;
+		tci.dwStateMask = dwStateMask;
+		tci.iImage = iImage;
+		tci.lParam = lParam;
+		return (int)::SendMessage(m_hWnd, TCM_SETITEM, nItem, (LPARAM)&tci);
+	}
+
+	BOOL GetItemRect(int nItem, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_GETITEMRECT, nItem, (LPARAM)lpRect);
+	}
+
+	int GetCurSel() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_GETCURSEL, 0, 0L);
+	}
+
+	int SetCurSel(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_SETCURSEL, nItem, 0L);
+	}
+
+	SIZE SetItemSize(SIZE size)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwSize = (DWORD)::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(size.cx, size.cy));
+		SIZE sizeRet = { GET_X_LPARAM(dwSize), GET_Y_LPARAM(dwSize) };
+		return sizeRet;
+	}
+
+	void SetItemSize(int cx, int cy)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_SETITEMSIZE, 0, MAKELPARAM(cx, cy));
+	}
+
+	void SetPadding(SIZE size)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_SETPADDING, 0, MAKELPARAM(size.cx, size.cy));
+	}
+
+	int GetRowCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_GETROWCOUNT, 0, 0L);
+	}
+
+#ifndef _WIN32_WCE
+	CToolTipCtrl GetTooltips() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TCM_GETTOOLTIPS, 0, 0L));
+	}
+
+	void SetTooltips(HWND hWndToolTip)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_SETTOOLTIPS, (WPARAM)hWndToolTip, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	int GetCurFocus() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_GETCURFOCUS, 0, 0L);
+	}
+
+	void SetCurFocus(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_SETCURFOCUS, nItem, 0L);
+	}
+
+	BOOL SetItemExtra(int cbExtra)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetItemCount() == 0);   // must be empty
+		return (BOOL)::SendMessage(m_hWnd, TCM_SETITEMEXTRA, cbExtra, 0L);
+	}
+
+	int SetMinTabWidth(int nWidth = -1)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_SETMINTABWIDTH, 0, nWidth);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	DWORD GetExtendedStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TCM_GETEXTENDEDSTYLE, 0, 0L);
+	}
+
+	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, TCM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+
+// Operations
+	int InsertItem(int nItem, LPTCITEM pTabCtrlItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)pTabCtrlItem);
+	}
+
+	int InsertItem(int nItem, UINT mask, LPCTSTR lpszItem, int iImage, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TCITEM tci = { 0 };
+		tci.mask = mask;
+		tci.pszText = (LPTSTR) lpszItem;
+		tci.iImage = iImage;
+		tci.lParam = lParam;
+		return (int)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)&tci);
+	}
+
+	int InsertItem(int nItem, LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TCITEM tci = { 0 };
+		tci.mask = TCIF_TEXT;
+		tci.pszText = (LPTSTR) lpszItem;
+		return (int)::SendMessage(m_hWnd, TCM_INSERTITEM, nItem, (LPARAM)&tci);
+	}
+
+	int AddItem(LPTCITEM pTabCtrlItem)
+	{
+		return InsertItem(GetItemCount(), pTabCtrlItem);
+	}
+
+	int AddItem(UINT mask, LPCTSTR lpszItem, int iImage, LPARAM lParam)
+	{
+		return InsertItem(GetItemCount(), mask, lpszItem, iImage, lParam);
+	}
+
+	int AddItem(LPCTSTR lpszItem)
+	{
+		return InsertItem(GetItemCount(), lpszItem);
+	}
+
+	BOOL DeleteItem(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_DELETEITEM, nItem, 0L);
+	}
+
+	BOOL DeleteAllItems()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_DELETEALLITEMS, 0, 0L);
+	}
+
+	void AdjustRect(BOOL bLarger, LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_ADJUSTRECT, bLarger, (LPARAM)lpRect);
+	}
+
+	void RemoveImage(int nImage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_REMOVEIMAGE, nImage, 0L);
+	}
+
+	int HitTest(TC_HITTESTINFO* pHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TCM_HITTEST, 0, (LPARAM)pHitTestInfo);
+	}
+
+	void DeselectAll(BOOL bExcludeFocus = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TCM_DESELECTALL, bExcludeFocus, 0L);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	BOOL HighlightItem(int nIndex, BOOL bHighlight = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TCM_HIGHLIGHTITEM, nIndex, MAKELPARAM(bHighlight, 0));
+	}
+#endif // (_WIN32_IE >= 0x0400)
+};
+
+typedef CTabCtrlT<ATL::CWindow>   CTabCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTrackBarCtrl
+
+template <class TBase>
+class CTrackBarCtrlT : public TBase
+{
+public:
+// Constructors
+	CTrackBarCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CTrackBarCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return TRACKBAR_CLASS;
+	}
+
+	int GetLineSize() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETLINESIZE, 0, 0L);
+	}
+
+	int SetLineSize(int nSize)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_SETLINESIZE, 0, nSize);
+	}
+
+	int GetPageSize() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETPAGESIZE, 0, 0L);
+	}
+
+	int SetPageSize(int nSize)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_SETPAGESIZE, 0, nSize);
+	}
+
+	int GetRangeMin() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETRANGEMIN, 0, 0L);
+	}
+
+	void SetRangeMin(int nMin, BOOL bRedraw = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETRANGEMIN, bRedraw, nMin);
+	}
+
+	int GetRangeMax() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETRANGEMAX, 0, 0L);
+	}
+
+	void SetRangeMax(int nMax, BOOL bRedraw = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETRANGEMAX, bRedraw, nMax);
+	}
+
+	void GetRange(int& nMin, int& nMax) const
+	{
+		nMin = GetRangeMin();
+		nMax = GetRangeMax();
+	}
+
+	void SetRange(int nMin, int nMax, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETRANGE, bRedraw, MAKELPARAM(nMin, nMax));
+	}
+
+	int GetSelStart() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETSELSTART, 0, 0L);
+	}
+
+	void SetSelStart(int nMin)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETSELSTART, 0, (LPARAM)nMin);
+	}
+
+	int GetSelEnd() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETSELEND, 0, 0L);
+	}
+
+	void SetSelEnd(int nMax)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETSELEND, 0, (LPARAM)nMax);
+	}
+
+	void GetSelection(int& nMin, int& nMax) const
+	{
+		nMin = GetSelStart();
+		nMax = GetSelEnd();
+	}
+
+	void SetSelection(int nMin, int nMax)
+	{
+		SetSelStart(nMin);
+		SetSelEnd(nMax);
+	}
+
+	void GetChannelRect(LPRECT lprc) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_GETCHANNELRECT, 0, (LPARAM)lprc);
+	}
+
+	void GetThumbRect(LPRECT lprc) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_GETTHUMBRECT, 0, (LPARAM)lprc);
+	}
+
+	int GetPos() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETPOS, 0, 0L);
+	}
+
+	void SetPos(int nPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETPOS, TRUE, nPos);
+	}
+
+	UINT GetNumTics() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, TBM_GETNUMTICS, 0, 0L);
+	}
+
+	DWORD* GetTicArray() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD*)::SendMessage(m_hWnd, TBM_GETPTICS, 0, 0L);
+	}
+
+	int GetTic(int nTic) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETTIC, nTic, 0L);
+	}
+
+	BOOL SetTic(int nTic)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TBM_SETTIC, 0, nTic);
+	}
+
+	int GetTicPos(int nTic) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETTICPOS, nTic, 0L);
+	}
+
+	void SetTicFreq(int nFreq)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETTICFREQ, nFreq, 0L);
+	}
+
+	int GetThumbLength() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_GETTHUMBLENGTH, 0, 0L);
+	}
+
+	void SetThumbLength(int nLength)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETTHUMBLENGTH, nLength, 0L);
+	}
+
+	void SetSel(int nStart, int nEnd, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & TBS_ENABLESELRANGE) != 0);
+		::SendMessage(m_hWnd, TBM_SETSEL, bRedraw, MAKELPARAM(nStart, nEnd));
+	}
+
+	ATL::CWindow GetBuddy(BOOL bLeft = TRUE) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ATL::CWindow((HWND)::SendMessage(m_hWnd, TBM_GETBUDDY, bLeft, 0L));
+	}
+
+	ATL::CWindow SetBuddy(HWND hWndBuddy, BOOL bLeft = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ATL::CWindow((HWND)::SendMessage(m_hWnd, TBM_SETBUDDY, bLeft, (LPARAM)hWndBuddy));
+	}
+
+#ifndef _WIN32_WCE
+	CToolTipCtrl GetToolTips() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, TBM_GETTOOLTIPS, 0, 0L));
+	}
+
+	void SetToolTips(HWND hWndTT)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETTOOLTIPS, (WPARAM)hWndTT, 0L);
+	}
+
+	int SetTipSide(int nSide)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, TBM_SETTIPSIDE, nSide, 0L);
+	}
+#endif // !_WIN32_WCE
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TBM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, TBM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+// Operations
+	void ClearSel(BOOL bRedraw = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_CLEARSEL, bRedraw, 0L);
+	}
+
+	void VerifyPos()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_SETPOS, FALSE, 0L);
+	}
+
+	void ClearTics(BOOL bRedraw = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, TBM_CLEARTICS, bRedraw, 0L);
+	}
+};
+
+typedef CTrackBarCtrlT<ATL::CWindow>   CTrackBarCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CUpDownCtrl
+
+template <class TBase>
+class CUpDownCtrlT : public TBase
+{
+public:
+// Constructors
+	CUpDownCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CUpDownCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return UPDOWN_CLASS;
+	}
+
+	UINT GetAccel(int nAccel, UDACCEL* pAccel) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETACCEL, nAccel, (LPARAM)pAccel));
+	}
+
+	BOOL SetAccel(int nAccel, UDACCEL* pAccel)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)LOWORD(::SendMessage(m_hWnd, UDM_SETACCEL, nAccel, (LPARAM)pAccel));
+	}
+
+	UINT GetBase() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)LOWORD(::SendMessage(m_hWnd, UDM_GETBASE, 0, 0L));
+	}
+
+	int SetBase(int nBase)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, UDM_SETBASE, nBase, 0L);
+	}
+
+	ATL::CWindow GetBuddy() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ATL::CWindow((HWND)::SendMessage(m_hWnd, UDM_GETBUDDY, 0, 0L));
+	}
+
+	ATL::CWindow SetBuddy(HWND hWndBuddy)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ATL::CWindow((HWND)::SendMessage(m_hWnd, UDM_SETBUDDY, (WPARAM)hWndBuddy, 0L));
+	}
+
+	int GetPos(LPBOOL lpbError = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, UDM_GETPOS, 0, 0L);
+		// Note: Seems that Windows always sets error to TRUE if
+		// UDS_SETBUDDYINT style is not used
+		if(lpbError != NULL)
+			*lpbError = (HIWORD(dwRet) != 0) ? TRUE : FALSE;
+		return (int)(short)LOWORD(dwRet);
+	}
+
+	int SetPos(int nPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)(short)LOWORD(::SendMessage(m_hWnd, UDM_SETPOS, 0, MAKELPARAM(nPos, 0)));
+	}
+
+	DWORD GetRange() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
+	}
+
+	void GetRange(int& nLower, int& nUpper) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, UDM_GETRANGE, 0, 0L);
+		nLower = (int)(short)HIWORD(dwRet);
+		nUpper = (int)(short)LOWORD(dwRet);
+	}
+
+	void SetRange(int nLower, int nUpper)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, UDM_SETRANGE, 0, MAKELPARAM(nUpper, nLower));
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	void SetRange32(int nLower, int nUpper)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, UDM_SETRANGE32, nLower, nUpper);
+	}
+
+	void GetRange32(int& nLower, int& nUpper) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, UDM_GETRANGE32, (WPARAM)&nLower, (LPARAM)&nUpper);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, UDM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, UDM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	int GetPos32(LPBOOL lpbError = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		// Note: Seems that Windows always sets error to TRUE if
+		// UDS_SETBUDDYINT style is not used
+		return (int)::SendMessage(m_hWnd, UDM_GETPOS32, 0, (LPARAM)lpbError);
+	}
+
+	int SetPos32(int nPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, UDM_SETPOS32, 0, (LPARAM)nPos);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+};
+
+typedef CUpDownCtrlT<ATL::CWindow>   CUpDownCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CProgressBarCtrl
+
+template <class TBase>
+class CProgressBarCtrlT : public TBase
+{
+public:
+// Constructors
+	CProgressBarCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CProgressBarCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return PROGRESS_CLASS;
+	}
+
+	DWORD SetRange(int nLower, int nUpper)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE, 0, MAKELPARAM(nLower, nUpper));
+	}
+
+	int SetPos(int nPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_SETPOS, nPos, 0L));
+	}
+
+	int OffsetPos(int nPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_DELTAPOS, nPos, 0L));
+	}
+
+	int SetStep(int nStep)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_SETSTEP, nStep, 0L));
+	}
+
+	UINT GetPos() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, PBM_GETPOS, 0, 0L);
+	}
+
+	void GetRange(PPBRANGE pPBRange) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pPBRange != NULL);
+		::SendMessage(m_hWnd, PBM_GETRANGE, TRUE, (LPARAM)pPBRange);
+	}
+
+	void GetRange(int& nLower, int& nUpper) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		PBRANGE range = { 0 };
+		::SendMessage(m_hWnd, PBM_GETRANGE, TRUE, (LPARAM)&range);
+		nLower = range.iLow;
+		nUpper = range.iHigh;
+	}
+
+	int GetRangeLimit(BOOL bLowLimit) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PBM_GETRANGE, bLowLimit, (LPARAM)NULL);
+	}
+
+	DWORD SetRange32(int nMin, int nMax)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, PBM_SETRANGE32, nMin, nMax);
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	COLORREF SetBarColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, PBM_SETBARCOLOR, 0, (LPARAM)clr);
+	}
+
+	COLORREF SetBkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, PBM_SETBKCOLOR, 0, (LPARAM)clr);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if (_WIN32_WINNT >= 0x0501) && defined(PBM_SETMARQUEE)
+	BOOL SetMarquee(BOOL bMarquee, UINT uUpdateTime = 0U)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PBM_SETMARQUEE, (WPARAM)bMarquee, (LPARAM)uUpdateTime);
+	}
+#endif // (_WIN32_WINNT >= 0x0501) && defined(PBM_SETMARQUEE)
+
+#if (_WIN32_WINNT >= 0x0600)
+	int GetStep() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PBM_GETSTEP, 0, 0L);
+	}
+
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, PBM_GETBKCOLOR, 0, 0L);
+	}
+
+	COLORREF GetBarColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, PBM_GETBARCOLOR, 0, 0L);
+	}
+
+	int GetState() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PBM_GETSTATE, 0, 0L);
+	}
+
+	int SetState(int nState)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PBM_SETSTATE, nState, 0L);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+// Operations
+	int StepIt()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)(short)LOWORD(::SendMessage(m_hWnd, PBM_STEPIT, 0, 0L));
+	}
+};
+
+typedef CProgressBarCtrlT<ATL::CWindow>   CProgressBarCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CHotKeyCtrl
+
+#ifndef _WIN32_WCE
+
+template <class TBase>
+class CHotKeyCtrlT : public TBase
+{
+public:
+// Constructors
+	CHotKeyCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CHotKeyCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return HOTKEY_CLASS;
+	}
+
+	DWORD GetHotKey() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
+	}
+
+	void GetHotKey(WORD &wVirtualKeyCode, WORD &wModifiers) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dw = (DWORD)::SendMessage(m_hWnd, HKM_GETHOTKEY, 0, 0L);
+		wVirtualKeyCode = LOBYTE(LOWORD(dw));
+		wModifiers = HIBYTE(LOWORD(dw));
+	}
+
+	void SetHotKey(WORD wVirtualKeyCode, WORD wModifiers)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, HKM_SETHOTKEY, MAKEWORD(wVirtualKeyCode, wModifiers), 0L);
+	}
+
+	void SetRules(WORD wInvalidComb, WORD wModifiers)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, HKM_SETRULES, wInvalidComb, MAKELPARAM(wModifiers, 0));
+	}
+};
+
+typedef CHotKeyCtrlT<ATL::CWindow>   CHotKeyCtrl;
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAnimateCtrl
+
+#ifndef _WIN32_WCE
+
+template <class TBase>
+class CAnimateCtrlT : public TBase
+{
+public:
+// Constructors
+	CAnimateCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CAnimateCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return ANIMATE_CLASS;
+	}
+
+// Operations
+	BOOL Open(ATL::_U_STRINGorID FileName)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, (LPARAM)FileName.m_lpstr);
+	}
+
+	BOOL Play(UINT nFrom, UINT nTo, UINT nRep)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, nRep, MAKELPARAM(nFrom, nTo));
+	}
+
+	BOOL Stop()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, ACM_STOP, 0, 0L);
+	}
+
+	BOOL Close()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, ACM_OPEN, 0, 0L);
+	}
+
+	BOOL Seek(UINT nTo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, ACM_PLAY, 0, MAKELPARAM(nTo, nTo));
+	}
+
+	// Vista only
+	BOOL IsPlaying() const
+	{
+#ifndef ACM_ISPLAYING
+		const UINT ACM_ISPLAYING = (WM_USER+104);
+#endif
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, ACM_ISPLAYING, 0, 0L);
+	}
+};
+
+typedef CAnimateCtrlT<ATL::CWindow>   CAnimateCtrl;
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRichEditCtrl
+
+#ifndef _WIN32_WCE
+
+#ifdef _UNICODE
+#if (_RICHEDIT_VER == 0x0100)
+#undef RICHEDIT_CLASS
+#define RICHEDIT_CLASS	L"RICHEDIT"
+#endif // (_RICHEDIT_VER == 0x0100)
+#endif // _UNICODE
+
+template <class TBase>
+class CRichEditCtrlT : public TBase
+{
+public:
+// Constructors
+	CRichEditCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CRichEditCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return RICHEDIT_CLASS;
+	}
+
+	static LPCTSTR GetLibraryName()
+	{
+#if (_RICHEDIT_VER >= 0x0200)
+		return _T("RICHED20.DLL");
+#else
+		return _T("RICHED32.DLL");
+#endif
+	}
+
+	int GetLineCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0L);
+	}
+
+	BOOL GetModify() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
+	}
+
+	void SetModify(BOOL bModified = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0L);
+	}
+
+	void GetRect(LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect);
+	}
+
+	DWORD GetOptions() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_GETOPTIONS, 0, 0L);
+	}
+
+	DWORD SetOptions(WORD wOperation, DWORD dwOptions)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_SETOPTIONS, wOperation, dwOptions);
+	}
+
+	// NOTE: first word in lpszBuffer must contain the size of the buffer!
+	int GetLine(int nIndex, LPTSTR lpszBuffer) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
+	}
+
+	int GetLine(int nIndex, LPTSTR lpszBuffer, int nMaxLength) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		*(LPWORD)lpszBuffer = (WORD)nMaxLength;
+		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
+	}
+
+	BOOL CanUndo() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
+	}
+
+	BOOL CanPaste(UINT nFormat = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, nFormat, 0L);
+	}
+
+	void GetSel(LONG& nStartChar, LONG& nEndChar) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		CHARRANGE cr = { 0, 0 };
+		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
+		nStartChar = cr.cpMin;
+		nEndChar = cr.cpMax;
+	}
+
+	void GetSel(CHARRANGE &cr) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
+	}
+
+	int SetSel(LONG nStartChar, LONG nEndChar)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		CHARRANGE cr = { nStartChar, nEndChar };
+		return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
+	}
+
+	int SetSel(CHARRANGE &cr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_EXSETSEL, 0, (LPARAM)&cr);
+	}
+
+	int SetSelAll()
+	{
+		return SetSel(0, -1);
+	}
+
+	int SetSelNone()
+	{
+		return SetSel(-1, 0);
+	}
+
+	DWORD GetDefaultCharFormat(CHARFORMAT& cf) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
+	}
+
+	DWORD GetSelectionCharFormat(CHARFORMAT& cf) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
+	}
+
+	DWORD GetEventMask() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_GETEVENTMASK, 0, 0L);
+	}
+
+	LONG GetLimitText() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_GETLIMITTEXT, 0, 0L);
+	}
+
+	DWORD GetParaFormat(PARAFORMAT& pf) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		pf.cbSize = sizeof(PARAFORMAT);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
+	}
+
+#if (_RICHEDIT_VER >= 0x0200)
+	LONG GetSelText(LPTSTR lpstrBuff) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrBuff);
+	}
+#else // !(_RICHEDIT_VER >= 0x0200)
+	// RichEdit 1.0 EM_GETSELTEXT is ANSI only
+	LONG GetSelText(LPSTR lpstrBuff) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrBuff);
+	}
+#endif // !(_RICHEDIT_VER >= 0x0200)
+
+#ifndef _ATL_NO_COM
+	BOOL GetSelTextBSTR(BSTR& bstrText) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrText == NULL);
+
+		CHARRANGE cr = { 0, 0 };
+		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
+
+#if (_RICHEDIT_VER >= 0x0200)
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrText = buff.Allocate(cr.cpMax - cr.cpMin + 1);
+		if(lpstrText == NULL)
+			return FALSE;
+		if(::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText) == 0)
+			return FALSE;
+
+		bstrText = ::SysAllocString(T2W(lpstrText));
+#else // !(_RICHEDIT_VER >= 0x0200)
+		CTempBuffer<char, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPSTR lpstrText = buff.Allocate(cr.cpMax - cr.cpMin + 1);
+		if(lpstrText == NULL)
+			return FALSE;
+		if(::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText) == 0)
+			return FALSE;
+
+		bstrText = ::SysAllocString(A2W(lpstrText));
+#endif // !(_RICHEDIT_VER >= 0x0200)
+
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	LONG GetSelText(_CSTRING_NS::CString& strText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		CHARRANGE cr = { 0, 0 };
+		::SendMessage(m_hWnd, EM_EXGETSEL, 0, (LPARAM)&cr);
+
+#if (_RICHEDIT_VER >= 0x0200)
+		LONG lLen = 0;
+		LPTSTR lpstrText = strText.GetBufferSetLength(cr.cpMax - cr.cpMin);
+		if(lpstrText != NULL)
+		{
+			lLen = (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText);
+			strText.ReleaseBuffer();
+		}
+#else // !(_RICHEDIT_VER >= 0x0200)
+		CTempBuffer<char, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPSTR lpstrText = buff.Allocate(cr.cpMax - cr.cpMin + 1);
+		if(lpstrText == NULL)
+			return 0;
+		LONG lLen = (LONG)::SendMessage(m_hWnd, EM_GETSELTEXT, 0, (LPARAM)lpstrText);
+		if(lLen == 0)
+			return 0;
+
+		USES_CONVERSION;
+		strText = A2T(lpstrText);
+#endif // !(_RICHEDIT_VER >= 0x0200)
+
+		return lLen;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	WORD GetSelectionType() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (WORD)::SendMessage(m_hWnd, EM_SELECTIONTYPE, 0, 0L);
+	}
+
+	COLORREF SetBackgroundColor(COLORREF cr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, 0, cr);
+	}
+
+	COLORREF SetBackgroundColor()   // sets to system background
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, EM_SETBKGNDCOLOR, 1, 0);
+	}
+
+	BOOL SetCharFormat(CHARFORMAT& cf, WORD wFlags)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, (WPARAM)wFlags, (LPARAM)&cf);
+	}
+
+	BOOL SetDefaultCharFormat(CHARFORMAT& cf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
+	}
+
+	BOOL SetSelectionCharFormat(CHARFORMAT& cf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
+	}
+
+	BOOL SetWordCharFormat(CHARFORMAT& cf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD, (LPARAM)&cf);
+	}
+
+	DWORD SetEventMask(DWORD dwEventMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_SETEVENTMASK, 0, dwEventMask);
+	}
+
+	BOOL SetParaFormat(PARAFORMAT& pf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		pf.cbSize = sizeof(PARAFORMAT);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
+	}
+
+	BOOL SetTargetDevice(HDC hDC, int cxLineWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTARGETDEVICE, (WPARAM)hDC, cxLineWidth);
+	}
+
+	int GetTextLength() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, 0, 0L);
+	}
+
+	BOOL SetReadOnly(BOOL bReadOnly = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L);
+	}
+
+	int GetFirstVisibleLine() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L);
+	}
+
+	EDITWORDBREAKPROCEX GetWordBreakProcEx() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (EDITWORDBREAKPROCEX)::SendMessage(m_hWnd, EM_GETWORDBREAKPROCEX, 0, 0L);
+	}
+
+	EDITWORDBREAKPROCEX SetWordBreakProcEx(EDITWORDBREAKPROCEX pfnEditWordBreakProcEx)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (EDITWORDBREAKPROCEX)::SendMessage(m_hWnd, EM_SETWORDBREAKPROCEX, 0, (LPARAM)pfnEditWordBreakProcEx);
+	}
+
+	int GetTextRange(TEXTRANGE* pTextRange) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)pTextRange);
+	}
+
+#if (_RICHEDIT_VER >= 0x0200)
+	int GetTextRange(LONG nStartChar, LONG nEndChar, LPTSTR lpstrText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TEXTRANGE tr = { 0 };
+		tr.chrg.cpMin = nStartChar;
+		tr.chrg.cpMax = nEndChar;
+		tr.lpstrText = lpstrText;
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)&tr);
+	}
+#else // !(_RICHEDIT_VER >= 0x0200)
+
+	int GetTextRange(LONG nStartChar, LONG nEndChar, LPSTR lpstrText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		TEXTRANGE tr = { 0 };
+		tr.chrg.cpMin = nStartChar;
+		tr.chrg.cpMax = nEndChar;
+		tr.lpstrText = lpstrText;
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTRANGE, 0, (LPARAM)&tr);
+	}
+#endif // !(_RICHEDIT_VER >= 0x0200)
+
+#if (_RICHEDIT_VER >= 0x0200)
+	DWORD GetDefaultCharFormat(CHARFORMAT2& cf) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT2);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 0, (LPARAM)&cf);
+	}
+
+	BOOL SetCharFormat(CHARFORMAT2& cf, WORD wFlags)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT2);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, (WPARAM)wFlags, (LPARAM)&cf);
+	}
+
+	BOOL SetDefaultCharFormat(CHARFORMAT2& cf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT2);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, 0, (LPARAM)&cf);
+	}
+
+	DWORD GetSelectionCharFormat(CHARFORMAT2& cf) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT2);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETCHARFORMAT, 1, (LPARAM)&cf);
+	}
+
+	BOOL SetSelectionCharFormat(CHARFORMAT2& cf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT2);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION, (LPARAM)&cf);
+	}
+
+	BOOL SetWordCharFormat(CHARFORMAT2& cf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		cf.cbSize = sizeof(CHARFORMAT2);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETCHARFORMAT, SCF_SELECTION | SCF_WORD, (LPARAM)&cf);
+	}
+
+	DWORD GetParaFormat(PARAFORMAT2& pf) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		pf.cbSize = sizeof(PARAFORMAT2);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETPARAFORMAT, 0, (LPARAM)&pf);
+	}
+
+	BOOL SetParaFormat(PARAFORMAT2& pf)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		pf.cbSize = sizeof(PARAFORMAT2);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETPARAFORMAT, 0, (LPARAM)&pf);
+	}
+
+	TEXTMODE GetTextMode() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (TEXTMODE)::SendMessage(m_hWnd, EM_GETTEXTMODE, 0, 0L);
+	}
+
+	BOOL SetTextMode(TEXTMODE enumTextMode)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return !(BOOL)::SendMessage(m_hWnd, EM_SETTEXTMODE, enumTextMode, 0L);
+	}
+
+	UNDONAMEID GetUndoName() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UNDONAMEID)::SendMessage(m_hWnd, EM_GETUNDONAME, 0, 0L);
+	}
+
+	UNDONAMEID GetRedoName() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UNDONAMEID)::SendMessage(m_hWnd, EM_GETREDONAME, 0, 0L);
+	}
+
+	BOOL CanRedo() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0L);
+	}
+
+	BOOL GetAutoURLDetect() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_GETAUTOURLDETECT, 0, 0L);
+	}
+
+	BOOL SetAutoURLDetect(BOOL bAutoDetect = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return !(BOOL)::SendMessage(m_hWnd, EM_AUTOURLDETECT, bAutoDetect, 0L);
+	}
+
+	// this method is deprecated, please use SetAutoURLDetect
+	BOOL EnableAutoURLDetect(BOOL bEnable = TRUE) { return SetAutoURLDetect(bEnable); }
+
+	UINT SetUndoLimit(UINT uUndoLimit)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_SETUNDOLIMIT, uUndoLimit, 0L);
+	}
+
+	void SetPalette(HPALETTE hPalette)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETPALETTE, (WPARAM)hPalette, 0L);
+	}
+
+	int GetTextEx(GETTEXTEX* pGetTextEx, LPTSTR lpstrText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTEX, (WPARAM)pGetTextEx, (LPARAM)lpstrText);
+	}
+
+	int GetTextEx(LPTSTR lpstrText, int nTextLen, DWORD dwFlags = GT_DEFAULT, UINT uCodePage = CP_ACP, LPCSTR lpDefaultChar = NULL, LPBOOL lpUsedDefChar = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		GETTEXTEX gte = { 0 };
+		gte.cb = nTextLen * sizeof(TCHAR);
+		gte.codepage = uCodePage;
+		gte.flags = dwFlags;
+		gte.lpDefaultChar = lpDefaultChar;
+		gte.lpUsedDefChar = lpUsedDefChar;
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTEX, (WPARAM)&gte, (LPARAM)lpstrText);
+	}
+
+	int GetTextLengthEx(GETTEXTLENGTHEX* pGetTextLengthEx) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX, (WPARAM)pGetTextLengthEx, 0L);
+	}
+
+	int GetTextLengthEx(DWORD dwFlags = GTL_DEFAULT, UINT uCodePage = CP_ACP) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		GETTEXTLENGTHEX gtle = { 0 };
+		gtle.codepage = uCodePage;
+		gtle.flags = dwFlags;
+		return (int)::SendMessage(m_hWnd, EM_GETTEXTLENGTHEX, (WPARAM)&gtle, 0L);
+	}
+#endif // (_RICHEDIT_VER >= 0x0200)
+
+#if (_RICHEDIT_VER >= 0x0300)
+	int SetTextEx(SETTEXTEX* pSetTextEx, LPCTSTR lpstrText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_SETTEXTEX, (WPARAM)pSetTextEx, (LPARAM)lpstrText);
+	}
+
+	int SetTextEx(LPCTSTR lpstrText, DWORD dwFlags = ST_DEFAULT, UINT uCodePage = CP_ACP)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		SETTEXTEX ste = { 0 };
+		ste.flags = dwFlags;
+		ste.codepage = uCodePage;
+		return (int)::SendMessage(m_hWnd, EM_SETTEXTEX, (WPARAM)&ste, (LPARAM)lpstrText);
+	}
+
+	int GetEditStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_GETEDITSTYLE, 0, 0L);
+	}
+
+	int SetEditStyle(int nStyle, int nMask = -1)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		if(nMask == -1)
+			nMask = nStyle;   // set everything specified
+		return (int)::SendMessage(m_hWnd, EM_SETEDITSTYLE, nStyle, nMask);
+	}
+
+	BOOL SetFontSize(int nFontSizeDelta)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nFontSizeDelta >= -1637 && nFontSizeDelta <= 1638);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETFONTSIZE, nFontSizeDelta, 0L);
+	}
+
+	void GetScrollPos(LPPOINT lpPoint) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpPoint != NULL);
+		::SendMessage(m_hWnd, EM_GETSCROLLPOS, 0, (LPARAM)lpPoint);
+	}
+
+	void SetScrollPos(LPPOINT lpPoint)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpPoint != NULL);
+		::SendMessage(m_hWnd, EM_SETSCROLLPOS, 0, (LPARAM)lpPoint);
+	}
+
+	BOOL GetZoom(int& nNum, int& nDen) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_GETZOOM, (WPARAM)&nNum, (LPARAM)&nDen);
+	}
+
+	BOOL SetZoom(int nNum, int nDen)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nNum >= 0 && nNum <= 64);
+		ATLASSERT(nDen >= 0 && nDen <= 64);
+		return (BOOL)::SendMessage(m_hWnd, EM_SETZOOM, nNum, nDen);
+	}
+
+	BOOL SetZoomOff()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETZOOM, 0, 0L);
+	}
+#endif // (_RICHEDIT_VER >= 0x0300)
+
+// Operations
+	void LimitText(LONG nChars = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_EXLIMITTEXT, 0, nChars);
+	}
+
+	int LineFromChar(LONG nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_EXLINEFROMCHAR, 0, nIndex);
+	}
+
+	POINT PosFromChar(LONG nChar) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		POINT point = { 0, 0 };
+		::SendMessage(m_hWnd, EM_POSFROMCHAR, (WPARAM)&point, nChar);
+		return point;
+	}
+
+	int CharFromPos(POINT pt) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		POINTL ptl = { pt.x, pt.y };
+		return (int)::SendMessage(m_hWnd, EM_CHARFROMPOS, 0, (LPARAM)&ptl);
+	}
+
+	void EmptyUndoBuffer()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0L);
+	}
+
+	int LineIndex(int nLine = -1) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0L);
+	}
+
+	int LineLength(int nLine = -1) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0L);
+	}
+
+	BOOL LineScroll(int nLines, int nChars = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_LINESCROLL, nChars, nLines);
+	}
+
+	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM) bCanUndo, (LPARAM)lpszNewText);
+	}
+
+	void SetRect(LPCRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect);
+	}
+
+	BOOL DisplayBand(LPRECT pDisplayRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_DISPLAYBAND, 0, (LPARAM)pDisplayRect);
+	}
+
+	LONG FindText(DWORD dwFlags, FINDTEXT& ft) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+#if (_RICHEDIT_VER >= 0x0200) && defined(_UNICODE)
+		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTW, dwFlags, (LPARAM)&ft);
+#else
+		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXT, dwFlags, (LPARAM)&ft);
+#endif
+	}
+
+	LONG FindText(DWORD dwFlags, FINDTEXTEX& ft) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+#if (_RICHEDIT_VER >= 0x0200) && defined(_UNICODE)
+		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTEXW, dwFlags, (LPARAM)&ft);
+#else
+		return (LONG)::SendMessage(m_hWnd, EM_FINDTEXTEX, dwFlags, (LPARAM)&ft);
+#endif
+	}
+
+	LONG FormatRange(FORMATRANGE& fr, BOOL bDisplay = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_FORMATRANGE, bDisplay, (LPARAM)&fr);
+	}
+
+	LONG FormatRange(FORMATRANGE* pFormatRange, BOOL bDisplay = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_FORMATRANGE, bDisplay, (LPARAM)pFormatRange);
+	}
+
+	void HideSelection(BOOL bHide = TRUE, BOOL bChangeStyle = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_HIDESELECTION, bHide, bChangeStyle);
+	}
+
+	void PasteSpecial(UINT uClipFormat, DWORD dwAspect = 0, HMETAFILE hMF = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		REPASTESPECIAL reps = { dwAspect, (DWORD_PTR)hMF };
+		::SendMessage(m_hWnd, EM_PASTESPECIAL, uClipFormat, (LPARAM)&reps);
+	}
+
+	void RequestResize()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_REQUESTRESIZE, 0, 0L);
+	}
+
+	LONG StreamIn(UINT uFormat, EDITSTREAM& es)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_STREAMIN, uFormat, (LPARAM)&es);
+	}
+
+	LONG StreamOut(UINT uFormat, EDITSTREAM& es)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_STREAMOUT, uFormat, (LPARAM)&es);
+	}
+
+	DWORD FindWordBreak(int nCode, LONG nStartChar)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, EM_FINDWORDBREAK, nCode, nStartChar);
+	}
+
+	// Additional operations
+	void ScrollCaret()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SCROLLCARET, 0, 0L);
+	}
+
+	int InsertText(long nInsertAfterChar, LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
+	{
+		int nRet = SetSel(nInsertAfterChar, nInsertAfterChar);
+		ReplaceSel(lpstrText, bCanUndo);
+		return nRet;
+	}
+
+	int AppendText(LPCTSTR lpstrText, BOOL bCanUndo = FALSE)
+	{
+		return InsertText(GetWindowTextLength(), lpstrText, bCanUndo);
+	}
+
+	// Clipboard operations
+	BOOL Undo()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0L);
+	}
+
+	void Clear()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
+	}
+
+	void Copy()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
+	}
+
+	void Cut()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
+	}
+
+	void Paste()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
+	}
+
+	// OLE support
+	IRichEditOle* GetOleInterface() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		IRichEditOle *pRichEditOle = NULL;
+		::SendMessage(m_hWnd, EM_GETOLEINTERFACE, 0, (LPARAM)&pRichEditOle);
+		return pRichEditOle;
+	}
+
+	BOOL SetOleCallback(IRichEditOleCallback* pCallback)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETOLECALLBACK, 0, (LPARAM)pCallback);
+	}
+
+#if (_RICHEDIT_VER >= 0x0200)
+	BOOL Redo()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_REDO, 0, 0L);
+	}
+
+	void StopGroupTyping()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_STOPGROUPTYPING, 0, 0L);
+	}
+
+	void ShowScrollBar(int nBarType, BOOL bVisible = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SHOWSCROLLBAR, nBarType, bVisible);
+	}
+#endif // (_RICHEDIT_VER >= 0x0200)
+
+#if (_RICHEDIT_VER >= 0x0300)
+	BOOL SetTabStops(int nTabStops, LPINT rgTabStops)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops);
+	}
+
+	BOOL SetTabStops()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0L);
+	}
+
+	BOOL SetTabStops(const int& cxEachStop)    // takes an 'int'
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop);
+	}
+#endif // (_RICHEDIT_VER >= 0x0300)
+};
+
+typedef CRichEditCtrlT<ATL::CWindow>   CRichEditCtrl;
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRichEditCommands - message handlers for standard EDIT commands
+
+#ifndef _WIN32_WCE
+
+// Chain to CRichEditCommands message map. Your class must also derive from CRichEditCtrl.
+// Example:
+// class CMyRichEdit : public CWindowImpl<CMyRichEdit, CRichEditCtrl>,
+//                     public CRichEditCommands<CMyRichEdit>
+// {
+// public:
+//      BEGIN_MSG_MAP(CMyRichEdit)
+//              // your handlers...
+//              CHAIN_MSG_MAP_ALT(CRichEditCommands<CMyRichEdit>, 1)
+//      END_MSG_MAP()
+//      // other stuff...
+// };
+
+template <class T>
+class CRichEditCommands : public CEditCommands< T >
+{
+public:
+	BEGIN_MSG_MAP(CRichEditCommands< T >)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_EDIT_CLEAR, CEditCommands< T >::OnEditClear)
+		COMMAND_ID_HANDLER(ID_EDIT_CLEAR_ALL, CEditCommands< T >::OnEditClearAll)
+		COMMAND_ID_HANDLER(ID_EDIT_COPY, CEditCommands< T >::OnEditCopy)
+		COMMAND_ID_HANDLER(ID_EDIT_CUT, CEditCommands< T >::OnEditCut)
+		COMMAND_ID_HANDLER(ID_EDIT_PASTE, CEditCommands< T >::OnEditPaste)
+		COMMAND_ID_HANDLER(ID_EDIT_SELECT_ALL, CEditCommands< T >::OnEditSelectAll)
+		COMMAND_ID_HANDLER(ID_EDIT_UNDO, CEditCommands< T >::OnEditUndo)
+#if (_RICHEDIT_VER >= 0x0200)
+		COMMAND_ID_HANDLER(ID_EDIT_REDO, OnEditRedo)
+#endif // (_RICHEDIT_VER >= 0x0200)
+	END_MSG_MAP()
+
+#if (_RICHEDIT_VER >= 0x0200)
+	LRESULT OnEditRedo(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Redo();
+		return 0;
+	}
+#endif // (_RICHEDIT_VER >= 0x0200)
+
+// State (update UI) helpers
+	BOOL CanCut() const
+	{ return HasSelection(); }
+
+	BOOL CanCopy() const
+	{ return HasSelection(); }
+
+	BOOL CanClear() const
+	{ return HasSelection(); }
+
+// Implementation
+	BOOL HasSelection() const
+	{
+		const T* pT = static_cast<const T*>(this);
+		return (pT->GetSelectionType() != SEL_EMPTY);
+	}
+};
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDragListBox
+
+#ifndef _WIN32_WCE
+
+template <class TBase>
+class CDragListBoxT : public CListBoxT< TBase >
+{
+public:
+// Constructors
+	CDragListBoxT(HWND hWnd = NULL) : CListBoxT< TBase >(hWnd)
+	{ }
+
+	CDragListBoxT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		if(hWnd != NULL)
+			MakeDragList();
+		return hWnd;
+	}
+
+// Operations
+	BOOL MakeDragList()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((GetStyle() & (LBS_MULTIPLESEL | LBS_EXTENDEDSEL)) == 0);
+		return ::MakeDragList(m_hWnd);
+	}
+
+	int LBItemFromPt(POINT pt, BOOL bAutoScroll = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::LBItemFromPt(m_hWnd, pt, bAutoScroll);
+	}
+
+	void DrawInsert(int nItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::DrawInsert(GetParent(), m_hWnd, nItem);
+	}
+
+	static UINT GetDragListMessage()
+	{
+		static UINT uDragListMessage = 0;
+		if(uDragListMessage == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CDragListBox::GetDragListMessage.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uDragListMessage == 0)
+				uDragListMessage = ::RegisterWindowMessage(DRAGLISTMSGSTRING);
+
+			lock.Unlock();
+		}
+		ATLASSERT(uDragListMessage != 0);
+		return uDragListMessage;
+	}
+};
+
+typedef CDragListBoxT<ATL::CWindow>   CDragListBox;
+
+template <class T>
+class CDragListNotifyImpl
+{
+public:
+	BEGIN_MSG_MAP(CDragListNotifyImpl< T >)
+		MESSAGE_HANDLER(CDragListBox::GetDragListMessage(), OnDragListNotify)
+	END_MSG_MAP()
+
+	LRESULT OnDragListNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		uMsg;   // avoid level 4 warning
+		ATLASSERT(uMsg == CDragListBox::GetDragListMessage());
+		T* pT = static_cast<T*>(this);
+		LPDRAGLISTINFO lpDragListInfo = (LPDRAGLISTINFO)lParam;
+		LRESULT lRet = 0;
+		switch(lpDragListInfo->uNotification)
+		{
+		case DL_BEGINDRAG:
+			lRet = (LPARAM)pT->OnBeginDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
+			break;
+		case DL_CANCELDRAG:
+			pT->OnCancelDrag((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
+			break;
+		case DL_DRAGGING:
+			lRet = (LPARAM)pT->OnDragging((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
+			break;
+		case DL_DROPPED:
+			pT->OnDropped((int)wParam, lpDragListInfo->hWnd, lpDragListInfo->ptCursor);
+			break;
+		default:
+			ATLTRACE2(atlTraceUI, 0, _T("Unknown DragListBox notification\n"));
+			bHandled = FALSE;   // don't handle it
+			break;
+		}
+		return lRet;
+	}
+
+// Overrideables
+	BOOL OnBeginDrag(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
+	{
+		return TRUE;   // allow dragging
+	}
+
+	void OnCancelDrag(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
+	{
+		// nothing to do
+	}
+
+	int OnDragging(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
+	{
+		return 0;   // don't change cursor
+	}
+
+	void OnDropped(int /*nCtlID*/, HWND /*hWndDragList*/, POINT /*ptCursor*/)
+	{
+		// nothing to do
+	}
+};
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CReBarCtrl
+
+template <class TBase>
+class CReBarCtrlT : public TBase
+{
+public:
+// Constructors
+	CReBarCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CReBarCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return REBARCLASSNAME;
+	}
+
+	UINT GetBandCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, RB_GETBANDCOUNT, 0, 0L);
+	}
+
+	BOOL GetBandInfo(int nBand, LPREBARBANDINFO lprbbi) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_GETBANDINFO, nBand, (LPARAM)lprbbi);
+	}
+
+	BOOL SetBandInfo(int nBand, LPREBARBANDINFO lprbbi)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_SETBANDINFO, nBand, (LPARAM)lprbbi);
+	}
+
+	BOOL GetBarInfo(LPREBARINFO lprbi) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)lprbi);
+	}
+
+	BOOL SetBarInfo(LPREBARINFO lprbi)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)lprbi);
+	}
+
+	CImageList GetImageList() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		REBARINFO rbi = { 0 };
+		rbi.cbSize = sizeof(REBARINFO);
+		rbi.fMask = RBIM_IMAGELIST;
+		if( (BOOL)::SendMessage(m_hWnd, RB_GETBARINFO, 0, (LPARAM)&rbi) == FALSE ) return CImageList();
+		return CImageList(rbi.himl);
+	}
+
+	BOOL SetImageList(HIMAGELIST hImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		REBARINFO rbi = { 0 };
+		rbi.cbSize = sizeof(REBARINFO);
+		rbi.fMask = RBIM_IMAGELIST;
+		rbi.himl = hImageList;
+		return (BOOL)::SendMessage(m_hWnd, RB_SETBARINFO, 0, (LPARAM)&rbi);
+	}
+
+	UINT GetRowCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, RB_GETROWCOUNT, 0, 0L);
+	}
+
+	UINT GetRowHeight(int nBand) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, RB_GETROWHEIGHT, nBand, 0L);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	COLORREF GetTextColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, RB_GETTEXTCOLOR, 0, 0L);
+	}
+
+	COLORREF SetTextColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, RB_SETTEXTCOLOR, 0, (LPARAM)clr);
+	}
+
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, RB_GETBKCOLOR, 0, 0L);
+	}
+
+	COLORREF SetBkColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, RB_SETBKCOLOR, 0, (LPARAM)clr);
+	}
+
+	UINT GetBarHeight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, RB_GETBARHEIGHT, 0, 0L);
+	}
+
+	BOOL GetRect(int nBand, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_GETRECT, nBand, (LPARAM)lpRect);
+	}
+
+#ifndef _WIN32_WCE
+	CToolTipCtrl GetToolTips() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CToolTipCtrl((HWND)::SendMessage(m_hWnd, RB_GETTOOLTIPS, 0, 0L));
+	}
+
+	void SetToolTips(HWND hwndToolTip)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_SETTOOLTIPS, (WPARAM)hwndToolTip, 0L);
+	}
+#endif // !_WIN32_WCE
+
+	void GetBandBorders(int nBand, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpRect != NULL);
+		::SendMessage(m_hWnd, RB_GETBANDBORDERS, nBand, (LPARAM)lpRect);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetColorScheme(LPCOLORSCHEME lpColorScheme) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpColorScheme != NULL);
+		return (BOOL)::SendMessage(m_hWnd, RB_GETCOLORSCHEME, 0, (LPARAM)lpColorScheme);
+	}
+
+	void SetColorScheme(LPCOLORSCHEME lpColorScheme)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpColorScheme != NULL);
+		::SendMessage(m_hWnd, RB_SETCOLORSCHEME, 0, (LPARAM)lpColorScheme);
+	}
+
+	HPALETTE GetPalette() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HPALETTE)::SendMessage(m_hWnd, RB_GETPALETTE, 0, 0L);
+	}
+
+	HPALETTE SetPalette(HPALETTE hPalette)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HPALETTE)::SendMessage(m_hWnd, RB_SETPALETTE, 0, (LPARAM)hPalette);
+	}
+
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_WINNT >= 0x0501)
+	// requires uxtheme.h to be included to use MARGINS struct
+#ifndef _UXTHEME_H_
+	typedef struct _MARGINS*   PMARGINS;
+#endif // !_UXTHEME_H_
+	void GetBandMargins(PMARGINS pMargins) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_GETBANDMARGINS, 0, (LPARAM)pMargins);
+	}
+
+	void SetWindowTheme(LPCWSTR lpstrTheme)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_SETWINDOWTHEME, 0, (LPARAM)lpstrTheme);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+#if (_WIN32_IE >= 0x0600)
+	DWORD GetExtendedStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, RB_GETEXTENDEDSTYLE, 0, 0L);
+	}
+
+	DWORD SetExtendedStyle(DWORD dwStyle, DWORD dwMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, RB_SETEXTENDEDSTYLE, dwMask, dwStyle);
+	}
+#endif // (_WIN32_IE >= 0x0600)
+
+// Operations
+	BOOL InsertBand(int nBand, LPREBARBANDINFO lprbbi)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_INSERTBAND, nBand, (LPARAM)lprbbi);
+	}
+
+	BOOL AddBand(LPREBARBANDINFO lprbbi)
+	{
+		return InsertBand(-1, lprbbi);
+	}
+
+	BOOL DeleteBand(int nBand)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_DELETEBAND, nBand, 0L);
+	}
+
+	ATL::CWindow SetNotifyWnd(HWND hWnd)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ATL::CWindow((HWND)::SendMessage(m_hWnd, RB_SETPARENT, (WPARAM)hWnd, 0L));
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	void BeginDrag(int nBand, DWORD dwPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, dwPos);
+	}
+
+	void BeginDrag(int nBand, int xPos, int yPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_BEGINDRAG, nBand, MAKELPARAM(xPos, yPos));
+	}
+
+	void EndDrag()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_ENDDRAG, 0, 0L);
+	}
+
+	void DragMove(DWORD dwPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_DRAGMOVE, 0, dwPos);
+	}
+
+	void DragMove(int xPos, int yPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_DRAGMOVE, 0, MAKELPARAM(xPos, yPos));
+	}
+
+#ifndef _WIN32_WCE
+	void GetDropTarget(IDropTarget** ppDropTarget) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
+	}
+#endif // !_WIN32_WCE
+
+	void MaximizeBand(int nBand, BOOL bIdeal = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_MAXIMIZEBAND, nBand, bIdeal);
+	}
+
+	void MinimizeBand(int nBand)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_MINIMIZEBAND, nBand, 0L);
+	}
+
+	BOOL SizeToRect(LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_SIZETORECT, 0, (LPARAM)lpRect);
+	}
+
+	int IdToIndex(UINT uBandID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, RB_IDTOINDEX, uBandID, 0L);
+	}
+
+	int HitTest(LPRBHITTESTINFO lprbht) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, RB_HITTEST, 0, (LPARAM)lprbht);
+	}
+
+	BOOL ShowBand(int nBand, BOOL bShow)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_SHOWBAND, nBand, bShow);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL MoveBand(int nBand, int nNewPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nNewPos >= 0 && nNewPos <= ((int)GetBandCount() - 1));
+		return (BOOL)::SendMessage(m_hWnd, RB_MOVEBAND, nBand, nNewPos);
+	}
+#endif // !_WIN32_WCE
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	void PushChevron(int nBand, LPARAM lAppValue)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, RB_PUSHCHEVRON, nBand, lAppValue);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+// Extra operations
+#if (_WIN32_IE >= 0x0400)
+	void LockBands(bool bLock)
+	{
+		int nBandCount = GetBandCount();
+		for(int i =0; i < nBandCount; i++)
+		{
+			REBARBANDINFO rbbi = { RunTimeHelper::SizeOf_REBARBANDINFO() };
+			rbbi.fMask = RBBIM_STYLE;
+			BOOL bRet = GetBandInfo(i, &rbbi);
+			ATLASSERT(bRet);
+
+			if((rbbi.fStyle & RBBS_GRIPPERALWAYS) == 0)
+			{
+				rbbi.fStyle |= RBBS_GRIPPERALWAYS;
+				bRet = SetBandInfo(i, &rbbi);
+				ATLASSERT(bRet);
+				rbbi.fStyle &= ~RBBS_GRIPPERALWAYS;
+			}
+
+			if(bLock)
+				rbbi.fStyle |= RBBS_NOGRIPPER;
+			else
+				rbbi.fStyle &= ~RBBS_NOGRIPPER;
+
+			bRet = SetBandInfo(i, &rbbi);
+			ATLASSERT(bRet);
+		}
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_WINNT >= 0x0600)
+	BOOL SetBandWidth(int nBand, int cxWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, RB_SETBANDWIDTH, nBand, cxWidth);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+};
+
+typedef CReBarCtrlT<ATL::CWindow>   CReBarCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CComboBoxEx
+
+#ifndef _WIN32_WCE
+
+template <class TBase>
+class CComboBoxExT : public CComboBoxT< TBase >
+{
+public:
+// Constructors
+	CComboBoxExT(HWND hWnd = NULL) : CComboBoxT< TBase >(hWnd)
+	{ }
+
+	CComboBoxExT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_COMBOBOXEX;
+	}
+
+	CImageList GetImageList() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, CBEM_GETIMAGELIST, 0, 0L));
+	}
+
+	CImageList SetImageList(HIMAGELIST hImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CImageList((HIMAGELIST)::SendMessage(m_hWnd, CBEM_SETIMAGELIST, 0, (LPARAM)hImageList));
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	DWORD GetExtendedStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, CBEM_GETEXTENDEDSTYLE, 0, 0L);
+	}
+
+	DWORD SetExtendedStyle(DWORD dwExMask, DWORD dwExStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, CBEM_SETEXTENDEDSTYLE, dwExMask, dwExStyle);
+	}
+
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CBEM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CBEM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_WINNT >= 0x0501)
+	void SetWindowTheme(LPCWSTR lpstrTheme)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, CBEM_SETWINDOWTHEME, 0, (LPARAM)lpstrTheme);
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+// Operations
+	int InsertItem(const COMBOBOXEXITEM* lpcCBItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)lpcCBItem);
+	}
+
+	int InsertItem(UINT nMask, int nIndex, LPCTSTR lpszItem, int nImage, int nSelImage, 
+	               int iIndent, int iOverlay, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		COMBOBOXEXITEM cbex = { 0 };
+		cbex.mask = nMask;
+		cbex.iItem = nIndex;
+		cbex.pszText = (LPTSTR) lpszItem;
+		cbex.iImage = nImage;
+		cbex.iSelectedImage = nSelImage;
+		cbex.iIndent = iIndent;
+		cbex.iOverlay = iOverlay;
+		cbex.lParam = lParam;
+		return (int)::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)&cbex);
+	}
+
+	int InsertItem(int nIndex, LPCTSTR lpszItem, int nImage, int nSelImage, int iIndent, LPARAM lParam = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		COMBOBOXEXITEM cbex = { 0 };
+		cbex.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE | CBEIF_INDENT | CBEIF_LPARAM;
+		cbex.iItem = nIndex;
+		cbex.pszText = (LPTSTR) lpszItem;
+		cbex.iImage = nImage;
+		cbex.iSelectedImage = nSelImage;
+		cbex.iIndent = iIndent;
+		cbex.lParam = lParam;
+		return (int)::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM)&cbex);
+	}
+
+	int AddItem(UINT nMask, LPCTSTR lpszItem, int nImage, int nSelImage, int iIndent, int iOverlay, LPARAM lParam)
+	{
+		return InsertItem(nMask, -1, lpszItem, nImage, nSelImage, iIndent, iOverlay, lParam);
+	}
+
+	int AddItem(LPCTSTR lpszItem, int nImage, int nSelImage, int iIndent, LPARAM lParam = 0)
+	{
+		return InsertItem(-1, lpszItem, nImage, nSelImage, iIndent, lParam);
+	}
+
+	int DeleteItem(int nIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, CBEM_DELETEITEM, nIndex, 0L);
+	}
+
+	BOOL GetItem(PCOMBOBOXEXITEM pCBItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)pCBItem);
+	}
+
+	BOOL SetItem(const COMBOBOXEXITEM* lpcCBItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM)lpcCBItem);
+	}
+
+	int SetItem(int nIndex, UINT nMask, LPCTSTR lpszItem, int nImage, int nSelImage, 
+	            int iIndent, int iOverlay, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		COMBOBOXEXITEM cbex = { 0 };
+		cbex.mask = nMask;
+		cbex.iItem = nIndex;
+		cbex.pszText = (LPTSTR) lpszItem;
+		cbex.iImage = nImage;
+		cbex.iSelectedImage = nSelImage;
+		cbex.iIndent = iIndent;
+		cbex.iOverlay = iOverlay;
+		cbex.lParam = lParam;
+		return (int)::SendMessage(m_hWnd, CBEM_SETITEM, 0, (LPARAM)&cbex);
+	}
+
+	BOOL GetItemText(int nIndex, LPTSTR lpszItem, int nLen) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpszItem != NULL);
+
+		COMBOBOXEXITEM cbex = { 0 };
+		cbex.mask = CBEIF_TEXT;
+		cbex.iItem = nIndex;
+		cbex.pszText = lpszItem;
+		cbex.cchTextMax = nLen;
+
+		return (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)&cbex);
+	}
+
+#ifndef _ATL_NO_COM
+	BOOL GetItemText(int nIndex, BSTR& bstrText) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(bstrText == NULL);
+
+		COMBOBOXEXITEM cbex = { 0 };
+		cbex.mask = CBEIF_TEXT;
+		cbex.iItem = nIndex;
+
+		LPTSTR lpstrText = NULL;
+		BOOL bRet = FALSE;
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			ATLTRY(lpstrText = new TCHAR[nLen]);
+			if(lpstrText == NULL)
+				break;
+			lpstrText[0] = NULL;
+			cbex.pszText = lpstrText;
+			cbex.cchTextMax = nLen;
+			bRet = (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)&cbex);
+			if(!bRet || (lstrlen(cbex.pszText) < nLen - 1))
+				break;
+			delete [] lpstrText;
+			lpstrText = NULL;
+		}
+
+		if(lpstrText != NULL)
+		{
+			if(bRet)
+				bstrText = ::SysAllocString(T2OLE(lpstrText));
+			delete [] lpstrText;
+		}
+
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	BOOL GetItemText(int nIndex, _CSTRING_NS::CString& strText) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		COMBOBOXEXITEM cbex = { 0 };
+		cbex.mask = CBEIF_TEXT;
+		cbex.iItem = nIndex;
+
+		strText.Empty();
+		BOOL bRet = FALSE;
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			cbex.pszText = strText.GetBufferSetLength(nLen);
+			if(cbex.pszText == NULL)
+			{
+				bRet = FALSE;
+				break;
+			}
+			cbex.cchTextMax = nLen;
+			bRet = (BOOL)::SendMessage(m_hWnd, CBEM_GETITEM, 0, (LPARAM)&cbex);
+			if(!bRet || (lstrlen(cbex.pszText) < nLen - 1))
+				break;
+		}
+		strText.ReleaseBuffer();
+		return bRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	BOOL SetItemText(int nIndex, LPCTSTR lpszItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return SetItem(nIndex, CBEIF_TEXT, lpszItem, 0, 0, 0, 0, 0);
+	}
+
+	CComboBox GetComboCtrl() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CComboBox((HWND)::SendMessage(m_hWnd, CBEM_GETCOMBOCONTROL, 0, 0L));
+	}
+
+	CEdit GetEditCtrl() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CEdit((HWND)::SendMessage(m_hWnd, CBEM_GETEDITCONTROL, 0, 0L));
+	}
+
+	BOOL HasEditChanged() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, CBEM_HASEDITCHANGED, 0, 0L);
+	}
+
+// Non-functional
+	int AddString(LPCTSTR /*lpszItem*/)
+	{
+		ATLASSERT(FALSE);  // Not available in CComboBoxEx; use InsertItem
+		return 0;
+	}
+
+	int InsertString(int /*nIndex*/, LPCTSTR /*lpszString*/)
+	{
+		ATLASSERT(FALSE);  // Not available in CComboBoxEx; use InsertItem
+		return 0;
+	}
+
+	int Dir(UINT /*attr*/, LPCTSTR /*lpszWildCard*/)
+	{
+		ATLASSERT(FALSE);  // Not available in CComboBoxEx
+		return 0;
+	}
+
+	int FindString(int /*nStartAfter*/, LPCTSTR /*lpszString*/) const
+	{
+		ATLASSERT(FALSE);  // Not available in CComboBoxEx; try FindStringExact
+		return 0;
+	}
+};
+
+typedef CComboBoxExT<ATL::CWindow>   CComboBoxEx;
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMonthCalendarCtrl
+
+template <class TBase>
+class CMonthCalendarCtrlT : public TBase
+{
+public:
+// Constructors
+	CMonthCalendarCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CMonthCalendarCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return MONTHCAL_CLASS;
+	}
+
+	COLORREF GetColor(int nColorType) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, MCM_GETCOLOR, nColorType, 0L);
+	}
+
+	COLORREF SetColor(int nColorType, COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, MCM_SETCOLOR, nColorType, clr);
+	}
+
+	BOOL GetCurSel(LPSYSTEMTIME lpSysTime) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_GETCURSEL, 0, (LPARAM)lpSysTime);
+	}
+
+	BOOL SetCurSel(LPSYSTEMTIME lpSysTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETCURSEL, 0, (LPARAM)lpSysTime);
+	}
+
+	int GetFirstDayOfWeek(BOOL* pbLocaleVal = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, MCM_GETFIRSTDAYOFWEEK, 0, 0L);
+		if(pbLocaleVal != NULL)
+			*pbLocaleVal = (BOOL)HIWORD(dwRet);
+		return (int)(short)LOWORD(dwRet);
+	}
+
+	int SetFirstDayOfWeek(int nDay, BOOL* pbLocaleVal = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		DWORD dwRet = (DWORD)::SendMessage(m_hWnd, MCM_SETFIRSTDAYOFWEEK, 0, nDay);
+		if(pbLocaleVal != NULL)
+			*pbLocaleVal = (BOOL)HIWORD(dwRet);
+		return (int)(short)LOWORD(dwRet);
+	}
+
+	int GetMaxSelCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, MCM_GETMAXSELCOUNT, 0, 0L);
+	}
+
+	BOOL SetMaxSelCount(int nMax)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETMAXSELCOUNT, nMax, 0L);
+	}
+
+	int GetMonthDelta() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, MCM_GETMONTHDELTA, 0, 0L);
+	}
+
+	int SetMonthDelta(int nDelta)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, MCM_SETMONTHDELTA, nDelta, 0L);
+	}
+
+	DWORD GetRange(LPSYSTEMTIME lprgSysTimeArray) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, MCM_GETRANGE, 0, (LPARAM)lprgSysTimeArray);
+	}
+
+	BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
+	}
+
+	BOOL GetSelRange(LPSYSTEMTIME lprgSysTimeArray) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_GETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
+	}
+
+	BOOL SetSelRange(LPSYSTEMTIME lprgSysTimeArray)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETSELRANGE, 0, (LPARAM)lprgSysTimeArray);
+	}
+
+	BOOL GetToday(LPSYSTEMTIME lpSysTime) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_GETTODAY, 0, (LPARAM)lpSysTime);
+	}
+
+	void SetToday(LPSYSTEMTIME lpSysTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, MCM_SETTODAY, 0, (LPARAM)lpSysTime);
+	}
+
+	BOOL GetMinReqRect(LPRECT lpRectInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_GETMINREQRECT, 0, (LPARAM)lpRectInfo);
+	}
+
+	int GetMaxTodayWidth() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, MCM_GETMAXTODAYWIDTH, 0, 0L);
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL GetUnicodeFormat() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_GETUNICODEFORMAT, 0, 0L);
+	}
+
+	BOOL SetUnicodeFormat(BOOL bUnicode = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETUNICODEFORMAT, bUnicode, 0L);
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+	DWORD GetCurrentView() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, MCM_GETCURRENTVIEW, 0, 0L);
+	}
+
+	BOOL SetCurrentView(DWORD dwView)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETCURRENTVIEW, 0, dwView);
+	}
+
+	DWORD GetCalendarCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, MCM_GETCALENDARCOUNT, 0, 0L);
+	}
+
+	BOOL GetCalendarGridInfo(PMCGRIDINFO pGridInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_GETCALENDARGRIDINFO, 0, (LPARAM)pGridInfo);
+	}
+
+	CALID GetCALID() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (CALID)::SendMessage(m_hWnd, MCM_GETCALID, 0, 0L);
+	}
+
+	void SetCALID(CALID calid)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, MCM_SETCALID, (LPARAM)calid, 0L);
+	}
+
+	int GetCalendarBorder() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, MCM_GETCALENDARBORDER, 0, 0L);
+	}
+
+	void SetCalendarBorder(int cxyBorder, BOOL bSet = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, MCM_SETCALENDARBORDER, (WPARAM)bSet, (LPARAM)cxyBorder);
+	}
+#endif // defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+
+// Operations
+	int GetMonthRange(DWORD dwFlags, LPSYSTEMTIME lprgSysTimeArray) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, MCM_GETMONTHRANGE, dwFlags, (LPARAM)lprgSysTimeArray);
+	}
+
+	BOOL SetDayState(int nMonths, LPMONTHDAYSTATE lpDayStateArray)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, MCM_SETDAYSTATE, nMonths, (LPARAM)lpDayStateArray);
+	}
+
+	DWORD HitTest(PMCHITTESTINFO pMCHitTest) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, MCM_HITTEST, 0, (LPARAM)pMCHitTest);
+	}
+
+#if defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+	void SizeRectToMin(LPRECT lpRect)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, MCM_SIZERECTTOMIN, 0, (LPARAM)lpRect);
+	}
+#endif // defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+};
+
+typedef CMonthCalendarCtrlT<ATL::CWindow>   CMonthCalendarCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDateTimePickerCtrl
+
+template <class TBase>
+class CDateTimePickerCtrlT : public TBase
+{
+public:
+// Constructors
+	CDateTimePickerCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CDateTimePickerCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Operations
+	static LPCTSTR GetWndClassName()
+	{
+		return DATETIMEPICK_CLASS;
+	}
+
+	BOOL SetFormat(LPCTSTR lpszFormat)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DTM_SETFORMAT, 0, (LPARAM)lpszFormat);
+	}
+
+	COLORREF GetMonthCalColor(int nColorType) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, DTM_GETMCCOLOR, nColorType, 0L);
+	}
+
+	COLORREF SetMonthCalColor(int nColorType, COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, DTM_SETMCCOLOR, nColorType, clr);
+	}
+
+	DWORD GetRange(LPSYSTEMTIME lpSysTimeArray) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, DTM_GETRANGE, 0, (LPARAM)lpSysTimeArray);
+	}
+
+	BOOL SetRange(DWORD dwFlags, LPSYSTEMTIME lpSysTimeArray)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DTM_SETRANGE, dwFlags, (LPARAM)lpSysTimeArray);
+	}
+
+	DWORD GetSystemTime(LPSYSTEMTIME lpSysTime) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, DTM_GETSYSTEMTIME, 0, (LPARAM)lpSysTime);
+	}
+
+	BOOL SetSystemTime(DWORD dwFlags, LPSYSTEMTIME lpSysTime)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DTM_SETSYSTEMTIME, dwFlags, (LPARAM)lpSysTime);
+	}
+
+	CMonthCalendarCtrl GetMonthCal() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CMonthCalendarCtrl((HWND)::SendMessage(m_hWnd, DTM_GETMONTHCAL, 0, 0L));
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	CFontHandle GetMonthCalFont() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CFontHandle((HFONT)::SendMessage(m_hWnd, DTM_GETMCFONT, 0, 0L));
+	}
+
+	void SetMonthCalFont(HFONT hFont, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_SETMCFONT, (WPARAM)hFont, MAKELPARAM(bRedraw, 0));
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+	DWORD GetMonthCalStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, DTM_GETMCSTYLE, 0, 0L);
+	}
+
+	DWORD SetMonthCalStyle(DWORD dwStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (DWORD)::SendMessage(m_hWnd, DTM_SETMCSTYLE, 0, (LPARAM)dwStyle);
+	}
+
+	void GetDateTimePickerInfo(LPDATETIMEPICKERINFO lpPickerInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_GETDATETIMEPICKERINFO, 0, (LPARAM)lpPickerInfo);
+	}
+
+	BOOL GetIdealSize(LPSIZE lpSize) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DTM_GETIDEALSIZE, 0, (LPARAM)lpSize);
+	}
+
+	void CloseMonthCal()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_CLOSEMONTHCAL, 0, 0L);
+	}
+#endif // defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+};
+
+typedef CDateTimePickerCtrlT<ATL::CWindow>   CDateTimePickerCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFlatScrollBarImpl - support for flat scroll bars
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+template <class T>
+class CFlatScrollBarImpl
+{
+public:
+// Initialization
+	BOOL FlatSB_Initialize()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::InitializeFlatSB(pT->m_hWnd);
+	}
+
+	HRESULT FlatSB_Uninitialize()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::UninitializeFlatSB(pT->m_hWnd);
+	}
+
+// Flat scroll bar properties
+	BOOL FlatSB_GetScrollProp(UINT uIndex, LPINT lpnValue) const
+	{
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_GetScrollProp(pT->m_hWnd, uIndex, lpnValue);
+	}
+
+	BOOL FlatSB_SetScrollProp(UINT uIndex, int nValue, BOOL bRedraw = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_SetScrollProp(pT->m_hWnd, uIndex, nValue, bRedraw);
+	}
+
+// Attributes
+	int FlatSB_GetScrollPos(int nBar) const
+	{
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_GetScrollPos(pT->m_hWnd, nBar);
+	}
+
+	int FlatSB_SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_SetScrollPos(pT->m_hWnd, nBar, nPos, bRedraw);
+	}
+
+	BOOL FlatSB_GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const
+	{
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_GetScrollRange(pT->m_hWnd, nBar, lpMinPos, lpMaxPos);
+	}
+
+	BOOL FlatSB_SetScrollRange(int nBar, int nMinPos, int nMaxPos, BOOL bRedraw = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_SetScrollRange(pT->m_hWnd, nBar, nMinPos, nMaxPos, bRedraw);
+	}
+
+	BOOL FlatSB_GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo) const
+	{
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_GetScrollInfo(pT->m_hWnd, nBar, lpScrollInfo);
+	}
+
+	int FlatSB_SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_SetScrollInfo(pT->m_hWnd, nBar, lpScrollInfo, bRedraw);
+	}
+
+// Operations
+	BOOL FlatSB_ShowScrollBar(UINT nBar, BOOL bShow = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_ShowScrollBar(pT->m_hWnd, nBar, bShow);
+	}
+
+	BOOL FlatSB_EnableScrollBar(UINT uSBFlags, UINT uArrowFlags = ESB_ENABLE_BOTH)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::FlatSB_EnableScrollBar(pT->m_hWnd, uSBFlags, uArrowFlags);
+	}
+};
+
+template <class TBase>
+class CFlatScrollBarT : public TBase, public CFlatScrollBarImpl<CFlatScrollBarT< TBase > >
+{
+public:
+	CFlatScrollBarT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CFlatScrollBarT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+};
+
+typedef CFlatScrollBarT<ATL::CWindow>   CFlatScrollBar;
+
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CIPAddressCtrl
+
+#if (_WIN32_IE >= 0x0400)
+
+template <class TBase>
+class CIPAddressCtrlT : public TBase
+{
+public:
+// Constructors
+	CIPAddressCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CIPAddressCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Atteributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_IPADDRESS;
+	}
+
+	BOOL IsBlank() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, IPM_ISBLANK, 0, 0L);
+	}
+
+	int GetAddress(LPDWORD lpdwAddress) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, IPM_GETADDRESS, 0, (LPARAM)lpdwAddress);
+	}
+
+	void SetAddress(DWORD dwAddress)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IPM_SETADDRESS, 0, dwAddress);
+	}
+
+	void ClearAddress()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IPM_CLEARADDRESS, 0, 0L);
+	}
+
+	void SetRange(int nField, WORD wRange)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IPM_SETRANGE, nField, wRange);
+	}
+
+	void SetRange(int nField, BYTE nMin, BYTE nMax)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IPM_SETRANGE, nField, MAKEIPRANGE(nMin, nMax));
+	}
+
+	void SetFocus(int nField)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IPM_SETFOCUS, nField, 0L);
+	}
+};
+
+typedef CIPAddressCtrlT<ATL::CWindow>   CIPAddressCtrl;
+
+#endif // (_WIN32_IE >= 0x0400)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPagerCtrl
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+template <class TBase>
+class CPagerCtrlT : public TBase
+{
+public:
+// Constructors
+	CPagerCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CPagerCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_PAGESCROLLER;
+	}
+
+	int GetButtonSize() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PGM_GETBUTTONSIZE, 0, 0L);
+	}
+
+	int SetButtonSize(int nButtonSize)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PGM_SETBUTTONSIZE, 0, nButtonSize);
+	}
+
+	DWORD GetButtonState(int nButton) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nButton == PGB_TOPORLEFT || nButton == PGB_BOTTOMORRIGHT);
+		return (DWORD)::SendMessage(m_hWnd, PGM_GETBUTTONSTATE, 0, nButton);
+	}
+
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, PGM_GETBKCOLOR, 0, 0L);
+	}
+
+	COLORREF SetBkColor(COLORREF clrBk)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (COLORREF)::SendMessage(m_hWnd, PGM_SETBKCOLOR, 0, (LPARAM)clrBk);
+	}
+
+	int GetBorder() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PGM_GETBORDER, 0, 0L);
+	}
+
+	int SetBorder(int nBorderSize)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PGM_SETBORDER, 0, nBorderSize);
+	}
+
+	int GetPos() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PGM_GETPOS, 0, 0L);
+	}
+
+	int SetPos(int nPos)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PGM_SETPOS, 0, nPos);
+	}
+
+// Operations
+	void SetChild(HWND hWndChild)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PGM_SETCHILD, 0, (LPARAM)hWndChild);
+	}
+
+	void ForwardMouse(BOOL bForward = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PGM_FORWARDMOUSE, bForward, 0L);
+	}
+
+	void RecalcSize()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PGM_RECALCSIZE, 0, 0L);
+	}
+
+	void GetDropTarget(IDropTarget** ppDropTarget)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(ppDropTarget != NULL);
+		::SendMessage(m_hWnd, PGM_GETDROPTARGET, 0, (LPARAM)ppDropTarget);
+	}
+};
+
+typedef CPagerCtrlT<ATL::CWindow>   CPagerCtrl;
+
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CLinkCtrl - Windows SYSLINK control
+
+#if (_WIN32_WINNT >= 0x0501) && !defined(_WIN32_WCE)
+
+template <class TBase>
+class CLinkCtrlT : public TBase
+{
+public:
+// Constructors
+	CLinkCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CLinkCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		return TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+#ifdef _UNICODE
+		return WC_LINK;
+#else // !_UNICODE
+		return "SysLink";
+#endif // !_UNICODE
+	}
+
+	int GetIdealHeight(int cxMaxWidth = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LM_GETIDEALHEIGHT, cxMaxWidth, 0L);
+	}
+
+	BOOL GetItem(PLITEM pLItem) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LM_GETITEM, 0, (LPARAM)pLItem);
+	}
+
+	BOOL SetItem(PLITEM pLItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LM_SETITEM, 0, (LPARAM)pLItem);
+	}
+
+	// Vista only
+	int GetIdealSize(SIZE& size, int cxMaxWidth = 0) const
+	{
+#ifndef LM_GETIDEALSIZE
+		const UINT LM_GETIDEALSIZE = LM_GETIDEALHEIGHT;
+#endif
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, LM_GETIDEALSIZE, cxMaxWidth, (LPARAM)&size);
+	}
+
+// Operations
+	BOOL HitTest(PLHITTESTINFO pLHitTestInfo) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, LM_HITTEST, 0, (LPARAM)pLHitTestInfo);
+	}
+};
+
+typedef CLinkCtrlT<ATL::CWindow>   CLinkCtrl;
+
+#endif // (_WIN32_WINNT >= 0x0501) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCustomDraw - MI class for custom-draw support
+
+template <class T>
+class CCustomDraw
+{
+public:
+#if (_ATL_VER < 0x0700)
+	BOOL m_bHandledCD;
+
+	BOOL IsMsgHandled() const
+	{
+		return m_bHandledCD;
+	}
+
+	void SetMsgHandled(BOOL bHandled)
+	{
+		m_bHandledCD = bHandled;
+	}
+#endif // !(_ATL_VER < 0x0700)
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CCustomDraw< T >)
+		NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
+	ALT_MSG_MAP(1)
+		REFLECTED_NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnCustomDraw)
+	END_MSG_MAP()
+
+// message handler
+	LRESULT OnCustomDraw(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetMsgHandled(TRUE);
+		LPNMCUSTOMDRAW lpNMCustomDraw = (LPNMCUSTOMDRAW)pnmh;
+		DWORD dwRet = 0;
+		switch(lpNMCustomDraw->dwDrawStage)
+		{
+		case CDDS_PREPAINT:
+			dwRet = pT->OnPrePaint(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_POSTPAINT:
+			dwRet = pT->OnPostPaint(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_PREERASE:
+			dwRet = pT->OnPreErase(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_POSTERASE:
+			dwRet = pT->OnPostErase(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_ITEMPREPAINT:
+			dwRet = pT->OnItemPrePaint(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_ITEMPOSTPAINT:
+			dwRet = pT->OnItemPostPaint(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_ITEMPREERASE:
+			dwRet = pT->OnItemPreErase(idCtrl, lpNMCustomDraw);
+			break;
+		case CDDS_ITEMPOSTERASE:
+			dwRet = pT->OnItemPostErase(idCtrl, lpNMCustomDraw);
+			break;
+#if (_WIN32_IE >= 0x0400)
+		case (CDDS_ITEMPREPAINT | CDDS_SUBITEM):
+			dwRet = pT->OnSubItemPrePaint(idCtrl, lpNMCustomDraw);
+			break;
+#endif // (_WIN32_IE >= 0x0400)
+		default:
+			pT->SetMsgHandled(FALSE);
+			break;
+		}
+		bHandled = pT->IsMsgHandled();
+		return dwRet;
+	}
+
+// Overrideables
+	DWORD OnPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnPreErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnPostErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnItemPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnItemPreErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+	DWORD OnItemPostErase(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	DWORD OnSubItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_DODEFAULT;
+	}
+#endif // (_WIN32_IE >= 0x0400)
+};
+
+
+// --- Windows CE common controls ---
+
+#ifdef _WIN32_WCE
+
+///////////////////////////////////////////////////////////////////////////////
+// CCECommandBarCtrl
+
+template <class TBase>
+class CCECommandBarCtrlT : public TBase
+{
+public:
+// Constructors
+	CCECommandBarCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }
+
+	CCECommandBarCtrlT< TBase >& operator=(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Attributes
+	BOOL IsVisible() const
+	{
+		return IsWindowVisible();
+	}
+
+	int GetHeight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_Height(m_hWnd);
+	}
+
+	HMENU GetMenu(WORD wButton) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_GetMenu(m_hWnd, wButton);
+	}
+
+// Operations
+	HWND Create(HWND hWndParent, int nCmdBarID)
+	{
+		m_hWnd = ::CommandBar_Create(ModuleHelper::GetModuleInstance(), hWndParent, nCmdBarID);
+		ATLASSERT(::IsWindow(m_hWnd));
+		return m_hWnd;
+	}
+
+	void Destroy()
+	{
+		DestroyWindow();
+	}
+
+	BOOL Show(BOOL bShow = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_Show(m_hWnd, bShow);
+	}
+
+	BOOL DrawMenuBar(WORD wButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_DrawMenuBar(m_hWnd, wButton);
+	}
+
+	BOOL AddAdornments(DWORD dwFlags = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_AddAdornments(m_hWnd, dwFlags, 0);
+	}
+
+	int AddBitmap(int nBitmapID, int nNumImages)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_AddBitmap(m_hWnd, ModuleHelper::GetResourceInstance(), nBitmapID, nNumImages, 16, 16);
+	}
+
+	BOOL AddButtons(UINT uNumButtons, LPTBBUTTON lpButtons)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CommandBar_AddButtons(m_hWnd, uNumButtons, lpButtons);
+	}
+
+	BOOL AddToolTips(UINT uNumToolTips, LPTSTR lpToolTips)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CommandBar_AddToolTips(m_hWnd, uNumToolTips, lpToolTips);
+	}
+
+	BOOL InsertButton(int nButton, LPTBBUTTON lpButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CommandBar_InsertButton(m_hWnd, nButton, lpButton);
+	}
+
+	HWND InsertComboBox(int nWidth, UINT dwStyle, WORD wComboBoxID, WORD wButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_InsertComboBox(m_hWnd, ModuleHelper::GetModuleInstance(), nWidth, dwStyle, wComboBoxID, wButton);
+	}
+
+	BOOL InsertMenubar(WORD wMenuID, WORD wButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_InsertMenubar(m_hWnd, ModuleHelper::GetResourceInstance(), wMenuID, wButton);
+	}
+
+	BOOL InsertMenubarEx(ATL::_U_STRINGorID menu, WORD wButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBar_InsertMenubarEx(m_hWnd, ModuleHelper::GetResourceInstance(), (LPTSTR)menu.m_lpstr, wButton);
+	}
+
+	BOOL IsCommandBarMessage(LPMSG lpMsg)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::IsCommandBarMessage(m_hWnd, lpMsg);
+	}
+};
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC MenuBar
+	typedef CCECommandBarCtrlT<CToolBarCtrl>	CMenuBarCtrl;
+#else
+	typedef CCECommandBarCtrlT<CToolBarCtrl>	CCECommandBarCtrl;
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__)
+
+///////////////////////////////////////////////////////////////////////////////
+// CCECommandBandsCtrl
+
+template <class TBase>
+class CCECommandBandsCtrlT : public TBase
+{
+public:
+// Constructors
+	CCECommandBandsCtrlT(HWND hWnd = NULL) : TBase(hWnd) { }
+
+	CCECommandBandsCtrlT< TBase >& operator=(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Attributes
+	BOOL IsVisible() const
+	{
+		return IsWindowVisible();
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	UINT GetHeight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CommandBands_Height(m_hWnd);
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+	HWND GetCommandBar(UINT uBand) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBands_GetCommandBar(m_hWnd, uBand);
+	}
+
+	BOOL GetRestoreInformation(UINT uBand, LPCOMMANDBANDSRESTOREINFO pcbr) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBands_GetRestoreInformation(m_hWnd, uBand, pcbr);
+	}
+
+// Operations
+	HWND Create(HWND hWndParent, UINT wID, DWORD dwStyles, HIMAGELIST hImageList = NULL)
+	{
+		m_hWnd = ::CommandBands_Create(ModuleHelper::GetModuleInstance(), hWndParent, wID, dwStyles, hImageList);
+		ATLASSERT(::IsWindow(m_hWnd));
+		return m_hWnd;
+	}
+
+	BOOL AddAdornments(DWORD dwFlags = 0, LPREBARBANDINFO prbbi = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBands_AddAdornments(m_hWnd, ModuleHelper::GetModuleInstance(), dwFlags, prbbi);
+	}
+
+	BOOL AddBands(UINT uBandCount, LPREBARBANDINFO prbbi)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBands_AddBands(m_hWnd, ModuleHelper::GetModuleInstance(), uBandCount, prbbi);
+	}
+
+	BOOL Show(BOOL bShow = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::CommandBands_Show(m_hWnd, bShow);
+	}
+};
+
+typedef CCECommandBandsCtrlT<ATL::CWindow>	CCECommandBandsCtrl;
+
+#endif // _WIN32_WCE
+
+}; // namespace WTL
+
+#endif // __ATLCTRLS_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlctrlw.h b/GLideN64/src/GLideNUI-wtl/WTL/atlctrlw.h
new file mode 100644
index 00000000..ade76d45
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlctrlw.h
@@ -0,0 +1,4157 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLCTRLW_H__
+#define __ATLCTRLW_H__
+
+#pragma once
+
+#ifdef _WIN32_WCE
+	#error atlctrlw.h is not supported on Windows CE
+#endif
+
+#ifndef __ATLAPP_H__
+	#error atlctrlw.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLCTRLS_H__
+	#error atlctrlw.h requires atlctrls.h to be included first
+#endif
+
+#if (_WIN32_IE < 0x0400)
+	#error atlctrlw.h requires _WIN32_IE >= 0x0400
+#endif
+
+// Define _WTL_CMDBAR_VISTA_MENUS as 0 to exclude Vista menus support
+#if !defined(_WTL_CMDBAR_VISTA_MENUS) && (WINVER >= 0x0500) && (_WIN32_WINNT >= 0x0501) && (_WIN32_IE >= 0x0501)
+  #define _WTL_CMDBAR_VISTA_MENUS 1
+#endif
+
+#if _WTL_CMDBAR_VISTA_MENUS
+  #if !((_WIN32_WINNT >= 0x0501) && (_WIN32_IE >= 0x0501))
+	#error _WTL_CMDBAR_VISTA_MENUS requires (_WIN32_WINNT >= 0x0501) && (_WIN32_IE >= 0x0501)
+  #endif
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CCommandBarCtrlImpl<T, TBase, TWinTraits>
+// CCommandBarCtrl
+// CMDICommandBarCtrlImpl<T, TBase, TWinTraits>
+// CMDICommandBarCtrl
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// Command Bars
+
+// Window Styles:
+#define CBRWS_TOP		CCS_TOP
+#define CBRWS_BOTTOM		CCS_BOTTOM
+#define CBRWS_NORESIZE		CCS_NORESIZE
+#define CBRWS_NOPARENTALIGN	CCS_NOPARENTALIGN
+#define CBRWS_NODIVIDER		CCS_NODIVIDER
+
+// Extended styles
+#define CBR_EX_TRANSPARENT	0x00000001L
+#define CBR_EX_SHAREMENU	0x00000002L
+#define CBR_EX_ALTFOCUSMODE	0x00000004L
+#define CBR_EX_TRACKALWAYS	0x00000008L
+#define CBR_EX_NOVISTAMENUS	0x00000010L
+
+// standard command bar styles
+#define ATL_SIMPLE_CMDBAR_PANE_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CBRWS_NODIVIDER | CBRWS_NORESIZE | CBRWS_NOPARENTALIGN)
+
+// Messages - support chevrons for frame windows
+#define CBRM_GETCMDBAR			(WM_USER + 301) // returns command bar HWND
+#define CBRM_GETMENU			(WM_USER + 302) // returns loaded or attached menu
+#define CBRM_TRACKPOPUPMENU		(WM_USER + 303) // displays a popup menu
+
+typedef struct tagCBRPOPUPMENU
+{
+	int cbSize;
+	HMENU hMenu;         // popup menu do display
+	UINT uFlags;         // TPM_* flags for ::TrackPopupMenuEx
+	int x;
+	int y;
+	LPTPMPARAMS lptpm;   // ptr to TPMPARAMS for ::TrackPopupMenuEx
+} CBRPOPUPMENU, *LPCBRPOPUPMENU;
+
+// helper class
+template <class T>
+class CSimpleStack : public ATL::CSimpleArray< T >
+{
+public:
+	BOOL Push(T t)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - STACK-PUSH (%8.8X) size = %i\n"), t, GetSize());
+#endif
+		return Add(t);
+	}
+
+	T Pop()
+	{
+		int nLast = GetSize() - 1;
+		if(nLast < 0)
+			return NULL;   // must be able to convert to NULL
+		T t = m_aT[nLast];
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - STACK-POP (%8.8X) size = %i\n"), t, GetSize());
+#endif
+		if(!RemoveAt(nLast))
+			return NULL;
+		return t;
+	}
+
+	T GetCurrent()
+	{
+		int nLast = GetSize() - 1;
+		if(nLast < 0)
+			return NULL;   // must be able to convert to NULL
+		return m_aT[nLast];
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCommandBarCtrlBase - base class for the Command Bar implementation
+
+class CCommandBarCtrlBase : public CToolBarCtrl
+{
+public:
+	struct _MsgHookData
+	{
+		HHOOK hMsgHook;
+		DWORD dwUsage;
+
+		_MsgHookData() : hMsgHook(NULL), dwUsage(0)
+		{ }
+	};
+
+	typedef ATL::CSimpleMap<DWORD, _MsgHookData*>   CMsgHookMap;
+	static CMsgHookMap* s_pmapMsgHook;
+
+	static HHOOK s_hCreateHook;
+	static bool s_bW2K;  // For animation flag
+	static CCommandBarCtrlBase* s_pCurrentBar;
+	static bool s_bStaticInit;
+
+	CSimpleStack<HWND> m_stackMenuWnd;
+	CSimpleStack<HMENU> m_stackMenuHandle;
+
+	HWND m_hWndHook;
+	DWORD m_dwMagic;
+
+
+	CCommandBarCtrlBase() : m_hWndHook(NULL), m_dwMagic(1314)
+	{
+		// init static variables
+		if(!s_bStaticInit)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CCommandBarCtrlBase::CCommandBarCtrlBase.\n"));
+				ATLASSERT(FALSE);
+				return;
+			}
+
+			if(!s_bStaticInit)
+			{
+				// Just in case...
+				AtlInitCommonControls(ICC_COOL_CLASSES | ICC_BAR_CLASSES);
+				// Animation on Win2000 only
+				s_bW2K = !AtlIsOldWindows();
+				// done
+				s_bStaticInit = true;
+			}
+
+			lock.Unlock();
+		}
+	}
+
+	bool IsCommandBarBase() const { return m_dwMagic == 1314; }
+};
+
+__declspec(selectany) CCommandBarCtrlBase::CMsgHookMap* CCommandBarCtrlBase::s_pmapMsgHook = NULL;
+__declspec(selectany) HHOOK CCommandBarCtrlBase::s_hCreateHook = NULL;
+__declspec(selectany) CCommandBarCtrlBase* CCommandBarCtrlBase::s_pCurrentBar = NULL;
+__declspec(selectany) bool CCommandBarCtrlBase::s_bW2K = false;
+__declspec(selectany) bool CCommandBarCtrlBase::s_bStaticInit = false;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCommandBarCtrl - ATL implementation of Command Bars
+
+template <class T, class TBase = CCommandBarCtrlBase, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CCommandBarCtrlImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >
+{
+public:
+	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())
+
+// Declarations
+	struct _MenuItemData	// menu item data
+	{
+		DWORD dwMagic;
+		LPTSTR lpstrText;
+		UINT fType;
+		UINT fState;
+		int iButton;
+
+		_MenuItemData() { dwMagic = 0x1313; }
+		bool IsCmdBarMenuItem() { return (dwMagic == 0x1313); }
+	};
+
+	struct _ToolBarData	// toolbar resource data
+	{
+		WORD wVersion;
+		WORD wWidth;
+		WORD wHeight;
+		WORD wItemCount;
+		//WORD aItems[wItemCount]
+
+		WORD* items()
+			{ return (WORD*)(this+1); }
+	};
+
+// Constants
+	enum _CmdBarDrawConstants
+	{
+		s_kcxGap = 1,
+		s_kcxTextMargin = 2,
+		s_kcxButtonMargin = 3,
+		s_kcyButtonMargin = 3
+	};
+
+	enum
+	{
+		_nMaxMenuItemTextLength = 100,
+		_chChevronShortcut = _T('/')
+	};
+
+#ifndef DT_HIDEPREFIX
+	enum { DT_HIDEPREFIX = 0x00100000 };
+#endif // !DT_HIDEPREFIX
+
+// Data members
+	HMENU m_hMenu;
+	HIMAGELIST m_hImageList;
+	ATL::CSimpleValArray<WORD> m_arrCommand;
+
+	DWORD m_dwExtendedStyle;   // Command Bar specific extended styles
+
+	ATL::CContainedWindow m_wndParent;
+
+	bool m_bMenuActive:1;
+	bool m_bAttachedMenu:1;
+	bool m_bImagesVisible:1;
+	bool m_bPopupItem:1;
+	bool m_bContextMenu:1;
+	bool m_bEscapePressed:1;
+	bool m_bSkipMsg:1;
+	bool m_bParentActive:1;
+	bool m_bFlatMenus:1;
+	bool m_bUseKeyboardCues:1;
+	bool m_bShowKeyboardCues:1;
+	bool m_bAllowKeyboardCues:1;
+	bool m_bKeyboardInput:1;
+	bool m_bAlphaImages:1;
+	bool m_bLayoutRTL:1;
+	bool m_bSkipPostDown:1;
+	bool m_bVistaMenus:1;
+
+	int m_nPopBtn;
+	int m_nNextPopBtn;
+
+	SIZE m_szBitmap;
+	SIZE m_szButton;
+
+	COLORREF m_clrMask;
+	CFont m_fontMenu;   // used internally, only to measure text
+
+	UINT m_uSysKey;
+
+	HWND m_hWndFocus;   // Alternate focus mode
+
+	int m_cxExtraSpacing;
+
+#if _WTL_CMDBAR_VISTA_MENUS
+	ATL::CSimpleValArray<HBITMAP> m_arrVistaBitmap;   // Bitmaps for Vista menus
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+// Constructor/destructor
+	CCommandBarCtrlImpl() : 
+			m_hMenu(NULL), 
+			m_hImageList(NULL), 
+			m_wndParent(this, 1), 
+			m_bMenuActive(false), 
+			m_bAttachedMenu(false), 
+			m_nPopBtn(-1), 
+			m_nNextPopBtn(-1), 
+			m_bPopupItem(false),
+			m_bImagesVisible(true),
+			m_bSkipMsg(false),
+			m_uSysKey(0),
+			m_hWndFocus(NULL),
+			m_bContextMenu(false),
+			m_bEscapePressed(false),
+			m_clrMask(RGB(192, 192, 192)),
+			m_dwExtendedStyle(CBR_EX_TRANSPARENT | CBR_EX_SHAREMENU | CBR_EX_TRACKALWAYS),
+			m_bParentActive(true),
+			m_bFlatMenus(false),
+			m_bUseKeyboardCues(false),
+			m_bShowKeyboardCues(false),
+			m_bAllowKeyboardCues(true),
+			m_bKeyboardInput(false),
+			m_cxExtraSpacing(0),
+			m_bAlphaImages(false),
+			m_bLayoutRTL(false),
+			m_bSkipPostDown(false),
+			m_bVistaMenus(false)
+	{
+		SetImageSize(16, 15);   // default
+ 	}
+
+	~CCommandBarCtrlImpl()
+	{
+		if(m_wndParent.IsWindow())
+/*scary!*/			m_wndParent.UnsubclassWindow();
+
+		if(m_hMenu != NULL && (m_dwExtendedStyle & CBR_EX_SHAREMENU) == 0)
+			::DestroyMenu(m_hMenu);
+
+		if(m_hImageList != NULL)
+			::ImageList_Destroy(m_hImageList);
+	}
+
+// Attributes
+	DWORD GetCommandBarExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+	DWORD SetCommandBarExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		return dwPrevStyle;
+	}
+
+	CMenuHandle GetMenu() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return m_hMenu;
+	}
+
+	COLORREF GetImageMaskColor() const
+	{
+		return m_clrMask;
+	}
+
+	COLORREF SetImageMaskColor(COLORREF clrMask)
+	{
+		COLORREF clrOld = m_clrMask;
+		m_clrMask = clrMask;
+		return clrOld;
+	}
+
+	bool GetImagesVisible() const
+	{
+		return m_bImagesVisible;
+	}
+
+	bool SetImagesVisible(bool bVisible)
+	{
+		bool bOld = m_bImagesVisible;
+		m_bImagesVisible = bVisible;
+		return bOld;
+	}
+
+	void GetImageSize(SIZE& size) const
+	{
+		size = m_szBitmap;
+	}
+
+	bool SetImageSize(SIZE& size)
+	{
+		return SetImageSize(size.cx, size.cy);
+	}
+
+	bool SetImageSize(int cx, int cy)
+	{
+		if(m_hImageList != NULL)
+		{
+			if(::ImageList_GetImageCount(m_hImageList) == 0)   // empty
+			{
+				::ImageList_Destroy(m_hImageList);
+				m_hImageList = NULL;
+			}
+			else
+			{
+				return false;   // can't set, image list exists
+			}
+		}
+
+		if(cx == 0 || cy == 0)
+			return false;
+
+		m_szBitmap.cx = cx;
+		m_szBitmap.cy = cy;
+		m_szButton.cx = m_szBitmap.cx + 2 * s_kcxButtonMargin;
+		m_szButton.cy = m_szBitmap.cy + 2 * s_kcyButtonMargin;
+
+		return true;
+	}
+
+	bool GetAlphaImages() const
+	{
+		return m_bAlphaImages;
+	}
+
+	bool SetAlphaImages(bool bAlphaImages)
+	{
+		if(m_hImageList != NULL)
+		{
+			if(::ImageList_GetImageCount(m_hImageList) == 0)   // empty
+			{
+				::ImageList_Destroy(m_hImageList);
+				m_hImageList = NULL;
+			}
+			else
+			{
+				return false;   // can't set, image list exists
+			}
+		}
+
+		m_bAlphaImages = bAlphaImages;
+		return true;
+	}
+
+	HWND GetCmdBar() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HWND)::SendMessage(m_hWnd, CBRM_GETCMDBAR, 0, 0L);
+	}
+
+// Methods
+	HWND Create(HWND hWndParent, RECT& rcPos, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			UINT nID = 0, LPVOID lpCreateParam = NULL)
+	{
+		// These styles are required for command bars
+		dwStyle |= TBSTYLE_LIST | TBSTYLE_FLAT;
+#if (_MSC_VER >= 1300)
+		return ATL::CWindowImpl< T, TBase, TWinTraits >::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImpl< T, TBase, TWinTraits >   _baseClass;
+		return _baseClass::Create(hWndParent, rcPos, szWindowName, dwStyle, dwExStyle, nID, lpCreateParam);
+#endif // !(_MSC_VER >= 1300)
+	}
+
+	BOOL AttachToWindow(HWND hWnd)
+	{
+		ATLASSERT(m_hWnd == NULL);
+		ATLASSERT(::IsWindow(hWnd));
+		BOOL bRet = SubclassWindow(hWnd);
+		if(bRet)
+		{
+			m_bAttachedMenu = true;
+			T* pT = static_cast<T*>(this);
+			pT->GetSystemSettings();
+		}
+		return bRet;
+	}
+
+	BOOL LoadMenu(ATL::_U_STRINGorID menu)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		if(m_bAttachedMenu)   // doesn't work in this mode
+			return FALSE;
+		if(menu.m_lpstr == NULL)
+			return FALSE;
+
+		HMENU hMenu = ::LoadMenu(ModuleHelper::GetResourceInstance(), menu.m_lpstr);
+		if(hMenu == NULL)
+			return FALSE;
+
+		return AttachMenu(hMenu);
+	}
+
+	BOOL AttachMenu(HMENU hMenu)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hMenu == NULL || ::IsMenu(hMenu));
+		if(hMenu != NULL && !::IsMenu(hMenu))
+			return FALSE;
+
+#if _WTL_CMDBAR_VISTA_MENUS
+		// remove Vista bitmaps if used
+		if(m_bVistaMenus && (m_hMenu != NULL))
+		{
+			T* pT = static_cast<T*>(this);
+			pT->_RemoveVistaBitmapsFromMenu();
+		}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+		// destroy old menu, if needed, and set new one
+		if(m_hMenu != NULL && (m_dwExtendedStyle & CBR_EX_SHAREMENU) == 0)
+			::DestroyMenu(m_hMenu);
+
+		m_hMenu = hMenu;
+
+		if(m_bAttachedMenu)   // Nothing else in this mode
+			return TRUE;
+
+		// Build buttons according to menu
+		SetRedraw(FALSE);
+
+		// Clear all buttons
+		int nCount = GetButtonCount();
+		for(int i = 0; i < nCount; i++)
+			ATLVERIFY(DeleteButton(0) != FALSE);
+
+		// Add buttons for each menu item
+		if(m_hMenu != NULL)
+		{
+			int nItems = ::GetMenuItemCount(m_hMenu);
+
+			T* pT = static_cast<T*>(this);
+			pT;   // avoid level 4 warning
+			TCHAR szString[pT->_nMaxMenuItemTextLength];
+			for(int i = 0; i < nItems; i++)
+			{
+				CMenuItemInfo mii;
+				mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_SUBMENU;
+				mii.fType = MFT_STRING;
+				mii.dwTypeData = szString;
+				mii.cch = pT->_nMaxMenuItemTextLength;
+				BOOL bRet = ::GetMenuItemInfo(m_hMenu, i, TRUE, &mii);
+				ATLASSERT(bRet);
+				// If we have more than the buffer, we assume we have bitmaps bits
+				if(lstrlen(szString) > pT->_nMaxMenuItemTextLength - 1)
+				{
+					mii.fType = MFT_BITMAP;
+					::SetMenuItemInfo(m_hMenu, i, TRUE, &mii);
+					szString[0] = 0;
+				}
+
+				// NOTE: Command Bar currently supports only drop-down menu items
+				ATLASSERT(mii.hSubMenu != NULL);
+
+				TBBUTTON btn = { 0 };
+				btn.iBitmap = 0;
+				btn.idCommand = i;
+				btn.fsState = (BYTE)(((mii.fState & MFS_DISABLED) == 0) ? TBSTATE_ENABLED : 0);
+				btn.fsStyle = TBSTYLE_BUTTON | TBSTYLE_AUTOSIZE | TBSTYLE_DROPDOWN;
+				btn.dwData = 0;
+				btn.iString = 0;
+
+				bRet = InsertButton(-1, &btn);
+				ATLASSERT(bRet);
+
+				TBBUTTONINFO bi = { 0 };
+				bi.cbSize = sizeof(TBBUTTONINFO);
+				bi.dwMask = TBIF_TEXT;
+				bi.pszText = szString;
+
+				bRet = SetButtonInfo(i, &bi);
+				ATLASSERT(bRet);
+			}
+		}
+
+		SetRedraw(TRUE);
+		Invalidate();
+		UpdateWindow();
+
+		return TRUE;
+	}
+
+	BOOL LoadImages(ATL::_U_STRINGorID image)
+	{
+		return _LoadImagesHelper(image, false);
+	}
+
+	BOOL LoadMappedImages(UINT nIDImage, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
+	{
+		return _LoadImagesHelper(nIDImage, true, nFlags , lpColorMap, nMapSize);
+	}
+
+	BOOL _LoadImagesHelper(ATL::_U_STRINGorID image, bool bMapped, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HINSTANCE hInstance = ModuleHelper::GetResourceInstance();
+
+		HRSRC hRsrc = ::FindResource(hInstance, image.m_lpstr, (LPTSTR)RT_TOOLBAR);
+		if(hRsrc == NULL)
+			return FALSE;
+
+		HGLOBAL hGlobal = ::LoadResource(hInstance, hRsrc);
+		if(hGlobal == NULL)
+			return FALSE;
+
+		_ToolBarData* pData = (_ToolBarData*)::LockResource(hGlobal);
+		if(pData == NULL)
+			return FALSE;
+		ATLASSERT(pData->wVersion == 1);
+
+		WORD* pItems = pData->items();
+		int nItems = pData->wItemCount;
+
+		// Set internal data
+		SetImageSize(pData->wWidth, pData->wHeight);
+
+		// Create image list if needed
+		if(m_hImageList == NULL)
+		{
+			// Check if the bitmap is 32-bit (alpha channel) bitmap (valid for Windows XP only)
+			T* pT = static_cast<T*>(this);
+			m_bAlphaImages = AtlIsAlphaBitmapResource(image);
+
+			if(!pT->CreateInternalImageList(pData->wItemCount))
+				return FALSE;
+		}
+
+#if _WTL_CMDBAR_VISTA_MENUS
+		int nOldImageCount = ::ImageList_GetImageCount(m_hImageList);
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+		// Add bitmap to our image list
+		CBitmap bmp;
+		if(bMapped)
+		{
+			ATLASSERT(HIWORD(PtrToUlong(image.m_lpstr)) == 0);   // if mapped, must be a numeric ID
+			int nIDImage = (int)(short)LOWORD(PtrToUlong(image.m_lpstr));
+			bmp.LoadMappedBitmap(nIDImage, (WORD)nFlags, lpColorMap, nMapSize);
+		}
+		else
+		{
+			if(m_bAlphaImages)
+				bmp = (HBITMAP)::LoadImage(ModuleHelper::GetResourceInstance(), image.m_lpstr, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
+			else
+				bmp.LoadBitmap(image.m_lpstr);
+		}
+		ATLASSERT(bmp.m_hBitmap != NULL);
+		if(bmp.m_hBitmap == NULL)
+			return FALSE;
+		if(::ImageList_AddMasked(m_hImageList, bmp, m_clrMask) == -1)
+			return FALSE;
+
+		// Fill the array with command IDs
+		for(int i = 0; i < nItems; i++)
+		{
+			if(pItems[i] != 0)
+				m_arrCommand.Add(pItems[i]);
+		}
+
+		int nImageCount = ::ImageList_GetImageCount(m_hImageList);
+		ATLASSERT(nImageCount == m_arrCommand.GetSize());
+		if(nImageCount != m_arrCommand.GetSize())
+			return FALSE;
+
+#if _WTL_CMDBAR_VISTA_MENUS
+		if(RunTimeHelper::IsVista())
+		{
+			T* pT = static_cast<T*>(this);
+			pT->_AddVistaBitmapsFromImageList(nOldImageCount, nImageCount - nOldImageCount);
+			ATLASSERT(nImageCount == m_arrVistaBitmap.GetSize());
+		}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+		return TRUE;
+	}
+
+	BOOL AddBitmap(ATL::_U_STRINGorID bitmap, int nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		CBitmap bmp;
+		bmp.LoadBitmap(bitmap.m_lpstr);
+		if(bmp.m_hBitmap == NULL)
+			return FALSE;
+		return AddBitmap(bmp, nCommandID);
+	}
+
+	BOOL AddBitmap(HBITMAP hBitmap, UINT nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		// Create image list if it doesn't exist
+		if(m_hImageList == NULL)
+		{
+			if(!pT->CreateInternalImageList(1))
+				return FALSE;
+		}
+		// check bitmap size
+		CBitmapHandle bmp = hBitmap;
+		SIZE size = { 0, 0 };
+		bmp.GetSize(size);
+		if(size.cx != m_szBitmap.cx || size.cy != m_szBitmap.cy)
+		{
+			ATLASSERT(FALSE);   // must match size!
+			return FALSE;
+		}
+		// add bitmap
+		int nRet = ::ImageList_AddMasked(m_hImageList, hBitmap, m_clrMask);
+		if(nRet == -1)
+			return FALSE;
+		BOOL bRet = m_arrCommand.Add((WORD)nCommandID);
+		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
+#if _WTL_CMDBAR_VISTA_MENUS
+		if(RunTimeHelper::IsVista())
+		{
+			pT->_AddVistaBitmapFromImageList(m_arrCommand.GetSize() - 1);
+			ATLASSERT(m_arrVistaBitmap.GetSize() == m_arrCommand.GetSize());
+		}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+		return bRet;
+	}
+
+	BOOL AddIcon(ATL::_U_STRINGorID icon, UINT nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HICON hIcon = ::LoadIcon(ModuleHelper::GetResourceInstance(), icon.m_lpstr);
+		if(hIcon == NULL)
+			return FALSE;
+		return AddIcon(hIcon, nCommandID);
+	}
+
+	BOOL AddIcon(HICON hIcon, UINT nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		// create image list if it doesn't exist
+		if(m_hImageList == NULL)
+		{
+			if(!pT->CreateInternalImageList(1))
+				return FALSE;
+		}
+
+		int nRet = ::ImageList_AddIcon(m_hImageList, hIcon);
+		if(nRet == -1)
+			return FALSE;
+		BOOL bRet = m_arrCommand.Add((WORD)nCommandID);
+		ATLASSERT(::ImageList_GetImageCount(m_hImageList) == m_arrCommand.GetSize());
+#if _WTL_CMDBAR_VISTA_MENUS
+		if(RunTimeHelper::IsVista())
+		{
+			pT->_AddVistaBitmapFromImageList(m_arrCommand.GetSize() - 1);
+			ATLASSERT(m_arrVistaBitmap.GetSize() == m_arrCommand.GetSize());
+		}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+		return bRet;
+	}
+
+	BOOL ReplaceBitmap(ATL::_U_STRINGorID bitmap, int nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		CBitmap bmp;
+		bmp.LoadBitmap(bitmap.m_lpstr);
+		if(bmp.m_hBitmap == NULL)
+			return FALSE;
+		return ReplaceBitmap(bmp, nCommandID);
+	}
+
+	BOOL ReplaceBitmap(HBITMAP hBitmap, UINT nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		BOOL bRet = FALSE;
+		for(int i = 0; i < m_arrCommand.GetSize(); i++)
+		{
+			if(m_arrCommand[i] == nCommandID)
+			{
+				bRet = ::ImageList_Remove(m_hImageList, i);
+				if(bRet)
+				{
+					m_arrCommand.RemoveAt(i);
+#if _WTL_CMDBAR_VISTA_MENUS
+					if(RunTimeHelper::IsVista())
+					{
+						if(m_arrVistaBitmap[i] != NULL)
+							::DeleteObject(m_arrVistaBitmap[i]);
+						m_arrVistaBitmap.RemoveAt(i);
+					}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+				}
+				break;
+			}
+		}
+		if(bRet)
+			bRet = AddBitmap(hBitmap, nCommandID);
+		return bRet;
+	}
+
+	BOOL ReplaceIcon(ATL::_U_STRINGorID icon, UINT nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HICON hIcon = ::LoadIcon(ModuleHelper::GetResourceInstance(), icon.m_lpstr);
+		if(hIcon == NULL)
+			return FALSE;
+		return ReplaceIcon(hIcon, nCommandID);
+	}
+
+	BOOL ReplaceIcon(HICON hIcon, UINT nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		BOOL bRet = FALSE;
+		for(int i = 0; i < m_arrCommand.GetSize(); i++)
+		{
+			if(m_arrCommand[i] == nCommandID)
+			{
+				bRet = (::ImageList_ReplaceIcon(m_hImageList, i, hIcon) != -1);
+#if _WTL_CMDBAR_VISTA_MENUS
+				if(RunTimeHelper::IsVista() && bRet != FALSE)
+				{
+					T* pT = static_cast<T*>(this);
+					pT->_ReplaceVistaBitmapFromImageList(i);
+				}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+				break;
+			}
+		}
+		return bRet;
+	}
+
+	BOOL RemoveImage(int nCommandID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		BOOL bRet = FALSE;
+		for(int i = 0; i < m_arrCommand.GetSize(); i++)
+		{
+			if(m_arrCommand[i] == nCommandID)
+			{
+				bRet = ::ImageList_Remove(m_hImageList, i);
+				if(bRet)
+				{
+					m_arrCommand.RemoveAt(i);
+#if _WTL_CMDBAR_VISTA_MENUS
+					if(RunTimeHelper::IsVista())
+					{
+						if(m_arrVistaBitmap[i] != NULL)
+							::DeleteObject(m_arrVistaBitmap[i]);
+						m_arrVistaBitmap.RemoveAt(i);
+					}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+				}
+				break;
+			}
+		}
+		return bRet;
+	}
+
+	BOOL RemoveAllImages()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Removing all images\n"));
+		BOOL bRet = ::ImageList_RemoveAll(m_hImageList);
+		if(bRet)
+		{
+			m_arrCommand.RemoveAll();
+#if _WTL_CMDBAR_VISTA_MENUS
+			for(int i = 0; i < m_arrVistaBitmap.GetSize(); i++)
+			{
+				if(m_arrVistaBitmap[i] != NULL)
+					::DeleteObject(m_arrVistaBitmap[i]);
+			}
+			m_arrVistaBitmap.RemoveAll();
+#endif // _WTL_CMDBAR_VISTA_MENUS
+		}
+		return bRet;
+	}
+
+	BOOL TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, LPTPMPARAMS lpParams = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(::IsMenu(hMenu));
+		if(!::IsMenu(hMenu))
+			return FALSE;
+		m_bContextMenu = true;
+		if(m_bUseKeyboardCues)
+			m_bShowKeyboardCues = m_bKeyboardInput;
+		T* pT = static_cast<T*>(this);
+		return pT->DoTrackPopupMenu(hMenu, uFlags, x, y, lpParams);
+	}
+
+	BOOL SetMDIClient(HWND /*hWndMDIClient*/)
+	{
+		// Use CMDICommandBarCtrl for MDI support
+		ATLASSERT(FALSE);
+		return FALSE;
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CCommandBarCtrlImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_INITMENU, OnInitMenu)
+		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
+		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
+		MESSAGE_HANDLER(GetAutoPopupMessage(), OnInternalAutoPopup)
+		MESSAGE_HANDLER(GetGetBarMessage(), OnInternalGetBar)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+		MESSAGE_HANDLER(WM_MENUCHAR, OnMenuChar)
+
+		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
+		MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
+		MESSAGE_HANDLER(WM_CHAR, OnChar)
+		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnSysKeyDown)
+		MESSAGE_HANDLER(WM_SYSKEYUP, OnSysKeyUp)
+		MESSAGE_HANDLER(WM_SYSCHAR, OnSysChar)
+// public API handlers - these stay to support chevrons in atlframe.h
+		MESSAGE_HANDLER(CBRM_GETMENU, OnAPIGetMenu)
+		MESSAGE_HANDLER(CBRM_TRACKPOPUPMENU, OnAPITrackPopupMenu)
+		MESSAGE_HANDLER(CBRM_GETCMDBAR, OnAPIGetCmdBar)
+
+		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
+		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
+
+		MESSAGE_HANDLER(WM_FORWARDMSG, OnForwardMsg)
+	ALT_MSG_MAP(1)   // Parent window messages
+		NOTIFY_CODE_HANDLER(TBN_HOTITEMCHANGE, OnParentHotItemChange)
+		NOTIFY_CODE_HANDLER(TBN_DROPDOWN, OnParentDropDown)
+		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnParentInitMenuPopup)
+		MESSAGE_HANDLER(GetGetBarMessage(), OnParentInternalGetBar)
+		MESSAGE_HANDLER(WM_SYSCOMMAND, OnParentSysCommand)
+		MESSAGE_HANDLER(CBRM_GETMENU, OnParentAPIGetMenu)
+		MESSAGE_HANDLER(WM_MENUCHAR, OnParentMenuChar)
+		MESSAGE_HANDLER(CBRM_TRACKPOPUPMENU, OnParentAPITrackPopupMenu)
+		MESSAGE_HANDLER(CBRM_GETCMDBAR, OnParentAPIGetCmdBar)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnParentSettingChange)
+
+		MESSAGE_HANDLER(WM_DRAWITEM, OnParentDrawItem)
+		MESSAGE_HANDLER(WM_MEASUREITEM, OnParentMeasureItem)
+
+		MESSAGE_HANDLER(WM_ACTIVATE, OnParentActivate)
+		NOTIFY_CODE_HANDLER(NM_CUSTOMDRAW, OnParentCustomDraw)
+	ALT_MSG_MAP(2)   // MDI client window messages
+		// Use CMDICommandBarCtrl for MDI support
+	ALT_MSG_MAP(3)   // Message hook messages
+		MESSAGE_HANDLER(WM_MOUSEMOVE, OnHookMouseMove)
+		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnHookSysKeyDown)
+		MESSAGE_HANDLER(WM_SYSKEYUP, OnHookSysKeyUp)
+		MESSAGE_HANDLER(WM_SYSCHAR, OnHookSysChar)
+		MESSAGE_HANDLER(WM_KEYDOWN, OnHookKeyDown)
+		MESSAGE_HANDLER(WM_NEXTMENU, OnHookNextMenu)
+		MESSAGE_HANDLER(WM_CHAR, OnHookChar)
+	END_MSG_MAP()
+
+	LRESULT OnForwardMsg(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LPMSG pMsg = (LPMSG)lParam;
+		if(pMsg->message >= WM_MOUSEFIRST && pMsg->message <= WM_MOUSELAST)
+			m_bKeyboardInput = false;
+		else if(pMsg->message >= WM_KEYFIRST && pMsg->message <= WM_KEYLAST)
+			m_bKeyboardInput = true;
+		LRESULT lRet = 0;
+		ProcessWindowMessage(pMsg->hwnd, pMsg->message, pMsg->wParam, pMsg->lParam, lRet, 3);
+		return lRet;
+	}
+
+	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		// Let the toolbar initialize itself
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+		// get and use system settings
+		T* pT = static_cast<T*>(this);
+		pT->GetSystemSettings();
+		// Parent init
+		ATL::CWindow wndParent = GetParent();
+		ATL::CWindow wndTopLevelParent = wndParent.GetTopLevelParent();
+		m_wndParent.SubclassWindow(wndTopLevelParent);
+		// Toolbar Init
+		SetButtonStructSize();
+		SetImageList(NULL);
+
+		// Create message hook if needed
+		CWindowCreateCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CCommandBarCtrlImpl::OnCreate.\n"));
+			ATLASSERT(FALSE);
+			return -1;
+		}
+
+		if(s_pmapMsgHook == NULL)
+		{
+			ATLTRY(s_pmapMsgHook = new CMsgHookMap);
+			ATLASSERT(s_pmapMsgHook != NULL);
+		}
+
+		if(s_pmapMsgHook != NULL)
+		{
+			DWORD dwThreadID = ::GetCurrentThreadId();
+			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
+			if(pData == NULL)
+			{
+				ATLTRY(pData = new _MsgHookData);
+				ATLASSERT(pData != NULL);
+				HHOOK hMsgHook = ::SetWindowsHookEx(WH_GETMESSAGE, MessageHookProc, ModuleHelper::GetModuleInstance(), dwThreadID);
+				ATLASSERT(hMsgHook != NULL);
+				if(pData != NULL && hMsgHook != NULL)
+				{
+					pData->hMsgHook = hMsgHook;
+					pData->dwUsage = 1;
+					BOOL bRet = s_pmapMsgHook->Add(dwThreadID, pData);
+					bRet;
+					ATLASSERT(bRet);
+				}
+			}
+			else
+			{
+				(pData->dwUsage)++;
+			}
+		}
+		lock.Unlock();
+
+		// Get layout
+#if (WINVER >= 0x0500)
+		m_bLayoutRTL = ((GetExStyle() & WS_EX_LAYOUTRTL) != 0);
+#endif // (WINVER >= 0x0500)
+
+		return lRet;
+	}
+
+	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+
+#if _WTL_CMDBAR_VISTA_MENUS
+		if(m_bVistaMenus && (m_hMenu != NULL))
+		{
+			T* pT = static_cast<T*>(this);
+			pT->_RemoveVistaBitmapsFromMenu();
+		}
+
+		for(int i = 0; i < m_arrVistaBitmap.GetSize(); i++)
+		{
+			if(m_arrVistaBitmap[i] != NULL)
+				::DeleteObject(m_arrVistaBitmap[i]);
+		}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+		if(m_bAttachedMenu)   // nothing to do in this mode
+			return lRet;
+
+		CWindowCreateCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CCommandBarCtrlImpl::OnDestroy.\n"));
+			ATLASSERT(FALSE);
+			return lRet;
+		}
+
+		if(s_pmapMsgHook != NULL)
+		{
+			DWORD dwThreadID = ::GetCurrentThreadId();
+			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
+			if(pData != NULL)
+			{
+				(pData->dwUsage)--;
+				if(pData->dwUsage == 0)
+				{
+					BOOL bRet = ::UnhookWindowsHookEx(pData->hMsgHook);
+					ATLASSERT(bRet);
+					bRet = s_pmapMsgHook->Remove(dwThreadID);
+					ATLASSERT(bRet);
+					if(bRet)
+						delete pData;
+				}
+
+				if(s_pmapMsgHook->GetSize() == 0)
+				{
+					delete s_pmapMsgHook;
+					s_pmapMsgHook = NULL;
+				}
+			}
+		}
+
+		lock.Unlock();
+
+		return lRet;
+	}
+
+	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnKeyDown\n"));
+#endif
+		bHandled = FALSE;
+		// Simulate Alt+Space for the parent
+		if(wParam == VK_SPACE)
+		{
+			m_wndParent.PostMessage(WM_SYSKEYDOWN, wParam, lParam | (1 << 29));
+			bHandled = TRUE;
+		}
+#if (_WIN32_IE >= 0x0500)
+		else if(wParam == VK_LEFT || wParam == VK_RIGHT)
+		{
+			WPARAM wpNext = m_bLayoutRTL ? VK_LEFT : VK_RIGHT;
+
+			if(!m_bMenuActive)
+			{
+				T* pT = static_cast<T*>(this);
+				int nBtn = GetHotItem();
+				int nNextBtn = (wParam == wpNext) ? pT->GetNextMenuItem(nBtn) : pT->GetPreviousMenuItem(nBtn);
+				if(nNextBtn == -2)
+				{
+					SetHotItem(-1);
+					if(pT->DisplayChevronMenu())
+						bHandled = TRUE;
+				}
+			}
+		}
+#endif // (_WIN32_IE >= 0x0500)
+		return 0;
+	}
+
+	LRESULT OnKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnKeyUp\n"));
+#endif
+		if(wParam != VK_SPACE)
+			bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnChar\n"));
+#endif
+		if(wParam != VK_SPACE)
+			bHandled = FALSE;
+		else
+			return 0;
+		// Security
+		if(!m_wndParent.IsWindowEnabled() || ::GetFocus() != m_hWnd)
+			return 0;
+
+		// Handle mnemonic press when we have focus
+		int nBtn = 0;
+		if(wParam != VK_RETURN && !MapAccelerator((TCHAR)LOWORD(wParam), nBtn))
+		{
+#if (_WIN32_IE >= 0x0500)
+			if((TCHAR)LOWORD(wParam) != _chChevronShortcut)
+#endif // (_WIN32_IE >= 0x0500)
+				::MessageBeep(0);
+		}
+		else
+		{
+#if (_WIN32_IE >= 0x0500)
+			RECT rcClient = { 0 };
+			GetClientRect(&rcClient);
+			RECT rcBtn = { 0 };
+			GetItemRect(nBtn, &rcBtn);
+			TBBUTTON tbb = { 0 };
+			GetButton(nBtn, &tbb);
+			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0 && rcBtn.right <= rcClient.right)
+			{
+#endif // (_WIN32_IE >= 0x0500)
+				PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
+				if(wParam != VK_RETURN)
+					SetHotItem(nBtn);
+#if (_WIN32_IE >= 0x0500)
+			}
+			else
+			{
+				::MessageBeep(0);
+				bHandled = TRUE;
+			}
+#endif // (_WIN32_IE >= 0x0500)
+		}
+		return 0;
+	}
+
+	LRESULT OnSysKeyDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnSysKeyDown\n"));
+#endif
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnSysKeyUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnSysKeyUp\n"));
+#endif
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnSysChar(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnSysChar\n"));
+#endif
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_bAttachedMenu || (m_dwExtendedStyle & CBR_EX_TRANSPARENT))
+		{
+			bHandled = FALSE;
+			return 0;
+		}
+
+		CDCHandle dc = (HDC)wParam;
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+		dc.FillRect(&rect, COLOR_MENU);
+
+		return 1;   // don't do the default erase
+	}
+
+	LRESULT OnInitMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		int nIndex = GetHotItem();
+		SendMessage(WM_MENUSELECT, MAKEWPARAM(nIndex, MF_POPUP|MF_HILITE), (LPARAM)m_hMenu);
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		if((BOOL)HIWORD(lParam))   // System menu, do nothing
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		if(!(m_bAttachedMenu || m_bMenuActive))   // Not attached or ours, do nothing
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnInitMenuPopup\n"));
+#endif
+		// forward to the parent or subclassed window, so it can handle update UI
+		LRESULT lRet = 0;
+		if(m_bAttachedMenu)
+			lRet = DefWindowProc(uMsg, wParam, (lParam || m_bContextMenu) ? lParam : GetHotItem());
+		else
+			lRet = m_wndParent.DefWindowProc(uMsg, wParam, (lParam || m_bContextMenu) ? lParam : GetHotItem());
+
+#if _WTL_CMDBAR_VISTA_MENUS
+		// If Vista menus are active, just set bitmaps and return
+		if(m_bVistaMenus)
+		{
+			CMenuHandle menu = (HMENU)wParam;
+			ATLASSERT(menu.m_hMenu != NULL);
+
+			for(int i = 0; i < menu.GetMenuItemCount(); i++)
+			{
+				WORD nID = (WORD)menu.GetMenuItemID(i);
+				int nIndex = m_arrCommand.Find(nID);
+
+				CMenuItemInfo mii;
+				mii.fMask = MIIM_BITMAP;
+				mii.hbmpItem = (m_bImagesVisible && (nIndex != -1)) ? m_arrVistaBitmap[nIndex] : NULL;
+				menu.SetMenuItemInfo(i, TRUE, &mii);
+			}
+
+			return lRet;
+		}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+		// Convert menu items to ownerdraw, add our data
+		if(m_bImagesVisible)
+		{
+			CMenuHandle menuPopup = (HMENU)wParam;
+			ATLASSERT(menuPopup.m_hMenu != NULL);
+
+			T* pT = static_cast<T*>(this);
+			pT;   // avoid level 4 warning
+			TCHAR szString[pT->_nMaxMenuItemTextLength];
+			BOOL bRet = FALSE;
+			for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
+			{
+				CMenuItemInfo mii;
+				mii.cch = pT->_nMaxMenuItemTextLength;
+				mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
+				mii.dwTypeData = szString;
+				bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
+				ATLASSERT(bRet);
+
+				if(!(mii.fType & MFT_OWNERDRAW))   // Not already an ownerdraw item
+				{
+					mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
+					_MenuItemData* pMI = NULL;
+					ATLTRY(pMI = new _MenuItemData);
+					ATLASSERT(pMI != NULL);
+					if(pMI != NULL)
+					{
+						pMI->fType = mii.fType;
+						pMI->fState = mii.fState;
+						mii.fType |= MFT_OWNERDRAW;
+						pMI->iButton = -1;
+						for(int j = 0; j < m_arrCommand.GetSize(); j++)
+						{
+							if(m_arrCommand[j] == mii.wID)
+							{
+								pMI->iButton = j;
+								break;
+							}
+						}
+						int cchLen = lstrlen(szString) + 1;
+						pMI->lpstrText = NULL;
+						ATLTRY(pMI->lpstrText = new TCHAR[cchLen]);
+						ATLASSERT(pMI->lpstrText != NULL);
+						if(pMI->lpstrText != NULL)
+							SecureHelper::strcpy_x(pMI->lpstrText, cchLen, szString);
+						mii.dwItemData = (ULONG_PTR)pMI;
+						bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
+						ATLASSERT(bRet);
+					}
+				}
+			}
+
+			// Add it to the list
+			m_stackMenuHandle.Push(menuPopup.m_hMenu);
+		}
+
+		return lRet;
+	}
+
+	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		if(!m_bAttachedMenu)   // Not attached, do nothing, forward to parent
+		{
+			m_bPopupItem = (lParam != NULL) && ((HMENU)lParam != m_hMenu) && (HIWORD(wParam) & MF_POPUP);
+			if(m_wndParent.IsWindow())
+				m_wndParent.SendMessage(uMsg, wParam, lParam);
+			bHandled = FALSE;
+			return 1;
+		}
+
+		// Check if a menu is closing, do a cleanup
+		if(HIWORD(wParam) == 0xFFFF && lParam == NULL)   // Menu closing
+		{
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnMenuSelect - CLOSING!!!!\n"));
+#endif
+			ATLASSERT(m_stackMenuWnd.GetSize() == 0);
+			// Restore the menu items to the previous state for all menus that were converted
+			if(m_bImagesVisible)
+			{
+				HMENU hMenu = NULL;
+				while((hMenu = m_stackMenuHandle.Pop()) != NULL)
+				{
+					CMenuHandle menuPopup = hMenu;
+					ATLASSERT(menuPopup.m_hMenu != NULL);
+					// Restore state and delete menu item data
+					BOOL bRet = FALSE;
+					for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
+					{
+						CMenuItemInfo mii;
+						mii.fMask = MIIM_DATA | MIIM_TYPE;
+						bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
+						ATLASSERT(bRet);
+
+						_MenuItemData* pMI = (_MenuItemData*)mii.dwItemData;
+						if(pMI != NULL && pMI->IsCmdBarMenuItem())
+						{
+							mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
+							mii.fType = pMI->fType;
+							mii.dwTypeData = pMI->lpstrText;
+							mii.cch = lstrlen(pMI->lpstrText);
+							mii.dwItemData = NULL;
+
+							bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
+							ATLASSERT(bRet);
+
+							delete [] pMI->lpstrText;
+							pMI->dwMagic = 0x6666;
+							delete pMI;
+						}
+					}
+				}
+			}
+		}
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnInternalAutoPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		int nIndex = (int)wParam;
+		T* pT = static_cast<T*>(this);
+		pT->DoPopupMenu(nIndex, false);
+		return 0;
+	}
+
+	LRESULT OnInternalGetBar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		// Let's make sure we're not embedded in another process
+		if((LPVOID)wParam != NULL)
+			*((DWORD*)wParam) = GetCurrentProcessId();
+		if(IsWindowVisible())
+			return (LRESULT)static_cast<CCommandBarCtrlBase*>(this);
+		else
+			return NULL;
+	}
+
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+#ifndef SPI_GETKEYBOARDCUES
+		const UINT SPI_SETKEYBOARDCUES = 0x100B;
+#endif // !SPI_GETKEYBOARDCUES
+#ifndef SPI_GETFLATMENU
+		const UINT SPI_SETFLATMENU = 0x1023;
+#endif // !SPI_GETFLATMENU
+
+		if(wParam == SPI_SETNONCLIENTMETRICS || wParam == SPI_SETKEYBOARDCUES || wParam == SPI_SETFLATMENU)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->GetSystemSettings();
+		}
+
+		return 0;
+	}
+
+	LRESULT OnWindowPosChanging(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+
+		LPWINDOWPOS lpWP = (LPWINDOWPOS)lParam;
+		int cyMin = ::GetSystemMetrics(SM_CYMENU);
+		if(lpWP->cy < cyMin)
+		lpWP->cy = cyMin;
+
+		return lRet;
+	}
+
+	LRESULT OnMenuChar(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - OnMenuChar\n"));
+#endif
+		bHandled = TRUE;
+		T* pT = static_cast<T*>(this);
+
+		LRESULT lRet;
+		if(m_bMenuActive && LOWORD(wParam) != 0x0D)
+			lRet = 0;
+		else
+			lRet = MAKELRESULT(1, 1);
+
+		if(m_bMenuActive && HIWORD(wParam) == MF_POPUP)
+		{
+			// Convert character to lower/uppercase and possibly Unicode, using current keyboard layout
+			TCHAR ch = (TCHAR)LOWORD(wParam);
+			CMenuHandle menu = (HMENU)lParam;
+			int nCount = ::GetMenuItemCount(menu);
+			int nRetCode = MNC_EXECUTE;
+			BOOL bRet = FALSE;
+			TCHAR szString[pT->_nMaxMenuItemTextLength];
+			WORD wMnem = 0;
+			bool bFound = false;
+			for(int i = 0; i < nCount; i++)
+			{
+				CMenuItemInfo mii;
+				mii.cch = pT->_nMaxMenuItemTextLength;
+				mii.fMask = MIIM_CHECKMARKS | MIIM_DATA | MIIM_ID | MIIM_STATE | MIIM_SUBMENU | MIIM_TYPE;
+				mii.dwTypeData = szString;
+				bRet = menu.GetMenuItemInfo(i, TRUE, &mii);
+				if(!bRet || (mii.fType & MFT_SEPARATOR))
+					continue;
+				_MenuItemData* pmd = (_MenuItemData*)mii.dwItemData;
+				if(pmd != NULL && pmd->IsCmdBarMenuItem())
+				{
+					LPTSTR p = pmd->lpstrText;
+
+					if(p != NULL)
+					{
+						while(*p && *p != _T('&'))
+							p = ::CharNext(p);
+						if(p != NULL && *p)
+						{
+							DWORD dwP = MAKELONG(*(++p), 0);
+							DWORD dwC = MAKELONG(ch, 0);
+							if(::CharLower((LPTSTR)ULongToPtr(dwP)) == ::CharLower((LPTSTR)ULongToPtr(dwC)))
+							{
+								if(!bFound)
+								{
+									wMnem = (WORD)i;
+									bFound = true;
+								}
+								else
+								{
+									nRetCode = MNC_SELECT;
+									break;
+								}
+							}
+						}
+					}
+				}
+			}
+			if(bFound)
+			{
+				if(nRetCode == MNC_EXECUTE)
+				{
+					PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
+					pT->GiveFocusBack();
+				}
+				bHandled = TRUE;
+				lRet = MAKELRESULT(wMnem, nRetCode);
+			}
+		} 
+		else if(!m_bMenuActive)
+		{
+			int nBtn = 0;
+			if(!MapAccelerator((TCHAR)LOWORD(wParam), nBtn))
+			{
+				bHandled = FALSE;
+				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
+				pT->GiveFocusBack();
+
+#if (_WIN32_IE >= 0x0500)
+				// check if we should display chevron menu
+				if((TCHAR)LOWORD(wParam) == pT->_chChevronShortcut)
+				{
+					if(pT->DisplayChevronMenu())
+						bHandled = TRUE;
+				}
+#endif // (_WIN32_IE >= 0x0500)
+			}
+			else if(m_wndParent.IsWindowEnabled())
+			{
+#if (_WIN32_IE >= 0x0500)
+				RECT rcClient = { 0 };
+				GetClientRect(&rcClient);
+				RECT rcBtn = { 0 };
+				GetItemRect(nBtn, &rcBtn);
+				TBBUTTON tbb = { 0 };
+				GetButton(nBtn, &tbb);
+				if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0 && rcBtn.right <= rcClient.right)
+				{
+#endif // (_WIN32_IE >= 0x0500)
+					if(m_bUseKeyboardCues && !m_bShowKeyboardCues)
+					{
+						m_bAllowKeyboardCues = true;
+						ShowKeyboardCues(true);
+					}
+					pT->TakeFocus();
+					PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
+					SetHotItem(nBtn);
+#if (_WIN32_IE >= 0x0500)
+				}
+				else
+				{
+					::MessageBeep(0);
+				}
+#endif // (_WIN32_IE >= 0x0500)
+			}
+		}
+
+		return lRet;
+	}
+
+	LRESULT OnDrawItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		LPDRAWITEMSTRUCT lpDrawItemStruct = (LPDRAWITEMSTRUCT)lParam;
+		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
+		if(lpDrawItemStruct->CtlType == ODT_MENU && pmd != NULL && pmd->IsCmdBarMenuItem())
+		{
+			T* pT = static_cast<T*>(this);
+			pT->DrawItem(lpDrawItemStruct);
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+		return (LRESULT)TRUE;
+	}
+
+	LRESULT OnMeasureItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		LPMEASUREITEMSTRUCT lpMeasureItemStruct = (LPMEASUREITEMSTRUCT)lParam;
+		_MenuItemData* pmd = (_MenuItemData*)lpMeasureItemStruct->itemData;
+		if(lpMeasureItemStruct->CtlType == ODT_MENU && pmd != NULL && pmd->IsCmdBarMenuItem())
+		{
+			T* pT = static_cast<T*>(this);
+			pT->MeasureItem(lpMeasureItemStruct);
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+		return (LRESULT)TRUE;
+	}
+
+// API message handlers
+	LRESULT OnAPIGetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return (LRESULT)m_hMenu;
+	}
+
+	LRESULT OnAPITrackPopupMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if(lParam == NULL)
+			return FALSE;
+		LPCBRPOPUPMENU lpCBRPopupMenu = (LPCBRPOPUPMENU)lParam;
+		if(lpCBRPopupMenu->cbSize != sizeof(CBRPOPUPMENU))
+			return FALSE;
+
+		T* pT = static_cast<T*>(this);
+		return pT->TrackPopupMenu(lpCBRPopupMenu->hMenu, lpCBRPopupMenu->uFlags, lpCBRPopupMenu->x, lpCBRPopupMenu->y, lpCBRPopupMenu->lptpm);
+	}
+
+	LRESULT OnAPIGetCmdBar(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return (LRESULT)m_hWnd;
+	}
+
+// Parent window message handlers
+	LRESULT OnParentHotItemChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		LPNMTBHOTITEM lpNMHT = (LPNMTBHOTITEM)pnmh;
+
+		// Check if this comes from us
+		if(pnmh->hwndFrom != m_hWnd)
+		{
+			bHandled = FALSE;
+			return 0;
+		}
+
+		bool bBlockTracking = false;
+		if((m_dwExtendedStyle & CBR_EX_TRACKALWAYS) == 0)
+		{
+			DWORD dwProcessID;
+			::GetWindowThreadProcessId(::GetActiveWindow(), &dwProcessID);
+			bBlockTracking = (::GetCurrentProcessId() != dwProcessID);
+		}
+
+		if((!m_wndParent.IsWindowEnabled() || bBlockTracking) && (lpNMHT->dwFlags & HICF_MOUSE))
+		{
+			return 1;
+		}
+		else
+		{
+#ifndef HICF_LMOUSE
+			const DWORD HICF_LMOUSE = 0x00000080;   // left mouse button selected
+#endif
+			bHandled = FALSE;
+
+			// Send WM_MENUSELECT to the app if it needs to display a status text
+			if(!(lpNMHT->dwFlags & HICF_MOUSE)
+				&& !(lpNMHT->dwFlags & HICF_ACCELERATOR)
+				&& !(lpNMHT->dwFlags & HICF_LMOUSE))
+			{
+				if(lpNMHT->dwFlags & HICF_ENTERING)
+					m_wndParent.SendMessage(WM_MENUSELECT, 0, (LPARAM)m_hMenu);
+				if(lpNMHT->dwFlags & HICF_LEAVING)
+					m_wndParent.SendMessage(WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);
+			}
+
+			return 0;
+		}
+	}
+
+	LRESULT OnParentDropDown(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		// Check if this comes from us
+		if(pnmh->hwndFrom != m_hWnd)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		T* pT = static_cast<T*>(this);
+		if(::GetFocus() != m_hWnd)
+			pT->TakeFocus();
+		LPNMTOOLBAR pNMToolBar = (LPNMTOOLBAR)pnmh;
+		int nIndex = CommandToIndex(pNMToolBar->iItem);
+		m_bContextMenu = false;
+		m_bEscapePressed = false;
+		pT->DoPopupMenu(nIndex, true);
+
+		return TBDDRET_DEFAULT;
+	}
+
+	LRESULT OnParentInitMenuPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnInitMenuPopup(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentInternalGetBar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnInternalGetBar(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentSysCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+		if((m_uSysKey == VK_MENU 
+			|| (m_uSysKey == VK_F10 && !(::GetKeyState(VK_SHIFT) & 0x80))
+			|| m_uSysKey == VK_SPACE) 
+			&& wParam == SC_KEYMENU)
+		{
+			T* pT = static_cast<T*>(this);
+			if(::GetFocus() == m_hWnd)
+			{
+				pT->GiveFocusBack();   // exit menu "loop"
+				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
+			}
+			else if(m_uSysKey != VK_SPACE && !m_bSkipMsg)
+			{
+				if(m_bUseKeyboardCues && !m_bShowKeyboardCues && m_bAllowKeyboardCues)
+					ShowKeyboardCues(true);
+
+				pT->TakeFocus();      // enter menu "loop"
+				bHandled = TRUE;
+			}
+			else if(m_uSysKey != VK_SPACE)
+			{
+				bHandled = TRUE;
+			}
+		}
+		m_bSkipMsg = false;
+		return 0;
+	}
+
+	LRESULT OnParentAPIGetMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnAPIGetMenu(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentMenuChar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnMenuChar(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentAPITrackPopupMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnAPITrackPopupMenu(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentAPIGetCmdBar(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnAPIGetCmdBar(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentSettingChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		OnSettingChange(uMsg, wParam, lParam, bHandled);
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnParentDrawItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnDrawItem(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentMeasureItem(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		return OnMeasureItem(uMsg, wParam, lParam, bHandled);
+	}
+
+	LRESULT OnParentActivate(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		m_bParentActive = (LOWORD(wParam) != WA_INACTIVE);
+		if(!m_bParentActive && m_bUseKeyboardCues && m_bShowKeyboardCues)
+		{
+			ShowKeyboardCues(false);   // this will repaint our window
+		}
+		else
+		{
+			Invalidate();
+			UpdateWindow();
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnParentCustomDraw(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		LRESULT lRet = CDRF_DODEFAULT;
+		bHandled = FALSE;
+		if(pnmh->hwndFrom == m_hWnd)
+		{
+			LPNMTBCUSTOMDRAW lpTBCustomDraw = (LPNMTBCUSTOMDRAW)pnmh;
+			if(lpTBCustomDraw->nmcd.dwDrawStage == CDDS_PREPAINT)
+			{
+				lRet = CDRF_NOTIFYITEMDRAW;
+				bHandled = TRUE;
+			}
+			else if(lpTBCustomDraw->nmcd.dwDrawStage == CDDS_ITEMPREPAINT)
+			{
+				if(m_bFlatMenus)
+				{
+#ifndef COLOR_MENUHILIGHT
+					const int COLOR_MENUHILIGHT = 29;
+#endif // !COLOR_MENUHILIGHT
+					bool bDisabled = ((lpTBCustomDraw->nmcd.uItemState & CDIS_DISABLED) == CDIS_DISABLED);
+					if(!bDisabled && ((lpTBCustomDraw->nmcd.uItemState & CDIS_HOT) == CDIS_HOT || 
+						(lpTBCustomDraw->nmcd.uItemState & CDIS_SELECTED) == CDIS_SELECTED))
+					{
+						::FillRect(lpTBCustomDraw->nmcd.hdc, &lpTBCustomDraw->nmcd.rc, ::GetSysColorBrush(COLOR_MENUHILIGHT));
+						::FrameRect(lpTBCustomDraw->nmcd.hdc, &lpTBCustomDraw->nmcd.rc, ::GetSysColorBrush(COLOR_HIGHLIGHT));
+						lpTBCustomDraw->clrText = ::GetSysColor(m_bParentActive ? COLOR_HIGHLIGHTTEXT : COLOR_GRAYTEXT);
+					}
+					else if(bDisabled || !m_bParentActive)
+					{
+						lpTBCustomDraw->clrText = ::GetSysColor(COLOR_GRAYTEXT);
+					}
+					CDCHandle dc = lpTBCustomDraw->nmcd.hdc;
+					dc.SetTextColor(lpTBCustomDraw->clrText);
+					dc.SetBkMode(lpTBCustomDraw->nStringBkMode);
+					HFONT hFont = GetFont();
+					HFONT hFontOld = NULL;
+					if(hFont != NULL)
+						hFontOld = dc.SelectFont(hFont);
+					const int cchText = 200;
+					TCHAR szText[cchText] = { 0 };
+					TBBUTTONINFO tbbi = { 0 };
+					tbbi.cbSize = sizeof(TBBUTTONINFO);
+					tbbi.dwMask = TBIF_TEXT;
+					tbbi.pszText = szText;
+					tbbi.cchText = cchText;
+					GetButtonInfo((int)lpTBCustomDraw->nmcd.dwItemSpec, &tbbi);
+					dc.DrawText(szText, -1, &lpTBCustomDraw->nmcd.rc, DT_SINGLELINE | DT_CENTER | DT_VCENTER | (m_bShowKeyboardCues ? 0 : DT_HIDEPREFIX));
+					if(hFont != NULL)
+						dc.SelectFont(hFontOld);
+					lRet = CDRF_SKIPDEFAULT;
+					bHandled = TRUE;
+				}
+				else if(!m_bParentActive)
+				{
+					lpTBCustomDraw->clrText = ::GetSysColor(COLOR_GRAYTEXT);
+					bHandled = TRUE;
+				}
+			}
+		}
+		return lRet;
+	}
+
+// Message hook handlers
+	LRESULT OnHookMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		static POINT s_point = { -1, -1 };
+		DWORD dwPoint = ::GetMessagePos();
+		POINT point = { GET_X_LPARAM(dwPoint), GET_Y_LPARAM(dwPoint) };
+
+		bHandled = FALSE;
+		if(m_bMenuActive)
+		{
+			if(::WindowFromPoint(point) == m_hWnd)
+			{
+				ScreenToClient(&point);
+				int nHit = HitTest(&point);
+
+				if((point.x != s_point.x || point.y != s_point.y) && nHit >= 0 && nHit < ::GetMenuItemCount(m_hMenu) && nHit != m_nPopBtn && m_nPopBtn != -1)
+				{
+					TBBUTTON tbb = { 0 };
+					GetButton(nHit, &tbb);
+					if((tbb.fsState & TBSTATE_ENABLED) != 0)
+					{
+						m_nNextPopBtn = nHit | 0xFFFF0000;
+						HWND hWndMenu = m_stackMenuWnd.GetCurrent();
+						ATLASSERT(hWndMenu != NULL);
+
+						// this one is needed to close a menu if mouse button was down
+						::PostMessage(hWndMenu, WM_LBUTTONUP, 0, MAKELPARAM(point.x, point.y));
+						// this one closes a popup menu
+						::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
+
+						bHandled = TRUE;
+					}
+				}
+			}
+		}
+		else
+		{
+			ScreenToClient(&point);
+		}
+
+		s_point = point;
+		return 0;
+	}
+
+	LRESULT OnHookSysKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook WM_SYSKEYDOWN (0x%2.2X)\n"), wParam);
+#endif
+
+		if(wParam == VK_MENU && m_bParentActive && m_bUseKeyboardCues && !m_bShowKeyboardCues && m_bAllowKeyboardCues)
+			ShowKeyboardCues(true);
+
+		if(wParam != VK_SPACE && !m_bMenuActive && ::GetFocus() == m_hWnd)
+		{
+			m_bAllowKeyboardCues = false;
+			PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
+			T* pT = static_cast<T*>(this);
+			pT->GiveFocusBack();
+			m_bSkipMsg = true;
+		}
+		else
+		{
+			if(wParam == VK_SPACE && m_bUseKeyboardCues && m_bShowKeyboardCues)
+			{
+				m_bAllowKeyboardCues = true;
+				ShowKeyboardCues(false);
+			}
+			m_uSysKey = (UINT)wParam;
+		}
+		return 0;
+	}
+
+	LRESULT OnHookSysKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(!m_bAllowKeyboardCues)
+			m_bAllowKeyboardCues = true;
+		bHandled = FALSE;
+		wParam;
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook WM_SYSKEYUP (0x%2.2X)\n"), wParam);
+#endif
+		return 0;
+	}
+
+	LRESULT OnHookSysChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook WM_SYSCHAR (0x%2.2X)\n"), wParam);
+#endif
+
+		if(!m_bMenuActive && m_hWndHook != m_hWnd && wParam != VK_SPACE)
+			bHandled = TRUE;
+		return 0;
+	}
+
+	LRESULT OnHookKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook WM_KEYDOWN (0x%2.2X)\n"), wParam);
+#endif
+		bHandled = FALSE;
+		T* pT = static_cast<T*>(this);
+
+		if(wParam == VK_ESCAPE && m_stackMenuWnd.GetSize() <= 1)
+		{
+			if(m_bMenuActive && !m_bContextMenu)
+			{
+				int nHot = GetHotItem();
+				if(nHot == -1)
+					nHot = m_nPopBtn;
+				if(nHot == -1)
+					nHot = 0;
+				SetHotItem(nHot);
+				bHandled = TRUE;
+				pT->TakeFocus();
+				m_bEscapePressed = true; // To keep focus
+				m_bSkipPostDown = false;
+			}
+			else if(::GetFocus() == m_hWnd && m_wndParent.IsWindow())
+			{
+				SetHotItem(-1);
+				pT->GiveFocusBack();
+				bHandled = TRUE;
+			}
+		}
+		else if(wParam == VK_RETURN || wParam == VK_UP || wParam == VK_DOWN)
+		{
+			if(!m_bMenuActive && ::GetFocus() == m_hWnd && m_wndParent.IsWindow())
+			{
+				int nHot = GetHotItem();
+				if(nHot != -1)
+				{
+					if(wParam != VK_RETURN)
+					{
+						if(!m_bSkipPostDown)
+						{
+// IE4 only: WM_KEYDOWN doesn't generate TBN_DROPDOWN, we need to simulate a mouse click
+#if (_WIN32_IE < 0x0500)
+							DWORD dwMajor = 0, dwMinor = 0;
+							ATL::AtlGetCommCtrlVersion(&dwMajor, &dwMinor);
+							if(dwMajor <= 4 || (dwMajor == 5 && dwMinor < 80))
+							{
+								RECT rect;
+								GetItemRect(nHot, &rect);
+								PostMessage(WM_LBUTTONDOWN, MK_LBUTTON, MAKELPARAM(rect.left, rect.top));
+							}
+#endif // (_WIN32_IE < 0x0500)
+							PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
+							m_bSkipPostDown = true;
+						}
+						else
+						{
+							ATLTRACE2(atlTraceUI, 0, _T("CmdBar - skipping posting another VK_DOWN\n"));
+							m_bSkipPostDown = false;
+						}
+					}
+				}
+				else
+				{
+					ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Can't find hot button\n"));
+				}
+			}
+			if(wParam == VK_RETURN && m_bMenuActive)
+			{
+				PostMessage(TB_SETHOTITEM, (WPARAM)-1, 0L);
+				m_nNextPopBtn = -1;
+				pT->GiveFocusBack();
+			}
+		}
+		else if(wParam == VK_LEFT || wParam == VK_RIGHT)
+		{
+			WPARAM wpNext = m_bLayoutRTL ? VK_LEFT : VK_RIGHT;
+			WPARAM wpPrev = m_bLayoutRTL ? VK_RIGHT : VK_LEFT;
+
+			if(m_bMenuActive && !m_bContextMenu && !(wParam == wpNext && m_bPopupItem))
+			{
+				bool bAction = false;
+				if(wParam == wpPrev && s_pCurrentBar->m_stackMenuWnd.GetSize() == 1)
+				{
+					m_nNextPopBtn = pT->GetPreviousMenuItem(m_nPopBtn);
+					if(m_nNextPopBtn != -1)
+						bAction = true;
+				}
+				else if(wParam == wpNext)
+				{
+					m_nNextPopBtn = pT->GetNextMenuItem(m_nPopBtn);
+					if(m_nNextPopBtn != -1)
+						bAction = true;
+				}
+				HWND hWndMenu = m_stackMenuWnd.GetCurrent();
+				ATLASSERT(hWndMenu != NULL);
+
+				// Close the popup menu
+				if(bAction)
+				{
+					::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
+					if(wParam == wpNext)
+					{
+						int cItem = m_stackMenuWnd.GetSize() - 1;
+						while(cItem >= 0)
+						{
+							hWndMenu = m_stackMenuWnd[cItem];
+							if(hWndMenu != NULL)
+								::PostMessage(hWndMenu, WM_KEYDOWN, VK_ESCAPE, 0L);
+							cItem--;
+						}
+					}
+#if (_WIN32_IE >= 0x0500)
+					if(m_nNextPopBtn == -2)
+					{
+						m_nNextPopBtn = -1;
+						pT->DisplayChevronMenu();
+					}
+#endif // (_WIN32_IE >= 0x0500)
+					bHandled = TRUE;
+				}
+			}
+		}
+		return 0;
+	}
+
+	LRESULT OnHookNextMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook WM_NEXTMENU\n"));
+#endif
+		bHandled = FALSE;
+		return 1;
+	}
+
+ 	LRESULT OnHookChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook WM_CHAR (0x%2.2X)\n"), wParam);
+#endif
+		bHandled = (wParam == VK_ESCAPE);
+		return 0;
+	}
+
+// Implementation - ownerdraw overrideables and helpers
+	void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
+	{
+		T* pT = static_cast<T*>(this);
+		if(m_bFlatMenus)
+			pT->DrawItemFlat(lpDrawItemStruct);
+		else
+			pT->DrawItem3D(lpDrawItemStruct);
+
+	}
+
+	void DrawItem3D(LPDRAWITEMSTRUCT lpDrawItemStruct)
+	{
+		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
+		CDCHandle dc = lpDrawItemStruct->hDC;
+		const RECT& rcItem = lpDrawItemStruct->rcItem;
+		T* pT = static_cast<T*>(this);
+
+		if(pmd->fType & MFT_SEPARATOR)
+		{
+			// draw separator
+			RECT rc = rcItem;
+			rc.top += (rc.bottom - rc.top) / 2;      // vertical center
+			dc.DrawEdge(&rc, EDGE_ETCHED, BF_TOP);   // draw separator line
+		}
+		else		// not a separator
+		{
+			BOOL bDisabled = lpDrawItemStruct->itemState & ODS_GRAYED;
+			BOOL bSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
+			BOOL bChecked = lpDrawItemStruct->itemState & ODS_CHECKED;
+			BOOL bHasImage = FALSE;
+
+			if(LOWORD(lpDrawItemStruct->itemID) == (WORD)-1)
+				bSelected = FALSE;
+			RECT rcButn = { rcItem.left, rcItem.top, rcItem.left + m_szButton.cx, rcItem.top + m_szButton.cy };   // button rect
+			::OffsetRect(&rcButn, 0, ((rcItem.bottom - rcItem.top) - (rcButn.bottom - rcButn.top)) / 2);          // center vertically
+
+			int iButton = pmd->iButton;
+			if(iButton >= 0)
+			{
+				bHasImage = TRUE;
+
+				// calc drawing point
+				SIZE sz = { rcButn.right - rcButn.left - m_szBitmap.cx, rcButn.bottom - rcButn.top - m_szBitmap.cy };
+				sz.cx /= 2;
+				sz.cy /= 2;
+				POINT point = { rcButn.left + sz.cx, rcButn.top + sz.cy };
+
+				// fill background depending on state
+				if(!bChecked || (bSelected && !bDisabled))
+				{
+					if(!bDisabled)
+						dc.FillRect(&rcButn, (bChecked && !bSelected) ? COLOR_3DLIGHT : COLOR_MENU);
+					else
+						dc.FillRect(&rcButn, COLOR_MENU);
+				}
+				else
+				{
+					COLORREF crTxt = dc.SetTextColor(::GetSysColor(COLOR_BTNFACE));
+					COLORREF crBk = dc.SetBkColor(::GetSysColor(COLOR_BTNHILIGHT));
+					CBrush hbr(CDCHandle::GetHalftoneBrush());
+					dc.SetBrushOrg(rcButn.left, rcButn.top);
+					dc.FillRect(&rcButn, hbr);
+					dc.SetTextColor(crTxt);
+					dc.SetBkColor(crBk);
+				}
+
+				// draw disabled or normal
+				if(!bDisabled)
+				{
+					// draw pushed-in or popped-out edge
+					if(bSelected || bChecked)
+					{
+						RECT rc2 = rcButn;
+						dc.DrawEdge(&rc2, bChecked ? BDR_SUNKENOUTER : BDR_RAISEDINNER, BF_RECT);
+					}
+					// draw the image
+					::ImageList_Draw(m_hImageList, iButton, dc, point.x, point.y, ILD_TRANSPARENT);
+				}
+				else
+				{
+					HBRUSH hBrushBackground = bChecked ? NULL : ::GetSysColorBrush(COLOR_MENU);
+					pT->DrawBitmapDisabled(dc, iButton, point, hBrushBackground);
+				}
+			}
+			else
+			{
+				// no image - look for custom checked/unchecked bitmaps
+				CMenuItemInfo info;
+				info.fMask = MIIM_CHECKMARKS | MIIM_TYPE;
+				::GetMenuItemInfo((HMENU)lpDrawItemStruct->hwndItem, lpDrawItemStruct->itemID, MF_BYCOMMAND, &info);
+				if(bChecked || info.hbmpUnchecked != NULL)
+				{
+					BOOL bRadio = ((info.fType & MFT_RADIOCHECK) != 0);
+					bHasImage = pT->DrawCheckmark(dc, rcButn, bSelected, bDisabled, bRadio, bChecked ? info.hbmpChecked : info.hbmpUnchecked);
+				}
+			}
+
+			// draw item text
+			int cxButn = m_szButton.cx;
+			COLORREF colorBG = ::GetSysColor(bSelected ? COLOR_HIGHLIGHT : COLOR_MENU);
+			if(bSelected || lpDrawItemStruct->itemAction == ODA_SELECT)
+			{
+				RECT rcBG = rcItem;
+				if(bHasImage)
+					rcBG.left += cxButn + s_kcxGap;
+				dc.FillRect(&rcBG, bSelected ? COLOR_HIGHLIGHT : COLOR_MENU);
+			}
+
+			// calc text rectangle and colors
+			RECT rcText = rcItem;
+			rcText.left += cxButn + s_kcxGap + s_kcxTextMargin;
+			rcText.right -= cxButn;
+			dc.SetBkMode(TRANSPARENT);
+			COLORREF colorText = ::GetSysColor(bDisabled ?  (bSelected ? COLOR_GRAYTEXT : COLOR_3DSHADOW) : (bSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT));
+
+			// font already selected by Windows
+			if(bDisabled && (!bSelected || colorText == colorBG))
+			{
+				// disabled - draw shadow text shifted down and right 1 pixel (unles selected)
+				RECT rcDisabled = rcText;
+				::OffsetRect(&rcDisabled, 1, 1);
+				pT->DrawMenuText(dc, rcDisabled, pmd->lpstrText, ::GetSysColor(COLOR_3DHILIGHT));
+			}
+			pT->DrawMenuText(dc, rcText, pmd->lpstrText, colorText); // finally!
+		}
+	}
+
+	void DrawItemFlat(LPDRAWITEMSTRUCT lpDrawItemStruct)
+	{
+		_MenuItemData* pmd = (_MenuItemData*)lpDrawItemStruct->itemData;
+		CDCHandle dc = lpDrawItemStruct->hDC;
+		const RECT& rcItem = lpDrawItemStruct->rcItem;
+		T* pT = static_cast<T*>(this);
+
+#ifndef COLOR_MENUHILIGHT
+		const int COLOR_MENUHILIGHT = 29;
+#endif // !COLOR_MENUHILIGHT
+
+		BOOL bDisabled = lpDrawItemStruct->itemState & ODS_GRAYED;
+		BOOL bSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
+		BOOL bChecked = lpDrawItemStruct->itemState & ODS_CHECKED;
+
+		// paint background
+		if(bSelected || lpDrawItemStruct->itemAction == ODA_SELECT)
+		{
+			if(bSelected)
+			{
+				dc.FillRect(&rcItem, ::GetSysColorBrush(COLOR_MENUHILIGHT));
+				dc.FrameRect(&rcItem, ::GetSysColorBrush(COLOR_HIGHLIGHT));
+			}
+			else
+			{
+				dc.FillRect(&rcItem, ::GetSysColorBrush(COLOR_MENU));
+			}
+		}
+
+		if(pmd->fType & MFT_SEPARATOR)
+		{
+			// draw separator
+			RECT rc = rcItem;
+			rc.top += (rc.bottom - rc.top) / 2;      // vertical center
+			dc.DrawEdge(&rc, EDGE_ETCHED, BF_TOP);   // draw separator line
+		}
+		else		// not a separator
+		{
+			if(LOWORD(lpDrawItemStruct->itemID) == (WORD)-1)
+				bSelected = FALSE;
+			RECT rcButn = { rcItem.left, rcItem.top, rcItem.left + m_szButton.cx, rcItem.top + m_szButton.cy };   // button rect
+			::OffsetRect(&rcButn, 0, ((rcItem.bottom - rcItem.top) - (rcButn.bottom - rcButn.top)) / 2);          // center vertically
+
+			// draw background and border for checked items
+			if(bChecked)
+			{
+				RECT rcCheck = rcButn;
+				::InflateRect(&rcCheck, -1, -1);
+				if(bSelected)
+					dc.FillRect(&rcCheck, ::GetSysColorBrush(COLOR_MENU));
+				dc.FrameRect(&rcCheck, ::GetSysColorBrush(COLOR_HIGHLIGHT));
+			}
+
+			int iButton = pmd->iButton;
+			if(iButton >= 0)
+			{
+				// calc drawing point
+				SIZE sz = { rcButn.right - rcButn.left - m_szBitmap.cx, rcButn.bottom - rcButn.top - m_szBitmap.cy };
+				sz.cx /= 2;
+				sz.cy /= 2;
+				POINT point = { rcButn.left + sz.cx, rcButn.top + sz.cy };
+
+				// draw disabled or normal
+				if(!bDisabled)
+				{
+					::ImageList_Draw(m_hImageList, iButton, dc, point.x, point.y, ILD_TRANSPARENT);
+				}
+				else
+				{
+					HBRUSH hBrushBackground = ::GetSysColorBrush((bSelected && !(bDisabled && bChecked)) ? COLOR_MENUHILIGHT : COLOR_MENU);
+					HBRUSH hBrushDisabledImage = ::GetSysColorBrush(COLOR_3DSHADOW);
+					pT->DrawBitmapDisabled(dc, iButton, point, hBrushBackground, hBrushBackground, hBrushDisabledImage);
+				}
+			}
+			else
+			{
+				// no image - look for custom checked/unchecked bitmaps
+				CMenuItemInfo info;
+				info.fMask = MIIM_CHECKMARKS | MIIM_TYPE;
+				::GetMenuItemInfo((HMENU)lpDrawItemStruct->hwndItem, lpDrawItemStruct->itemID, MF_BYCOMMAND, &info);
+				if(bChecked || info.hbmpUnchecked != NULL)
+				{
+					BOOL bRadio = ((info.fType & MFT_RADIOCHECK) != 0);
+					pT->DrawCheckmark(dc, rcButn, bSelected, bDisabled, bRadio, bChecked ? info.hbmpChecked : info.hbmpUnchecked);
+				}
+			}
+
+			// draw item text
+			int cxButn = m_szButton.cx;
+			// calc text rectangle and colors
+			RECT rcText = rcItem;
+			rcText.left += cxButn + s_kcxGap + s_kcxTextMargin;
+			rcText.right -= cxButn;
+			dc.SetBkMode(TRANSPARENT);
+			COLORREF colorText = ::GetSysColor(bDisabled ?  (bSelected ? COLOR_GRAYTEXT : COLOR_3DSHADOW) : (bSelected ? COLOR_HIGHLIGHTTEXT : COLOR_MENUTEXT));
+
+			pT->DrawMenuText(dc, rcText, pmd->lpstrText, colorText); // finally!
+		}
+	}
+
+	void DrawMenuText(CDCHandle& dc, RECT& rc, LPCTSTR lpstrText, COLORREF color)
+	{
+		int nTab = -1;
+		for(int i = 0; i < lstrlen(lpstrText); i++)
+		{
+			if(lpstrText[i] == _T('\t'))
+			{
+				nTab = i;
+				break;
+			}
+		}
+		dc.SetTextColor(color);
+		dc.DrawText(lpstrText, nTab, &rc, DT_SINGLELINE | DT_LEFT | DT_VCENTER | (m_bShowKeyboardCues ? 0 : DT_HIDEPREFIX));
+		if(nTab != -1)
+			dc.DrawText(&lpstrText[nTab + 1], -1, &rc, DT_SINGLELINE | DT_RIGHT | DT_VCENTER | (m_bShowKeyboardCues ? 0 : DT_HIDEPREFIX));
+	}
+
+	void DrawBitmapDisabled(CDCHandle& dc, int nImage, POINT point,
+			HBRUSH hBrushBackground = ::GetSysColorBrush(COLOR_3DFACE),
+			HBRUSH hBrush3DEffect = ::GetSysColorBrush(COLOR_3DHILIGHT),
+			HBRUSH hBrushDisabledImage = ::GetSysColorBrush(COLOR_3DSHADOW))
+	{
+#if (_WIN32_WINNT >= 0x0501) && (_WIN32_IE >= 0x0501)
+		if(m_bAlphaImages)
+		{
+			IMAGELISTDRAWPARAMS ildp = { 0 };
+			ildp.cbSize = sizeof(IMAGELISTDRAWPARAMS);
+			ildp.himl = m_hImageList;
+			ildp.i = nImage;
+			ildp.hdcDst = dc;
+			ildp.x = point.x;
+			ildp.y = point.y;
+			ildp.cx = 0;
+			ildp.cy = 0;
+			ildp.xBitmap = 0;
+			ildp.yBitmap = 0;
+			ildp.fStyle = ILD_TRANSPARENT;
+			ildp.fState = ILS_SATURATE;
+			ildp.Frame = 0;
+			::ImageList_DrawIndirect(&ildp);
+		}
+		else
+#endif // (_WIN32_WINNT >= 0x0501) && (_WIN32_IE >= 0x0501)
+		{
+			// create memory DC
+			CDC dcMem;
+			dcMem.CreateCompatibleDC(dc);
+			// create mono or color bitmap
+			CBitmap bmp;
+			bmp.CreateCompatibleBitmap(dc, m_szBitmap.cx, m_szBitmap.cy);
+			ATLASSERT(bmp.m_hBitmap != NULL);
+			// draw image into memory DC--fill BG white first
+			HBITMAP hBmpOld = dcMem.SelectBitmap(bmp);
+			dcMem.PatBlt(0, 0, m_szBitmap.cx, m_szBitmap.cy, WHITENESS);
+			// If white is the text color, we can't use the normal painting since
+			// it would blend with the WHITENESS, but the mask is OK
+			UINT uDrawStyle = (::GetSysColor(COLOR_BTNTEXT) == RGB(255, 255, 255)) ? ILD_MASK : ILD_NORMAL;
+			::ImageList_Draw(m_hImageList, nImage, dcMem, 0, 0, uDrawStyle);
+			dc.DitherBlt(point.x, point.y, m_szBitmap.cx, m_szBitmap.cy, dcMem, NULL, 0, 0, hBrushBackground, hBrush3DEffect, hBrushDisabledImage);
+			dcMem.SelectBitmap(hBmpOld);   // restore
+		}
+	}
+
+	// old name
+	BOOL Draw3DCheckmark(CDCHandle& dc, const RECT& rc, BOOL bSelected, BOOL bDisabled, BOOL bRadio, HBITMAP hBmpCheck)
+	{
+		return DrawCheckmark(dc, rc, bSelected, bDisabled, bRadio, hBmpCheck);
+	}
+
+	BOOL DrawCheckmark(CDCHandle& dc, const RECT& rc, BOOL bSelected, BOOL bDisabled, BOOL bRadio, HBITMAP hBmpCheck)
+	{
+		// get checkmark bitmap, if none, use Windows standard
+		SIZE size = { 0, 0 };
+		CBitmapHandle bmp = hBmpCheck;
+		if(hBmpCheck != NULL)
+		{
+			bmp.GetSize(size);
+		}
+		else
+		{
+			size.cx = ::GetSystemMetrics(SM_CXMENUCHECK); 
+			size.cy = ::GetSystemMetrics(SM_CYMENUCHECK); 
+			bmp.CreateCompatibleBitmap(dc, size.cx, size.cy);
+			ATLASSERT(bmp.m_hBitmap != NULL);
+		}
+		// center bitmap in caller's rectangle
+		RECT rcDest = rc;
+		if((rc.right - rc.left) > size.cx)
+		{
+			rcDest.left = rc.left + (rc.right - rc.left - size.cx) / 2;
+			rcDest.right = rcDest.left + size.cx;
+		}
+		if((rc.bottom - rc.top) > size.cy)
+		{
+			rcDest.top = rc.top + (rc.bottom - rc.top - size.cy) / 2;
+			rcDest.bottom = rcDest.top + size.cy;
+		}
+		// paint background
+		if(!m_bFlatMenus)
+		{
+			if(bSelected && !bDisabled)
+			{
+				dc.FillRect(&rcDest, COLOR_MENU);
+			}
+			else
+			{
+				COLORREF clrTextOld = dc.SetTextColor(::GetSysColor(COLOR_BTNFACE));
+				COLORREF clrBkOld = dc.SetBkColor(::GetSysColor(COLOR_BTNHILIGHT));
+				CBrush hbr(CDCHandle::GetHalftoneBrush());
+				dc.SetBrushOrg(rcDest.left, rcDest.top);
+				dc.FillRect(&rcDest, hbr);
+				dc.SetTextColor(clrTextOld);
+				dc.SetBkColor(clrBkOld);
+			}
+		}
+
+		// create source image
+		CDC dcSource;
+		dcSource.CreateCompatibleDC(dc);
+		HBITMAP hBmpOld = dcSource.SelectBitmap(bmp);
+		// set colors
+		const COLORREF clrBlack = RGB(0, 0, 0);
+		const COLORREF clrWhite = RGB(255, 255, 255);
+		COLORREF clrTextOld = dc.SetTextColor(clrBlack);
+		COLORREF clrBkOld = dc.SetBkColor(clrWhite);
+		// create mask
+		CDC dcMask;
+		dcMask.CreateCompatibleDC(dc);
+		CBitmap bmpMask;
+		bmpMask.CreateBitmap(size.cx, size.cy, 1, 1, NULL);
+		HBITMAP hBmpOld1 = dcMask.SelectBitmap(bmpMask);
+
+		// draw the checkmark transparently
+		int cx = rcDest.right - rcDest.left;
+		int cy = rcDest.bottom - rcDest.top;
+		if(hBmpCheck != NULL)
+		{
+			// build mask based on transparent color	
+			dcSource.SetBkColor(m_clrMask);
+			dcMask.SetBkColor(clrBlack);
+			dcMask.SetTextColor(clrWhite);
+			dcMask.BitBlt(0, 0, size.cx, size.cy, dcSource, 0, 0, SRCCOPY);
+			// draw bitmap using the mask
+			dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, SRCINVERT);
+			dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcMask, 0, 0, SRCAND);
+			dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, SRCINVERT);
+		}
+		else
+		{
+			const DWORD ROP_DSno = 0x00BB0226L;
+			const DWORD ROP_DSa = 0x008800C6L;
+			const DWORD ROP_DSo = 0x00EE0086L;
+			const DWORD ROP_DSna = 0x00220326L;
+
+			// draw mask
+			RECT rcSource = { 0, 0, min(size.cx, rc.right - rc.left), min(size.cy, rc.bottom - rc.top) };
+			dcMask.DrawFrameControl(&rcSource, DFC_MENU, bRadio ? DFCS_MENUBULLET : DFCS_MENUCHECK);
+
+			// draw shadow if disabled
+			if(!m_bFlatMenus && bDisabled)
+			{
+				// offset by one pixel
+				int x = rcDest.left + 1;
+				int y = rcDest.top + 1;
+				// paint source bitmap
+				const int nColor = COLOR_3DHILIGHT;
+				dcSource.FillRect(&rcSource, nColor);
+				// draw checkmark - special case black and white colors
+				COLORREF clrCheck = ::GetSysColor(nColor);
+				if(clrCheck == clrWhite)
+				{
+					dc.BitBlt(x, y, cx, cy, dcMask,  0, 0,   ROP_DSno);
+					dc.BitBlt(x, y, cx, cy, dcSource, 0, 0, ROP_DSa);
+				}
+				else
+				{
+					if(clrCheck != clrBlack)
+					{
+						ATLASSERT(dcSource.GetTextColor() == clrBlack);
+						ATLASSERT(dcSource.GetBkColor() == clrWhite);
+						dcSource.BitBlt(0, 0, size.cx, size.cy, dcMask, 0, 0, ROP_DSna);
+					}
+					dc.BitBlt(x, y, cx, cy, dcMask,  0,  0,  ROP_DSa);
+					dc.BitBlt(x, y, cx, cy, dcSource, 0, 0, ROP_DSo);
+				}
+			}
+
+			// paint source bitmap
+			const int nColor = bDisabled ? COLOR_BTNSHADOW : COLOR_MENUTEXT;
+			dcSource.FillRect(&rcSource, nColor);
+			// draw checkmark - special case black and white colors
+			COLORREF clrCheck = ::GetSysColor(nColor);
+			if(clrCheck == clrWhite)
+			{
+				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcMask,  0, 0,   ROP_DSno);
+				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, ROP_DSa);
+			}
+			else
+			{
+				if(clrCheck != clrBlack)
+				{
+					ATLASSERT(dcSource.GetTextColor() == clrBlack);
+					ATLASSERT(dcSource.GetBkColor() == clrWhite);
+					dcSource.BitBlt(0, 0, size.cx, size.cy, dcMask, 0, 0, ROP_DSna);
+				}
+				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcMask,  0,  0,  ROP_DSa);
+				dc.BitBlt(rcDest.left, rcDest.top, cx, cy, dcSource, 0, 0, ROP_DSo);
+			}
+		}
+		// restore all
+		dc.SetTextColor(clrTextOld);
+		dc.SetBkColor(clrBkOld);
+		dcSource.SelectBitmap(hBmpOld);
+		dcMask.SelectBitmap(hBmpOld1);
+		if(hBmpCheck == NULL)
+			bmp.DeleteObject();
+		// draw pushed-in hilight
+		if(!m_bFlatMenus && !bDisabled)
+		{
+			if(rc.right - rc.left > size.cx)
+				::InflateRect(&rcDest, 1,1);   // inflate checkmark by one pixel all around
+			dc.DrawEdge(&rcDest, BDR_SUNKENOUTER, BF_RECT);
+		}
+
+		return TRUE;
+	}
+
+	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
+	{
+		_MenuItemData* pmd = (_MenuItemData*)lpMeasureItemStruct->itemData;
+
+		if(pmd->fType & MFT_SEPARATOR)   // separator - use half system height and zero width
+		{
+			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU) / 2;
+			lpMeasureItemStruct->itemWidth  = 0;
+		}
+		else
+		{
+			// compute size of text - use DrawText with DT_CALCRECT
+			CWindowDC dc(NULL);
+			CFont fontBold;
+			HFONT hOldFont = NULL;
+			if(pmd->fState & MFS_DEFAULT)
+			{
+				// need bold version of font
+				LOGFONT lf = { 0 };
+				m_fontMenu.GetLogFont(lf);
+				lf.lfWeight += 200;
+				fontBold.CreateFontIndirect(&lf);
+				ATLASSERT(fontBold.m_hFont != NULL);
+				hOldFont = dc.SelectFont(fontBold);
+			}
+			else
+			{
+				hOldFont = dc.SelectFont(m_fontMenu);
+			}
+
+			RECT rcText = { 0, 0, 0, 0 };
+			dc.DrawText(pmd->lpstrText, -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_CALCRECT);
+			int cx = rcText.right - rcText.left;
+			dc.SelectFont(hOldFont);
+
+			LOGFONT lf = { 0 };
+			m_fontMenu.GetLogFont(lf);
+			int cy = lf.lfHeight;
+			if(cy < 0)
+				cy = -cy;
+			const int cyMargin = 8;
+			cy += cyMargin;
+
+			// height of item is the bigger of these two
+			lpMeasureItemStruct->itemHeight = max(cy, (int)m_szButton.cy);
+
+			// width is width of text plus a bunch of stuff
+			cx += 2 * s_kcxTextMargin;   // L/R margin for readability
+			cx += s_kcxGap;              // space between button and menu text
+			cx += 2 * m_szButton.cx;     // button width (L=button; R=empty margin)
+			cx += m_cxExtraSpacing;      // extra between item text and accelerator keys
+
+			// Windows adds 1 to returned value
+			cx -= ::GetSystemMetrics(SM_CXMENUCHECK) - 1;
+			lpMeasureItemStruct->itemWidth = cx;   // done deal
+		}
+	}
+
+// Implementation - Hook procs
+	static LRESULT CALLBACK CreateHookProc(int nCode, WPARAM wParam, LPARAM lParam)
+	{
+		const int cchClassName = 7;
+		TCHAR szClassName[cchClassName] = { 0 };
+
+		if(nCode == HCBT_CREATEWND)
+		{
+			HWND hWndMenu = (HWND)wParam;
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("CmdBar - HCBT_CREATEWND (HWND = %8.8X)\n"), hWndMenu);
+#endif
+
+			::GetClassName(hWndMenu, szClassName, cchClassName);
+			if(!lstrcmp(_T("#32768"), szClassName))
+				s_pCurrentBar->m_stackMenuWnd.Push(hWndMenu);
+		}
+		else if(nCode == HCBT_DESTROYWND)
+		{
+			HWND hWndMenu = (HWND)wParam;
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("CmdBar - HCBT_DESTROYWND (HWND = %8.8X)\n"), hWndMenu);
+#endif
+
+			::GetClassName(hWndMenu, szClassName, cchClassName);
+			if(!lstrcmp(_T("#32768"), szClassName))
+			{
+				ATLASSERT(hWndMenu == s_pCurrentBar->m_stackMenuWnd.GetCurrent());
+				s_pCurrentBar->m_stackMenuWnd.Pop();
+			}
+		}
+
+		return ::CallNextHookEx(s_hCreateHook, nCode, wParam, lParam);
+	}
+
+	static LRESULT CALLBACK MessageHookProc(int nCode, WPARAM wParam, LPARAM lParam)
+	{
+		LPMSG pMsg = (LPMSG)lParam;
+
+		if(nCode == HC_ACTION && wParam == PM_REMOVE && pMsg->message != GetGetBarMessage() && pMsg->message != WM_FORWARDMSG)
+		{
+			CCommandBarCtrlBase* pCmdBar = NULL;
+			HWND hWnd = pMsg->hwnd;
+			DWORD dwPID = 0;
+			while(pCmdBar == NULL && hWnd != NULL)
+			{
+				pCmdBar = (CCommandBarCtrlBase*)::SendMessage(hWnd, GetGetBarMessage(), (WPARAM)&dwPID, 0L);
+				hWnd = ::GetParent(hWnd);
+			}
+
+			if(pCmdBar != NULL && dwPID == GetCurrentProcessId())
+			{
+				pCmdBar->m_hWndHook = pMsg->hwnd;
+				ATLASSERT(pCmdBar->IsCommandBarBase());
+
+				if(::IsWindow(pCmdBar->m_hWnd))
+					pCmdBar->SendMessage(WM_FORWARDMSG, 0, (LPARAM)pMsg);
+				else
+					ATLTRACE2(atlTraceUI, 0, _T("CmdBar - Hook skipping message, can't find command bar!\n"));
+			}
+		}
+
+		LRESULT lRet = 0;
+		ATLASSERT(s_pmapMsgHook != NULL);
+		if(s_pmapMsgHook != NULL)
+		{
+			DWORD dwThreadID = ::GetCurrentThreadId();
+			_MsgHookData* pData = s_pmapMsgHook->Lookup(dwThreadID);
+			if(pData != NULL)
+			{
+				lRet = ::CallNextHookEx(pData->hMsgHook, nCode, wParam, lParam);
+			}
+		}
+		return lRet;
+	}
+
+// Implementation
+	void DoPopupMenu(int nIndex, bool bAnimate)
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - DoPopupMenu, bAnimate = %s\n"), bAnimate ? "true" : "false");
+#endif
+
+		// Menu animation flags
+#ifndef TPM_VERPOSANIMATION
+		const UINT TPM_VERPOSANIMATION = 0x1000L;
+#endif
+#ifndef TPM_NOANIMATION
+		const UINT TPM_NOANIMATION = 0x4000L;
+#endif
+		T* pT = static_cast<T*>(this);
+
+		// get popup menu and it's position
+		RECT rect = { 0 };
+		GetItemRect(nIndex, &rect);
+		POINT pt = { rect.left, rect.bottom };
+		MapWindowPoints(NULL, &pt, 1);
+		MapWindowPoints(NULL, &rect);
+		TPMPARAMS TPMParams = { 0 };
+		TPMParams.cbSize = sizeof(TPMPARAMS);
+		TPMParams.rcExclude = rect;
+		HMENU hMenuPopup = ::GetSubMenu(m_hMenu, nIndex);
+		ATLASSERT(hMenuPopup != NULL);
+
+		// get button ID
+		TBBUTTON tbb = { 0 };
+		GetButton(nIndex, &tbb);
+		int nCmdID = tbb.idCommand;
+
+		m_nPopBtn = nIndex;   // remember current button's index
+
+		// press button and display popup menu
+		PressButton(nCmdID, TRUE);
+		SetHotItem(nCmdID);
+		pT->DoTrackPopupMenu(hMenuPopup, TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN |
+			(s_bW2K ? (bAnimate ? TPM_VERPOSANIMATION : TPM_NOANIMATION) : 0), pt.x, pt.y, &TPMParams);
+		PressButton(nCmdID, FALSE);
+		if(::GetFocus() != m_hWnd)
+			SetHotItem(-1);
+
+		m_nPopBtn = -1;   // restore
+
+		// eat next message if click is on the same button
+		MSG msg = { 0 };
+		if(::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_NOREMOVE) && ::PtInRect(&rect, msg.pt))
+			::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
+
+		// check if another popup menu should be displayed
+		if(m_nNextPopBtn != -1)
+		{
+			PostMessage(GetAutoPopupMessage(), m_nNextPopBtn & 0xFFFF);
+			if(!(m_nNextPopBtn & 0xFFFF0000) && !m_bPopupItem)
+				PostMessage(WM_KEYDOWN, VK_DOWN, 0);
+			m_nNextPopBtn = -1;
+		}
+		else
+		{
+			m_bContextMenu = false;
+			// If user didn't hit escape, give focus back
+			if(!m_bEscapePressed)
+			{
+				if(m_bUseKeyboardCues && m_bShowKeyboardCues)
+					m_bAllowKeyboardCues = false;
+				pT->GiveFocusBack();
+			}
+			else
+			{
+				SetHotItem(nCmdID);
+				SetAnchorHighlight(TRUE);
+			}
+		}
+	}
+
+	BOOL DoTrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, LPTPMPARAMS lpParams = NULL)
+	{
+		CMenuHandle menuPopup = hMenu;
+
+		CWindowCreateCriticalSectionLock lock;
+		if(FAILED(lock.Lock()))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CCommandBarCtrlImpl::DoTrackPopupMenu.\n"));
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		ATLASSERT(s_hCreateHook == NULL);
+
+		s_pCurrentBar = static_cast<CCommandBarCtrlBase*>(this);
+
+		s_hCreateHook = ::SetWindowsHookEx(WH_CBT, CreateHookProc, ModuleHelper::GetModuleInstance(), GetCurrentThreadId());
+		ATLASSERT(s_hCreateHook != NULL);
+
+		m_bPopupItem = false;
+		m_bMenuActive = true;
+
+		BOOL bTrackRet = menuPopup.TrackPopupMenuEx(uFlags, x, y, m_hWnd, lpParams);
+		m_bMenuActive = false;
+
+		::UnhookWindowsHookEx(s_hCreateHook);
+
+		s_hCreateHook = NULL;
+		s_pCurrentBar = NULL;
+
+		lock.Unlock();
+
+		// cleanup - convert menus back to original state
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - TrackPopupMenu - cleanup\n"));
+#endif
+
+		ATLASSERT(m_stackMenuWnd.GetSize() == 0);
+
+		UpdateWindow();
+		ATL::CWindow wndTL = GetTopLevelParent();
+		wndTL.UpdateWindow();
+
+		// restore the menu items to the previous state for all menus that were converted
+		if(m_bImagesVisible)
+		{
+			HMENU hMenuSav = NULL;
+			while((hMenuSav = m_stackMenuHandle.Pop()) != NULL)
+			{
+				menuPopup = hMenuSav;
+				BOOL bRet = FALSE;
+				// restore state and delete menu item data
+				for(int i = 0; i < menuPopup.GetMenuItemCount(); i++)
+				{
+					CMenuItemInfo mii;
+					mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_ID;
+					bRet = menuPopup.GetMenuItemInfo(i, TRUE, &mii);
+					ATLASSERT(bRet);
+
+					_MenuItemData* pMI = (_MenuItemData*)mii.dwItemData;
+					if(pMI != NULL && pMI->IsCmdBarMenuItem())
+					{
+						mii.fMask = MIIM_DATA | MIIM_TYPE | MIIM_STATE;
+						mii.fType = pMI->fType;
+						mii.fState = pMI->fState;
+						mii.dwTypeData = pMI->lpstrText;
+						mii.cch = lstrlen(pMI->lpstrText);
+						mii.dwItemData = NULL;
+
+						bRet = menuPopup.SetMenuItemInfo(i, TRUE, &mii);
+						// this one triggers WM_MEASUREITEM
+						menuPopup.ModifyMenu(i, MF_BYPOSITION | mii.fType | mii.fState, mii.wID, pMI->lpstrText);
+						ATLASSERT(bRet);
+
+						delete [] pMI->lpstrText;
+						delete pMI;
+					}
+				}
+			}
+		}
+		return bTrackRet;
+	}
+
+	int GetPreviousMenuItem(int nBtn) const
+	{
+		if(nBtn == -1)
+			return -1;
+#if (_WIN32_IE >= 0x0500)
+		RECT rcClient;
+		GetClientRect(&rcClient);
+#endif // (_WIN32_IE >= 0x0500)
+		int nNextBtn;
+		for(nNextBtn = nBtn - 1; nNextBtn != nBtn; nNextBtn--)
+		{
+			if(nNextBtn < 0)
+				nNextBtn = ::GetMenuItemCount(m_hMenu) - 1;
+			TBBUTTON tbb = { 0 };
+			GetButton(nNextBtn, &tbb);
+#if (_WIN32_IE >= 0x0500)
+			RECT rcBtn;
+			GetItemRect(nNextBtn, &rcBtn);
+			if(rcBtn.right > rcClient.right)
+			{
+				nNextBtn = -2;   // chevron
+				break;
+			}
+#endif // (_WIN32_IE >= 0x0500)
+			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0)
+				break;
+		}
+		return (nNextBtn != nBtn) ? nNextBtn : -1;
+	}
+
+	int GetNextMenuItem(int nBtn) const
+	{
+		if(nBtn == -1)
+			return -1;
+#if (_WIN32_IE >= 0x0500)
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+#endif // (_WIN32_IE >= 0x0500)
+		int nNextBtn = 0;
+		int nCount = ::GetMenuItemCount(m_hMenu);
+		for(nNextBtn = nBtn + 1; nNextBtn != nBtn; nNextBtn++)
+		{
+			if(nNextBtn >= nCount)
+				nNextBtn = 0;
+			TBBUTTON tbb = { 0 };
+			GetButton(nNextBtn, &tbb);
+#if (_WIN32_IE >= 0x0500)
+			RECT rcBtn = { 0 };
+			GetItemRect(nNextBtn, &rcBtn);
+			if(rcBtn.right > rcClient.right)
+			{
+				nNextBtn = -2;   // chevron
+				break;
+			}
+#endif // (_WIN32_IE >= 0x0500)
+			if((tbb.fsState & TBSTATE_ENABLED) != 0 && (tbb.fsState & TBSTATE_HIDDEN) == 0)
+				break;
+		}
+		return (nNextBtn != nBtn) ? nNextBtn : -1;
+	}
+
+#if (_WIN32_IE >= 0x0500)
+	bool DisplayChevronMenu()
+	{
+		// assume we are in a rebar
+		HWND hWndReBar = GetParent();
+		int nCount = (int)::SendMessage(hWndReBar, RB_GETBANDCOUNT, 0, 0L);
+		bool bRet = false;
+		for(int i = 0; i < nCount; i++)
+		{
+			REBARBANDINFO rbbi = { RunTimeHelper::SizeOf_REBARBANDINFO(), RBBIM_CHILD | RBBIM_STYLE };
+			BOOL bRetBandInfo = (BOOL)::SendMessage(hWndReBar, RB_GETBANDINFO, i, (LPARAM)&rbbi);
+			if(bRetBandInfo && rbbi.hwndChild == m_hWnd)
+			{
+				if((rbbi.fStyle & RBBS_USECHEVRON) != 0)
+				{
+					::PostMessage(hWndReBar, RB_PUSHCHEVRON, i, 0L);
+					PostMessage(WM_KEYDOWN, VK_DOWN, 0L);
+					bRet = true;
+				}
+				break;
+			}
+		}
+		return bRet;
+	}
+#endif // (_WIN32_IE >= 0x0500)
+
+	void GetSystemSettings()
+	{
+		// refresh our font
+		NONCLIENTMETRICS info = { RunTimeHelper::SizeOf_NONCLIENTMETRICS() };
+		BOOL bRet = ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(info), &info, 0);
+		ATLASSERT(bRet);
+		if(bRet)
+		{
+			LOGFONT logfont = { 0 };
+			if(m_fontMenu.m_hFont != NULL)
+				m_fontMenu.GetLogFont(logfont);
+			if(logfont.lfHeight != info.lfMenuFont.lfHeight ||
+			   logfont.lfWidth != info.lfMenuFont.lfWidth ||
+			   logfont.lfEscapement != info.lfMenuFont.lfEscapement ||
+			   logfont.lfOrientation != info.lfMenuFont.lfOrientation ||
+			   logfont.lfWeight != info.lfMenuFont.lfWeight ||
+			   logfont.lfItalic != info.lfMenuFont.lfItalic ||
+			   logfont.lfUnderline != info.lfMenuFont.lfUnderline ||
+			   logfont.lfStrikeOut != info.lfMenuFont.lfStrikeOut ||
+			   logfont.lfCharSet != info.lfMenuFont.lfCharSet ||
+			   logfont.lfOutPrecision != info.lfMenuFont.lfOutPrecision ||
+			   logfont.lfClipPrecision != info.lfMenuFont.lfClipPrecision ||
+			   logfont.lfQuality != info.lfMenuFont.lfQuality ||
+			   logfont.lfPitchAndFamily != info.lfMenuFont.lfPitchAndFamily ||
+			   lstrcmp(logfont.lfFaceName, info.lfMenuFont.lfFaceName) != 0)
+			{
+				HFONT hFontMenu = ::CreateFontIndirect(&info.lfMenuFont);
+				ATLASSERT(hFontMenu != NULL);
+				if(hFontMenu != NULL)
+				{
+					if(m_fontMenu.m_hFont != NULL)
+						m_fontMenu.DeleteObject();
+					m_fontMenu.Attach(hFontMenu);
+					SetFont(m_fontMenu);
+					AddStrings(_T("NS\0"));   // for proper item height
+					AutoSize();
+				}
+			}
+		}
+
+		// check if we need extra spacing for menu item text
+		CWindowDC dc(m_hWnd);
+		HFONT hFontOld = dc.SelectFont(m_fontMenu);
+		RECT rcText = { 0, 0, 0, 0 };
+		dc.DrawText(_T("\t"), -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_CALCRECT);
+		if((rcText.right - rcText.left) < 4)
+		{
+			::SetRectEmpty(&rcText);
+			dc.DrawText(_T("x"), -1, &rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_CALCRECT);
+			m_cxExtraSpacing = rcText.right - rcText.left;
+		}
+		else
+		{
+			m_cxExtraSpacing = 0;
+		}
+		dc.SelectFont(hFontOld);
+
+		// get Windows version
+		OSVERSIONINFO ovi = { sizeof(OSVERSIONINFO) };
+		::GetVersionEx(&ovi);
+
+		// query keyboard cues mode (Windows 2000 or later)
+		if(ovi.dwMajorVersion >= 5)
+		{
+#ifndef SPI_GETKEYBOARDCUES
+			const UINT SPI_GETKEYBOARDCUES = 0x100A;
+#endif // !SPI_GETKEYBOARDCUES
+			BOOL bRetVal = TRUE;
+			bRet = ::SystemParametersInfo(SPI_GETKEYBOARDCUES, 0, &bRetVal, 0);
+			m_bUseKeyboardCues = (bRet && !bRetVal);
+			m_bAllowKeyboardCues = true;
+			ShowKeyboardCues(!m_bUseKeyboardCues);
+		}
+
+		// query flat menu mode (Windows XP or later)
+		if((ovi.dwMajorVersion == 5 && ovi.dwMinorVersion >= 1) || (ovi.dwMajorVersion > 5))
+		{
+#ifndef SPI_GETFLATMENU
+			const UINT SPI_GETFLATMENU = 0x1022;
+#endif // !SPI_GETFLATMENU
+			BOOL bRetVal = FALSE;
+			bRet = ::SystemParametersInfo(SPI_GETFLATMENU, 0, &bRetVal, 0);
+			m_bFlatMenus = (bRet && bRetVal);
+		}
+
+#if _WTL_CMDBAR_VISTA_MENUS
+		// check if we should use Vista menus
+		bool bVistaMenus = (RunTimeHelper::IsVista() && RunTimeHelper::IsCommCtrl6() && ((m_dwExtendedStyle & CBR_EX_NOVISTAMENUS) == 0));
+
+		if(bVistaMenus)
+		{
+			HMODULE hThemeDLL = ::LoadLibrary(_T("uxtheme.dll"));
+			if(hThemeDLL != NULL)
+			{
+				typedef BOOL (STDAPICALLTYPE *PFN_IsThemeActive)();
+				PFN_IsThemeActive pfnIsThemeActive = (PFN_IsThemeActive)::GetProcAddress(hThemeDLL, "IsThemeActive");
+				ATLASSERT(pfnIsThemeActive != NULL);
+				bVistaMenus = bVistaMenus && (pfnIsThemeActive != NULL) && (pfnIsThemeActive() != FALSE);
+
+				typedef BOOL (STDAPICALLTYPE *PFN_IsAppThemed)();
+				PFN_IsAppThemed pfnIsAppThemed = (PFN_IsAppThemed)::GetProcAddress(hThemeDLL, "IsAppThemed");
+				ATLASSERT(pfnIsAppThemed != NULL);
+				bVistaMenus = bVistaMenus && (pfnIsAppThemed != NULL) && (pfnIsAppThemed() != FALSE);
+
+				::FreeLibrary(hThemeDLL);
+			}
+		}
+
+		if(!bVistaMenus && m_bVistaMenus && (m_hMenu != NULL) && (m_arrCommand.GetSize() > 0))
+		{
+			T* pT = static_cast<T*>(this);
+			pT->_RemoveVistaBitmapsFromMenu();
+		}
+
+		m_bVistaMenus = bVistaMenus;
+#endif // _WTL_CMDBAR_VISTA_MENUS
+
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("CmdBar - GetSystemSettings:\n     m_bFlatMenus = %s\n     m_bUseKeyboardCues = %s     m_bVistaMenus = %s\n"),
+			m_bFlatMenus ? "true" : "false", m_bUseKeyboardCues ? "true" : "false", m_bVistaMenus ? "true" : "false");
+#endif
+	}
+
+// Implementation - alternate focus mode support
+	void TakeFocus()
+	{
+		if((m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && m_hWndFocus == NULL)
+			m_hWndFocus = ::GetFocus();
+		SetFocus();
+	}
+
+	void GiveFocusBack()
+	{
+		if(m_bParentActive)
+		{
+			if((m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && ::IsWindow(m_hWndFocus))
+				::SetFocus(m_hWndFocus);
+			else if(!(m_dwExtendedStyle & CBR_EX_ALTFOCUSMODE) && m_wndParent.IsWindow())
+				m_wndParent.SetFocus();
+		}
+		m_hWndFocus = NULL;
+		SetAnchorHighlight(FALSE);
+		if(m_bUseKeyboardCues && m_bShowKeyboardCues)
+			ShowKeyboardCues(false);
+		m_bSkipPostDown = false;
+	}
+
+	void ShowKeyboardCues(bool bShow)
+	{
+		m_bShowKeyboardCues = bShow;
+		SetDrawTextFlags(DT_HIDEPREFIX, m_bShowKeyboardCues ? 0 : DT_HIDEPREFIX);
+		Invalidate();
+		UpdateWindow();
+	}
+
+// Implementation - internal message helpers
+	static UINT GetAutoPopupMessage()
+	{
+		static UINT uAutoPopupMessage = 0;
+		if(uAutoPopupMessage == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CCommandBarCtrlImpl::GetAutoPopupMessage.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uAutoPopupMessage == 0)
+				uAutoPopupMessage = ::RegisterWindowMessage(_T("WTL_CmdBar_InternalAutoPopupMsg"));
+
+			lock.Unlock();
+		}
+		ATLASSERT(uAutoPopupMessage != 0);
+		return uAutoPopupMessage;
+	}
+
+	static UINT GetGetBarMessage()
+	{
+		static UINT uGetBarMessage = 0;
+		if(uGetBarMessage == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CCommandBarCtrlImpl::GetGetBarMessage.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uGetBarMessage == 0)
+				uGetBarMessage = ::RegisterWindowMessage(_T("WTL_CmdBar_InternalGetBarMsg"));
+
+			lock.Unlock();
+		}
+		ATLASSERT(uGetBarMessage != 0);
+		return uGetBarMessage;
+	}
+
+// Implementation
+	bool CreateInternalImageList(int cImages)
+	{
+		UINT uFlags = (m_bAlphaImages ? ILC_COLOR32 : ILC_COLOR24) | ILC_MASK;
+		m_hImageList = ::ImageList_Create(m_szBitmap.cx, m_szBitmap.cy, uFlags, cImages, 1);
+		ATLASSERT(m_hImageList != NULL);
+		return (m_hImageList != NULL);
+	}
+
+// Implementation - support for Vista menus
+#if _WTL_CMDBAR_VISTA_MENUS
+	void _AddVistaBitmapsFromImageList(int nStartIndex, int nCount)
+	{
+		// Create display compatible memory DC
+		CClientDC dc(NULL);
+		CDC dcMem;
+		dcMem.CreateCompatibleDC(dc);
+		HBITMAP hBitmapSave = dcMem.GetCurrentBitmap();
+
+		T* pT = static_cast<T*>(this);
+		// Create bitmaps for all menu items
+		for(int i = 0; i < nCount; i++)
+		{
+			HBITMAP hBitmap = pT->_CreateVistaBitmapHelper(nStartIndex + i, dc, dcMem);
+			dcMem.SelectBitmap(hBitmapSave);
+			m_arrVistaBitmap.Add(hBitmap);
+		}
+	}
+
+	void _AddVistaBitmapFromImageList(int nIndex)
+	{
+		// Create display compatible memory DC
+		CClientDC dc(NULL);
+		CDC dcMem;
+		dcMem.CreateCompatibleDC(dc);
+		HBITMAP hBitmapSave = dcMem.GetCurrentBitmap();
+
+		// Create bitmap for menu item
+		T* pT = static_cast<T*>(this);
+		HBITMAP hBitmap = pT->_CreateVistaBitmapHelper(nIndex, dc, dcMem);
+
+		// Select saved bitmap back and add bitmap to the array
+		dcMem.SelectBitmap(hBitmapSave);
+		m_arrVistaBitmap.Add(hBitmap);
+	}
+
+	void _ReplaceVistaBitmapFromImageList(int nIndex)
+	{
+		// Delete existing bitmap
+		if(m_arrVistaBitmap[nIndex] != NULL)
+			::DeleteObject(m_arrVistaBitmap[nIndex]);
+
+		// Create display compatible memory DC
+		CClientDC dc(NULL);
+		CDC dcMem;
+		dcMem.CreateCompatibleDC(dc);
+		HBITMAP hBitmapSave = dcMem.GetCurrentBitmap();
+
+		// Create bitmap for menu item
+		T* pT = static_cast<T*>(this);
+		HBITMAP hBitmap = pT->_CreateVistaBitmapHelper(nIndex, dc, dcMem);
+
+		// Select saved bitmap back and replace bitmap in the array
+		dcMem.SelectBitmap(hBitmapSave);
+		m_arrVistaBitmap.SetAtIndex(nIndex, hBitmap);
+	}
+
+	HBITMAP _CreateVistaBitmapHelper(int nIndex, HDC hDCSource, HDC hDCTarget)
+	{
+		// Create 32-bit bitmap
+		BITMAPINFO bi = { 0 };
+		bi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+		bi.bmiHeader.biWidth = m_szBitmap.cx;
+		bi.bmiHeader.biHeight = m_szBitmap.cy;
+		bi.bmiHeader.biPlanes = 1;
+		bi.bmiHeader.biBitCount = 32;
+		bi.bmiHeader.biCompression = BI_RGB;
+		bi.bmiHeader.biSizeImage = 0;
+		bi.bmiHeader.biXPelsPerMeter = 0;
+		bi.bmiHeader.biYPelsPerMeter = 0;
+		bi.bmiHeader.biClrUsed = 0;
+		bi.bmiHeader.biClrImportant = 0;
+		HBITMAP hBitmap = ::CreateDIBSection(hDCSource, &bi, DIB_RGB_COLORS, NULL, NULL, 0);
+		ATLASSERT(hBitmap != NULL);
+
+		// Select bitmap into target DC and draw from image list to it
+		if(hBitmap != NULL)
+		{
+			::SelectObject(hDCTarget, hBitmap);
+
+			IMAGELISTDRAWPARAMS ildp = { 0 };
+			ildp.cbSize = sizeof(IMAGELISTDRAWPARAMS);
+			ildp.himl = m_hImageList;
+			ildp.i = nIndex;
+			ildp.hdcDst = hDCTarget;
+			ildp.x = 0;
+			ildp.y = 0;
+			ildp.cx = 0;
+			ildp.cy = 0;
+			ildp.xBitmap = 0;
+			ildp.yBitmap = 0;
+			ildp.fStyle = ILD_TRANSPARENT;
+			ildp.fState = ILS_ALPHA;
+			ildp.Frame = 255;
+			::ImageList_DrawIndirect(&ildp);
+		}
+
+		return hBitmap;
+	}
+
+	void _RemoveVistaBitmapsFromMenu()
+	{
+		CMenuHandle menu = m_hMenu;
+		for(int i = 0; i < m_arrCommand.GetSize(); i++)
+		{
+			CMenuItemInfo mii;
+			mii.fMask = MIIM_BITMAP;
+			mii.hbmpItem = NULL;
+			menu.SetMenuItemInfo(m_arrCommand[i], FALSE, &mii);
+		}
+	}
+#endif // _WTL_CMDBAR_VISTA_MENUS
+};
+
+
+class CCommandBarCtrl : public CCommandBarCtrlImpl<CCommandBarCtrl>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_CommandBar"), GetWndClassName())
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMDICommandBarCtrl - ATL implementation of Command Bars for MDI apps
+
+template <class T, class TBase = CCommandBarCtrlBase, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CMDICommandBarCtrlImpl : public CCommandBarCtrlImpl< T, TBase, TWinTraits>
+{
+public:
+// Data members
+	ATL::CContainedWindow m_wndMDIClient;
+	bool m_bChildMaximized;
+	HWND m_hWndChildMaximized;
+	HICON m_hIconChildMaximized;
+	int m_nBtnPressed;
+	int m_nBtnWasPressed;
+
+	int m_cxyOffset;      // offset between nonclient elements
+	int m_cxIconWidth;    // small icon width
+	int m_cyIconHeight;   // small icon height
+	int m_cxBtnWidth;     // nonclient button width
+	int m_cyBtnHeight;    // nonclient button height
+	int m_cxLeft;         // left nonclient area width
+	int m_cxRight;        // right nonclient area width
+
+// Theme declarations and data members
+#ifndef _WTL_NO_AUTO_THEME
+#ifndef _UXTHEME_H_
+	typedef HANDLE HTHEME;
+#endif // !_UXTHEME_H_
+	typedef HTHEME (STDAPICALLTYPE *PFN_OpenThemeData)(HWND hwnd, LPCWSTR pszClassList);
+	typedef HRESULT (STDAPICALLTYPE *PFN_CloseThemeData)(HTHEME hTheme);
+	typedef HRESULT (STDAPICALLTYPE *PFN_DrawThemeBackground)(HTHEME hTheme, HDC hdc, int iPartId, int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);
+	typedef HRESULT (STDAPICALLTYPE *PFN_DrawThemeParentBackground)(HWND hwnd, HDC hdc, OPTIONAL RECT* prc);
+
+	HMODULE m_hThemeDLL;
+	HTHEME m_hTheme;
+	PFN_DrawThemeBackground m_pfnDrawThemeBackground;
+	PFN_DrawThemeParentBackground m_pfnDrawThemeParentBackground;
+#endif // !_WTL_NO_AUTO_THEME
+
+// Constructor/destructor
+	CMDICommandBarCtrlImpl() : 
+			m_wndMDIClient(this, 2), m_bChildMaximized(false), 
+			m_hWndChildMaximized(NULL), m_hIconChildMaximized(NULL), 
+			m_nBtnPressed(-1), m_nBtnWasPressed(-1),
+#ifndef _WTL_NO_AUTO_THEME
+			m_hThemeDLL(NULL), m_hTheme(NULL), m_pfnDrawThemeBackground(NULL), m_pfnDrawThemeParentBackground(NULL), 
+#endif // !_WTL_NO_AUTO_THEME
+			m_cxyOffset(2),
+			m_cxIconWidth(16), m_cyIconHeight(16),
+			m_cxBtnWidth(16), m_cyBtnHeight(14),
+			m_cxLeft(20), m_cxRight(55)
+	{ }
+
+	~CMDICommandBarCtrlImpl()
+	{
+		if(m_wndMDIClient.IsWindow())
+/*scary!*/			m_wndMDIClient.UnsubclassWindow();
+	}
+
+// Operations
+	BOOL SetMDIClient(HWND hWndMDIClient)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(::IsWindow(hWndMDIClient));
+		if(!::IsWindow(hWndMDIClient))
+			return FALSE;
+
+#ifdef _DEBUG
+		// BLOCK: Test if the passed window is MDICLIENT
+		{
+			LPCTSTR lpszMDIClientClass = _T("MDICLIENT");
+			const int nNameLen = 9 + 1;   // "MDICLIENT" + NULL
+			TCHAR szClassName[nNameLen] = { 0 };
+			::GetClassName(hWndMDIClient, szClassName, nNameLen);
+			ATLASSERT(lstrcmpi(szClassName, lpszMDIClientClass) == 0);
+		}
+#endif // _DEBUG
+
+		if(m_wndMDIClient.IsWindow())
+/*scary!*/		m_wndMDIClient.UnsubclassWindow();
+
+		return m_wndMDIClient.SubclassWindow(hWndMDIClient);
+	}
+
+// Message maps
+	typedef CCommandBarCtrlImpl< T, TBase, TWinTraits >   _baseClass;
+	BEGIN_MSG_MAP(CMDICommandBarCtrlImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+#ifndef _WTL_NO_AUTO_THEME
+		MESSAGE_HANDLER(_GetThemeChangedMsg(), OnThemeChanged)
+#endif // !_WTL_NO_AUTO_THEME
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_NCCALCSIZE, OnNcCalcSize)
+		MESSAGE_HANDLER(WM_NCPAINT, OnNcPaint)
+		MESSAGE_HANDLER(WM_NCHITTEST, OnNcHitTest)
+		MESSAGE_HANDLER(WM_NCLBUTTONDOWN, OnNcLButtonDown)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
+		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
+		MESSAGE_HANDLER(WM_NCLBUTTONDBLCLK, OnNcLButtonDblClk)
+		MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
+		CHAIN_MSG_MAP(_baseClass)
+	ALT_MSG_MAP(1)   // Parent window messages
+		MESSAGE_HANDLER(WM_ACTIVATE, OnParentActivate)
+		CHAIN_MSG_MAP_ALT(_baseClass, 1)
+	ALT_MSG_MAP(2)   // MDI client window messages
+		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
+		// no chaining needed since this was moved from the base class here
+	ALT_MSG_MAP(3)   // Message hook messages
+		MESSAGE_RANGE_HANDLER(0, 0xFFFF, OnAllHookMessages)
+		CHAIN_MSG_MAP_ALT(_baseClass, 3)
+	END_MSG_MAP()
+
+// Additional MDI message handlers
+	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		LRESULT lRet = _baseClass::OnCreate(uMsg, wParam, lParam, bHandled);
+		if(lRet == (LRESULT)-1)
+			return lRet;
+
+#ifndef _WTL_NO_AUTO_THEME
+		// this will fail if theming is not supported
+		m_hThemeDLL = ::LoadLibrary(_T("uxtheme.dll"));
+		if(m_hThemeDLL != NULL)
+		{
+			m_pfnDrawThemeBackground = (PFN_DrawThemeBackground)::GetProcAddress(m_hThemeDLL, "DrawThemeBackground");
+			ATLASSERT(m_pfnDrawThemeBackground != NULL);
+			if(m_pfnDrawThemeBackground != NULL)
+			{
+				T* pT = static_cast<T*>(this);
+				pT->_OpenThemeData();
+			}
+			else
+			{
+				::FreeLibrary(m_hThemeDLL);
+				m_hThemeDLL = NULL;
+			}
+			m_pfnDrawThemeParentBackground = (PFN_DrawThemeParentBackground)::GetProcAddress(m_hThemeDLL, "DrawThemeParentBackground");
+			ATLASSERT(m_pfnDrawThemeParentBackground != NULL);
+		}
+#endif // !_WTL_NO_AUTO_THEME
+
+		return lRet;
+	}
+
+	LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		LRESULT lRet = _baseClass::OnDestroy(uMsg, wParam, lParam, bHandled);
+
+#ifndef _WTL_NO_AUTO_THEME
+		if(m_hThemeDLL != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->_CloseThemeData();
+			::FreeLibrary(m_hThemeDLL);
+			m_hThemeDLL = NULL;
+		}
+#endif // !_WTL_NO_AUTO_THEME
+
+		return lRet;
+	}
+
+#ifndef _WTL_NO_AUTO_THEME
+	LRESULT OnThemeChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_hThemeDLL != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->_CloseThemeData();
+			pT->_OpenThemeData();
+		}
+		return 0;
+	}
+#endif // !_WTL_NO_AUTO_THEME
+
+	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+		T* pT = static_cast<T*>(this);
+		pT->_AdjustBtnSize(GET_Y_LPARAM(lParam));
+		return lRet;
+	}
+
+	LRESULT OnNcCalcSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+
+		if(m_bChildMaximized && (BOOL)wParam)
+		{
+			LPNCCALCSIZE_PARAMS lpParams = (LPNCCALCSIZE_PARAMS)lParam;
+			if(m_bLayoutRTL)
+			{
+				lpParams->rgrc[0].left += m_cxRight;
+				lpParams->rgrc[0].right -= m_cxLeft;
+			}
+			else
+			{
+				lpParams->rgrc[0].left += m_cxLeft;
+				lpParams->rgrc[0].right -= m_cxRight;
+			}
+		}
+
+		return lRet;
+	}
+
+	LRESULT OnNcPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+
+		if(!m_bChildMaximized)
+			return lRet;
+
+		ATLASSERT(m_hWndChildMaximized != NULL && m_hIconChildMaximized != NULL);
+
+		// get DC and window rectangle
+		CWindowDC dc(m_hWnd);
+		RECT rect;
+		GetWindowRect(&rect);
+		int cxWidth = rect.right - rect.left;
+		int cyHeight = rect.bottom - rect.top;
+
+		// paint left side nonclient background and draw icon
+		::SetRect(&rect, 0, 0, m_cxLeft, cyHeight);
+#ifndef _WTL_NO_AUTO_THEME
+		if(m_hTheme != NULL)
+		{
+			if(m_pfnDrawThemeParentBackground != NULL)
+				m_pfnDrawThemeParentBackground(m_hWnd, dc, &rect);
+			else
+				dc.FillRect(&rect, COLOR_WINDOW);
+		}
+		else
+#endif // !_WTL_NO_AUTO_THEME
+		{
+			if((m_dwExtendedStyle & CBR_EX_TRANSPARENT) != 0)
+				dc.FillRect(&rect, COLOR_3DFACE);
+			else
+				dc.FillRect(&rect, COLOR_MENU);
+		}
+
+		RECT rcIcon = { 0 };
+		T* pT = static_cast<T*>(this);
+		pT->_CalcIconRect(cxWidth, cyHeight, rcIcon);
+		dc.DrawIconEx(rcIcon.left, rcIcon.top, m_hIconChildMaximized, m_cxIconWidth, m_cyIconHeight);
+
+		// paint right side nonclient background
+		::SetRect(&rect, cxWidth - m_cxRight, 0, cxWidth, cyHeight);
+#ifndef _WTL_NO_AUTO_THEME
+		if(m_hTheme != NULL)
+		{
+			if(m_pfnDrawThemeParentBackground != NULL)
+			{
+				// this is to account for the left non-client area
+				POINT ptOrg = { 0, 0 };
+				dc.GetViewportOrg(&ptOrg);
+				dc.SetViewportOrg(ptOrg.x + m_cxLeft, ptOrg.y);
+				::OffsetRect(&rect, -m_cxLeft, 0);
+
+				m_pfnDrawThemeParentBackground(m_hWnd, dc, &rect);
+
+				// restore
+				dc.SetViewportOrg(ptOrg);
+				::OffsetRect(&rect, m_cxLeft, 0);
+			}
+			else
+			{
+				dc.FillRect(&rect, COLOR_3DFACE);
+			}
+		}
+		else
+#endif // !_WTL_NO_AUTO_THEME
+		{
+			if((m_dwExtendedStyle & CBR_EX_TRANSPARENT) != 0)
+				dc.FillRect(&rect, COLOR_3DFACE);
+			else
+				dc.FillRect(&rect, COLOR_MENU);
+		}
+
+		// draw buttons
+		RECT arrRect[3] = { 0 };
+		pT->_CalcBtnRects(cxWidth, cyHeight, arrRect);
+		pT->_DrawMDIButton(dc, arrRect, -1);   // draw all buttons
+
+		return lRet;
+	}
+
+	LRESULT OnNcHitTest(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+		if(m_bChildMaximized)
+		{
+			RECT rect = { 0 };
+			GetWindowRect(&rect);
+			POINT pt = { GET_X_LPARAM(lParam) - rect.left, GET_Y_LPARAM(lParam) - rect.top };
+			if(m_bLayoutRTL)
+			{
+				if((pt.x < m_cxRight) || (pt.x > ((rect.right - rect.left) - m_cxLeft)))
+					lRet = HTBORDER;
+			}
+			else
+			{
+				if((pt.x < m_cxLeft) || (pt.x > ((rect.right - rect.left) - m_cxRight)))
+					lRet = HTBORDER;
+			}
+		}
+		return lRet;
+	}
+
+	LRESULT OnNcLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(!m_bChildMaximized)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		ATLASSERT(_DebugCheckChild());
+
+		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		RECT rect = { 0 };
+		GetWindowRect(&rect);
+		pt.x -= rect.left;
+		pt.y -= rect.top;
+
+		RECT rcIcon = { 0 };
+		T* pT = static_cast<T*>(this);
+		pT->_CalcIconRect(rect.right - rect.left, rect.bottom - rect.top, rcIcon, m_bLayoutRTL);
+		RECT arrRect[3] = { 0 };
+		pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect, m_bLayoutRTL);
+
+		if(::PtInRect(&rcIcon, pt))
+		{
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonDown: icon\n"));
+#endif
+#ifndef TPM_VERPOSANIMATION
+			const UINT TPM_VERPOSANIMATION = 0x1000L;   // Menu animation flag
+#endif
+			CMenuHandle menu = ::GetSystemMenu(m_hWndChildMaximized, FALSE);
+			UINT uRet = (UINT)menu.TrackPopupMenu(TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN | TPM_RETURNCMD |  
+				(s_bW2K ? TPM_VERPOSANIMATION : 0), m_bLayoutRTL ? rect.right : rect.left, rect.bottom, m_hWndChildMaximized);
+
+			// eat next message if click is on the same button
+			::OffsetRect(&rcIcon, rect.left, rect.top);
+			MSG msg = { 0 };
+			if(::PeekMessage(&msg, m_hWnd, WM_NCLBUTTONDOWN, WM_NCLBUTTONDOWN, PM_NOREMOVE) && ::PtInRect(&rcIcon, msg.pt))
+				::PeekMessage(&msg, m_hWnd, WM_NCLBUTTONDOWN, WM_NCLBUTTONDOWN, PM_REMOVE);
+
+			if(uRet != 0)
+				::SendMessage(m_hWndChildMaximized, WM_SYSCOMMAND, uRet, 0L);
+		}
+		else if(::PtInRect(&arrRect[0], pt))
+		{
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonDown: close button\n"));
+#endif
+			m_nBtnWasPressed = m_nBtnPressed = 0;
+		}
+		else if(::PtInRect(&arrRect[1], pt))
+		{
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonDown: restore button\n"));
+#endif
+			m_nBtnWasPressed = m_nBtnPressed = 1;
+		}
+		else if(::PtInRect(&arrRect[2], pt))
+		{
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonDown: minimize button\n"));
+#endif
+			m_nBtnWasPressed = m_nBtnPressed = 2;
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+
+		// draw the button state if it was pressed
+		if(m_nBtnPressed != -1)
+		{
+			SetCapture();
+			CWindowDC dc(m_hWnd);
+			pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect);
+			pT->_DrawMDIButton(dc, arrRect, m_nBtnPressed);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(!m_bChildMaximized || ::GetCapture() != m_hWnd || m_nBtnWasPressed == -1)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		ClientToScreen(&pt);
+		RECT rect = { 0 };
+		GetWindowRect(&rect);
+		pt.x -= rect.left;
+		pt.y -= rect.top;
+		RECT arrRect[3] = { 0 };
+		T* pT = static_cast<T*>(this);
+		pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect, m_bLayoutRTL);
+		int nOldBtnPressed = m_nBtnPressed;
+		m_nBtnPressed = ::PtInRect(&arrRect[m_nBtnWasPressed], pt) ? m_nBtnWasPressed : -1;
+		if(nOldBtnPressed != m_nBtnPressed)
+		{
+			CWindowDC dc(m_hWnd);
+			pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect);
+			pT->_DrawMDIButton(dc, arrRect, (m_nBtnPressed != -1) ? m_nBtnPressed : nOldBtnPressed);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(!m_bChildMaximized || ::GetCapture() != m_hWnd || m_nBtnWasPressed == -1)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		ATLASSERT(_DebugCheckChild());
+
+		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		ClientToScreen(&pt);
+		RECT rect = { 0 };
+		GetWindowRect(&rect);
+		pt.x -= rect.left;
+		pt.y -= rect.top;
+
+		int nBtn = m_nBtnWasPressed;
+		ReleaseCapture();
+
+		RECT arrRect[3] = { 0 };
+		T* pT = static_cast<T*>(this);
+		pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect, m_bLayoutRTL);
+		if(::PtInRect(&arrRect[nBtn], pt))
+		{
+			switch(nBtn)
+			{
+			case 0:		// close
+#ifdef _CMDBAR_EXTRA_TRACE
+				ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonUp: close button\n"));
+#endif
+				::SendMessage(m_hWndChildMaximized, WM_SYSCOMMAND, SC_CLOSE, 0L);
+				break;
+			case 1:		// restore
+#ifdef _CMDBAR_EXTRA_TRACE
+				ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonUp: restore button\n"));
+#endif
+				::SendMessage(m_hWndChildMaximized, WM_SYSCOMMAND, SC_RESTORE, 0L);
+				break;
+			case 2:		// minimize
+#ifdef _CMDBAR_EXTRA_TRACE
+				ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - LButtonUp: minimize button\n"));
+#endif
+				::SendMessage(m_hWndChildMaximized, WM_SYSCOMMAND, SC_MINIMIZE, 0L);
+				break;
+			default:
+				break;
+			}
+		}
+
+		return 0;
+	}
+
+	LRESULT OnNcLButtonDblClk(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(!m_bChildMaximized || m_nBtnWasPressed != -1)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		ATLASSERT(_DebugCheckChild());
+
+		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		RECT rect = { 0 };
+		GetWindowRect(&rect);
+		pt.x -= rect.left;
+		pt.y -= rect.top;
+
+		RECT rcIcon = { 0 };
+		T* pT = static_cast<T*>(this);
+		pT->_CalcIconRect(rect.right - rect.left, rect.bottom - rect.top, rcIcon, m_bLayoutRTL);
+		RECT arrRect[3] = { 0 };
+		pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect, m_bLayoutRTL);
+
+		if(::PtInRect(&rcIcon, pt))
+		{
+			CMenuHandle menu = ::GetSystemMenu(m_hWndChildMaximized, FALSE);
+			UINT uDefID = menu.GetMenuDefaultItem();
+			if(uDefID == (UINT)-1)
+				uDefID = SC_CLOSE;
+			::SendMessage(m_hWndChildMaximized, WM_SYSCOMMAND, uDefID, 0L);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_bChildMaximized)
+		{
+			if(m_nBtnPressed != -1)
+			{
+				ATLASSERT(m_nBtnPressed == m_nBtnWasPressed);   // must be
+				m_nBtnPressed = -1;
+				RECT rect = { 0 };
+				GetWindowRect(&rect);
+				RECT arrRect[3] = { 0 };
+				T* pT = static_cast<T*>(this);
+				pT->_CalcBtnRects(rect.right - rect.left, rect.bottom - rect.top, arrRect);
+				CWindowDC dc(m_hWnd);
+				pT->_DrawMDIButton(dc, arrRect, m_nBtnWasPressed);
+			}
+			m_nBtnWasPressed = -1;
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+		return 0;
+	}
+
+// Parent window message handlers
+	LRESULT OnParentActivate(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		m_bParentActive = (LOWORD(wParam) != WA_INACTIVE);
+		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_FRAME | RDW_UPDATENOW);
+		bHandled = FALSE;
+		return 1;
+	}
+
+// MDI client window message handlers
+	LRESULT OnMDISetMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		m_wndMDIClient.DefWindowProc(uMsg, NULL, lParam);
+		HMENU hOldMenu = GetMenu();
+		BOOL bRet = AttachMenu((HMENU)wParam);
+		bRet;   // avoid level 4 warning
+		ATLASSERT(bRet);
+
+#if (_WIN32_IE >= 0x0400)
+		T* pT = static_cast<T*>(this);
+		pT->UpdateRebarBandIdealSize();
+#endif // (_WIN32_IE >= 0x0400)
+
+		return (LRESULT)hOldMenu;
+	}
+
+// All messages from the message hook
+	LRESULT OnAllHookMessages(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->_ProcessAllHookMessages(uMsg, wParam, lParam);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+// Overrideables
+	// override this to provide different ideal size
+	void UpdateRebarBandIdealSize()
+	{
+		// assuming we are in a rebar, change ideal size to our size
+		// we hope that if we are not in a rebar, nCount will be 0
+		int nCount = (int)::SendMessage(GetParent(), RB_GETBANDCOUNT, 0, 0L);
+		for(int i = 0; i < nCount; i++)
+		{
+			REBARBANDINFO rbi = { RunTimeHelper::SizeOf_REBARBANDINFO(), RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE };
+			::SendMessage(GetParent(), RB_GETBANDINFO, i, (LPARAM)&rbi);
+			if(rbi.hwndChild == m_hWnd)
+			{
+				rbi.fMask = RBBIM_IDEALSIZE;
+				rbi.cxIdeal = m_bChildMaximized ? m_cxLeft + m_cxRight : 0;
+				int nBtnCount = GetButtonCount();
+				if(nBtnCount > 0)
+				{
+					RECT rect = { 0 };
+					GetItemRect(nBtnCount - 1, &rect);
+					rbi.cxIdeal += rect.right;
+				}
+				::SendMessage(GetParent(), RB_SETBANDINFO, i, (LPARAM)&rbi);
+				break;
+			}
+		}
+	}
+
+	// all hook messages - check for the maximized MDI child window change
+	void _ProcessAllHookMessages(UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/)
+	{
+		if(uMsg == WM_MDIGETACTIVE || uMsg == WM_MDISETMENU)
+			return;
+
+		BOOL bMaximized = FALSE;
+		HWND hWndChild = (HWND)::SendMessage(m_wndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)&bMaximized);
+		bool bMaxOld = m_bChildMaximized;
+		m_bChildMaximized = (hWndChild != NULL && bMaximized);
+		HICON hIconOld = m_hIconChildMaximized;
+
+		if(m_bChildMaximized)
+		{
+			if(m_hWndChildMaximized != hWndChild)
+			{
+				ATL::CWindow wnd = m_hWndChildMaximized = hWndChild;
+				m_hIconChildMaximized = wnd.GetIcon(FALSE);
+				if(m_hIconChildMaximized == NULL)
+				{
+					m_hIconChildMaximized = wnd.GetIcon(TRUE);
+					if(m_hIconChildMaximized == NULL)
+					{
+						// no icon set with WM_SETICON, get the class one
+// need conditional code because types don't match in winuser.h
+#ifdef _WIN64
+						m_hIconChildMaximized = (HICON)::GetClassLongPtr(wnd, GCLP_HICONSM);
+#else
+						m_hIconChildMaximized = (HICON)LongToHandle(::GetClassLongPtr(wnd, GCLP_HICONSM));
+#endif
+					}
+				}
+			}
+		}
+		else
+		{
+			m_hWndChildMaximized = NULL;
+			m_hIconChildMaximized = NULL;
+		}
+
+		if(bMaxOld != m_bChildMaximized)
+		{
+#ifdef _CMDBAR_EXTRA_TRACE
+			ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - All messages hook change: m_bChildMaximized = %s\n"), m_bChildMaximized ? "true" : "false");
+#endif
+			// assuming we are in a rebar, change our size to accomodate new state
+			// we hope that if we are not in a rebar, nCount will be 0
+			int nCount = (int)::SendMessage(GetParent(), RB_GETBANDCOUNT, 0, 0L);
+			int cxDiff = (m_bChildMaximized ? 1 : -1) * (m_cxLeft + m_cxRight);
+			for(int i = 0; i < nCount; i++)
+			{
+#if (_WIN32_IE >= 0x0500)
+				REBARBANDINFO rbi = { RunTimeHelper::SizeOf_REBARBANDINFO(), RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE | RBBIM_STYLE };
+				::SendMessage(GetParent(), RB_GETBANDINFO, i, (LPARAM)&rbi);
+				if(rbi.hwndChild == m_hWnd)
+				{
+					if((rbi.fStyle & RBBS_USECHEVRON) != 0)
+					{
+						rbi.fMask = RBBIM_CHILDSIZE | RBBIM_IDEALSIZE;
+						rbi.cxMinChild += cxDiff;
+						rbi.cxIdeal += cxDiff;
+						::SendMessage(GetParent(), RB_SETBANDINFO, i, (LPARAM)&rbi);
+					}
+					break;
+				}
+#elif (_WIN32_IE >= 0x0400)
+				REBARBANDINFO rbi = { RunTimeHelper::SizeOf_REBARBANDINFO(), RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_IDEALSIZE };
+				::SendMessage(GetParent(), RB_GETBANDINFO, i, (LPARAM)&rbi);
+				if(rbi.hwndChild == m_hWnd)
+				{
+					rbi.fMask = RBBIM_CHILDSIZE | RBBIM_IDEALSIZE;
+					rbi.cxMinChild += cxDiff;
+					rbi.cxIdeal += cxDiff;
+					::SendMessage(GetParent(), RB_SETBANDINFO, i, (LPARAM)&rbi);
+					break;
+				}
+#else // (_WIN32_IE < 0x0400)
+				REBARBANDINFO rbi = { RunTimeHelper::SizeOf_REBARBANDINFO(), RBBIM_CHILD | RBBIM_CHILDSIZE };
+				::SendMessage(GetParent(), RB_GETBANDINFO, i, (LPARAM)&rbi);
+				if(rbi.hwndChild == m_hWnd)
+				{
+					rbi.fMask = RBBIM_CHILDSIZE;
+					rbi.cxMinChild += cxDiff;
+					::SendMessage(GetParent(), RB_SETBANDINFO, i, (LPARAM)&rbi);
+					break;
+				}
+#endif // (_WIN32_IE < 0x0400)
+			}
+		}
+
+		if(bMaxOld != m_bChildMaximized || hIconOld != m_hIconChildMaximized)
+		{
+			// force size change and redraw everything
+			RECT rect = { 0 };
+			GetWindowRect(&rect);
+			::MapWindowPoints(NULL, GetParent(), (LPPOINT)&rect, 2);
+			SetRedraw(FALSE);
+			SetWindowPos(NULL, 0, 0, 1, 1, SWP_NOZORDER | SWP_NOMOVE);
+			SetWindowPos(NULL, &rect, SWP_NOZORDER | SWP_NOMOVE);
+			SetRedraw(TRUE);
+			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW);
+		}
+	}
+
+// Implementation
+	void GetSystemSettings()
+	{
+#ifdef _CMDBAR_EXTRA_TRACE
+		ATLTRACE2(atlTraceUI, 0, _T("MDI CmdBar - GetSystemSettings\n"));
+#endif
+		_baseClass::GetSystemSettings();
+
+		NONCLIENTMETRICS info = { RunTimeHelper::SizeOf_NONCLIENTMETRICS() };
+		BOOL bRet = ::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(info), &info, 0);
+		ATLASSERT(bRet);
+		if(bRet)
+		{
+			m_cxIconWidth = ::GetSystemMetrics(SM_CXSMICON);
+			m_cyIconHeight = ::GetSystemMetrics(SM_CYSMICON);
+			m_cxLeft = m_cxIconWidth;
+
+#ifndef _WTL_NO_AUTO_THEME
+			if(m_hTheme != NULL)
+			{
+				m_cxBtnWidth = info.iCaptionWidth - 2 * m_cxyOffset;
+				m_cyBtnHeight = info.iCaptionHeight - 2 * m_cxyOffset;
+				m_cxRight = 3 * m_cxBtnWidth;
+			}
+			else
+#endif // !_WTL_NO_AUTO_THEME
+			{
+				m_cxBtnWidth = info.iCaptionWidth - m_cxyOffset;
+				m_cyBtnHeight = info.iCaptionHeight - 2 * m_cxyOffset;
+				m_cxRight = 3 * m_cxBtnWidth + m_cxyOffset;
+			}
+		}
+
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+		T* pT = static_cast<T*>(this);
+		pT->_AdjustBtnSize(rect.bottom);
+	}
+
+	void _AdjustBtnSize(int cyHeight)
+	{
+		if(cyHeight > 1 && m_cyBtnHeight > cyHeight)
+		{
+#ifndef _WTL_NO_AUTO_THEME
+			if(m_hTheme != NULL)
+			{
+				m_cyBtnHeight = cyHeight;
+				m_cxBtnWidth = cyHeight;
+				m_cxRight = 3 * m_cxBtnWidth;
+			}
+			else
+#endif // !_WTL_NO_AUTO_THEME
+			{
+				m_cyBtnHeight = cyHeight;
+				m_cxBtnWidth = cyHeight + m_cxyOffset;
+				m_cxRight = 3 * m_cxBtnWidth + m_cxyOffset;
+			}
+		}
+	}
+
+	void _CalcIconRect(int cxWidth, int cyHeight, RECT& rect, bool bInvertX = false) const
+	{
+		int xStart = (m_cxLeft - m_cxIconWidth) / 2;
+		if(xStart < 0)
+			xStart = 0;
+		int yStart = (cyHeight - m_cyIconHeight) / 2;
+		if(yStart < 0)
+			yStart = 0;
+
+		if(bInvertX)
+			::SetRect(&rect, cxWidth - (xStart + m_cxBtnWidth), yStart, cxWidth - xStart, yStart + m_cyBtnHeight);
+		else
+			::SetRect(&rect, xStart, yStart, xStart + m_cxBtnWidth, yStart + m_cyBtnHeight);
+	}
+
+	void _CalcBtnRects(int cxWidth, int cyHeight, RECT arrRect[3], bool bInvertX = false) const
+	{
+		int yStart = (cyHeight - m_cyBtnHeight) / 2;
+		if(yStart < 0)
+			yStart = 0;
+
+		RECT rcBtn = { cxWidth - m_cxBtnWidth, yStart, cxWidth, yStart + m_cyBtnHeight };
+		int nDirection = -1;
+		if(bInvertX)
+		{
+			::SetRect(&rcBtn, 0, yStart, m_cxBtnWidth, yStart + m_cyBtnHeight);
+			nDirection = 1;
+		}
+
+		arrRect[0] = rcBtn;
+#ifndef _WTL_NO_AUTO_THEME
+		if(m_hTheme != NULL)
+			::OffsetRect(&rcBtn, nDirection * m_cxBtnWidth, 0);
+		else
+#endif // !_WTL_NO_AUTO_THEME
+			::OffsetRect(&rcBtn, nDirection * (m_cxBtnWidth + m_cxyOffset), 0);
+		arrRect[1] = rcBtn;
+		::OffsetRect(&rcBtn, nDirection * m_cxBtnWidth, 0);
+		arrRect[2] = rcBtn;
+	}
+
+	void _DrawMDIButton(CWindowDC& dc, LPRECT pRects, int nBtn)
+	{
+#ifndef _WTL_NO_AUTO_THEME
+		if(m_hTheme != NULL)
+		{
+#ifndef TMSCHEMA_H
+			const int WP_MDICLOSEBUTTON = 20;
+			const int CBS_NORMAL = 1;
+			const int CBS_PUSHED = 3;
+			const int CBS_DISABLED = 4;
+			const int WP_MDIRESTOREBUTTON = 22;
+			const int RBS_NORMAL = 1;
+			const int RBS_PUSHED = 3;
+			const int RBS_DISABLED = 4;
+			const int WP_MDIMINBUTTON = 16;
+			const int MINBS_NORMAL = 1;
+			const int MINBS_PUSHED = 3;
+			const int MINBS_DISABLED = 4;
+#endif // TMSCHEMA_H
+			if(nBtn == -1 || nBtn == 0)
+				m_pfnDrawThemeBackground(m_hTheme, dc, WP_MDICLOSEBUTTON, m_bParentActive ? ((m_nBtnPressed == 0) ? CBS_PUSHED : CBS_NORMAL) : CBS_DISABLED, &pRects[0], NULL);
+			if(nBtn == -1 || nBtn == 1)
+				m_pfnDrawThemeBackground(m_hTheme, dc, WP_MDIRESTOREBUTTON, m_bParentActive ? ((m_nBtnPressed == 1) ? RBS_PUSHED : RBS_NORMAL) : RBS_DISABLED, &pRects[1], NULL);
+			if(nBtn == -1 || nBtn == 2)
+				m_pfnDrawThemeBackground(m_hTheme, dc, WP_MDIMINBUTTON, m_bParentActive ? ((m_nBtnPressed == 2) ? MINBS_PUSHED : MINBS_NORMAL) : MINBS_DISABLED, &pRects[2], NULL);
+		}
+		else
+#endif // !_WTL_NO_AUTO_THEME
+		{
+			if(nBtn == -1 || nBtn == 0)
+				dc.DrawFrameControl(&pRects[0], DFC_CAPTION, DFCS_CAPTIONCLOSE | ((m_nBtnPressed == 0) ? DFCS_PUSHED : 0));
+			if(nBtn == -1 || nBtn == 1)
+				dc.DrawFrameControl(&pRects[1], DFC_CAPTION, DFCS_CAPTIONRESTORE | ((m_nBtnPressed == 1) ? DFCS_PUSHED : 0));
+			if(nBtn == -1 || nBtn == 2)
+				dc.DrawFrameControl(&pRects[2], DFC_CAPTION, DFCS_CAPTIONMIN | ((m_nBtnPressed == 2) ? DFCS_PUSHED : 0));
+		}
+	}
+
+#ifndef _WTL_NO_AUTO_THEME
+	static UINT _GetThemeChangedMsg()
+	{
+#ifndef WM_THEMECHANGED
+		static const UINT WM_THEMECHANGED = 0x031A;
+#endif // !WM_THEMECHANGED
+		return WM_THEMECHANGED;
+	}
+
+	void _OpenThemeData()
+	{
+		ATLASSERT(m_hThemeDLL != NULL);
+
+		PFN_OpenThemeData pfnOpenThemeData = (PFN_OpenThemeData)::GetProcAddress(m_hThemeDLL, "OpenThemeData");
+		ATLASSERT(pfnOpenThemeData != NULL);
+		if(pfnOpenThemeData != NULL)
+			m_hTheme = pfnOpenThemeData(m_hWnd, L"Window");
+	}
+
+	void _CloseThemeData()
+	{
+		ATLASSERT(m_hThemeDLL != NULL);
+
+		if(m_hTheme == NULL)
+			return;   // nothing to do
+
+		PFN_CloseThemeData pfnCloseThemeData = (PFN_CloseThemeData)::GetProcAddress(m_hThemeDLL, "CloseThemeData");
+		ATLASSERT(pfnCloseThemeData != NULL);
+		if(pfnCloseThemeData != NULL)
+		{
+			pfnCloseThemeData(m_hTheme);
+			m_hTheme = NULL;
+		}
+	}
+#endif // !_WTL_NO_AUTO_THEME
+
+	bool _DebugCheckChild()
+	{
+#ifdef _DEBUG
+		BOOL bMaximized = FALSE;
+		HWND hWndChild = (HWND)::SendMessage(m_wndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)&bMaximized);
+		return (bMaximized && hWndChild == m_hWndChildMaximized);
+#else // !_DEBUG
+		return true;
+#endif // !_DEBUG
+	}
+};
+
+class CMDICommandBarCtrl : public CMDICommandBarCtrlImpl<CMDICommandBarCtrl>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_MDICommandBar"), GetWndClassName())
+};
+
+}; // namespace WTL
+
+#endif // __ATLCTRLW_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlctrlx.h b/GLideN64/src/GLideNUI-wtl/WTL/atlctrlx.h
new file mode 100644
index 00000000..2b94be71
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlctrlx.h
@@ -0,0 +1,4979 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLCTRLX_H__
+#define __ATLCTRLX_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlctrlx.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLCTRLS_H__
+	#error atlctrlx.h requires atlctrls.h to be included first
+#endif
+
+#ifndef WM_UPDATEUISTATE
+  #define WM_UPDATEUISTATE                0x0128
+#endif // !WM_UPDATEUISTATE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CBitmapButtonImpl<T, TBase, TWinTraits>
+// CBitmapButton
+// CCheckListViewCtrlImpl<T, TBase, TWinTraits>
+// CCheckListViewCtrl
+// CHyperLinkImpl<T, TBase, TWinTraits>
+// CHyperLink
+// CWaitCursor
+// CCustomWaitCursor
+// CMultiPaneStatusBarCtrlImpl<T, TBase>
+// CMultiPaneStatusBarCtrl
+// CPaneContainerImpl<T, TBase, TWinTraits>
+// CPaneContainer
+// CSortListViewImpl<T>
+// CSortListViewCtrlImpl<T, TBase, TWinTraits>
+// CSortListViewCtrl
+// CTabViewImpl<T, TBase, TWinTraits>
+// CTabView
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CBitmapButton - bitmap button implementation
+
+#ifndef _WIN32_WCE
+
+// bitmap button extended styles
+#define BMPBTN_HOVER		0x00000001
+#define BMPBTN_AUTO3D_SINGLE	0x00000002
+#define BMPBTN_AUTO3D_DOUBLE	0x00000004
+#define BMPBTN_AUTOSIZE		0x00000008
+#define BMPBTN_SHAREIMAGELISTS	0x00000010
+#define BMPBTN_AUTOFIRE		0x00000020
+
+template <class T, class TBase = CButton, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CBitmapButtonImpl : public ATL::CWindowImpl< T, TBase, TWinTraits>
+{
+public:
+	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())
+
+	enum
+	{
+		_nImageNormal = 0,
+		_nImagePushed,
+		_nImageFocusOrHover,
+		_nImageDisabled,
+
+		_nImageCount = 4,
+	};
+
+	enum
+	{
+		ID_TIMER_FIRST = 1000,
+		ID_TIMER_REPEAT = 1001
+	};
+
+	// Bitmap button specific extended styles
+	DWORD m_dwExtendedStyle;
+
+	CImageList m_ImageList;
+	int m_nImage[_nImageCount];
+
+	CToolTipCtrl m_tip;
+	LPTSTR m_lpstrToolTipText;
+
+	// Internal states
+	unsigned m_fMouseOver:1;
+	unsigned m_fFocus:1;
+	unsigned m_fPressed:1;
+
+
+// Constructor/Destructor
+	CBitmapButtonImpl(DWORD dwExtendedStyle = BMPBTN_AUTOSIZE, HIMAGELIST hImageList = NULL) : 
+			m_ImageList(hImageList), m_dwExtendedStyle(dwExtendedStyle), 
+			m_lpstrToolTipText(NULL),
+			m_fMouseOver(0), m_fFocus(0), m_fPressed(0)
+	{
+		m_nImage[_nImageNormal] = -1;
+		m_nImage[_nImagePushed] = -1;
+		m_nImage[_nImageFocusOrHover] = -1;
+		m_nImage[_nImageDisabled] = -1;
+	}
+
+	~CBitmapButtonImpl()
+	{
+		if((m_dwExtendedStyle & BMPBTN_SHAREIMAGELISTS) == 0)
+			m_ImageList.Destroy();
+		delete [] m_lpstrToolTipText;
+	}
+
+	// overridden to provide proper initialization
+	BOOL SubclassWindow(HWND hWnd)
+	{
+#if (_MSC_VER >= 1300)
+		BOOL bRet = ATL::CWindowImpl< T, TBase, TWinTraits>::SubclassWindow(hWnd);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImpl< T, TBase, TWinTraits>   _baseClass;
+		BOOL bRet = _baseClass::SubclassWindow(hWnd);
+#endif // !(_MSC_VER >= 1300)
+		if(bRet)
+			Init();
+		return bRet;
+	}
+
+// Attributes
+	DWORD GetBitmapButtonExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+	DWORD SetBitmapButtonExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		return dwPrevStyle;
+	}
+
+	HIMAGELIST GetImageList() const
+	{
+		return m_ImageList;
+	}
+
+	HIMAGELIST SetImageList(HIMAGELIST hImageList)
+	{
+		HIMAGELIST hImageListPrev = m_ImageList;
+		m_ImageList = hImageList;
+		if((m_dwExtendedStyle & BMPBTN_AUTOSIZE) != 0 && ::IsWindow(m_hWnd))
+			SizeToImage();
+		return hImageListPrev;
+	}
+
+	int GetToolTipTextLength() const
+	{
+		return (m_lpstrToolTipText == NULL) ? -1 : lstrlen(m_lpstrToolTipText);
+	}
+
+	bool GetToolTipText(LPTSTR lpstrText, int nLength) const
+	{
+		ATLASSERT(lpstrText != NULL);
+		if(m_lpstrToolTipText == NULL)
+			return false;
+
+		errno_t nRet = SecureHelper::strncpy_x(lpstrText, nLength, m_lpstrToolTipText, _TRUNCATE);
+
+		return (nRet == 0 || nRet == STRUNCATE);
+	}
+
+	bool SetToolTipText(LPCTSTR lpstrText)
+	{
+		if(m_lpstrToolTipText != NULL)
+		{
+			delete [] m_lpstrToolTipText;
+			m_lpstrToolTipText = NULL;
+		}
+
+		if(lpstrText == NULL)
+		{
+			if(m_tip.IsWindow())
+				m_tip.Activate(FALSE);
+			return true;
+		}
+
+		int cchLen = lstrlen(lpstrText) + 1;
+		ATLTRY(m_lpstrToolTipText = new TCHAR[cchLen]);
+		if(m_lpstrToolTipText == NULL)
+			return false;
+
+		SecureHelper::strcpy_x(m_lpstrToolTipText, cchLen, lpstrText);
+		if(m_tip.IsWindow())
+		{
+			m_tip.Activate(TRUE);
+			m_tip.AddTool(m_hWnd, m_lpstrToolTipText);
+		}
+
+		return true;
+	}
+
+// Operations
+	void SetImages(int nNormal, int nPushed = -1, int nFocusOrHover = -1, int nDisabled = -1)
+	{
+		if(nNormal != -1)
+			m_nImage[_nImageNormal] = nNormal;
+		if(nPushed != -1)
+			m_nImage[_nImagePushed] = nPushed;
+		if(nFocusOrHover != -1)
+			m_nImage[_nImageFocusOrHover] = nFocusOrHover;
+		if(nDisabled != -1)
+			m_nImage[_nImageDisabled] = nDisabled;
+	}
+
+	BOOL SizeToImage()
+	{
+		ATLASSERT(::IsWindow(m_hWnd) && m_ImageList.m_hImageList != NULL);
+		int cx = 0;
+		int cy = 0;
+		if(!m_ImageList.GetIconSize(cx, cy))
+			return FALSE;
+		return ResizeClient(cx, cy);
+	}
+
+// Overrideables
+	void DoPaint(CDCHandle dc)
+	{
+		ATLASSERT(m_ImageList.m_hImageList != NULL);   // image list must be set
+		ATLASSERT(m_nImage[0] != -1);                  // main bitmap must be set
+
+		// set bitmap according to the current button state
+		int nImage = -1;
+		bool bHover = IsHoverMode();
+		if(!IsWindowEnabled())
+			nImage = m_nImage[_nImageDisabled];
+		else if(m_fPressed == 1)
+			nImage = m_nImage[_nImagePushed];
+		else if((!bHover && m_fFocus == 1) || (bHover && m_fMouseOver == 1))
+			nImage = m_nImage[_nImageFocusOrHover];
+		if(nImage == -1)   // not there, use default one
+			nImage = m_nImage[_nImageNormal];
+
+		// draw the button image
+		int xyPos = 0;
+		if((m_fPressed == 1) && ((m_dwExtendedStyle & (BMPBTN_AUTO3D_SINGLE | BMPBTN_AUTO3D_DOUBLE)) != 0) && (m_nImage[_nImagePushed] == -1))
+			xyPos = 1;
+		m_ImageList.Draw(dc, nImage, xyPos, xyPos, ILD_NORMAL);
+
+		// draw 3D border if required
+		if((m_dwExtendedStyle & (BMPBTN_AUTO3D_SINGLE | BMPBTN_AUTO3D_DOUBLE)) != 0)
+		{
+			RECT rect;
+			GetClientRect(&rect);
+
+			if(m_fPressed == 1)
+				dc.DrawEdge(&rect, ((m_dwExtendedStyle & BMPBTN_AUTO3D_SINGLE) != 0) ? BDR_SUNKENOUTER : EDGE_SUNKEN, BF_RECT);
+			else if(!bHover || m_fMouseOver == 1)
+				dc.DrawEdge(&rect, ((m_dwExtendedStyle & BMPBTN_AUTO3D_SINGLE) != 0) ? BDR_RAISEDINNER : EDGE_RAISED, BF_RECT);
+
+			if(!bHover && m_fFocus == 1)
+			{
+				::InflateRect(&rect, -2 * ::GetSystemMetrics(SM_CXEDGE), -2 * ::GetSystemMetrics(SM_CYEDGE));
+				dc.DrawFocusRect(&rect);
+			}
+		}
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CBitmapButtonImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+		MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
+		MESSAGE_HANDLER(WM_KILLFOCUS, OnFocus)
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
+		MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDblClk)
+		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
+		MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
+		MESSAGE_HANDLER(WM_ENABLE, OnEnable)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
+		MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
+		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
+		MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
+		MESSAGE_HANDLER(WM_TIMER, OnTimer)
+		MESSAGE_HANDLER(WM_UPDATEUISTATE, OnUpdateUiState)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		Init();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_tip.IsWindow())
+		{
+			m_tip.DestroyWindow();
+			m_tip.m_hWnd = NULL;
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		MSG msg = { m_hWnd, uMsg, wParam, lParam };
+		if(m_tip.IsWindow())
+			m_tip.RelayEvent(&msg);
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background needed
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		if(wParam != NULL)
+		{
+			pT->DoPaint((HDC)wParam);
+		}
+		else
+		{
+			CPaintDC dc(m_hWnd);
+			pT->DoPaint(dc.m_hDC);
+		}
+		return 0;
+	}
+
+	LRESULT OnFocus(UINT uMsg, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		m_fFocus = (uMsg == WM_SETFOCUS) ? 1 : 0;
+		Invalidate();
+		UpdateWindow();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnLButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = 0;
+		if(IsHoverMode())
+			SetCapture();
+		else
+			lRet = DefWindowProc(uMsg, wParam, lParam);
+		if(::GetCapture() == m_hWnd)
+		{
+			m_fPressed = 1;
+			Invalidate();
+			UpdateWindow();
+		}
+		if((m_dwExtendedStyle & BMPBTN_AUTOFIRE) != 0)
+		{
+			int nElapse = 250;
+			int nDelay = 0;
+			if(::SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &nDelay, 0))
+				nElapse += nDelay * 250;   // all milli-seconds
+			SetTimer(ID_TIMER_FIRST, nElapse);
+		}
+		return lRet;
+	}
+
+	LRESULT OnLButtonDblClk(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = 0;
+		if(!IsHoverMode())
+			lRet = DefWindowProc(uMsg, wParam, lParam);
+		if(::GetCapture() != m_hWnd)
+			SetCapture();
+		if(m_fPressed == 0)
+		{
+			m_fPressed = 1;
+			Invalidate();
+			UpdateWindow();
+		}
+		return lRet;
+	}
+
+	LRESULT OnLButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = 0;
+		bool bHover = IsHoverMode();
+		if(!bHover)
+			lRet = DefWindowProc(uMsg, wParam, lParam);
+		if(::GetCapture() == m_hWnd)
+		{
+			if(bHover && m_fPressed == 1)
+				::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
+			::ReleaseCapture();
+		}
+		return lRet;
+	}
+
+	LRESULT OnCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_fPressed == 1)
+		{
+			m_fPressed = 0;
+			Invalidate();
+			UpdateWindow();
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnEnable(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		Invalidate();
+		UpdateWindow();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(::GetCapture() == m_hWnd)
+		{
+			POINT ptCursor = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+			ClientToScreen(&ptCursor);
+			RECT rect = { 0 };
+			GetWindowRect(&rect);
+			unsigned int uPressed = ::PtInRect(&rect, ptCursor) ? 1 : 0;
+			if(m_fPressed != uPressed)
+			{
+				m_fPressed = uPressed;
+				Invalidate();
+				UpdateWindow();
+			}
+		}
+		else if(IsHoverMode() && m_fMouseOver == 0)
+		{
+			m_fMouseOver = 1;
+			Invalidate();
+			UpdateWindow();
+			StartTrackMouseLeave();
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnMouseLeave(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_fMouseOver == 1)
+		{
+			m_fMouseOver = 0;
+			Invalidate();
+			UpdateWindow();
+		}
+		return 0;
+	}
+
+	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(wParam == VK_SPACE && IsHoverMode())
+			return 0;   // ignore if in hover mode
+		if(wParam == VK_SPACE && m_fPressed == 0)
+		{
+			m_fPressed = 1;
+			Invalidate();
+			UpdateWindow();
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnKeyUp(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(wParam == VK_SPACE && IsHoverMode())
+			return 0;   // ignore if in hover mode
+		if(wParam == VK_SPACE && m_fPressed == 1)
+		{
+			m_fPressed = 0;
+			Invalidate();
+			UpdateWindow();
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnTimer(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		ATLASSERT((m_dwExtendedStyle & BMPBTN_AUTOFIRE) != 0);
+		switch(wParam)   // timer ID
+		{
+		case ID_TIMER_FIRST:
+			KillTimer(ID_TIMER_FIRST);
+			if(m_fPressed == 1)
+			{
+				::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
+				int nElapse = 250;
+				int nRepeat = 40;
+				if(::SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &nRepeat, 0))
+					nElapse = 10000 / (10 * nRepeat + 25);   // milli-seconds, approximated
+				SetTimer(ID_TIMER_REPEAT, nElapse);
+			}
+			break;
+		case ID_TIMER_REPEAT:
+			if(m_fPressed == 1)
+				::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
+			else if(::GetCapture() != m_hWnd)
+				KillTimer(ID_TIMER_REPEAT);
+			break;
+		default:	// not our timer
+			break;
+		}
+		return 0;
+	}
+
+	LRESULT OnUpdateUiState(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		// If the control is subclassed or superclassed, this message can cause
+		// repainting without WM_PAINT. We don't use this state, so just do nothing.
+		return 0;
+	}
+
+// Implementation
+	void Init()
+	{
+		// We need this style to prevent Windows from painting the button
+		ModifyStyle(0, BS_OWNERDRAW);
+
+		// create a tool tip
+		m_tip.Create(m_hWnd);
+		ATLASSERT(m_tip.IsWindow());
+		if(m_tip.IsWindow() && m_lpstrToolTipText != NULL)
+		{
+			m_tip.Activate(TRUE);
+			m_tip.AddTool(m_hWnd, m_lpstrToolTipText);
+		}
+
+		if(m_ImageList.m_hImageList != NULL && (m_dwExtendedStyle & BMPBTN_AUTOSIZE) != 0)
+			SizeToImage();
+	}
+
+	BOOL StartTrackMouseLeave()
+	{
+		TRACKMOUSEEVENT tme = { 0 };
+		tme.cbSize = sizeof(tme);
+		tme.dwFlags = TME_LEAVE;
+		tme.hwndTrack = m_hWnd;
+		return _TrackMouseEvent(&tme);
+	}
+
+	bool IsHoverMode() const
+	{
+		return ((m_dwExtendedStyle & BMPBTN_HOVER) != 0);
+	}
+};
+
+class CBitmapButton : public CBitmapButtonImpl<CBitmapButton>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_BitmapButton"), GetWndClassName())
+
+	CBitmapButton(DWORD dwExtendedStyle = BMPBTN_AUTOSIZE, HIMAGELIST hImageList = NULL) : 
+		CBitmapButtonImpl<CBitmapButton>(dwExtendedStyle, hImageList)
+	{ }
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCheckListCtrlView - list view control with check boxes
+
+template <DWORD t_dwStyle, DWORD t_dwExStyle, DWORD t_dwExListViewStyle>
+class CCheckListViewCtrlImplTraits
+{
+public:
+	static DWORD GetWndStyle(DWORD dwStyle)
+	{
+		return (dwStyle == 0) ? t_dwStyle : dwStyle;
+	}
+
+	static DWORD GetWndExStyle(DWORD dwExStyle)
+	{
+		return (dwExStyle == 0) ? t_dwExStyle : dwExStyle;
+	}
+
+	static DWORD GetExtendedLVStyle()
+	{
+		return t_dwExListViewStyle;
+	}
+};
+
+typedef CCheckListViewCtrlImplTraits<WS_CHILD | WS_VISIBLE | LVS_REPORT | LVS_SHOWSELALWAYS, WS_EX_CLIENTEDGE, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT>   CCheckListViewCtrlTraits;
+
+template <class T, class TBase = CListViewCtrl, class TWinTraits = CCheckListViewCtrlTraits>
+class ATL_NO_VTABLE CCheckListViewCtrlImpl : public ATL::CWindowImpl<T, TBase, TWinTraits>
+{
+public:
+	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())
+
+// Attributes
+	static DWORD GetExtendedLVStyle()
+	{
+		return TWinTraits::GetExtendedLVStyle();
+	}
+
+// Operations
+	BOOL SubclassWindow(HWND hWnd)
+	{
+#if (_MSC_VER >= 1300)
+		BOOL bRet = ATL::CWindowImplBaseT< TBase, TWinTraits>::SubclassWindow(hWnd);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImplBaseT< TBase, TWinTraits>   _baseClass;
+		BOOL bRet = _baseClass::SubclassWindow(hWnd);
+#endif // !(_MSC_VER >= 1300)
+		if(bRet)
+		{
+			T* pT = static_cast<T*>(this);
+			pT;
+			ATLASSERT((pT->GetExtendedLVStyle() & LVS_EX_CHECKBOXES) != 0);
+			SetExtendedListViewStyle(pT->GetExtendedLVStyle());
+		}
+		return bRet;
+	}
+
+	void CheckSelectedItems(int nCurrItem)
+	{
+		// first check if this item is selected
+		LVITEM lvi = { 0 };
+		lvi.iItem = nCurrItem;
+		lvi.iSubItem = 0;
+		lvi.mask = LVIF_STATE;
+		lvi.stateMask = LVIS_SELECTED;
+		GetItem(&lvi);
+		// if item is not selected, don't do anything
+		if(!(lvi.state & LVIS_SELECTED))
+			return;
+		// new check state will be reverse of the current state,
+		BOOL bCheck = !GetCheckState(nCurrItem);
+		int nItem = -1;
+		int nOldItem = -1;
+		while((nItem = GetNextItem(nOldItem, LVNI_SELECTED)) != -1)
+		{
+			if(nItem != nCurrItem)
+				SetCheckState(nItem, bCheck);
+			nOldItem = nItem;
+		}
+	}
+
+// Implementation
+	BEGIN_MSG_MAP(CCheckListViewCtrlImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
+		MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDown)
+		MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		// first let list view control initialize everything
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+		T* pT = static_cast<T*>(this);
+		pT;
+		ATLASSERT((pT->GetExtendedLVStyle() & LVS_EX_CHECKBOXES) != 0);
+		SetExtendedListViewStyle(pT->GetExtendedLVStyle());
+		return lRet;
+	}
+
+	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		POINT ptMsg = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		LVHITTESTINFO lvh = { 0 };
+		lvh.pt = ptMsg;
+		if(HitTest(&lvh) != -1 && lvh.flags == LVHT_ONITEMSTATEICON && ::GetKeyState(VK_CONTROL) >= 0)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->CheckSelectedItems(lvh.iItem);
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(wParam == VK_SPACE)
+		{
+			int nCurrItem = GetNextItem(-1, LVNI_FOCUSED);
+			if(nCurrItem != -1  && ::GetKeyState(VK_CONTROL) >= 0)
+			{
+				T* pT = static_cast<T*>(this);
+				pT->CheckSelectedItems(nCurrItem);
+			}
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+};
+
+class CCheckListViewCtrl : public CCheckListViewCtrlImpl<CCheckListViewCtrl>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_CheckListView"), GetWndClassName())
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CHyperLink - hyper link control implementation
+
+#if (WINVER < 0x0500) && !defined(_WIN32_WCE)
+__declspec(selectany) struct
+{
+	enum { cxWidth = 32, cyHeight = 32 };
+	int xHotSpot;
+	int yHotSpot;
+	unsigned char arrANDPlane[cxWidth * cyHeight / 8];
+	unsigned char arrXORPlane[cxWidth * cyHeight / 8];
+} _AtlHyperLink_CursorData = 
+{
+	5, 0, 
+	{
+		0xF9, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xFF, 0xFF, 
+		0xF0, 0xFF, 0xFF, 0xFF, 0xF0, 0x3F, 0xFF, 0xFF, 0xF0, 0x07, 0xFF, 0xFF, 0xF0, 0x01, 0xFF, 0xFF, 
+		0xF0, 0x00, 0xFF, 0xFF, 0x10, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 0x00, 0x00, 0x7F, 0xFF, 
+		0x80, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xC0, 0x00, 0x7F, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 
+		0xE0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 
+		0xF8, 0x01, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
+		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
+	},
+	{
+		0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 
+		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0xC0, 0x00, 0x00, 0x06, 0xD8, 0x00, 0x00, 
+		0x06, 0xDA, 0x00, 0x00, 0x06, 0xDB, 0x00, 0x00, 0x67, 0xFB, 0x00, 0x00, 0x77, 0xFF, 0x00, 0x00, 
+		0x37, 0xFF, 0x00, 0x00, 0x17, 0xFF, 0x00, 0x00, 0x1F, 0xFF, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 
+		0x0F, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x07, 0xFE, 0x00, 0x00, 0x03, 0xFC, 0x00, 0x00, 
+		0x03, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	}
+};
+#endif // (WINVER < 0x0500) && !defined(_WIN32_WCE)
+
+#define HLINK_UNDERLINED           0x00000000
+#define HLINK_NOTUNDERLINED        0x00000001
+#define HLINK_UNDERLINEHOVER       0x00000002
+#define HLINK_COMMANDBUTTON        0x00000004
+#define HLINK_NOTIFYBUTTON         0x0000000C
+#define HLINK_USETAGS              0x00000010
+#define HLINK_USETAGSBOLD          0x00000030
+#define HLINK_NOTOOLTIP            0x00000040
+#define HLINK_AUTOCREATELINKFONT   0x00000080
+#define HLINK_SINGLELINE           0x00000100
+
+// Notes:
+// - HLINK_USETAGS and HLINK_USETAGSBOLD are always left-aligned
+// - When HLINK_USETAGSBOLD is used, the underlined styles will be ignored
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CHyperLinkImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >
+{
+public:
+	LPTSTR m_lpstrLabel;
+	LPTSTR m_lpstrHyperLink;
+
+	HCURSOR m_hCursor;
+	HFONT m_hFontLink;
+	HFONT m_hFontNormal;
+
+	RECT m_rcLink;
+#ifndef _WIN32_WCE
+	CToolTipCtrl m_tip;
+#endif // !_WIN32_WCE
+
+	COLORREF m_clrLink;
+	COLORREF m_clrVisited;
+
+	DWORD m_dwExtendedStyle;   // Hyper Link specific extended styles
+
+	bool m_bPaintLabel:1;
+	bool m_bVisited:1;
+	bool m_bHover:1;
+	bool m_bInternalLinkFont:1;
+	bool m_bInternalNormalFont:1;
+
+
+// Constructor/Destructor
+	CHyperLinkImpl(DWORD dwExtendedStyle = HLINK_UNDERLINED) : 
+			m_lpstrLabel(NULL), m_lpstrHyperLink(NULL),
+			m_hCursor(NULL), m_hFontLink(NULL), m_hFontNormal(NULL),
+			m_clrLink(RGB(0, 0, 255)), m_clrVisited(RGB(128, 0, 128)),
+			m_dwExtendedStyle(dwExtendedStyle),
+			m_bPaintLabel(true), m_bVisited(false),
+			m_bHover(false), m_bInternalLinkFont(false), m_bInternalNormalFont(false)
+	{
+		::SetRectEmpty(&m_rcLink);
+	}
+
+	~CHyperLinkImpl()
+	{
+		delete [] m_lpstrLabel;
+		delete [] m_lpstrHyperLink;
+#if (WINVER < 0x0500) && !defined(_WIN32_WCE)
+		// It was created, not loaded, so we have to destroy it
+		if(m_hCursor != NULL)
+			::DestroyCursor(m_hCursor);
+#endif // (WINVER < 0x0500) && !defined(_WIN32_WCE)
+	}
+
+// Attributes
+	DWORD GetHyperLinkExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+	DWORD SetHyperLinkExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		return dwPrevStyle;
+	}
+
+	bool GetLabel(LPTSTR lpstrBuffer, int nLength) const
+	{
+		if(m_lpstrLabel == NULL)
+			return false;
+		ATLASSERT(lpstrBuffer != NULL);
+		if(nLength <= lstrlen(m_lpstrLabel))
+			return false;
+
+		SecureHelper::strcpy_x(lpstrBuffer, nLength, m_lpstrLabel);
+
+		return true;
+	}
+
+	bool SetLabel(LPCTSTR lpstrLabel)
+	{
+		delete [] m_lpstrLabel;
+		m_lpstrLabel = NULL;
+		int cchLen = lstrlen(lpstrLabel) + 1;
+		ATLTRY(m_lpstrLabel = new TCHAR[cchLen]);
+		if(m_lpstrLabel == NULL)
+			return false;
+
+		SecureHelper::strcpy_x(m_lpstrLabel, cchLen, lpstrLabel);
+		T* pT = static_cast<T*>(this);
+		pT->CalcLabelRect();
+
+		if(m_hWnd != NULL)
+			SetWindowText(lpstrLabel);   // Set this for accessibility
+
+		return true;
+	}
+
+	bool GetHyperLink(LPTSTR lpstrBuffer, int nLength) const
+	{
+		if(m_lpstrHyperLink == NULL)
+			return false;
+		ATLASSERT(lpstrBuffer != NULL);
+		if(nLength <= lstrlen(m_lpstrHyperLink))
+			return false;
+
+		SecureHelper::strcpy_x(lpstrBuffer, nLength, m_lpstrHyperLink);
+
+		return true;
+	}
+
+	bool SetHyperLink(LPCTSTR lpstrLink)
+	{
+		delete [] m_lpstrHyperLink;
+		m_lpstrHyperLink = NULL;
+		int cchLen = lstrlen(lpstrLink) + 1;
+		ATLTRY(m_lpstrHyperLink = new TCHAR[cchLen]);
+		if(m_lpstrHyperLink == NULL)
+			return false;
+
+		SecureHelper::strcpy_x(m_lpstrHyperLink, cchLen, lpstrLink);
+		if(m_lpstrLabel == NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->CalcLabelRect();
+		}
+#ifndef _WIN32_WCE
+		if(m_tip.IsWindow())
+		{
+			m_tip.Activate(TRUE);
+			m_tip.AddTool(m_hWnd, m_lpstrHyperLink, &m_rcLink, 1);
+		}
+#endif // !_WIN32_WCE
+		return true;
+	}
+
+	HFONT GetLinkFont() const
+	{
+		return m_hFontLink;
+	}
+
+	void SetLinkFont(HFONT hFont)
+	{
+		if(m_bInternalLinkFont)
+		{
+			::DeleteObject(m_hFontLink);
+			m_bInternalLinkFont = false;
+		}
+
+		m_hFontLink = hFont;
+
+		T* pT = static_cast<T*>(this);
+		pT->CalcLabelRect();
+	}
+
+	int GetIdealHeight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
+			return -1;
+		if(!m_bPaintLabel)
+			return -1;
+
+		UINT uFormat = IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+
+		CClientDC dc(m_hWnd);
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+		HFONT hFontOld = dc.SelectFont(m_hFontNormal);
+		RECT rcText = rect;
+		dc.DrawText(_T("NS"), -1, &rcText, DT_LEFT | uFormat | DT_CALCRECT);
+		dc.SelectFont(m_hFontLink);
+		RECT rcLink = rect;
+		dc.DrawText(_T("NS"), -1, &rcLink, DT_LEFT | uFormat | DT_CALCRECT);
+		dc.SelectFont(hFontOld);
+		return max(rcText.bottom - rcText.top, rcLink.bottom - rcLink.top);
+	}
+
+	bool GetIdealSize(SIZE& size) const
+	{
+		int cx = 0, cy = 0;
+		bool bRet = GetIdealSize(cx, cy);
+		if(bRet)
+		{
+			size.cx = cx;
+			size.cy = cy;
+		}
+		return bRet;
+	}
+
+	bool GetIdealSize(int& cx, int& cy) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
+			return false;
+		if(!m_bPaintLabel)
+			return false;
+
+		CClientDC dc(m_hWnd);
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+		RECT rcAll = rcClient;
+
+		if(IsUsingTags())
+		{
+			// find tags and label parts
+			LPTSTR lpstrLeft = NULL;
+			int cchLeft = 0;
+			LPTSTR lpstrLink = NULL;
+			int cchLink = 0;
+			LPTSTR lpstrRight = NULL;
+			int cchRight = 0;
+
+			const T* pT = static_cast<const T*>(this);
+			pT->CalcLabelParts(lpstrLeft, cchLeft, lpstrLink, cchLink, lpstrRight, cchRight);
+
+			// get label part rects
+			UINT uFormat = IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+
+			HFONT hFontOld = dc.SelectFont(m_hFontNormal);
+			RECT rcLeft = rcClient;
+			dc.DrawText(lpstrLeft, cchLeft, &rcLeft, DT_LEFT | uFormat | DT_CALCRECT);
+
+			dc.SelectFont(m_hFontLink);
+			RECT rcLink = { rcLeft.right, rcLeft.top, rcClient.right, rcClient.bottom };
+			dc.DrawText(lpstrLink, cchLink, &rcLink, DT_LEFT | uFormat | DT_CALCRECT);
+
+			dc.SelectFont(m_hFontNormal);
+			RECT rcRight = { rcLink.right, rcLink.top, rcClient.right, rcClient.bottom };
+			dc.DrawText(lpstrRight, cchRight, &rcRight, DT_LEFT | uFormat | DT_CALCRECT);
+
+			dc.SelectFont(hFontOld);
+
+			int cyMax = max(rcLeft.bottom, max(rcLink.bottom, rcRight.bottom));
+			::SetRect(&rcAll, rcLeft.left, rcLeft.top, rcRight.right, cyMax);
+		}
+		else
+		{
+			HFONT hOldFont = NULL;
+			if(m_hFontLink != NULL)
+				hOldFont = dc.SelectFont(m_hFontLink);
+			LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
+			DWORD dwStyle = GetStyle();
+			UINT uFormat = DT_LEFT;
+			if (dwStyle & SS_CENTER)
+				uFormat = DT_CENTER;
+			else if (dwStyle & SS_RIGHT)
+				uFormat = DT_RIGHT;
+			uFormat |= IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+			dc.DrawText(lpstrText, -1, &rcAll, uFormat | DT_CALCRECT);
+			if(m_hFontLink != NULL)
+				dc.SelectFont(hOldFont);
+			if (dwStyle & SS_CENTER)
+			{
+				int dx = (rcClient.right - rcAll.right) / 2;
+				::OffsetRect(&rcAll, dx, 0);
+			}
+			else if (dwStyle & SS_RIGHT)
+			{
+				int dx = rcClient.right - rcAll.right;
+				::OffsetRect(&rcAll, dx, 0);
+			}
+		}
+
+		cx = rcAll.right - rcAll.left;
+		cy = rcAll.bottom - rcAll.top;
+
+		return true;
+	}
+
+	// for command buttons only
+	bool GetToolTipText(LPTSTR lpstrBuffer, int nLength) const
+	{
+		ATLASSERT(IsCommandButton());
+		return GetHyperLink(lpstrBuffer, nLength);
+	}
+
+	bool SetToolTipText(LPCTSTR lpstrToolTipText)
+	{
+		ATLASSERT(IsCommandButton());
+		return SetHyperLink(lpstrToolTipText);
+	}
+
+// Operations
+	BOOL SubclassWindow(HWND hWnd)
+	{
+		ATLASSERT(m_hWnd == NULL);
+		ATLASSERT(::IsWindow(hWnd));
+		if(m_hFontNormal == NULL)
+			m_hFontNormal = (HFONT)::SendMessage(hWnd, WM_GETFONT, 0, 0L);
+#if (_MSC_VER >= 1300)
+		BOOL bRet = ATL::CWindowImpl< T, TBase, TWinTraits>::SubclassWindow(hWnd);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImpl< T, TBase, TWinTraits>   _baseClass;
+		BOOL bRet = _baseClass::SubclassWindow(hWnd);
+#endif // !(_MSC_VER >= 1300)
+		if(bRet)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->Init();
+		}
+		return bRet;
+	}
+
+	bool Navigate()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		bool bRet = true;
+		if(IsNotifyButton())
+		{
+			NMHDR nmhdr = { m_hWnd, GetDlgCtrlID(), NM_CLICK };
+			::SendMessage(GetParent(), WM_NOTIFY, GetDlgCtrlID(), (LPARAM)&nmhdr);
+		}
+		else if(IsCommandButton())
+		{
+			::SendMessage(GetParent(), WM_COMMAND, MAKEWPARAM(GetDlgCtrlID(), BN_CLICKED), (LPARAM)m_hWnd);
+		}
+		else
+		{
+			ATLASSERT(m_lpstrHyperLink != NULL);
+#ifndef _WIN32_WCE
+			DWORD_PTR dwRet = (DWORD_PTR)::ShellExecute(0, _T("open"), m_lpstrHyperLink, 0, 0, SW_SHOWNORMAL);
+			bRet = (dwRet > 32);
+#else // CE specific
+			SHELLEXECUTEINFO shExeInfo = { sizeof(SHELLEXECUTEINFO), 0, 0, L"open", m_lpstrHyperLink, 0, 0, SW_SHOWNORMAL, 0, 0, 0, 0, 0, 0, 0 };
+			::ShellExecuteEx(&shExeInfo);
+			DWORD_PTR dwRet = (DWORD_PTR)shExeInfo.hInstApp;
+			bRet = (dwRet == 0) || (dwRet > 32);
+#endif // _WIN32_WCE
+			ATLASSERT(bRet);
+			if(bRet)
+			{
+				m_bVisited = true;
+				Invalidate();
+			}
+		}
+		return bRet;
+	}
+
+	void CreateLinkFontFromNormal()
+	{
+		if(m_bInternalLinkFont)
+		{
+			::DeleteObject(m_hFontLink);
+			m_bInternalLinkFont = false;
+		}
+
+		CFontHandle font = (m_hFontNormal != NULL) ? m_hFontNormal : (HFONT)::GetStockObject(SYSTEM_FONT);
+		LOGFONT lf = { 0 };
+		font.GetLogFont(&lf);
+
+		if(IsUsingTagsBold())
+			lf.lfWeight = FW_BOLD;
+		else if(!IsNotUnderlined())
+			lf.lfUnderline = TRUE;
+
+		m_hFontLink = ::CreateFontIndirect(&lf);
+		m_bInternalLinkFont = true;
+		ATLASSERT(m_hFontLink != NULL);
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CHyperLinkImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouseMessage)
+#endif // !_WIN32_WCE
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+#endif // !_WIN32_WCE
+		MESSAGE_HANDLER(WM_SETFOCUS, OnFocus)
+		MESSAGE_HANDLER(WM_KILLFOCUS, OnFocus)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
+#endif // !_WIN32_WCE
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
+		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
+		MESSAGE_HANDLER(WM_CHAR, OnChar)
+		MESSAGE_HANDLER(WM_GETDLGCODE, OnGetDlgCode)
+		MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
+		MESSAGE_HANDLER(WM_ENABLE, OnEnable)
+		MESSAGE_HANDLER(WM_GETFONT, OnGetFont)
+		MESSAGE_HANDLER(WM_SETFONT, OnSetFont)
+		MESSAGE_HANDLER(WM_UPDATEUISTATE, OnUpdateUiState)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Init();
+		return 0;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_tip.IsWindow())
+		{
+			m_tip.DestroyWindow();
+			m_tip.m_hWnd = NULL;
+		}
+
+		if(m_bInternalLinkFont)
+		{
+			::DeleteObject(m_hFontLink);
+			m_hFontLink = NULL;
+			m_bInternalLinkFont = false;
+		}
+
+		if(m_bInternalNormalFont)
+		{
+			::DeleteObject(m_hFontNormal);
+			m_hFontNormal = NULL;
+			m_bInternalNormalFont = false;
+		}
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		MSG msg = { m_hWnd, uMsg, wParam, lParam };
+		if(m_tip.IsWindow() && IsUsingToolTip())
+			m_tip.RelayEvent(&msg);
+		bHandled = FALSE;
+		return 1;
+	}
+#endif // !_WIN32_WCE
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background painting needed (we do it all during WM_PAINT)
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(!m_bPaintLabel)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		T* pT = static_cast<T*>(this);
+		if(wParam != NULL)
+		{
+			pT->DoEraseBackground((HDC)wParam);
+			pT->DoPaint((HDC)wParam);
+		}
+		else
+		{
+			CPaintDC dc(m_hWnd);
+			pT->DoEraseBackground(dc.m_hDC);
+			pT->DoPaint(dc.m_hDC);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_bPaintLabel)
+			Invalidate();
+		else
+			bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		if((m_lpstrHyperLink != NULL  || IsCommandButton()) && ::PtInRect(&m_rcLink, pt))
+		{
+			::SetCursor(m_hCursor);
+			if(IsUnderlineHover())
+			{
+				if(!m_bHover)
+				{
+					m_bHover = true;
+					InvalidateRect(&m_rcLink);
+					UpdateWindow();
+#ifndef _WIN32_WCE
+					StartTrackMouseLeave();
+#endif // !_WIN32_WCE
+				}
+			}
+		}
+		else
+		{
+			if(IsUnderlineHover())
+			{
+				if(m_bHover)
+				{
+					m_bHover = false;
+					InvalidateRect(&m_rcLink);
+					UpdateWindow();
+				}
+			}
+			bHandled = FALSE;
+		}
+		return 0;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnMouseLeave(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(IsUnderlineHover() && m_bHover)
+		{
+			m_bHover = false;
+			InvalidateRect(&m_rcLink);
+			UpdateWindow();
+		}
+		return 0;
+	}
+#endif // !_WIN32_WCE
+
+	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+		if(::PtInRect(&m_rcLink, pt))
+		{
+			SetFocus();
+			SetCapture();
+		}
+		return 0;
+	}
+
+	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if(GetCapture() == m_hWnd)
+		{
+			ReleaseCapture();
+			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+			if(::PtInRect(&m_rcLink, pt))
+			{
+				T* pT = static_cast<T*>(this);
+				pT->Navigate();
+			}
+		}
+		return 0;
+	}
+
+	LRESULT OnChar(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(wParam == VK_RETURN || wParam == VK_SPACE)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->Navigate();
+		}
+		return 0;
+	}
+
+	LRESULT OnGetDlgCode(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return DLGC_WANTCHARS;
+	}
+
+	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		POINT pt = { 0, 0 };
+		GetCursorPos(&pt);
+		ScreenToClient(&pt);
+		if((m_lpstrHyperLink != NULL  || IsCommandButton()) && ::PtInRect(&m_rcLink, pt))
+		{
+			return TRUE;
+		}
+		bHandled = FALSE;
+		return FALSE;
+	}
+
+	LRESULT OnEnable(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		Invalidate();
+		UpdateWindow();
+		return 0;
+	}
+
+	LRESULT OnGetFont(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return (LRESULT)m_hFontNormal;
+	}
+
+	LRESULT OnSetFont(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if(m_bInternalNormalFont)
+		{
+			::DeleteObject(m_hFontNormal);
+			m_bInternalNormalFont = false;
+		}
+
+		bool bCreateLinkFont = m_bInternalLinkFont;
+
+		m_hFontNormal = (HFONT)wParam;
+
+		if(bCreateLinkFont || IsAutoCreateLinkFont())
+			CreateLinkFontFromNormal();
+
+		T* pT = static_cast<T*>(this);
+		pT->CalcLabelRect();
+
+		if((BOOL)lParam)
+		{
+			Invalidate();
+			UpdateWindow();
+		}
+
+		return 0;
+	}
+
+	LRESULT OnUpdateUiState(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		// If the control is subclassed or superclassed, this message can cause
+		// repainting without WM_PAINT. We don't use this state, so just do nothing.
+		return 0;
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->CalcLabelRect();
+		pT->Invalidate();
+		return 0;
+	}
+
+// Implementation
+	void Init()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		// Check if we should paint a label
+		const int cchBuff = 8;
+		TCHAR szBuffer[cchBuff] = { 0 };
+		if(::GetClassName(m_hWnd, szBuffer, cchBuff))
+		{
+			if(lstrcmpi(szBuffer, _T("static")) == 0)
+			{
+				ModifyStyle(0, SS_NOTIFY);   // we need this
+				DWORD dwStyle = GetStyle() & 0x000000FF;
+#ifndef _WIN32_WCE
+				if(dwStyle == SS_ICON || dwStyle == SS_BLACKRECT || dwStyle == SS_GRAYRECT || 
+						dwStyle == SS_WHITERECT || dwStyle == SS_BLACKFRAME || dwStyle == SS_GRAYFRAME || 
+						dwStyle == SS_WHITEFRAME || dwStyle == SS_OWNERDRAW || 
+						dwStyle == SS_BITMAP || dwStyle == SS_ENHMETAFILE)
+#else // CE specific
+				if(dwStyle == SS_ICON || dwStyle == SS_BITMAP)
+#endif // _WIN32_WCE
+					m_bPaintLabel = false;
+			}
+		}
+
+		// create or load a cursor
+#if (WINVER >= 0x0500) || defined(_WIN32_WCE)
+		m_hCursor = ::LoadCursor(NULL, IDC_HAND);
+#else
+		m_hCursor = ::CreateCursor(ModuleHelper::GetModuleInstance(), _AtlHyperLink_CursorData.xHotSpot, _AtlHyperLink_CursorData.yHotSpot, _AtlHyperLink_CursorData.cxWidth, _AtlHyperLink_CursorData.cyHeight, _AtlHyperLink_CursorData.arrANDPlane, _AtlHyperLink_CursorData.arrXORPlane);
+#endif
+		ATLASSERT(m_hCursor != NULL);
+
+		// set fonts
+		if(m_bPaintLabel)
+		{
+			if(m_hFontNormal == NULL)
+			{
+				m_hFontNormal = AtlCreateControlFont();
+				m_bInternalNormalFont = true;
+			}
+
+			if(m_hFontLink == NULL)
+				CreateLinkFontFromNormal();
+		}
+
+#ifndef _WIN32_WCE
+		// create a tool tip
+		m_tip.Create(m_hWnd);
+		ATLASSERT(m_tip.IsWindow());
+#endif // !_WIN32_WCE
+
+		// set label (defaults to window text)
+		if(m_lpstrLabel == NULL)
+		{
+			int nLen = GetWindowTextLength();
+			if(nLen > 0)
+			{
+				ATLTRY(m_lpstrLabel = new TCHAR[nLen + 1]);
+				if(m_lpstrLabel != NULL)
+					ATLVERIFY(GetWindowText(m_lpstrLabel, nLen + 1) > 0);
+			}
+		}
+
+		T* pT = static_cast<T*>(this);
+		pT->CalcLabelRect();
+
+		// set hyperlink (defaults to label), or just activate tool tip if already set
+		if(m_lpstrHyperLink == NULL && !IsCommandButton())
+		{
+			if(m_lpstrLabel != NULL)
+				SetHyperLink(m_lpstrLabel);
+		}
+#ifndef _WIN32_WCE
+		else
+		{
+			m_tip.Activate(TRUE);
+			m_tip.AddTool(m_hWnd, m_lpstrHyperLink, &m_rcLink, 1);
+		}
+#endif // !_WIN32_WCE
+
+		// set link colors
+		if(m_bPaintLabel)
+		{
+			CRegKeyEx rk;
+			LONG lRet = rk.Open(HKEY_CURRENT_USER, _T("Software\\Microsoft\\Internet Explorer\\Settings"));
+			if(lRet == ERROR_SUCCESS)
+			{
+				const int cchValue = 12;
+				TCHAR szValue[cchValue] = { 0 };
+				ULONG ulCount = cchValue;
+				lRet = rk.QueryStringValue(_T("Anchor Color"), szValue, &ulCount);
+				if(lRet == ERROR_SUCCESS)
+				{
+					COLORREF clr = pT->_ParseColorString(szValue);
+					ATLASSERT(clr != CLR_INVALID);
+					if(clr != CLR_INVALID)
+						m_clrLink = clr;
+				}
+
+				ulCount = cchValue;
+				lRet = rk.QueryStringValue(_T("Anchor Color Visited"), szValue, &ulCount);
+				if(lRet == ERROR_SUCCESS)
+				{
+					COLORREF clr = pT->_ParseColorString(szValue);
+					ATLASSERT(clr != CLR_INVALID);
+					if(clr != CLR_INVALID)
+						m_clrVisited = clr;
+				}
+			}
+		}
+	}
+
+	static COLORREF _ParseColorString(LPTSTR lpstr)
+	{
+		int c[3] = { -1, -1, -1 };
+		LPTSTR p = NULL;
+		for(int i = 0; i < 2; i++)
+		{
+			for(p = lpstr; *p != _T('\0'); p = ::CharNext(p))
+			{
+				if(*p == _T(','))
+				{
+					*p = _T('\0');
+					c[i] = MinCrtHelper::_atoi(lpstr);
+					lpstr = &p[1];
+					break;
+				}
+			}
+			if(c[i] == -1)
+				return CLR_INVALID;
+		}
+		if(*lpstr == _T('\0'))
+			return CLR_INVALID;
+		c[2] = MinCrtHelper::_atoi(lpstr);
+
+		return RGB(c[0], c[1], c[2]);
+	}
+
+	bool CalcLabelRect()
+	{
+		if(!::IsWindow(m_hWnd))
+			return false;
+		if(m_lpstrLabel == NULL && m_lpstrHyperLink == NULL)
+			return false;
+
+		CClientDC dc(m_hWnd);
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+		m_rcLink = rcClient;
+		if(!m_bPaintLabel)
+			return true;
+
+		if(IsUsingTags())
+		{
+			// find tags and label parts
+			LPTSTR lpstrLeft = NULL;
+			int cchLeft = 0;
+			LPTSTR lpstrLink = NULL;
+			int cchLink = 0;
+			LPTSTR lpstrRight = NULL;
+			int cchRight = 0;
+
+			T* pT = static_cast<T*>(this);
+			pT->CalcLabelParts(lpstrLeft, cchLeft, lpstrLink, cchLink, lpstrRight, cchRight);
+			ATLASSERT(lpstrLink != NULL);
+			ATLASSERT(cchLink > 0);
+
+			// get label part rects
+			HFONT hFontOld = dc.SelectFont(m_hFontNormal);
+
+			UINT uFormat = IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+
+			RECT rcLeft = rcClient;
+			if(lpstrLeft != NULL)
+				dc.DrawText(lpstrLeft, cchLeft, &rcLeft, DT_LEFT | uFormat | DT_CALCRECT);
+
+			dc.SelectFont(m_hFontLink);
+			RECT rcLink = rcClient;
+			if(lpstrLeft != NULL)
+				rcLink.left = rcLeft.right;
+			dc.DrawText(lpstrLink, cchLink, &rcLink, DT_LEFT | uFormat | DT_CALCRECT);
+
+			dc.SelectFont(hFontOld);
+
+			m_rcLink = rcLink;
+		}
+		else
+		{
+			HFONT hOldFont = NULL;
+			if(m_hFontLink != NULL)
+				hOldFont = dc.SelectFont(m_hFontLink);
+			LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
+			DWORD dwStyle = GetStyle();
+			UINT uFormat = DT_LEFT;
+			if (dwStyle & SS_CENTER)
+				uFormat = DT_CENTER;
+			else if (dwStyle & SS_RIGHT)
+				uFormat = DT_RIGHT;
+			uFormat |= IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+			dc.DrawText(lpstrText, -1, &m_rcLink, uFormat | DT_CALCRECT);
+			if(m_hFontLink != NULL)
+				dc.SelectFont(hOldFont);
+			if (dwStyle & SS_CENTER)
+			{
+				int dx = (rcClient.right - m_rcLink.right) / 2;
+				::OffsetRect(&m_rcLink, dx, 0);
+			}
+			else if (dwStyle & SS_RIGHT)
+			{
+				int dx = rcClient.right - m_rcLink.right;
+				::OffsetRect(&m_rcLink, dx, 0);
+			}
+		}
+
+		return true;
+	}
+
+	void CalcLabelParts(LPTSTR& lpstrLeft, int& cchLeft, LPTSTR& lpstrLink, int& cchLink, LPTSTR& lpstrRight, int& cchRight) const
+	{
+		lpstrLeft = NULL;
+		cchLeft = 0;
+		lpstrLink = NULL;
+		cchLink = 0;
+		lpstrRight = NULL;
+		cchRight = 0;
+
+		LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
+		int cchText = lstrlen(lpstrText);
+		bool bOutsideLink = true;
+		for(int i = 0; i < cchText; i++)
+		{
+			if(lpstrText[i] != _T('<'))
+				continue;
+
+			if(bOutsideLink)
+			{
+				if(::CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, &lpstrText[i], 3, _T("<A>"), 3) == CSTR_EQUAL)
+				{
+					if(i > 0)
+					{
+						lpstrLeft = lpstrText;
+						cchLeft = i;
+					}
+					lpstrLink = &lpstrText[i + 3];
+					bOutsideLink = false;
+				}
+			}
+			else
+			{
+				if(::CompareString(LOCALE_USER_DEFAULT, NORM_IGNORECASE, &lpstrText[i], 4, _T("</A>"), 4) == CSTR_EQUAL)
+				{
+					cchLink = i - 3 - cchLeft;
+					if(lpstrText[i + 4] != 0)
+					{
+						lpstrRight = &lpstrText[i + 4];
+						cchRight = cchText - (i + 4);
+						break;
+					}
+				}
+			}
+		}
+
+	}
+
+	void DoEraseBackground(CDCHandle dc)
+	{
+		HBRUSH hBrush = (HBRUSH)::SendMessage(GetParent(), WM_CTLCOLORSTATIC, (WPARAM)dc.m_hDC, (LPARAM)m_hWnd);
+		if(hBrush != NULL)
+		{
+			RECT rect = { 0 };
+			GetClientRect(&rect);
+			dc.FillRect(&rect, hBrush);
+		}
+	}
+
+	void DoPaint(CDCHandle dc)
+	{
+		if(IsUsingTags())
+		{
+			// find tags and label parts
+			LPTSTR lpstrLeft = NULL;
+			int cchLeft = 0;
+			LPTSTR lpstrLink = NULL;
+			int cchLink = 0;
+			LPTSTR lpstrRight = NULL;
+			int cchRight = 0;
+
+			T* pT = static_cast<T*>(this);
+			pT->CalcLabelParts(lpstrLeft, cchLeft, lpstrLink, cchLink, lpstrRight, cchRight);
+
+			// get label part rects
+			RECT rcClient = { 0 };
+			GetClientRect(&rcClient);
+
+			dc.SetBkMode(TRANSPARENT);
+			HFONT hFontOld = dc.SelectFont(m_hFontNormal);
+
+			UINT uFormat = IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+
+			if(lpstrLeft != NULL)
+				dc.DrawText(lpstrLeft, cchLeft, &rcClient, DT_LEFT | uFormat);
+
+			COLORREF clrOld = dc.SetTextColor(IsWindowEnabled() ? (m_bVisited ? m_clrVisited : m_clrLink) : (::GetSysColor(COLOR_GRAYTEXT)));
+			if(m_hFontLink != NULL && (!IsUnderlineHover() || (IsUnderlineHover() && m_bHover)))
+				dc.SelectFont(m_hFontLink);
+			else
+				dc.SelectFont(m_hFontNormal);
+
+			dc.DrawText(lpstrLink, cchLink, &m_rcLink, DT_LEFT | uFormat);
+
+			dc.SetTextColor(clrOld);
+			dc.SelectFont(m_hFontNormal);
+			if(lpstrRight != NULL)
+			{
+				RECT rcRight = { m_rcLink.right, m_rcLink.top, rcClient.right, rcClient.bottom };
+				dc.DrawText(lpstrRight, cchRight, &rcRight, DT_LEFT | uFormat);
+			}
+
+			if(GetFocus() == m_hWnd)
+				dc.DrawFocusRect(&m_rcLink);
+
+			dc.SelectFont(hFontOld);
+		}
+		else
+		{
+			dc.SetBkMode(TRANSPARENT);
+			COLORREF clrOld = dc.SetTextColor(IsWindowEnabled() ? (m_bVisited ? m_clrVisited : m_clrLink) : (::GetSysColor(COLOR_GRAYTEXT)));
+
+			HFONT hFontOld = NULL;
+			if(m_hFontLink != NULL && (!IsUnderlineHover() || (IsUnderlineHover() && m_bHover)))
+				hFontOld = dc.SelectFont(m_hFontLink);
+			else
+				hFontOld = dc.SelectFont(m_hFontNormal);
+
+			LPTSTR lpstrText = (m_lpstrLabel != NULL) ? m_lpstrLabel : m_lpstrHyperLink;
+
+			DWORD dwStyle = GetStyle();
+			UINT uFormat = DT_LEFT;
+			if (dwStyle & SS_CENTER)
+				uFormat = DT_CENTER;
+			else if (dwStyle & SS_RIGHT)
+				uFormat = DT_RIGHT;
+			uFormat |= IsSingleLine() ? DT_SINGLELINE : DT_WORDBREAK;
+
+			dc.DrawText(lpstrText, -1, &m_rcLink, uFormat);
+
+			if(GetFocus() == m_hWnd)
+				dc.DrawFocusRect(&m_rcLink);
+
+			dc.SetTextColor(clrOld);
+			dc.SelectFont(hFontOld);
+		}
+	}
+
+#ifndef _WIN32_WCE
+	BOOL StartTrackMouseLeave()
+	{
+		TRACKMOUSEEVENT tme = { 0 };
+		tme.cbSize = sizeof(tme);
+		tme.dwFlags = TME_LEAVE;
+		tme.hwndTrack = m_hWnd;
+		return _TrackMouseEvent(&tme);
+	}
+#endif // !_WIN32_WCE
+
+// Implementation helpers
+	bool IsUnderlined() const
+	{
+		return ((m_dwExtendedStyle & (HLINK_NOTUNDERLINED | HLINK_UNDERLINEHOVER)) == 0);
+	}
+
+	bool IsNotUnderlined() const
+	{
+		return ((m_dwExtendedStyle & HLINK_NOTUNDERLINED) != 0);
+	}
+
+	bool IsUnderlineHover() const
+	{
+		return ((m_dwExtendedStyle & HLINK_UNDERLINEHOVER) != 0);
+	}
+
+	bool IsCommandButton() const
+	{
+		return ((m_dwExtendedStyle & HLINK_COMMANDBUTTON) != 0);
+	}
+
+	bool IsNotifyButton() const
+	{
+		return ((m_dwExtendedStyle & HLINK_NOTIFYBUTTON) == HLINK_NOTIFYBUTTON);
+	}
+
+	bool IsUsingTags() const
+	{
+		return ((m_dwExtendedStyle & HLINK_USETAGS) != 0);
+	}
+
+	bool IsUsingTagsBold() const
+	{
+		return ((m_dwExtendedStyle & HLINK_USETAGSBOLD) == HLINK_USETAGSBOLD);
+	}
+
+	bool IsUsingToolTip() const
+	{
+		return ((m_dwExtendedStyle & HLINK_NOTOOLTIP) == 0);
+	}
+
+	bool IsAutoCreateLinkFont() const
+	{
+		return ((m_dwExtendedStyle & HLINK_AUTOCREATELINKFONT) == HLINK_AUTOCREATELINKFONT);
+	}
+
+	bool IsSingleLine() const
+	{
+		return ((m_dwExtendedStyle & HLINK_SINGLELINE) == HLINK_SINGLELINE);
+	}
+};
+
+class CHyperLink : public CHyperLinkImpl<CHyperLink>
+{
+public:
+	DECLARE_WND_CLASS(_T("WTL_HyperLink"))
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWaitCursor - displays a wait cursor
+
+class CWaitCursor
+{
+public:
+// Data
+	HCURSOR m_hWaitCursor;
+	HCURSOR m_hOldCursor;
+	bool m_bInUse;
+
+// Constructor/destructor
+	CWaitCursor(bool bSet = true, LPCTSTR lpstrCursor = IDC_WAIT, bool bSys = true) : m_hOldCursor(NULL), m_bInUse(false)
+	{
+		HINSTANCE hInstance = bSys ? NULL : ModuleHelper::GetResourceInstance();
+		m_hWaitCursor = ::LoadCursor(hInstance, lpstrCursor);
+		ATLASSERT(m_hWaitCursor != NULL);
+
+		if(bSet)
+			Set();
+	}
+
+	~CWaitCursor()
+	{
+		Restore();
+	}
+
+// Methods
+	bool Set()
+	{
+		if(m_bInUse)
+			return false;
+		m_hOldCursor = ::SetCursor(m_hWaitCursor);
+		m_bInUse = true;
+		return true;
+	}
+
+	bool Restore()
+	{
+		if(!m_bInUse)
+			return false;
+		::SetCursor(m_hOldCursor);
+		m_bInUse = false;
+		return true;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCustomWaitCursor - for custom and animated cursors
+
+class CCustomWaitCursor : public CWaitCursor
+{
+public:
+// Constructor/destructor
+	CCustomWaitCursor(ATL::_U_STRINGorID cursor, bool bSet = true, HINSTANCE hInstance = NULL) : 
+			CWaitCursor(false, IDC_WAIT, true)
+	{
+		if(hInstance == NULL)
+			hInstance = ModuleHelper::GetResourceInstance();
+		m_hWaitCursor = (HCURSOR)::LoadImage(hInstance, cursor.m_lpstr, IMAGE_CURSOR, 0, 0, LR_DEFAULTSIZE);
+
+		if(bSet)
+			Set();
+	}
+
+	~CCustomWaitCursor()
+	{
+		Restore();
+#if !defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP)))
+		::DestroyCursor(m_hWaitCursor);
+#endif // !defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP)))
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMultiPaneStatusBarCtrl - Status Bar with multiple panes
+
+template <class T, class TBase = CStatusBarCtrl>
+class ATL_NO_VTABLE CMultiPaneStatusBarCtrlImpl : public ATL::CWindowImpl< T, TBase >
+{
+public:
+	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())
+
+// Data
+	enum { m_cxPaneMargin = 3 };
+
+	int m_nPanes;
+	int* m_pPane;
+
+// Constructor/destructor
+	CMultiPaneStatusBarCtrlImpl() : m_nPanes(0), m_pPane(NULL)
+	{ }
+
+	~CMultiPaneStatusBarCtrlImpl()
+	{
+		delete [] m_pPane;
+	}
+
+// Methods
+	HWND Create(HWND hWndParent, LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
+	{
+#if (_MSC_VER >= 1300)
+		return ATL::CWindowImpl< T, TBase >::Create(hWndParent, rcDefault, lpstrText, dwStyle, 0, nID);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImpl< T, TBase >   _baseClass;
+		return _baseClass::Create(hWndParent, rcDefault, lpstrText, dwStyle, 0, nID);
+#endif // !(_MSC_VER >= 1300)
+	}
+
+	HWND Create(HWND hWndParent, UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
+	{
+		const int cchMax = 128;   // max text length is 127 for status bars (+1 for null)
+		TCHAR szText[cchMax];
+		szText[0] = 0;
+		::LoadString(ModuleHelper::GetResourceInstance(), nTextID, szText, cchMax);
+		return Create(hWndParent, szText, dwStyle, nID);
+	}
+
+	BOOL SetPanes(int* pPanes, int nPanes, bool bSetText = true)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPanes > 0);
+
+		m_nPanes = nPanes;
+		delete [] m_pPane;
+		m_pPane = NULL;
+
+		ATLTRY(m_pPane = new int[nPanes]);
+		ATLASSERT(m_pPane != NULL);
+		if(m_pPane == NULL)
+			return FALSE;
+
+		CTempBuffer<int, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		int* pPanesPos = buff.Allocate(nPanes);
+		ATLASSERT(pPanesPos != NULL);
+		if(pPanesPos == NULL)
+			return FALSE;
+
+		SecureHelper::memcpy_x(m_pPane, nPanes * sizeof(int), pPanes, nPanes * sizeof(int));
+
+		// get status bar DC and set font
+		CClientDC dc(m_hWnd);
+		HFONT hOldFont = dc.SelectFont(GetFont());
+
+		// get status bar borders
+		int arrBorders[3] = { 0 };
+		GetBorders(arrBorders);
+
+		const int cchBuff = 128;
+		TCHAR szBuff[cchBuff] = { 0 };
+		SIZE size = { 0, 0 };
+		int cxLeft = arrBorders[0];
+
+		// calculate right edge of each part
+		for(int i = 0; i < nPanes; i++)
+		{
+			if(pPanes[i] == ID_DEFAULT_PANE)
+			{
+				// make very large, will be resized later
+				pPanesPos[i] = INT_MAX / 2;
+			}
+			else
+			{
+				::LoadString(ModuleHelper::GetResourceInstance(), pPanes[i], szBuff, cchBuff);
+				dc.GetTextExtent(szBuff, lstrlen(szBuff), &size);
+				T* pT = static_cast<T*>(this);
+				pT;
+				pPanesPos[i] = cxLeft + size.cx + arrBorders[2] + 2 * pT->m_cxPaneMargin;
+			}
+			cxLeft = pPanesPos[i];
+		}
+
+		BOOL bRet = SetParts(nPanes, pPanesPos);
+
+		if(bRet && bSetText)
+		{
+			for(int i = 0; i < nPanes; i++)
+			{
+				if(pPanes[i] != ID_DEFAULT_PANE)
+				{
+					::LoadString(ModuleHelper::GetResourceInstance(), pPanes[i], szBuff, cchBuff);
+					SetPaneText(m_pPane[i], szBuff);
+				}
+			}
+		}
+
+		dc.SelectFont(hOldFont);
+		return bRet;
+	}
+
+	bool GetPaneTextLength(int nPaneID, int* pcchLength = NULL, int* pnType = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return false;
+
+		int nLength = GetTextLength(nIndex, pnType);
+		if(pcchLength != NULL)
+			*pcchLength = nLength;
+
+		return true;
+	}
+
+	BOOL GetPaneText(int nPaneID, LPTSTR lpstrText, int* pcchLength = NULL, int* pnType = NULL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		int nLength = GetText(nIndex, lpstrText, pnType);
+		if(pcchLength != NULL)
+			*pcchLength = nLength;
+
+		return TRUE;
+	}
+
+	BOOL SetPaneText(int nPaneID, LPCTSTR lpstrText, int nType = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		return SetText(nIndex, lpstrText, nType);
+	}
+
+	BOOL GetPaneRect(int nPaneID, LPRECT lpRect) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		return GetRect(nIndex, lpRect);
+	}
+
+	BOOL SetPaneWidth(int nPaneID, int cxWidth)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPaneID != ID_DEFAULT_PANE);   // Can't resize this one
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		// get pane positions
+		CTempBuffer<int, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		int* pPanesPos = buff.Allocate(m_nPanes);
+		if(pPanesPos == NULL)
+			return FALSE;
+		GetParts(m_nPanes, pPanesPos);
+		// calculate offset
+		int cxPaneWidth = pPanesPos[nIndex] - ((nIndex == 0) ? 0 : pPanesPos[nIndex - 1]);
+		int cxOff = cxWidth - cxPaneWidth;
+		// find variable width pane
+		int nDef = m_nPanes;
+		for(int i = 0; i < m_nPanes; i++)
+		{
+			if(m_pPane[i] == ID_DEFAULT_PANE)
+			{
+				nDef = i;
+				break;
+			}
+		}
+		// resize
+		if(nIndex < nDef)   // before default pane
+		{
+			for(int i = nIndex; i < nDef; i++)
+				pPanesPos[i] += cxOff;
+				
+		}
+		else			// after default one
+		{
+			for(int i = nDef; i < nIndex; i++)
+				pPanesPos[i] -= cxOff;
+		}
+		// set pane postions
+		return SetParts(m_nPanes, pPanesPos);
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	BOOL GetPaneTipText(int nPaneID, LPTSTR lpstrText, int nSize) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		GetTipText(nIndex, lpstrText, nSize);
+		return TRUE;
+	}
+
+	BOOL SetPaneTipText(int nPaneID, LPCTSTR lpstrText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		SetTipText(nIndex, lpstrText);
+		return TRUE;
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+#if ((_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 0x0500))
+	BOOL GetPaneIcon(int nPaneID, HICON& hIcon) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		hIcon = GetIcon(nIndex);
+		return TRUE;
+	}
+
+	BOOL SetPaneIcon(int nPaneID, HICON hIcon)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		int nIndex  = GetPaneIndexFromID(nPaneID);
+		if(nIndex == -1)
+			return FALSE;
+
+		return SetIcon(nIndex, hIcon);
+	}
+#endif // ((_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)) || (defined(_WIN32_WCE) && (_WIN32_WCE >= 0x0500))
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CMultiPaneStatusBarCtrlImpl< T >)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+	END_MSG_MAP()
+
+	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+		if(wParam != SIZE_MINIMIZED && m_nPanes > 0)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdatePanesLayout();
+		}
+		return lRet;
+	}
+
+// Implementation
+	BOOL UpdatePanesLayout()
+	{
+		// get pane positions
+		CTempBuffer<int, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		int* pPanesPos = buff.Allocate(m_nPanes);
+		ATLASSERT(pPanesPos != NULL);
+		if(pPanesPos == NULL)
+			return FALSE;
+		int nRet = GetParts(m_nPanes, pPanesPos);
+		ATLASSERT(nRet == m_nPanes);
+		if(nRet != m_nPanes)
+			return FALSE;
+		// calculate offset
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+		int cxOff = rcClient.right - pPanesPos[m_nPanes - 1];
+#ifndef _WIN32_WCE
+		// Move panes left if size grip box is present
+		if((GetStyle() & SBARS_SIZEGRIP) != 0)
+			cxOff -= ::GetSystemMetrics(SM_CXVSCROLL) + ::GetSystemMetrics(SM_CXEDGE);
+#endif // !_WIN32_WCE
+		// find variable width pane
+		int i;
+		for(i = 0; i < m_nPanes; i++)
+		{
+			if(m_pPane[i] == ID_DEFAULT_PANE)
+				break;
+		}
+		// resize all panes from the variable one to the right
+		if((i < m_nPanes) && (pPanesPos[i] + cxOff) > ((i == 0) ? 0 : pPanesPos[i - 1]))
+		{
+			for(; i < m_nPanes; i++)
+				pPanesPos[i] += cxOff;
+		}
+		// set pane postions
+		return SetParts(m_nPanes, pPanesPos);
+	}
+
+	int GetPaneIndexFromID(int nPaneID) const
+	{
+		for(int i = 0; i < m_nPanes; i++)
+		{
+			if(m_pPane[i] == nPaneID)
+				return i;
+		}
+
+		return -1;   // not found
+	}
+};
+
+class CMultiPaneStatusBarCtrl : public CMultiPaneStatusBarCtrlImpl<CMultiPaneStatusBarCtrl>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_MultiPaneStatusBar"), GetWndClassName())
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPaneContainer - provides header with title and close button for panes
+
+// pane container extended styles
+#define PANECNT_NOCLOSEBUTTON	0x00000001
+#define PANECNT_VERTICAL	0x00000002
+#define PANECNT_FLATBORDER	0x00000004
+#define PANECNT_NOBORDER	0x00000008
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CPaneContainerImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >, public CCustomDraw< T >
+{
+public:
+	DECLARE_WND_CLASS_EX(NULL, 0, -1)
+
+// Constants
+	enum
+	{
+		m_cxyBorder = 2,
+		m_cxyTextOffset = 4,
+		m_cxyBtnOffset = 1,
+
+		m_cchTitle = 80,
+
+		m_cxImageTB = 13,
+		m_cyImageTB = 11,
+		m_cxyBtnAddTB = 7,
+
+		m_cxToolBar = m_cxImageTB + m_cxyBtnAddTB + m_cxyBorder + m_cxyBtnOffset,
+
+		m_xBtnImageLeft = 6,
+		m_yBtnImageTop = 5,
+		m_xBtnImageRight = 12,
+		m_yBtnImageBottom = 11,
+
+		m_nCloseBtnID = ID_PANE_CLOSE
+	};
+
+// Data members
+	CToolBarCtrl m_tb;
+	ATL::CWindow m_wndClient;
+	int m_cxyHeader;
+	TCHAR m_szTitle[m_cchTitle];
+	DWORD m_dwExtendedStyle;   // Pane container specific extended styles
+	HFONT m_hFont;
+	bool m_bInternalFont;
+
+
+// Constructor
+	CPaneContainerImpl() : m_cxyHeader(0), m_dwExtendedStyle(0), m_hFont(NULL), m_bInternalFont(false)
+	{
+		m_szTitle[0] = 0;
+	}
+
+// Attributes
+	DWORD GetPaneContainerExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+	DWORD SetPaneContainerExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		if(m_hWnd != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			bool bUpdate = false;
+
+			if(((dwPrevStyle & PANECNT_NOCLOSEBUTTON) != 0) && ((m_dwExtendedStyle & PANECNT_NOCLOSEBUTTON) == 0))   // add close button
+			{
+				pT->CreateCloseButton();
+				bUpdate = true;
+			}
+			else if(((dwPrevStyle & PANECNT_NOCLOSEBUTTON) == 0) && ((m_dwExtendedStyle & PANECNT_NOCLOSEBUTTON) != 0))   // remove close button
+			{
+				pT->DestroyCloseButton();
+				bUpdate = true;
+			}
+
+			if((dwPrevStyle & PANECNT_VERTICAL) != (m_dwExtendedStyle & PANECNT_VERTICAL))   // change orientation
+			{
+				pT->CalcSize();
+				bUpdate = true;
+			}
+
+			if((dwPrevStyle & (PANECNT_FLATBORDER | PANECNT_NOBORDER)) != 
+			   (m_dwExtendedStyle & (PANECNT_FLATBORDER | PANECNT_NOBORDER)))   // change border
+			{
+				bUpdate = true;
+			}
+
+			if(bUpdate)
+				pT->UpdateLayout();
+		}
+		return dwPrevStyle;
+	}
+
+	HWND GetClient() const
+	{
+		return m_wndClient;
+	}
+
+	HWND SetClient(HWND hWndClient)
+	{
+		HWND hWndOldClient = m_wndClient;
+		m_wndClient = hWndClient;
+		if(m_hWnd != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdateLayout();
+		}
+		return hWndOldClient;
+	}
+
+	BOOL GetTitle(LPTSTR lpstrTitle, int cchLength) const
+	{
+		ATLASSERT(lpstrTitle != NULL);
+
+		errno_t nRet = SecureHelper::strncpy_x(lpstrTitle, cchLength, m_szTitle, _TRUNCATE);
+
+		return (nRet == 0 || nRet == STRUNCATE);
+	}
+
+	BOOL SetTitle(LPCTSTR lpstrTitle)
+	{
+		ATLASSERT(lpstrTitle != NULL);
+
+		errno_t nRet = SecureHelper::strncpy_x(m_szTitle, m_cchTitle, lpstrTitle, _TRUNCATE);
+		bool bRet = (nRet == 0 || nRet == STRUNCATE);
+		if(bRet && m_hWnd != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdateLayout();
+		}
+
+		return bRet;
+	}
+
+	int GetTitleLength() const
+	{
+		return lstrlen(m_szTitle);
+	}
+
+// Methods
+	HWND Create(HWND hWndParent, LPCTSTR lpstrTitle = NULL, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
+			DWORD dwExStyle = 0, UINT nID = 0, LPVOID lpCreateParam = NULL)
+	{
+		if(lpstrTitle != NULL)
+			SecureHelper::strncpy_x(m_szTitle, m_cchTitle, lpstrTitle, _TRUNCATE);
+#if (_MSC_VER >= 1300)
+		return ATL::CWindowImpl< T, TBase, TWinTraits >::Create(hWndParent, rcDefault, NULL, dwStyle, dwExStyle, nID, lpCreateParam);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImpl< T, TBase, TWinTraits >   _baseClass;
+		return _baseClass::Create(hWndParent, rcDefault, NULL, dwStyle, dwExStyle, nID, lpCreateParam);
+#endif // !(_MSC_VER >= 1300)
+	}
+
+	HWND Create(HWND hWndParent, UINT uTitleID, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_CLIPCHILDREN,
+			DWORD dwExStyle = 0, UINT nID = 0, LPVOID lpCreateParam = NULL)
+	{
+		if(uTitleID != 0U)
+			::LoadString(ModuleHelper::GetResourceInstance(), uTitleID, m_szTitle, m_cchTitle);
+#if (_MSC_VER >= 1300)
+		return ATL::CWindowImpl< T, TBase, TWinTraits >::Create(hWndParent, rcDefault, NULL, dwStyle, dwExStyle, nID, lpCreateParam);
+#else // !(_MSC_VER >= 1300)
+		typedef ATL::CWindowImpl< T, TBase, TWinTraits >   _baseClass;
+		return _baseClass::Create(hWndParent, rcDefault, NULL, dwStyle, dwExStyle, nID, lpCreateParam);
+#endif // !(_MSC_VER >= 1300)
+	}
+
+	BOOL EnableCloseButton(BOOL bEnable)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		return (m_tb.m_hWnd != NULL) ? m_tb.EnableButton(pT->m_nCloseBtnID, bEnable) : FALSE;
+	}
+
+	void UpdateLayout()
+	{
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout(rcClient.right, rcClient.bottom);
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CPaneContainerImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
+		MESSAGE_HANDLER(WM_GETFONT, OnGetFont)
+		MESSAGE_HANDLER(WM_SETFONT, OnSetFont)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+#endif // !_WIN32_WCE
+		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
+		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
+		FORWARD_NOTIFICATIONS()
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_hFont == NULL)
+		{
+			// The same as AtlCreateControlFont() for horizontal pane
+#ifndef _WIN32_WCE
+			LOGFONT lf = { 0 };
+			ATLVERIFY(::SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lf, 0) != FALSE);
+			if(IsVertical())
+				lf.lfEscapement = 900;   // 90 degrees
+			m_hFont = ::CreateFontIndirect(&lf);
+#else // CE specific
+			m_hFont = (HFONT)::GetStockObject(SYSTEM_FONT);
+			if(IsVertical())
+			{
+				CLogFont lf(m_hFont);
+				lf.lfEscapement = 900;   // 90 degrees
+				m_hFont = ::CreateFontIndirect(&lf);
+			}
+#endif // _WIN32_WCE
+			m_bInternalFont = true;
+		}
+
+		T* pT = static_cast<T*>(this);
+		pT->CalcSize();
+
+		if((m_dwExtendedStyle & PANECNT_NOCLOSEBUTTON) == 0)
+			pT->CreateCloseButton();
+
+		return 0;
+	}
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_bInternalFont)
+		{
+			::DeleteObject(m_hFont);
+			m_hFont = NULL;
+			m_bInternalFont = false;
+		}
+
+		return 0;
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
+		return 0;
+	}
+
+	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_wndClient.m_hWnd != NULL)
+			m_wndClient.SetFocus();
+		return 0;
+	}
+
+	LRESULT OnGetFont(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return (LRESULT)m_hFont;
+	}
+
+	LRESULT OnSetFont(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if(m_bInternalFont)
+		{
+			::DeleteObject(m_hFont);
+			m_bInternalFont = false;
+		}
+
+		m_hFont = (HFONT)wParam;
+
+		T* pT = static_cast<T*>(this);
+		pT->CalcSize();
+
+		if((BOOL)lParam != FALSE)
+			pT->UpdateLayout();
+
+		return 0;
+	}
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background needed
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		if(wParam != NULL)
+		{
+			pT->DrawPaneTitle((HDC)wParam);
+
+			if(m_wndClient.m_hWnd == NULL)   // no client window
+				pT->DrawPane((HDC)wParam);
+		}
+		else
+		{
+			CPaintDC dc(m_hWnd);
+			pT->DrawPaneTitle(dc.m_hDC);
+
+			if(m_wndClient.m_hWnd == NULL)   // no client window
+				pT->DrawPane(dc.m_hDC);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnNotify(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(m_tb.m_hWnd == NULL)
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+
+		T* pT = static_cast<T*>(this);
+		pT;
+		LPNMHDR lpnmh = (LPNMHDR)lParam;
+		LRESULT lRet = 0;
+
+		// pass toolbar custom draw notifications to the base class
+		if(lpnmh->code == NM_CUSTOMDRAW && lpnmh->hwndFrom == m_tb.m_hWnd)
+			lRet = CCustomDraw< T >::OnCustomDraw(0, lpnmh, bHandled);
+#ifndef _WIN32_WCE
+		// tooltip notifications come with the tooltip window handle and button ID,
+		// pass them to the parent if we don't handle them
+		else if(lpnmh->code == TTN_GETDISPINFO && lpnmh->idFrom == pT->m_nCloseBtnID)
+			bHandled = pT->GetToolTipText(lpnmh);
+#endif // !_WIN32_WCE
+		// only let notifications not from the toolbar go to the parent
+		else if(lpnmh->hwndFrom != m_tb.m_hWnd && lpnmh->idFrom != pT->m_nCloseBtnID)
+			bHandled = FALSE;
+
+		return lRet;
+	}
+
+	LRESULT OnCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		// if command comes from the close button, substitute HWND of the pane container instead
+		if(m_tb.m_hWnd != NULL && (HWND)lParam == m_tb.m_hWnd)
+			return ::SendMessage(GetParent(), WM_COMMAND, wParam, (LPARAM)m_hWnd);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+// Custom draw overrides
+	DWORD OnPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW /*lpNMCustomDraw*/)
+	{
+		return CDRF_NOTIFYITEMDRAW;   // we need per-item notifications
+	}
+
+	DWORD OnItemPrePaint(int /*idCtrl*/, LPNMCUSTOMDRAW lpNMCustomDraw)
+	{
+		CDCHandle dc = lpNMCustomDraw->hdc;
+#if (_WIN32_IE >= 0x0400)
+		RECT& rc = lpNMCustomDraw->rc;
+#else // !(_WIN32_IE >= 0x0400)
+		RECT rc;
+		m_tb.GetItemRect(0, &rc);
+#endif // !(_WIN32_IE >= 0x0400)
+
+		dc.FillRect(&rc, COLOR_3DFACE);
+
+		return CDRF_NOTIFYPOSTPAINT;
+	}
+
+	DWORD OnItemPostPaint(int /*idCtrl*/, LPNMCUSTOMDRAW lpNMCustomDraw)
+	{
+		CDCHandle dc = lpNMCustomDraw->hdc;
+#if (_WIN32_IE >= 0x0400)
+		RECT& rc = lpNMCustomDraw->rc;
+#else // !(_WIN32_IE >= 0x0400)
+		RECT rc = { 0 };
+		m_tb.GetItemRect(0, &rc);
+#endif // !(_WIN32_IE >= 0x0400)
+
+		RECT rcImage = { m_xBtnImageLeft, m_yBtnImageTop, m_xBtnImageRight + 1, m_yBtnImageBottom + 1 };
+		::OffsetRect(&rcImage, rc.left, rc.top);
+		T* pT = static_cast<T*>(this);
+
+		if((lpNMCustomDraw->uItemState & CDIS_DISABLED) != 0)
+		{
+			RECT rcShadow = rcImage;
+			::OffsetRect(&rcShadow, 1, 1);
+			CPen pen1;
+			pen1.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_3DHILIGHT));
+			pT->DrawButtonImage(dc, rcShadow, pen1);
+			CPen pen2;
+			pen2.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_3DSHADOW));
+			pT->DrawButtonImage(dc, rcImage, pen2);
+		}
+		else
+		{
+			if((lpNMCustomDraw->uItemState & CDIS_SELECTED) != 0)
+				::OffsetRect(&rcImage, 1, 1);
+			CPen pen;
+			pen.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_BTNTEXT));
+			pT->DrawButtonImage(dc, rcImage, pen);
+		}
+
+		return CDRF_DODEFAULT;   // continue with the default item painting
+	}
+
+// Implementation - overrideable methods
+	void UpdateLayout(int cxWidth, int cyHeight)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		RECT rect = { 0 };
+
+		if(IsVertical())
+		{
+			::SetRect(&rect, 0, 0, m_cxyHeader, cyHeight);
+			if(m_tb.m_hWnd != NULL)
+				m_tb.SetWindowPos(NULL, m_cxyBorder, m_cxyBorder + m_cxyBtnOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
+
+			if(m_wndClient.m_hWnd != NULL)
+				m_wndClient.SetWindowPos(NULL, m_cxyHeader, 0, cxWidth - m_cxyHeader, cyHeight, SWP_NOZORDER);
+			else
+				rect.right = cxWidth;
+		}
+		else
+		{
+			::SetRect(&rect, 0, 0, cxWidth, m_cxyHeader);
+			if(m_tb.m_hWnd != NULL)
+				m_tb.SetWindowPos(NULL, rect.right - m_cxToolBar, m_cxyBorder + m_cxyBtnOffset, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
+
+			if(m_wndClient.m_hWnd != NULL)
+				m_wndClient.SetWindowPos(NULL, 0, m_cxyHeader, cxWidth, cyHeight - m_cxyHeader, SWP_NOZORDER);
+			else
+				rect.bottom = cyHeight;
+		}
+
+		InvalidateRect(&rect);
+	}
+
+	void CreateCloseButton()
+	{
+		ATLASSERT(m_tb.m_hWnd == NULL);
+		// create toolbar for the "x" button
+		m_tb.Create(m_hWnd, rcDefault, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN | CCS_NOMOVEY | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT, 0);
+		ATLASSERT(m_tb.IsWindow());
+
+		if(m_tb.m_hWnd != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT;   // avoid level 4 warning
+
+			m_tb.SetButtonStructSize();
+
+			TBBUTTON tbbtn = { 0 };
+			tbbtn.idCommand = pT->m_nCloseBtnID;
+			tbbtn.fsState = TBSTATE_ENABLED;
+			tbbtn.fsStyle = TBSTYLE_BUTTON;
+			m_tb.AddButtons(1, &tbbtn);
+
+			m_tb.SetBitmapSize(m_cxImageTB, m_cyImageTB);
+			m_tb.SetButtonSize(m_cxImageTB + m_cxyBtnAddTB, m_cyImageTB + m_cxyBtnAddTB);
+
+			if(IsVertical())
+				m_tb.SetWindowPos(NULL, m_cxyBorder + m_cxyBtnOffset, m_cxyBorder + m_cxyBtnOffset, m_cxImageTB + m_cxyBtnAddTB, m_cyImageTB + m_cxyBtnAddTB, SWP_NOZORDER | SWP_NOACTIVATE);
+			else
+				m_tb.SetWindowPos(NULL, 0, 0, m_cxImageTB + m_cxyBtnAddTB, m_cyImageTB + m_cxyBtnAddTB, SWP_NOZORDER | SWP_NOMOVE | SWP_NOACTIVATE);
+		}
+	}
+
+	void DestroyCloseButton()
+	{
+		if(m_tb.m_hWnd != NULL)
+			m_tb.DestroyWindow();
+	}
+
+	void CalcSize()
+	{
+		T* pT = static_cast<T*>(this);
+		CFontHandle font = pT->GetTitleFont();
+		if(font.IsNull())
+			font = (HFONT)::GetStockObject(SYSTEM_FONT);
+		LOGFONT lf = { 0 };
+		font.GetLogFont(lf);
+		if(IsVertical())
+		{
+			m_cxyHeader = m_cxImageTB + m_cxyBtnAddTB + m_cxyBorder;
+		}
+		else
+		{
+			int cyFont = abs(lf.lfHeight) + m_cxyBorder + 2 * m_cxyTextOffset;
+			int cyBtn = m_cyImageTB + m_cxyBtnAddTB + m_cxyBorder + 2 * m_cxyBtnOffset;
+			m_cxyHeader = max(cyFont, cyBtn);
+		}
+	}
+
+	HFONT GetTitleFont() const
+	{
+		return m_hFont;
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetToolTipText(LPNMHDR /*lpnmh*/)
+	{
+		return FALSE;
+	}
+#endif // !_WIN32_WCE
+
+	void DrawPaneTitle(CDCHandle dc)
+	{
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+
+		UINT uBorder = BF_LEFT | BF_TOP | BF_ADJUST;
+		if(IsVertical())
+		{
+			rect.right = rect.left + m_cxyHeader;
+			uBorder |= BF_BOTTOM;
+		}
+		else
+		{
+			rect.bottom = rect.top + m_cxyHeader;
+			uBorder |= BF_RIGHT;
+		}
+
+		if((m_dwExtendedStyle & PANECNT_NOBORDER) == 0)
+		{
+			if((m_dwExtendedStyle & PANECNT_FLATBORDER) != 0)
+				uBorder |= BF_FLAT;
+			dc.DrawEdge(&rect, EDGE_ETCHED, uBorder);
+		}
+		dc.FillRect(&rect, COLOR_3DFACE);
+
+		// draw title text
+		dc.SetTextColor(::GetSysColor(COLOR_WINDOWTEXT));
+		dc.SetBkMode(TRANSPARENT);
+		T* pT = static_cast<T*>(this);
+		HFONT hFontOld = dc.SelectFont(pT->GetTitleFont());
+#ifdef _WIN32_WCE
+		const UINT DT_END_ELLIPSIS = 0;
+#endif // _WIN32_WCE
+
+		if(IsVertical())
+		{
+			rect.top += m_cxyTextOffset;
+			rect.bottom -= m_cxyTextOffset;
+			if(m_tb.m_hWnd != NULL)
+				rect.top += m_cxToolBar;;
+
+			RECT rcCalc = { rect.left, rect.bottom, rect.right, rect.top };
+			int cxFont = dc.DrawText(m_szTitle, -1, &rcCalc, DT_TOP | DT_SINGLELINE | DT_END_ELLIPSIS | DT_CALCRECT);
+			RECT rcText = { 0 };
+			rcText.left = (rect.right - rect.left - cxFont) / 2;
+			rcText.right = rcText.left + (rect.bottom - rect.top);
+			rcText.top = rect.bottom;
+			rcText.bottom = rect.top;
+			dc.DrawText(m_szTitle, -1, &rcText, DT_TOP | DT_SINGLELINE | DT_END_ELLIPSIS);
+		}
+		else
+		{
+			rect.left += m_cxyTextOffset;
+			rect.right -= m_cxyTextOffset;
+			if(m_tb.m_hWnd != NULL)
+				rect.right -= m_cxToolBar;;
+
+			dc.DrawText(m_szTitle, -1, &rect, DT_LEFT | DT_SINGLELINE | DT_VCENTER | DT_END_ELLIPSIS);
+		}
+
+		dc.SelectFont(hFontOld);
+	}
+
+	// called only if pane is empty
+	void DrawPane(CDCHandle dc)
+	{
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+		if(IsVertical())
+			rect.left += m_cxyHeader;
+		else
+			rect.top += m_cxyHeader;
+		if((GetExStyle() & WS_EX_CLIENTEDGE) == 0)
+			dc.DrawEdge(&rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
+		dc.FillRect(&rect, COLOR_APPWORKSPACE);
+	}
+
+	// drawing helper - draws "x" button image
+	void DrawButtonImage(CDCHandle dc, RECT& rcImage, HPEN hPen)
+	{
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+		HPEN hPenOld = dc.SelectPen(hPen);
+
+		dc.MoveTo(rcImage.left, rcImage.top);
+		dc.LineTo(rcImage.right, rcImage.bottom);
+		dc.MoveTo(rcImage.left + 1, rcImage.top);
+		dc.LineTo(rcImage.right + 1, rcImage.bottom);
+
+		dc.MoveTo(rcImage.left, rcImage.bottom - 1);
+		dc.LineTo(rcImage.right, rcImage.top - 1);
+		dc.MoveTo(rcImage.left + 1, rcImage.bottom - 1);
+		dc.LineTo(rcImage.right + 1, rcImage.top - 1);
+
+		dc.SelectPen(hPenOld);
+#else // (_WIN32_WCE < 400)
+		rcImage;
+		hPen;
+		// no support for the "x" button image
+#endif // (_WIN32_WCE < 400)
+	}
+
+	bool IsVertical() const
+	{
+		return ((m_dwExtendedStyle & PANECNT_VERTICAL) != 0);
+	}
+};
+
+class CPaneContainer : public CPaneContainerImpl<CPaneContainer>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_PaneContainer"), 0, -1)
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CSortListViewCtrl - implements sorting for a listview control
+
+// sort listview extended styles
+#define SORTLV_USESHELLBITMAPS	0x00000001
+
+// Notification sent to parent when sort column is changed by user clicking header.  
+#define SLVN_SORTCHANGED	LVN_LAST
+
+// A LPNMSORTLISTVIEW is sent with the SLVN_SORTCHANGED notification
+typedef struct tagNMSORTLISTVIEW
+{
+    NMHDR hdr;
+    int iNewSortColumn;
+    int iOldSortColumn;
+} NMSORTLISTVIEW, *LPNMSORTLISTVIEW;
+
+// Column sort types. Can be set on a per-column basis with the SetColumnSortType method.
+enum
+{
+	LVCOLSORT_NONE,
+	LVCOLSORT_TEXT,   // default
+	LVCOLSORT_TEXTNOCASE,
+	LVCOLSORT_LONG,
+	LVCOLSORT_DOUBLE,
+	LVCOLSORT_DECIMAL,
+	LVCOLSORT_DATETIME,
+	LVCOLSORT_DATE,
+	LVCOLSORT_TIME,
+	LVCOLSORT_CUSTOM,
+	LVCOLSORT_LAST = LVCOLSORT_CUSTOM
+};
+
+
+template <class T>
+class CSortListViewImpl
+{
+public:
+	enum
+	{
+		m_cchCmpTextMax = 32, // overrideable
+		m_cxSortImage = 16,
+		m_cySortImage = 15,
+		m_cxSortArrow = 11,
+		m_cySortArrow = 6,
+		m_iSortUp = 0,        // index of sort bitmaps
+		m_iSortDown = 1,
+		m_nShellSortUpID = 133
+	};
+
+	// passed to LVCompare functions as lParam1 and lParam2 
+	struct LVCompareParam
+	{
+		int iItem;
+		DWORD_PTR dwItemData;
+		union
+		{
+			long lValue;
+			double dblValue;
+			DECIMAL decValue;
+			LPCTSTR pszValue;
+		};
+	};
+	
+	// passed to LVCompare functions as the lParamSort parameter
+	struct LVSortInfo
+	{
+		T* pT;
+		int iSortCol;
+		bool bDescending;
+	};
+
+	bool m_bSortDescending;
+	bool m_bCommCtrl6;
+	int m_iSortColumn;
+	CBitmap m_bmSort[2];
+	int m_fmtOldSortCol;
+	HBITMAP m_hbmOldSortCol;
+	DWORD m_dwSortLVExtendedStyle;
+	ATL::CSimpleArray<WORD> m_arrColSortType;
+	bool m_bUseWaitCursor;
+	
+	CSortListViewImpl() :
+			m_bSortDescending(false),
+			m_bCommCtrl6(false),
+			m_iSortColumn(-1), 
+			m_fmtOldSortCol(0),
+			m_hbmOldSortCol(NULL),
+			m_dwSortLVExtendedStyle(SORTLV_USESHELLBITMAPS),
+			m_bUseWaitCursor(true)
+	{
+#ifndef _WIN32_WCE
+		DWORD dwMajor = 0;
+		DWORD dwMinor = 0;
+		HRESULT hRet = ATL::AtlGetCommCtrlVersion(&dwMajor, &dwMinor);
+		m_bCommCtrl6 = SUCCEEDED(hRet) && dwMajor >= 6;
+#endif // !_WIN32_WCE
+	}
+	
+// Attributes
+	void SetSortColumn(int iCol)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		CHeaderCtrl header = pT->GetHeader();
+		ATLASSERT(header.m_hWnd != NULL);
+		ATLASSERT(iCol >= -1 && iCol < m_arrColSortType.GetSize());
+
+		int iOldSortCol = m_iSortColumn;
+		m_iSortColumn = iCol;
+		if(m_bCommCtrl6)
+		{
+#ifndef HDF_SORTUP
+			const int HDF_SORTUP = 0x0400;	
+#endif // HDF_SORTUP
+#ifndef HDF_SORTDOWN
+			const int HDF_SORTDOWN = 0x0200;	
+#endif // HDF_SORTDOWN
+			const int nMask = HDF_SORTUP | HDF_SORTDOWN;
+			HDITEM hditem = { HDI_FORMAT };
+			if(iOldSortCol != iCol && iOldSortCol >= 0 && header.GetItem(iOldSortCol, &hditem))
+			{
+				hditem.fmt &= ~nMask;
+				header.SetItem(iOldSortCol, &hditem);
+			}
+			if(iCol >= 0 && header.GetItem(iCol, &hditem))
+			{
+				hditem.fmt &= ~nMask;
+				hditem.fmt |= m_bSortDescending ? HDF_SORTDOWN : HDF_SORTUP;
+				header.SetItem(iCol, &hditem);
+			}
+			return;
+		}
+
+		if(m_bmSort[m_iSortUp].IsNull())
+			pT->CreateSortBitmaps();
+
+		// restore previous sort column's bitmap, if any, and format
+		HDITEM hditem = { HDI_BITMAP | HDI_FORMAT };
+		if(iOldSortCol != iCol && iOldSortCol >= 0)
+		{
+			hditem.hbm = m_hbmOldSortCol;
+			hditem.fmt = m_fmtOldSortCol;
+			header.SetItem(iOldSortCol, &hditem);
+		}
+
+		// save new sort column's bitmap and format, and add our sort bitmap
+		if(iCol >= 0 && header.GetItem(iCol, &hditem))
+		{
+			if(iOldSortCol != iCol)
+			{
+				m_fmtOldSortCol = hditem.fmt;
+				m_hbmOldSortCol = hditem.hbm;
+			}
+			hditem.fmt &= ~HDF_IMAGE;
+			hditem.fmt |= HDF_BITMAP | HDF_BITMAP_ON_RIGHT;
+			int i = m_bSortDescending ? m_iSortDown : m_iSortUp;
+			hditem.hbm = m_bmSort[i];
+			header.SetItem(iCol, &hditem);
+		}
+	}
+
+	int GetSortColumn() const
+	{
+		return m_iSortColumn;
+	}
+
+	void SetColumnSortType(int iCol, WORD wType)
+	{
+		ATLASSERT(iCol >= 0 && iCol < m_arrColSortType.GetSize());
+		ATLASSERT(wType >= LVCOLSORT_NONE && wType <= LVCOLSORT_LAST);
+		m_arrColSortType[iCol] = wType;
+	}
+
+	WORD GetColumnSortType(int iCol) const
+	{
+		ATLASSERT((iCol >= 0) && iCol < m_arrColSortType.GetSize());
+		return m_arrColSortType[iCol];
+	}
+
+	int GetColumnCount() const
+	{
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		CHeaderCtrl header = pT->GetHeader();
+		return header.m_hWnd != NULL ? header.GetItemCount() : 0;
+	}
+
+	bool IsSortDescending() const
+	{
+		return m_bSortDescending;
+	}
+
+	DWORD GetSortListViewExtendedStyle() const
+	{
+		return m_dwSortLVExtendedStyle;
+	}
+
+	DWORD SetSortListViewExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwSortLVExtendedStyle;
+		if(dwMask == 0)
+			m_dwSortLVExtendedStyle = dwExtendedStyle;
+		else
+			m_dwSortLVExtendedStyle = (m_dwSortLVExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		return dwPrevStyle;
+	}
+
+// Operations
+	bool DoSortItems(int iCol, bool bDescending = false)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		ATLASSERT(iCol >= 0 && iCol < m_arrColSortType.GetSize());
+
+		WORD wType = m_arrColSortType[iCol];
+		if(wType == LVCOLSORT_NONE)
+			return false;
+
+		int nCount = pT->GetItemCount();
+		if(nCount < 2)
+		{
+			m_bSortDescending = bDescending;
+			SetSortColumn(iCol);
+			return true;
+		}
+
+		CWaitCursor waitCursor(false);
+		if(m_bUseWaitCursor)
+			waitCursor.Set();
+
+		LVCompareParam* pParam = NULL;
+		ATLTRY(pParam = new LVCompareParam[nCount]);
+		PFNLVCOMPARE pFunc = NULL;
+		TCHAR pszTemp[pT->m_cchCmpTextMax];
+		bool bStrValue = false;
+
+		switch(wType)
+		{
+		case LVCOLSORT_TEXT:
+			pFunc = (PFNLVCOMPARE)pT->LVCompareText;
+		case LVCOLSORT_TEXTNOCASE:
+			if(pFunc == NULL)
+				pFunc = (PFNLVCOMPARE)pT->LVCompareTextNoCase;
+		case LVCOLSORT_CUSTOM:
+			{
+				if(pFunc == NULL)
+					pFunc = (PFNLVCOMPARE)pT->LVCompareCustom;
+
+				for(int i = 0; i < nCount; i++)
+				{
+					pParam[i].iItem = i;
+					pParam[i].dwItemData = pT->GetItemData(i);
+					pParam[i].pszValue = new TCHAR[pT->m_cchCmpTextMax];
+					pT->GetItemText(i, iCol, (LPTSTR)pParam[i].pszValue, pT->m_cchCmpTextMax);
+					pT->SetItemData(i, (DWORD_PTR)&pParam[i]);
+				}
+				bStrValue = true;
+			}
+			break;
+		case LVCOLSORT_LONG:
+			{
+				pFunc = (PFNLVCOMPARE)pT->LVCompareLong;
+				for(int i = 0; i < nCount; i++)
+				{
+					pParam[i].iItem = i;
+					pParam[i].dwItemData = pT->GetItemData(i);
+					pT->GetItemText(i, iCol, pszTemp, pT->m_cchCmpTextMax);
+					pParam[i].lValue = pT->StrToLong(pszTemp);
+					pT->SetItemData(i, (DWORD_PTR)&pParam[i]);
+				}
+			}
+			break;
+		case LVCOLSORT_DOUBLE:
+			{
+				pFunc = (PFNLVCOMPARE)pT->LVCompareDouble;
+				for(int i = 0; i < nCount; i++)
+				{
+					pParam[i].iItem = i;
+					pParam[i].dwItemData = pT->GetItemData(i);
+					pT->GetItemText(i, iCol, pszTemp, pT->m_cchCmpTextMax);
+					pParam[i].dblValue = pT->StrToDouble(pszTemp);
+					pT->SetItemData(i, (DWORD_PTR)&pParam[i]);
+				}
+			}
+			break;
+		case LVCOLSORT_DECIMAL:
+			{
+				pFunc = (PFNLVCOMPARE)pT->LVCompareDecimal;
+				for(int i = 0; i < nCount; i++)
+				{
+					pParam[i].iItem = i;
+					pParam[i].dwItemData = pT->GetItemData(i);
+					pT->GetItemText(i, iCol, pszTemp, pT->m_cchCmpTextMax);
+					pT->StrToDecimal(pszTemp, &pParam[i].decValue);
+					pT->SetItemData(i, (DWORD_PTR)&pParam[i]);
+				}
+			}
+			break;
+		case LVCOLSORT_DATETIME:
+		case LVCOLSORT_DATE:
+		case LVCOLSORT_TIME:
+			{
+				pFunc = (PFNLVCOMPARE)pT->LVCompareDouble;
+				DWORD dwFlags = LOCALE_NOUSEROVERRIDE;
+				if(wType == LVCOLSORT_DATE)
+					dwFlags |= VAR_DATEVALUEONLY;
+				else if(wType == LVCOLSORT_TIME)
+					dwFlags |= VAR_TIMEVALUEONLY;
+				for(int i = 0; i < nCount; i++)
+				{
+					pParam[i].iItem = i;
+					pParam[i].dwItemData = pT->GetItemData(i);
+					pT->GetItemText(i, iCol, pszTemp, pT->m_cchCmpTextMax);
+					pParam[i].dblValue = pT->DateStrToDouble(pszTemp, dwFlags);
+					pT->SetItemData(i, (DWORD_PTR)&pParam[i]);
+				}
+			}
+			break;
+		default:
+			ATLTRACE2(atlTraceUI, 0, _T("Unknown value for sort type in CSortListViewImpl::DoSortItems()\n"));
+			break;
+		} // switch(wType)
+
+		ATLASSERT(pFunc != NULL);
+		LVSortInfo lvsi = { pT, iCol, bDescending };
+		bool bRet = ((BOOL)pT->DefWindowProc(LVM_SORTITEMS, (WPARAM)&lvsi, (LPARAM)pFunc) != FALSE);
+		for(int i = 0; i < nCount; i++)
+		{
+			DWORD_PTR dwItemData = pT->GetItemData(i);
+			LVCompareParam* p = (LVCompareParam*)dwItemData;
+			ATLASSERT(p != NULL);
+			if(bStrValue)
+				delete [] (TCHAR*)p->pszValue;
+			pT->SetItemData(i, p->dwItemData);
+		}
+		delete [] pParam;
+
+		if(bRet)
+		{
+			m_bSortDescending = bDescending;
+			SetSortColumn(iCol);
+		}
+
+		if(m_bUseWaitCursor)
+			waitCursor.Restore();
+
+		return bRet;
+	}
+
+	void CreateSortBitmaps()
+	{
+		if((m_dwSortLVExtendedStyle & SORTLV_USESHELLBITMAPS) != 0)
+		{
+			bool bFree = false;
+			LPCTSTR pszModule = _T("shell32.dll"); 
+			HINSTANCE hShell = ::GetModuleHandle(pszModule);
+
+			if (hShell == NULL)		
+			{
+				hShell = ::LoadLibrary(pszModule);
+				bFree = true;
+			}
+ 
+			if (hShell != NULL)
+			{
+				bool bSuccess = true;
+				for(int i = m_iSortUp; i <= m_iSortDown; i++)
+				{
+					if(!m_bmSort[i].IsNull())
+						m_bmSort[i].DeleteObject();
+					m_bmSort[i] = (HBITMAP)::LoadImage(hShell, MAKEINTRESOURCE(m_nShellSortUpID + i), 
+#ifndef _WIN32_WCE
+						IMAGE_BITMAP, 0, 0, LR_LOADMAP3DCOLORS);
+#else // CE specific
+						IMAGE_BITMAP, 0, 0, 0);
+#endif // _WIN32_WCE
+					if(m_bmSort[i].IsNull())
+					{
+						bSuccess = false;
+						break;
+					}
+				}
+				if(bFree)
+					::FreeLibrary(hShell);
+				if(bSuccess)
+					return;
+			}
+		}
+
+		T* pT = static_cast<T*>(this);
+		for(int i = m_iSortUp; i <= m_iSortDown; i++)
+		{
+			if(!m_bmSort[i].IsNull())
+				m_bmSort[i].DeleteObject();
+
+			CDC dcMem;
+			CClientDC dc(::GetDesktopWindow());
+			dcMem.CreateCompatibleDC(dc.m_hDC);
+			m_bmSort[i].CreateCompatibleBitmap(dc.m_hDC, m_cxSortImage, m_cySortImage);
+			HBITMAP hbmOld = dcMem.SelectBitmap(m_bmSort[i]);
+			RECT rc = {0,0,m_cxSortImage, m_cySortImage};
+			pT->DrawSortBitmap(dcMem.m_hDC, i, &rc);
+			dcMem.SelectBitmap(hbmOld);
+			dcMem.DeleteDC();
+		}
+	}
+
+	void NotifyParentSortChanged(int iNewSortCol, int iOldSortCol)
+	{
+		T* pT = static_cast<T*>(this);
+		int nID = pT->GetDlgCtrlID();
+		NMSORTLISTVIEW nm = { { pT->m_hWnd, nID, SLVN_SORTCHANGED }, iNewSortCol, iOldSortCol };
+		::SendMessage(pT->GetParent(), WM_NOTIFY, (WPARAM)nID, (LPARAM)&nm);
+	}
+
+// Overrideables
+	int CompareItemsCustom(LVCompareParam* /*pItem1*/, LVCompareParam* /*pItem2*/, int /*iSortCol*/)
+	{
+		// pItem1 and pItem2 contain valid iItem, dwItemData, and pszValue members.
+		// If item1 > item2 return 1, if item1 < item2 return -1, else return 0.
+		return 0;
+	}
+
+	void DrawSortBitmap(CDCHandle dc, int iBitmap, LPRECT prc)
+	{
+		dc.FillRect(prc, ::GetSysColorBrush(COLOR_BTNFACE));	
+		HBRUSH hbrOld = dc.SelectBrush(::GetSysColorBrush(COLOR_BTNSHADOW));
+		CPen pen;
+		pen.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_BTNSHADOW));
+		HPEN hpenOld = dc.SelectPen(pen);
+		POINT ptOrg = { (m_cxSortImage - m_cxSortArrow) / 2, (m_cySortImage - m_cySortArrow) / 2 };
+		if(iBitmap == m_iSortUp)
+		{
+			POINT pts[3] = 
+			{
+				{ ptOrg.x + m_cxSortArrow / 2, ptOrg.y },
+				{ ptOrg.x, ptOrg.y + m_cySortArrow - 1 }, 
+				{ ptOrg.x + m_cxSortArrow - 1, ptOrg.y + m_cySortArrow - 1 }
+			};
+			dc.Polygon(pts, 3);
+		}
+		else
+		{
+			POINT pts[3] = 
+			{
+				{ ptOrg.x, ptOrg.y },
+				{ ptOrg.x + m_cxSortArrow / 2, ptOrg.y + m_cySortArrow - 1 },
+				{ ptOrg.x + m_cxSortArrow - 1, ptOrg.y }
+			};
+			dc.Polygon(pts, 3);
+		}
+		dc.SelectBrush(hbrOld);
+		dc.SelectPen(hpenOld);
+	}
+
+	double DateStrToDouble(LPCTSTR lpstr, DWORD dwFlags)
+	{
+		ATLASSERT(lpstr != NULL);
+		if(lpstr == NULL || lpstr[0] == _T('\0'))
+			return 0;
+
+		USES_CONVERSION;
+		HRESULT hRet = E_FAIL;
+		DATE dRet = 0;
+		if (FAILED(hRet = ::VarDateFromStr((LPOLESTR)T2COLE(lpstr), LANG_USER_DEFAULT, dwFlags, &dRet)))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("VarDateFromStr failed with result of 0x%8.8X\n"), hRet);
+			dRet = 0;
+		}
+		return dRet;
+	}
+
+	long StrToLong(LPCTSTR lpstr)
+	{
+		ATLASSERT(lpstr != NULL);
+		if(lpstr == NULL || lpstr[0] == _T('\0'))
+			return 0;
+		
+		USES_CONVERSION;
+		HRESULT hRet = E_FAIL;
+		long lRet = 0;
+		if (FAILED(hRet = ::VarI4FromStr((LPOLESTR)T2COLE(lpstr), LANG_USER_DEFAULT, LOCALE_NOUSEROVERRIDE, &lRet)))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("VarI4FromStr failed with result of 0x%8.8X\n"), hRet);
+			lRet = 0;
+		}
+		return lRet;
+	}
+
+	double StrToDouble(LPCTSTR lpstr)
+	{
+		ATLASSERT(lpstr != NULL);
+		if(lpstr == NULL || lpstr[0] == _T('\0'))
+			return 0;
+
+		USES_CONVERSION;
+		HRESULT hRet = E_FAIL;
+		double dblRet = 0;
+		if (FAILED(hRet = ::VarR8FromStr((LPOLESTR)T2COLE(lpstr), LANG_USER_DEFAULT, LOCALE_NOUSEROVERRIDE, &dblRet)))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("VarR8FromStr failed with result of 0x%8.8X\n"), hRet);
+			dblRet = 0;
+		}
+		return dblRet;
+	}
+
+	bool StrToDecimal(LPCTSTR lpstr, DECIMAL* pDecimal)
+	{
+		ATLASSERT(lpstr != NULL);
+		ATLASSERT(pDecimal != NULL);
+		if(lpstr == NULL || pDecimal == NULL)
+			return false;
+
+		USES_CONVERSION;
+		HRESULT hRet = E_FAIL;
+		if (FAILED(hRet = ::VarDecFromStr((LPOLESTR)T2COLE(lpstr), LANG_USER_DEFAULT, LOCALE_NOUSEROVERRIDE, pDecimal)))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("VarDecFromStr failed with result of 0x%8.8X\n"), hRet);
+			pDecimal->Lo64 = 0;
+			pDecimal->Hi32 = 0;
+			pDecimal->signscale = 0;
+			return false;
+		}
+		return true;
+	}
+
+// Overrideable PFNLVCOMPARE functions
+	static int CALLBACK LVCompareText(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = lstrcmp(pParam1->pszValue, pParam2->pszValue);
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+
+	static int CALLBACK LVCompareTextNoCase(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = lstrcmpi(pParam1->pszValue, pParam2->pszValue);
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+
+	static int CALLBACK LVCompareLong(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = 0;
+		if(pParam1->lValue > pParam2->lValue)
+			nRet = 1;
+		else if(pParam1->lValue < pParam2->lValue)
+			nRet = -1;
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+
+	static int CALLBACK LVCompareDouble(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = 0;
+		if(pParam1->dblValue > pParam2->dblValue)
+			nRet = 1;
+		else if(pParam1->dblValue < pParam2->dblValue)
+			nRet = -1;
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+
+	static int CALLBACK LVCompareCustom(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = pInfo->pT->CompareItemsCustom(pParam1, pParam2, pInfo->iSortCol);
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+
+#ifndef _WIN32_WCE
+	static int CALLBACK LVCompareDecimal(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = (int)::VarDecCmp(&pParam1->decValue, &pParam2->decValue);
+		nRet--;
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+#else
+	// Compare mantissas, ignore sign and scale
+	static int CompareMantissas(const DECIMAL& decLeft, const DECIMAL& decRight)
+	{
+		if (decLeft.Hi32 < decRight.Hi32)
+		{
+			return -1;
+		}
+		if (decLeft.Hi32 > decRight.Hi32)
+		{
+			return 1;
+		}
+		// Here, decLeft.Hi32 == decRight.Hi32
+		if (decLeft.Lo64 < decRight.Lo64)
+		{
+			return -1;
+		}
+		if (decLeft.Lo64 > decRight.Lo64)
+		{
+			return 1;
+		}
+		return 0;
+	}
+
+	// return values: VARCMP_LT, VARCMP_EQ, VARCMP_GT, VARCMP_NULL
+	static HRESULT VarDecCmp(const DECIMAL* pdecLeft, const DECIMAL* pdecRight)
+	{
+		static const ULONG powersOfTen[] =
+		{
+			10ul,
+			100ul,
+			1000ul,
+			10000ul,
+			100000ul,
+			1000000ul,
+			10000000ul,
+			100000000ul,
+			1000000000ul
+		};
+		static const int largestPower = sizeof(powersOfTen) / sizeof(powersOfTen[0]);
+		if (!pdecLeft || !pdecRight)
+		{
+			return VARCMP_NULL;
+		}
+		
+		// Degenerate case - at least one comparand is of the form
+		// [+-]0*10^N (denormalized zero)
+		bool bLeftZero = (!pdecLeft->Lo64 && !pdecLeft->Hi32);
+		bool bRightZero = (!pdecRight->Lo64 && !pdecRight->Hi32);
+		if (bLeftZero && bRightZero)
+		{
+			return VARCMP_EQ;
+		}
+		bool bLeftNeg = ((pdecLeft->sign & DECIMAL_NEG) != 0);
+		bool bRightNeg = ((pdecRight->sign & DECIMAL_NEG) != 0);
+		if (bLeftZero)
+		{
+			return (bRightNeg ? VARCMP_GT : VARCMP_LT);
+		}
+		// This also covers the case where the comparands have different signs
+		if (bRightZero || bLeftNeg != bRightNeg)
+		{
+			return (bLeftNeg ? VARCMP_LT : VARCMP_GT);
+		}
+
+		// Here both comparands have the same sign and need to be compared
+		// on mantissa and scale. The result is obvious when
+		// 1. Scales are equal (then compare mantissas)
+		// 2. A number with smaller scale is also the one with larger mantissa
+		//    (then this number is obviously larger)
+		// In the remaining case, we would multiply the number with smaller
+		// scale by 10 and simultaneously increment its scale (which amounts to
+		// adding trailing zeros after decimal point), until the numbers fall under
+		// one of the two cases above
+		DECIMAL temp;
+		bool bInvert = bLeftNeg; // the final result needs to be inverted
+		if (pdecLeft->scale < pdecRight->scale)
+		{
+			temp = *pdecLeft;
+		}
+		else
+		{
+			temp = *pdecRight;
+			pdecRight = pdecLeft;
+			bInvert = !bInvert;
+		}
+
+		// Now temp is the number with smaller (or equal) scale, and
+		// we can modify it freely without touching original parameters
+		int comp;
+		while ((comp = CompareMantissas(temp, *pdecRight)) < 0 &&
+			temp.scale < pdecRight->scale)
+		{
+			// Multiply by an appropriate power of 10
+			int scaleDiff = pdecRight->scale - temp.scale;
+			if (scaleDiff > largestPower)
+			{
+				// Keep the multiplier representable in 32bit
+				scaleDiff = largestPower;
+			}
+			DWORDLONG power = powersOfTen[scaleDiff - 1];
+			// Multiply temp's mantissa by power
+			DWORDLONG product = temp.Lo32 * power;
+			ULONG carry = static_cast<ULONG>(product >> 32);
+			temp.Lo32  = static_cast<ULONG>(product);
+			product = temp.Mid32 * power + carry;
+			carry = static_cast<ULONG>(product >> 32);
+			temp.Mid32 = static_cast<ULONG>(product);
+			product = temp.Hi32 * power + carry;
+			if (static_cast<ULONG>(product >> 32))
+			{
+				// Multiplication overflowed - pdecLeft is clearly larger
+				break;
+			}
+			temp.Hi32 = static_cast<ULONG>(product);
+			temp.scale = (BYTE)(temp.scale + scaleDiff);
+		}
+		if (temp.scale < pdecRight->scale)
+		{
+			comp = 1;
+		}
+		if (bInvert)
+		{
+			comp = -comp;
+		}
+		return (comp > 0 ? VARCMP_GT : comp < 0 ? VARCMP_LT : VARCMP_EQ);
+	}
+
+	static int CALLBACK LVCompareDecimal(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
+	{
+		ATLASSERT(lParam1 != NULL && lParam2 != NULL && lParamSort != NULL);
+
+		LVCompareParam* pParam1 = (LVCompareParam*)lParam1;
+		LVCompareParam* pParam2 = (LVCompareParam*)lParam2;
+		LVSortInfo* pInfo = (LVSortInfo*)lParamSort;
+		
+		int nRet = (int)VarDecCmp(&pParam1->decValue, &pParam2->decValue);
+		nRet--;
+		return pInfo->bDescending ? -nRet : nRet;
+	}
+#endif // !_WIN32_WCE
+
+	BEGIN_MSG_MAP(CSortListViewImpl)
+		MESSAGE_HANDLER(LVM_INSERTCOLUMN, OnInsertColumn)
+		MESSAGE_HANDLER(LVM_DELETECOLUMN, OnDeleteColumn)
+		NOTIFY_CODE_HANDLER(HDN_ITEMCLICKA, OnHeaderItemClick)
+		NOTIFY_CODE_HANDLER(HDN_ITEMCLICKW, OnHeaderItemClick)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+	END_MSG_MAP()
+
+	LRESULT OnInsertColumn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)	
+	{
+		T* pT = static_cast<T*>(this);
+		LRESULT lRet = pT->DefWindowProc(uMsg, wParam, lParam);
+		if(lRet == -1)
+			return -1;
+
+		WORD wType = 0;
+		m_arrColSortType.Add(wType);
+		int nCount = m_arrColSortType.GetSize();
+		ATLASSERT(nCount == GetColumnCount());
+
+		for(int i = nCount - 1; i > lRet; i--)
+			m_arrColSortType[i] = m_arrColSortType[i - 1];
+		m_arrColSortType[(int)lRet] = LVCOLSORT_TEXT;
+
+		if(lRet <= m_iSortColumn)
+			m_iSortColumn++;
+
+		return lRet;
+	}
+
+	LRESULT OnDeleteColumn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)	
+	{
+		T* pT = static_cast<T*>(this);
+		LRESULT lRet = pT->DefWindowProc(uMsg, wParam, lParam);
+		if(lRet == 0)
+			return 0;
+
+		int iCol = (int)wParam; 
+		if(m_iSortColumn == iCol)
+			m_iSortColumn = -1;
+		else if(m_iSortColumn > iCol)
+			m_iSortColumn--;
+		m_arrColSortType.RemoveAt(iCol);
+
+		return lRet;
+	}
+
+	LRESULT OnHeaderItemClick(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		LPNMHEADER p = (LPNMHEADER)pnmh;
+		if(p->iButton == 0)
+		{
+			int iOld = m_iSortColumn;
+			bool bDescending = (m_iSortColumn == p->iItem) ? !m_bSortDescending : false;
+			if(DoSortItems(p->iItem, bDescending))
+				NotifyParentSortChanged(p->iItem, iOld);				
+		}
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifndef _WIN32_WCE
+		if(wParam == SPI_SETNONCLIENTMETRICS)
+			GetSystemSettings();
+#else  // CE specific
+		wParam; // avoid level 4 warning
+		GetSystemSettings();
+#endif // _WIN32_WCE
+		bHandled = FALSE;
+		return 0;
+	}
+
+	void GetSystemSettings()
+	{
+		if(!m_bCommCtrl6 && !m_bmSort[m_iSortUp].IsNull())
+		{
+			T* pT = static_cast<T*>(this);
+			pT->CreateSortBitmaps();
+			if(m_iSortColumn != -1)
+				SetSortColumn(m_iSortColumn);
+		}
+	}
+
+};
+
+
+typedef ATL::CWinTraits<WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | LVS_REPORT | LVS_SHOWSELALWAYS , WS_EX_CLIENTEDGE>   CSortListViewCtrlTraits;
+
+template <class T, class TBase = CListViewCtrl, class TWinTraits = CSortListViewCtrlTraits>
+class ATL_NO_VTABLE CSortListViewCtrlImpl: public ATL::CWindowImpl<T, TBase, TWinTraits>, public CSortListViewImpl<T>
+{
+public:
+	DECLARE_WND_SUPERCLASS(NULL, TBase::GetWndClassName())
+
+	bool SortItems(int iCol, bool bDescending = false)
+	{
+		return DoSortItems(iCol, bDescending);
+	}
+		
+	BEGIN_MSG_MAP(CSortListViewCtrlImpl)
+		MESSAGE_HANDLER(LVM_INSERTCOLUMN, CSortListViewImpl<T>::OnInsertColumn)
+		MESSAGE_HANDLER(LVM_DELETECOLUMN, CSortListViewImpl<T>::OnDeleteColumn)
+		NOTIFY_CODE_HANDLER(HDN_ITEMCLICKA, CSortListViewImpl<T>::OnHeaderItemClick)
+		NOTIFY_CODE_HANDLER(HDN_ITEMCLICKW, CSortListViewImpl<T>::OnHeaderItemClick)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CSortListViewImpl<T>::OnSettingChange)
+	END_MSG_MAP()
+};
+
+class CSortListViewCtrl : public CSortListViewCtrlImpl<CSortListViewCtrl>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_SortListViewCtrl"), GetWndClassName())
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTabView - implements tab view window
+
+// TabView Notifications
+#define TBVN_PAGEACTIVATED   (0U-741)
+#define TBVN_CONTEXTMENU     (0U-742)
+
+// Notification data for TBVN_CONTEXTMENU
+struct TBVCONTEXTMENUINFO
+{
+	NMHDR hdr;
+	POINT pt;
+};
+
+typedef TBVCONTEXTMENUINFO* LPTBVCONTEXTMENUINFO;
+
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CTabViewImpl : public ATL::CWindowImpl<T, TBase, TWinTraits>
+{
+public:
+	DECLARE_WND_CLASS_EX(NULL, 0, COLOR_APPWORKSPACE)
+
+// Declarations and enums
+	struct TABVIEWPAGE
+	{
+		HWND hWnd;
+		LPTSTR lpstrTitle;
+		LPVOID pData;
+	};
+
+	struct TCITEMEXTRA
+	{
+		TCITEMHEADER tciheader;
+		TABVIEWPAGE tvpage;
+
+		operator LPTCITEM() { return (LPTCITEM)this; }
+	};
+
+	enum
+	{
+		m_nTabID = 1313,
+		m_cxMoveMark = 6,
+		m_cyMoveMark = 3,
+		m_nMenuItemsMax = (ID_WINDOW_TABLAST - ID_WINDOW_TABFIRST + 1)
+	};
+
+// Data members
+	ATL::CContainedWindowT<CTabCtrl> m_tab;
+	int m_cyTabHeight;
+
+	int m_nActivePage;
+
+	int m_nInsertItem;
+	POINT m_ptStartDrag;
+
+	CMenuHandle m_menu;
+
+	int m_cchTabTextLength;
+
+	int m_nMenuItemsCount;
+
+	ATL::CWindow m_wndTitleBar;
+	LPTSTR m_lpstrTitleBarBase;
+	int m_cchTitleBarLength;
+
+	CImageList m_ilDrag;
+
+	bool m_bDestroyPageOnRemove:1;
+	bool m_bDestroyImageList:1;
+	bool m_bActivePageMenuItem:1;
+	bool m_bActiveAsDefaultMenuItem:1;
+	bool m_bEmptyMenuItem:1;
+	bool m_bWindowsMenuItem:1;
+	bool m_bNoTabDrag:1;
+	// internal
+	bool m_bTabCapture:1;
+	bool m_bTabDrag:1;
+	bool m_bInternalFont:1;
+
+// Constructor/destructor
+	CTabViewImpl() :
+			m_nActivePage(-1), 
+			m_cyTabHeight(0), 
+			m_tab(this, 1), 
+			m_nInsertItem(-1), 
+			m_cchTabTextLength(30), 
+			m_nMenuItemsCount(10), 
+			m_lpstrTitleBarBase(NULL), 
+			m_cchTitleBarLength(100), 
+			m_bDestroyPageOnRemove(true), 
+			m_bDestroyImageList(true), 
+			m_bActivePageMenuItem(true), 
+			m_bActiveAsDefaultMenuItem(false), 
+			m_bEmptyMenuItem(false), 
+			m_bWindowsMenuItem(false), 
+			m_bNoTabDrag(false), 
+			m_bTabCapture(false), 
+			m_bTabDrag(false), 
+			m_bInternalFont(false)
+	{
+		m_ptStartDrag.x = 0;
+		m_ptStartDrag.y = 0;
+	}
+
+	~CTabViewImpl()
+	{
+		delete [] m_lpstrTitleBarBase;
+	}
+
+// Message filter function - to be called from PreTranslateMessage of the main window
+	BOOL PreTranslateMessage(MSG* pMsg)
+	{
+		if(IsWindow() == FALSE)
+			return FALSE;
+
+		BOOL bRet = FALSE;
+
+		// Check for TabView built-in accelerators (Ctrl+Tab/Ctrl+Shift+Tab - next/previous page)
+		int nCount = GetPageCount();
+		if(nCount > 0)
+		{
+			bool bControl = (::GetKeyState(VK_CONTROL) < 0);
+			if((pMsg->message == WM_KEYDOWN) && (pMsg->wParam == VK_TAB) && bControl)
+			{
+				if(nCount > 1)
+				{
+					int nPage = m_nActivePage;
+					bool bShift = (::GetKeyState(VK_SHIFT) < 0);
+					if(bShift)
+						nPage = (nPage > 0) ? (nPage - 1) : (nCount - 1);
+					else
+						nPage = ((nPage >= 0) && (nPage < (nCount - 1))) ? (nPage + 1) : 0;
+
+					SetActivePage(nPage);
+					T* pT = static_cast<T*>(this);
+					pT->OnPageActivated(m_nActivePage);
+				}
+
+				bRet = TRUE;
+			}
+		}
+
+		// If we are doing drag-drop, check for Escape key that cancels it
+		if(bRet == FALSE)
+		{
+			if(m_bTabCapture && pMsg->message == WM_KEYDOWN && pMsg->wParam == VK_ESCAPE)
+			{
+				::ReleaseCapture();
+				bRet = TRUE;
+			}
+		}
+
+		// Pass the message to the active page
+		if(bRet == FALSE)
+		{
+			if(m_nActivePage != -1)
+				bRet = (BOOL)::SendMessage(GetPageHWND(m_nActivePage), WM_FORWARDMSG, 0, (LPARAM)pMsg);
+		}
+
+		return bRet;
+	}
+
+// Attributes
+	int GetPageCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return m_tab.GetItemCount();
+	}
+
+	int GetActivePage() const
+	{
+		return m_nActivePage;
+	}
+
+	void SetActivePage(int nPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		T* pT = static_cast<T*>(this);
+
+		SetRedraw(FALSE);
+
+		if(m_nActivePage != -1)
+			::ShowWindow(GetPageHWND(m_nActivePage), FALSE);
+		m_nActivePage = nPage;
+		m_tab.SetCurSel(m_nActivePage);
+		::ShowWindow(GetPageHWND(m_nActivePage), TRUE);
+
+		pT->UpdateLayout();
+
+		SetRedraw(TRUE);
+		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
+
+		if(::GetFocus() != m_tab.m_hWnd)
+			::SetFocus(GetPageHWND(m_nActivePage));
+
+		pT->UpdateTitleBar();
+		pT->UpdateMenu();
+	}
+
+	HIMAGELIST GetImageList() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return m_tab.GetImageList();
+	}
+
+	HIMAGELIST SetImageList(HIMAGELIST hImageList)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return m_tab.SetImageList(hImageList);
+	}
+
+	void SetWindowMenu(HMENU hMenu)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		m_menu = hMenu;
+
+		T* pT = static_cast<T*>(this);
+		pT->UpdateMenu();
+	}
+
+	void SetTitleBarWindow(HWND hWnd)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		delete [] m_lpstrTitleBarBase;
+		m_lpstrTitleBarBase = NULL;
+
+		m_wndTitleBar = hWnd;
+		if(hWnd == NULL)
+			return;
+
+		int cchLen = m_wndTitleBar.GetWindowTextLength() + 1;
+		ATLTRY(m_lpstrTitleBarBase = new TCHAR[cchLen]);
+		if(m_lpstrTitleBarBase != NULL)
+		{
+			m_wndTitleBar.GetWindowText(m_lpstrTitleBarBase, cchLen);
+			T* pT = static_cast<T*>(this);
+			pT->UpdateTitleBar();
+		}
+	}
+
+// Page attributes
+	HWND GetPageHWND(int nPage) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_PARAM;
+		m_tab.GetItem(nPage, tcix);
+
+		return tcix.tvpage.hWnd;
+	}
+
+	LPCTSTR GetPageTitle(int nPage) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_PARAM;
+		if(m_tab.GetItem(nPage, tcix) == FALSE)
+			return NULL;
+
+		return tcix.tvpage.lpstrTitle;
+	}
+
+	bool SetPageTitle(int nPage, LPCTSTR lpstrTitle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		T* pT = static_cast<T*>(this);
+
+		int cchBuff = lstrlen(lpstrTitle) + 1;
+		LPTSTR lpstrBuff = NULL;
+		ATLTRY(lpstrBuff = new TCHAR[cchBuff]);
+		if(lpstrBuff == NULL)
+			return false;
+
+		SecureHelper::strcpy_x(lpstrBuff, cchBuff, lpstrTitle);
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_PARAM;
+		if(m_tab.GetItem(nPage, tcix) == FALSE)
+			return false;
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrTabText = buff.Allocate(m_cchTabTextLength + 1);
+		if(lpstrTabText == NULL)
+			return false;
+
+		delete [] tcix.tvpage.lpstrTitle;
+
+		pT->ShortenTitle(lpstrTitle, lpstrTabText, m_cchTabTextLength + 1);
+
+		tcix.tciheader.mask = TCIF_TEXT | TCIF_PARAM;
+		tcix.tciheader.pszText = lpstrTabText;
+		tcix.tvpage.lpstrTitle = lpstrBuff;
+		if(m_tab.SetItem(nPage, tcix) == FALSE)
+			return false;
+
+		pT->UpdateTitleBar();
+		pT->UpdateMenu();
+
+		return true;
+	}
+
+	LPVOID GetPageData(int nPage) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_PARAM;
+		m_tab.GetItem(nPage, tcix);
+
+		return tcix.tvpage.pData;
+	}
+
+	LPVOID SetPageData(int nPage, LPVOID pData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_PARAM;
+		m_tab.GetItem(nPage, tcix);
+		LPVOID pDataOld = tcix.tvpage.pData;
+
+		tcix.tvpage.pData = pData;
+		m_tab.SetItem(nPage, tcix);
+
+		return pDataOld;
+	}
+
+	int GetPageImage(int nPage) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_IMAGE;
+		m_tab.GetItem(nPage, tcix);
+
+		return tcix.tciheader.iImage;
+	}
+
+	int SetPageImage(int nPage, int nImage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_IMAGE;
+		m_tab.GetItem(nPage, tcix);
+		int nImageOld = tcix.tciheader.iImage;
+
+		tcix.tciheader.iImage = nImage;
+		m_tab.SetItem(nPage, tcix);
+
+		return nImageOld;
+	}
+
+// Operations
+	bool AddPage(HWND hWndView, LPCTSTR lpstrTitle, int nImage = -1, LPVOID pData = NULL)
+	{
+		return InsertPage(GetPageCount(), hWndView, lpstrTitle, nImage, pData);
+	}
+
+	bool InsertPage(int nPage, HWND hWndView, LPCTSTR lpstrTitle, int nImage = -1, LPVOID pData = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(nPage == GetPageCount() || IsValidPageIndex(nPage));
+
+		T* pT = static_cast<T*>(this);
+
+		int cchBuff = lstrlen(lpstrTitle) + 1;
+		LPTSTR lpstrBuff = NULL;
+		ATLTRY(lpstrBuff = new TCHAR[cchBuff]);
+		if(lpstrBuff == NULL)
+			return false;
+
+		SecureHelper::strcpy_x(lpstrBuff, cchBuff, lpstrTitle);
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrTabText = buff.Allocate(m_cchTabTextLength + 1);
+		if(lpstrTabText == NULL)
+			return false;
+
+		pT->ShortenTitle(lpstrTitle, lpstrTabText, m_cchTabTextLength + 1);
+
+		SetRedraw(FALSE);
+
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_TEXT | TCIF_IMAGE | TCIF_PARAM;
+		tcix.tciheader.pszText = lpstrTabText;
+		tcix.tciheader.iImage = nImage;
+		tcix.tvpage.hWnd = hWndView;
+		tcix.tvpage.lpstrTitle = lpstrBuff;
+		tcix.tvpage.pData = pData;
+		int nItem = m_tab.InsertItem(nPage, tcix);
+		if(nItem == -1)
+		{
+			delete [] lpstrBuff;
+			SetRedraw(TRUE);
+			return false;
+		}
+
+		SetActivePage(nItem);
+		pT->OnPageActivated(m_nActivePage);
+
+		if(GetPageCount() == 1)
+			pT->ShowTabControl(true);
+
+		pT->UpdateLayout();
+
+		SetRedraw(TRUE);
+		RedrawWindow(NULL, NULL, RDW_FRAME | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
+
+		return true;
+	}
+
+	void RemovePage(int nPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(IsValidPageIndex(nPage));
+
+		T* pT = static_cast<T*>(this);
+
+		SetRedraw(FALSE);
+
+		if(GetPageCount() == 1)
+			pT->ShowTabControl(false);
+
+		if(m_bDestroyPageOnRemove)
+			::DestroyWindow(GetPageHWND(nPage));
+		else
+			::ShowWindow(GetPageHWND(nPage), FALSE);
+		LPTSTR lpstrTitle = (LPTSTR)GetPageTitle(nPage);
+		delete [] lpstrTitle;
+
+		ATLVERIFY(m_tab.DeleteItem(nPage) != FALSE);
+
+		if(m_nActivePage == nPage)
+		{
+			m_nActivePage = -1;
+
+			if(nPage > 0)
+			{
+				SetActivePage(nPage - 1);
+			}
+			else if(GetPageCount() > 0)
+			{
+				SetActivePage(nPage);
+			}
+			else
+			{
+				SetRedraw(TRUE);
+				Invalidate();
+				UpdateWindow();
+				pT->UpdateTitleBar();
+				pT->UpdateMenu();
+			}
+		}
+		else
+		{
+			nPage = (nPage < m_nActivePage) ? (m_nActivePage - 1) : m_nActivePage;
+			m_nActivePage = -1;
+			SetActivePage(nPage);
+		}
+
+		pT->OnPageActivated(m_nActivePage);
+	}
+
+	void RemoveAllPages()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		if(GetPageCount() == 0)
+			return;
+
+		T* pT = static_cast<T*>(this);
+
+		SetRedraw(FALSE);
+
+		pT->ShowTabControl(false);
+
+		for(int i = 0; i < GetPageCount(); i++)
+		{
+			if(m_bDestroyPageOnRemove)
+				::DestroyWindow(GetPageHWND(i));
+			else
+				::ShowWindow(GetPageHWND(i), FALSE);
+			LPTSTR lpstrTitle = (LPTSTR)GetPageTitle(i);
+			delete [] lpstrTitle;
+		}
+		m_tab.DeleteAllItems();
+
+		m_nActivePage = -1;
+		pT->OnPageActivated(m_nActivePage);
+
+		SetRedraw(TRUE);
+		Invalidate();
+		UpdateWindow();
+
+		pT->UpdateTitleBar();
+		pT->UpdateMenu();
+	}
+
+	int PageIndexFromHwnd(HWND hWnd) const
+	{
+		int nIndex = -1;
+
+		for(int i = 0; i < GetPageCount(); i++)
+		{
+			if(GetPageHWND(i) == hWnd)
+			{
+				nIndex = i;
+				break;
+			}
+		}
+
+		return nIndex;
+	}
+
+	void BuildWindowMenu(HMENU hMenu, int nMenuItemsCount = 10, bool bEmptyMenuItem = true, bool bWindowsMenuItem = true, bool bActivePageMenuItem = true, bool bActiveAsDefaultMenuItem = false)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		CMenuHandle menu = hMenu;
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		int nFirstPos = 0;
+
+		// Find first menu item in our range
+#ifndef _WIN32_WCE
+		for(nFirstPos = 0; nFirstPos < menu.GetMenuItemCount(); nFirstPos++)
+		{
+			UINT nID = menu.GetMenuItemID(nFirstPos);
+			if((nID >= ID_WINDOW_TABFIRST && nID <= ID_WINDOW_TABLAST) || nID == ID_WINDOW_SHOWTABLIST)
+				break;
+		}
+#else // CE specific
+		for(nFirstPos = 0; ; nFirstPos++)
+		{
+			CMenuItemInfo mii;
+			mii.fMask = MIIM_ID;
+			BOOL bRet = menu.GetMenuItemInfo(nFirstPos, TRUE, &mii);
+			if(bRet == FALSE)
+				break;
+			if((mii.wID >= ID_WINDOW_TABFIRST && mii.wID <= ID_WINDOW_TABLAST) || mii.wID == ID_WINDOW_SHOWTABLIST)
+				break;
+		}
+#endif // _WIN32_WCE
+
+		// Remove all menu items for tab pages
+		BOOL bRet = TRUE;
+		while(bRet != FALSE)
+			bRet = menu.DeleteMenu(nFirstPos, MF_BYPOSITION);
+
+		// Add separator if it's not already there
+		int nPageCount = GetPageCount();
+		if((bWindowsMenuItem || (nPageCount > 0)) && (nFirstPos > 0))
+		{
+			CMenuItemInfo mii;
+			mii.fMask = MIIM_TYPE;
+			menu.GetMenuItemInfo(nFirstPos - 1, TRUE, &mii);
+			if((nFirstPos <= 0) || ((mii.fType & MFT_SEPARATOR) == 0))
+			{
+				menu.AppendMenu(MF_SEPARATOR);
+				nFirstPos++;
+			}
+		}
+
+		// Add menu items for all pages
+		if(nPageCount > 0)
+		{
+			// Append menu items for all pages
+			const int cchPrefix = 3;   // 2 digits + space
+			nMenuItemsCount = min(min(nPageCount, nMenuItemsCount), (int)m_nMenuItemsMax);
+			ATLASSERT(nMenuItemsCount < 100);   // 2 digits only
+			if(nMenuItemsCount >= 100)
+				nMenuItemsCount = 99;
+
+			for(int i = 0; i < nMenuItemsCount; i++)
+			{
+				LPCTSTR lpstrTitle = GetPageTitle(i);
+				int nLen = lstrlen(lpstrTitle);
+				CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+				LPTSTR lpstrText = buff.Allocate(cchPrefix + nLen + 1);
+				ATLASSERT(lpstrText != NULL);
+				if(lpstrText != NULL)
+				{
+					LPCTSTR lpstrFormat = (i < 9) ? _T("&%i %s") : _T("%i %s");
+					SecureHelper::wsprintf_x(lpstrText, cchPrefix + nLen + 1, lpstrFormat, i + 1, lpstrTitle);
+					menu.AppendMenu(MF_STRING, ID_WINDOW_TABFIRST + i, lpstrText);
+				}
+			}
+
+			// Mark active page
+			if(bActivePageMenuItem && (m_nActivePage != -1))
+			{
+#ifndef _WIN32_WCE
+				if(bActiveAsDefaultMenuItem)
+				{
+					menu.SetMenuDefaultItem((UINT)-1,  TRUE);
+					menu.SetMenuDefaultItem(nFirstPos + m_nActivePage,  TRUE);
+				}
+				else
+#else // CE specific
+				bActiveAsDefaultMenuItem;   // avoid level 4 warning
+#endif // _WIN32_WCE
+				{
+					menu.CheckMenuRadioItem(nFirstPos, nFirstPos + nMenuItemsCount, nFirstPos + m_nActivePage, MF_BYPOSITION);
+				}
+			}
+		}
+		else
+		{
+			if(bEmptyMenuItem)
+			{
+				menu.AppendMenu(MF_BYPOSITION | MF_STRING, ID_WINDOW_TABFIRST, pT->GetEmptyListText());
+				menu.EnableMenuItem(ID_WINDOW_TABFIRST, MF_GRAYED);
+			}
+
+			// Remove separator if nothing else is there
+			if(!bEmptyMenuItem && !bWindowsMenuItem && (nFirstPos > 0))
+			{
+				CMenuItemInfo mii;
+				mii.fMask = MIIM_TYPE;
+				menu.GetMenuItemInfo(nFirstPos - 1, TRUE, &mii);
+				if((mii.fType & MFT_SEPARATOR) != 0)
+					menu.DeleteMenu(nFirstPos - 1, MF_BYPOSITION);
+			}
+		}
+
+		// Add "Windows..." menu item
+		if(bWindowsMenuItem)
+			menu.AppendMenu(MF_BYPOSITION | MF_STRING, ID_WINDOW_SHOWTABLIST, pT->GetWindowsMenuItemText());
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CTabViewImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
+		MESSAGE_HANDLER(WM_GETFONT, OnGetFont)
+		MESSAGE_HANDLER(WM_SETFONT, OnSetFont)
+		NOTIFY_HANDLER(m_nTabID, TCN_SELCHANGE, OnTabChanged)
+		NOTIFY_ID_HANDLER(m_nTabID, OnTabNotification)
+#ifndef _WIN32_WCE
+		NOTIFY_CODE_HANDLER(TTN_GETDISPINFO, OnTabGetDispInfo)
+#endif // !_WIN32_WCE
+		FORWARD_NOTIFICATIONS()
+	ALT_MSG_MAP(1)   // tab control
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnTabLButtonDown)
+		MESSAGE_HANDLER(WM_LBUTTONUP, OnTabLButtonUp)
+		MESSAGE_HANDLER(WM_CAPTURECHANGED, OnTabCaptureChanged)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, OnTabMouseMove)
+		MESSAGE_HANDLER(WM_RBUTTONUP, OnTabRButtonUp)
+		MESSAGE_HANDLER(WM_SYSKEYDOWN, OnTabSysKeyDown)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->CreateTabControl();
+
+		return 0;
+	}
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		RemoveAllPages();
+
+		if(m_bDestroyImageList)
+		{
+			CImageList il = m_tab.SetImageList(NULL);
+			if(il.m_hImageList != NULL)
+				il.Destroy();
+		}
+
+		if(m_bInternalFont)
+		{
+			HFONT hFont = m_tab.GetFont();
+			m_tab.SetFont(NULL, FALSE);
+			::DeleteObject(hFont);
+			m_bInternalFont = false;
+		}
+
+		return 0;
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout();
+		return 0;
+	}
+
+	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_nActivePage != -1)
+			::SetFocus(GetPageHWND(m_nActivePage));
+		return 0;
+	}
+
+	LRESULT OnGetFont(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return m_tab.SendMessage(WM_GETFONT);
+	}
+
+	LRESULT OnSetFont(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if(m_bInternalFont)
+		{
+			HFONT hFont = m_tab.GetFont();
+			m_tab.SetFont(NULL, FALSE);
+			::DeleteObject(hFont);
+			m_bInternalFont = false;
+		}
+
+		m_tab.SendMessage(WM_SETFONT, wParam, lParam);
+
+		T* pT = static_cast<T*>(this);
+		m_cyTabHeight = pT->CalcTabHeight();
+
+		if((BOOL)lParam != FALSE)
+			pT->UpdateLayout();
+
+		return 0;
+	}
+
+	LRESULT OnTabChanged(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
+	{
+		SetActivePage(m_tab.GetCurSel());
+		T* pT = static_cast<T*>(this);
+		pT->OnPageActivated(m_nActivePage);
+
+		return 0;
+	}
+
+	LRESULT OnTabNotification(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
+	{
+		// nothing to do - this just blocks all tab control
+		// notifications from being propagated further
+		return 0;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnTabGetDispInfo(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		LPNMTTDISPINFO pTTDI = (LPNMTTDISPINFO)pnmh;
+		if(pTTDI->hdr.hwndFrom == m_tab.GetTooltips())
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdateTooltipText(pTTDI);
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+
+		return 0;
+	}
+#endif // !_WIN32_WCE
+
+// Tab control message handlers
+	LRESULT OnTabLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(!m_bNoTabDrag && (m_tab.GetItemCount() > 1))
+		{
+			m_bTabCapture = true;
+			m_tab.SetCapture();
+
+			m_ptStartDrag.x = GET_X_LPARAM(lParam);
+			m_ptStartDrag.y = GET_Y_LPARAM(lParam);
+		}
+
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnTabLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(m_bTabCapture)
+		{
+			if(m_bTabDrag)
+			{
+				TCHITTESTINFO hti = { 0 };
+				hti.pt.x = GET_X_LPARAM(lParam);
+				hti.pt.y = GET_Y_LPARAM(lParam);
+				int nItem = m_tab.HitTest(&hti);
+				if(nItem != -1)
+					MovePage(m_nActivePage, nItem);
+			}
+
+			::ReleaseCapture();
+		}
+
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnTabCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_bTabCapture)
+		{
+			m_bTabCapture = false;
+
+			if(m_bTabDrag)
+			{
+				m_bTabDrag = false;
+				T* pT = static_cast<T*>(this);
+				pT->DrawMoveMark(-1);
+
+#ifndef _WIN32_WCE
+				m_ilDrag.DragLeave(GetDesktopWindow());
+#endif // !_WIN32_WCE
+				m_ilDrag.EndDrag();
+
+				m_ilDrag.Destroy();
+				m_ilDrag.m_hImageList = NULL;
+			}
+		}
+
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnTabMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+
+		if(m_bTabCapture)
+		{
+			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+
+			if(!m_bTabDrag)
+			{
+#ifndef _WIN32_WCE
+				if(abs(m_ptStartDrag.x - GET_X_LPARAM(lParam)) >= ::GetSystemMetrics(SM_CXDRAG) ||
+				   abs(m_ptStartDrag.y - GET_Y_LPARAM(lParam)) >= ::GetSystemMetrics(SM_CYDRAG))
+#else // CE specific
+				if(abs(m_ptStartDrag.x - GET_X_LPARAM(lParam)) >= 4 ||
+				   abs(m_ptStartDrag.y - GET_Y_LPARAM(lParam)) >= 4)
+#endif // _WIN32_WCE
+				{
+					T* pT = static_cast<T*>(this);
+					pT->GenerateDragImage(m_nActivePage);
+
+					int cxCursor = ::GetSystemMetrics(SM_CXCURSOR);
+					int cyCursor = ::GetSystemMetrics(SM_CYCURSOR);
+					m_ilDrag.BeginDrag(0, -(cxCursor / 2), -(cyCursor / 2));
+#ifndef _WIN32_WCE
+					POINT ptEnter = m_ptStartDrag;
+					m_tab.ClientToScreen(&ptEnter);
+					m_ilDrag.DragEnter(GetDesktopWindow(), ptEnter);
+#endif // !_WIN32_WCE
+
+					m_bTabDrag = true;
+				}
+			}
+
+			if(m_bTabDrag)
+			{
+				TCHITTESTINFO hti = { 0 };
+				hti.pt = pt;
+				int nItem = m_tab.HitTest(&hti);
+
+				T* pT = static_cast<T*>(this);
+				pT->SetMoveCursor(nItem != -1);
+
+				if(m_nInsertItem != nItem)
+					pT->DrawMoveMark(nItem);
+
+				m_ilDrag.DragShowNolock((nItem != -1) ? TRUE : FALSE);
+				m_tab.ClientToScreen(&pt);
+				m_ilDrag.DragMove(pt);
+
+				bHandled = TRUE;
+			}
+		}
+
+		return 0;
+	}
+
+	LRESULT OnTabRButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		TCHITTESTINFO hti = { 0 };
+		hti.pt.x = GET_X_LPARAM(lParam);
+		hti.pt.y = GET_Y_LPARAM(lParam);
+		int nItem = m_tab.HitTest(&hti);
+		if(nItem != -1)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->OnContextMenu(nItem, hti.pt);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnTabSysKeyDown(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		bool bShift = (::GetKeyState(VK_SHIFT) < 0);
+		if(wParam == VK_F10 && bShift)
+		{
+			if(m_nActivePage != -1)
+			{
+				RECT rect = { 0 };
+				m_tab.GetItemRect(m_nActivePage, &rect);
+				POINT pt = { rect.left, rect.bottom };
+				T* pT = static_cast<T*>(this);
+				pT->OnContextMenu(m_nActivePage, pt);
+			}
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+
+		return 0;
+	}
+
+// Implementation helpers
+	bool IsValidPageIndex(int nPage) const
+	{
+		return (nPage >= 0 && nPage < GetPageCount());
+	}
+
+	bool MovePage(int nMovePage, int nInsertBeforePage)
+	{
+		ATLASSERT(IsValidPageIndex(nMovePage));
+		ATLASSERT(IsValidPageIndex(nInsertBeforePage));
+
+		if(!IsValidPageIndex(nMovePage) || !IsValidPageIndex(nInsertBeforePage))
+			return false;
+
+		if(nMovePage == nInsertBeforePage)
+			return true;   // nothing to do
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpstrTabText = buff.Allocate(m_cchTabTextLength + 1);
+		if(lpstrTabText == NULL)
+			return false;
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_TEXT | TCIF_IMAGE | TCIF_PARAM;
+		tcix.tciheader.pszText = lpstrTabText;
+		tcix.tciheader.cchTextMax = m_cchTabTextLength + 1;
+		BOOL bRet = m_tab.GetItem(nMovePage, tcix);
+		ATLASSERT(bRet != FALSE);
+		if(bRet == FALSE)
+			return false;
+
+		int nInsertItem = (nInsertBeforePage > nMovePage) ? nInsertBeforePage + 1 : nInsertBeforePage;
+		int nNewItem = m_tab.InsertItem(nInsertItem, tcix);
+		ATLASSERT(nNewItem == nInsertItem);
+		if(nNewItem != nInsertItem)
+		{
+			ATLVERIFY(m_tab.DeleteItem(nNewItem));
+			return false;
+		}
+
+		if(nMovePage > nInsertBeforePage)
+			ATLVERIFY(m_tab.DeleteItem(nMovePage + 1) != FALSE);
+		else if(nMovePage < nInsertBeforePage)
+			ATLVERIFY(m_tab.DeleteItem(nMovePage) != FALSE);
+
+		SetActivePage(nInsertBeforePage);
+		T* pT = static_cast<T*>(this);
+		pT->OnPageActivated(m_nActivePage);
+
+		return true;
+	}
+
+// Implementation overrideables
+	bool CreateTabControl()
+	{
+#ifndef _WIN32_WCE
+		m_tab.Create(m_hWnd, rcDefault, NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN | TCS_TOOLTIPS, 0, m_nTabID);
+#else // CE specific
+		m_tab.Create(m_hWnd, rcDefault, NULL, WS_CHILD | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, 0, m_nTabID);
+#endif // _WIN32_WCE
+		ATLASSERT(m_tab.m_hWnd != NULL);
+		if(m_tab.m_hWnd == NULL)
+			return false;
+
+		m_tab.SetFont(AtlCreateControlFont());
+		m_bInternalFont = true;
+
+		m_tab.SetItemExtra(sizeof(TABVIEWPAGE));
+
+		T* pT = static_cast<T*>(this);
+		m_cyTabHeight = pT->CalcTabHeight();
+
+		return true;
+	}
+
+	int CalcTabHeight()
+	{
+		int nCount = m_tab.GetItemCount();
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_TEXT;
+		tcix.tciheader.pszText = _T("NS");
+		int nIndex = m_tab.InsertItem(nCount, tcix);
+
+		RECT rect = { 0, 0, 1000, 1000 };
+		m_tab.AdjustRect(FALSE, &rect);
+
+		RECT rcWnd = { 0, 0, 1000, rect.top };
+		::AdjustWindowRectEx(&rcWnd, m_tab.GetStyle(), FALSE, m_tab.GetExStyle());
+
+		int nHeight = rcWnd.bottom - rcWnd.top;
+
+		m_tab.DeleteItem(nIndex);
+
+		return nHeight;
+	}
+
+	void ShowTabControl(bool bShow)
+	{
+		m_tab.ShowWindow(bShow ? SW_SHOWNOACTIVATE : SW_HIDE);
+	}
+
+	void UpdateLayout()
+	{
+		RECT rect;
+		GetClientRect(&rect);
+
+		if(m_tab.IsWindow() && ((m_tab.GetStyle() & WS_VISIBLE) != 0))
+			m_tab.SetWindowPos(NULL, 0, 0, rect.right - rect.left, m_cyTabHeight, SWP_NOZORDER);
+
+		if(m_nActivePage != -1)
+			::SetWindowPos(GetPageHWND(m_nActivePage), NULL, 0, m_cyTabHeight, rect.right - rect.left, rect.bottom - rect.top - m_cyTabHeight, SWP_NOZORDER);
+	}
+
+	void UpdateMenu()
+	{
+		if(m_menu.m_hMenu != NULL)
+			BuildWindowMenu(m_menu, m_nMenuItemsCount, m_bEmptyMenuItem, m_bWindowsMenuItem, m_bActivePageMenuItem, m_bActiveAsDefaultMenuItem);
+	}
+
+	void UpdateTitleBar()
+	{
+		if(!m_wndTitleBar.IsWindow() || m_lpstrTitleBarBase == NULL)
+			return;   // nothing to do
+
+		if(m_nActivePage != -1)
+		{
+			T* pT = static_cast<T*>(this);
+			LPCTSTR lpstrTitle = pT->GetPageTitle(m_nActivePage);
+			LPCTSTR lpstrDivider = pT->GetTitleDividerText();
+			int cchBuffer = m_cchTitleBarLength + lstrlen(lpstrDivider) + lstrlen(m_lpstrTitleBarBase) + 1;
+			CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+			LPTSTR lpstrPageTitle = buff.Allocate(cchBuffer);
+			ATLASSERT(lpstrPageTitle != NULL);
+			if(lpstrPageTitle != NULL)
+			{
+				pT->ShortenTitle(lpstrTitle, lpstrPageTitle, m_cchTitleBarLength + 1);
+				SecureHelper::strcat_x(lpstrPageTitle, cchBuffer, lpstrDivider);
+				SecureHelper::strcat_x(lpstrPageTitle, cchBuffer, m_lpstrTitleBarBase);
+			}
+			else
+			{
+				lpstrPageTitle = m_lpstrTitleBarBase;
+			}
+
+			m_wndTitleBar.SetWindowText(lpstrPageTitle);
+		}
+		else
+		{
+			m_wndTitleBar.SetWindowText(m_lpstrTitleBarBase);
+		}
+	}
+
+	void DrawMoveMark(int nItem)
+	{
+		T* pT = static_cast<T*>(this);
+
+		if(m_nInsertItem != -1)
+		{
+			RECT rect = { 0 };
+			pT->GetMoveMarkRect(rect);
+			m_tab.InvalidateRect(&rect);
+		}
+
+		m_nInsertItem = nItem;
+
+		if(m_nInsertItem != -1)
+		{
+			CClientDC dc(m_tab.m_hWnd);
+
+			RECT rect = { 0 };
+			pT->GetMoveMarkRect(rect);
+
+			CPen pen;
+			pen.CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_WINDOWTEXT));
+			CBrush brush;
+			brush.CreateSolidBrush(::GetSysColor(COLOR_WINDOWTEXT));
+
+			HPEN hPenOld = dc.SelectPen(pen);
+			HBRUSH hBrushOld = dc.SelectBrush(brush);
+
+			int x = rect.left;
+			int y = rect.top;
+			POINT ptsTop[3] = { { x, y }, { x + m_cxMoveMark, y }, { x + (m_cxMoveMark / 2), y + m_cyMoveMark } };
+			dc.Polygon(ptsTop, 3);
+
+			y = rect.bottom - 1;
+			POINT ptsBottom[3] = { { x, y }, { x + m_cxMoveMark, y }, { x + (m_cxMoveMark / 2), y - m_cyMoveMark } };
+			dc.Polygon(ptsBottom, 3);
+
+			dc.SelectPen(hPenOld);
+			dc.SelectBrush(hBrushOld);
+		}
+	}
+
+	void GetMoveMarkRect(RECT& rect) const
+	{
+		m_tab.GetClientRect(&rect);
+
+		RECT rcItem = { 0 };
+		m_tab.GetItemRect(m_nInsertItem, &rcItem);
+
+		if(m_nInsertItem <= m_nActivePage)
+		{
+			rect.left = rcItem.left - m_cxMoveMark / 2 - 1;
+			rect.right = rcItem.left + m_cxMoveMark / 2;
+		}
+		else
+		{
+			rect.left = rcItem.right - m_cxMoveMark / 2 - 1;
+			rect.right = rcItem.right + m_cxMoveMark / 2;
+		}
+	}
+
+	void SetMoveCursor(bool bCanMove)
+	{
+		::SetCursor(::LoadCursor(NULL, bCanMove ? IDC_ARROW : IDC_NO));
+	}
+
+	void GenerateDragImage(int nItem)
+	{
+		ATLASSERT(IsValidPageIndex(nItem));
+
+#ifndef _WIN32_WCE
+		RECT rcItem = { 0 };
+		m_tab.GetItemRect(nItem, &rcItem);
+		::InflateRect(&rcItem, 2, 2);   // make bigger to cover selected item
+#else // CE specific
+		nItem;   // avoid level 4 warning
+		RECT rcItem = { 0, 0, 40, 20 };
+#endif // _WIN32_WCE
+
+		ATLASSERT(m_ilDrag.m_hImageList == NULL);
+		m_ilDrag.Create(rcItem.right - rcItem.left, rcItem.bottom - rcItem.top, ILC_COLORDDB | ILC_MASK, 1, 1);
+
+		CClientDC dc(m_hWnd);
+		CDC dcMem;
+		dcMem.CreateCompatibleDC(dc);
+		ATLASSERT(dcMem.m_hDC != NULL);
+		dcMem.SetViewportOrg(-rcItem.left, -rcItem.top);
+
+		CBitmap bmp;
+		bmp.CreateCompatibleBitmap(dc, rcItem.right - rcItem.left, rcItem.bottom - rcItem.top);
+		ATLASSERT(bmp.m_hBitmap != NULL);
+
+		HBITMAP hBmpOld = dcMem.SelectBitmap(bmp);
+#ifndef _WIN32_WCE
+		m_tab.SendMessage(WM_PRINTCLIENT, (WPARAM)dcMem.m_hDC);
+#else // CE specific
+		dcMem.Rectangle(&rcItem);
+#endif // _WIN32_WCE
+		dcMem.SelectBitmap(hBmpOld);
+
+		ATLVERIFY(m_ilDrag.Add(bmp.m_hBitmap, RGB(255, 0, 255)) != -1);
+	}
+
+	void ShortenTitle(LPCTSTR lpstrTitle, LPTSTR lpstrShortTitle, int cchShortTitle)
+	{
+		if(lstrlen(lpstrTitle) >= cchShortTitle)
+		{
+			LPCTSTR lpstrEllipsis = _T("...");
+			int cchEllipsis = lstrlen(lpstrEllipsis);
+			SecureHelper::strncpy_x(lpstrShortTitle, cchShortTitle, lpstrTitle, cchShortTitle - cchEllipsis - 1);
+			SecureHelper::strcat_x(lpstrShortTitle, cchShortTitle, lpstrEllipsis);
+		}
+		else
+		{
+			SecureHelper::strcpy_x(lpstrShortTitle, cchShortTitle, lpstrTitle);
+		}
+	}
+
+#ifndef _WIN32_WCE
+	void UpdateTooltipText(LPNMTTDISPINFO pTTDI)
+	{
+		ATLASSERT(pTTDI != NULL);
+		pTTDI->lpszText = (LPTSTR)GetPageTitle((int)pTTDI->hdr.idFrom);
+	}
+#endif // !_WIN32_WCE
+
+// Text for menu items and title bar - override to provide different strings
+	static LPCTSTR GetEmptyListText()
+	{
+		return _T("(Empty)");
+	}
+
+	static LPCTSTR GetWindowsMenuItemText()
+	{
+		return _T("&Windows...");
+	}
+
+	static LPCTSTR GetTitleDividerText()
+	{
+		return _T(" - ");
+	}
+
+// Notifications - override to provide different behavior
+	void OnPageActivated(int nPage)
+	{
+		NMHDR nmhdr = { 0 };
+		nmhdr.hwndFrom = m_hWnd;
+		nmhdr.idFrom = nPage;
+		nmhdr.code = TBVN_PAGEACTIVATED;
+		::SendMessage(GetParent(), WM_NOTIFY, GetDlgCtrlID(), (LPARAM)&nmhdr);
+	}
+
+	void OnContextMenu(int nPage, POINT pt)
+	{
+		m_tab.ClientToScreen(&pt);
+
+		TBVCONTEXTMENUINFO cmi = { 0 };
+		cmi.hdr.hwndFrom = m_hWnd;
+		cmi.hdr.idFrom = nPage;
+		cmi.hdr.code = TBVN_CONTEXTMENU;
+		cmi.pt = pt;
+		::SendMessage(GetParent(), WM_NOTIFY, GetDlgCtrlID(), (LPARAM)&cmi);
+	}
+};
+
+class CTabView : public CTabViewImpl<CTabView>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_TabView"), 0, COLOR_APPWORKSPACE)
+};
+
+}; // namespace WTL
+
+#endif // __ATLCTRLX_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlddx.h b/GLideN64/src/GLideNUI-wtl/WTL/atlddx.h
new file mode 100644
index 00000000..2d54ca52
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlddx.h
@@ -0,0 +1,685 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLDDX_H__
+#define __ATLDDX_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlddx.h requires atlapp.h to be included first
+#endif
+
+#if defined(_ATL_USE_DDX_FLOAT) && defined(_ATL_MIN_CRT)
+	#error Cannot use floating point DDX with _ATL_MIN_CRT defined
+#endif // defined(_ATL_USE_DDX_FLOAT) && defined(_ATL_MIN_CRT)
+
+#ifdef _ATL_USE_DDX_FLOAT
+  #include <float.h>
+#endif // _ATL_USE_DDX_FLOAT
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CWinDataExchange<T>
+
+
+namespace WTL
+{
+
+// Constants
+#define DDX_LOAD	FALSE
+#define DDX_SAVE	TRUE
+
+// DDX map macros
+#define BEGIN_DDX_MAP(thisClass) \
+	BOOL DoDataExchange(BOOL bSaveAndValidate = FALSE, UINT nCtlID = (UINT)-1) \
+	{ \
+		bSaveAndValidate; \
+		nCtlID;
+
+#define DDX_TEXT(nID, var) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Text(nID, var, sizeof(var), bSaveAndValidate)) \
+				return FALSE; \
+		}
+
+#define DDX_TEXT_LEN(nID, var, len) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Text(nID, var, sizeof(var), bSaveAndValidate, TRUE, len)) \
+				return FALSE; \
+		}
+
+#define DDX_INT(nID, var) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Int(nID, var, TRUE, bSaveAndValidate)) \
+				return FALSE; \
+		}
+
+#define DDX_INT_RANGE(nID, var, min, max) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Int(nID, var, TRUE, bSaveAndValidate, TRUE, min, max)) \
+				return FALSE; \
+		}
+
+#define DDX_UINT(nID, var) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Int(nID, var, FALSE, bSaveAndValidate)) \
+				return FALSE; \
+		}
+
+#define DDX_UINT_RANGE(nID, var, min, max) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Int(nID, var, FALSE, bSaveAndValidate, TRUE, min, max)) \
+				return FALSE; \
+		}
+
+#ifdef _ATL_USE_DDX_FLOAT
+#define DDX_FLOAT(nID, var) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Float(nID, var, bSaveAndValidate)) \
+				return FALSE; \
+		}
+
+#define DDX_FLOAT_RANGE(nID, var, min, max) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Float(nID, var, bSaveAndValidate, TRUE, min, max)) \
+				return FALSE; \
+		}
+#define DDX_FLOAT_P(nID, var, precision) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Float(nID, var, bSaveAndValidate, FALSE, 0, 0, precision)) \
+				return FALSE; \
+		}
+
+#define DDX_FLOAT_P_RANGE(nID, var, min, max, precision) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		{ \
+			if(!DDX_Float(nID, var, bSaveAndValidate, TRUE, min, max, precision)) \
+				return FALSE; \
+		}
+#endif // _ATL_USE_DDX_FLOAT
+
+#define DDX_CONTROL(nID, obj) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+			DDX_Control(nID, obj, bSaveAndValidate);
+
+#define DDX_CONTROL_HANDLE(nID, obj) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+			DDX_Control_Handle(nID, obj, bSaveAndValidate);
+
+#define DDX_CHECK(nID, var) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+			DDX_Check(nID, var, bSaveAndValidate);
+
+#define DDX_RADIO(nID, var) \
+		if(nCtlID == (UINT)-1 || nCtlID == nID) \
+			DDX_Radio(nID, var, bSaveAndValidate);
+
+#define END_DDX_MAP() \
+		return TRUE; \
+	}
+
+// DDX support for Tab, Combo, ListBox and ListView selection index
+// Note: Specialized versions require atlctrls.h to be included first
+#if (_MSC_VER >= 1300)
+
+#define DDX_INDEX(CtrlClass, nID, var) \
+	if(nCtlID == (UINT)-1 || nCtlID == nID) \
+		DDX_Index<CtrlClass>(nID, var, bSaveAndValidate);
+
+#ifdef __ATLCTRLS_H__
+  #define DDX_TAB_INDEX(nID, var)      DDX_INDEX(WTL::CTabCtrl, nID, var)
+  #define DDX_COMBO_INDEX(nID, var)    DDX_INDEX(WTL::CComboBox, nID, var)
+  #define DDX_LISTBOX_INDEX(nID, var)  DDX_INDEX(WTL::CListBox, nID, var)
+  #define DDX_LISTVIEW_INDEX(nID, var) DDX_INDEX(WTL::CListViewCtrl, nID, var)
+#endif // __ATLCTRLS_H__
+
+#endif // (_MSC_VER >= 1300)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWinDataExchange - provides support for DDX
+
+template <class T>
+class CWinDataExchange
+{
+public:
+// Data exchange method - override in your derived class
+	BOOL DoDataExchange(BOOL /*bSaveAndValidate*/ = FALSE, UINT /*nCtlID*/ = (UINT)-1)
+	{
+		// this one should never be called, override it in
+		// your derived class by implementing DDX map
+		ATLASSERT(FALSE);
+		return FALSE;
+	}
+
+// Helpers for validation error reporting
+	enum _XDataType
+	{
+		ddxDataNull = 0,
+		ddxDataText = 1,
+		ddxDataInt = 2,
+		ddxDataFloat = 3,
+		ddxDataDouble = 4
+	};
+
+	struct _XTextData
+	{
+		int nLength;
+		int nMaxLength;
+	};
+
+	struct _XIntData
+	{
+		long nVal;
+		long nMin;
+		long nMax;
+	};
+
+	struct _XFloatData
+	{
+		double nVal;
+		double nMin;
+		double nMax;
+	};
+
+	struct _XData
+	{
+		_XDataType nDataType;
+		union
+		{
+			_XTextData textData;
+			_XIntData intData;
+			_XFloatData floatData;
+		};
+	};
+
+// Text exchange
+	BOOL DDX_Text(UINT nID, LPTSTR lpstrText, int cbSize, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+
+		if(bSave)
+		{
+			HWND hWndCtrl = pT->GetDlgItem(nID);
+			int nRetLen = ::GetWindowText(hWndCtrl, lpstrText, cbSize / sizeof(TCHAR));
+			if(nRetLen < ::GetWindowTextLength(hWndCtrl))
+				bSuccess = FALSE;
+		}
+		else
+		{
+			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
+			bSuccess = pT->SetDlgItemText(nID, lpstrText);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nLength > 0);
+			if(lstrlen(lpstrText) > nLength)
+			{
+				_XData data = { ddxDataText };
+				data.textData.nLength = lstrlen(lpstrText);
+				data.textData.nMaxLength = nLength;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+
+	BOOL DDX_Text(UINT nID, BSTR& bstrText, int /*cbSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+
+		if(bSave)
+		{
+			bSuccess = pT->GetDlgItemText(nID, bstrText);
+		}
+		else
+		{
+			USES_CONVERSION;
+			LPTSTR lpstrText = OLE2T(bstrText);
+			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
+			bSuccess = pT->SetDlgItemText(nID, lpstrText);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nLength > 0);
+			if((int)::SysStringLen(bstrText) > nLength)
+			{
+				_XData data = { ddxDataText };
+				data.textData.nLength = (int)::SysStringLen(bstrText);
+				data.textData.nMaxLength = nLength;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+
+	BOOL DDX_Text(UINT nID, ATL::CComBSTR& bstrText, int /*cbSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+
+		if(bSave)
+		{
+			bSuccess = pT->GetDlgItemText(nID, (BSTR&)bstrText);
+		}
+		else
+		{
+			USES_CONVERSION;
+			LPTSTR lpstrText = OLE2T(bstrText);
+			ATLASSERT(!bValidate || lstrlen(lpstrText) <= nLength);
+			bSuccess = pT->SetDlgItemText(nID, lpstrText);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nLength > 0);
+			if((int)bstrText.Length() > nLength)
+			{
+				_XData data = { ddxDataText };
+				data.textData.nLength = (int)bstrText.Length();
+				data.textData.nMaxLength = nLength;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	BOOL DDX_Text(UINT nID, _CSTRING_NS::CString& strText, int /*cbSize*/, BOOL bSave, BOOL bValidate = FALSE, int nLength = 0)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+
+		if(bSave)
+		{
+			HWND hWndCtrl = pT->GetDlgItem(nID);
+			int nLen = ::GetWindowTextLength(hWndCtrl);
+			int nRetLen = -1;
+			LPTSTR lpstr = strText.GetBufferSetLength(nLen);
+			if(lpstr != NULL)
+			{
+				nRetLen = ::GetWindowText(hWndCtrl, lpstr, nLen + 1);
+				strText.ReleaseBuffer();
+			}
+			if(nRetLen < nLen)
+				bSuccess = FALSE;
+		}
+		else
+		{
+			bSuccess = pT->SetDlgItemText(nID, strText);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nLength > 0);
+			if(strText.GetLength() > nLength)
+			{
+				_XData data = { ddxDataText };
+				data.textData.nLength = strText.GetLength();
+				data.textData.nMaxLength = nLength;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+// Numeric exchange
+	template <class Type>
+	BOOL DDX_Int(UINT nID, Type& nVal, BOOL bSigned, BOOL bSave, BOOL bValidate = FALSE, Type nMin = 0, Type nMax = 0)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+
+		if(bSave)
+		{
+			nVal = (Type)pT->GetDlgItemInt(nID, &bSuccess, bSigned);
+		}
+		else
+		{
+			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
+			bSuccess = pT->SetDlgItemInt(nID, nVal, bSigned);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nMin != nMax);
+			if(nVal < nMin || nVal > nMax)
+			{
+				_XData data = { ddxDataInt };
+				data.intData.nVal = (long)nVal;
+				data.intData.nMin = (long)nMin;
+				data.intData.nMax = (long)nMax;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+
+// Float exchange
+#ifdef _ATL_USE_DDX_FLOAT
+	static BOOL _AtlSimpleFloatParse(LPCTSTR lpszText, double& d)
+	{
+		ATLASSERT(lpszText != NULL);
+		while (*lpszText == _T(' ') || *lpszText == _T('\t'))
+			lpszText++;
+
+		TCHAR chFirst = lpszText[0];
+		d = _tcstod(lpszText, (LPTSTR*)&lpszText);
+		if (d == 0.0 && chFirst != _T('0'))
+			return FALSE;   // could not convert
+		while (*lpszText == _T(' ') || *lpszText == _T('\t'))
+			lpszText++;
+
+		if (*lpszText != _T('\0'))
+			return FALSE;   // not terminated properly
+
+		return TRUE;
+	}
+
+	BOOL DDX_Float(UINT nID, float& nVal, BOOL bSave, BOOL bValidate = FALSE, float nMin = 0.F, float nMax = 0.F, int nPrecision = FLT_DIG)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+		const int cchBuff = 32;
+		TCHAR szBuff[cchBuff] = { 0 };
+
+		if(bSave)
+		{
+			pT->GetDlgItemText(nID, szBuff, cchBuff);
+			double d = 0;
+			if(_AtlSimpleFloatParse(szBuff, d))
+				nVal = (float)d;
+			else
+				bSuccess = FALSE;
+		}
+		else
+		{
+			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
+			SecureHelper::sprintf_x(szBuff, cchBuff, _T("%.*g"), nPrecision, nVal);
+			bSuccess = pT->SetDlgItemText(nID, szBuff);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nMin != nMax);
+			if(nVal < nMin || nVal > nMax)
+			{
+				_XData data = { ddxDataFloat };
+				data.floatData.nVal = (double)nVal;
+				data.floatData.nMin = (double)nMin;
+				data.floatData.nMax = (double)nMax;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+
+	BOOL DDX_Float(UINT nID, double& nVal, BOOL bSave, BOOL bValidate = FALSE, double nMin = 0., double nMax = 0., int nPrecision = DBL_DIG)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bSuccess = TRUE;
+		const int cchBuff = 32;
+		TCHAR szBuff[cchBuff] = { 0 };
+
+		if(bSave)
+		{
+			pT->GetDlgItemText(nID, szBuff, cchBuff);
+			double d = 0;
+			if(_AtlSimpleFloatParse(szBuff, d))
+				nVal = d;
+			else
+				bSuccess = FALSE;
+		}
+		else
+		{
+			ATLASSERT(!bValidate || nVal >= nMin && nVal <= nMax);
+			SecureHelper::sprintf_x(szBuff, cchBuff, _T("%.*g"), nPrecision, nVal);
+			bSuccess = pT->SetDlgItemText(nID, szBuff);
+		}
+
+		if(!bSuccess)
+		{
+			pT->OnDataExchangeError(nID, bSave);
+		}
+		else if(bSave && bValidate)   // validation
+		{
+			ATLASSERT(nMin != nMax);
+			if(nVal < nMin || nVal > nMax)
+			{
+				_XData data = { ddxDataFloat };
+				data.floatData.nVal = nVal;
+				data.floatData.nMin = nMin;
+				data.floatData.nMax = nMax;
+				pT->OnDataValidateError(nID, bSave, data);
+				bSuccess = FALSE;
+			}
+		}
+		return bSuccess;
+	}
+#endif // _ATL_USE_DDX_FLOAT
+
+// Full control subclassing (for CWindowImpl derived controls)
+	template <class TControl>
+	void DDX_Control(UINT nID, TControl& ctrl, BOOL bSave)
+	{
+		if(!bSave && ctrl.m_hWnd == NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			ctrl.SubclassWindow(pT->GetDlgItem(nID));
+		}
+	}
+
+// Simple control attaching (for HWND wrapper controls)
+	template <class TControl>
+	void DDX_Control_Handle(UINT nID, TControl& ctrl, BOOL bSave)
+	{
+		if(!bSave && ctrl.m_hWnd == NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			ctrl = pT->GetDlgItem(nID);
+		}
+	}
+
+// Control state
+	void DDX_Check(UINT nID, int& nValue, BOOL bSave)
+	{
+		T* pT = static_cast<T*>(this);
+		HWND hWndCtrl = pT->GetDlgItem(nID);
+		if(bSave)
+		{
+			nValue = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
+			ATLASSERT(nValue >= 0 && nValue <= 2);
+		}
+		else
+		{
+			if(nValue < 0 || nValue > 2)
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ATL: Warning - dialog data checkbox value (%d) out of range.\n"), nValue);
+				nValue = 0;  // default to off
+			}
+			::SendMessage(hWndCtrl, BM_SETCHECK, nValue, 0L);
+		}
+	}
+
+	// variant that supports bool (checked/not-checked, no intermediate state)
+	void DDX_Check(UINT nID, bool& bCheck, BOOL bSave)
+	{
+		int nValue = bCheck ? 1 : 0;
+		DDX_Check(nID, nValue, bSave);
+
+		if(bSave)
+		{
+			if(nValue == 2)
+				ATLTRACE2(atlTraceUI, 0, _T("ATL: Warning - checkbox state (%d) out of supported range.\n"), nValue);
+			bCheck = (nValue == 1);
+		}
+	}
+
+	void DDX_Radio(UINT nID, int& nValue, BOOL bSave)
+	{
+		T* pT = static_cast<T*>(this);
+		HWND hWndCtrl = pT->GetDlgItem(nID);
+		ATLASSERT(hWndCtrl != NULL);
+
+		// must be first in a group of auto radio buttons
+		ATLASSERT(::GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP);
+		ATLASSERT(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON);
+
+		if(bSave)
+			nValue = -1;     // value if none found
+
+		// walk all children in group
+		int nButton = 0;
+		do
+		{
+			if(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON)
+			{
+				// control in group is a radio button
+				if(bSave)
+				{
+					if(::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L) != 0)
+					{
+						ATLASSERT(nValue == -1);    // only set once
+						nValue = nButton;
+					}
+				}
+				else
+				{
+					// select button
+					::SendMessage(hWndCtrl, BM_SETCHECK, (nButton == nValue), 0L);
+				}
+				nButton++;
+			}
+			else
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ATL: Warning - skipping non-radio button in group.\n"));
+			}
+			hWndCtrl = ::GetWindow(hWndCtrl, GW_HWNDNEXT);
+		}
+		while (hWndCtrl != NULL && !(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP));
+	}
+
+// DDX support for Tab, Combo, ListBox and ListView selection index
+#if (_MSC_VER >= 1300)
+	template <class TCtrl>
+	INT _getSel(TCtrl& tCtrl)
+	{
+		return tCtrl.GetCurSel();
+	}
+
+	template <class TCtrl>
+	void _setSel(TCtrl& tCtrl, INT iSel)
+	{
+		if(iSel < 0)
+			tCtrl.SetCurSel(-1);
+		else
+			tCtrl.SetCurSel(iSel);
+	}
+
+#ifdef __ATLCTRLS_H__
+	// ListViewCtrl specialization
+	template <>
+	INT _getSel(WTL::CListViewCtrl& tCtrl)
+	{
+		return tCtrl.GetSelectedIndex();
+	}
+
+	template <>
+	void _setSel(WTL::CListViewCtrl& tCtrl, INT iSel)
+	{
+		if(iSel < 0)
+			tCtrl.SelectItem(-1);
+		else
+			tCtrl.SelectItem(iSel);
+	}
+#endif // __ATLCTRLS_H__
+
+	template <class TCtrl>
+	void DDX_Index(UINT nID, INT& nVal, BOOL bSave)
+	{
+		T* pT = static_cast<T*>(this);
+		TCtrl ctrl(pT->GetDlgItem(nID));
+
+		if(bSave)
+			nVal = _getSel(ctrl);
+		else
+			_setSel(ctrl, nVal);
+	}
+#endif // (_MSC_VER >= 1300)
+
+// Overrideables
+	void OnDataExchangeError(UINT nCtrlID, BOOL /*bSave*/)
+	{
+		// Override to display an error message
+		::MessageBeep((UINT)-1);
+		T* pT = static_cast<T*>(this);
+		::SetFocus(pT->GetDlgItem(nCtrlID));
+	}
+
+	void OnDataValidateError(UINT nCtrlID, BOOL /*bSave*/, _XData& /*data*/)
+	{
+		// Override to display an error message
+		::MessageBeep((UINT)-1);
+		T* pT = static_cast<T*>(this);
+		::SetFocus(pT->GetDlgItem(nCtrlID));
+	}
+};
+
+}; // namespace WTL
+
+#endif // __ATLDDX_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atldlgs.h b/GLideN64/src/GLideNUI-wtl/WTL/atldlgs.h
new file mode 100644
index 00000000..7923b951
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atldlgs.h
@@ -0,0 +1,6386 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLDLGS_H__
+#define __ATLDLGS_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atldlgs.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atldlgs.h requires atlwin.h to be included first
+#endif
+
+#include <commdlg.h>
+#include <shlobj.h>
+
+#if (_WIN32_WINNT >= 0x0600) && !defined(_WIN32_WCE)
+  #include <shobjidl.h>
+#endif // (_WIN32_WINNT >= 0x0600) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CFileDialogImpl<T>
+// CFileDialog
+// CFileDialogEx
+// CMultiFileDialogImpl<T>
+// CMultiFileDialog
+// CShellFileDialogImpl<T>
+// CShellFileOpenDialogImpl<T>
+// CShellFileOpenDialog
+// CShellFileSaveDialogImpl<T>
+// CShellFileSaveDialog
+// CFolderDialogImpl<T>
+// CFolderDialog
+// CFontDialogImpl<T>
+// CFontDialog
+// CRichEditFontDialogImpl<T>
+// CRichEditFontDialog
+// CColorDialogImpl<T>
+// CColorDialog
+// CPrintDialogImpl<T>
+// CPrintDialog
+// CPrintDialogExImpl<T>
+// CPrintDialogEx
+// CPageSetupDialogImpl<T>
+// CPageSetupDialog
+// CFindReplaceDialogImpl<T>
+// CFindReplaceDialog
+//
+// CDialogBaseUnits
+// CMemDlgTemplate
+// CIndirectDialogImpl<T, TDlgTemplate, TBase>
+//
+// CPropertySheetWindow
+// CPropertySheetImpl<T, TBase>
+// CPropertySheet
+// CPropertyPageWindow
+// CPropertyPageImpl<T, TBase>
+// CPropertyPage<t_wDlgTemplateID>
+// CAxPropertyPageImpl<T, TBase>
+// CAxPropertyPage<t_wDlgTemplateID>
+//
+// CWizard97SheetWindow
+// CWizard97SheetImpl<T, TBase>
+// CWizard97Sheet
+// CWizard97PageWindow
+// CWizard97PageImpl<T, TBase>
+// CWizard97ExteriorPageImpl<T, TBase>
+// CWizard97InteriorPageImpl<T, TBase>
+//
+// CAeroWizardFrameWindow
+// CAeroWizardFrameImpl<T, TBase>
+// CAeroWizardFrame
+// CAeroWizardPageWindow
+// CAeroWizardPageImpl<T, TBase>
+// CAeroWizardPage<t_wDlgTemplateID>
+// CAeroWizardAxPageImpl<T, TBase>
+// CAeroWizardAxPage<t_wDlgTemplateID>
+//
+// CTaskDialogConfig
+// CTaskDialogImpl<T>
+// CTaskDialog
+//
+// Global functions:
+//   AtlTaskDialog()
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CFileDialogImpl - used for File Open or File Save As
+
+// compatibility with the old (vc6.0) headers
+#if (_WIN32_WINNT >= 0x0500) && !defined(OPENFILENAME_SIZE_VERSION_400)
+  #ifndef CDSIZEOF_STRUCT
+    #define CDSIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
+  #endif
+  #define OPENFILENAME_SIZE_VERSION_400A  CDSIZEOF_STRUCT(OPENFILENAMEA,lpTemplateName)
+  #define OPENFILENAME_SIZE_VERSION_400W  CDSIZEOF_STRUCT(OPENFILENAMEW,lpTemplateName)
+  #ifdef UNICODE
+    #define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400W
+  #else
+    #define OPENFILENAME_SIZE_VERSION_400  OPENFILENAME_SIZE_VERSION_400A
+  #endif // !UNICODE
+#endif // (_WIN32_WINNT >= 0x0500) && !defined(OPENFILENAME_SIZE_VERSION_400)
+
+#if !defined(_WIN32_WCE) && !defined(CDN_INCLUDEITEM)
+  #define CDN_INCLUDEITEM         (CDN_FIRST - 0x0007)
+#endif
+
+template <class T>
+class ATL_NO_VTABLE CFileDialogImpl : public ATL::CDialogImplBase
+{
+public:
+#if defined(__AYGSHELL_H__) && (_WIN32_WCE >= 0x0501)
+	OPENFILENAMEEX m_ofn;
+#else
+	OPENFILENAME m_ofn;
+#endif
+	BOOL m_bOpenFileDialog;            // TRUE for file open, FALSE for file save
+	TCHAR m_szFileTitle[_MAX_FNAME];   // contains file title after return
+	TCHAR m_szFileName[_MAX_PATH];     // contains full path name after return
+
+	CFileDialogImpl(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
+			LPCTSTR lpszDefExt = NULL,
+			LPCTSTR lpszFileName = NULL,
+			DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
+			LPCTSTR lpszFilter = NULL,
+			HWND hWndParent = NULL)
+	{
+		memset(&m_ofn, 0, sizeof(m_ofn)); // initialize structure to 0/NULL
+		m_szFileName[0] = _T('\0');
+		m_szFileTitle[0] = _T('\0');
+
+		m_bOpenFileDialog = bOpenFileDialog;
+
+#if defined(__AYGSHELL_H__) && (_WIN32_WCE >= 0x0501)
+		m_ofn.lStructSize = bOpenFileDialog ? sizeof(m_ofn) : sizeof(OPENFILENAME);
+#else
+		m_ofn.lStructSize = sizeof(m_ofn);
+#endif
+
+#if (_WIN32_WINNT >= 0x0500)
+		// adjust struct size if running on older version of Windows
+		if(AtlIsOldWindows())
+		{
+			ATLASSERT(sizeof(m_ofn) > OPENFILENAME_SIZE_VERSION_400);   // must be
+			m_ofn.lStructSize = OPENFILENAME_SIZE_VERSION_400;
+		}
+#endif // (_WIN32_WINNT >= 0x0500)
+		m_ofn.lpstrFile = m_szFileName;
+		m_ofn.nMaxFile = _MAX_PATH;
+		m_ofn.lpstrDefExt = lpszDefExt;
+		m_ofn.lpstrFileTitle = (LPTSTR)m_szFileTitle;
+		m_ofn.nMaxFileTitle = _MAX_FNAME;
+#ifndef _WIN32_WCE
+		m_ofn.Flags = dwFlags | OFN_EXPLORER | OFN_ENABLEHOOK | OFN_ENABLESIZING;
+#else // CE specific
+		m_ofn.Flags = dwFlags | OFN_EXPLORER | OFN_ENABLEHOOK;
+#endif // !_WIN32_WCE
+		m_ofn.lpstrFilter = lpszFilter;
+		m_ofn.hInstance = ModuleHelper::GetResourceInstance();
+		m_ofn.lpfnHook = (LPOFNHOOKPROC)T::StartDialogProc;
+		m_ofn.hwndOwner = hWndParent;
+
+		// setup initial file name
+		if(lpszFileName != NULL)
+		SecureHelper::strncpy_x(m_szFileName, _countof(m_szFileName), lpszFileName, _TRUNCATE);
+	}
+
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT((m_ofn.Flags & OFN_ENABLEHOOK) != 0);
+		ATLASSERT(m_ofn.lpfnHook != NULL);   // can still be a user hook
+
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		if(m_ofn.hwndOwner == NULL)   // set only if not specified before
+			m_ofn.hwndOwner = hWndParent;
+
+		ATLASSERT(m_hWnd == NULL);
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, (ATL::CDialogImplBase*)this);
+
+		BOOL bRet;
+		if(m_bOpenFileDialog)
+#if defined(__AYGSHELL_H__) && (_WIN32_WCE >= 0x0501)
+			bRet = ::GetOpenFileNameEx(&m_ofn);
+		else
+			bRet = ::GetSaveFileName((LPOPENFILENAME)&m_ofn);
+#else
+			bRet = ::GetOpenFileName(&m_ofn);
+		else
+			bRet = ::GetSaveFileName(&m_ofn);
+#endif
+
+		m_hWnd = NULL;
+
+		return bRet ? IDOK : IDCANCEL;
+	}
+
+// Attributes
+	ATL::CWindow GetFileDialogWindow() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ATL::CWindow(GetParent());
+	}
+
+	int GetFilePath(LPTSTR lpstrFilePath, int nLength) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		return (int)GetFileDialogWindow().SendMessage(CDM_GETFILEPATH, nLength, (LPARAM)lpstrFilePath);
+	}
+
+	int GetFolderIDList(LPVOID lpBuff, int nLength) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		return (int)GetFileDialogWindow().SendMessage(CDM_GETFOLDERIDLIST, nLength, (LPARAM)lpBuff);
+	}
+
+	int GetFolderPath(LPTSTR lpstrFolderPath, int nLength) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		return (int)GetFileDialogWindow().SendMessage(CDM_GETFOLDERPATH, nLength, (LPARAM)lpstrFolderPath);
+	}
+
+	int GetSpec(LPTSTR lpstrSpec, int nLength) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		return (int)GetFileDialogWindow().SendMessage(CDM_GETSPEC, nLength, (LPARAM)lpstrSpec);
+	}
+
+	void SetControlText(int nCtrlID, LPCTSTR lpstrText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		GetFileDialogWindow().SendMessage(CDM_SETCONTROLTEXT, nCtrlID, (LPARAM)lpstrText);
+	}
+
+	void SetDefExt(LPCTSTR lpstrExt)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		GetFileDialogWindow().SendMessage(CDM_SETDEFEXT, 0, (LPARAM)lpstrExt);
+	}
+
+	BOOL GetReadOnlyPref() const	// return TRUE if readonly checked
+	{
+		return ((m_ofn.Flags & OFN_READONLY) != 0) ? TRUE : FALSE;
+	}
+
+// Operations
+	void HideControl(int nCtrlID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((m_ofn.Flags & OFN_EXPLORER) != 0);
+
+		GetFileDialogWindow().SendMessage(CDM_HIDECONTROL, nCtrlID);
+	}
+
+// Special override for common dialogs
+	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		GetFileDialogWindow().SendMessage(WM_COMMAND, MAKEWPARAM(IDCANCEL, 0));
+		return TRUE;
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CFileDialogImpl)
+		NOTIFY_CODE_HANDLER(CDN_FILEOK, _OnFileOK)
+		NOTIFY_CODE_HANDLER(CDN_FOLDERCHANGE, _OnFolderChange)
+		NOTIFY_CODE_HANDLER(CDN_HELP, _OnHelp)
+		NOTIFY_CODE_HANDLER(CDN_INITDONE, _OnInitDone)
+		NOTIFY_CODE_HANDLER(CDN_SELCHANGE, _OnSelChange)
+		NOTIFY_CODE_HANDLER(CDN_SHAREVIOLATION, _OnShareViolation)
+		NOTIFY_CODE_HANDLER(CDN_TYPECHANGE, _OnTypeChange)
+#ifndef _WIN32_WCE
+		NOTIFY_CODE_HANDLER(CDN_INCLUDEITEM, _OnIncludeItem)
+#endif // !_WIN32_WCE
+	END_MSG_MAP()
+
+	LRESULT _OnFileOK(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		return !pT->OnFileOK((LPOFNOTIFY)pnmh);
+	}
+
+	LRESULT _OnFolderChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		pT->OnFolderChange((LPOFNOTIFY)pnmh);
+		return 0;
+	}
+
+	LRESULT _OnHelp(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		pT->OnHelp((LPOFNOTIFY)pnmh);
+		return 0;
+	}
+
+	LRESULT _OnInitDone(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		pT->OnInitDone((LPOFNOTIFY)pnmh);
+		return 0;
+	}
+
+	LRESULT _OnSelChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		pT->OnSelChange((LPOFNOTIFY)pnmh);
+		return 0;
+	}
+
+	LRESULT _OnShareViolation(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		return pT->OnShareViolation((LPOFNOTIFY)pnmh);
+	}
+
+	LRESULT _OnTypeChange(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		pT->OnTypeChange((LPOFNOTIFY)pnmh);
+		return 0;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT _OnIncludeItem(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		T* pT = static_cast<T*>(this);
+		return pT->OnIncludeItem((LPOFNOTIFYEX)pnmh);
+	}
+#endif // !_WIN32_WCE
+
+// Overrideables
+	BOOL OnFileOK(LPOFNOTIFY /*lpon*/)
+	{
+		return TRUE;
+	}
+
+	void OnFolderChange(LPOFNOTIFY /*lpon*/)
+	{
+	}
+
+	void OnHelp(LPOFNOTIFY /*lpon*/)
+	{
+	}
+
+	void OnInitDone(LPOFNOTIFY /*lpon*/)
+	{
+	}
+
+	void OnSelChange(LPOFNOTIFY /*lpon*/)
+	{
+	}
+
+	int OnShareViolation(LPOFNOTIFY /*lpon*/)
+	{
+		return 0;
+	}
+
+	void OnTypeChange(LPOFNOTIFY /*lpon*/)
+	{
+	}
+
+#ifndef _WIN32_WCE
+	BOOL OnIncludeItem(LPOFNOTIFYEX /*lponex*/)
+	{
+		return TRUE;   // include item
+	}
+#endif // !_WIN32_WCE
+};
+
+class CFileDialog : public CFileDialogImpl<CFileDialog>
+{
+public:
+	CFileDialog(BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
+		LPCTSTR lpszDefExt = NULL,
+		LPCTSTR lpszFileName = NULL,
+		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
+		LPCTSTR lpszFilter = NULL,
+		HWND hWndParent = NULL)
+		: CFileDialogImpl<CFileDialog>(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent)
+	{ }
+
+	// override base class map and references to handlers
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+#if defined(__AYGSHELL_H__) && (_WIN32_WCE >= 0x0501)
+class CFileDialogEx : public CFileDialogImpl<CFileDialogEx>
+{
+public:
+	CFileDialogEx( // Supports only FileOpen
+		LPCTSTR lpszDefExt = NULL,
+		LPCTSTR lpszFileName = NULL,
+		DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
+		OFN_EXFLAG ExFlags = OFN_EXFLAG_THUMBNAILVIEW,
+		OFN_SORTORDER dwSortOrder = OFN_SORTORDER_AUTO,		
+		LPCTSTR lpszFilter = NULL,
+		HWND hWndParent = NULL)
+		: CFileDialogImpl<CFileDialogEx>(TRUE, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent)
+	{
+		m_ofn.ExFlags = ExFlags;
+		m_ofn.dwSortOrder = dwSortOrder;
+	}
+
+	// override base class map and references to handlers
+	DECLARE_EMPTY_MSG_MAP()
+};
+#endif // defined(__AYGSHELL_H__) && (_WIN32_WCE >= 0x0501)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Multi File Dialog - Multi-select File Open dialog
+
+#ifndef _WIN32_WCE
+
+// The class dynamically resizes the buffer as the file selection changes
+// (as described in Knowledge Base article 131462). It also expands selected
+// shortcut files to take into account the full path of the target file.
+// Note that this doesn't work on Win9x for the old style dialogs, as well as
+// on NT for non-Unicode builds. 
+
+#ifndef _WTL_FIXED_OFN_BUFFER_LENGTH
+  #define _WTL_FIXED_OFN_BUFFER_LENGTH 0x10000
+#endif
+
+template <class T>
+class ATL_NO_VTABLE CMultiFileDialogImpl : public CFileDialogImpl< T >
+{
+public:
+	mutable LPCTSTR m_pNextFile; 
+#ifndef _UNICODE
+	bool m_bIsNT;
+#endif
+
+	CMultiFileDialogImpl(
+		LPCTSTR lpszDefExt = NULL,
+		LPCTSTR lpszFileName = NULL,
+		DWORD dwFlags = OFN_HIDEREADONLY,
+		LPCTSTR lpszFilter = NULL,
+		HWND hWndParent = NULL)
+		: CFileDialogImpl<T>(TRUE, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent), 
+		  m_pNextFile(NULL)
+	{
+		m_ofn.Flags |= OFN_ALLOWMULTISELECT;   // Force multiple selection mode
+
+#ifndef _UNICODE
+		OSVERSIONINFO ovi = { sizeof(ovi) };
+		::GetVersionEx(&ovi);
+		m_bIsNT = (ovi.dwPlatformId == VER_PLATFORM_WIN32_NT);
+		if (m_bIsNT)
+		{
+			// On NT platforms, GetOpenFileNameA thunks to GetOpenFileNameW and there 
+			// is absolutely nothing we can do except to start off with a large buffer.
+			ATLVERIFY(ResizeFilenameBuffer(_WTL_FIXED_OFN_BUFFER_LENGTH));
+		}
+#endif
+	}
+
+	~CMultiFileDialogImpl()
+	{
+		if (m_ofn.lpstrFile != m_szFileName)   // Free the buffer if we allocated it
+			delete[] m_ofn.lpstrFile;
+	}
+
+// Operations
+	// Get the directory that the files were chosen from.
+	// The function returns the number of characters copied, not including the terminating zero. 
+	// If the buffer is NULL, the function returns the required size, in characters, including the terminating zero.
+	// If the function fails, the return value is zero.
+	int GetDirectory(LPTSTR pBuffer, int nBufLen) const
+	{
+		if (m_ofn.lpstrFile == NULL)
+			return 0;
+
+		LPCTSTR pStr = m_ofn.lpstrFile;
+		int nLength = lstrlen(pStr);
+		if (pStr[nLength + 1] == 0)
+		{
+			// The OFN buffer contains a single item so extract its path.
+			LPCTSTR pSep = MinCrtHelper::_strrchr(pStr, _T('\\'));
+			if (pSep != NULL)
+				nLength = (int)(DWORD_PTR)(pSep - pStr);
+		}
+
+		int nRet = 0;
+		if (pBuffer == NULL)   // If the buffer is NULL, return the required length
+		{
+			nRet = nLength + 1;
+		}
+		else if (nBufLen > nLength)
+		{
+			SecureHelper::strncpy_x(pBuffer, nBufLen, pStr, nLength);
+			nRet = nLength;
+		}
+
+		return nRet;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	bool GetDirectory(_CSTRING_NS::CString& strDir) const
+	{
+		bool bRet = false;
+
+		int nLength = GetDirectory(NULL, 0);
+		if (nLength > 0)
+		{
+			bRet = (GetDirectory(strDir.GetBuffer(nLength), nLength) > 0);
+			strDir.ReleaseBuffer(nLength - 1);
+		}
+
+		return bRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	// Get the first filename as a pointer into the buffer.
+	LPCTSTR GetFirstFileName() const
+	{
+		if (m_ofn.lpstrFile == NULL)
+			return NULL;
+
+		m_pNextFile = NULL;   // Reset internal buffer pointer
+
+		LPCTSTR pStr = m_ofn.lpstrFile;
+		int nLength = lstrlen(pStr);
+		if (pStr[nLength + 1] != 0)
+		{
+			// Multiple items were selected. The first string is the directory,
+			// so skip forwards to the second string.
+			pStr += nLength + 1;
+
+			// Set up m_pNext so it points to the second item (or null).
+			m_pNextFile = pStr;
+			GetNextFileName();
+		}
+		else
+		{
+			// A single item was selected. Skip forward past the path.
+			LPCTSTR pSep = MinCrtHelper::_strrchr(pStr, _T('\\'));
+			if (pSep != NULL)
+				pStr = pSep + 1;
+		}
+
+		return pStr;
+	}
+
+	// Get the next filename as a pointer into the buffer.
+	LPCTSTR GetNextFileName() const
+	{
+		if (m_pNextFile == NULL)
+			return NULL;
+
+		LPCTSTR pStr = m_pNextFile;
+		// Set "m_pNextFile" to point to the next file name, or null if we 
+		// have reached the last file in the list.
+		int nLength = lstrlen(pStr);
+		m_pNextFile = (pStr[nLength + 1] != 0) ? &pStr[nLength + 1] : NULL;
+
+		return pStr;
+	}
+
+	// Get the first filename as a full path.
+	// The function returns the number of characters copied, not including the terminating zero. 
+	// If the buffer is NULL, the function returns the required size, in characters, including the terminating zero.
+	// If the function fails, the return value is zero.
+	int GetFirstPathName(LPTSTR pBuffer, int nBufLen) const
+	{
+		LPCTSTR pStr = GetFirstFileName();
+		int nLengthDir = GetDirectory(NULL, 0);
+		if((pStr == NULL) || (nLengthDir == 0))
+			return 0;
+
+		// Figure out the required length.
+		int nLengthTotal = nLengthDir + lstrlen(pStr);
+
+		int nRet = 0;
+		if(pBuffer == NULL) // If the buffer is NULL, return the required length
+		{
+			nRet = nLengthTotal + 1;
+		}
+		else if (nBufLen > nLengthTotal) // If the buffer is big enough, go ahead and construct the path
+		{		
+			GetDirectory(pBuffer, nBufLen);
+			SecureHelper::strcat_x(pBuffer, nBufLen, _T("\\"));
+			SecureHelper::strcat_x(pBuffer, nBufLen, pStr);
+			nRet = nLengthTotal;
+		}
+
+		return nRet;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	bool GetFirstPathName(_CSTRING_NS::CString& strPath) const
+	{
+		bool bRet = false;
+
+		int nLength = GetFirstPathName(NULL, 0);
+		if (nLength > 0)
+		{
+			bRet = (GetFirstPathName(strPath.GetBuffer(nLength), nLength) > 0);
+			strPath.ReleaseBuffer(nLength - 1);
+		}
+
+		return bRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	// Get the next filename as a full path.
+	// The function returns the number of characters copied, not including the terminating zero. 
+	// If the buffer is NULL, the function returns the required size, in characters, including the terminating zero.
+	// If the function fails, the return value is zero.
+	// The internal position marker is moved forward only if the function succeeds and the buffer was large enough.
+	int GetNextPathName(LPTSTR pBuffer, int nBufLen) const
+	{
+		if (m_pNextFile == NULL)
+			return 0;
+
+		int nRet = 0;
+		LPCTSTR pStr = m_pNextFile;
+		// Does the filename contain a backslash?
+		if (MinCrtHelper::_strrchr(pStr, _T('\\')) != NULL)
+		{
+			// Yes, so we'll assume it's a full path.
+			int nLength = lstrlen(pStr);
+
+			if (pBuffer == NULL) // If the buffer is NULL, return the required length
+			{
+				nRet = nLength + 1;
+			}
+			else if (nBufLen > nLength) // The buffer is big enough, so go ahead and copy the filename
+			{
+				SecureHelper::strcpy_x(pBuffer, nBufLen, GetNextFileName());
+				nRet = nBufLen;
+			}
+		}
+		else
+		{
+			// The filename is relative, so construct the full path.
+			int nLengthDir = GetDirectory(NULL, 0);
+			if (nLengthDir > 0)
+			{
+				// Calculate the required space.
+				int nLengthTotal = nLengthDir + lstrlen(pStr);
+
+				if(pBuffer == NULL) // If the buffer is NULL, return the required length
+				{
+					nRet = nLengthTotal + 1;
+				}
+				else if (nBufLen > nLengthTotal) // If the buffer is big enough, go ahead and construct the path
+				{
+					GetDirectory(pBuffer, nBufLen);
+					SecureHelper::strcat_x(pBuffer, nBufLen, _T("\\"));
+					SecureHelper::strcat_x(pBuffer, nBufLen, GetNextFileName());
+					nRet = nLengthTotal;
+				}
+			}
+		}
+
+		return nRet;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	bool GetNextPathName(_CSTRING_NS::CString& strPath) const
+	{
+		bool bRet = false;
+
+		int nLength = GetNextPathName(NULL, 0);
+		if (nLength > 0)
+		{
+			bRet = (GetNextPathName(strPath.GetBuffer(nLength), nLength) > 0);
+			strPath.ReleaseBuffer(nLength - 1);
+		}
+
+		return bRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+// Implementation
+	bool ResizeFilenameBuffer(DWORD dwLength)
+	{
+		if (dwLength > m_ofn.nMaxFile)
+		{
+			// Free the old buffer.
+			if (m_ofn.lpstrFile != m_szFileName)
+			{
+				delete[] m_ofn.lpstrFile;
+				m_ofn.lpstrFile = NULL;
+				m_ofn.nMaxFile = 0;
+			}
+
+			// Allocate the new buffer.
+			LPTSTR lpstrBuff = NULL;
+			ATLTRY(lpstrBuff = new TCHAR[dwLength]);
+			if (lpstrBuff != NULL)
+			{
+				m_ofn.lpstrFile = lpstrBuff;
+				m_ofn.lpstrFile[0] = 0;
+				m_ofn.nMaxFile = dwLength;
+			}
+		}
+
+		return (m_ofn.lpstrFile != NULL);
+	}
+
+	void OnSelChange(LPOFNOTIFY /*lpon*/)
+	{
+#ifndef _UNICODE
+		// There is no point resizing the buffer in ANSI builds running on NT.
+		if (m_bIsNT)
+			return;
+#endif
+
+		// Get the buffer length required to hold the spec.
+		int nLength = GetSpec(NULL, 0);
+		if (nLength <= 1)
+			return; // no files are selected, presumably
+		
+		// Add room for the directory, and an extra terminating zero.
+		nLength += GetFolderPath(NULL, 0) + 1;
+
+		if (!ResizeFilenameBuffer(nLength))
+		{
+			ATLASSERT(FALSE);
+			return;
+		}
+
+		// If we are not following links then our work is done.
+		if ((m_ofn.Flags & OFN_NODEREFERENCELINKS) != 0)
+			return;
+
+		// Get the file spec, which is the text in the edit control.
+		if (GetSpec(m_ofn.lpstrFile, m_ofn.nMaxFile) <= 0)
+			return;
+		
+		// Get the ID-list of the current folder.
+		int nBytes = GetFolderIDList(NULL, 0);
+		CTempBuffer<ITEMIDLIST> idlist;
+		idlist.AllocateBytes(nBytes);
+		if ((nBytes <= 0) || (GetFolderIDList(idlist, nBytes) <= 0))
+			return;
+
+		// First bind to the desktop folder, then to the current folder.
+		ATL::CComPtr<IShellFolder> pDesktop, pFolder;
+		if (FAILED(::SHGetDesktopFolder(&pDesktop)))
+			return;
+		if (FAILED(pDesktop->BindToObject(idlist, NULL, IID_IShellFolder, (void**)&pFolder)))
+			return;
+
+		// Work through the file spec, looking for quoted filenames. If we find a shortcut file, then 
+		// we need to add enough extra buffer space to hold its target path.
+		DWORD nExtraChars = 0;
+		bool bInsideQuotes = false;
+		LPCTSTR pAnchor = m_ofn.lpstrFile;
+		LPCTSTR pChar = m_ofn.lpstrFile;
+		for ( ; *pChar; ++pChar)
+		{
+			// Look for quotation marks.
+			if (*pChar == _T('\"'))
+			{
+				// We are either entering or leaving a passage of quoted text.
+				bInsideQuotes = !bInsideQuotes;
+
+				// Is it an opening or closing quote?
+				if (bInsideQuotes)
+				{
+					// We found an opening quote, so set "pAnchor" to the following character.
+					pAnchor = pChar + 1;
+				}
+				else // closing quote
+				{
+					// Each quoted entity should be shorter than MAX_PATH.
+					if (pChar - pAnchor >= MAX_PATH)
+						return;
+
+					// Get the ID-list and attributes of the file.
+					USES_CONVERSION;
+					int nFileNameLength = (int)(DWORD_PTR)(pChar - pAnchor);
+					TCHAR szFileName[MAX_PATH];
+					SecureHelper::strncpy_x(szFileName, MAX_PATH, pAnchor, nFileNameLength);
+					LPITEMIDLIST pidl = NULL;
+					DWORD dwAttrib = SFGAO_LINK;
+					if (SUCCEEDED(pFolder->ParseDisplayName(NULL, NULL, T2W(szFileName), NULL, &pidl, &dwAttrib)))
+					{
+						// Is it a shortcut file?
+						if (dwAttrib & SFGAO_LINK)
+						{
+							// Bind to its IShellLink interface.
+							ATL::CComPtr<IShellLink> pLink;
+							if (SUCCEEDED(pFolder->BindToObject(pidl, NULL, IID_IShellLink, (void**)&pLink)))
+							{
+								// Get the shortcut's target path.
+								TCHAR szPath[MAX_PATH];
+								if (SUCCEEDED(pLink->GetPath(szPath, MAX_PATH, NULL, 0)))
+								{
+									// If the target path is longer than the shortcut name, then add on the number 
+									// of extra characters that are required.
+									int nNewLength = lstrlen(szPath);
+									if (nNewLength > nFileNameLength)
+										nExtraChars += nNewLength - nFileNameLength;
+								}
+							}
+						}
+
+						// Free the ID-list returned by ParseDisplayName.
+						::CoTaskMemFree(pidl);
+					}
+				}
+			}
+		}
+
+		// If we need more space for shortcut targets, then reallocate.
+		if (nExtraChars > 0)
+			ATLVERIFY(ResizeFilenameBuffer(m_ofn.nMaxFile + nExtraChars));
+	}
+};
+
+class CMultiFileDialog : public CMultiFileDialogImpl<CMultiFileDialog>
+{
+public:
+	CMultiFileDialog(
+		LPCTSTR lpszDefExt = NULL,
+		LPCTSTR lpszFileName = NULL,
+		DWORD dwFlags = OFN_HIDEREADONLY,
+		LPCTSTR lpszFilter = NULL,
+		HWND hWndParent = NULL)
+		: CMultiFileDialogImpl<CMultiFileDialog>(lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent)
+	{ }
+
+	BEGIN_MSG_MAP(CMultiFileDialog)
+		CHAIN_MSG_MAP(CMultiFileDialogImpl<CMultiFileDialog>)
+	END_MSG_MAP()
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Shell File Dialog - new Shell File Open and Save dialogs in Vista
+
+// Note: Use GetPtr() to access dialog interface methods.
+// Example:
+//	CShellFileOpenDialog dlg;
+//	dlg.GetPtr()->SetTitle(L"MyFileOpenDialog");
+
+#if (_WIN32_WINNT >= 0x0600) && !defined(_WIN32_WCE)
+
+///////////////////////////////////////////////////////////////////////////////
+// CShellFileDialogImpl - base class for CShellFileOpenDialogImpl and CShellFileSaveDialogImpl
+
+template <class T>
+class ATL_NO_VTABLE CShellFileDialogImpl : public IFileDialogEvents
+{
+public:
+// Operations
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		INT_PTR nRet = -1;
+
+		T* pT = static_cast<T*>(this);
+		if(pT->m_spFileDlg == NULL)
+		{
+			ATLASSERT(FALSE);
+			return nRet;
+		}
+
+		DWORD dwCookie = 0;
+		pT->_Advise(dwCookie);
+
+		HRESULT hRet = pT->m_spFileDlg->Show(hWndParent);
+		if(SUCCEEDED(hRet))
+			nRet = IDOK;
+		else if(hRet == HRESULT_FROM_WIN32(ERROR_CANCELLED))
+			nRet = IDCANCEL;
+		else
+			ATLASSERT(FALSE);   // error
+
+		pT->_Unadvise(dwCookie);
+
+		return nRet;
+	}
+
+	bool IsNull() const
+	{
+		const T* pT = static_cast<const T*>(this);
+		return (pT->m_spFileDlg == NULL);
+	}
+
+// Operations - get file path after dialog returns
+	HRESULT GetFilePath(LPWSTR lpstrFilePath, int cchLength)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+
+		ATL::CComPtr<IShellItem> spItem;
+		HRESULT hRet = pT->m_spFileDlg->GetResult(&spItem);
+
+		if(SUCCEEDED(hRet))
+			hRet = GetFileNameFromShellItem(spItem, SIGDN_FILESYSPATH, lpstrFilePath, cchLength);
+
+		return hRet;
+	}
+
+	HRESULT GetFileTitle(LPWSTR lpstrFileTitle, int cchLength)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+
+		ATL::CComPtr<IShellItem> spItem;
+		HRESULT hRet = pT->m_spFileDlg->GetResult(&spItem);
+
+		if(SUCCEEDED(hRet))
+			hRet = GetFileNameFromShellItem(spItem, SIGDN_NORMALDISPLAY, lpstrFileTitle, cchLength);
+
+		return hRet;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	HRESULT GetFilePath(_CSTRING_NS::CString& strFilePath)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+
+		ATL::CComPtr<IShellItem> spItem;
+		HRESULT hRet = pT->m_spFileDlg->GetResult(&spItem);
+
+		if(SUCCEEDED(hRet))
+			hRet = GetFileNameFromShellItem(spItem, SIGDN_FILESYSPATH, strFilePath);
+
+		return hRet;
+	}
+
+	HRESULT GetFileTitle(_CSTRING_NS::CString& strFileTitle)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+
+		ATL::CComPtr<IShellItem> spItem;
+		HRESULT hRet = pT->m_spFileDlg->GetResult(&spItem);
+
+		if(SUCCEEDED(hRet))
+			hRet = GetFileNameFromShellItem(spItem, SIGDN_NORMALDISPLAY, strFileTitle);
+
+		return hRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+// Helpers for IShellItem
+	static HRESULT GetFileNameFromShellItem(IShellItem* pShellItem, SIGDN type, LPWSTR lpstr, int cchLength)
+	{
+		ATLASSERT(pShellItem != NULL);
+
+		LPWSTR lpstrName = NULL;
+		HRESULT hRet = pShellItem->GetDisplayName(type, &lpstrName);
+
+		if(SUCCEEDED(hRet))
+		{
+			if(lstrlenW(lpstrName) < cchLength)
+			{
+				SecureHelper::strcpyW_x(lpstr, cchLength, lpstrName);
+			}
+			else
+			{
+				ATLASSERT(FALSE);
+				hRet = DISP_E_BUFFERTOOSMALL;
+			}
+
+			::CoTaskMemFree(lpstrName);
+		}
+
+		return hRet;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	static HRESULT GetFileNameFromShellItem(IShellItem* pShellItem, SIGDN type, _CSTRING_NS::CString& str)
+	{
+		ATLASSERT(pShellItem != NULL);
+
+		LPWSTR lpstrName = NULL;
+		HRESULT hRet = pShellItem->GetDisplayName(type, &lpstrName);
+
+		if(SUCCEEDED(hRet))
+		{
+			str = lpstrName;
+			::CoTaskMemFree(lpstrName);
+		}
+
+		return hRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+// Implementation
+	void _Advise(DWORD& dwCookie)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+		HRESULT hRet = pT->m_spFileDlg->Advise((IFileDialogEvents*)this, &dwCookie);
+		ATLVERIFY(SUCCEEDED(hRet));
+	}
+
+	void _Unadvise(DWORD dwCookie)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+		HRESULT hRet = pT->m_spFileDlg->Unadvise(dwCookie);
+		ATLVERIFY(SUCCEEDED(hRet));
+	}
+
+	void _Init(LPCWSTR lpszFileName, DWORD dwOptions, LPCWSTR lpszDefExt, const COMDLG_FILTERSPEC* arrFilterSpec, UINT uFilterSpecCount)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg != NULL);
+
+		HRESULT hRet = E_FAIL;
+
+		if(lpszFileName != NULL)
+		{
+			hRet = pT->m_spFileDlg->SetFileName(lpszFileName);
+			ATLASSERT(SUCCEEDED(hRet));
+		}
+
+		hRet = pT->m_spFileDlg->SetOptions(dwOptions);
+		ATLASSERT(SUCCEEDED(hRet));
+
+		if(lpszDefExt != NULL)
+		{
+			hRet = pT->m_spFileDlg->SetDefaultExtension(lpszDefExt);
+			ATLASSERT(SUCCEEDED(hRet));
+		}
+
+		if(arrFilterSpec != NULL && uFilterSpecCount != 0U)
+		{
+			hRet = pT->m_spFileDlg->SetFileTypes(uFilterSpecCount, arrFilterSpec);
+			ATLASSERT(SUCCEEDED(hRet));
+		}
+	}
+
+// Implementation - IUnknown interface
+	STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject)
+	{
+		if(ppvObject == NULL)
+			return E_POINTER;
+
+		T* pT = static_cast<T*>(this);
+		if(IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IFileDialogEvents))
+		{
+			*ppvObject = (IFileDialogEvents*)pT;
+			// AddRef() not needed
+			return S_OK;
+		}
+
+		return E_NOINTERFACE;
+	}
+
+	virtual ULONG STDMETHODCALLTYPE AddRef()
+	{
+		return 1;
+	}
+
+	virtual ULONG STDMETHODCALLTYPE Release()
+	{
+		return 1;
+	}
+
+// Implementation - IFileDialogEvents interface
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnFileOk(IFileDialog* pfd)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnFileOk();
+	}
+
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnFolderChanging(IFileDialog* pfd, IShellItem* psiFolder)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnFolderChanging(psiFolder);
+	}
+
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnFolderChange(IFileDialog* pfd)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnFolderChange();
+	}
+
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnSelectionChange(IFileDialog* pfd)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnSelectionChange();
+	}
+
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnShareViolation(IFileDialog* pfd, IShellItem* psi, FDE_SHAREVIOLATION_RESPONSE* pResponse)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnShareViolation(psi, pResponse);
+	}
+
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnTypeChange(IFileDialog* pfd)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnTypeChange();
+	}
+
+	virtual HRESULT STDMETHODCALLTYPE IFileDialogEvents::OnOverwrite(IFileDialog* pfd, IShellItem* psi, FDE_OVERWRITE_RESPONSE* pResponse)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_spFileDlg.IsEqualObject(pfd));
+		pfd;   // avoid level 4 warning
+		return pT->OnOverwrite(psi, pResponse);
+	}
+
+// Overrideables - Event handlers
+	HRESULT OnFileOk()
+	{
+		return E_NOTIMPL;
+	}
+
+	HRESULT OnFolderChanging(IShellItem* /*psiFolder*/)
+	{
+		return E_NOTIMPL;
+	}
+
+	HRESULT OnFolderChange()
+	{
+		return E_NOTIMPL;
+	}
+
+	HRESULT OnSelectionChange()
+	{
+		return E_NOTIMPL;
+	}
+
+	HRESULT OnShareViolation(IShellItem* /*psi*/, FDE_SHAREVIOLATION_RESPONSE* /*pResponse*/)
+	{
+		return E_NOTIMPL;
+	}
+
+	HRESULT OnTypeChange()
+	{
+		return E_NOTIMPL;
+	}
+
+	HRESULT OnOverwrite(IShellItem* /*psi*/, FDE_OVERWRITE_RESPONSE* /*pResponse*/)
+	{
+		return E_NOTIMPL;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CShellFileOpenDialogImpl - implements new Shell File Open dialog
+
+template <class T>
+class ATL_NO_VTABLE CShellFileOpenDialogImpl : public CShellFileDialogImpl< T >
+{
+public:
+	ATL::CComPtr<IFileOpenDialog> m_spFileDlg;
+
+	CShellFileOpenDialogImpl(LPCWSTR lpszFileName = NULL, 
+	                         DWORD dwOptions = FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST, 
+	                         LPCWSTR lpszDefExt = NULL, 
+	                         const COMDLG_FILTERSPEC* arrFilterSpec = NULL, 
+	                         UINT uFilterSpecCount = 0U)
+	{
+		HRESULT hRet = m_spFileDlg.CoCreateInstance(CLSID_FileOpenDialog);
+
+		if(SUCCEEDED(hRet))
+			_Init(lpszFileName, dwOptions, lpszDefExt, arrFilterSpec, uFilterSpecCount);
+	}
+
+	IFileOpenDialog* GetPtr()
+	{
+		return m_spFileDlg;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CShellFileOpenDialog - new Shell File Open dialog without events
+
+class CShellFileOpenDialog : public CShellFileOpenDialogImpl<CShellFileOpenDialog>
+{
+public:
+	CShellFileOpenDialog(LPCWSTR lpszFileName = NULL, 
+	                     DWORD dwOptions = FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST | FOS_FILEMUSTEXIST, 
+	                     LPCWSTR lpszDefExt = NULL, 
+	                     const COMDLG_FILTERSPEC* arrFilterSpec = NULL, 
+	                     UINT uFilterSpecCount = 0U) : CShellFileOpenDialogImpl<CShellFileOpenDialog>(lpszFileName, dwOptions, lpszDefExt, arrFilterSpec, uFilterSpecCount)
+	{ }
+
+// Implementation (remove _Advise/_Unadvise code using template magic)
+	void _Advise(DWORD& /*dwCookie*/)
+	{ }
+
+	void _Unadvise(DWORD /*dwCookie*/)
+	{ }
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CShellFileSaveDialogImpl - implements new Shell File Save dialog
+
+template <class T>
+class ATL_NO_VTABLE CShellFileSaveDialogImpl : public CShellFileDialogImpl< T >
+{
+public:
+	ATL::CComPtr<IFileSaveDialog> m_spFileDlg;
+
+	CShellFileSaveDialogImpl(LPCWSTR lpszFileName = NULL, 
+	                         DWORD dwOptions = FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST | FOS_OVERWRITEPROMPT, 
+	                         LPCWSTR lpszDefExt = NULL, 
+	                         const COMDLG_FILTERSPEC* arrFilterSpec = NULL, 
+	                         UINT uFilterSpecCount = 0U)
+	{
+		HRESULT hRet = m_spFileDlg.CoCreateInstance(CLSID_FileSaveDialog);
+
+		if(SUCCEEDED(hRet))
+			_Init(lpszFileName, dwOptions, lpszDefExt, arrFilterSpec, uFilterSpecCount);
+	}
+
+	IFileSaveDialog* GetPtr()
+	{
+		return m_spFileDlg;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CShellFileSaveDialog - new Shell File Save dialog without events
+
+class CShellFileSaveDialog : public CShellFileSaveDialogImpl<CShellFileSaveDialog>
+{
+public:
+	CShellFileSaveDialog(LPCWSTR lpszFileName = NULL, 
+	                     DWORD dwOptions = FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST | FOS_OVERWRITEPROMPT, 
+	                     LPCWSTR lpszDefExt = NULL, 
+	                     const COMDLG_FILTERSPEC* arrFilterSpec = NULL, 
+	                     UINT uFilterSpecCount = 0U) : CShellFileSaveDialogImpl<CShellFileSaveDialog>(lpszFileName, dwOptions, lpszDefExt, arrFilterSpec, uFilterSpecCount)
+	{ }
+
+// Implementation (remove _Advise/_Unadvise code using template magic)
+	void _Advise(DWORD& /*dwCookie*/)
+	{ }
+
+	void _Unadvise(DWORD /*dwCookie*/)
+	{ }
+};
+
+#endif // (_WIN32_WINNT >= 0x0600) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFolderDialogImpl - used for browsing for a folder
+
+#ifndef _WIN32_WCE
+
+template <class T>
+class ATL_NO_VTABLE CFolderDialogImpl
+{
+public:
+	BROWSEINFO m_bi;
+	LPCTSTR m_lpstrInitialFolder;
+	LPCITEMIDLIST m_pidlInitialSelection;
+	bool m_bExpandInitialSelection;
+	TCHAR m_szFolderDisplayName[MAX_PATH];
+	TCHAR m_szFolderPath[MAX_PATH];
+	LPITEMIDLIST m_pidlSelected;
+	HWND m_hWnd;   // used only in the callback function
+
+// Constructor
+	CFolderDialogImpl(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS) : 
+			m_lpstrInitialFolder(NULL), m_pidlInitialSelection(NULL), m_bExpandInitialSelection(false), m_pidlSelected(NULL), m_hWnd(NULL)
+	{
+		memset(&m_bi, 0, sizeof(m_bi)); // initialize structure to 0/NULL
+
+		m_bi.hwndOwner = hWndParent;
+		m_bi.pidlRoot = NULL;
+		m_bi.pszDisplayName = m_szFolderDisplayName;
+		m_bi.lpszTitle = lpstrTitle;
+		m_bi.ulFlags = uFlags;
+		m_bi.lpfn = BrowseCallbackProc;
+		m_bi.lParam = (LPARAM)static_cast<T*>(this);
+
+		m_szFolderPath[0] = 0;
+		m_szFolderDisplayName[0] = 0;
+	}
+
+	~CFolderDialogImpl()
+	{
+		::CoTaskMemFree(m_pidlSelected);
+	}
+
+// Operations
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		if(m_bi.hwndOwner == NULL)   // set only if not specified before
+			m_bi.hwndOwner = hWndParent;
+
+		// Clear out any previous results
+		m_szFolderPath[0] = 0;
+		m_szFolderDisplayName[0] = 0;
+		::CoTaskMemFree(m_pidlSelected);
+
+		INT_PTR nRet = IDCANCEL;
+		m_pidlSelected = ::SHBrowseForFolder(&m_bi);
+
+		if(m_pidlSelected != NULL)
+		{
+			nRet = IDOK;
+
+			// If BIF_RETURNONLYFSDIRS is set, we try to get the filesystem path.
+			// Otherwise, the caller must handle the ID-list directly.
+			if((m_bi.ulFlags & BIF_RETURNONLYFSDIRS) != 0)
+			{
+				if(::SHGetPathFromIDList(m_pidlSelected, m_szFolderPath) == FALSE)
+					nRet = IDCANCEL;
+			}
+		}
+
+		return nRet;
+	}
+
+	// Methods to call before DoModal
+	void SetInitialFolder(LPCTSTR lpstrInitialFolder, bool bExpand = true)
+	{
+		// lpstrInitialFolder may be a file if BIF_BROWSEINCLUDEFILES is specified
+		m_lpstrInitialFolder = lpstrInitialFolder;
+		m_bExpandInitialSelection = bExpand;
+	}
+
+	void SetInitialSelection(LPCITEMIDLIST pidl, bool bExpand = true)
+	{
+		m_pidlInitialSelection = pidl;
+		m_bExpandInitialSelection = bExpand;
+	}
+
+	// Methods to call after DoModal
+	LPITEMIDLIST GetSelectedItem(bool bDetach = false)
+	{
+		LPITEMIDLIST pidl = m_pidlSelected;
+		if(bDetach)
+			m_pidlSelected = NULL;
+
+		return pidl;
+	}
+
+	LPCTSTR GetFolderPath() const
+	{
+		return m_szFolderPath;
+	}
+
+	LPCTSTR GetFolderDisplayName() const
+	{
+		return m_szFolderDisplayName;
+	}
+
+	int GetFolderImageIndex() const
+	{
+		return m_bi.iImage;
+	}
+
+// Callback function and overrideables
+	static int CALLBACK BrowseCallbackProc(HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData)
+	{
+#ifndef BFFM_VALIDATEFAILED
+  #ifdef UNICODE
+		const int BFFM_VALIDATEFAILED = 4;
+  #else
+		const int BFFM_VALIDATEFAILED = 3;
+  #endif
+#endif // !BFFM_VALIDATEFAILED
+#ifndef BFFM_IUNKNOWN
+		const int BFFM_IUNKNOWN = 5;
+#endif // !BFFM_IUNKNOWN
+#ifndef BIF_NEWDIALOGSTYLE
+		const UINT BIF_NEWDIALOGSTYLE = 0x0040;
+#endif // !BIF_NEWDIALOGSTYLE
+
+		int nRet = 0;
+		T* pT = (T*)lpData;
+		bool bClear = false;
+		if(pT->m_hWnd == NULL)
+		{
+			pT->m_hWnd = hWnd;
+			bClear = true;
+		}
+		else
+		{
+			ATLASSERT(pT->m_hWnd == hWnd);
+		}
+
+		switch(uMsg)
+		{
+		case BFFM_INITIALIZED:
+			// Set initial selection
+			// Note that m_pidlInitialSelection, if set, takes precedence over m_lpstrInitialFolder
+			if(pT->m_pidlInitialSelection != NULL)
+				pT->SetSelection(pT->m_pidlInitialSelection);
+			else if(pT->m_lpstrInitialFolder != NULL)
+				pT->SetSelection(pT->m_lpstrInitialFolder);
+
+			// Expand initial selection if appropriate
+			if(pT->m_bExpandInitialSelection && ((pT->m_bi.ulFlags & BIF_NEWDIALOGSTYLE) != 0))
+			{
+				if(pT->m_pidlInitialSelection != NULL)
+					pT->SetExpanded(pT->m_pidlInitialSelection);
+				else if(pT->m_lpstrInitialFolder != NULL)
+					pT->SetExpanded(pT->m_lpstrInitialFolder);
+			}
+			pT->OnInitialized();
+			break;
+		case BFFM_SELCHANGED:
+			pT->OnSelChanged((LPITEMIDLIST)lParam);
+			break;
+		case BFFM_VALIDATEFAILED:
+			nRet = pT->OnValidateFailed((LPCTSTR)lParam);
+			break;
+		case BFFM_IUNKNOWN:
+			pT->OnIUnknown((IUnknown*)lParam);
+			break;
+		default:
+			ATLTRACE2(atlTraceUI, 0, _T("Unknown message received in CFolderDialogImpl::BrowseCallbackProc\n"));
+			break;
+		}
+
+		if(bClear)
+			pT->m_hWnd = NULL;
+		return nRet;
+	}
+
+	void OnInitialized()
+	{
+	}
+
+	void OnSelChanged(LPITEMIDLIST /*pItemIDList*/)
+	{
+	}
+
+	int OnValidateFailed(LPCTSTR /*lpstrFolderPath*/)
+	{
+		return 1;   // 1=continue, 0=EndDialog
+	}
+
+	void OnIUnknown(IUnknown* /*pUnknown*/)
+	{
+	}
+
+	// Commands - valid to call only from handlers
+	void EnableOK(BOOL bEnable)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, BFFM_ENABLEOK, 0, bEnable);
+	}
+
+	void SetSelection(LPCITEMIDLIST pItemIDList)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, BFFM_SETSELECTION, FALSE, (LPARAM)pItemIDList);
+	}
+
+	void SetSelection(LPCTSTR lpstrFolderPath)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, BFFM_SETSELECTION, TRUE, (LPARAM)lpstrFolderPath);
+	}
+
+	void SetStatusText(LPCTSTR lpstrText)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)lpstrText);
+	}
+
+	void SetOKText(LPCTSTR lpstrOKText)
+	{
+#ifndef BFFM_SETOKTEXT
+		const UINT BFFM_SETOKTEXT = WM_USER + 105;
+#endif
+		ATLASSERT(m_hWnd != NULL);
+		USES_CONVERSION;
+		LPCWSTR lpstr = T2CW(lpstrOKText);
+		::SendMessage(m_hWnd, BFFM_SETOKTEXT, 0, (LPARAM)lpstr);
+	}
+
+	void SetExpanded(LPCITEMIDLIST pItemIDList)
+	{
+#ifndef BFFM_SETEXPANDED
+		const UINT BFFM_SETEXPANDED = WM_USER + 106;
+#endif
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, BFFM_SETEXPANDED, FALSE, (LPARAM)pItemIDList);
+	}
+
+	void SetExpanded(LPCTSTR lpstrFolderPath)
+	{
+#ifndef BFFM_SETEXPANDED
+		const UINT BFFM_SETEXPANDED = WM_USER + 106;
+#endif
+		ATLASSERT(m_hWnd != NULL);
+		USES_CONVERSION;
+		LPCWSTR lpstr = T2CW(lpstrFolderPath);
+		::SendMessage(m_hWnd, BFFM_SETEXPANDED, TRUE, (LPARAM)lpstr);
+	}
+};
+
+class CFolderDialog : public CFolderDialogImpl<CFolderDialog>
+{
+public:
+	CFolderDialog(HWND hWndParent = NULL, LPCTSTR lpstrTitle = NULL, UINT uFlags = BIF_RETURNONLYFSDIRS)
+		: CFolderDialogImpl<CFolderDialog>(hWndParent, lpstrTitle, uFlags)
+	{ }
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCommonDialogImplBase - base class for common dialog classes
+
+class ATL_NO_VTABLE CCommonDialogImplBase : public ATL::CWindowImplBase
+{
+public:
+	static UINT_PTR APIENTRY HookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		if(uMsg != WM_INITDIALOG)
+			return 0;
+		CCommonDialogImplBase* pT = (CCommonDialogImplBase*)ModuleHelper::ExtractCreateWndData();
+		ATLASSERT(pT != NULL);
+		ATLASSERT(pT->m_hWnd == NULL);
+		ATLASSERT(::IsWindow(hWnd));
+		// subclass dialog's window
+		if(!pT->SubclassWindow(hWnd))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("Subclassing a common dialog failed\n"));
+			return 0;
+		}
+		// check message map for WM_INITDIALOG handler
+		LRESULT lRes = 0;
+		if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0) == FALSE)
+			return 0;
+		return lRes;
+	}
+
+// Special override for common dialogs
+	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		SendMessage(WM_COMMAND, MAKEWPARAM(IDABORT, 0));
+		return TRUE;
+	}
+
+// Implementation - try to override these, to prevent errors
+	HWND Create(HWND, ATL::_U_RECT, LPCTSTR, DWORD, DWORD, ATL::_U_MENUorID, ATOM, LPVOID)
+	{
+		ATLASSERT(FALSE);   // should not be called
+		return NULL;
+	}
+
+	static LRESULT CALLBACK StartWindowProc(HWND /*hWnd*/, UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/)
+	{
+		ATLASSERT(FALSE);   // should not be called
+		return 0;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFontDialogImpl - font selection dialog
+
+#ifndef _WIN32_WCE
+
+template <class T>
+class ATL_NO_VTABLE CFontDialogImpl : public CCommonDialogImplBase
+{
+public:
+	enum { _cchStyleName = 64 };
+
+	CHOOSEFONT m_cf;
+	TCHAR m_szStyleName[_cchStyleName];  // contains style name after return
+	LOGFONT m_lf;                        // default LOGFONT to store the info
+
+// Constructors
+	CFontDialogImpl(LPLOGFONT lplfInitial = NULL,
+			DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
+			HDC hDCPrinter = NULL,
+			HWND hWndParent = NULL)
+	{
+		memset(&m_cf, 0, sizeof(m_cf));
+		memset(&m_lf, 0, sizeof(m_lf));
+		memset(&m_szStyleName, 0, sizeof(m_szStyleName));
+
+		m_cf.lStructSize = sizeof(m_cf);
+		m_cf.hwndOwner = hWndParent;
+		m_cf.rgbColors = RGB(0, 0, 0);
+		m_cf.lpszStyle = (LPTSTR)&m_szStyleName;
+		m_cf.Flags = dwFlags | CF_ENABLEHOOK;
+		m_cf.lpfnHook = (LPCFHOOKPROC)T::HookProc;
+
+		if(lplfInitial != NULL)
+		{
+			m_cf.lpLogFont = lplfInitial;
+			m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
+			m_lf = *lplfInitial;
+		}
+		else
+		{
+			m_cf.lpLogFont = &m_lf;
+		}
+
+		if(hDCPrinter != NULL)
+		{
+			m_cf.hDC = hDCPrinter;
+			m_cf.Flags |= CF_PRINTERFONTS;
+		}
+	}
+
+// Operations
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT((m_cf.Flags & CF_ENABLEHOOK) != 0);
+		ATLASSERT(m_cf.lpfnHook != NULL);   // can still be a user hook
+
+		if(m_cf.hwndOwner == NULL)          // set only if not specified before
+			m_cf.hwndOwner = hWndParent;
+
+		ATLASSERT(m_hWnd == NULL);
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
+
+		BOOL bRet = ::ChooseFont(&m_cf);
+
+		m_hWnd = NULL;
+
+		if(bRet)   // copy logical font from user's initialization buffer (if needed)
+			SecureHelper::memcpy_x(&m_lf, sizeof(m_lf), m_cf.lpLogFont, sizeof(m_lf));
+
+		return bRet ? IDOK : IDCANCEL;
+	}
+
+	// works only when the dialog is dislayed or after
+	void GetCurrentFont(LPLOGFONT lplf) const
+	{
+		ATLASSERT(lplf != NULL);
+
+		if(m_hWnd != NULL)
+			::SendMessage(m_hWnd, WM_CHOOSEFONT_GETLOGFONT, 0, (LPARAM)lplf);
+		else
+			*lplf = m_lf;
+	}
+
+	// works only when the dialog is dislayed or before
+#ifndef _WIN32_WCE
+	void SetLogFont(LPLOGFONT lplf)
+	{
+		ATLASSERT(lplf != NULL);
+#ifndef WM_CHOOSEFONT_SETLOGFONT
+		const UINT WM_CHOOSEFONT_SETLOGFONT = (WM_USER + 101);
+#endif
+		if(m_hWnd != NULL)
+		{
+			::SendMessage(m_hWnd, WM_CHOOSEFONT_SETLOGFONT, 0, (LPARAM)lplf);
+		}
+		else
+		{
+			m_lf = *lplf;
+			m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
+		}
+	}
+
+	void SetFlags(DWORD dwFlags)
+	{
+#ifndef WM_CHOOSEFONT_SETFLAGS
+		const UINT WM_CHOOSEFONT_SETFLAGS = (WM_USER + 102);
+#endif
+		if(m_hWnd != NULL)
+		{
+			CHOOSEFONT cf = { sizeof(CHOOSEFONT) };
+			cf.Flags = dwFlags;
+			::SendMessage(m_hWnd, WM_CHOOSEFONT_SETFLAGS, 0, (LPARAM)&cf);
+		}
+		else
+		{
+			m_cf.Flags = dwFlags;
+		}
+	}
+#endif // !_WIN32_WCE
+
+	// Helpers for parsing information after successful return
+	LPCTSTR GetFaceName() const   // return the face name of the font
+	{
+		return (LPCTSTR)m_cf.lpLogFont->lfFaceName;
+	}
+
+	LPCTSTR GetStyleName() const  // return the style name of the font
+	{
+		return m_cf.lpszStyle;
+	}
+
+	int GetSize() const           // return the pt size of the font
+	{
+		return m_cf.iPointSize;
+	}
+
+	COLORREF GetColor() const     // return the color of the font
+	{
+		return m_cf.rgbColors;
+	}
+
+	int GetWeight() const         // return the chosen font weight
+	{
+		return (int)m_cf.lpLogFont->lfWeight;
+	}
+
+	BOOL IsStrikeOut() const      // return TRUE if strikeout
+	{
+		return (m_cf.lpLogFont->lfStrikeOut) ? TRUE : FALSE;
+	}
+
+	BOOL IsUnderline() const      // return TRUE if underline
+	{
+		return (m_cf.lpLogFont->lfUnderline) ? TRUE : FALSE;
+	}
+
+	BOOL IsBold() const           // return TRUE if bold font
+	{
+		return (m_cf.lpLogFont->lfWeight == FW_BOLD) ? TRUE : FALSE;
+	}
+
+	BOOL IsItalic() const         // return TRUE if italic font
+	{
+		return m_cf.lpLogFont->lfItalic ? TRUE : FALSE;
+	}
+};
+
+class CFontDialog : public CFontDialogImpl<CFontDialog>
+{
+public:
+	CFontDialog(LPLOGFONT lplfInitial = NULL,
+		DWORD dwFlags = CF_EFFECTS | CF_SCREENFONTS,
+		HDC hDCPrinter = NULL,
+		HWND hWndParent = NULL)
+		: CFontDialogImpl<CFontDialog>(lplfInitial, dwFlags, hDCPrinter, hWndParent)
+	{ }
+
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRichEditFontDialogImpl - font selection for the Rich Edit ctrl
+
+#if defined(_RICHEDIT_) && !defined(_WIN32_WCE)
+
+template <class T>
+class ATL_NO_VTABLE CRichEditFontDialogImpl : public CFontDialogImpl< T >
+{
+public:
+	CRichEditFontDialogImpl(const CHARFORMAT& charformat,
+			DWORD dwFlags = CF_SCREENFONTS,
+			HDC hDCPrinter = NULL,
+			HWND hWndParent = NULL)
+			: CFontDialogImpl< T >(NULL, dwFlags, hDCPrinter, hWndParent)
+	{
+		m_cf.Flags |= CF_INITTOLOGFONTSTRUCT;
+		m_cf.Flags |= FillInLogFont(charformat);
+		m_cf.lpLogFont = &m_lf;
+
+		if((charformat.dwMask & CFM_COLOR) != 0)
+			m_cf.rgbColors = charformat.crTextColor;
+	}
+
+	void GetCharFormat(CHARFORMAT& cf) const
+	{
+		USES_CONVERSION;
+		cf.dwEffects = 0;
+		cf.dwMask = 0;
+		if((m_cf.Flags & CF_NOSTYLESEL) == 0)
+		{
+			cf.dwMask |= CFM_BOLD | CFM_ITALIC;
+			cf.dwEffects |= IsBold() ? CFE_BOLD : 0;
+			cf.dwEffects |= IsItalic() ? CFE_ITALIC : 0;
+		}
+		if((m_cf.Flags & CF_NOSIZESEL) == 0)
+		{
+			cf.dwMask |= CFM_SIZE;
+			// GetSize() returns in tenths of points so mulitply by 2 to get twips
+			cf.yHeight = GetSize() * 2;
+		}
+
+		if((m_cf.Flags & CF_NOFACESEL) == 0)
+		{
+			cf.dwMask |= CFM_FACE;
+			cf.bPitchAndFamily = m_cf.lpLogFont->lfPitchAndFamily;
+#if (_RICHEDIT_VER >= 0x0200)
+			SecureHelper::strcpy_x(cf.szFaceName, _countof(cf.szFaceName), GetFaceName());
+#else // !(_RICHEDIT_VER >= 0x0200)
+			SecureHelper::strcpyA_x(cf.szFaceName, _countof(cf.szFaceName), T2A((LPTSTR)(LPCTSTR)GetFaceName()));
+#endif // !(_RICHEDIT_VER >= 0x0200)
+		}
+
+		if((m_cf.Flags & CF_EFFECTS) != 0)
+		{
+			cf.dwMask |= CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR;
+			cf.dwEffects |= IsUnderline() ? CFE_UNDERLINE : 0;
+			cf.dwEffects |= IsStrikeOut() ? CFE_STRIKEOUT : 0;
+			cf.crTextColor = GetColor();
+		}
+		if((m_cf.Flags & CF_NOSCRIPTSEL) == 0)
+		{
+			cf.bCharSet = m_cf.lpLogFont->lfCharSet;
+			cf.dwMask |= CFM_CHARSET;
+		}
+		cf.yOffset = 0;
+	}
+
+	DWORD FillInLogFont(const CHARFORMAT& cf)
+	{
+		USES_CONVERSION;
+		DWORD dwFlags = 0;
+		if((cf.dwMask & CFM_SIZE) != 0)
+		{
+			HDC hDC = ::CreateDC(_T("DISPLAY"), NULL, NULL, NULL);
+			LONG yPerInch = ::GetDeviceCaps(hDC, LOGPIXELSY);
+			m_lf.lfHeight = -(int)((cf.yHeight * yPerInch) / 1440);
+		}
+		else
+			m_lf.lfHeight = 0;
+
+		m_lf.lfWidth = 0;
+		m_lf.lfEscapement = 0;
+		m_lf.lfOrientation = 0;
+
+		if((cf.dwMask & (CFM_ITALIC | CFM_BOLD)) == (CFM_ITALIC | CFM_BOLD))
+		{
+			m_lf.lfWeight = ((cf.dwEffects & CFE_BOLD) != 0) ? FW_BOLD : FW_NORMAL;
+			m_lf.lfItalic = (BYTE)(((cf.dwEffects & CFE_ITALIC) != 0) ? TRUE : FALSE);
+		}
+		else
+		{
+			dwFlags |= CF_NOSTYLESEL;
+			m_lf.lfWeight = FW_DONTCARE;
+			m_lf.lfItalic = FALSE;
+		}
+
+		if((cf.dwMask & (CFM_UNDERLINE | CFM_STRIKEOUT | CFM_COLOR)) == (CFM_UNDERLINE|CFM_STRIKEOUT|CFM_COLOR))
+		{
+			dwFlags |= CF_EFFECTS;
+			m_lf.lfUnderline = (BYTE)(((cf.dwEffects & CFE_UNDERLINE) != 0) ? TRUE : FALSE);
+			m_lf.lfStrikeOut = (BYTE)(((cf.dwEffects & CFE_STRIKEOUT) != 0) ? TRUE : FALSE);
+		}
+		else
+		{
+			m_lf.lfUnderline = (BYTE)FALSE;
+			m_lf.lfStrikeOut = (BYTE)FALSE;
+		}
+
+		if((cf.dwMask & CFM_CHARSET) != 0)
+			m_lf.lfCharSet = cf.bCharSet;
+		else
+			dwFlags |= CF_NOSCRIPTSEL;
+		m_lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
+		m_lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
+		m_lf.lfQuality = DEFAULT_QUALITY;
+		if((cf.dwMask & CFM_FACE) != 0)
+		{
+			m_lf.lfPitchAndFamily = cf.bPitchAndFamily;
+#if (_RICHEDIT_VER >= 0x0200)
+			SecureHelper::strcpy_x(m_lf.lfFaceName, _countof(m_lf.lfFaceName), cf.szFaceName);
+#else // !(_RICHEDIT_VER >= 0x0200)
+			SecureHelper::strcpy_x(m_lf.lfFaceName, _countof(m_lf.lfFaceName), A2T((LPSTR)cf.szFaceName));
+#endif // !(_RICHEDIT_VER >= 0x0200)
+		}
+		else
+		{
+			m_lf.lfPitchAndFamily = DEFAULT_PITCH|FF_DONTCARE;
+			m_lf.lfFaceName[0] = (TCHAR)0;
+		}
+		return dwFlags;
+	}
+};
+
+class CRichEditFontDialog : public CRichEditFontDialogImpl<CRichEditFontDialog>
+{
+public:
+	CRichEditFontDialog(const CHARFORMAT& charformat,
+		DWORD dwFlags = CF_SCREENFONTS,
+		HDC hDCPrinter = NULL,
+		HWND hWndParent = NULL)
+		: CRichEditFontDialogImpl<CRichEditFontDialog>(charformat, dwFlags, hDCPrinter, hWndParent)
+	{ }
+
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+#endif // defined(_RICHEDIT_) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CColorDialogImpl - color selection
+
+#if !defined(_WIN32_WCE) || ((_WIN32_WCE > 420) && !(defined(WIN32_PLATFORM_WFSP) && (_WIN32_WCE > 0x0500)))
+
+#ifdef _WIN32_WCE
+  #pragma comment(lib, "commdlg.lib")
+
+  #ifndef SETRGBSTRING
+    #define SETRGBSTRING _T("commdlg_SetRGBColor")
+  #endif
+
+  #ifndef COLOROKSTRING
+    #define COLOROKSTRING _T("commdlg_ColorOK")
+  #endif
+#endif
+
+template <class T>
+class ATL_NO_VTABLE CColorDialogImpl : public CCommonDialogImplBase
+{
+public:
+	CHOOSECOLOR m_cc;
+
+// Constructor
+	CColorDialogImpl(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
+	{
+		memset(&m_cc, 0, sizeof(m_cc));
+
+		m_cc.lStructSize = sizeof(m_cc);
+		m_cc.lpCustColors = GetCustomColors();
+		m_cc.hwndOwner = hWndParent;
+		m_cc.Flags = dwFlags | CC_ENABLEHOOK;
+		m_cc.lpfnHook = (LPCCHOOKPROC)T::HookProc;
+
+		if(clrInit != 0)
+		{
+			m_cc.rgbResult = clrInit;
+			m_cc.Flags |= CC_RGBINIT;
+		}
+	}
+
+// Operations
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT((m_cc.Flags & CC_ENABLEHOOK) != 0);
+		ATLASSERT(m_cc.lpfnHook != NULL);   // can still be a user hook
+
+		if(m_cc.hwndOwner == NULL)          // set only if not specified before
+			m_cc.hwndOwner = hWndParent;
+
+		ATLASSERT(m_hWnd == NULL);
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
+
+		BOOL bRet = ::ChooseColor(&m_cc);
+
+		m_hWnd = NULL;
+
+		return bRet ? IDOK : IDCANCEL;
+	}
+
+	// Set the current color while dialog is displayed
+	void SetCurrentColor(COLORREF clr)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		SendMessage(_GetSetRGBMessage(), 0, (LPARAM)clr);
+	}
+
+	// Get the selected color after DoModal returns, or in OnColorOK
+	COLORREF GetColor() const
+	{
+		return m_cc.rgbResult;
+	}
+
+// Special override for the color dialog
+	static UINT_PTR APIENTRY HookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		if(uMsg != WM_INITDIALOG && uMsg != _GetColorOKMessage())
+			return 0;
+
+		LPCHOOSECOLOR lpCC = (LPCHOOSECOLOR)lParam;
+		CCommonDialogImplBase* pT = NULL;
+
+		if(uMsg == WM_INITDIALOG)
+		{
+			pT = (CCommonDialogImplBase*)ModuleHelper::ExtractCreateWndData();
+			lpCC->lCustData = (LPARAM)pT;
+			ATLASSERT(pT != NULL);
+			ATLASSERT(pT->m_hWnd == NULL);
+			ATLASSERT(::IsWindow(hWnd));
+			// subclass dialog's window
+			if(!pT->SubclassWindow(hWnd))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("Subclassing a Color common dialog failed\n"));
+				return 0;
+			}
+		}
+		else if(uMsg == _GetColorOKMessage())
+		{
+			pT = (CCommonDialogImplBase*)lpCC->lCustData;
+			ATLASSERT(pT != NULL);
+			ATLASSERT(::IsWindow(pT->m_hWnd));
+		}
+
+		// pass to the message map
+		LRESULT lRes;
+		if(pT->ProcessWindowMessage(pT->m_hWnd, uMsg, wParam, lParam, lRes, 0) == FALSE)
+			return 0;
+		return lRes;
+	}
+
+// Helpers
+	static COLORREF* GetCustomColors()
+	{
+		static COLORREF rgbCustomColors[16] =
+		{
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+			RGB(255, 255, 255), RGB(255, 255, 255), 
+		};
+
+		return rgbCustomColors;
+	}
+
+	static UINT _GetSetRGBMessage()
+	{
+		static UINT uSetRGBMessage = 0;
+		if(uSetRGBMessage == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CColorDialogImpl::_GetSetRGBMessage.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uSetRGBMessage == 0)
+				uSetRGBMessage = ::RegisterWindowMessage(SETRGBSTRING);
+
+			lock.Unlock();
+		}
+		ATLASSERT(uSetRGBMessage != 0);
+		return uSetRGBMessage;
+	}
+
+	static UINT _GetColorOKMessage()
+	{
+		static UINT uColorOKMessage = 0;
+		if(uColorOKMessage == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CColorDialogImpl::_GetColorOKMessage.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uColorOKMessage == 0)
+				uColorOKMessage = ::RegisterWindowMessage(COLOROKSTRING);
+
+			lock.Unlock();
+		}
+		ATLASSERT(uColorOKMessage != 0);
+		return uColorOKMessage;
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CColorDialogImpl)
+		MESSAGE_HANDLER(_GetColorOKMessage(), _OnColorOK)
+	END_MSG_MAP()
+
+	LRESULT _OnColorOK(UINT, WPARAM, LPARAM, BOOL&)
+	{
+		T* pT = static_cast<T*>(this);
+		return pT->OnColorOK();
+	}
+
+// Overrideable
+	BOOL OnColorOK()        // validate color
+	{
+		return FALSE;
+	}
+};
+
+class CColorDialog : public CColorDialogImpl<CColorDialog>
+{
+public:
+	CColorDialog(COLORREF clrInit = 0, DWORD dwFlags = 0, HWND hWndParent = NULL)
+		: CColorDialogImpl<CColorDialog>(clrInit, dwFlags, hWndParent)
+	{ }
+
+	// override base class map and references to handlers
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+#endif // !defined(_WIN32_WCE) || ((_WIN32_WCE > 420) && !(defined(WIN32_PLATFORM_WFSP) && (_WIN32_WCE > 0x0500)))
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrintDialogImpl - used for Print... and PrintSetup...
+
+#ifndef _WIN32_WCE
+
+// global helper
+static HDC _AtlCreateDC(HGLOBAL hDevNames, HGLOBAL hDevMode)
+{
+	if(hDevNames == NULL)
+		return NULL;
+
+	LPDEVNAMES lpDevNames = (LPDEVNAMES)::GlobalLock(hDevNames);
+	LPDEVMODE  lpDevMode = (hDevMode != NULL) ? (LPDEVMODE)::GlobalLock(hDevMode) : NULL;
+
+	if(lpDevNames == NULL)
+		return NULL;
+
+	HDC hDC = ::CreateDC((LPCTSTR)lpDevNames + lpDevNames->wDriverOffset,
+					  (LPCTSTR)lpDevNames + lpDevNames->wDeviceOffset,
+					  (LPCTSTR)lpDevNames + lpDevNames->wOutputOffset,
+					  lpDevMode);
+
+	::GlobalUnlock(hDevNames);
+	if(hDevMode != NULL)
+		::GlobalUnlock(hDevMode);
+	return hDC;
+}
+
+template <class T>
+class ATL_NO_VTABLE CPrintDialogImpl : public CCommonDialogImplBase
+{
+public:
+	// print dialog parameter block (note this is a reference)
+	PRINTDLG& m_pd;
+
+// Constructors
+	CPrintDialogImpl(BOOL bPrintSetupOnly = FALSE,	// TRUE for Print Setup, FALSE for Print Dialog
+			DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION,
+			HWND hWndParent = NULL)
+			: m_pd(m_pdActual)
+	{
+		memset(&m_pdActual, 0, sizeof(m_pdActual));
+
+		m_pd.lStructSize = sizeof(m_pdActual);
+		m_pd.hwndOwner = hWndParent;
+		m_pd.Flags = (dwFlags | PD_ENABLEPRINTHOOK | PD_ENABLESETUPHOOK);
+		m_pd.lpfnPrintHook = (LPPRINTHOOKPROC)T::HookProc;
+		m_pd.lpfnSetupHook = (LPSETUPHOOKPROC)T::HookProc;
+
+		if(bPrintSetupOnly)
+			m_pd.Flags |= PD_PRINTSETUP;
+		else
+			m_pd.Flags |= PD_RETURNDC;
+
+		m_pd.Flags &= ~PD_RETURNIC; // do not support information context
+	}
+
+// Operations
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT((m_pd.Flags & PD_ENABLEPRINTHOOK) != 0);
+		ATLASSERT((m_pd.Flags & PD_ENABLESETUPHOOK) != 0);
+		ATLASSERT(m_pd.lpfnPrintHook != NULL);   // can still be a user hook
+		ATLASSERT(m_pd.lpfnSetupHook != NULL);   // can still be a user hook
+		ATLASSERT((m_pd.Flags & PD_RETURNDEFAULT) == 0);   // use GetDefaults for this
+
+		if(m_pd.hwndOwner == NULL)   // set only if not specified before
+			m_pd.hwndOwner = hWndParent;
+
+		ATLASSERT(m_hWnd == NULL);
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
+
+		BOOL bRet = ::PrintDlg(&m_pd);
+
+		m_hWnd = NULL;
+
+		return bRet ? IDOK : IDCANCEL;
+	}
+
+	// GetDefaults will not display a dialog but will get device defaults
+	BOOL GetDefaults()
+	{
+		m_pd.Flags |= PD_RETURNDEFAULT;
+		ATLASSERT(m_pd.hDevMode == NULL);    // must be NULL
+		ATLASSERT(m_pd.hDevNames == NULL);   // must be NULL
+
+		return ::PrintDlg(&m_pd);
+	}
+
+	// Helpers for parsing information after successful return num. copies requested
+	int GetCopies() const
+	{
+		if((m_pd.Flags & PD_USEDEVMODECOPIES) != 0)
+		{
+			LPDEVMODE lpDevMode = GetDevMode();
+			return (lpDevMode != NULL) ? lpDevMode->dmCopies : -1;
+		}
+
+		return m_pd.nCopies;
+	}
+
+	BOOL PrintCollate() const       // TRUE if collate checked
+	{
+		return ((m_pd.Flags & PD_COLLATE) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL PrintSelection() const     // TRUE if printing selection
+	{
+		return ((m_pd.Flags & PD_SELECTION) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL PrintAll() const           // TRUE if printing all pages
+	{
+		return (!PrintRange() && !PrintSelection()) ? TRUE : FALSE;
+	}
+
+	BOOL PrintRange() const         // TRUE if printing page range
+	{
+		return ((m_pd.Flags & PD_PAGENUMS) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL PrintToFile() const        // TRUE if printing to a file
+	{
+		return ((m_pd.Flags & PD_PRINTTOFILE) != 0) ? TRUE : FALSE;
+	}
+
+	int GetFromPage() const         // starting page if valid
+	{
+		return PrintRange() ? m_pd.nFromPage : -1;
+	}
+
+	int GetToPage() const           // ending page if valid
+	{
+		return PrintRange() ? m_pd.nToPage : -1;
+	}
+
+	LPDEVMODE GetDevMode() const    // return DEVMODE
+	{
+		if(m_pd.hDevMode == NULL)
+			return NULL;
+
+		return (LPDEVMODE)::GlobalLock(m_pd.hDevMode);
+	}
+
+	LPCTSTR GetDriverName() const   // return driver name
+	{
+		if(m_pd.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
+		if(lpDev == NULL)
+			return NULL;
+
+		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
+	}
+
+	LPCTSTR GetDeviceName() const   // return device name
+	{
+		if(m_pd.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
+		if(lpDev == NULL)
+			return NULL;
+
+		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
+	}
+
+	LPCTSTR GetPortName() const     // return output port name
+	{
+		if(m_pd.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pd.hDevNames);
+		if(lpDev == NULL)
+			return NULL;
+
+		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
+	}
+
+	HDC GetPrinterDC() const        // return HDC (caller must delete)
+	{
+		ATLASSERT((m_pd.Flags & PD_RETURNDC) != 0);
+		return m_pd.hDC;
+	}
+
+	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
+	// This DC is returned, but also stored in m_pd.hDC as though it had been
+	// returned by CommDlg.  It is assumed that any previously obtained DC
+	// has been/will be deleted by the user.  This may be
+	// used without ever invoking the print/print setup dialogs.
+	HDC CreatePrinterDC()
+	{
+		m_pd.hDC = _AtlCreateDC(m_pd.hDevNames, m_pd.hDevMode);
+		return m_pd.hDC;
+	}
+
+// Implementation
+	PRINTDLG m_pdActual; // the Print/Print Setup need to share this
+
+	// The following handle the case of print setup... from the print dialog
+	CPrintDialogImpl(PRINTDLG& pdInit) : m_pd(pdInit)
+	{ }
+
+	BEGIN_MSG_MAP(CPrintDialogImpl)
+#ifdef psh1
+		COMMAND_ID_HANDLER(psh1, OnPrintSetup) // print setup button when print is displayed
+#else // !psh1
+		COMMAND_ID_HANDLER(0x0400, OnPrintSetup) // value from dlgs.h
+#endif // !psh1
+	END_MSG_MAP()
+
+	LRESULT OnPrintSetup(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& /*bHandled*/)
+	{
+		T dlgSetup(m_pd);
+		ModuleHelper::AddCreateWndData(&dlgSetup.m_thunk.cd, (CCommonDialogImplBase*)&dlgSetup);
+		return DefWindowProc(WM_COMMAND, MAKEWPARAM(wID, wNotifyCode), (LPARAM)hWndCtl);
+	}
+};
+
+class CPrintDialog : public CPrintDialogImpl<CPrintDialog>
+{
+public:
+	CPrintDialog(BOOL bPrintSetupOnly = FALSE,
+		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION,
+		HWND hWndParent = NULL)
+		: CPrintDialogImpl<CPrintDialog>(bPrintSetupOnly, dwFlags, hWndParent)
+	{ }
+
+	CPrintDialog(PRINTDLG& pdInit) : CPrintDialogImpl<CPrintDialog>(pdInit)
+	{ }
+};
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrintDialogExImpl - new print dialog for Windows 2000
+
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+
+}; // namespace WTL
+
+#include <atlcom.h>
+
+extern "C" const __declspec(selectany) IID IID_IPrintDialogCallback = {0x5852a2c3, 0x6530, 0x11d1, {0xb6, 0xa3, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};
+extern "C" const __declspec(selectany) IID IID_IPrintDialogServices = {0x509aaeda, 0x5639, 0x11d1, {0xb6, 0xa1, 0x0, 0x0, 0xf8, 0x75, 0x7b, 0xf9}};
+
+namespace WTL
+{
+
+template <class T>
+class ATL_NO_VTABLE CPrintDialogExImpl : 
+				public ATL::CWindow,
+				public ATL::CMessageMap,
+				public IPrintDialogCallback,
+				public ATL::IObjectWithSiteImpl< T >
+{
+public:
+	PRINTDLGEX m_pdex;
+
+// Constructor
+	CPrintDialogExImpl(DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION | PD_NOCURRENTPAGE,
+				HWND hWndParent = NULL)
+	{
+		memset(&m_pdex, 0, sizeof(m_pdex));
+
+		m_pdex.lStructSize = sizeof(PRINTDLGEX);
+		m_pdex.hwndOwner = hWndParent;
+		m_pdex.Flags = dwFlags;
+		m_pdex.nStartPage = START_PAGE_GENERAL;
+		// callback object will be set in DoModal
+
+		m_pdex.Flags &= ~PD_RETURNIC; // do not support information context
+	}
+
+// Operations
+	HRESULT DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT(m_hWnd == NULL);
+		ATLASSERT((m_pdex.Flags & PD_RETURNDEFAULT) == 0);   // use GetDefaults for this
+
+		if(m_pdex.hwndOwner == NULL)   // set only if not specified before
+			m_pdex.hwndOwner = hWndParent;
+
+		T* pT = static_cast<T*>(this);
+		m_pdex.lpCallback = (IUnknown*)(IPrintDialogCallback*)pT;
+
+		HRESULT hResult = ::PrintDlgEx(&m_pdex);
+
+		m_hWnd = NULL;
+
+		return hResult;
+	}
+
+	BOOL EndDialog(INT_PTR /*nRetCode*/ = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		SendMessage(WM_COMMAND, MAKEWPARAM(IDABORT, 0));
+		return TRUE;
+	}
+
+	// GetDefaults will not display a dialog but will get device defaults
+	HRESULT GetDefaults()
+	{
+		m_pdex.Flags |= PD_RETURNDEFAULT;
+		ATLASSERT(m_pdex.hDevMode == NULL);    // must be NULL
+		ATLASSERT(m_pdex.hDevNames == NULL);   // must be NULL
+
+		return ::PrintDlgEx(&m_pdex);
+	}
+
+	// Helpers for parsing information after successful return num. copies requested
+	int GetCopies() const
+	{
+		if((m_pdex.Flags & PD_USEDEVMODECOPIES) != 0)
+		{
+			LPDEVMODE lpDevMode = GetDevMode();
+			return (lpDevMode != NULL) ? lpDevMode->dmCopies : -1;
+		}
+
+		return m_pdex.nCopies;
+	}
+
+	BOOL PrintCollate() const       // TRUE if collate checked
+	{
+		return ((m_pdex.Flags & PD_COLLATE) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL PrintSelection() const     // TRUE if printing selection
+	{
+		return ((m_pdex.Flags & PD_SELECTION) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL PrintAll() const           // TRUE if printing all pages
+	{
+		return (!PrintRange() && !PrintSelection()) ? TRUE : FALSE;
+	}
+
+	BOOL PrintRange() const         // TRUE if printing page range
+	{
+		return ((m_pdex.Flags & PD_PAGENUMS) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL PrintToFile() const        // TRUE if printing to a file
+	{
+		return ((m_pdex.Flags & PD_PRINTTOFILE) != 0) ? TRUE : FALSE;
+	}
+
+	LPDEVMODE GetDevMode() const    // return DEVMODE
+	{
+		if(m_pdex.hDevMode == NULL)
+			return NULL;
+
+		return (LPDEVMODE)::GlobalLock(m_pdex.hDevMode);
+	}
+
+	LPCTSTR GetDriverName() const   // return driver name
+	{
+		if(m_pdex.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
+		if(lpDev == NULL)
+			return NULL;
+
+		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
+	}
+
+	LPCTSTR GetDeviceName() const   // return device name
+	{
+		if(m_pdex.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
+		if(lpDev == NULL)
+			return NULL;
+
+		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
+	}
+
+	LPCTSTR GetPortName() const     // return output port name
+	{
+		if(m_pdex.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_pdex.hDevNames);
+		if(lpDev == NULL)
+			return NULL;
+
+		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
+	}
+
+	HDC GetPrinterDC() const        // return HDC (caller must delete)
+	{
+		ATLASSERT((m_pdex.Flags & PD_RETURNDC) != 0);
+		return m_pdex.hDC;
+	}
+
+	// This helper creates a DC based on the DEVNAMES and DEVMODE structures.
+	// This DC is returned, but also stored in m_pdex.hDC as though it had been
+	// returned by CommDlg.  It is assumed that any previously obtained DC
+	// has been/will be deleted by the user.  This may be
+	// used without ever invoking the print/print setup dialogs.
+	HDC CreatePrinterDC()
+	{
+		m_pdex.hDC = _AtlCreateDC(m_pdex.hDevNames, m_pdex.hDevMode);
+		return m_pdex.hDC;
+	}
+
+// Implementation - interfaces
+
+// IUnknown
+	STDMETHOD(QueryInterface)(REFIID riid, void** ppvObject)
+	{
+		if(ppvObject == NULL)
+			return E_POINTER;
+
+		T* pT = static_cast<T*>(this);
+		if(IsEqualGUID(riid, IID_IUnknown) || IsEqualGUID(riid, IID_IPrintDialogCallback))
+		{
+			*ppvObject = (IPrintDialogCallback*)pT;
+			// AddRef() not needed
+			return S_OK;
+		}
+		else if(IsEqualGUID(riid, IID_IObjectWithSite))
+		{
+			*ppvObject = (IObjectWithSite*)pT;
+			// AddRef() not needed
+			return S_OK;
+		}
+
+		return E_NOINTERFACE;
+	}
+
+	virtual ULONG STDMETHODCALLTYPE AddRef()
+	{
+		return 1;
+	}
+
+	virtual ULONG STDMETHODCALLTYPE Release()
+	{
+		return 1;
+	}
+
+// IPrintDialogCallback
+	STDMETHOD(InitDone)()
+	{
+		return S_FALSE;
+	}
+
+	STDMETHOD(SelectionChange)()
+	{
+		return S_FALSE;
+	}
+
+	STDMETHOD(HandleMessage)(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult)
+	{
+		// set up m_hWnd the first time
+		if(m_hWnd == NULL)
+			Attach(hWnd);
+
+		// call message map
+		HRESULT hRet = ProcessWindowMessage(hWnd, uMsg, wParam, lParam, *plResult, 0) ? S_OK : S_FALSE;
+		if(hRet == S_OK && uMsg == WM_NOTIFY)   // return in DWLP_MSGRESULT
+			::SetWindowLongPtr(GetParent(), DWLP_MSGRESULT, (LONG_PTR)*plResult);
+
+		if(uMsg == WM_INITDIALOG && hRet == S_OK && (BOOL)*plResult != FALSE)
+			hRet = S_FALSE;
+
+		return hRet;
+	}
+};
+
+class CPrintDialogEx : public CPrintDialogExImpl<CPrintDialogEx>
+{
+public:
+	CPrintDialogEx(
+		DWORD dwFlags = PD_ALLPAGES | PD_USEDEVMODECOPIES | PD_NOPAGENUMS | PD_NOSELECTION | PD_NOCURRENTPAGE,
+		HWND hWndParent = NULL)
+		: CPrintDialogExImpl<CPrintDialogEx>(dwFlags, hWndParent)
+	{ }
+
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPageSetupDialogImpl - Page Setup dialog
+
+#ifndef _WIN32_WCE
+
+template <class T>
+class ATL_NO_VTABLE CPageSetupDialogImpl : public CCommonDialogImplBase
+{
+public:
+	PAGESETUPDLG m_psd;
+	ATL::CWndProcThunk m_thunkPaint;
+
+// Constructors
+	CPageSetupDialogImpl(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
+	{
+		memset(&m_psd, 0, sizeof(m_psd));
+
+		m_psd.lStructSize = sizeof(m_psd);
+		m_psd.hwndOwner = hWndParent;
+		m_psd.Flags = (dwFlags | PSD_ENABLEPAGESETUPHOOK | PSD_ENABLEPAGEPAINTHOOK);
+		m_psd.lpfnPageSetupHook = (LPPAGESETUPHOOK)T::HookProc;
+		m_thunkPaint.Init((WNDPROC)T::PaintHookProc, this);
+#if (_ATL_VER >= 0x0700)
+		m_psd.lpfnPagePaintHook = (LPPAGEPAINTHOOK)m_thunkPaint.GetWNDPROC();
+#else
+		m_psd.lpfnPagePaintHook = (LPPAGEPAINTHOOK)&(m_thunkPaint.thunk);
+#endif
+	}
+
+	DECLARE_EMPTY_MSG_MAP()
+
+// Attributes
+	LPDEVMODE GetDevMode() const    // return DEVMODE
+	{
+		if(m_psd.hDevMode == NULL)
+			return NULL;
+
+		return (LPDEVMODE)::GlobalLock(m_psd.hDevMode);
+	}
+
+	LPCTSTR GetDriverName() const   // return driver name
+	{
+		if(m_psd.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
+		return (LPCTSTR)lpDev + lpDev->wDriverOffset;
+	}
+
+	LPCTSTR GetDeviceName() const   // return device name
+	{
+		if(m_psd.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
+		return (LPCTSTR)lpDev + lpDev->wDeviceOffset;
+	}
+
+	LPCTSTR GetPortName() const     // return output port name
+	{
+		if(m_psd.hDevNames == NULL)
+			return NULL;
+
+		LPDEVNAMES lpDev = (LPDEVNAMES)::GlobalLock(m_psd.hDevNames);
+		return (LPCTSTR)lpDev + lpDev->wOutputOffset;
+	}
+
+	HDC CreatePrinterDC()
+	{
+		return _AtlCreateDC(m_psd.hDevNames, m_psd.hDevMode);
+	}
+
+	SIZE GetPaperSize() const
+	{
+		SIZE size;
+		size.cx = m_psd.ptPaperSize.x;
+		size.cy = m_psd.ptPaperSize.y;
+		return size;
+	}
+
+	void GetMargins(LPRECT lpRectMargins, LPRECT lpRectMinMargins) const
+	{
+		if(lpRectMargins != NULL)
+			*lpRectMargins = m_psd.rtMargin;
+		if(lpRectMinMargins != NULL)
+			*lpRectMinMargins = m_psd.rtMinMargin;
+	}
+
+// Operations
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT((m_psd.Flags & PSD_ENABLEPAGESETUPHOOK) != 0);
+		ATLASSERT((m_psd.Flags & PSD_ENABLEPAGEPAINTHOOK) != 0);
+		ATLASSERT(m_psd.lpfnPageSetupHook != NULL);   // can still be a user hook
+		ATLASSERT(m_psd.lpfnPagePaintHook != NULL);   // can still be a user hook
+
+		if(m_psd.hwndOwner == NULL)   // set only if not specified before
+			m_psd.hwndOwner = hWndParent;
+
+		ATLASSERT(m_hWnd == NULL);
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
+
+		BOOL bRet = ::PageSetupDlg(&m_psd);
+
+		m_hWnd = NULL;
+
+		return bRet ? IDOK : IDCANCEL;
+	}
+
+// Implementation
+	static UINT_PTR CALLBACK PaintHookProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		T* pT = (T*)hWnd;
+		UINT_PTR uRet = 0;
+		switch(uMsg)
+		{
+		case WM_PSD_PAGESETUPDLG:
+			uRet = pT->PreDrawPage(LOWORD(wParam), HIWORD(wParam), (LPPAGESETUPDLG)lParam);
+			break;
+		case WM_PSD_FULLPAGERECT:
+		case WM_PSD_MINMARGINRECT:
+		case WM_PSD_MARGINRECT:
+		case WM_PSD_GREEKTEXTRECT:
+		case WM_PSD_ENVSTAMPRECT:
+		case WM_PSD_YAFULLPAGERECT:
+			uRet = pT->OnDrawPage(uMsg, (HDC)wParam, (LPRECT)lParam);
+			break;
+		default:
+			ATLTRACE2(atlTraceUI, 0, _T("CPageSetupDialogImpl::PaintHookProc - unknown message received\n"));
+			break;
+		}
+		return uRet;
+	}
+
+// Overridables
+	UINT_PTR PreDrawPage(WORD /*wPaper*/, WORD /*wFlags*/, LPPAGESETUPDLG /*pPSD*/)
+	{
+		// return 1 to prevent any more drawing
+		return 0;
+	}
+
+	UINT_PTR OnDrawPage(UINT /*uMsg*/, HDC /*hDC*/, LPRECT /*lpRect*/)
+	{
+		return 0; // do the default
+	}
+};
+
+class CPageSetupDialog : public CPageSetupDialogImpl<CPageSetupDialog>
+{
+public:
+	CPageSetupDialog(DWORD dwFlags = PSD_MARGINS | PSD_INWININIINTLMEASURE, HWND hWndParent = NULL)
+		: CPageSetupDialogImpl<CPageSetupDialog>(dwFlags, hWndParent)
+	{ }
+
+	// override PaintHookProc and references to handlers
+	static UINT_PTR CALLBACK PaintHookProc(HWND, UINT, WPARAM, LPARAM)
+	{
+		return 0;
+	}
+};
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFindReplaceDialogImpl - Find/FindReplace modeless dialogs
+
+#ifndef _WIN32_WCE
+
+template <class T>
+class ATL_NO_VTABLE CFindReplaceDialogImpl : public CCommonDialogImplBase
+{
+public:
+	enum { _cchFindReplaceBuffer = 128 };
+
+	FINDREPLACE m_fr;
+	TCHAR m_szFindWhat[_cchFindReplaceBuffer];
+	TCHAR m_szReplaceWith[_cchFindReplaceBuffer];
+
+// Constructors
+	CFindReplaceDialogImpl()
+	{
+		memset(&m_fr, 0, sizeof(m_fr));
+		m_szFindWhat[0] = _T('\0');
+		m_szReplaceWith[0] = _T('\0');
+
+		m_fr.lStructSize = sizeof(m_fr);
+		m_fr.Flags = FR_ENABLEHOOK;
+		m_fr.lpfnHook = (LPFRHOOKPROC)T::HookProc;
+		m_fr.lpstrFindWhat = (LPTSTR)m_szFindWhat;
+		m_fr.wFindWhatLen = _cchFindReplaceBuffer;
+		m_fr.lpstrReplaceWith = (LPTSTR)m_szReplaceWith;
+		m_fr.wReplaceWithLen = _cchFindReplaceBuffer;
+	}
+
+	// Note: You must allocate the object on the heap.
+	//       If you do not, you must override OnFinalMessage()
+	virtual void OnFinalMessage(HWND /*hWnd*/)
+	{
+		delete this;
+	}
+
+	HWND Create(BOOL bFindDialogOnly, // TRUE for Find, FALSE for FindReplace
+			LPCTSTR lpszFindWhat,
+			LPCTSTR lpszReplaceWith = NULL,
+			DWORD dwFlags = FR_DOWN,
+			HWND hWndParent = NULL)
+	{
+		ATLASSERT((m_fr.Flags & FR_ENABLEHOOK) != 0);
+		ATLASSERT(m_fr.lpfnHook != NULL);
+
+		m_fr.Flags |= dwFlags;
+
+		if(hWndParent == NULL)
+			m_fr.hwndOwner = ::GetActiveWindow();
+		else
+			m_fr.hwndOwner = hWndParent;
+		ATLASSERT(m_fr.hwndOwner != NULL); // must have an owner for modeless dialog
+
+		if(lpszFindWhat != NULL)
+			SecureHelper::strncpy_x(m_szFindWhat, _countof(m_szFindWhat), lpszFindWhat, _TRUNCATE);
+
+		if(lpszReplaceWith != NULL)
+			SecureHelper::strncpy_x(m_szReplaceWith, _countof(m_szReplaceWith), lpszReplaceWith, _TRUNCATE);
+
+		ATLASSERT(m_hWnd == NULL);
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, (CCommonDialogImplBase*)this);
+
+		HWND hWnd = NULL;
+		if(bFindDialogOnly)
+			hWnd = ::FindText(&m_fr);
+		else
+			hWnd = ::ReplaceText(&m_fr);
+
+		ATLASSERT(m_hWnd == hWnd);
+		return hWnd;
+	}
+
+	static const UINT GetFindReplaceMsg()
+	{
+		static const UINT nMsgFindReplace = ::RegisterWindowMessage(FINDMSGSTRING);
+		return nMsgFindReplace;
+	}
+	// call while handling FINDMSGSTRING registered message
+	// to retreive the object
+	static T* PASCAL GetNotifier(LPARAM lParam)
+	{
+		ATLASSERT(lParam != NULL);
+		T* pDlg = (T*)(lParam - offsetof(T, m_fr));
+		return pDlg;
+	}
+
+// Operations
+	// Helpers for parsing information after successful return
+	LPCTSTR GetFindString() const    // get find string
+	{
+		return (LPCTSTR)m_fr.lpstrFindWhat;
+	}
+
+	LPCTSTR GetReplaceString() const // get replacement string
+	{
+		return (LPCTSTR)m_fr.lpstrReplaceWith;
+	}
+
+	BOOL SearchDown() const          // TRUE if search down, FALSE is up
+	{
+		return ((m_fr.Flags & FR_DOWN) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL FindNext() const            // TRUE if command is find next
+	{
+		return ((m_fr.Flags & FR_FINDNEXT) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL MatchCase() const           // TRUE if matching case
+	{
+		return ((m_fr.Flags & FR_MATCHCASE) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL MatchWholeWord() const      // TRUE if matching whole words only
+	{
+		return ((m_fr.Flags & FR_WHOLEWORD) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL ReplaceCurrent() const      // TRUE if replacing current string
+	{
+		return ((m_fr. Flags & FR_REPLACE) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL ReplaceAll() const          // TRUE if replacing all occurrences
+	{
+		return ((m_fr.Flags & FR_REPLACEALL) != 0) ? TRUE : FALSE;
+	}
+
+	BOOL IsTerminating() const       // TRUE if terminating dialog
+	{
+		return ((m_fr.Flags & FR_DIALOGTERM) != 0) ? TRUE : FALSE ;
+	}
+};
+
+class CFindReplaceDialog : public CFindReplaceDialogImpl<CFindReplaceDialog>
+{
+public:
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+#endif // !_WIN32_WCE
+
+
+/////////////////////////////////////////////////////////////////////////
+// CDialogBaseUnits - Dialog Units helper
+//
+
+class CDialogBaseUnits
+{
+public:
+	SIZE m_sizeUnits;
+
+// Constructors
+	CDialogBaseUnits()
+	{
+		// The base units of the out-dated System Font
+		LONG nDlgBaseUnits = ::GetDialogBaseUnits();
+		m_sizeUnits.cx = LOWORD(nDlgBaseUnits);
+		m_sizeUnits.cy = HIWORD(nDlgBaseUnits);
+	}
+
+	CDialogBaseUnits(HWND hWnd)
+	{
+		if(!InitDialogBaseUnits(hWnd)) {
+			LONG nDlgBaseUnits = ::GetDialogBaseUnits();
+			m_sizeUnits.cx = LOWORD(nDlgBaseUnits);
+			m_sizeUnits.cy = HIWORD(nDlgBaseUnits);
+		}
+	}
+
+	CDialogBaseUnits(HFONT hFont, HWND hWnd = NULL)
+	{
+		if(!InitDialogBaseUnits(hFont, hWnd)) {
+			LONG nDlgBaseUnits = ::GetDialogBaseUnits();
+			m_sizeUnits.cx = LOWORD(nDlgBaseUnits);
+			m_sizeUnits.cy = HIWORD(nDlgBaseUnits);
+		}
+	}
+
+	CDialogBaseUnits(LOGFONT lf, HWND hWnd = NULL)
+	{
+		if(!InitDialogBaseUnits(lf, hWnd)) {
+			LONG nDlgBaseUnits = ::GetDialogBaseUnits();
+			m_sizeUnits.cx = LOWORD(nDlgBaseUnits);
+			m_sizeUnits.cy = HIWORD(nDlgBaseUnits);
+		}
+	}
+
+// Operations
+	BOOL InitDialogBaseUnits(HWND hWnd)
+	{
+		ATLASSERT(::IsWindow(hWnd));
+		RECT rc = { 0, 0, 4, 8 };
+		if(!::MapDialogRect(hWnd, &rc)) return FALSE;
+		m_sizeUnits.cx = rc.right;
+		m_sizeUnits.cy = rc.bottom;
+		return TRUE;
+	}
+
+	BOOL InitDialogBaseUnits(LOGFONT lf, HWND hWnd = NULL)
+	{
+		CFont font;
+		font.CreateFontIndirect(&lf);
+		if(font.IsNull()) return FALSE;
+		return InitDialogBaseUnits(font, hWnd);
+	}
+
+	BOOL InitDialogBaseUnits(HFONT hFont, HWND hWnd = NULL)
+	{
+		ATLASSERT(hFont != NULL);
+		CWindowDC dc = hWnd;
+		TEXTMETRIC tmText = { 0 };
+		SIZE sizeText = { 0 };
+		HFONT hFontOld = dc.SelectFont(hFont);
+		dc.GetTextMetrics(&tmText);
+		m_sizeUnits.cy = tmText.tmHeight + tmText.tmExternalLeading;
+		dc.GetTextExtent(_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52, &sizeText);
+		m_sizeUnits.cx = (sizeText.cx + 26) / 52;
+		dc.SelectFont(hFontOld);
+		return TRUE;
+	}
+
+	SIZE GetDialogBaseUnits() const
+	{
+		return m_sizeUnits;
+	}
+
+	INT MapDialogPixelsX(INT x) const
+	{
+		return ::MulDiv(x, 4, m_sizeUnits.cx);  // Pixels X to DLU
+	}
+
+	INT MapDialogPixelsY(INT y) const
+	{
+		return ::MulDiv(y, 8, m_sizeUnits.cy);  // Pixels Y to DLU
+	}
+
+	POINT MapDialogPixels(POINT pt) const
+	{
+		POINT out = { MapDialogPixelsX(pt.x), MapDialogPixelsY(pt.y) };
+		return out;
+	}
+
+	SIZE MapDialogPixels(SIZE input) const
+	{
+		SIZE out = { MapDialogPixelsX(input.cx), MapDialogPixelsY(input.cy) };
+		return out;
+	}
+
+	RECT MapDialogPixels(RECT input) const
+	{
+		RECT out = { MapDialogPixelsX(input.left), MapDialogPixelsY(input.top), MapDialogPixelsX(input.right), MapDialogPixelsY(input.bottom) };
+		return out;
+	}
+
+	INT MapDialogUnitsX(INT x) const
+	{
+		return ::MulDiv(x, m_sizeUnits.cx, 4);  // DLU to Pixels X
+	}
+
+	INT MapDialogUnitsY(INT y) const
+	{
+		return ::MulDiv(y, m_sizeUnits.cx, 8);  // DLU to Pixels Y
+	}
+
+	POINT MapDialogUnits(POINT pt) const
+	{
+		POINT out = { MapDialogUnitsX(pt.x), MapDialogUnitsY(pt.y) };
+		return out;
+	}
+
+	SIZE MapDialogUnits(SIZE input) const
+	{
+		SIZE out = { MapDialogUnitsX(input.cx), MapDialogUnitsY(input.cy) };
+		return out;
+	}
+
+	RECT MapDialogUnits(RECT input) const
+	{
+		RECT out = { MapDialogUnitsX(input.left), MapDialogUnitsY(input.top), MapDialogUnitsX(input.right), MapDialogUnitsY(input.bottom) };
+		return out;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMemDlgTemplate - in-memory dialog template - DLGTEMPLATE or DLGTEMPLATEEX
+
+#if (_ATL_VER >= 0x800)
+  typedef ATL::_DialogSplitHelper::DLGTEMPLATEEX DLGTEMPLATEEX;
+  typedef ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX DLGITEMTEMPLATEEX;
+#else // (_ATL_VER >= 0x800)
+  typedef ATL::_DialogSizeHelper::_ATL_DLGTEMPLATEEX DLGTEMPLATEEX;
+  #pragma pack(push, 4)
+  struct DLGITEMTEMPLATEEX
+  {
+	DWORD helpID;
+	DWORD exStyle;
+	DWORD style;
+	short x;
+	short y;
+	short cx;
+	short cy;
+	DWORD id;
+  };
+  #pragma pack(pop)
+#endif // (_ATL_VER >= 0x800)
+
+
+class CMemDlgTemplate
+{
+public:
+	enum StdCtrlType
+	{
+		CTRL_BUTTON    = 0x0080,
+		CTRL_EDIT      = 0x0081,
+		CTRL_STATIC    = 0x0082,
+		CTRL_LISTBOX   = 0x0083,
+		CTRL_SCROLLBAR = 0x0084,
+		CTRL_COMBOBOX  = 0x0085
+	};
+
+	CMemDlgTemplate() : m_hData(NULL), m_pData(NULL), m_pPtr(NULL), m_cAllocated(0)
+	{ }
+
+	~CMemDlgTemplate()
+	{
+		Reset();
+	}
+
+	bool IsValid() const
+	{
+		return (m_pData != NULL);
+	}
+
+	bool IsTemplateEx() const
+	{
+		return (IsValid() && ((DLGTEMPLATEEX*)m_pData)->signature == 0xFFFF);
+	}
+
+	LPDLGTEMPLATE GetTemplatePtr()
+	{
+		return reinterpret_cast<LPDLGTEMPLATE>(m_pData);
+	}
+
+	DLGTEMPLATEEX* GetTemplateExPtr()
+	{
+		return reinterpret_cast<DLGTEMPLATEEX*>(m_pData);
+	}
+
+	void Reset()
+	{
+		if (IsValid()) {
+#ifndef UNDER_CE
+			::GlobalUnlock(m_pData);
+#endif
+			ATLVERIFY(::GlobalFree(m_hData) == NULL);
+		}
+
+		m_hData = NULL;
+		m_pData = NULL;
+		m_pPtr = NULL;
+		m_cAllocated = 0;
+	}
+
+	void Create(bool bDlgEx, LPCTSTR lpszCaption, RECT rc, DWORD dwStyle = 0, DWORD dwExStyle = 0,
+		LPCTSTR lpstrFontName = NULL, WORD wFontSize = 0, WORD wWeight = 0, BYTE bItalic = 0, BYTE bCharset = 0, DWORD dwHelpID = 0,
+		ATL::_U_STRINGorID ClassName = 0U, ATL::_U_STRINGorID Menu = 0U)
+	{
+		Create(bDlgEx, lpszCaption, (short) rc.left, (short) rc.top, (short) (rc.right - rc.left), (short) (rc.bottom - rc.top), dwStyle, dwExStyle,
+			lpstrFontName, wFontSize, wWeight, bItalic, bCharset, dwHelpID, ClassName.m_lpstr, Menu.m_lpstr);
+	}
+
+	void Create(bool bDlgEx, LPCTSTR lpszCaption, short nX, short nY, short nWidth, short nHeight, DWORD dwStyle = 0, DWORD dwExStyle = 0,
+		LPCTSTR lpstrFontName = NULL, WORD wFontSize = 0, WORD wWeight = 0, BYTE bItalic = 0, BYTE bCharset = 0, DWORD dwHelpID = 0,
+		ATL::_U_STRINGorID ClassName = 0U, ATL::_U_STRINGorID Menu = 0U)
+	{
+		// Should have DS_SETFONT style to set the dialog font name and size
+		if (lpstrFontName != NULL)
+		{
+			dwStyle |= DS_SETFONT;
+		}
+		else
+		{
+			dwStyle &= ~DS_SETFONT;
+		}
+
+		if (bDlgEx)
+		{
+			DLGTEMPLATEEX dlg = {1, 0xFFFF, dwHelpID, dwExStyle, dwStyle, 0, nX, nY, nWidth, nHeight};
+			AddData(&dlg, sizeof(dlg));
+		}
+		else
+		{
+			DLGTEMPLATE dlg = {dwStyle, dwExStyle, 0, nX, nY, nWidth, nHeight};
+			AddData(&dlg, sizeof(dlg));
+		}
+
+#ifndef _WIN32_WCE
+		if (Menu.m_lpstr == NULL)
+		{
+			WORD menuData = 0;
+			AddData(&menuData, sizeof(WORD));
+		}
+		else if (IS_INTRESOURCE(Menu.m_lpstr))
+		{
+			WORD menuData[] = {0xFFFF, (WORD)Menu.m_lpstr};
+			AddData(menuData, sizeof(menuData));
+		}
+		else
+		{
+			AddString(Menu.m_lpstr);
+		}
+#else // _WIN32_WCE
+		// Windows CE doesn't support the addition of menus to a dialog box
+		ATLASSERT(Menu.m_lpstr == NULL);
+		Menu.m_lpstr;   // avoid level 4 warning
+		WORD menuData = 0;
+		AddData(&menuData, sizeof(WORD));
+#endif // _WIN32_WCE
+
+		if (ClassName.m_lpstr == NULL)
+		{
+			WORD classData = 0;
+			AddData(&classData, sizeof(WORD));
+		}
+		else if (IS_INTRESOURCE(ClassName.m_lpstr))
+		{
+			WORD classData[] = {0xFFFF, (WORD)ClassName.m_lpstr};
+			AddData(classData, sizeof(classData));
+		}
+		else
+		{
+			AddString(ClassName.m_lpstr);
+		}
+
+		// Set dialog caption
+		AddString(lpszCaption);
+
+		if (lpstrFontName != NULL)
+		{
+			AddData(&wFontSize, sizeof(wFontSize));
+
+			if (bDlgEx)
+			{
+				AddData(&wWeight, sizeof(wWeight));
+				AddData(&bItalic, sizeof(bItalic));
+				AddData(&bCharset, sizeof(bCharset));
+			}
+
+			AddString(lpstrFontName);
+		}
+	}
+
+	void AddControl(ATL::_U_STRINGorID ClassName, WORD wId, RECT rc, DWORD dwStyle, DWORD dwExStyle,
+	                ATL::_U_STRINGorID Text, const WORD* pCreationData = NULL, WORD nCreationData = 0, DWORD dwHelpID = 0)
+	{
+		AddControl(ClassName.m_lpstr, wId, (short) rc.left, (short) rc.top, (short) (rc.right - rc.left), (short) (rc.bottom - rc.top), dwStyle, dwExStyle,
+			Text.m_lpstr, pCreationData, nCreationData, dwHelpID);
+	}
+
+	void AddControl(ATL::_U_STRINGorID ClassName, WORD wId, short nX, short nY, short nWidth, short nHeight, DWORD dwStyle, DWORD dwExStyle,
+	                ATL::_U_STRINGorID Text, const WORD* pCreationData = NULL, WORD nCreationData = 0, DWORD dwHelpID = 0)
+	{
+		ATLASSERT(IsValid());
+
+		// DWORD align data
+		m_pPtr = (LPBYTE)(DWORD_PTR)((DWORD)(DWORD_PTR)(m_pPtr + 3) & (~3));
+
+		if (IsTemplateEx())
+		{
+			DLGTEMPLATEEX* dlg = (DLGTEMPLATEEX*)m_pData;
+			dlg->cDlgItems++;
+
+			DLGITEMTEMPLATEEX item = {dwHelpID, ATL::CControlWinTraits::GetWndExStyle(0) | dwExStyle, ATL::CControlWinTraits::GetWndStyle(0) | dwStyle, nX, nY, nWidth, nHeight, wId};
+			AddData(&item, sizeof(item));
+		}
+		else
+		{
+			LPDLGTEMPLATE dlg = (LPDLGTEMPLATE)m_pData;
+			dlg->cdit++;
+
+			DLGITEMTEMPLATE item = {ATL::CControlWinTraits::GetWndStyle(0) | dwStyle, ATL::CControlWinTraits::GetWndExStyle(0) | dwExStyle, nX, nY, nWidth, nHeight, wId};
+			AddData(&item, sizeof(item));
+		}
+
+		ATLASSERT(ClassName.m_lpstr != NULL);
+		if (IS_INTRESOURCE(ClassName.m_lpstr))
+		{
+			WORD wData[] = {0xFFFF, (WORD)ClassName.m_lpstr};
+			AddData(wData, sizeof(wData));
+		}
+		else
+		{
+			AddString(ClassName.m_lpstr);
+		}
+
+		if (Text.m_lpstr == NULL)
+		{
+			WORD classData = 0;
+			AddData(&classData, sizeof(WORD));
+		}
+		else if (IS_INTRESOURCE(Text.m_lpstr))
+		{
+			WORD wData[] = {0xFFFF, (WORD)Text.m_lpstr};
+			AddData(wData, sizeof(wData));
+		}
+		else
+		{
+			AddString(Text.m_lpstr);
+		}
+
+		AddData(&nCreationData, sizeof(nCreationData));
+
+		if ((nCreationData != 0))
+		{
+			ATLASSERT(pCreationData != NULL);
+			AddData(pCreationData, nCreationData * sizeof(WORD));
+		}
+	}
+
+	void AddStdControl(StdCtrlType CtrlType, WORD wId, short nX, short nY, short nWidth, short nHeight,
+	                   DWORD dwStyle, DWORD dwExStyle, ATL::_U_STRINGorID Text, const WORD* pCreationData = NULL, WORD nCreationData = 0, DWORD dwHelpID = 0)
+	{
+		AddControl(CtrlType, wId, nX, nY, nWidth, nHeight, dwStyle, dwExStyle, Text, pCreationData, nCreationData, dwHelpID);
+	}
+
+	void AddData(LPCVOID pData, size_t nData)
+	{
+		ATLASSERT(pData != NULL);
+
+		const SIZE_T ALLOCATION_INCREMENT = 1024;
+
+		if (m_pData == NULL)
+		{
+			m_cAllocated = ((nData / ALLOCATION_INCREMENT) + 1) * ALLOCATION_INCREMENT;
+			m_hData = ::GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT, m_cAllocated);
+			ATLASSERT(m_hData != NULL);
+#ifndef UNDER_CE
+			m_pPtr = m_pData = static_cast<LPBYTE>(::GlobalLock(m_hData));
+#else
+			m_pPtr = m_pData = static_cast<LPBYTE>(m_hData);
+#endif
+			ATLASSERT(m_pData != NULL);
+		}
+		else if (((m_pPtr - m_pData) + nData) > m_cAllocated)
+		{
+			SIZE_T ptrPos = (m_pPtr - m_pData);
+			m_cAllocated += ((nData / ALLOCATION_INCREMENT) + 1) * ALLOCATION_INCREMENT;
+#ifndef UNDER_CE
+			::GlobalUnlock(m_pData);
+#endif
+			m_hData = ::GlobalReAlloc(m_hData, m_cAllocated, GMEM_MOVEABLE | GMEM_ZEROINIT);
+			ATLASSERT(m_hData != NULL);
+#ifndef UNDER_CE
+			m_pData = static_cast<LPBYTE>(::GlobalLock(m_hData));
+#else
+			m_pData = static_cast<LPBYTE>(m_hData);
+#endif
+			ATLASSERT(m_pData != NULL);
+			m_pPtr = m_pData + ptrPos;
+		}
+
+		SecureHelper::memcpy_x(m_pPtr, m_cAllocated - (m_pPtr - m_pData), pData, nData);
+
+		m_pPtr += nData;
+	}
+
+	void AddString(LPCTSTR lpszStr)
+	{
+		if (lpszStr == NULL)
+		{
+			WCHAR szEmpty = 0;
+			AddData(&szEmpty, sizeof(szEmpty));
+		}
+		else
+		{
+			USES_CONVERSION;
+			LPCWSTR lpstr = T2CW(lpszStr);
+			int nSize = lstrlenW(lpstr) + 1;
+			AddData(lpstr, nSize * sizeof(WCHAR));
+		}
+	}
+
+	HANDLE m_hData;
+	LPBYTE m_pData;
+	LPBYTE m_pPtr;
+	SIZE_T m_cAllocated;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Dialog and control macros for indirect dialogs
+
+// for DLGTEMPLATE
+#define BEGIN_DIALOG(x, y, width, height) \
+	void DoInitTemplate() \
+	{ \
+		bool bExTemplate = false; \
+		short nX = x, nY = y, nWidth = width, nHeight = height; \
+		LPCTSTR szCaption = NULL; \
+		DWORD dwStyle = WS_POPUP | WS_BORDER | WS_SYSMENU; \
+		DWORD dwExStyle = 0; \
+		LPCTSTR szFontName = NULL; \
+		WORD wFontSize = 0; \
+		WORD wWeight = 0; \
+		BYTE bItalic = 0; \
+		BYTE bCharset = 0; \
+		DWORD dwHelpID = 0; \
+		ATL::_U_STRINGorID Menu = 0U; \
+		ATL::_U_STRINGorID ClassName = 0U;
+
+// for DLGTEMPLATEEX
+#define BEGIN_DIALOG_EX(x, y, width, height, helpID) \
+	void DoInitTemplate() \
+	{ \
+		bool bExTemplate = true; \
+		short nX = x, nY = y, nWidth = width, nHeight = height; \
+		LPCTSTR szCaption = NULL; \
+		DWORD dwStyle = WS_POPUP | WS_BORDER | WS_SYSMENU; \
+		DWORD dwExStyle = 0; \
+		LPCTSTR szFontName = NULL; \
+		WORD wFontSize = 0; \
+		WORD wWeight = 0; \
+		BYTE bItalic = 0; \
+		BYTE bCharset = 0; \
+		DWORD dwHelpID = helpID; \
+		ATL::_U_STRINGorID Menu = 0U; \
+		ATL::_U_STRINGorID ClassName = 0U;
+
+#define END_DIALOG() \
+		m_Template.Create(bExTemplate, szCaption, nX, nY, nWidth, nHeight, dwStyle, dwExStyle, szFontName, wFontSize, wWeight, bItalic, bCharset, dwHelpID, ClassName, Menu); \
+	};
+
+#define DIALOG_CAPTION(caption) \
+		szCaption = caption;
+#define DIALOG_STYLE(style) \
+		dwStyle = style;
+#define DIALOG_EXSTYLE(exStyle) \
+		dwExStyle = exStyle;
+#define DIALOG_FONT(pointSize, typeFace) \
+		wFontSize = pointSize; \
+		szFontName = typeFace;
+#define DIALOG_FONT_EX(pointsize, typeface, weight, italic, charset) \
+		ATLASSERT(bExTemplate); \
+		wFontSize = pointsize; \
+		szFontName = typeface; \
+		wWeight = weight; \
+		bItalic = italic; \
+		bCharset = charset;
+#define DIALOG_MENU(menuName) \
+		Menu = menuName;
+#define DIALOG_CLASS(className) \
+		ClassName = className;
+
+#define BEGIN_CONTROLS_MAP() \
+	void DoInitControls() \
+	{
+
+#define END_CONTROLS_MAP() \
+	};
+
+
+#define CONTROL_LTEXT(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_STATIC, (WORD)id, x, y, width, height, style | SS_LEFT | WS_GROUP, exStyle, text, NULL, 0);
+#define CONTROL_CTEXT(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_STATIC, (WORD)id, x, y, width, height, style | SS_CENTER | WS_GROUP, exStyle, text, NULL, 0);
+#define CONTROL_RTEXT(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_STATIC, (WORD)id, x, y, width, height, style | SS_RIGHT | WS_GROUP, exStyle, text, NULL, 0);
+#define CONTROL_PUSHBUTTON(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_PUSHBUTTON | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_DEFPUSHBUTTON(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_DEFPUSHBUTTON | WS_TABSTOP, exStyle, text, NULL, 0);
+#ifndef _WIN32_WCE
+#define CONTROL_PUSHBOX(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_PUSHBOX | WS_TABSTOP, exStyle, text, NULL, 0);
+#endif // !_WIN32_WCE
+#define CONTROL_STATE3(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_3STATE | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_AUTO3STATE(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_AUTO3STATE | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_CHECKBOX(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_CHECKBOX | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_AUTOCHECKBOX(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_AUTOCHECKBOX | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_RADIOBUTTON(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_RADIOBUTTON | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_AUTORADIOBUTTON(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_AUTORADIOBUTTON | WS_TABSTOP, exStyle, text, NULL, 0);
+#define CONTROL_COMBOBOX(id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_COMBOBOX, (WORD)id, x, y, width, height, style | CBS_DROPDOWN | WS_TABSTOP, exStyle, (LPCTSTR)NULL, NULL, 0);
+#define CONTROL_EDITTEXT(id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_EDIT, (WORD)id, x, y, width, height, style | ES_LEFT | WS_BORDER | WS_TABSTOP, exStyle, (LPCTSTR)NULL, NULL, 0);
+#define CONTROL_GROUPBOX(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_BUTTON, (WORD)id, x, y, width, height, style | BS_GROUPBOX, exStyle, text, NULL, 0);
+#define CONTROL_LISTBOX(id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_LISTBOX, (WORD)id, x, y, width, height, style | LBS_NOTIFY | WS_BORDER, exStyle, (LPCTSTR)NULL, NULL, 0);
+#define CONTROL_SCROLLBAR(id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_SCROLLBAR, (WORD)id, x, y, width, height, style | SBS_HORZ, exStyle, (LPCTSTR)NULL, NULL, 0);
+#define CONTROL_ICON(text, id, x, y, width, height, style, exStyle) \
+	m_Template.AddStdControl(WTL::CMemDlgTemplate::CTRL_STATIC, (WORD)id, x, y, width, height, style | SS_ICON, exStyle, text, NULL, 0);
+#define CONTROL_CONTROL(text, id, className, style, x, y, width, height, exStyle) \
+	m_Template.AddControl(className, (WORD)id, x, y, width, height, style, exStyle, text, NULL, 0);
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CIndirectDialogImpl - dialogs with template in memory
+
+template <class T, class TDlgTemplate = CMemDlgTemplate, class TBase = ATL::CDialogImpl<T, ATL::CWindow> >
+class ATL_NO_VTABLE CIndirectDialogImpl : public TBase
+{
+public:
+	enum { IDD = 0 };   // no dialog template resource
+
+	TDlgTemplate m_Template;
+
+	void CreateTemplate()
+	{
+		T* pT = static_cast<T*>(this);
+		pT->DoInitTemplate();
+		pT->DoInitControls();
+	}
+
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_hWnd == NULL);
+
+		if (!m_Template.IsValid())
+			CreateTemplate();
+
+#if (_ATL_VER >= 0x0800)
+		// Allocate the thunk structure here, where we can fail gracefully.
+		BOOL result = m_thunk.Init(NULL, NULL);
+		if (result == FALSE)
+		{
+			SetLastError(ERROR_OUTOFMEMORY);
+			return -1;
+		}
+#endif // (_ATL_VER >= 0x0800)
+
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, pT);
+
+#ifdef _DEBUG
+		m_bModal = true;
+#endif // _DEBUG
+
+		return ::DialogBoxIndirectParam(ModuleHelper::GetResourceInstance(), m_Template.GetTemplatePtr(), hWndParent, (DLGPROC)T::StartDialogProc, dwInitParam);
+	}
+
+	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->m_hWnd == NULL);
+
+		if (!m_Template.IsValid())
+			CreateTemplate();
+
+#if (_ATL_VER >= 0x0800)
+		// Allocate the thunk structure here, where we can fail gracefully.
+		BOOL result = m_thunk.Init(NULL, NULL);
+		if (result == FALSE) 
+		{
+			SetLastError(ERROR_OUTOFMEMORY);
+			return NULL;
+		}
+#endif // (_ATL_VER >= 0x0800)
+
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, pT);
+
+#ifdef _DEBUG
+		m_bModal = false;
+#endif // _DEBUG
+
+		HWND hWnd = ::CreateDialogIndirectParam(ModuleHelper::GetResourceInstance(), (LPCDLGTEMPLATE)m_Template.GetTemplatePtr(), hWndParent, (DLGPROC)T::StartDialogProc, dwInitParam);
+		ATLASSERT(m_hWnd == hWnd);
+
+		return hWnd;
+	}
+
+	// for CComControl
+	HWND Create(HWND hWndParent, RECT&, LPARAM dwInitParam = NULL)
+	{
+		return Create(hWndParent, dwInitParam);
+	}
+
+	void DoInitTemplate() 
+	{
+		ATLASSERT(FALSE);   // MUST be defined in derived class
+	}
+
+	void DoInitControls() 
+	{
+		ATLASSERT(FALSE);   // MUST be defined in derived class
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CPropertySheetWindow - client side for a property sheet
+
+class CPropertySheetWindow : public ATL::CWindow
+{
+public:
+// Constructors
+	CPropertySheetWindow(HWND hWnd = NULL) : ATL::CWindow(hWnd)
+	{ }
+
+	CPropertySheetWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Attributes
+	int GetPageCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HWND hWndTabCtrl = GetTabControl();
+		ATLASSERT(hWndTabCtrl != NULL);
+		return (int)::SendMessage(hWndTabCtrl, TCM_GETITEMCOUNT, 0, 0L);
+	}
+
+	HWND GetActivePage() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HWND)::SendMessage(m_hWnd, PSM_GETCURRENTPAGEHWND, 0, 0L);
+	}
+
+	int GetActiveIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		HWND hWndTabCtrl = GetTabControl();
+		ATLASSERT(hWndTabCtrl != NULL);
+		return (int)::SendMessage(hWndTabCtrl, TCM_GETCURSEL, 0, 0L);
+	}
+
+	BOOL SetActivePage(int nPageIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, nPageIndex, 0L);
+	}
+
+	BOOL SetActivePage(HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hPage != NULL);
+		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSEL, 0, (LPARAM)hPage);
+	}
+
+	BOOL SetActivePageByID(int nPageID)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PSM_SETCURSELID, 0, nPageID);
+	}
+
+	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0); // only PSH_PROPTITLE is valid
+		ATLASSERT(lpszText != NULL);
+		::SendMessage(m_hWnd, PSM_SETTITLE, nStyle, (LPARAM)lpszText);
+	}
+
+	HWND GetTabControl() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HWND)::SendMessage(m_hWnd, PSM_GETTABCONTROL, 0, 0L);
+	}
+
+	void SetFinishText(LPCTSTR lpszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText);
+	}
+
+	void SetWizardButtons(DWORD dwFlags)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::PostMessage(m_hWnd, PSM_SETWIZBUTTONS, 0, dwFlags);
+	}
+
+// Operations
+	BOOL AddPage(HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hPage != NULL);
+		return (BOOL)::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
+	}
+
+	BOOL AddPage(LPCPROPSHEETPAGE pPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pPage != NULL);
+		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
+		if(hPage == NULL)
+			return FALSE;
+		return (BOOL)::SendMessage(m_hWnd, PSM_ADDPAGE, 0, (LPARAM)hPage);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL InsertPage(int nNewPageIndex, HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hPage != NULL);
+		return (BOOL)::SendMessage(m_hWnd, PSM_INSERTPAGE, nNewPageIndex, (LPARAM)hPage);
+	}
+
+	BOOL InsertPage(int nNewPageIndex, LPCPROPSHEETPAGE pPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pPage != NULL);
+		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
+		if(hPage == NULL)
+			return FALSE;
+		return (BOOL)::SendMessage(m_hWnd, PSM_INSERTPAGE, nNewPageIndex, (LPARAM)hPage);
+	}
+
+	BOOL InsertPage(HPROPSHEETPAGE hPageInsertAfter, HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hPage != NULL);
+		return (BOOL)::SendMessage(m_hWnd, PSM_INSERTPAGE, (WPARAM)hPageInsertAfter, (LPARAM)hPage);
+	}
+
+	BOOL InsertPage(HPROPSHEETPAGE hPageInsertAfter, LPCPROPSHEETPAGE pPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pPage != NULL);
+		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
+		if(hPage == NULL)
+			return FALSE;
+		return (BOOL)::SendMessage(m_hWnd, PSM_INSERTPAGE, (WPARAM)hPageInsertAfter, (LPARAM)hPage);
+	}
+#endif // !_WIN32_WCE
+
+	void RemovePage(int nPageIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_REMOVEPAGE, nPageIndex, 0L);
+	}
+
+	void RemovePage(HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(hPage != NULL);
+		::SendMessage(m_hWnd, PSM_REMOVEPAGE, 0, (LPARAM)hPage);
+	}
+
+	BOOL PressButton(int nButton)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PSM_PRESSBUTTON, nButton, 0L);
+	}
+
+	BOOL Apply()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PSM_APPLY, 0, 0L);
+	}
+
+	void CancelToClose()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_CANCELTOCLOSE, 0, 0L);
+	}
+
+	void SetModified(HWND hWndPage, BOOL bChanged = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(::IsWindow(hWndPage));
+		UINT uMsg = bChanged ? PSM_CHANGED : PSM_UNCHANGED;
+		::SendMessage(m_hWnd, uMsg, (WPARAM)hWndPage, 0L);
+	}
+
+	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return ::SendMessage(m_hWnd, PSM_QUERYSIBLINGS, wParam, lParam);
+	}
+
+	void RebootSystem()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_REBOOTSYSTEM, 0, 0L);
+	}
+
+	void RestartWindows()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_RESTARTWINDOWS, 0, 0L);
+	}
+
+	BOOL IsDialogMessage(LPMSG lpMsg)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PSM_ISDIALOGMESSAGE, 0, (LPARAM)lpMsg);
+	}
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	int HwndToIndex(HWND hWnd) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PSM_HWNDTOINDEX, (WPARAM)hWnd, 0L);
+	}
+
+	HWND IndexToHwnd(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HWND)::SendMessage(m_hWnd, PSM_INDEXTOHWND, nIndex, 0L);
+	}
+
+	int PageToIndex(HPROPSHEETPAGE hPage) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PSM_PAGETOINDEX, 0, (LPARAM)hPage);
+	}
+
+	HPROPSHEETPAGE IndexToPage(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HPROPSHEETPAGE)::SendMessage(m_hWnd, PSM_INDEXTOPAGE, nIndex, 0L);
+	}
+
+	int IdToIndex(int nID) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PSM_IDTOINDEX, 0, nID);
+	}
+
+	int IndexToId(int nIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PSM_INDEXTOID, nIndex, 0L);
+	}
+
+	int GetResult() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, PSM_GETRESULT, 0, 0L);
+	}
+
+	BOOL RecalcPageSizes()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, PSM_RECALCPAGESIZES, 0, 0L);
+	}
+
+	void SetHeaderTitle(int nIndex, LPCTSTR lpstrHeaderTitle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_SETHEADERTITLE, nIndex, (LPARAM)lpstrHeaderTitle);
+	}
+
+	void SetHeaderSubTitle(int nIndex, LPCTSTR lpstrHeaderSubTitle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_SETHEADERSUBTITLE, nIndex, (LPARAM)lpstrHeaderSubTitle);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+// Implementation - override to prevent usage
+	HWND Create(LPCTSTR, HWND, ATL::_U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, ATL::_U_MENUorID = 0U, LPVOID = NULL)
+	{
+		ATLASSERT(FALSE);
+		return NULL;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CPropertySheetImpl - implements a property sheet
+
+template <class T, class TBase = CPropertySheetWindow>
+class ATL_NO_VTABLE CPropertySheetImpl : public ATL::CWindowImplBaseT< TBase >
+{
+public:
+	PROPSHEETHEADER m_psh;
+	ATL::CSimpleArray<HPROPSHEETPAGE> m_arrPages;
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC specific
+  #ifndef PROPSHEET_LINK_SIZE
+	#define PROPSHEET_LINK_SIZE 128
+  #endif // PROPSHEET_LINK_SIZE
+	TCHAR m_szLink[PROPSHEET_LINK_SIZE];
+	static LPCTSTR m_pszTitle;
+	static LPCTSTR m_pszLink;
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) 
+
+// Construction/Destruction
+	CPropertySheetImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
+	{
+		memset(&m_psh, 0, sizeof(PROPSHEETHEADER));
+		m_psh.dwSize = sizeof(PROPSHEETHEADER);
+		m_psh.dwFlags = PSH_USECALLBACK;
+		m_psh.hInstance = ModuleHelper::GetResourceInstance();
+		m_psh.phpage = NULL;   // will be set later
+		m_psh.nPages = 0;      // will be set later
+		m_psh.pszCaption = title.m_lpstr;
+		m_psh.nStartPage = uStartPage;
+		m_psh.hwndParent = hWndParent;   // if NULL, will be set in DoModal/Create
+		m_psh.pfnCallback = T::PropSheetCallback;
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC specific 
+		m_psh.dwFlags |= PSH_MAXIMIZE;
+		m_szLink[0] = 0;
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__)
+	}
+
+	~CPropertySheetImpl()
+	{
+		if(m_arrPages.GetSize() > 0)   // sheet never created, destroy all pages
+		{
+			for(int i = 0; i < m_arrPages.GetSize(); i++)
+				::DestroyPropertySheetPage((HPROPSHEETPAGE)m_arrPages[i]);
+		}
+	}
+
+// Callback function and overrideables
+	static int CALLBACK PropSheetCallback(HWND hWnd, UINT uMsg, LPARAM lParam)
+	{
+		lParam;   // avoid level 4 warning
+		int nRet = 0;
+
+		if(uMsg == PSCB_INITIALIZED)
+		{
+			ATLASSERT(hWnd != NULL);
+			T* pT = (T*)ModuleHelper::ExtractCreateWndData();
+			// subclass the sheet window
+			pT->SubclassWindow(hWnd);
+			// remove page handles array
+			pT->_CleanUpPages();
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC specific
+			m_pszTitle = pT->m_psh.pszCaption;
+			if(*pT->m_szLink != 0)
+				m_pszLink = pT->m_szLink;
+#endif  // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC specific
+
+			pT->OnSheetInitialized();
+		}
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC specific uMsg
+		else
+		{
+			switch(uMsg)
+			{
+			case PSCB_GETVERSION :
+				nRet = COMCTL32_VERSION;
+				break;
+			case PSCB_GETTITLE :
+				if(m_pszTitle != NULL)
+				{
+					lstrcpy((LPTSTR)lParam, m_pszTitle);
+					m_pszTitle = NULL;
+				}
+				break;
+			case PSCB_GETLINKTEXT:
+				if(m_pszLink != NULL)
+				{
+					lstrcpy((LPTSTR)lParam, m_pszLink);
+					m_pszLink = NULL;
+				}
+				break;
+			default:
+				break;
+			}
+		}
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) 
+
+		return nRet;
+	}
+
+	void OnSheetInitialized()
+	{
+	}
+
+// Create method
+	HWND Create(HWND hWndParent = NULL)
+	{
+		ATLASSERT(m_hWnd == NULL);
+
+		m_psh.dwFlags |= PSH_MODELESS;
+		if(m_psh.hwndParent == NULL)
+			m_psh.hwndParent = hWndParent;
+		m_psh.phpage = (HPROPSHEETPAGE*)m_arrPages.GetData();
+		m_psh.nPages = m_arrPages.GetSize();
+
+		T* pT = static_cast<T*>(this);
+		ModuleHelper::AddCreateWndData(&pT->m_thunk.cd, pT);
+
+		HWND hWnd = (HWND)::PropertySheet(&m_psh);
+		_CleanUpPages();   // ensure clean-up, required if call failed
+
+		ATLASSERT(m_hWnd == hWnd);
+
+		return hWnd;
+	}
+
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow())
+	{
+		ATLASSERT(m_hWnd == NULL);
+
+		m_psh.dwFlags &= ~PSH_MODELESS;
+		if(m_psh.hwndParent == NULL)
+			m_psh.hwndParent = hWndParent;
+		m_psh.phpage = (HPROPSHEETPAGE*)m_arrPages.GetData();
+		m_psh.nPages = m_arrPages.GetSize();
+
+		T* pT = static_cast<T*>(this);
+		ModuleHelper::AddCreateWndData(&pT->m_thunk.cd, pT);
+
+		INT_PTR nRet = ::PropertySheet(&m_psh);
+		_CleanUpPages();   // ensure clean-up, required if call failed
+
+		return nRet;
+	}
+
+	// implementation helper - clean up pages array
+	void _CleanUpPages()
+	{
+		m_psh.nPages = 0;
+		m_psh.phpage = NULL;
+		m_arrPages.RemoveAll();
+	}
+
+// Attributes (extended overrides of client class methods)
+// These now can be called before the sheet is created
+// Note: Calling these after the sheet is created gives unpredictable results
+	int GetPageCount() const
+	{
+		if(m_hWnd == NULL)   // not created yet
+			return m_arrPages.GetSize();
+		return TBase::GetPageCount();
+	}
+
+	int GetActiveIndex() const
+	{
+		if(m_hWnd == NULL)   // not created yet
+			return m_psh.nStartPage;
+		return TBase::GetActiveIndex();
+	}
+
+	HPROPSHEETPAGE GetPage(int nPageIndex) const
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		return (HPROPSHEETPAGE)m_arrPages[nPageIndex];
+	}
+
+	int GetPageIndex(HPROPSHEETPAGE hPage) const
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		return m_arrPages.Find((HPROPSHEETPAGE&)hPage);
+	}
+
+	BOOL SetActivePage(int nPageIndex)
+	{
+		if(m_hWnd == NULL)   // not created yet
+		{
+			ATLASSERT(nPageIndex >= 0 && nPageIndex < m_arrPages.GetSize());
+			m_psh.nStartPage = nPageIndex;
+			return TRUE;
+		}
+		return TBase::SetActivePage(nPageIndex);
+	}
+
+	BOOL SetActivePage(HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(hPage != NULL);
+		if (m_hWnd == NULL)   // not created yet
+		{
+			int nPageIndex = GetPageIndex(hPage);
+			if(nPageIndex == -1)
+				return FALSE;
+
+			return SetActivePage(nPageIndex);
+		}
+		return TBase::SetActivePage(hPage);
+
+	}
+
+	void SetTitle(LPCTSTR lpszText, UINT nStyle = 0)
+	{
+		ATLASSERT((nStyle & ~PSH_PROPTITLE) == 0);   // only PSH_PROPTITLE is valid
+		ATLASSERT(lpszText != NULL);
+
+		if(m_hWnd == NULL)
+		{
+			// set internal state
+			m_psh.pszCaption = lpszText;   // must exist until sheet is created
+			m_psh.dwFlags &= ~PSH_PROPTITLE;
+			m_psh.dwFlags |= nStyle;
+		}
+		else
+		{
+			// set external state
+			TBase::SetTitle(lpszText, nStyle);
+		}
+	}
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC specific Link field	
+	void SetLinkText(LPCTSTR lpszText)
+	{
+		ATLASSERT(lpszText != NULL);
+		ATLASSERT(lstrlen(lpszText) < PROPSHEET_LINK_SIZE);
+		lstrcpy(m_szLink, lpszText);
+	}
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) 
+
+	void SetWizardMode()
+	{
+		m_psh.dwFlags |= PSH_WIZARD;
+	}
+
+	void EnableHelp()
+	{
+		m_psh.dwFlags |= PSH_HASHELP;
+	}
+
+// Operations
+	BOOL AddPage(HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(hPage != NULL);
+		BOOL bRet = FALSE;
+		if(m_hWnd != NULL)
+			bRet = TBase::AddPage(hPage);
+		else	// sheet not created yet, use internal data
+			bRet = m_arrPages.Add((HPROPSHEETPAGE&)hPage);
+		return bRet;
+	}
+
+	BOOL AddPage(LPCPROPSHEETPAGE pPage)
+	{
+		ATLASSERT(pPage != NULL);
+		HPROPSHEETPAGE hPage = ::CreatePropertySheetPage(pPage);
+		if(hPage == NULL)
+			return FALSE;
+		BOOL bRet = AddPage(hPage);
+		if(!bRet)
+			::DestroyPropertySheetPage(hPage);
+		return bRet;
+	}
+
+	BOOL RemovePage(HPROPSHEETPAGE hPage)
+	{
+		ATLASSERT(hPage != NULL);
+		if (m_hWnd == NULL)   // not created yet
+		{
+			int nPage = GetPageIndex(hPage);
+			if(nPage == -1)
+				return FALSE;
+			return RemovePage(nPage);
+		}
+		TBase::RemovePage(hPage);
+		return TRUE;
+
+	}
+
+	BOOL RemovePage(int nPageIndex)
+	{
+		BOOL bRet = TRUE;
+		if(m_hWnd != NULL)
+			TBase::RemovePage(nPageIndex);
+		else	// sheet not created yet, use internal data
+			bRet = m_arrPages.RemoveAt(nPageIndex);
+		return bRet;
+	}
+
+#if (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+	void SetHeader(LPCTSTR szbmHeader)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+
+		m_psh.dwFlags &= ~PSH_WIZARD;
+		m_psh.dwFlags |= (PSH_HEADER | PSH_WIZARD97);
+		m_psh.pszbmHeader = szbmHeader;
+	}
+
+	void SetHeader(HBITMAP hbmHeader)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+
+		m_psh.dwFlags &= ~PSH_WIZARD;
+		m_psh.dwFlags |= (PSH_HEADER | PSH_USEHBMHEADER | PSH_WIZARD97);
+		m_psh.hbmHeader = hbmHeader;
+	}
+
+	void SetWatermark(LPCTSTR szbmWatermark, HPALETTE hplWatermark = NULL)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+
+		m_psh.dwFlags &= ~PSH_WIZARD;
+		m_psh.dwFlags |= PSH_WATERMARK | PSH_WIZARD97;
+		m_psh.pszbmWatermark = szbmWatermark;
+
+		if (hplWatermark != NULL)
+		{
+			m_psh.dwFlags |= PSH_USEHPLWATERMARK;
+			m_psh.hplWatermark = hplWatermark;
+		}
+	}
+
+	void SetWatermark(HBITMAP hbmWatermark, HPALETTE hplWatermark = NULL)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+
+		m_psh.dwFlags &= ~PSH_WIZARD;
+		m_psh.dwFlags |= (PSH_WATERMARK | PSH_USEHBMWATERMARK | PSH_WIZARD97);
+		m_psh.hbmWatermark = hbmWatermark;
+
+		if (hplWatermark != NULL)
+		{
+			m_psh.dwFlags |= PSH_USEHPLWATERMARK;
+			m_psh.hplWatermark = hplWatermark;
+		}
+	}
+
+	void StretchWatermark(bool bStretchWatermark)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		if (bStretchWatermark)
+			m_psh.dwFlags |= PSH_STRETCHWATERMARK;
+		else
+			m_psh.dwFlags &= ~PSH_STRETCHWATERMARK;
+	}
+#endif // (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CPropertySheetImpl)
+		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
+		MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
+	END_MSG_MAP()
+
+	LRESULT OnCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRet = DefWindowProc(uMsg, wParam, lParam);
+		if(HIWORD(wParam) == BN_CLICKED && (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) &&
+		   ((m_psh.dwFlags & PSH_MODELESS) != 0) && (GetActivePage() == NULL))
+			DestroyWindow();
+		return lRet;
+	}
+
+	LRESULT OnSysCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(((m_psh.dwFlags & PSH_MODELESS) == PSH_MODELESS) && ((wParam & 0xFFF0) == SC_CLOSE))
+			SendMessage(WM_CLOSE);
+		else
+			bHandled = FALSE;
+		return 0;
+	}
+};
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__) // PPC static pointers
+template < class T, class TBase >
+LPCWSTR CPropertySheetImpl<T,TBase>::m_pszTitle = NULL;
+template < class T, class TBase>
+LPCWSTR CPropertySheetImpl<T,TBase>::m_pszLink = NULL;
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__)
+
+// for non-customized sheets
+class CPropertySheet : public CPropertySheetImpl<CPropertySheet>
+{
+public:
+	CPropertySheet(ATL::_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
+		: CPropertySheetImpl<CPropertySheet>(title, uStartPage, hWndParent)
+	{ }
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPropertyPageWindow - client side for a property page
+
+class CPropertyPageWindow : public ATL::CWindow
+{
+public:
+// Constructors
+	CPropertyPageWindow(HWND hWnd = NULL) : ATL::CWindow(hWnd)
+	{ }
+
+	CPropertyPageWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Attributes
+	CPropertySheetWindow GetPropertySheet() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CPropertySheetWindow(GetParent());
+	}
+
+// Operations
+	BOOL Apply()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		return GetPropertySheet().Apply();
+	}
+
+	void CancelToClose()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetPropertySheet().CancelToClose();
+	}
+
+	void SetModified(BOOL bChanged = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetPropertySheet().SetModified(m_hWnd, bChanged);
+	}
+
+	LRESULT QuerySiblings(WPARAM wParam, LPARAM lParam)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		return GetPropertySheet().QuerySiblings(wParam, lParam);
+	}
+
+	void RebootSystem()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetPropertySheet().RebootSystem();
+	}
+
+	void RestartWindows()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetPropertySheet().RestartWindows();
+	}
+
+	void SetWizardButtons(DWORD dwFlags)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetPropertySheet().SetWizardButtons(dwFlags);
+	}
+
+// Implementation - overrides to prevent usage
+	HWND Create(LPCTSTR, HWND, ATL::_U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, ATL::_U_MENUorID = 0U, LPVOID = NULL)
+	{
+		ATLASSERT(FALSE);
+		return NULL;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CPropertyPageImpl - implements a property page
+
+template <class T, class TBase = CPropertyPageWindow>
+class ATL_NO_VTABLE CPropertyPageImpl : public ATL::CDialogImplBaseT< TBase >
+{
+public:
+	PROPSHEETPAGE m_psp;
+
+	operator PROPSHEETPAGE*() { return &m_psp; }
+
+// Construction
+	CPropertyPageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL)
+	{
+		// initialize PROPSHEETPAGE struct
+		memset(&m_psp, 0, sizeof(PROPSHEETPAGE));
+		m_psp.dwSize = sizeof(PROPSHEETPAGE);
+		m_psp.dwFlags = PSP_USECALLBACK;
+		m_psp.hInstance = ModuleHelper::GetResourceInstance();
+		T* pT = static_cast<T*>(this);
+		m_psp.pszTemplate = MAKEINTRESOURCE(pT->IDD);
+		m_psp.pfnDlgProc = (DLGPROC)T::StartDialogProc;
+		m_psp.pfnCallback = T::PropPageCallback;
+		m_psp.lParam = (LPARAM)pT;
+
+		if(title.m_lpstr != NULL)
+			SetTitle(title);
+	}
+
+// Callback function and overrideables
+	static UINT CALLBACK PropPageCallback(HWND hWnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
+	{
+		hWnd;   // avoid level 4 warning
+		ATLASSERT(hWnd == NULL);
+		T* pT = (T*)ppsp->lParam;
+		UINT uRet = 0;
+
+		switch(uMsg)
+		{
+		case PSPCB_CREATE:
+			{
+				ATL::CDialogImplBaseT< TBase >* pPage = (ATL::CDialogImplBaseT< TBase >*)pT;
+				ModuleHelper::AddCreateWndData(&pPage->m_thunk.cd, pPage);
+				uRet = pT->OnPageCreate() ? 1 : 0;
+			}
+			break;
+#if (_WIN32_IE >= 0x0500)
+		case PSPCB_ADDREF:
+			pT->OnPageAddRef();
+			break;
+#endif // (_WIN32_IE >= 0x0500)
+		case PSPCB_RELEASE:
+			pT->OnPageRelease();
+			break;
+		default:
+			break;
+		}
+
+		return uRet;
+	}
+
+	bool OnPageCreate()
+	{
+		return true;   // true - allow page to be created, false - prevent creation
+	}
+
+#if (_WIN32_IE >= 0x0500)
+	void OnPageAddRef()
+	{
+	}
+#endif // (_WIN32_IE >= 0x0500)
+
+	void OnPageRelease()
+	{
+	}
+
+// Create method
+	HPROPSHEETPAGE Create()
+	{
+		return ::CreatePropertySheetPage(&m_psp);
+	}
+
+// Attributes
+	void SetTitle(ATL::_U_STRINGorID title)
+	{
+		m_psp.pszTitle = title.m_lpstr;
+		m_psp.dwFlags |= PSP_USETITLE;
+	}
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	void SetHeaderTitle(LPCTSTR lpstrHeaderTitle)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		m_psp.dwFlags |= PSP_USEHEADERTITLE;
+		m_psp.pszHeaderTitle = lpstrHeaderTitle;
+	}
+
+	void SetHeaderSubTitle(LPCTSTR lpstrHeaderSubTitle)
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		m_psp.dwFlags |= PSP_USEHEADERSUBTITLE;
+		m_psp.pszHeaderSubTitle = lpstrHeaderSubTitle;
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+// Operations
+	void EnableHelp()
+	{
+		m_psp.dwFlags |= PSP_HASHELP;
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CPropertyPageImpl)
+		MESSAGE_HANDLER(WM_NOTIFY, OnNotify)
+	END_MSG_MAP()
+
+	// NOTE: Define _WTL_NEW_PAGE_NOTIFY_HANDLERS to use new notification
+	// handlers that return direct values without any restrictions
+	LRESULT OnNotify(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+#ifndef _WIN32_WCE
+		// This notification is sometimes received on Windows CE after the window is already destroyed
+		ATLASSERT(::IsWindow(m_hWnd));
+#endif
+		NMHDR* pNMHDR = (NMHDR*)lParam;
+
+		// don't handle messages not from the page/sheet itself
+		if(pNMHDR->hwndFrom != m_hWnd && pNMHDR->hwndFrom != ::GetParent(m_hWnd))
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+#ifdef _WIN32_WCE
+		ATLASSERT(::IsWindow(m_hWnd));
+#endif
+
+		T* pT = static_cast<T*>(this);
+		LRESULT lResult = 0;
+		switch(pNMHDR->code)
+		{
+#ifdef _WTL_NEW_PAGE_NOTIFY_HANDLERS
+		case PSN_SETACTIVE:
+			lResult = pT->OnSetActive();
+			break;
+		case PSN_KILLACTIVE:
+			lResult = pT->OnKillActive();
+			break;
+		case PSN_APPLY:
+			lResult = pT->OnApply();
+			break;
+		case PSN_RESET:
+			pT->OnReset();
+			break;
+		case PSN_QUERYCANCEL:
+			lResult = pT->OnQueryCancel();
+			break;
+		case PSN_WIZNEXT:
+			lResult = pT->OnWizardNext();
+			break;
+		case PSN_WIZBACK:
+			lResult = pT->OnWizardBack();
+			break;
+		case PSN_WIZFINISH:
+			lResult = pT->OnWizardFinish();
+			break;
+		case PSN_HELP:
+			pT->OnHelp();
+			break;
+#ifndef _WIN32_WCE
+#if (_WIN32_IE >= 0x0400)
+		case PSN_GETOBJECT:
+			if(!pT->OnGetObject((LPNMOBJECTNOTIFY)lParam))
+				bHandled = FALSE;
+			break;
+#endif // (_WIN32_IE >= 0x0400)
+#if (_WIN32_IE >= 0x0500)
+		case PSN_TRANSLATEACCELERATOR:
+			{
+				LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY)lParam;
+				lResult = pT->OnTranslateAccelerator((LPMSG)lpPSHNotify->lParam);
+			}
+			break;
+		case PSN_QUERYINITIALFOCUS:
+			{
+				LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY)lParam;
+				lResult = (LRESULT)pT->OnQueryInitialFocus((HWND)lpPSHNotify->lParam);
+			}
+			break;
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_WIN32_WCE
+
+#else // !_WTL_NEW_PAGE_NOTIFY_HANDLERS
+		case PSN_SETACTIVE:
+			lResult = pT->OnSetActive() ? 0 : -1;
+			break;
+		case PSN_KILLACTIVE:
+			lResult = !pT->OnKillActive();
+			break;
+		case PSN_APPLY:
+			lResult = pT->OnApply() ? PSNRET_NOERROR : PSNRET_INVALID_NOCHANGEPAGE;
+			break;
+		case PSN_RESET:
+			pT->OnReset();
+			break;
+		case PSN_QUERYCANCEL:
+			lResult = !pT->OnQueryCancel();
+			break;
+		case PSN_WIZNEXT:
+			lResult = pT->OnWizardNext();
+			break;
+		case PSN_WIZBACK:
+			lResult = pT->OnWizardBack();
+			break;
+		case PSN_WIZFINISH:
+			lResult = !pT->OnWizardFinish();
+			break;
+		case PSN_HELP:
+			pT->OnHelp();
+			break;
+#ifndef _WIN32_WCE
+#if (_WIN32_IE >= 0x0400)
+		case PSN_GETOBJECT:
+			if(!pT->OnGetObject((LPNMOBJECTNOTIFY)lParam))
+				bHandled = FALSE;
+			break;
+#endif // (_WIN32_IE >= 0x0400)
+#if (_WIN32_IE >= 0x0500)
+		case PSN_TRANSLATEACCELERATOR:
+			{
+				LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY)lParam;
+				lResult = pT->OnTranslateAccelerator((LPMSG)lpPSHNotify->lParam) ? PSNRET_MESSAGEHANDLED : PSNRET_NOERROR;
+			}
+			break;
+		case PSN_QUERYINITIALFOCUS:
+			{
+				LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY)lParam;
+				lResult = (LRESULT)pT->OnQueryInitialFocus((HWND)lpPSHNotify->lParam);
+			}
+			break;
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_WIN32_WCE
+
+#endif // !_WTL_NEW_PAGE_NOTIFY_HANDLERS
+		default:
+			bHandled = FALSE;   // not handled
+		}
+
+		return lResult;
+	}
+
+// Overridables
+	// NOTE: Define _WTL_NEW_PAGE_NOTIFY_HANDLERS to use new notification
+	// handlers that return direct values without any restrictions
+#ifdef _WTL_NEW_PAGE_NOTIFY_HANDLERS
+	int OnSetActive()
+	{
+		// 0 = allow activate
+		// -1 = go back that was active
+		// page ID = jump to page
+		return 0;
+	}
+
+	BOOL OnKillActive()
+	{
+		// FALSE = allow deactivate
+		// TRUE = prevent deactivation
+		return FALSE;
+	}
+
+	int OnApply()
+	{
+		// PSNRET_NOERROR = apply OK
+		// PSNRET_INVALID = apply not OK, return to this page
+		// PSNRET_INVALID_NOCHANGEPAGE = apply not OK, don't change focus
+		return PSNRET_NOERROR;
+	}
+
+	void OnReset()
+	{
+	}
+
+	BOOL OnQueryCancel()
+	{
+		// FALSE = allow cancel
+		// TRUE = prevent cancel
+		return FALSE;
+	}
+
+	int OnWizardBack()
+	{
+		// 0  = goto previous page
+		// -1 = prevent page change
+		// >0 = jump to page by dlg ID
+		return 0;
+	}
+
+	int OnWizardNext()
+	{
+		// 0  = goto next page
+		// -1 = prevent page change
+		// >0 = jump to page by dlg ID
+		return 0;
+	}
+
+	INT_PTR OnWizardFinish()
+	{
+		// FALSE = allow finish
+		// TRUE = prevent finish
+		// HWND = prevent finish and set focus to HWND (CommCtrl 5.80 only)
+		return FALSE;
+	}
+
+	void OnHelp()
+	{
+	}
+
+#ifndef _WIN32_WCE
+#if (_WIN32_IE >= 0x0400)
+	BOOL OnGetObject(LPNMOBJECTNOTIFY /*lpObjectNotify*/)
+	{
+		return FALSE;   // not processed
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500)
+	int OnTranslateAccelerator(LPMSG /*lpMsg*/)
+	{
+		// PSNRET_NOERROR - message not handled
+		// PSNRET_MESSAGEHANDLED - message handled
+		return PSNRET_NOERROR;
+	}
+
+	HWND OnQueryInitialFocus(HWND /*hWndFocus*/)
+	{
+		// NULL = set focus to default control
+		// HWND = set focus to HWND
+		return NULL;
+	}
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_WIN32_WCE
+
+#else // !_WTL_NEW_PAGE_NOTIFY_HANDLERS
+	BOOL OnSetActive()
+	{
+		return TRUE;
+	}
+
+	BOOL OnKillActive()
+	{
+		return TRUE;
+	}
+
+	BOOL OnApply()
+	{
+		return TRUE;
+	}
+
+	void OnReset()
+	{
+	}
+
+	BOOL OnQueryCancel()
+	{
+		return TRUE;    // ok to cancel
+	}
+
+	int OnWizardBack()
+	{
+		// 0  = goto previous page
+		// -1 = prevent page change
+		// >0 = jump to page by dlg ID
+		return 0;
+	}
+
+	int OnWizardNext()
+	{
+		// 0  = goto next page
+		// -1 = prevent page change
+		// >0 = jump to page by dlg ID
+		return 0;
+	}
+
+	BOOL OnWizardFinish()
+	{
+		return TRUE;
+	}
+
+	void OnHelp()
+	{
+	}
+
+#ifndef _WIN32_WCE
+#if (_WIN32_IE >= 0x0400)
+	BOOL OnGetObject(LPNMOBJECTNOTIFY /*lpObjectNotify*/)
+	{
+		return FALSE;   // not processed
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500)
+	BOOL OnTranslateAccelerator(LPMSG /*lpMsg*/)
+	{
+		return FALSE;   // not translated
+	}
+
+	HWND OnQueryInitialFocus(HWND /*hWndFocus*/)
+	{
+		return NULL;   // default
+	}
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_WIN32_WCE
+
+#endif // !_WTL_NEW_PAGE_NOTIFY_HANDLERS
+};
+
+// for non-customized pages
+template <WORD t_wDlgTemplateID>
+class CPropertyPage : public CPropertyPageImpl<CPropertyPage<t_wDlgTemplateID> >
+{
+public:
+	enum { IDD = t_wDlgTemplateID };
+
+	CPropertyPage(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : CPropertyPageImpl<CPropertyPage>(title)
+	{ }
+
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CAxPropertyPageImpl - property page that hosts ActiveX controls
+
+#ifndef _ATL_NO_HOSTING
+
+// Note: You must #include <atlhost.h> to use these classes
+
+template <class T, class TBase = CPropertyPageWindow>
+class ATL_NO_VTABLE CAxPropertyPageImpl : public CPropertyPageImpl< T, TBase >
+{
+public:
+// Data members
+	HGLOBAL m_hInitData;
+	HGLOBAL m_hDlgRes;
+	HGLOBAL m_hDlgResSplit;
+
+// Constructor/destructor
+	CAxPropertyPageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : 
+			CPropertyPageImpl< T, TBase >(title),
+			m_hInitData(NULL), m_hDlgRes(NULL), m_hDlgResSplit(NULL)
+	{
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+
+		// initialize ActiveX hosting and modify dialog template
+		ATL::AtlAxWinInit();
+
+		HINSTANCE hInstance = ModuleHelper::GetResourceInstance();
+		LPCTSTR lpTemplateName = MAKEINTRESOURCE(pT->IDD);
+		HRSRC hDlg = ::FindResource(hInstance, lpTemplateName, (LPTSTR)RT_DIALOG);
+		if(hDlg != NULL)
+		{
+			HRSRC hDlgInit = ::FindResource(hInstance, lpTemplateName, (LPTSTR)_ATL_RT_DLGINIT);
+
+			BYTE* pInitData = NULL;
+			if(hDlgInit != NULL)
+			{
+				m_hInitData = ::LoadResource(hInstance, hDlgInit);
+				pInitData = (BYTE*)::LockResource(m_hInitData);
+			}
+
+			m_hDlgRes = ::LoadResource(hInstance, hDlg);
+			DLGTEMPLATE* pDlg = (DLGTEMPLATE*)::LockResource(m_hDlgRes);
+			LPCDLGTEMPLATE lpDialogTemplate = ATL::_DialogSplitHelper::SplitDialogTemplate(pDlg, pInitData);
+			if(lpDialogTemplate != pDlg)
+				m_hDlgResSplit = GlobalHandle(lpDialogTemplate);
+
+			// set up property page to use in-memory dialog template
+			if(lpDialogTemplate != NULL)
+			{
+				m_psp.dwFlags |= PSP_DLGINDIRECT;
+				m_psp.pResource = lpDialogTemplate;
+			}
+			else
+			{
+				ATLASSERT(FALSE && _T("CAxPropertyPageImpl - ActiveX initializtion failed!"));
+			}
+		}
+		else
+		{
+			ATLASSERT(FALSE && _T("CAxPropertyPageImpl - Cannot find dialog template!"));
+		}
+	}
+
+	~CAxPropertyPageImpl()
+	{
+		if(m_hInitData != NULL)
+		{
+			UnlockResource(m_hInitData);
+			FreeResource(m_hInitData);
+		}
+		if(m_hDlgRes != NULL)
+		{
+			UnlockResource(m_hDlgRes);
+			FreeResource(m_hDlgRes);
+		}
+		if(m_hDlgResSplit != NULL)
+		{
+			::GlobalFree(m_hDlgResSplit);
+		}
+	}
+
+// Methods
+	// call this one to handle keyboard message for ActiveX controls
+	BOOL PreTranslateMessage(LPMSG pMsg)
+	{
+		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
+		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
+			return FALSE;
+		// find a direct child of the dialog from the window that has focus
+		HWND hWndCtl = ::GetFocus();
+		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
+		{
+			do
+			{
+				hWndCtl = ::GetParent(hWndCtl);
+			}
+			while (::GetParent(hWndCtl) != m_hWnd);
+		}
+		// give controls a chance to translate this message
+		return (BOOL)::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg);
+	}
+
+// Overridables
+#if (_WIN32_IE >= 0x0500)
+	// new default implementation for ActiveX hosting pages
+#ifdef _WTL_NEW_PAGE_NOTIFY_HANDLERS
+	int OnTranslateAccelerator(LPMSG lpMsg)
+	{
+		T* pT = static_cast<T*>(this);
+		return (pT->PreTranslateMessage(lpMsg) != FALSE) ? PSNRET_MESSAGEHANDLED : PSNRET_NOERROR;
+	}
+#else // !_WTL_NEW_PAGE_NOTIFY_HANDLERS
+	BOOL OnTranslateAccelerator(LPMSG lpMsg)
+	{
+		T* pT = static_cast<T*>(this);
+		return pT->PreTranslateMessage(lpMsg);
+	}
+#endif // !_WTL_NEW_PAGE_NOTIFY_HANDLERS
+#endif // (_WIN32_IE >= 0x0500)
+
+// Support for new stuff in ATL7
+#if (_ATL_VER >= 0x0700)
+	int GetIDD()
+	{
+		return( static_cast<T*>(this)->IDD );
+	}
+
+	virtual DLGPROC GetDialogProc()
+	{
+		return DialogProc;
+	}
+
+	static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		CAxPropertyPageImpl< T, TBase >* pThis = (CAxPropertyPageImpl< T, TBase >*)hWnd;
+		if (uMsg == WM_INITDIALOG)
+		{
+			HRESULT hr;
+			if (FAILED(hr = pThis->CreateActiveXControls(pThis->GetIDD())))
+			{
+				ATLASSERT(FALSE);
+				return FALSE;
+			}
+		}
+		return CPropertyPageImpl< T, TBase >::DialogProc(hWnd, uMsg, wParam, lParam);
+	}
+
+// ActiveX controls creation
+	virtual HRESULT CreateActiveXControls(UINT nID)
+	{
+		// Load dialog template and InitData
+		HRSRC hDlgInit = ::FindResource(ATL::_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(nID), (LPTSTR)_ATL_RT_DLGINIT);
+		BYTE* pInitData = NULL;
+		HGLOBAL hData = NULL;
+		HRESULT hr = S_OK;
+		if (hDlgInit != NULL)
+		{
+			hData = ::LoadResource(ATL::_AtlBaseModule.GetResourceInstance(), hDlgInit);
+			if (hData != NULL)
+				pInitData = (BYTE*) ::LockResource(hData);
+		}
+
+		HRSRC hDlg = ::FindResource(ATL::_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(nID), (LPTSTR)RT_DIALOG);
+		if (hDlg != NULL)
+		{
+			HGLOBAL hResource = ::LoadResource(ATL::_AtlBaseModule.GetResourceInstance(), hDlg);
+			DLGTEMPLATE* pDlg = NULL;
+			if (hResource != NULL)
+			{
+				pDlg = (DLGTEMPLATE*) ::LockResource(hResource);
+				if (pDlg != NULL)
+				{
+					// Get first control on the template
+					BOOL bDialogEx = ATL::_DialogSplitHelper::IsDialogEx(pDlg);
+					WORD nItems = ATL::_DialogSplitHelper::DlgTemplateItemCount(pDlg);
+
+					// Get first control on the dialog
+					DLGITEMTEMPLATE* pItem = ATL::_DialogSplitHelper::FindFirstDlgItem(pDlg);
+					HWND hWndPrev = GetWindow(GW_CHILD);
+
+					// Create all ActiveX cotnrols in the dialog template and place them in the correct tab order (z-order)
+					for (WORD nItem = 0; nItem < nItems; nItem++)
+					{
+						DWORD wID = bDialogEx ? ((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->id : pItem->id;
+						if (ATL::_DialogSplitHelper::IsActiveXControl(pItem, bDialogEx))
+						{
+							BYTE* pData = NULL;
+							DWORD dwLen = ATL::_DialogSplitHelper::FindCreateData(wID, pInitData, &pData);
+							ATL::CComPtr<IStream> spStream;
+							if (dwLen != 0)
+							{
+								HGLOBAL h = GlobalAlloc(GHND, dwLen);
+								if (h != NULL)
+								{
+									BYTE* pBytes = (BYTE*) GlobalLock(h);
+									BYTE* pSource = pData; 
+									SecureHelper::memcpy_x(pBytes, dwLen, pSource, dwLen);
+									GlobalUnlock(h);
+									CreateStreamOnHGlobal(h, TRUE, &spStream);
+								}
+								else
+								{
+									hr = E_OUTOFMEMORY;
+									break;
+								}
+							}
+
+							ATL::CComBSTR bstrLicKey;
+							hr = ATL::_DialogSplitHelper::ParseInitData(spStream, &bstrLicKey.m_str);
+							if (SUCCEEDED(hr))
+							{
+								ATL::CAxWindow2 wnd;
+								// Get control caption.
+								LPWSTR pszClassName = 
+									bDialogEx ? 
+										(LPWSTR)(((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem) + 1) :
+										(LPWSTR)(pItem + 1);
+								// Get control rect.
+								RECT rect;
+								rect.left = 
+									bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->x : 
+										pItem->x;
+								rect.top = 
+									bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->y : 
+										pItem->y;
+								rect.right = rect.left + 
+									(bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->cx : 
+										pItem->cx);
+								rect.bottom = rect.top + 
+									(bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->cy : 
+										pItem->cy);
+
+								// Convert from dialog units to screen units
+								MapDialogRect(&rect);
+
+								// Create AxWindow with a NULL caption.
+								wnd.Create(m_hWnd, 
+									&rect, 
+									NULL, 
+									(bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->style : 
+										pItem->style) | WS_TABSTOP, 
+									bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->exStyle : 
+										0,
+									bDialogEx ? 
+										((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->id : 
+										pItem->id,
+									NULL);
+
+								if (wnd != NULL)
+								{
+#ifndef _WIN32_WCE
+									// Set the Help ID
+									if (bDialogEx && ((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->helpID != 0)
+										wnd.SetWindowContextHelpId(((ATL::_DialogSplitHelper::DLGITEMTEMPLATEEX*)pItem)->helpID);
+#endif // !_WIN32_WCE
+									// Try to create the ActiveX control.
+									hr = wnd.CreateControlLic(pszClassName, spStream, NULL, bstrLicKey);
+									if (FAILED(hr))
+										break;
+									// Set the correct tab position.
+									if (nItem == 0)
+										hWndPrev = HWND_TOP;
+									wnd.SetWindowPos(hWndPrev, 0,0,0,0,SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
+									hWndPrev = wnd;
+								}
+								else
+								{
+									hr = ATL::AtlHresultFromLastError();
+								}
+							}
+						}
+						else
+						{
+							if (nItem != 0)
+								hWndPrev = ::GetWindow(hWndPrev, GW_HWNDNEXT);
+						}
+						pItem = ATL::_DialogSplitHelper::FindNextDlgItem(pItem, bDialogEx);
+					}
+				}
+				else
+					hr = ATL::AtlHresultFromLastError();
+			}
+			else
+				hr = ATL::AtlHresultFromLastError();
+		}
+		return hr;
+	}
+
+// Event handling support
+	HRESULT AdviseSinkMap(bool bAdvise)
+	{
+		if(!bAdvise && m_hWnd == NULL)
+		{
+			// window is gone, controls are already unadvised
+			ATLTRACE2(atlTraceUI, 0, _T("CAxPropertyPageImpl::AdviseSinkMap called after the window was destroyed\n"));
+			return S_OK;
+		}
+		HRESULT hRet = E_NOTIMPL;
+		__if_exists(T::_GetSinkMapFinder)
+		{
+			T* pT = static_cast<T*>(this);
+			hRet = AtlAdviseSinkMap(pT, bAdvise);
+		}
+		return hRet;
+	}
+
+// Message map and handlers
+	typedef CPropertyPageImpl< T, TBase>   _baseClass;
+	BEGIN_MSG_MAP(CAxPropertyPageImpl)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		CHAIN_MSG_MAP(_baseClass)
+	END_MSG_MAP()
+
+	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		// initialize controls in dialog with DLGINIT resource section
+		ExecuteDlgInit(static_cast<T*>(this)->IDD);
+		AdviseSinkMap(true);
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		AdviseSinkMap(false);
+		bHandled = FALSE;
+		return 1;
+	}
+#endif // (_ATL_VER >= 0x0700)
+};
+
+// for non-customized pages
+template <WORD t_wDlgTemplateID>
+class CAxPropertyPage : public CAxPropertyPageImpl<CAxPropertyPage<t_wDlgTemplateID> >
+{
+public:
+	enum { IDD = t_wDlgTemplateID };
+
+	CAxPropertyPage(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : CAxPropertyPageImpl<CAxPropertyPage>(title)
+	{ }
+
+#if (_WIN32_IE >= 0x0500) || (_ATL_VER >= 0x0700)
+	// not empty so we handle accelerators/create controls
+	BEGIN_MSG_MAP(CAxPropertyPage)
+		CHAIN_MSG_MAP(CAxPropertyPageImpl<CAxPropertyPage<t_wDlgTemplateID> >)
+	END_MSG_MAP()
+#else // !((_WIN32_IE >= 0x0500) || (_ATL_VER >= 0x0700))
+	DECLARE_EMPTY_MSG_MAP()
+#endif // !((_WIN32_IE >= 0x0500) || (_ATL_VER >= 0x0700))
+};
+
+#endif // _ATL_NO_HOSTING
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Wizard97 Support
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+// Sample wizard dialog resources:
+//
+// IDD_WIZ97_INTERIOR_BLANK DIALOG  0, 0, 317, 143
+// STYLE DS_SETFONT | WS_CHILD | WS_DISABLED | WS_CAPTION
+// CAPTION "Wizard97 Property Page - Interior"
+// FONT 8, "MS Shell Dlg"
+// BEGIN
+// END
+//
+// IDD_WIZ97_EXTERIOR_BLANK DIALOGEX 0, 0, 317, 193
+// STYLE DS_SETFONT | DS_FIXEDSYS | WS_CHILD | WS_DISABLED | WS_CAPTION
+// CAPTION "Wizard97 Property Page - Welcome/Complete"
+// FONT 8, "MS Shell Dlg", 0, 0, 0x0
+// BEGIN
+//    LTEXT           "Welcome to the X Wizard",IDC_WIZ97_EXTERIOR_TITLE,115,8,
+//                    195,24
+//    LTEXT           "Wizard Explanation\r\n(The height of the static text should be in multiples of 8 dlus)",
+//                    IDC_STATIC,115,40,195,16
+//    LTEXT           "h",IDC_WIZ97_BULLET1,118,64,8,8
+//    LTEXT           "List Item 1 (the h is turned into a bullet)",IDC_STATIC,
+//                    127,63,122,8
+//    LTEXT           "h",IDC_WIZ97_BULLET2,118,79,8,8
+//    LTEXT           "List Item 2. Keep 7 dlus between paragraphs",IDC_STATIC,
+//                    127,78,33,8
+//    CONTROL         "&Do not show this Welcome page again",
+//                    IDC_WIZ97_WELCOME_NOTAGAIN,"Button",BS_AUTOCHECKBOX | 
+//                    WS_TABSTOP,115,169,138,10
+// END
+//
+// GUIDELINES DESIGNINFO 
+// BEGIN
+//    IDD_WIZ97_INTERIOR_BLANK, DIALOG
+//    BEGIN
+//        LEFTMARGIN, 7
+//        RIGHTMARGIN, 310
+//        VERTGUIDE, 21
+//        VERTGUIDE, 31
+//        VERTGUIDE, 286
+//        VERTGUIDE, 296
+//        TOPMARGIN, 7
+//        BOTTOMMARGIN, 136
+//        HORZGUIDE, 8
+//    END
+//
+//    IDD_WIZ97_EXTERIOR_BLANK, DIALOG
+//    BEGIN
+//        RIGHTMARGIN, 310
+//        VERTGUIDE, 115
+//        VERTGUIDE, 118
+//        VERTGUIDE, 127
+//        TOPMARGIN, 7
+//        BOTTOMMARGIN, 186
+//        HORZGUIDE, 8
+//        HORZGUIDE, 32
+//        HORZGUIDE, 40
+//        HORZGUIDE, 169
+//    END
+// END
+
+///////////////////////////////////////////////////////////////////////////////
+// CWizard97SheetWindow - client side for a Wizard 97 style wizard sheet
+
+class CWizard97SheetWindow : public CPropertySheetWindow
+{
+public:
+// Constructors
+	CWizard97SheetWindow(HWND hWnd = NULL) : CPropertySheetWindow(hWnd)
+	{ }
+
+	CWizard97SheetWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Operations
+	HFONT GetExteriorPageTitleFont(void)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HFONT)::SendMessage(m_hWnd, GetMessage_GetExteriorPageTitleFont(), 0, 0L);
+	}
+
+	HFONT GetBulletFont(void)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HFONT)::SendMessage(m_hWnd, GetMessage_GetBulletFont(), 0, 0L);
+	}
+
+// Helpers
+	static UINT GetMessage_GetExteriorPageTitleFont()
+	{
+		static UINT uGetExteriorPageTitleFont = 0;
+		if(uGetExteriorPageTitleFont == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CWizard97SheetWindow::GetMessage_GetExteriorPageTitleFont().\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uGetExteriorPageTitleFont == 0)
+				uGetExteriorPageTitleFont = ::RegisterWindowMessage(_T("GetExteriorPageTitleFont_531AF056-B8BE-4c4c-B786-AC608DF0DF12"));
+
+			lock.Unlock();
+		}
+		ATLASSERT(uGetExteriorPageTitleFont != 0);
+		return uGetExteriorPageTitleFont;
+	}
+
+	static UINT GetMessage_GetBulletFont()
+	{
+		static UINT uGetBulletFont = 0;
+		if(uGetBulletFont == 0)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CWizard97SheetWindow::GetMessage_GetBulletFont().\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(uGetBulletFont == 0)
+				uGetBulletFont = ::RegisterWindowMessage(_T("GetBulletFont_AD347D08-8F65-45ef-982E-6352E8218AD5"));
+
+			lock.Unlock();
+		}
+		ATLASSERT(uGetBulletFont != 0);
+		return uGetBulletFont;
+	}
+
+// Implementation - override to prevent usage
+	HWND Create(LPCTSTR, HWND, ATL::_U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, ATL::_U_MENUorID = 0U, LPVOID = NULL)
+	{
+		ATLASSERT(FALSE);
+		return NULL;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWizard97SheetImpl - implements a Wizard 97 style wizard sheet
+
+template <class T, class TBase = CWizard97SheetWindow>
+class ATL_NO_VTABLE CWizard97SheetImpl : public CPropertySheetImpl< T, TBase >
+{
+protected:
+// Typedefs
+	typedef CWizard97SheetImpl< T, TBase > thisClass;
+	typedef CPropertySheetImpl< T, TBase > baseClass;
+
+// Member variables
+	CFont m_fontExteriorPageTitle;   // Welcome and Completion page title font
+	CFont m_fontBullet;              // Bullet font (used on static text 'h' to produce a small bullet)
+	bool m_bReceivedFirstSizeMessage;   
+
+public:
+	CWizard97SheetImpl(ATL::_U_STRINGorID title, ATL::_U_STRINGorID headerBitmap, ATL::_U_STRINGorID watermarkBitmap, UINT uStartPage = 0, HWND hWndParent = NULL) :
+			baseClass(title, uStartPage, hWndParent),
+			m_bReceivedFirstSizeMessage(false)
+	{
+		m_psh.dwFlags &= ~(PSH_NOCONTEXTHELP);
+		m_psh.dwFlags &= ~(PSH_WIZARD | PSH_WIZARD_LITE);
+
+		m_psh.dwFlags |= (PSH_HASHELP | PSH_WIZARDCONTEXTHELP);
+		m_psh.dwFlags |= PSH_WIZARD97;
+
+		baseClass::SetHeader(headerBitmap.m_lpstr);
+		baseClass::SetWatermark(watermarkBitmap.m_lpstr);
+	}
+
+// Overrides from base class
+	void OnSheetInitialized()
+	{
+		T* pT = static_cast<T*>(this);
+		pT->_InitializeFonts();
+
+		// We'd like to center the wizard here, but its too early.
+		// Instead, we'll do CenterWindow upon our first WM_SIZE message
+	}
+
+// Initialization
+	void _InitializeFonts()
+	{
+		// Setup the Title and Bullet Font
+		// (Property pages can send the "get external page title font" and "get bullet font" messages)
+		// The derived class needs to do the actual SetFont for the dialog items)
+
+		CFontHandle fontThisDialog = this->GetFont();
+		CClientDC dcScreen(NULL);
+
+		LOGFONT titleLogFont = {0};
+		LOGFONT bulletLogFont = {0};
+		fontThisDialog.GetLogFont(&titleLogFont);
+		fontThisDialog.GetLogFont(&bulletLogFont);
+
+		// The Wizard 97 Spec recommends to do the Title Font
+		// as Verdana Bold, 12pt.
+		titleLogFont.lfCharSet = DEFAULT_CHARSET;
+		titleLogFont.lfWeight = FW_BOLD;
+		SecureHelper::strcpy_x(titleLogFont.lfFaceName, _countof(titleLogFont.lfFaceName), _T("Verdana Bold"));
+		INT titleFontPointSize = 12;
+		titleLogFont.lfHeight = -::MulDiv(titleFontPointSize, dcScreen.GetDeviceCaps(LOGPIXELSY), 72);
+		m_fontExteriorPageTitle.CreateFontIndirect(&titleLogFont);
+
+		// The Wizard 97 Spec recommends to do Bullets by having
+		// static text of "h" in the Marlett font.
+		bulletLogFont.lfCharSet = DEFAULT_CHARSET;
+		bulletLogFont.lfWeight = FW_NORMAL;
+		SecureHelper::strcpy_x(bulletLogFont.lfFaceName, _countof(bulletLogFont.lfFaceName), _T("Marlett"));
+		INT bulletFontSize = 8;
+		bulletLogFont.lfHeight = -::MulDiv(bulletFontSize, dcScreen.GetDeviceCaps(LOGPIXELSY), 72);
+		m_fontBullet.CreateFontIndirect(&bulletLogFont);
+	}
+
+// Message Handling
+	BEGIN_MSG_MAP(thisClass)
+		MESSAGE_HANDLER(CWizard97SheetWindow::GetMessage_GetExteriorPageTitleFont(), OnGetExteriorPageTitleFont)
+		MESSAGE_HANDLER(CWizard97SheetWindow::GetMessage_GetBulletFont(), OnGetBulletFont)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		CHAIN_MSG_MAP(baseClass)
+	END_MSG_MAP()
+
+	LRESULT OnGetExteriorPageTitleFont(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return (LRESULT)(HFONT)m_fontExteriorPageTitle;
+	}
+
+	LRESULT OnGetBulletFont(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return (LRESULT)(HFONT)m_fontBullet;
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(!m_bReceivedFirstSizeMessage)
+		{
+			m_bReceivedFirstSizeMessage = true;
+			this->CenterWindow();
+		}
+
+		bHandled = FALSE;
+		return 0;
+	}
+};
+
+// for non-customized sheets
+class CWizard97Sheet : public CWizard97SheetImpl<CWizard97Sheet>
+{
+protected:
+// Typedefs
+	typedef CWizard97Sheet thisClass;
+	typedef CWizard97SheetImpl<CWizard97Sheet> baseClass;
+
+public:
+	CWizard97Sheet(ATL::_U_STRINGorID title, ATL::_U_STRINGorID headerBitmap, ATL::_U_STRINGorID watermarkBitmap, UINT uStartPage = 0, HWND hWndParent = NULL) :
+		baseClass(title, headerBitmap, watermarkBitmap, uStartPage, hWndParent)
+	{ }
+
+	BEGIN_MSG_MAP(thisClass)
+		CHAIN_MSG_MAP(baseClass)
+	END_MSG_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWizard97PageWindow - client side for a Wizard 97 style wizard page
+
+#define WIZARD97_EXTERIOR_CXDLG 317
+#define WIZARD97_EXTERIOR_CYDLG 193
+
+#define WIZARD97_INTERIOR_CXDLG 317
+#define WIZARD97_INTERIOR_CYDLG 143
+
+class CWizard97PageWindow : public CPropertyPageWindow
+{
+public:
+// Constructors
+	CWizard97PageWindow(HWND hWnd = NULL) : CPropertyPageWindow(hWnd)
+	{ }
+
+	CWizard97PageWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Attributes
+	CWizard97SheetWindow GetPropertySheet() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return CWizard97SheetWindow(GetParent());
+	}
+
+// Operations
+	HFONT GetExteriorPageTitleFont(void)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return GetPropertySheet().GetExteriorPageTitleFont();
+	}
+
+	HFONT GetBulletFont(void)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return GetPropertySheet().GetBulletFont();
+	}
+
+// Implementation - overrides to prevent usage
+	HWND Create(LPCTSTR, HWND, ATL::_U_RECT = NULL, LPCTSTR = NULL, DWORD = 0, DWORD = 0, ATL::_U_MENUorID = 0U, LPVOID = NULL)
+	{
+		ATLASSERT(FALSE);
+		return NULL;
+	}
+
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWizard97PageImpl - implements a Wizard 97 style wizard page
+
+template <class T, class TBase = CWizard97PageWindow>
+class ATL_NO_VTABLE CWizard97PageImpl : public CPropertyPageImpl< T, TBase >
+{
+protected:
+// Typedefs
+	typedef CWizard97PageImpl< T, TBase > thisClass;
+	typedef CPropertyPageImpl< T, TBase > baseClass;
+
+public:
+	CWizard97PageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : baseClass(title)
+	{ }
+
+// Message Handling
+	BEGIN_MSG_MAP(thisClass)
+		CHAIN_MSG_MAP(baseClass)
+	END_MSG_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWizard97ExteriorPageImpl - implements a Wizard 97 style exterior wizard page
+
+template <class T, class TBase = CWizard97PageWindow>
+class ATL_NO_VTABLE CWizard97ExteriorPageImpl : public CPropertyPageImpl< T, TBase >
+{
+protected:
+// Typedefs
+	typedef CWizard97ExteriorPageImpl< T, TBase > thisClass;
+	typedef CPropertyPageImpl< T, TBase > baseClass;
+
+public:
+// Constructors
+	CWizard97ExteriorPageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : baseClass(title)
+	{
+		m_psp.dwFlags |= PSP_HASHELP;
+		m_psp.dwFlags |= PSP_HIDEHEADER;
+	}
+
+// Message Handling
+	BEGIN_MSG_MAP(thisClass)
+		CHAIN_MSG_MAP(baseClass)
+	END_MSG_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CWizard97InteriorPageImpl - implements a Wizard 97 style interior wizard page
+
+template <class T, class TBase = CWizard97PageWindow>
+class ATL_NO_VTABLE CWizard97InteriorPageImpl : public CPropertyPageImpl< T, TBase >
+{
+protected:
+// Typedefs
+	typedef CWizard97InteriorPageImpl< T, TBase > thisClass;
+	typedef CPropertyPageImpl< T, TBase > baseClass;
+
+public:
+// Constructors
+	CWizard97InteriorPageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : baseClass(title)
+	{
+		m_psp.dwFlags |= PSP_HASHELP;
+		m_psp.dwFlags &= ~PSP_HIDEHEADER;
+		m_psp.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
+
+		// Be sure to have the derived class define this in the constructor.
+		// We'll default it to something obvious in case its forgotten.
+		baseClass::SetHeaderTitle(_T("Call SetHeaderTitle in Derived Class"));
+		baseClass::SetHeaderSubTitle(_T("Call SetHeaderSubTitle in the constructor of the Derived Class."));
+	}
+
+// Message Handling
+	BEGIN_MSG_MAP(thisClass)
+		CHAIN_MSG_MAP(baseClass)
+	END_MSG_MAP()
+};
+
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Aero Wizard support
+
+#if (_WIN32_WINNT >= 0x0600) && !defined(_WIN32_WCE)
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardFrameWindow - client side for an Aero Wizard frame window
+
+class CAeroWizardFrameWindow : public CPropertySheetWindow
+{
+public:
+// Constructors
+	CAeroWizardFrameWindow(HWND hWnd = NULL) : CPropertySheetWindow(hWnd)
+	{ }
+
+	CAeroWizardFrameWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Operations - new, Aero Wizard only
+	void SetNextText(LPCWSTR lpszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_SETNEXTTEXT, 0, (LPARAM)lpszText);
+	}
+
+	void ShowWizardButtons(DWORD dwButtons, DWORD dwStates)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::PostMessage(m_hWnd, PSM_SHOWWIZBUTTONS, (WPARAM)dwStates, (LPARAM)dwButtons);
+	}
+
+	void EnableWizardButtons(DWORD dwButtons, DWORD dwStates)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::PostMessage(m_hWnd, PSM_ENABLEWIZBUTTONS, (WPARAM)dwStates, (LPARAM)dwButtons);
+	}
+
+	void SetButtonText(DWORD dwButton, LPCWSTR lpszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, PSM_SETBUTTONTEXT, (WPARAM)dwButton, (LPARAM)lpszText);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardFrameImpl - implements an Aero Wizard frame
+
+template <class T, class TBase = CAeroWizardFrameWindow>
+class ATL_NO_VTABLE CAeroWizardFrameImpl : public CPropertySheetImpl<T, TBase >
+{
+public:
+// Constructor
+	CAeroWizardFrameImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL) :
+		CPropertySheetImpl<T, TBase >(title, uStartPage, hWndParent)
+	{
+		m_psh.dwFlags |= PSH_WIZARD | PSH_AEROWIZARD;
+	}
+
+// Operations
+	void EnableResizing()
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		m_psh.dwFlags |= PSH_RESIZABLE;
+	}
+
+	void UseHeaderBitmap()
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		m_psh.dwFlags |= PSH_HEADERBITMAP;
+	}
+
+	void SetNoMargin()
+	{
+		ATLASSERT(m_hWnd == NULL);   // can't do this after it's created
+		m_psh.dwFlags |= PSH_NOMARGIN;
+	}
+
+// Override to prevent use
+	HWND Create(HWND /*hWndParent*/ = NULL)
+	{
+		ATLASSERT(FALSE);   // not supported for Aero Wizard
+		return NULL;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardFrame - for non-customized frames
+
+class CAeroWizardFrame : public CAeroWizardFrameImpl<CAeroWizardFrame>
+{
+public:
+	CAeroWizardFrame(ATL::_U_STRINGorID title = (LPCTSTR)NULL, UINT uStartPage = 0, HWND hWndParent = NULL)
+		: CAeroWizardFrameImpl<CAeroWizardFrame>(title, uStartPage, hWndParent)
+	{ }
+
+	BEGIN_MSG_MAP(CAeroWizardFrame)
+		MESSAGE_HANDLER(WM_COMMAND, CAeroWizardFrameImpl<CAeroWizardFrame>::OnCommand)
+	END_MSG_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardPageWindow - client side for an Aero Wizard page
+
+class CAeroWizardPageWindow : public CPropertyPageWindow
+{
+public:
+// Constructors
+	CAeroWizardPageWindow(HWND hWnd = NULL) : CPropertyPageWindow(hWnd)
+	{ }
+
+	CAeroWizardPageWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Attributes
+	CAeroWizardFrameWindow GetAeroWizardFrame() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		// This is not really top-level frame window, but it processes all frame messages
+		return CAeroWizardFrameWindow(GetParent());
+	}
+
+// Operations - new, Aero Wizard only
+	void SetNextText(LPCWSTR lpszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetAeroWizardFrame().SetNextText(lpszText);
+	}
+
+	void ShowWizardButtons(DWORD dwButtons, DWORD dwStates)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetAeroWizardFrame().ShowWizardButtons(dwButtons, dwStates);
+	}
+
+	void EnableWizardButtons(DWORD dwButtons, DWORD dwStates)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetAeroWizardFrame().EnableWizardButtons(dwButtons, dwStates);
+	}
+
+	void SetButtonText(DWORD dwButton, LPCWSTR lpszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetParent() != NULL);
+		GetAeroWizardFrame().SetButtonText(dwButton, lpszText);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardPageImpl - implements an Aero Wizard page
+
+template <class T, class TBase = CAeroWizardPageWindow>
+class ATL_NO_VTABLE CAeroWizardPageImpl : public CPropertyPageImpl<T, TBase >
+{
+public:
+	CAeroWizardPageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : CPropertyPageImpl<T, TBase >(title)
+	{ }
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardPage - for non-customized pages
+
+template <WORD t_wDlgTemplateID>
+class CAeroWizardPage : public CAeroWizardPageImpl<CAeroWizardPage<t_wDlgTemplateID> >
+{
+public:
+	enum { IDD = t_wDlgTemplateID };
+
+	CAeroWizardPage(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : CAeroWizardPageImpl<CAeroWizardPage>(title)
+	{ }
+
+	DECLARE_EMPTY_MSG_MAP()
+};
+
+
+#ifndef _ATL_NO_HOSTING
+
+// Note: You must #include <atlhost.h> to use these classes
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardAxPageImpl - Aero Wizard page that hosts ActiveX controls
+
+template <class T, class TBase = CAeroWizardPageWindow>
+class ATL_NO_VTABLE CAeroWizardAxPageImpl : public CAxPropertyPageImpl< T, TBase >
+{
+public:
+	CAeroWizardAxPageImpl(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : CAxPropertyPageImpl< T, TBase >(title)
+	{ }
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroWizardAxPage - for non-customized pages
+
+template <WORD t_wDlgTemplateID>
+class CAeroWizardAxPage : public CAeroWizardAxPageImpl<CAeroWizardAxPage<t_wDlgTemplateID> >
+{
+public:
+	enum { IDD = t_wDlgTemplateID };
+
+	CAeroWizardAxPage(ATL::_U_STRINGorID title = (LPCTSTR)NULL) : CAeroWizardAxPageImpl<CAeroWizardAxPage>(title)
+	{ }
+
+#if (_WIN32_IE >= 0x0500) || (_ATL_VER >= 0x0700)
+	// not empty so we handle accelerators/create controls
+	BEGIN_MSG_MAP(CAeroWizardAxPage)
+		CHAIN_MSG_MAP(CAeroWizardAxPageImpl<CAeroWizardAxPage<t_wDlgTemplateID> >)
+	END_MSG_MAP()
+#else // !((_WIN32_IE >= 0x0500) || (_ATL_VER >= 0x0700))
+	DECLARE_EMPTY_MSG_MAP()
+#endif // !((_WIN32_IE >= 0x0500) || (_ATL_VER >= 0x0700))
+};
+
+#endif // _ATL_NO_HOSTING
+
+#endif // (_WIN32_WINNT >= 0x0600) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// TaskDialog support
+
+#if ((_WIN32_WINNT >= 0x0600) || defined(_WTL_TASKDIALOG)) && !defined(_WIN32_WCE)
+
+///////////////////////////////////////////////////////////////////////////////
+// AtlTaskDialog - support for TaskDialog() function
+
+inline int AtlTaskDialog(HWND hWndParent, 
+                         ATL::_U_STRINGorID WindowTitle, ATL::_U_STRINGorID MainInstructionText, ATL::_U_STRINGorID ContentText, 
+                         TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons = 0U, ATL::_U_STRINGorID Icon = (LPCTSTR)NULL)
+{
+	int nRet = -1;
+
+#ifdef _WTL_TASKDIALOG_DIRECT
+	USES_CONVERSION;
+	HRESULT hRet = ::TaskDialog(hWndParent, ModuleHelper::GetResourceInstance(), 
+		IS_INTRESOURCE(WindowTitle.m_lpstr) ? (LPCWSTR) WindowTitle.m_lpstr : T2CW(WindowTitle.m_lpstr), 
+		IS_INTRESOURCE(MainInstructionText.m_lpstr) ? (LPCWSTR) MainInstructionText.m_lpstr : T2CW(MainInstructionText.m_lpstr), 
+		IS_INTRESOURCE(ContentText.m_lpstr) ?  (LPCWSTR) ContentText.m_lpstr : T2CW(ContentText.m_lpstr), 
+		dwCommonButtons, 
+		IS_INTRESOURCE(Icon.m_lpstr) ? (LPCWSTR) Icon.m_lpstr : T2CW(Icon.m_lpstr),
+		&nRet);
+	ATLVERIFY(SUCCEEDED(hRet));
+#else
+	// This allows apps to run on older versions of Windows
+	typedef HRESULT (STDAPICALLTYPE *PFN_TaskDialog)(HWND hwndParent, HINSTANCE hInstance, PCWSTR pszWindowTitle, PCWSTR pszMainInstruction, PCWSTR pszContent, TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons, PCWSTR pszIcon, int* pnButton);
+
+	HMODULE m_hCommCtrlDLL = ::LoadLibrary(_T("comctl32.dll"));
+	if(m_hCommCtrlDLL != NULL)
+	{
+		PFN_TaskDialog pfnTaskDialog = (PFN_TaskDialog)::GetProcAddress(m_hCommCtrlDLL, "TaskDialog");
+		if(pfnTaskDialog != NULL)
+		{
+			USES_CONVERSION;
+			HRESULT hRet = pfnTaskDialog(hWndParent, ModuleHelper::GetResourceInstance(), 
+				IS_INTRESOURCE(WindowTitle.m_lpstr) ? (LPCWSTR) WindowTitle.m_lpstr : T2CW(WindowTitle.m_lpstr), 
+				IS_INTRESOURCE(MainInstructionText.m_lpstr) ? (LPCWSTR) MainInstructionText.m_lpstr : T2CW(MainInstructionText.m_lpstr), 
+				IS_INTRESOURCE(ContentText.m_lpstr) ?  (LPCWSTR) ContentText.m_lpstr : T2CW(ContentText.m_lpstr), 
+				dwCommonButtons, 
+				IS_INTRESOURCE(Icon.m_lpstr) ? (LPCWSTR) Icon.m_lpstr : T2CW(Icon.m_lpstr),
+				&nRet);
+			ATLVERIFY(SUCCEEDED(hRet));
+		}
+
+		::FreeLibrary(m_hCommCtrlDLL);
+	}
+#endif
+
+	return nRet;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTaskDialogConfig - TASKDIALOGCONFIG wrapper
+
+class CTaskDialogConfig : public TASKDIALOGCONFIG
+{
+public:
+// Constructor
+	CTaskDialogConfig()
+	{
+		Init();
+	}
+
+	void Init()
+	{
+		memset(this, 0, sizeof(TASKDIALOGCONFIG));   // initialize structure to 0/NULL
+		this->cbSize = sizeof(TASKDIALOGCONFIG);
+		this->hInstance = ModuleHelper::GetResourceInstance();
+	}
+
+// Operations - setting values
+	// common buttons
+	void SetCommonButtons(TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons)
+	{
+		this->dwCommonButtons = dwCommonButtons;
+	}
+
+	// window title text
+	void SetWindowTitle(UINT nID)
+	{
+		this->pszWindowTitle = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetWindowTitle(LPCWSTR lpstrWindowTitle)
+	{
+		this->pszWindowTitle = lpstrWindowTitle;
+	}
+
+	// main icon
+	void SetMainIcon(HICON hIcon)
+	{
+		this->dwFlags |= TDF_USE_HICON_MAIN;
+		this->hMainIcon = hIcon;
+	}
+
+	void SetMainIcon(UINT nID)
+	{
+		this->dwFlags &= ~TDF_USE_HICON_MAIN;
+		this->pszMainIcon = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetMainIcon(LPCWSTR lpstrMainIcon)
+	{
+		this->dwFlags &= ~TDF_USE_HICON_MAIN;
+		this->pszMainIcon = lpstrMainIcon;
+	}
+
+	// main instruction text
+	void SetMainInstructionText(UINT nID)
+	{
+		this->pszMainInstruction = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetMainInstructionText(LPCWSTR lpstrMainInstruction)
+	{
+		this->pszMainInstruction = lpstrMainInstruction;
+	}
+
+	// content text
+	void SetContentText(UINT nID)
+	{
+		this->pszContent = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetContentText(LPCWSTR lpstrContent)
+	{
+		this->pszContent = lpstrContent;
+	}
+
+	// buttons
+	void SetButtons(const TASKDIALOG_BUTTON* pButtons, UINT cButtons, int nDefaultButton = 0)
+	{
+		this->pButtons = pButtons;
+		this->cButtons = cButtons;
+		if(nDefaultButton != 0)
+			this->nDefaultButton = nDefaultButton;
+	}
+
+	void SetDefaultButton(int nDefaultButton)
+	{
+		this->nDefaultButton = nDefaultButton;
+	}
+
+	// radio buttons
+	void SetRadioButtons(const TASKDIALOG_BUTTON* pRadioButtons, UINT cRadioButtons, int nDefaultRadioButton = 0)
+	{
+		this->pRadioButtons = pRadioButtons;
+		this->cRadioButtons = cRadioButtons;
+		if(nDefaultRadioButton != 0)
+			this->nDefaultRadioButton = nDefaultRadioButton;
+	}
+
+	void SetDefaultRadioButton(int nDefaultRadioButton)
+	{
+		this->nDefaultRadioButton = nDefaultRadioButton;
+	}
+
+	// verification text
+	void SetVerificationText(UINT nID)
+	{
+		this->pszVerificationText = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetVerificationText(LPCWSTR lpstrVerificationText)
+	{
+		this->pszVerificationText = lpstrVerificationText;
+	}
+
+	// expanded information text
+	void SetExpandedInformationText(UINT nID)
+	{
+		this->pszExpandedInformation = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetExpandedInformationText(LPCWSTR lpstrExpandedInformation)
+	{
+		this->pszExpandedInformation = lpstrExpandedInformation;
+	}
+
+	// expanded control text
+	void SetExpandedControlText(UINT nID)
+	{
+		this->pszExpandedControlText = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetExpandedControlText(LPCWSTR lpstrExpandedControlText)
+	{
+		this->pszExpandedControlText = lpstrExpandedControlText;
+	}
+
+	// collapsed control text
+	void SetCollapsedControlText(UINT nID)
+	{
+		this->pszCollapsedControlText = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetCollapsedControlText(LPCWSTR lpstrCollapsedControlText)
+	{
+		this->pszCollapsedControlText = lpstrCollapsedControlText;
+	}
+
+	// footer icon
+	void SetFooterIcon(HICON hIcon)
+	{
+		this->dwFlags |= TDF_USE_HICON_FOOTER;
+		this->hFooterIcon = hIcon;
+	}
+
+	void SetFooterIcon(UINT nID)
+	{
+		this->dwFlags &= ~TDF_USE_HICON_FOOTER;
+		this->pszFooterIcon = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetFooterIcon(LPCWSTR lpstrFooterIcon)
+	{
+		this->dwFlags &= ~TDF_USE_HICON_FOOTER;
+		this->pszFooterIcon = lpstrFooterIcon;
+	}
+
+	// footer text
+	void SetFooterText(UINT nID)
+	{
+		this->pszFooter = MAKEINTRESOURCEW(nID);
+	}
+
+	void SetFooterText(LPCWSTR lpstrFooterText)
+	{
+		this->pszFooter = lpstrFooterText;
+	}
+
+	// width (in DLUs)
+	void SetWidth(UINT cxWidth)
+	{
+		this->cxWidth = cxWidth;
+	}
+
+	// modify flags
+	void ModifyFlags(DWORD dwRemove, DWORD dwAdd)
+	{
+		this->dwFlags = (this->dwFlags & ~dwRemove) | dwAdd;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTaskDialogImpl - implements a Task Dialog
+
+template <class T>
+class ATL_NO_VTABLE CTaskDialogImpl
+{
+public:
+	CTaskDialogConfig m_tdc;
+	HWND m_hWnd;   // used only in callback functions
+
+// Constructor
+	CTaskDialogImpl(HWND hWndParent = NULL) : m_hWnd(NULL)
+	{
+		m_tdc.hwndParent = hWndParent;
+		m_tdc.pfCallback = T::TaskDialogCallback;
+		m_tdc.lpCallbackData = (LONG_PTR)static_cast<T*>(this);
+	}
+
+// Operations
+	HRESULT DoModal(HWND hWndParent = ::GetActiveWindow(), int* pnButton = NULL, int* pnRadioButton = NULL, BOOL* pfVerificationFlagChecked = NULL)
+	{
+		if(m_tdc.hwndParent == NULL)
+			m_tdc.hwndParent = hWndParent;
+
+#ifdef _WTL_TASKDIALOG_DIRECT
+		return ::TaskDialogIndirect(&m_tdc, pnButton, pnRadioButton, pfVerificationFlagChecked);
+#else
+
+		// This allows apps to run on older versions of Windows
+		typedef HRESULT (STDAPICALLTYPE *PFN_TaskDialogIndirect)(const TASKDIALOGCONFIG* pTaskConfig, int* pnButton, int* pnRadioButton, BOOL* pfVerificationFlagChecked);
+
+		HRESULT hRet = E_UNEXPECTED;
+		HMODULE m_hCommCtrlDLL = ::LoadLibrary(_T("comctl32.dll"));
+		if(m_hCommCtrlDLL != NULL)
+		{
+			PFN_TaskDialogIndirect pfnTaskDialogIndirect = (PFN_TaskDialogIndirect)::GetProcAddress(m_hCommCtrlDLL, "TaskDialogIndirect");
+			if(pfnTaskDialogIndirect != NULL)
+				hRet = pfnTaskDialogIndirect(&m_tdc, pnButton, pnRadioButton, pfVerificationFlagChecked);
+
+			::FreeLibrary(m_hCommCtrlDLL);
+		}
+
+		return hRet;
+#endif
+	}
+
+// Operations - setting values of TASKDIALOGCONFIG
+	// common buttons
+	void SetCommonButtons(TASKDIALOG_COMMON_BUTTON_FLAGS dwCommonButtons)
+	{	m_tdc.SetCommonButtons(dwCommonButtons); }
+	// window title text
+	void SetWindowTitle(UINT nID)
+	{	m_tdc.SetWindowTitle(nID); }
+	void SetWindowTitle(LPCWSTR lpstrWindowTitle)
+	{	m_tdc.SetWindowTitle(lpstrWindowTitle); }
+	// main icon
+	void SetMainIcon(HICON hIcon)
+	{	m_tdc.SetMainIcon(hIcon); }
+	void SetMainIcon(UINT nID)
+	{	m_tdc.SetMainIcon(nID); }
+	void SetMainIcon(LPCWSTR lpstrMainIcon)
+	{	m_tdc.SetMainIcon(lpstrMainIcon); }
+	// main instruction text
+	void SetMainInstructionText(UINT nID)
+	{	m_tdc.SetMainInstructionText(nID); }
+	void SetMainInstructionText(LPCWSTR lpstrMainInstruction)
+	{	m_tdc.SetMainInstructionText(lpstrMainInstruction); }
+	// content text
+	void SetContentText(UINT nID)
+	{	m_tdc.SetContentText(nID); }
+	void SetContentText(LPCWSTR lpstrContent)
+	{	m_tdc.SetContentText(lpstrContent); }
+	// buttons
+	void SetButtons(const TASKDIALOG_BUTTON* pButtons, UINT cButtons, int nDefaultButton = 0)
+	{	m_tdc.SetButtons(pButtons, cButtons, nDefaultButton); }
+	void SetDefaultButton(int nDefaultButton)
+	{	m_tdc.SetDefaultButton(nDefaultButton); }
+	// radio buttons
+	void SetRadioButtons(const TASKDIALOG_BUTTON* pRadioButtons, UINT cRadioButtons, int nDefaultRadioButton = 0)
+	{	m_tdc.SetRadioButtons(pRadioButtons, cRadioButtons, nDefaultRadioButton); }
+	void SetDefaultRadioButton(int nDefaultRadioButton)
+	{	m_tdc.SetDefaultRadioButton(nDefaultRadioButton); }
+	// verification text
+	void SetVerificationText(UINT nID)
+	{	m_tdc.SetVerificationText(nID); }
+	void SetVerificationText(LPCWSTR lpstrVerificationText)
+	{	m_tdc.SetVerificationText(lpstrVerificationText); }
+	// expanded information text
+	void SetExpandedInformationText(UINT nID)
+	{	m_tdc.SetExpandedInformationText(nID); }
+	void SetExpandedInformationText(LPCWSTR lpstrExpandedInformation)
+	{	m_tdc.SetExpandedInformationText(lpstrExpandedInformation); }
+	// expanded control text
+	void SetExpandedControlText(UINT nID)
+	{	m_tdc.SetExpandedControlText(nID); }
+	void SetExpandedControlText(LPCWSTR lpstrExpandedControlText)
+	{	m_tdc.SetExpandedControlText(lpstrExpandedControlText); }
+	// collapsed control text
+	void SetCollapsedControlText(UINT nID)
+	{	m_tdc.SetCollapsedControlText(nID); }
+	void SetCollapsedControlText(LPCWSTR lpstrCollapsedControlText)
+	{	m_tdc.SetCollapsedControlText(lpstrCollapsedControlText); }
+	// footer icon
+	void SetFooterIcon(HICON hIcon)
+	{	m_tdc.SetFooterIcon(hIcon); }
+	void SetFooterIcon(UINT nID)
+	{	m_tdc.SetFooterIcon(nID); }
+	void SetFooterIcon(LPCWSTR lpstrFooterIcon)
+	{	m_tdc.SetFooterIcon(lpstrFooterIcon); }
+	// footer text
+	void SetFooterText(UINT nID)
+	{	m_tdc.SetFooterText(nID); }
+	void SetFooterText(LPCWSTR lpstrFooterText)
+	{	m_tdc.SetFooterText(lpstrFooterText); }
+	// width (in DLUs)
+	void SetWidth(UINT cxWidth)
+	{	m_tdc.SetWidth(cxWidth); }
+	// modify flags
+	void ModifyFlags(DWORD dwRemove, DWORD dwAdd)
+	{	m_tdc.ModifyFlags(dwRemove, dwAdd); }
+
+// Implementation
+	static HRESULT CALLBACK TaskDialogCallback(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LONG_PTR lpRefData)
+	{
+		T* pT = (T*)lpRefData;
+		ATLASSERT(pT->m_hWnd == NULL || pT->m_hWnd == hWnd);
+
+		BOOL bRet = FALSE;
+		switch(uMsg)
+		{
+		case TDN_DIALOG_CONSTRUCTED:
+			pT->m_hWnd = hWnd;
+			pT->OnDialogConstructed();
+			break;
+		case TDN_CREATED:
+			pT->OnCreated();
+			break;
+		case TDN_BUTTON_CLICKED:
+			bRet = pT->OnButtonClicked((int)wParam);
+			break;
+		case TDN_RADIO_BUTTON_CLICKED:
+			pT->OnRadioButtonClicked((int)wParam);
+			break;
+		case TDN_HYPERLINK_CLICKED:
+			pT->OnHyperlinkClicked((LPCWSTR)lParam);
+			break;
+		case TDN_EXPANDO_BUTTON_CLICKED:
+			pT->OnExpandoButtonClicked((wParam != 0));
+			break;
+		case TDN_VERIFICATION_CLICKED:
+			pT->OnVerificationClicked((wParam != 0));
+			break;
+		case TDN_HELP:
+			pT->OnHelp();
+			break;
+		case TDN_TIMER:
+			bRet = pT->OnTimer((DWORD)wParam);
+			break;
+		case TDN_NAVIGATED:
+			pT->OnNavigated();
+			break;
+		case TDN_DESTROYED:
+			pT->OnDestroyed();
+			pT->m_hWnd = NULL;
+			break;
+		default:
+			ATLTRACE2(atlTraceUI, 0, _T("Unknown notification received in CTaskDialogImpl::TaskDialogCallback\n"));
+			break;
+		}
+
+		return (HRESULT)bRet;
+	}
+
+// Overrideables - notification handlers
+	void OnDialogConstructed()
+	{
+	}
+
+	void OnCreated()
+	{
+	}
+
+	BOOL OnButtonClicked(int /*nButton*/)
+	{
+		return FALSE;   // don't prevent dialog to close
+	}
+
+	void OnRadioButtonClicked(int /*nRadioButton*/)
+	{
+	}
+
+	void OnHyperlinkClicked(LPCWSTR /*pszHREF*/)
+	{
+	}
+
+	void OnExpandoButtonClicked(bool /*bExpanded*/)
+	{
+	}
+
+	void OnVerificationClicked(bool /*bChecked*/)
+	{
+	}
+
+	void OnHelp()
+	{
+	}
+
+	BOOL OnTimer(DWORD /*dwTickCount*/)
+	{
+		return FALSE;   // don't reset counter
+	}
+
+	void OnNavigated()
+	{
+	}
+
+	void OnDestroyed()
+	{
+	}
+
+// Commands - valid to call only from handlers
+	void NavigatePage(TASKDIALOGCONFIG& tdc)
+	{
+		ATLASSERT(m_hWnd != NULL);
+
+		tdc.cbSize = sizeof(TASKDIALOGCONFIG);
+		if(tdc.hwndParent == NULL)
+			tdc.hwndParent = m_tdc.hwndParent;
+		tdc.pfCallback = m_tdc.pfCallback;
+		tdc.lpCallbackData = m_tdc.lpCallbackData;
+		(TASKDIALOGCONFIG)m_tdc = tdc;
+
+		::SendMessage(m_hWnd, TDM_NAVIGATE_PAGE, 0, (LPARAM)&tdc);
+	}
+
+	// modify TASKDIALOGCONFIG values, then call this to update task dialog
+	void NavigatePage()
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_NAVIGATE_PAGE, 0, (LPARAM)&m_tdc);
+	}
+
+	void ClickButton(int nButton)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_CLICK_BUTTON, nButton, 0L);
+	}
+
+	void SetMarqueeProgressBar(BOOL bMarquee)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_SET_MARQUEE_PROGRESS_BAR, bMarquee, 0L);
+	}
+
+	BOOL SetProgressBarState(int nNewState)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		return (BOOL)::SendMessage(m_hWnd, TDM_SET_PROGRESS_BAR_STATE, nNewState, 0L);
+	}
+
+	DWORD SetProgressBarRange(int nMinRange, int nMaxRange)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		return (DWORD)::SendMessage(m_hWnd, TDM_SET_PROGRESS_BAR_RANGE, 0, MAKELPARAM(nMinRange, nMaxRange));
+	}
+
+	int SetProgressBarPos(int nNewPos)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		return (int)::SendMessage(m_hWnd, TDM_SET_PROGRESS_BAR_POS, nNewPos, 0L);
+	}
+
+	BOOL SetProgressBarMarquee(BOOL bMarquee, UINT uSpeed)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		return (BOOL)::SendMessage(m_hWnd, TDM_SET_PROGRESS_BAR_MARQUEE, bMarquee, uSpeed);
+	}
+
+	void SetElementText(TASKDIALOG_ELEMENTS element, LPCWSTR lpstrText)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_SET_ELEMENT_TEXT, element, (LPARAM)lpstrText);
+	}
+
+	void ClickRadioButton(int nRadioButton)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_CLICK_RADIO_BUTTON, nRadioButton, 0L);
+	}
+
+	void EnableButton(int nButton, BOOL bEnable)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_ENABLE_BUTTON, nButton, bEnable);
+	}
+
+	void EnableRadioButton(int nButton, BOOL bEnable)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_ENABLE_RADIO_BUTTON, nButton, bEnable);
+	}
+
+	void ClickVerification(BOOL bCheck, BOOL bFocus)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_CLICK_VERIFICATION, bCheck, bFocus);
+	}
+
+	void UpdateElementText(TASKDIALOG_ELEMENTS element, LPCWSTR lpstrText)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_UPDATE_ELEMENT_TEXT, element, (LPARAM)lpstrText);
+	}
+
+	void SetButtonElevationRequiredState(int nButton, BOOL bElevation)
+	{
+		ATLASSERT(m_hWnd != NULL);
+		::SendMessage(m_hWnd, TDM_SET_BUTTON_ELEVATION_REQUIRED_STATE, nButton, bElevation);
+	}
+
+	void UpdateIcon(TASKDIALOG_ICON_ELEMENTS element, HICON hIcon)
+	{
+		ATLASSERT(m_hWnd != NULL);
+#ifdef _DEBUG
+		if(element == TDIE_ICON_MAIN)
+			ATLASSERT((m_tdc.dwFlags & TDF_USE_HICON_MAIN) != 0);
+		else if(element == TDIE_ICON_FOOTER)
+			ATLASSERT((m_tdc.dwFlags & TDF_USE_HICON_FOOTER) != 0);
+#endif // _DEBUG
+		::SendMessage(m_hWnd, TDM_UPDATE_ICON, element, (LPARAM)hIcon);
+	}
+
+	void UpdateIcon(TASKDIALOG_ICON_ELEMENTS element, LPCWSTR lpstrIcon)
+	{
+		ATLASSERT(m_hWnd != NULL);
+#ifdef _DEBUG
+		if(element == TDIE_ICON_MAIN)
+			ATLASSERT((m_tdc.dwFlags & TDF_USE_HICON_MAIN) == 0);
+		else if(element == TDIE_ICON_FOOTER)
+			ATLASSERT((m_tdc.dwFlags & TDF_USE_HICON_FOOTER) == 0);
+#endif // _DEBUG
+		::SendMessage(m_hWnd, TDM_UPDATE_ICON, element, (LPARAM)lpstrIcon);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTaskDialog - for non-customized task dialogs
+
+class CTaskDialog : public CTaskDialogImpl<CTaskDialog>
+{
+public:
+	CTaskDialog(HWND hWndParent = NULL) : CTaskDialogImpl<CTaskDialog>(hWndParent)
+	{
+		m_tdc.pfCallback = NULL;
+	}
+};
+
+#endif // ((_WIN32_WINNT >= 0x0600) || defined(_WTL_TASKDIALOG)) && !defined(_WIN32_WCE)
+
+}; // namespace WTL
+
+#endif // __ATLDLGS_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atldwm.h b/GLideN64/src/GLideNUI-wtl/WTL/atldwm.h
new file mode 100644
index 00000000..e6377f4d
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atldwm.h
@@ -0,0 +1,461 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLDWM_H__
+#define __ATLDWM_H__
+
+#pragma once
+
+#ifdef _WIN32_WCE
+	#error atldwm.h is not supported on Windows CE
+#endif
+
+#ifndef __ATLAPP_H__
+	#error atldwm.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atldwm.h requires atlwin.h to be included first
+#endif
+
+#if (_WIN32_WINNT < 0x0600)
+	#error atldwm.h requires _WIN32_WINNT >= 0x0600
+#endif // (_WIN32_WINNT < 0x0600)
+
+#ifndef _DWMAPI_H_
+#include <dwmapi.h>
+#endif // _DWMAPI_H_
+#pragma comment(lib, "dwmapi.lib")
+
+// Note: To create an application that also runs on older versions of Windows,
+// use delay load of dwmapi.dll and ensure that no calls to the DWM API are
+// Delay load is NOT AUTOMATIC for VC++ 7, you have to link to delayimp.lib, 
+// and add dwmapi.dll in the Linker.Input.Delay Loaded DLLs section of the 
+// project properties.
+#if (_MSC_VER < 1300) && !defined(_WTL_NO_DWMAPI_DELAYLOAD)
+	#pragma comment(lib, "delayimp.lib")
+	#pragma comment(linker, "/delayload:dwmapi.dll")
+#endif // (_MSC_VER < 1300) && !defined(_WTL_NO_DWMAPI_DELAYLOAD)
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CDwm
+// CDwmImpl<T, TBase>
+// CDwmWindowT<TBase> - CDwmWindow
+// CDwmThumbnailT<t_bManaged, TBase>
+// CDwmThumbnail
+// CDwmThumbnailHandle
+// CAeroControlImpl
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CDwm - wrapper for DWM handle
+
+class CDwm
+{
+public:
+// Data members
+	static int m_nIsDwmSupported;
+
+// Constructor
+	CDwm()
+	{
+		IsDwmSupported();
+	}
+
+// Dwm support helper
+	static bool IsDwmSupported()
+	{
+		if(m_nIsDwmSupported == -1)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CDwm::IsDwmSupported.\n"));
+				ATLASSERT(FALSE);
+				return false;
+			}
+
+			if(m_nIsDwmSupported == -1)
+			{
+				HMODULE hDwmDLL = ::LoadLibrary(_T("dwmapi.dll"));
+				m_nIsDwmSupported = (hDwmDLL != NULL) ? 1 : 0;
+				if(hDwmDLL != NULL)
+					::FreeLibrary(hDwmDLL);
+			}
+
+			lock.Unlock();
+		}
+
+		ATLASSERT(m_nIsDwmSupported != -1);
+		return (m_nIsDwmSupported == 1);
+	}
+
+// Operations
+	BOOL DwmIsCompositionEnabled() const
+	{
+		if(!IsDwmSupported()) return FALSE;
+		BOOL bRes = FALSE;
+		return SUCCEEDED(::DwmIsCompositionEnabled(&bRes)) && bRes;
+	}
+
+	BOOL DwmEnableComposition(UINT fEnable)
+	{
+		if(!IsDwmSupported()) return FALSE;
+		return SUCCEEDED(::DwmEnableComposition(fEnable));
+	}
+
+	BOOL DwmEnableMMCSS(BOOL fEnableMMCSS)
+	{
+		if(!IsDwmSupported()) return FALSE;
+		return SUCCEEDED(::DwmEnableMMCSS(fEnableMMCSS));
+	}
+
+	HRESULT DwmGetColorizationColor(DWORD* pcrColorization, BOOL* pfOpaqueBlend)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		return ::DwmGetColorizationColor(pcrColorization, pfOpaqueBlend);
+	}
+
+	HRESULT DwmFlush()
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		return ::DwmFlush();
+	}
+};
+
+__declspec(selectany) int CDwm::m_nIsDwmSupported = -1;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDwmImpl - DWM window support
+
+template <class T, class TBase = CDwm>
+class CDwmImpl : public TBase
+{
+public:
+	HRESULT DwmEnableBlurBehindWindow(const DWM_BLURBEHIND* pBB)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmEnableBlurBehindWindow(pT->m_hWnd, pBB);
+	}
+
+	HRESULT DwmExtendFrameIntoClientArea(const MARGINS* pMargins)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmExtendFrameIntoClientArea(pT->m_hWnd, pMargins);
+	}
+
+	HRESULT DwmExtendFrameIntoEntireClientArea()
+	{
+		MARGINS margins = { -1 };
+		return DwmExtendFrameIntoClientArea(&margins);
+	}
+
+	HRESULT DwmGetCompositionTimingInfo(DWM_TIMING_INFO* pTimingInfo)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmGetCompositionTimingInfo(pT->m_hWnd, pTimingInfo);
+	}
+
+	HRESULT DwmGetWindowAttribute(DWORD dwAttribute, PVOID pvAttribute, DWORD cbAttribute)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmGetWindowAttribute(pT->m_hWnd, dwAttribute, pvAttribute, cbAttribute);
+	}
+
+	HRESULT DwmModifyPreviousDxFrameDuration(INT cRefreshes, BOOL fRelative)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmModifyPreviousDxFrameDuration(pT->m_hWnd, cRefreshes, fRelative);
+	}
+
+	HRESULT DwmSetDxFrameDuration(INT cRefreshes)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmSetDxFrameDuration(pT->m_hWnd, cRefreshes);
+	}
+
+	HRESULT DwmSetPresentParameters(DWM_PRESENT_PARAMETERS* pPresentParams)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmSetPresentParameters(pT->m_hWnd, pPresentParams);
+	}
+
+	HRESULT DwmSetWindowAttribute(DWORD dwAttribute, LPCVOID pvAttribute, DWORD cbAttribute)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmSetWindowAttribute(pT->m_hWnd, dwAttribute, pvAttribute, cbAttribute);
+	}
+
+	HRESULT DwmAttachMilContent()
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmAttachMilContent(pT->m_hWnd);
+	}
+
+	HRESULT DwmDetachMilContent()
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DwmDetachMilContent(pT->m_hWnd);
+	}
+};
+
+template <class TBase>
+class CDwmWindowT : public TBase, public CDwmImpl<CDwmWindowT< TBase > >
+{
+public:
+	CDwmWindowT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CDwmWindowT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+};
+
+typedef CDwmWindowT<ATL::CWindow>	CDwmWindow;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDwmThumbnail - provides DWM thumbnail support
+
+template <bool t_bManaged, class TBase = CDwm>
+class CDwmThumbnailT : public TBase
+{
+public:
+// Data members
+	HTHUMBNAIL m_hThumbnail;
+
+// Constructor
+	CDwmThumbnailT(HTHUMBNAIL hThumbnail = NULL) : m_hThumbnail(hThumbnail)
+	{
+	}
+
+	~CDwmThumbnailT()
+	{
+		if(t_bManaged && m_hThumbnail != NULL)
+			Unregister();
+	}
+
+// Operations
+	CDwmThumbnailT<t_bManaged, TBase>& operator =(HTHUMBNAIL hThumbnail)
+	{
+		Attach(hThumbnail);
+		return *this;
+	}
+
+	void Attach(HTHUMBNAIL hThumbnailNew)
+	{
+		if(t_bManaged && m_hThumbnail != NULL && m_hThumbnail != hThumbnailNew)
+			Unregister();
+		m_hThumbnail = hThumbnailNew;
+	}
+
+	HTHUMBNAIL Detach()
+	{
+		HTHUMBNAIL hThumbnail = m_hThumbnail;
+		m_hThumbnail = NULL;
+		return hThumbnail;
+	}
+
+	HRESULT Register(HWND hwndDestination, HWND hwndSource)
+	{
+		ATLASSERT(::IsWindow(hwndDestination));
+		ATLASSERT(::IsWindow(hwndSource));
+		ATLASSERT(m_hThumbnail==NULL);
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		return ::DwmRegisterThumbnail(hwndDestination, hwndSource, &m_hThumbnail);
+	}
+
+	HRESULT Unregister()
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		if(m_hThumbnail == NULL) return S_FALSE;
+		HRESULT Hr = ::DwmUnregisterThumbnail(m_hThumbnail);
+		if(SUCCEEDED(Hr)) m_hThumbnail = NULL;
+		return Hr;
+	}
+
+	operator HTHUMBNAIL() const { return m_hThumbnail; }
+
+	bool IsNull() const { return (m_hThumbnail == NULL); }
+
+	HRESULT UpdateProperties(const DWM_THUMBNAIL_PROPERTIES* ptnProperties)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		ATLASSERT(m_hThumbnail != NULL);
+		return ::DwmUpdateThumbnailProperties(m_hThumbnail, ptnProperties);
+	}
+
+// Attributes
+	HRESULT QuerySourceSize(PSIZE pSize)
+	{
+		if(!IsDwmSupported()) return E_NOTIMPL;
+		ATLASSERT(m_hThumbnail != NULL);
+		return ::DwmQueryThumbnailSourceSize(m_hThumbnail, pSize);
+	}
+};
+
+typedef CDwmThumbnailT<true, CDwm> CDwmThumbnail;
+typedef CDwmThumbnailT<false, CDwm> CDwmThumbnailHandle;
+
+
+#ifdef __ATLTHEME_H__
+
+///////////////////////////////////////////////////////////////////////////////
+// CAeroControlImpl - Base class for controls on Glass
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class CAeroControlImpl :
+	public CThemeImpl<T>,
+	public CBufferedPaintImpl<T>,
+	public ATL::CWindowImpl<T, TBase, TWinTraits>
+{
+public:
+	typedef CThemeImpl<T> _themeClass;
+	typedef CBufferedPaintImpl<T> _baseClass;
+	typedef ATL::CWindowImpl<T, TBase, TWinTraits> _windowClass;
+
+	CAeroControlImpl()
+	{
+		m_PaintParams.dwFlags = BPPF_ERASE;
+	}
+
+	static LPCWSTR GetThemeName()
+	{
+#ifdef _UNICODE
+		return TBase::GetWndClassName();
+#else
+		ATLASSERT(!_T("Return UNICODE string of window classname / theme class"));
+		return NULL;
+#endif // _UNICODE
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CAeroControlImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
+		CHAIN_MSG_MAP(_themeClass)
+		CHAIN_MSG_MAP(_baseClass)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Init();
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(IsThemingSupported()) Invalidate(FALSE);
+		bHandled = FALSE;
+		return 0;
+	}
+
+// Operations
+	BOOL SubclassWindow(HWND hWnd)
+	{
+		ATLASSERT(m_hWnd == NULL);
+		ATLASSERT(::IsWindow(hWnd));
+		BOOL bRet = _windowClass::SubclassWindow(hWnd);
+		if(bRet) {
+			T* pT = static_cast<T*>(this);
+			pT->Init();
+		}
+		return bRet;
+	}
+
+// Implementation
+	LRESULT DefWindowProc()
+	{
+		const _ATL_MSG* pMsg = m_pCurrentMsg;
+		LRESULT lRes = 0;
+		if(pMsg != NULL)
+			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
+		return lRes;
+	}
+
+	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		T* pT = static_cast<T*>(this);
+		LRESULT lRes = 0;
+		if( ::DwmDefWindowProc(pT->m_hWnd, uMsg, wParam, lParam, &lRes) ) return lRes;
+		return _windowClass::DefWindowProc(uMsg, wParam, lParam);
+	}
+
+	void DoBufferedPaint(HDC hDC, RECT& rcPaint)
+	{
+		T* pT = static_cast<T*>(this);
+		HDC hDCPaint = NULL;
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+		m_BufferedPaint.Begin(hDC, &rcClient, m_dwFormat, &m_PaintParams, &hDCPaint);
+		ATLASSERT(hDCPaint != NULL);
+		pT->DoAeroPaint(hDCPaint, rcClient, rcPaint);
+		m_BufferedPaint.End();
+	}
+
+	void DoPaint(HDC /*hdc*/, RECT& /*rcClient*/)
+	{
+		DefWindowProc();
+	}
+
+// Overridables
+	void Init()
+	{
+		T* pT = static_cast<T*>(this);
+		SetThemeClassList(pT->GetThemeName());
+		if(m_lpstrThemeClassList != NULL)
+			OpenThemeData();
+	}
+
+	void DoAeroPaint(HDC hDC, RECT& /*rcClient*/, RECT& rcPaint)
+	{
+		DefWindowProc(WM_PAINT, (WPARAM) hDC, 0L);
+		m_BufferedPaint.MakeOpaque(&rcPaint);
+	}
+};
+
+#endif // __ATLTHEME_H__
+
+
+}; // namespace WTL
+
+
+#endif // __ATLDWM_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlfind.h b/GLideN64/src/GLideNUI-wtl/WTL/atlfind.h
new file mode 100644
index 00000000..4f82824b
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlfind.h
@@ -0,0 +1,1032 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLFIND_H__
+#define __ATLFIND_H__
+
+#pragma once
+
+#ifdef _WIN32_WCE
+	#error atlfind.h is not supported on Windows CE
+#endif
+
+#ifndef __ATLCTRLS_H__
+	#error atlfind.h requires atlctrls.h to be included first
+#endif
+
+#ifndef __ATLDLGS_H__
+	#error atlfind.h requires atldlgs.h to be included first
+#endif
+
+#if !((defined(__ATLMISC_H__) && defined(_WTL_USE_CSTRING)) || defined(__ATLSTR_H__))
+	#error atlfind.h requires CString (either from ATL's atlstr.h or WTL's atlmisc.h with _WTL_USE_CSTRING)
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CEditFindReplaceImplBase<T, TFindReplaceDialog>
+// CEditFindReplaceImpl<T, TFindReplaceDialog>
+// CRichEditFindReplaceImpl<T, TFindReplaceDialog>
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CEditFindReplaceImplBase - Base class for mixin classes that
+// help implement Find/Replace for CEdit or CRichEditCtrl based window classes.
+
+template <class T, class TFindReplaceDialog = CFindReplaceDialog>
+class CEditFindReplaceImplBase
+{
+protected:
+// Typedefs
+	typedef CEditFindReplaceImplBase<T, TFindReplaceDialog> thisClass;
+
+// Data members
+	TFindReplaceDialog* m_pFindReplaceDialog;
+	_CSTRING_NS::CString m_sFindNext, m_sReplaceWith;
+	BOOL m_bFindOnly, m_bFirstSearch, m_bMatchCase, m_bWholeWord, m_bFindDown;
+	LONG m_nInitialSearchPos;
+	HCURSOR m_hOldCursor;
+
+// Enumerations
+	enum TranslationTextItem
+	{
+		eText_OnReplaceAllMessage   = 0,
+		eText_OnReplaceAllTitle     = 1,
+		eText_OnTextNotFoundMessage = 2,
+		eText_OnTextNotFoundTitle   = 3
+	};
+
+public:
+// Constructors
+	CEditFindReplaceImplBase() :
+		m_pFindReplaceDialog(NULL),
+		m_bFindOnly(TRUE),
+		m_bFirstSearch(TRUE),
+		m_bMatchCase(FALSE),
+		m_bWholeWord(FALSE),
+		m_bFindDown(TRUE),
+		m_nInitialSearchPos(0),
+		m_hOldCursor(NULL)
+	{
+	}
+
+// Message Handlers
+	BEGIN_MSG_MAP(thisClass)
+	ALT_MSG_MAP(1)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_HANDLER(TFindReplaceDialog::GetFindReplaceMsg(), OnFindReplaceCmd)
+		COMMAND_ID_HANDLER(ID_EDIT_FIND, OnEditFind)
+		COMMAND_ID_HANDLER(ID_EDIT_REPEAT, OnEditRepeat)
+		COMMAND_ID_HANDLER(ID_EDIT_REPLACE, OnEditReplace)
+	END_MSG_MAP()
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_pFindReplaceDialog != NULL)
+		{
+			m_pFindReplaceDialog->SendMessage(WM_CLOSE);
+			ATLASSERT(m_pFindReplaceDialog == NULL);
+		}
+
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnFindReplaceCmd(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+
+		TFindReplaceDialog* pDialog = TFindReplaceDialog::GetNotifier(lParam);
+		if(pDialog == NULL)
+		{
+			ATLASSERT(FALSE);
+			::MessageBeep(MB_ICONERROR);
+			return 1;
+		}
+		ATLASSERT(pDialog == m_pFindReplaceDialog);
+
+		LPFINDREPLACE findReplace = (LPFINDREPLACE)lParam;
+		if((m_pFindReplaceDialog != NULL) && (findReplace != NULL))
+		{
+			if(pDialog->FindNext())
+			{
+				pT->OnFindNext(pDialog->GetFindString(), pDialog->SearchDown(),
+					pDialog->MatchCase(), pDialog->MatchWholeWord());
+			}
+			else if(pDialog->ReplaceCurrent())
+			{
+				pT->OnReplaceSel(pDialog->GetFindString(),
+					pDialog->SearchDown(), pDialog->MatchCase(), pDialog->MatchWholeWord(),
+					pDialog->GetReplaceString());
+			}
+			else if(pDialog->ReplaceAll())
+			{
+				pT->OnReplaceAll(pDialog->GetFindString(), pDialog->GetReplaceString(),
+					pDialog->MatchCase(), pDialog->MatchWholeWord());
+			}
+			else if(pDialog->IsTerminating())
+			{
+				// Dialog is going away (but hasn't gone away yet)
+				// OnFinalMessage will "delete this"
+				pT->OnTerminatingFindReplaceDialog(m_pFindReplaceDialog);
+				m_pFindReplaceDialog = NULL;
+			}
+		}
+
+		return 0;
+	}
+
+	LRESULT OnEditFind(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->FindReplace(TRUE);
+
+		return 0;
+	}
+
+	LRESULT OnEditRepeat(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+
+		// If the user is holding down SHIFT when hitting F3, we'll
+		// search in reverse. Otherwise, we'll search forward.
+		// (be sure to have an accelerator mapped to ID_EDIT_REPEAT
+		// for both F3 and Shift+F3)
+		m_bFindDown = !((::GetKeyState(VK_SHIFT) & 0x8000) == 0x8000);
+
+		if(m_sFindNext.IsEmpty())
+		{
+			pT->FindReplace(TRUE);
+		}
+		else
+		{
+			if(!pT->FindTextSimple(m_sFindNext, m_bMatchCase, m_bWholeWord, m_bFindDown))
+				pT->TextNotFound(m_sFindNext);
+		}
+
+		return 0;
+	}
+
+	LRESULT OnEditReplace(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+
+		DWORD style = pT->GetStyle();
+		if((style & ES_READONLY) != ES_READONLY)
+		{
+			pT->FindReplace(FALSE);
+		}
+		else
+		{
+			// Don't allow replace when the edit control is read only
+			bHandled = FALSE;
+		}
+
+		return 0;
+	}
+
+// Operations (overrideable)
+	TFindReplaceDialog* CreateFindReplaceDialog(BOOL bFindOnly, // TRUE for Find, FALSE for FindReplace
+			LPCTSTR lpszFindWhat,
+			LPCTSTR lpszReplaceWith = NULL,
+			DWORD dwFlags = FR_DOWN,
+			HWND hWndParent = NULL)
+	{
+		// You can override all of this in a derived class
+
+		TFindReplaceDialog* findReplaceDialog = new TFindReplaceDialog();
+		if(findReplaceDialog == NULL)
+		{
+			::MessageBeep(MB_ICONHAND);
+		}
+		else
+		{
+			HWND hWndFindReplace = findReplaceDialog->Create(bFindOnly,
+				lpszFindWhat, lpszReplaceWith, dwFlags, hWndParent);
+			if(hWndFindReplace == NULL)
+			{
+				delete findReplaceDialog;
+				findReplaceDialog = NULL;
+			}
+			else
+			{
+				findReplaceDialog->SetActiveWindow();
+				findReplaceDialog->ShowWindow(SW_SHOW);
+			}
+		}
+
+		return findReplaceDialog;
+	}
+
+	void AdjustDialogPosition(HWND hWndDialog)
+	{
+		ATLASSERT((hWndDialog != NULL) && ::IsWindow(hWndDialog));
+
+		T* pT = static_cast<T*>(this);
+		LONG nStartChar = 0, nEndChar = 0;
+		// Send EM_GETSEL so we can use both Edit and RichEdit
+		// (CEdit::GetSel uses int&, and CRichEditCtrlT::GetSel uses LONG&)
+		::SendMessage(pT->m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
+		POINT point = pT->PosFromChar(nStartChar);
+		::ClientToScreen(pT->GetParent(), &point);
+		CRect rect;
+		::GetWindowRect(hWndDialog, &rect);
+		if(rect.PtInRect(point))
+		{
+			if(point.y > rect.Height())
+			{
+				rect.OffsetRect(0, point.y - rect.bottom - 20);
+			}
+			else
+			{
+				int nVertExt = GetSystemMetrics(SM_CYSCREEN);
+				if(point.y + rect.Height() < nVertExt)
+					rect.OffsetRect(0, 40 + point.y - rect.top);
+			}
+
+			::MoveWindow(hWndDialog, rect.left, rect.top, rect.Width(), rect.Height(), TRUE);
+		}
+	}
+
+	DWORD GetFindReplaceDialogFlags(void) const
+	{
+		DWORD dwFlags = 0;
+
+		if(m_bFindDown)
+			dwFlags |= FR_DOWN;
+		if(m_bMatchCase)
+			dwFlags |= FR_MATCHCASE;
+		if(m_bWholeWord)
+			dwFlags |= FR_WHOLEWORD;
+
+		return dwFlags;
+	}
+
+	void FindReplace(BOOL bFindOnly)
+	{
+		T* pT = static_cast<T*>(this);
+		m_bFirstSearch = TRUE;
+		if(m_pFindReplaceDialog != NULL)
+		{
+			if(m_bFindOnly == bFindOnly)
+			{
+				m_pFindReplaceDialog->SetActiveWindow();
+				m_pFindReplaceDialog->ShowWindow(SW_SHOW);
+				return;
+			}
+			else
+			{
+				m_pFindReplaceDialog->SendMessage(WM_CLOSE);
+				ATLASSERT(m_pFindReplaceDialog == NULL);
+			}
+		}
+
+		ATLASSERT(m_pFindReplaceDialog == NULL);
+
+		_CSTRING_NS::CString findNext;
+		pT->GetSelText(findNext);
+		// if selection is empty or spans multiple lines use old find text
+		if(findNext.IsEmpty() || (findNext.FindOneOf(_T("\n\r")) != -1))
+			findNext = m_sFindNext;
+		_CSTRING_NS::CString replaceWith = m_sReplaceWith;
+		DWORD dwFlags = pT->GetFindReplaceDialogFlags();
+
+		m_pFindReplaceDialog = pT->CreateFindReplaceDialog(bFindOnly,
+			findNext, replaceWith, dwFlags, pT->operator HWND());
+		ATLASSERT(m_pFindReplaceDialog != NULL);
+		if(m_pFindReplaceDialog != NULL)
+			m_bFindOnly = bFindOnly;
+	}
+
+	BOOL SameAsSelected(LPCTSTR lpszCompare, BOOL bMatchCase, BOOL /*bWholeWord*/)
+	{
+		T* pT = static_cast<T*>(this);
+
+		// check length first
+		size_t nLen = lstrlen(lpszCompare);
+		LONG nStartChar = 0, nEndChar = 0;
+		// Send EM_GETSEL so we can use both Edit and RichEdit
+		// (CEdit::GetSel uses int&, and CRichEditCtrlT::GetSel uses LONG&)
+		::SendMessage(pT->m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
+		if(nLen != (size_t)(nEndChar - nStartChar))
+			return FALSE;
+
+		// length is the same, check contents
+		_CSTRING_NS::CString selectedText;
+		pT->GetSelText(selectedText);
+
+		return (bMatchCase && selectedText.Compare(lpszCompare) == 0) ||
+			(!bMatchCase && selectedText.CompareNoCase(lpszCompare) == 0);
+	}
+
+	void TextNotFound(LPCTSTR lpszFind)
+	{
+		T* pT = static_cast<T*>(this);
+		m_bFirstSearch = TRUE;
+		pT->OnTextNotFound(lpszFind);
+	}
+
+	_CSTRING_NS::CString GetTranslationText(enum TranslationTextItem eItem) const
+	{
+		_CSTRING_NS::CString text;
+		switch(eItem)
+		{
+		case eText_OnReplaceAllMessage:
+			text = _T("Replaced %d occurances of \"%s\" with \"%s\"");
+			break;
+		case eText_OnReplaceAllTitle:
+			text = _T("Replace All");
+			break;
+		case eText_OnTextNotFoundMessage:
+			text = _T("Unable to find the text \"%s\"");
+			break;
+		case eText_OnTextNotFoundTitle:
+			text = _T("Text not found");
+			break;
+		}
+
+		return text;
+	}
+
+// Overrideable Handlers
+	void OnFindNext(LPCTSTR lpszFind, BOOL bFindDown, BOOL bMatchCase, BOOL bWholeWord)
+	{
+		T* pT = static_cast<T*>(this);
+
+		m_sFindNext = lpszFind;
+		m_bMatchCase = bMatchCase;
+		m_bWholeWord = bWholeWord;
+		m_bFindDown = bFindDown;
+
+		if(!pT->FindTextSimple(m_sFindNext, m_bMatchCase, m_bWholeWord, m_bFindDown))
+			pT->TextNotFound(m_sFindNext);
+		else
+			pT->AdjustDialogPosition(m_pFindReplaceDialog->operator HWND());
+	}
+
+	void OnReplaceSel(LPCTSTR lpszFind, BOOL bFindDown, BOOL bMatchCase, BOOL bWholeWord, LPCTSTR lpszReplace)
+	{
+		T* pT = static_cast<T*>(this);
+
+		m_sFindNext = lpszFind;
+		m_sReplaceWith = lpszReplace;
+		m_bMatchCase = bMatchCase;
+		m_bWholeWord = bWholeWord;
+		m_bFindDown = bFindDown;
+
+		if(pT->SameAsSelected(m_sFindNext, m_bMatchCase, m_bWholeWord))
+			pT->ReplaceSel(m_sReplaceWith);
+
+		if(!pT->FindTextSimple(m_sFindNext, m_bMatchCase, m_bWholeWord, m_bFindDown))
+			pT->TextNotFound(m_sFindNext);
+		else
+			pT->AdjustDialogPosition(m_pFindReplaceDialog->operator HWND());
+	}
+
+	void OnReplaceAll(LPCTSTR lpszFind, LPCTSTR lpszReplace, BOOL bMatchCase, BOOL bWholeWord)
+	{
+		T* pT = static_cast<T*>(this);
+
+		m_sFindNext = lpszFind;
+		m_sReplaceWith = lpszReplace;
+		m_bMatchCase = bMatchCase;
+		m_bWholeWord = bWholeWord;
+		m_bFindDown = TRUE;
+
+		// no selection or different than what looking for
+		if(!pT->SameAsSelected(m_sFindNext, m_bMatchCase, m_bWholeWord))
+		{
+			if(!pT->FindTextSimple(m_sFindNext, m_bMatchCase, m_bWholeWord, m_bFindDown))
+			{
+				pT->TextNotFound(m_sFindNext);
+				return;
+			}
+		}
+
+		pT->OnReplaceAllCoreBegin();
+
+		int replaceCount=0;
+		do
+		{
+			++replaceCount;
+			pT->ReplaceSel(m_sReplaceWith);
+		} while(pT->FindTextSimple(m_sFindNext, m_bMatchCase, m_bWholeWord, m_bFindDown));
+
+		pT->OnReplaceAllCoreEnd(replaceCount);
+	}
+
+	void OnReplaceAllCoreBegin()
+	{
+		T* pT = static_cast<T*>(this);
+
+		m_hOldCursor = ::SetCursor(::LoadCursor(NULL, IDC_WAIT));
+
+		pT->HideSelection(TRUE, FALSE);
+
+	}
+
+	void OnReplaceAllCoreEnd(int replaceCount)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->HideSelection(FALSE, FALSE);
+
+		::SetCursor(m_hOldCursor);
+
+		_CSTRING_NS::CString message = pT->GetTranslationText(eText_OnReplaceAllMessage);
+		if(message.GetLength() > 0)
+		{
+			_CSTRING_NS::CString formattedMessage;
+			formattedMessage.Format(message,
+				replaceCount, m_sFindNext, m_sReplaceWith);
+			if(m_pFindReplaceDialog != NULL)
+			{
+				m_pFindReplaceDialog->MessageBox(formattedMessage,
+					pT->GetTranslationText(eText_OnReplaceAllTitle),
+					MB_OK | MB_ICONINFORMATION | MB_APPLMODAL);
+			}
+			else
+			{
+				pT->MessageBox(formattedMessage,
+					pT->GetTranslationText(eText_OnReplaceAllTitle),
+					MB_OK | MB_ICONINFORMATION | MB_APPLMODAL);
+			}
+		}
+	}
+
+	void OnTextNotFound(LPCTSTR lpszFind)
+	{
+		T* pT = static_cast<T*>(this);
+		_CSTRING_NS::CString message = pT->GetTranslationText(eText_OnTextNotFoundMessage);
+		if(message.GetLength() > 0)
+		{
+			_CSTRING_NS::CString formattedMessage;
+			formattedMessage.Format(message, lpszFind);
+			if(m_pFindReplaceDialog != NULL)
+			{
+				m_pFindReplaceDialog->MessageBox(formattedMessage,
+					pT->GetTranslationText(eText_OnTextNotFoundTitle),
+					MB_OK | MB_ICONINFORMATION | MB_APPLMODAL);
+			}
+			else
+			{
+				pT->MessageBox(formattedMessage,
+					pT->GetTranslationText(eText_OnTextNotFoundTitle),
+					MB_OK | MB_ICONINFORMATION | MB_APPLMODAL);
+			}
+		}
+		else
+		{
+			::MessageBeep(MB_ICONHAND);
+		}
+	}
+
+	void OnTerminatingFindReplaceDialog(TFindReplaceDialog*& /*findReplaceDialog*/)
+	{
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CEditFindReplaceImpl - Mixin class for implementing Find/Replace for CEdit
+// based window classes.
+
+// Chain to CEditFindReplaceImpl message map. Your class must also derive from CEdit.
+// Example:
+// class CMyEdit : public CWindowImpl<CMyEdit, CEdit>,
+//                 public CEditFindReplaceImpl<CMyEdit>
+// {
+// public:
+//      BEGIN_MSG_MAP(CMyEdit)
+//              // your handlers...
+//              CHAIN_MSG_MAP_ALT(CEditFindReplaceImpl<CMyEdit>, 1)
+//      END_MSG_MAP()
+//      // other stuff...
+// };
+
+template <class T, class TFindReplaceDialog = CFindReplaceDialog>
+class CEditFindReplaceImpl : public CEditFindReplaceImplBase<T, TFindReplaceDialog>
+{
+protected:
+	typedef CEditFindReplaceImpl<T, TFindReplaceDialog> thisClass;
+	typedef CEditFindReplaceImplBase<T, TFindReplaceDialog> baseClass;
+
+// Data members
+	LPTSTR m_pShadowBuffer;     // Special shadow buffer only used in some cases.
+	UINT m_nShadowSize;
+	int m_bShadowBufferNeeded;  // TRUE, FALSE, < 0 => Need to check
+
+public:
+// Constructors
+	CEditFindReplaceImpl() :
+		m_pShadowBuffer(NULL),
+		m_nShadowSize(0),
+		m_bShadowBufferNeeded(-1)
+	{
+	}
+
+	virtual ~CEditFindReplaceImpl()
+	{
+		if(m_pShadowBuffer != NULL)
+		{
+			delete [] m_pShadowBuffer;
+			m_pShadowBuffer = NULL;
+		}
+	}
+
+// Message Handlers
+	BEGIN_MSG_MAP(thisClass)
+	ALT_MSG_MAP(1)
+		CHAIN_MSG_MAP_ALT(baseClass, 1)
+	END_MSG_MAP()
+
+// Operations
+	// Supported only for RichEdit, so this does nothing for Edit
+	void HideSelection(BOOL /*bHide*/ = TRUE, BOOL /*bChangeStyle*/ = FALSE)
+	{
+	}
+
+// Operations (overrideable)
+	BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bMatchCase, BOOL bWholeWord, BOOL bFindDown = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+
+		ATLASSERT(lpszFind != NULL);
+		ATLASSERT(*lpszFind != _T('\0'));
+
+		UINT nLen = pT->GetBufferLength();
+		int nStartChar = 0, nEndChar = 0;
+		pT->GetSel(nStartChar, nEndChar);
+		UINT nStart = nStartChar;
+		int iDir = bFindDown ? +1 : -1;
+
+		// can't find a match before the first character
+		if(nStart == 0 && iDir < 0)
+			return FALSE;
+
+		LPCTSTR lpszText = pT->LockBuffer();
+
+		bool isDBCS = false;
+#ifdef _MBCS
+		CPINFO info = { 0 };
+		::GetCPInfo(::GetOEMCP(), &info);
+		isDBCS = (info.MaxCharSize > 1);
+#endif
+
+		if(iDir < 0)
+		{
+			// always go back one for search backwards
+			nStart -= int((lpszText + nStart) - ::CharPrev(lpszText, lpszText + nStart));
+		}
+		else if(nStartChar != nEndChar && pT->SameAsSelected(lpszFind, bMatchCase, bWholeWord))
+		{
+			// easy to go backward/forward with SBCS
+#ifndef _UNICODE
+			if(::IsDBCSLeadByte(lpszText[nStart]))
+				nStart++;
+#endif
+			nStart += iDir;
+		}
+
+		// handle search with nStart past end of buffer
+		UINT nLenFind = ::lstrlen(lpszFind);
+		if(nStart + nLenFind - 1 >= nLen)
+		{
+			if(iDir < 0 && nLen >= nLenFind)
+			{
+				if(isDBCS)
+				{
+					// walk back to previous character n times
+					nStart = nLen;
+					int n = nLenFind;
+					while(n--)
+					{
+						nStart -= int((lpszText + nStart) - ::CharPrev(lpszText, lpszText + nStart));
+					}
+				}
+				else
+				{
+					// single-byte character set is easy and fast
+					nStart = nLen - nLenFind;
+				}
+				ATLASSERT(nStart + nLenFind - 1 <= nLen);
+			}
+			else
+			{
+				pT->UnlockBuffer();
+				return FALSE;
+			}
+		}
+
+		// start the search at nStart
+		LPCTSTR lpsz = lpszText + nStart;
+		typedef int (WINAPI* CompareProc)(LPCTSTR str1, LPCTSTR str2);
+		CompareProc pfnCompare = bMatchCase ? lstrcmp : lstrcmpi;
+
+		if(isDBCS)
+		{
+			// double-byte string search
+			LPCTSTR lpszStop = NULL;
+			if(iDir > 0)
+			{
+				// start at current and find _first_ occurrance
+				lpszStop = lpszText + nLen - nLenFind + 1;
+			}
+			else
+			{
+				// start at top and find _last_ occurrance
+				lpszStop = lpsz;
+				lpsz = lpszText;
+			}
+
+			LPCTSTR lpszFound = NULL;
+			while(lpsz <= lpszStop)
+			{
+#ifndef _UNICODE
+				if(!bMatchCase || (*lpsz == *lpszFind && (!::IsDBCSLeadByte(*lpsz) || lpsz[1] == lpszFind[1])))
+#else
+				if(!bMatchCase || (*lpsz == *lpszFind && lpsz[1] == lpszFind[1]))
+#endif
+				{
+					LPTSTR lpch = (LPTSTR)(lpsz + nLenFind);
+					TCHAR chSave = *lpch;
+					*lpch = _T('\0');
+					int nResult = (*pfnCompare)(lpsz, lpszFind);
+					*lpch = chSave;
+					if(nResult == 0)
+					{
+						lpszFound = lpsz;
+						if(iDir > 0)
+							break;
+					}
+				}
+				lpsz = ::CharNext(lpsz);
+			}
+			pT->UnlockBuffer();
+
+			if(lpszFound != NULL)
+			{
+				int n = (int)(lpszFound - lpszText);
+				pT->SetSel(n, n + nLenFind);
+				return TRUE;
+			}
+		}
+		else
+		{
+			// single-byte string search
+			UINT nCompare;
+			if(iDir < 0)
+				nCompare = (UINT)(lpsz - lpszText) + 1;
+			else
+				nCompare = nLen - (UINT)(lpsz - lpszText) - nLenFind + 1;
+
+			while(nCompare > 0)
+			{
+				ATLASSERT(lpsz >= lpszText);
+				ATLASSERT(lpsz + nLenFind - 1 <= lpszText + nLen - 1);
+
+				LPSTR lpch = (LPSTR)(lpsz + nLenFind);
+				char chSave = *lpch;
+				*lpch = '\0';
+				int nResult = (*pfnCompare)(lpsz, lpszFind);
+				*lpch = chSave;
+				if(nResult == 0)
+				{
+					pT->UnlockBuffer();
+					int n = (int)(lpsz - lpszText);
+					pT->SetSel(n, n + nLenFind);
+					return TRUE;
+				}
+
+				// restore character at end of search
+				*lpch = chSave;
+
+				// move on to next substring
+				nCompare--;
+				lpsz += iDir;
+			}
+			pT->UnlockBuffer();
+		}
+
+		return FALSE;
+	}
+
+	LPCTSTR LockBuffer() const
+	{
+		const T* pT = static_cast<const T*>(this);
+
+		ATLASSERT(pT->m_hWnd != NULL);
+
+		BOOL useShadowBuffer = pT->UseShadowBuffer();
+		if(useShadowBuffer)
+		{
+			if(m_pShadowBuffer == NULL || pT->GetModify())
+			{
+				ATLASSERT(m_pShadowBuffer != NULL || m_nShadowSize == 0);
+				UINT nSize = pT->GetWindowTextLength() + 1;
+				if(nSize > m_nShadowSize)
+				{
+					// need more room for shadow buffer
+					T* pThisNoConst = const_cast<T*>(pT);
+					delete[] m_pShadowBuffer;
+					pThisNoConst->m_pShadowBuffer = NULL;
+					pThisNoConst->m_nShadowSize = 0;
+					pThisNoConst->m_pShadowBuffer = new TCHAR[nSize];
+					pThisNoConst->m_nShadowSize = nSize;
+				}
+
+				// update the shadow buffer with GetWindowText
+				ATLASSERT(m_nShadowSize >= nSize);
+				ATLASSERT(m_pShadowBuffer != NULL);
+				pT->GetWindowText(m_pShadowBuffer, nSize);
+			}
+
+			return m_pShadowBuffer;
+		}
+
+		HLOCAL hLocal = pT->GetHandle();
+		ATLASSERT(hLocal != NULL);
+		LPCTSTR lpszText = (LPCTSTR)::LocalLock(hLocal);
+		ATLASSERT(lpszText != NULL);
+
+		return lpszText;
+	}
+
+	void UnlockBuffer() const
+	{
+		const T* pT = static_cast<const T*>(this);
+
+		ATLASSERT(pT->m_hWnd != NULL);
+
+		BOOL useShadowBuffer = pT->UseShadowBuffer();
+		if(!useShadowBuffer)
+		{
+			HLOCAL hLocal = pT->GetHandle();
+			ATLASSERT(hLocal != NULL);
+			::LocalUnlock(hLocal);
+		}
+	}
+
+	UINT GetBufferLength() const
+	{
+		const T* pT = static_cast<const T*>(this);
+
+		ATLASSERT(pT->m_hWnd != NULL);
+		UINT nLen = 0;
+		LPCTSTR lpszText = pT->LockBuffer();
+		if(lpszText != NULL)
+			nLen = ::lstrlen(lpszText);
+		pT->UnlockBuffer();
+
+		return nLen;
+	}
+
+	LONG EndOfLine(LPCTSTR lpszText, UINT nLen, UINT nIndex) const
+	{
+		LPCTSTR lpsz = lpszText + nIndex;
+		LPCTSTR lpszStop = lpszText + nLen;
+		while(lpsz < lpszStop && *lpsz != _T('\r'))
+			++lpsz;
+		return LONG(lpsz - lpszText);
+	}
+
+	LONG GetSelText(_CSTRING_NS::CString& strText) const
+	{
+		const T* pT = static_cast<const T*>(this);
+
+		int nStartChar = 0, nEndChar = 0;
+		pT->GetSel(nStartChar, nEndChar);
+		ATLASSERT((UINT)nEndChar <= pT->GetBufferLength());
+		LPCTSTR lpszText = pT->LockBuffer();
+		LONG nLen = pT->EndOfLine(lpszText, nEndChar, nStartChar) - nStartChar;
+		SecureHelper::memcpy_x(strText.GetBuffer(nLen), nLen * sizeof(TCHAR), lpszText + nStartChar, nLen * sizeof(TCHAR));
+		strText.ReleaseBuffer(nLen);
+		pT->UnlockBuffer();
+
+		return nLen;
+	}
+
+	BOOL UseShadowBuffer(void) const
+	{
+		const T* pT = static_cast<const T*>(this);
+
+		if(pT->m_bShadowBufferNeeded < 0)
+		{
+			T* pThisNoConst = const_cast<T*>(pT);
+
+			OSVERSIONINFO ovi = { 0 };
+			ovi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
+			::GetVersionEx(&ovi);
+
+			bool bWin9x = (ovi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS);
+			if(bWin9x)
+			{
+				// Windows 95, 98, ME
+				// Under Win9x, it is necessary to maintain a shadow buffer.
+				// It is only updated when the control contents have been changed.
+				pThisNoConst->m_bShadowBufferNeeded = TRUE;
+			}
+			else
+			{
+				// Windows NT, 2000, XP, etc.
+				pThisNoConst->m_bShadowBufferNeeded = FALSE;
+
+#ifndef _UNICODE
+				// On Windows XP (or later), if common controls version 6 is in use
+				// (such as via theming), then EM_GETHANDLE will always return a UNICODE string.
+				// If theming is enabled and Common Controls version 6 is in use,
+				// you're really not suppose to superclass or subclass common controls
+				// with an ANSI windows procedure (so its best to only theme if you use UNICODE).
+				// Using a shadow buffer uses GetWindowText instead, so it solves
+				// this problem for us (although it makes it a little less efficient).
+
+				if((ovi.dwMajorVersion == 5 && ovi.dwMinorVersion >= 1) || (ovi.dwMajorVersion > 5))
+				{
+					// We use DLLVERSIONINFO_private so we don't have to depend on shlwapi.h
+					typedef struct _DLLVERSIONINFO_private
+					{
+						DWORD cbSize;
+						DWORD dwMajorVersion;
+						DWORD dwMinorVersion;
+						DWORD dwBuildNumber;
+						DWORD dwPlatformID;
+					} DLLVERSIONINFO_private;
+
+					HMODULE hModule = ::LoadLibrary("comctl32.dll");
+					if(hModule != NULL)
+					{
+						typedef HRESULT (CALLBACK *LPFN_DllGetVersion)(DLLVERSIONINFO_private *);
+						LPFN_DllGetVersion fnDllGetVersion = (LPFN_DllGetVersion)::GetProcAddress(hModule, "DllGetVersion");
+						if(fnDllGetVersion != NULL)
+						{
+							DLLVERSIONINFO_private version = { 0 };
+							version.cbSize = sizeof(DLLVERSIONINFO_private);
+							if(SUCCEEDED(fnDllGetVersion(&version)))
+							{
+								if(version.dwMajorVersion >= 6)
+								{
+									pThisNoConst->m_bShadowBufferNeeded = TRUE;
+
+									ATLTRACE2(atlTraceUI, 0, _T("Warning: You have compiled for MBCS/ANSI but are using common controls version 6 or later (likely through a manifest file).\r\n"));
+									ATLTRACE2(atlTraceUI, 0, _T("If you use common controls version 6 or later, you should only do so for UNICODE builds.\r\n"));
+								}
+							}
+						}
+
+						::FreeLibrary(hModule);
+						hModule = NULL;
+					}
+				}
+#endif // !_UNICODE
+			}
+		}
+
+		return (pT->m_bShadowBufferNeeded != FALSE);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRichEditFindReplaceImpl - Mixin class for implementing Find/Replace for CRichEditCtrl
+// based window classes.
+
+// Chain to CRichEditFindReplaceImpl message map. Your class must also derive from CRichEditCtrl.
+// Example:
+// class CMyRichEdit : public CWindowImpl<CMyRichEdit, CRichEditCtrl>,
+//                     public CRichEditFindReplaceImpl<CMyRichEdit>
+// {
+// public:
+//      BEGIN_MSG_MAP(CMyRichEdit)
+//              // your handlers...
+//              CHAIN_MSG_MAP_ALT(CRichEditFindReplaceImpl<CMyRichEdit>, 1)
+//      END_MSG_MAP()
+//      // other stuff...
+// };
+
+template <class T, class TFindReplaceDialog = CFindReplaceDialog>
+class CRichEditFindReplaceImpl : public CEditFindReplaceImplBase<T, TFindReplaceDialog>
+{
+protected:
+	typedef CRichEditFindReplaceImpl<T, TFindReplaceDialog> thisClass;
+	typedef CEditFindReplaceImplBase<T, TFindReplaceDialog> baseClass;
+
+public:
+	BEGIN_MSG_MAP(thisClass)
+	ALT_MSG_MAP(1)
+		CHAIN_MSG_MAP_ALT(baseClass, 1)
+	END_MSG_MAP()
+
+// Operations (overrideable)
+	BOOL FindTextSimple(LPCTSTR lpszFind, BOOL bMatchCase, BOOL bWholeWord, BOOL bFindDown = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+
+		ATLASSERT(lpszFind != NULL);
+		FINDTEXTEX ft = { 0 };
+
+		pT->GetSel(ft.chrg);
+		if(m_bFirstSearch)
+		{
+			if(bFindDown)
+				m_nInitialSearchPos = ft.chrg.cpMin;
+			else
+				m_nInitialSearchPos = ft.chrg.cpMax;
+			m_bFirstSearch = FALSE;
+		}
+
+#if (_RICHEDIT_VER >= 0x0200)
+		ft.lpstrText = (LPTSTR)lpszFind;
+#else // !(_RICHEDIT_VER >= 0x0200)
+		USES_CONVERSION;
+		ft.lpstrText = T2A((LPTSTR)lpszFind);
+#endif // !(_RICHEDIT_VER >= 0x0200)
+
+		if(ft.chrg.cpMin != ft.chrg.cpMax) // i.e. there is a selection
+		{
+			if(bFindDown)
+			{
+				ft.chrg.cpMin++;
+			}
+			else
+			{
+				// won't wraparound backwards
+				ft.chrg.cpMin = max(ft.chrg.cpMin, 0);
+			}
+		}
+
+		DWORD dwFlags = bMatchCase ? FR_MATCHCASE : 0;
+		dwFlags |= bWholeWord ? FR_WHOLEWORD : 0;
+
+		ft.chrg.cpMax = pT->GetTextLength() + m_nInitialSearchPos;
+
+		if(bFindDown)
+		{
+			if(m_nInitialSearchPos >= 0)
+				ft.chrg.cpMax = pT->GetTextLength();
+
+			dwFlags |= FR_DOWN;
+			ATLASSERT(ft.chrg.cpMax >= ft.chrg.cpMin);
+		}
+		else
+		{
+			if(m_nInitialSearchPos >= 0)
+				ft.chrg.cpMax = 0;
+
+			dwFlags &= ~FR_DOWN;
+			ATLASSERT(ft.chrg.cpMax <= ft.chrg.cpMin);
+		}
+
+		BOOL bRet = FALSE;
+
+		if(pT->FindAndSelect(dwFlags, ft) != -1)
+		{
+			bRet = TRUE;   // we found the text
+		}
+		else if(m_nInitialSearchPos > 0)
+		{
+			// if the original starting point was not the beginning
+			// of the buffer and we haven't already been here
+			if(bFindDown)
+			{
+				ft.chrg.cpMin = 0;
+				ft.chrg.cpMax = m_nInitialSearchPos;
+			}
+			else
+			{
+				ft.chrg.cpMin = pT->GetTextLength();
+				ft.chrg.cpMax = m_nInitialSearchPos;
+			}
+			m_nInitialSearchPos = m_nInitialSearchPos - pT->GetTextLength();
+
+			bRet = (pT->FindAndSelect(dwFlags, ft) != -1) ? TRUE : FALSE;
+		}
+
+		return bRet;
+	}
+
+	long FindAndSelect(DWORD dwFlags, FINDTEXTEX& ft)
+	{
+		T* pT = static_cast<T*>(this);
+		LONG index = pT->FindText(dwFlags, ft);
+		if(index != -1) // i.e. we found something
+			pT->SetSel(ft.chrgText);
+
+		return index;
+	}
+};
+
+}; // namespace WTL
+
+#endif // __ATLFIND_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlframe.h b/GLideN64/src/GLideNUI-wtl/WTL/atlframe.h
new file mode 100644
index 00000000..96f15c53
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlframe.h
@@ -0,0 +1,3688 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLFRAME_H__
+#define __ATLFRAME_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlframe.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atlframe.h requires atlwin.h to be included first
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CFrameWindowImpl<T, TBase, TWinTraits>
+// CMDIWindow
+// CMDIFrameWindowImpl<T, TBase, TWinTraits>
+// CMDIChildWindowImpl<T, TBase, TWinTraits>
+// COwnerDraw<T>
+// CUpdateUIBase
+// CUpdateUI<T>
+// CDynamicUpdateUI<T>
+// CAutoUpdateUI<T>
+// CDialogResize<T>
+// CDoubleBufferImpl<T>
+// CDoubleBufferWindowImpl<T, TBase, TWinTraits>
+//
+// Global functions:
+//   AtlCreateSimpleToolBar()
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CFrameWndClassInfo - Manages frame window Windows class information
+
+class CFrameWndClassInfo
+{
+public:
+#ifndef _WIN32_WCE
+	enum { cchAutoName = 5 + sizeof(void*) * 2 };   // sizeof(void*) * 2 is the number of digits %p outputs
+	WNDCLASSEX m_wc;
+#else // CE specific
+	enum { cchAutoName = MAX_PATH };   // MAX_PATH because this can be set in the wizard generated CMainFrame::ActivatePreviousInstance to a user defined string.
+	WNDCLASS m_wc;
+#endif // !_WIN32_WCE
+	LPCTSTR m_lpszOrigName;
+	WNDPROC pWndProc;
+	LPCTSTR m_lpszCursorID;
+	BOOL m_bSystemCursor;
+	ATOM m_atom;
+	TCHAR m_szAutoName[cchAutoName];
+	UINT m_uCommonResourceID;
+
+#ifndef _WIN32_WCE
+	ATOM Register(WNDPROC* pProc)
+	{
+		if (m_atom == 0)
+		{
+			CWindowCreateCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CFrameWndClassInfo::Register.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(m_atom == 0)
+			{
+				HINSTANCE hInst = ModuleHelper::GetModuleInstance();
+
+				if (m_lpszOrigName != NULL)
+				{
+					ATLASSERT(pProc != NULL);
+					LPCTSTR lpsz = m_wc.lpszClassName;
+					WNDPROC proc = m_wc.lpfnWndProc;
+
+					WNDCLASSEX wc = { 0 };
+					wc.cbSize = sizeof(WNDCLASSEX);
+					// try process local class first
+					if(!::GetClassInfoEx(ModuleHelper::GetModuleInstance(), m_lpszOrigName, &wc))
+					{
+						// try global class
+						if(!::GetClassInfoEx(NULL, m_lpszOrigName, &wc))
+						{
+							lock.Unlock();
+							return 0;
+						}
+					}
+					m_wc = wc;
+					pWndProc = m_wc.lpfnWndProc;
+					m_wc.lpszClassName = lpsz;
+					m_wc.lpfnWndProc = proc;
+				}
+				else
+				{
+					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst, m_lpszCursorID);
+				}
+
+				m_wc.hInstance = hInst;
+				m_wc.style &= ~CS_GLOBALCLASS;   // we don't register global classes
+				if (m_wc.lpszClassName == NULL)
+				{
+#if (_WIN32_WINNT >= 0x0500) || defined(_WIN64)
+					SecureHelper::wsprintf_x(m_szAutoName, cchAutoName, _T("ATL:%p"), &m_wc);
+#else // !((_WIN32_WINNT >= 0x0500) || defined(_WIN64))
+					SecureHelper::wsprintf_x(m_szAutoName, cchAutoName, _T("ATL:%8.8X"), (DWORD_PTR)&m_wc);
+#endif // !((_WIN32_WINNT >= 0x0500) || defined(_WIN64))
+					m_wc.lpszClassName = m_szAutoName;
+				}
+
+				WNDCLASSEX wcTemp = m_wc;
+				m_atom = (ATOM)::GetClassInfoEx(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
+				if (m_atom == 0)
+				{
+					if(m_uCommonResourceID != 0)   // use it if not zero
+					{
+						m_wc.hIcon = (HICON)::LoadImage(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
+						m_wc.hIconSm = (HICON)::LoadImage(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 16, 16, LR_DEFAULTCOLOR);
+					}
+					m_atom = ::RegisterClassEx(&m_wc);
+				}
+			}
+
+			lock.Unlock();
+		}
+
+		if (m_lpszOrigName != NULL)
+		{
+			ATLASSERT(pProc != NULL);
+			ATLASSERT(pWndProc != NULL);
+			*pProc = pWndProc;
+		}
+
+		return m_atom;
+	}
+#else // CE specific
+	ATOM Register(WNDPROC* pProc)
+	{
+		if (m_atom == 0)
+		{
+			CWindowCreateCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CFrameWndClassInfo::Register.\n"));
+				ATLASSERT(FALSE);
+				return 0;
+			}
+
+			if(m_atom == 0)
+			{
+				HINSTANCE hInst = ModuleHelper::GetModuleInstance();
+
+				if (m_lpszOrigName != NULL)
+				{
+					ATLASSERT(pProc != NULL);
+					LPCTSTR lpsz = m_wc.lpszClassName;
+					WNDPROC proc = m_wc.lpfnWndProc;
+
+					WNDCLASS wc = { 0 };
+					// try process local class first
+					if(!::GetClassInfo(ModuleHelper::GetModuleInstance(), m_lpszOrigName, &wc))
+					{
+						// try global class
+						if(!::GetClassInfo(NULL, m_lpszOrigName, &wc))
+						{
+							lock.Unlock();
+							return 0;
+						}
+					}
+					m_wc = wc;
+					pWndProc = m_wc.lpfnWndProc;
+					m_wc.lpszClassName = lpsz;
+					m_wc.lpfnWndProc = proc;
+				}
+				else
+				{
+#if defined(GWES_CURSOR) || defined(GWES_MCURSOR)
+					m_wc.hCursor = ::LoadCursor(m_bSystemCursor ? NULL : hInst, m_lpszCursorID);
+#else // !(defined(GWES_CURSOR) || defined(GWES_MCURSOR))
+					m_wc.hCursor = NULL;
+#endif // !(defined(GWES_CURSOR) || defined(GWES_MCURSOR))
+				}
+
+				m_wc.hInstance = hInst;
+				m_wc.style &= ~CS_GLOBALCLASS;   // we don't register global classes
+				if (m_wc.lpszClassName == NULL)
+				{
+					wsprintf(m_szAutoName, _T("ATL:%8.8X"), (DWORD_PTR)&m_wc);
+					m_wc.lpszClassName = m_szAutoName;
+				}
+
+				WNDCLASS wcTemp = m_wc;
+				m_atom = (ATOM)::GetClassInfo(m_wc.hInstance, m_wc.lpszClassName, &wcTemp);
+				if (m_atom == 0)
+				{
+					if(m_uCommonResourceID != 0)   // use it if not zero
+						m_wc.hIcon = (HICON)::LoadImage(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(m_uCommonResourceID), IMAGE_ICON, 32, 32, LR_DEFAULTCOLOR);
+					m_atom = ::RegisterClass(&m_wc);
+				}
+			}
+
+			lock.Unlock();
+		}
+
+		if (m_lpszOrigName != NULL)
+		{
+			ATLASSERT(pProc != NULL);
+			ATLASSERT(pWndProc != NULL);
+			*pProc = pWndProc;
+		}
+
+		return m_atom;
+	}
+#endif // _WIN32_WCE
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Macros for declaring frame window WNDCLASS
+
+#ifndef _WIN32_WCE
+
+#define DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
+static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+{ \
+	static WTL::CFrameWndClassInfo wc = \
+	{ \
+		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName, NULL }, \
+		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
+	}; \
+	return wc; \
+}
+
+#define DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
+static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+{ \
+	static WTL::CFrameWndClassInfo wc = \
+	{ \
+		{ sizeof(WNDCLASSEX), style, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName, NULL }, \
+		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
+	}; \
+	return wc; \
+}
+
+#define DECLARE_FRAME_WND_SUPERCLASS(WndClassName, OrigWndClassName, uCommonResourceID) \
+static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+{ \
+	static WTL::CFrameWndClassInfo wc = \
+	{ \
+		{ sizeof(WNDCLASSEX), 0, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName, NULL }, \
+		OrigWndClassName, NULL, NULL, TRUE, 0, _T(""), uCommonResourceID \
+	}; \
+	return wc; \
+}
+
+#else // CE specific
+
+#define DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
+static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+{ \
+	static WTL::CFrameWndClassInfo wc = \
+	{ \
+		{ 0, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName }, \
+		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
+	}; \
+	return wc; \
+}
+
+#define DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
+static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+{ \
+	static WTL::CFrameWndClassInfo wc = \
+	{ \
+		{ style, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, (HBRUSH)(bkgnd + 1), NULL, WndClassName }, \
+		NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
+	}; \
+	return wc; \
+}
+
+#define DECLARE_FRAME_WND_SUPERCLASS(WndClassName, OrigWndClassName, uCommonResourceID) \
+static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+{ \
+	static WTL::CFrameWndClassInfo wc = \
+	{ \
+		{ NULL, StartWindowProc, \
+		  0, 0, NULL, NULL, NULL, NULL, NULL, WndClassName }, \
+		OrigWndClassName, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
+	}; \
+	return wc; \
+}
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFrameWindowImpl
+
+// Client window command chaining macro (only for frame windows)
+#define CHAIN_CLIENT_COMMANDS() \
+	if(uMsg == WM_COMMAND && m_hWndClient != NULL) \
+		::SendMessage(m_hWndClient, uMsg, wParam, lParam);
+
+// standard toolbar styles
+#define ATL_SIMPLE_TOOLBAR_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | TBSTYLE_TOOLTIPS)
+// toolbar in a rebar pane
+#define ATL_SIMPLE_TOOLBAR_PANE_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NORESIZE | CCS_NOPARENTALIGN | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT)
+// standard rebar styles
+#if (_WIN32_IE >= 0x0400)
+  #define ATL_SIMPLE_REBAR_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE)
+#else
+  #define ATL_SIMPLE_REBAR_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_BORDER | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS)
+#endif // !(_WIN32_IE >= 0x0400)
+// rebar without borders
+#if (_WIN32_IE >= 0x0400)
+  #define ATL_SIMPLE_REBAR_NOBORDER_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | RBS_AUTOSIZE | CCS_NODIVIDER)
+#else
+  #define ATL_SIMPLE_REBAR_NOBORDER_STYLE \
+	(WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | RBS_VARHEIGHT | RBS_BANDBORDERS | CCS_NODIVIDER)
+#endif // !(_WIN32_IE >= 0x0400)
+
+// command bar support
+#if !defined(__ATLCTRLW_H__) && !defined(_WIN32_WCE)
+
+#define CBRM_GETCMDBAR			(WM_USER + 301) // returns command bar HWND
+#define CBRM_GETMENU			(WM_USER + 302) // returns loaded or attached menu
+#define CBRM_TRACKPOPUPMENU		(WM_USER + 303) // displays a popup menu
+
+struct _AtlFrameWnd_CmdBarPopupMenu
+{
+	int cbSize;
+	HMENU hMenu;
+	UINT uFlags;
+	int x;
+	int y;
+	LPTPMPARAMS lptpm;
+};
+
+#define CBRPOPUPMENU _AtlFrameWnd_CmdBarPopupMenu
+
+#endif // !defined(__ATLCTRLW_H__) && !defined(_WIN32_WCE)
+
+
+template <class TBase = ATL::CWindow, class TWinTraits = ATL::CFrameWinTraits>
+class ATL_NO_VTABLE CFrameWindowImplBase : public ATL::CWindowImplBaseT< TBase, TWinTraits >
+{
+public:
+	DECLARE_FRAME_WND_CLASS(NULL, 0)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	struct _ChevronMenuInfo
+	{
+		HMENU hMenu;
+		LPNMREBARCHEVRON lpnm;
+		bool bCmdBar;
+	};
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+
+// Data members
+	HWND m_hWndToolBar;
+	HWND m_hWndStatusBar;
+	HWND m_hWndClient;
+
+#ifdef _WIN32_WCE
+	HWND m_hWndCECommandBar;
+#endif // _WIN32_WCE
+
+	HACCEL m_hAccel;
+
+// Constructor
+	CFrameWindowImplBase() : 
+		m_hWndToolBar(NULL), 
+		m_hWndStatusBar(NULL), 
+		m_hWndClient(NULL), 
+#ifdef _WIN32_WCE
+		m_hWndCECommandBar(NULL),
+#endif // _WIN32_WCE
+		m_hAccel(NULL)
+	{ }
+
+// Methods
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect, LPCTSTR szWindowName, DWORD dwStyle, DWORD dwExStyle, ATL::_U_MENUorID MenuOrID, ATOM atom, LPVOID lpCreateParam)
+	{
+		ATLASSERT(m_hWnd == NULL);
+
+		if(atom == 0)
+			return NULL;
+
+		ModuleHelper::AddCreateWndData(&m_thunk.cd, this);
+
+		if(MenuOrID.m_hMenu == NULL && (dwStyle & WS_CHILD))
+			MenuOrID.m_hMenu = (HMENU)(UINT_PTR)this;
+		if(rect.m_lpRect == NULL)
+			rect.m_lpRect = &TBase::rcDefault;
+
+		HWND hWnd = ::CreateWindowEx(dwExStyle, MAKEINTATOM(atom), szWindowName,
+			dwStyle, rect.m_lpRect->left, rect.m_lpRect->top, rect.m_lpRect->right - rect.m_lpRect->left,
+			rect.m_lpRect->bottom - rect.m_lpRect->top, hWndParent, MenuOrID.m_hMenu,
+			ModuleHelper::GetModuleInstance(), lpCreateParam);
+
+		ATLASSERT(hWnd == NULL || m_hWnd == hWnd);
+
+		return hWnd;
+	}
+
+	static HWND CreateSimpleToolBarCtrl(HWND hWndParent, UINT nResourceID, BOOL bInitialSeparator = FALSE, 
+			DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		HINSTANCE hInst = ModuleHelper::GetResourceInstance();
+		HRSRC hRsrc = ::FindResource(hInst, MAKEINTRESOURCE(nResourceID), RT_TOOLBAR);
+		if (hRsrc == NULL)
+			return NULL;
+
+		HGLOBAL hGlobal = ::LoadResource(hInst, hRsrc);
+		if (hGlobal == NULL)
+			return NULL;
+
+		_AtlToolBarData* pData = (_AtlToolBarData*)::LockResource(hGlobal);
+		if (pData == NULL)
+			return NULL;
+		ATLASSERT(pData->wVersion == 1);
+
+		WORD* pItems = pData->items();
+		int nItems = pData->wItemCount + (bInitialSeparator ? 1 : 0);
+		CTempBuffer<TBBUTTON, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		TBBUTTON* pTBBtn = buff.Allocate(nItems);
+		ATLASSERT(pTBBtn != NULL);
+		if(pTBBtn == NULL)
+			return NULL;
+
+		const int cxSeparator = 8;
+
+		// set initial separator (half width)
+		if(bInitialSeparator)
+		{
+			pTBBtn[0].iBitmap = cxSeparator / 2;
+			pTBBtn[0].idCommand = 0;
+			pTBBtn[0].fsState = 0;
+			pTBBtn[0].fsStyle = TBSTYLE_SEP;
+			pTBBtn[0].dwData = 0;
+			pTBBtn[0].iString = 0;
+		}
+
+		int nBmp = 0;
+		for(int i = 0, j = bInitialSeparator ? 1 : 0; i < pData->wItemCount; i++, j++)
+		{
+			if(pItems[i] != 0)
+			{
+				pTBBtn[j].iBitmap = nBmp++;
+				pTBBtn[j].idCommand = pItems[i];
+				pTBBtn[j].fsState = TBSTATE_ENABLED;
+				pTBBtn[j].fsStyle = TBSTYLE_BUTTON;
+				pTBBtn[j].dwData = 0;
+				pTBBtn[j].iString = 0;
+			}
+			else
+			{
+				pTBBtn[j].iBitmap = cxSeparator;
+				pTBBtn[j].idCommand = 0;
+				pTBBtn[j].fsState = 0;
+				pTBBtn[j].fsStyle = TBSTYLE_SEP;
+				pTBBtn[j].dwData = 0;
+				pTBBtn[j].iString = 0;
+			}
+		}
+
+#ifndef _WIN32_WCE
+		HWND hWnd = ::CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle, 0, 0, 100, 100, hWndParent, (HMENU)LongToHandle(nID), ModuleHelper::GetModuleInstance(), NULL);
+		if(hWnd == NULL)
+		{
+			ATLASSERT(FALSE);
+			return NULL;
+		}
+#else // CE specific
+		dwStyle;
+		nID;
+		// The toolbar must go onto the existing CommandBar or MenuBar
+		HWND hWnd = hWndParent;
+#endif // _WIN32_WCE
+
+		::SendMessage(hWnd, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0L);
+
+		// check if font is taller than our bitmaps
+		CFontHandle font = (HFONT)::SendMessage(hWnd, WM_GETFONT, 0, 0L);
+		if(font.IsNull())
+			font = (HFONT)::GetStockObject(SYSTEM_FONT);
+		LOGFONT lf = { 0 };
+		font.GetLogFont(lf);
+		WORD cyFontHeight = (WORD)abs(lf.lfHeight);
+
+#ifndef _WIN32_WCE
+		WORD bitsPerPixel = AtlGetBitmapResourceBitsPerPixel(nResourceID);
+		if(bitsPerPixel > 4)
+		{
+			COLORREF crMask = CLR_DEFAULT;
+			if(bitsPerPixel == 32)
+			{
+				// 32-bit color bitmap with alpha channel (valid for Windows XP and later)
+				crMask = CLR_NONE;
+			}
+			HIMAGELIST hImageList = ImageList_LoadImage(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(nResourceID), pData->wWidth, 1, crMask, IMAGE_BITMAP, LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
+			ATLASSERT(hImageList != NULL);
+			::SendMessage(hWnd, TB_SETIMAGELIST, 0, (LPARAM)hImageList);
+		}
+		else
+#endif // !_WIN32_WCE
+		{
+			TBADDBITMAP tbab = { 0 };
+			tbab.hInst = hInst;
+			tbab.nID = nResourceID;
+			::SendMessage(hWnd, TB_ADDBITMAP, nBmp, (LPARAM)&tbab);
+		}
+
+		::SendMessage(hWnd, TB_ADDBUTTONS, nItems, (LPARAM)pTBBtn);
+		::SendMessage(hWnd, TB_SETBITMAPSIZE, 0, MAKELONG(pData->wWidth, max(pData->wHeight, cyFontHeight)));
+		const int cxyButtonMargin = 7;
+		::SendMessage(hWnd, TB_SETBUTTONSIZE, 0, MAKELONG(pData->wWidth + cxyButtonMargin, max(pData->wHeight, cyFontHeight) + cxyButtonMargin));
+
+		return hWnd;
+	}
+
+#ifndef _WIN32_WCE
+	static HWND CreateSimpleReBarCtrl(HWND hWndParent, DWORD dwStyle = ATL_SIMPLE_REBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		// Ensure style combinations for proper rebar painting
+		if(dwStyle & CCS_NODIVIDER && dwStyle & WS_BORDER)
+			dwStyle &= ~WS_BORDER;
+		else if(!(dwStyle & WS_BORDER) && !(dwStyle & CCS_NODIVIDER))
+			dwStyle |= CCS_NODIVIDER;
+
+		// Create rebar window
+		HWND hWndReBar = ::CreateWindowEx(0, REBARCLASSNAME, NULL, dwStyle, 0, 0, 100, 100, hWndParent, (HMENU)LongToHandle(nID), ModuleHelper::GetModuleInstance(), NULL);
+		if(hWndReBar == NULL)
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("Failed to create rebar.\n"));
+			return NULL;
+		}
+
+		// Initialize and send the REBARINFO structure
+		REBARINFO rbi = { 0 };
+		rbi.cbSize = sizeof(REBARINFO);
+		rbi.fMask  = 0;
+		if(!::SendMessage(hWndReBar, RB_SETBARINFO, 0, (LPARAM)&rbi))
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("Failed to initialize rebar.\n"));
+			::DestroyWindow(hWndReBar);
+			return NULL;
+		}
+
+		return hWndReBar;
+	}
+
+	BOOL CreateSimpleReBar(DWORD dwStyle = ATL_SIMPLE_REBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		ATLASSERT(!::IsWindow(m_hWndToolBar));
+		m_hWndToolBar = CreateSimpleReBarCtrl(m_hWnd, dwStyle, nID);
+		return (m_hWndToolBar != NULL);
+	}
+
+	static BOOL AddSimpleReBarBandCtrl(HWND hWndReBar, HWND hWndBand, int nID = 0, LPCTSTR lpstrTitle = NULL, BOOL bNewRow = FALSE, int cxWidth = 0, BOOL bFullWidthAlways = FALSE)
+	{
+		ATLASSERT(::IsWindow(hWndReBar));   // must be already created
+#ifdef _DEBUG
+		// block - check if this is really a rebar
+		{
+			TCHAR lpszClassName[sizeof(REBARCLASSNAME)] = { 0 };
+			::GetClassName(hWndReBar, lpszClassName, sizeof(REBARCLASSNAME));
+			ATLASSERT(lstrcmp(lpszClassName, REBARCLASSNAME) == 0);
+		}
+#endif // _DEBUG
+		ATLASSERT(::IsWindow(hWndBand));   // must be already created
+
+		// Get number of buttons on the toolbar
+		int nBtnCount = (int)::SendMessage(hWndBand, TB_BUTTONCOUNT, 0, 0L);
+
+		// Set band info structure
+		REBARBANDINFO rbBand = { RunTimeHelper::SizeOf_REBARBANDINFO() };
+#if (_WIN32_IE >= 0x0400)
+		rbBand.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE | RBBIM_IDEALSIZE;
+#else
+		rbBand.fMask = RBBIM_CHILD | RBBIM_CHILDSIZE | RBBIM_STYLE | RBBIM_ID | RBBIM_SIZE;
+#endif // !(_WIN32_IE >= 0x0400)
+		if(lpstrTitle != NULL)
+			rbBand.fMask |= RBBIM_TEXT;
+		rbBand.fStyle = RBBS_CHILDEDGE;
+#if (_WIN32_IE >= 0x0500)
+		if(nBtnCount > 0)   // add chevron style for toolbar with buttons
+			rbBand.fStyle |= RBBS_USECHEVRON;
+#endif // (_WIN32_IE >= 0x0500)
+		if(bNewRow)
+			rbBand.fStyle |= RBBS_BREAK;
+
+		rbBand.lpText = (LPTSTR)lpstrTitle;
+		rbBand.hwndChild = hWndBand;
+		if(nID == 0)   // calc band ID
+			nID = ATL_IDW_BAND_FIRST + (int)::SendMessage(hWndReBar, RB_GETBANDCOUNT, 0, 0L);
+		rbBand.wID = nID;
+
+		// Calculate the size of the band
+		BOOL bRet = FALSE;
+		RECT rcTmp = { 0 };
+		if(nBtnCount > 0)
+		{
+			bRet = (BOOL)::SendMessage(hWndBand, TB_GETITEMRECT, nBtnCount - 1, (LPARAM)&rcTmp);
+			ATLASSERT(bRet);
+			rbBand.cx = (cxWidth != 0) ? cxWidth : rcTmp.right;
+			rbBand.cyMinChild = rcTmp.bottom - rcTmp.top;
+			if(bFullWidthAlways)
+			{
+				rbBand.cxMinChild = rbBand.cx;
+			}
+			else if(lpstrTitle == NULL)
+			{
+				bRet = (BOOL)::SendMessage(hWndBand, TB_GETITEMRECT, 0, (LPARAM)&rcTmp);
+				ATLASSERT(bRet);
+				rbBand.cxMinChild = rcTmp.right;
+			}
+			else
+			{
+				rbBand.cxMinChild = 0;
+			}
+		}
+		else	// no buttons, either not a toolbar or really has no buttons
+		{
+			bRet = ::GetWindowRect(hWndBand, &rcTmp);
+			ATLASSERT(bRet);
+			rbBand.cx = (cxWidth != 0) ? cxWidth : (rcTmp.right - rcTmp.left);
+			rbBand.cxMinChild = bFullWidthAlways ? rbBand.cx : 0;
+			rbBand.cyMinChild = rcTmp.bottom - rcTmp.top;
+		}
+
+#if (_WIN32_IE >= 0x0400)
+		rbBand.cxIdeal = rbBand.cx;
+#endif // (_WIN32_IE >= 0x0400)
+
+		// Add the band
+		LRESULT lRes = ::SendMessage(hWndReBar, RB_INSERTBAND, (WPARAM)-1, (LPARAM)&rbBand);
+		if(lRes == 0)
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("Failed to add a band to the rebar.\n"));
+			return FALSE;
+		}
+
+#if (_WIN32_IE >= 0x0501)
+		DWORD dwExStyle = (DWORD)::SendMessage(hWndBand, TB_GETEXTENDEDSTYLE, 0, 0L);
+		::SendMessage(hWndBand, TB_SETEXTENDEDSTYLE, 0, dwExStyle | TBSTYLE_EX_HIDECLIPPEDBUTTONS);
+#endif // (_WIN32_IE >= 0x0501)
+
+		return TRUE;
+	}
+
+	BOOL AddSimpleReBarBand(HWND hWndBand, LPCTSTR lpstrTitle = NULL, BOOL bNewRow = FALSE, int cxWidth = 0, BOOL bFullWidthAlways = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWndToolBar));   // must be an existing rebar
+		ATLASSERT(::IsWindow(hWndBand));        // must be created
+		return AddSimpleReBarBandCtrl(m_hWndToolBar, hWndBand, 0, lpstrTitle, bNewRow, cxWidth, bFullWidthAlways);
+	}
+
+#if (_WIN32_IE >= 0x0400)
+	void SizeSimpleReBarBands()
+	{
+		ATLASSERT(::IsWindow(m_hWndToolBar));   // must be an existing rebar
+
+		int nCount = (int)::SendMessage(m_hWndToolBar, RB_GETBANDCOUNT, 0, 0L);
+
+		for(int i = 0; i < nCount; i++)
+		{
+			REBARBANDINFO rbBand = { RunTimeHelper::SizeOf_REBARBANDINFO() };
+			rbBand.fMask = RBBIM_SIZE;
+			BOOL bRet = (BOOL)::SendMessage(m_hWndToolBar, RB_GETBANDINFO, i, (LPARAM)&rbBand);
+			ATLASSERT(bRet);
+			RECT rect = { 0, 0, 0, 0 };
+			::SendMessage(m_hWndToolBar, RB_GETBANDBORDERS, i, (LPARAM)&rect);
+			rbBand.cx += rect.left + rect.right;
+			bRet = (BOOL)::SendMessage(m_hWndToolBar, RB_SETBANDINFO, i, (LPARAM)&rbBand);
+			ATLASSERT(bRet);
+		}
+	}
+#endif // (_WIN32_IE >= 0x0400)
+#endif // _WIN32_WCE
+
+#ifndef _WIN32_WCE
+	BOOL CreateSimpleStatusBar(LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
+#else // CE specific
+	BOOL CreateSimpleStatusBar(LPCTSTR lpstrText, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, UINT nID = ATL_IDW_STATUS_BAR)
+#endif // _WIN32_WCE
+	{
+		ATLASSERT(!::IsWindow(m_hWndStatusBar));
+		m_hWndStatusBar = ::CreateStatusWindow(dwStyle, lpstrText, m_hWnd, nID);
+		return (m_hWndStatusBar != NULL);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL CreateSimpleStatusBar(UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | SBARS_SIZEGRIP, UINT nID = ATL_IDW_STATUS_BAR)
+#else // CE specific
+	BOOL CreateSimpleStatusBar(UINT nTextID = ATL_IDS_IDLEMESSAGE, DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, UINT nID = ATL_IDW_STATUS_BAR)
+#endif // _WIN32_WCE
+	{
+		const int cchMax = 128;   // max text length is 127 for status bars (+1 for null)
+		TCHAR szText[cchMax];
+		szText[0] = 0;
+		::LoadString(ModuleHelper::GetResourceInstance(), nTextID, szText, cchMax);
+		return CreateSimpleStatusBar(szText, dwStyle, nID);
+	}
+
+#ifdef _WIN32_WCE
+	BOOL CreateSimpleCECommandBar(LPTSTR pszMenu = NULL, WORD iButton = 0, DWORD dwFlags = 0, int nCmdBarID = 1)
+	{
+		ATLASSERT(m_hWndCECommandBar == NULL);
+		ATLASSERT(m_hWndToolBar == NULL);
+
+		m_hWndCECommandBar = ::CommandBar_Create(ModuleHelper::GetModuleInstance(), m_hWnd, nCmdBarID);
+		if(m_hWndCECommandBar == NULL)
+			return FALSE;
+
+		m_hWndToolBar = m_hWndCECommandBar;
+
+		BOOL bRet = TRUE;
+
+		if(pszMenu != NULL)
+			bRet &= ::CommandBar_InsertMenubarEx(m_hWndCECommandBar, IS_INTRESOURCE(pszMenu) ? ModuleHelper::GetResourceInstance() : NULL, pszMenu, iButton);
+
+		bRet &= ::CommandBar_AddAdornments(m_hWndCECommandBar, dwFlags, 0);
+
+		return bRet;
+	}
+
+#if defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__)
+	BOOL CreateSimpleCEMenuBar(UINT nToolBarId = ATL_IDW_MENU_BAR, DWORD dwFlags = 0, int nBmpId = 0, int cBmpImages = 0)
+	{
+		ATLASSERT(m_hWndCECommandBar == NULL);
+
+		SHMENUBARINFO mbi = { 0 };
+		mbi.cbSize = sizeof(mbi);
+		mbi.hwndParent = m_hWnd;
+		mbi.dwFlags = dwFlags;
+		mbi.nToolBarId = nToolBarId;
+		mbi.hInstRes  = ModuleHelper::GetResourceInstance();
+		mbi.nBmpId = nBmpId;
+		mbi.cBmpImages = cBmpImages;
+		mbi.hwndMB = NULL;   // This gets set by SHCreateMenuBar
+
+		BOOL bRet = ::SHCreateMenuBar(&mbi);
+		if(bRet != FALSE)
+		{
+			m_hWndCECommandBar = mbi.hwndMB;
+			SizeToMenuBar();
+		}
+
+		return bRet;
+	}
+
+	void SizeToMenuBar()   // for menu bar only
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(::IsWindow(m_hWndCECommandBar));
+
+		RECT rect = { 0 };
+		GetWindowRect(&rect);
+		RECT rectMB = { 0 };
+		::GetWindowRect(m_hWndCECommandBar, &rectMB);
+		int cy = ::IsWindowVisible(m_hWndCECommandBar) ? rectMB.top - rect.top : rectMB.bottom - rect.top;
+		SetWindowPos(NULL, 0, 0, rect.right - rect.left, cy, SWP_NOZORDER | SWP_NOMOVE);
+	}
+#endif // defined(_AYGSHELL_H_) || defined(__AYGSHELL_H__)
+#endif // _WIN32_WCE
+
+	void UpdateLayout(BOOL bResizeBars = TRUE)
+	{
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+
+		// position bars and offset their dimensions
+		UpdateBarsPosition(rect, bResizeBars);
+
+		// resize client window
+		if(m_hWndClient != NULL)
+			::SetWindowPos(m_hWndClient, NULL, rect.left, rect.top,
+				rect.right - rect.left, rect.bottom - rect.top,
+				SWP_NOZORDER | SWP_NOACTIVATE);
+	}
+
+	void UpdateBarsPosition(RECT& rect, BOOL bResizeBars = TRUE)
+	{
+		// resize toolbar
+		if(m_hWndToolBar != NULL && ((DWORD)::GetWindowLong(m_hWndToolBar, GWL_STYLE) & WS_VISIBLE))
+		{
+			if(bResizeBars != FALSE)
+			{
+				::SendMessage(m_hWndToolBar, WM_SIZE, 0, 0);
+				::InvalidateRect(m_hWndToolBar, NULL, TRUE);
+			}
+			RECT rectTB = { 0 };
+			::GetWindowRect(m_hWndToolBar, &rectTB);
+			rect.top += rectTB.bottom - rectTB.top;
+		}
+
+		// resize status bar
+		if(m_hWndStatusBar != NULL && ((DWORD)::GetWindowLong(m_hWndStatusBar, GWL_STYLE) & WS_VISIBLE))
+		{
+			if(bResizeBars != FALSE)
+				::SendMessage(m_hWndStatusBar, WM_SIZE, 0, 0);
+			RECT rectSB = { 0 };
+			::GetWindowRect(m_hWndStatusBar, &rectSB);
+			rect.bottom -= rectSB.bottom - rectSB.top;
+		}
+	}
+
+	BOOL PreTranslateMessage(MSG* pMsg)
+	{
+		if(m_hAccel != NULL && ::TranslateAccelerator(m_hWnd, m_hAccel, pMsg))
+			return TRUE;
+		return FALSE;
+	}
+
+	BEGIN_MSG_MAP(CFrameWindowImplBase)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
+#endif // !_WIN32_WCE
+		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+#ifndef _WIN32_WCE
+		NOTIFY_CODE_HANDLER(TTN_GETDISPINFOA, OnToolTipTextA)
+		NOTIFY_CODE_HANDLER(TTN_GETDISPINFOW, OnToolTipTextW)
+#endif // !_WIN32_WCE
+	END_MSG_MAP()
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_hWndClient != NULL)   // view will paint itself instead
+			return 1;
+
+		bHandled = FALSE;
+		return 0;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnMenuSelect(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+
+		if(m_hWndStatusBar == NULL)
+			return 1;
+
+		WORD wFlags = HIWORD(wParam);
+		if(wFlags == 0xFFFF && lParam == NULL)   // menu closing
+		{
+			::SendMessage(m_hWndStatusBar, SB_SIMPLE, FALSE, 0L);
+		}
+		else
+		{
+			const int cchBuff = 256;
+			TCHAR szBuff[cchBuff];
+			szBuff[0] = 0;
+			if(!(wFlags & MF_POPUP))
+			{
+				WORD wID = LOWORD(wParam);
+				// check for special cases
+				if(wID >= 0xF000 && wID < 0xF1F0)   // system menu IDs
+					wID = (WORD)(((wID - 0xF000) >> 4) + ATL_IDS_SCFIRST);
+				else if(wID >= ID_FILE_MRU_FIRST && wID <= ID_FILE_MRU_LAST)   // MRU items
+					wID = ATL_IDS_MRU_FILE;
+				else if(wID >= ATL_IDM_FIRST_MDICHILD && wID <= ATL_IDM_LAST_MDICHILD)   // MDI child windows
+					wID = ATL_IDS_MDICHILD;
+
+				int nRet = ::LoadString(ModuleHelper::GetResourceInstance(), wID, szBuff, cchBuff);
+				for(int i = 0; i < nRet; i++)
+				{
+					if(szBuff[i] == _T('\n'))
+					{
+						szBuff[i] = 0;
+						break;
+					}
+				}
+			}
+			::SendMessage(m_hWndStatusBar, SB_SIMPLE, TRUE, 0L);
+			::SendMessage(m_hWndStatusBar, SB_SETTEXT, (255 | SBT_NOBORDERS), (LPARAM)szBuff);
+		}
+
+		return 1;
+	}
+#endif // !_WIN32_WCE
+
+	LRESULT OnSetFocus(UINT, WPARAM, LPARAM, BOOL& bHandled)
+	{
+		if(m_hWndClient != NULL)
+			::SetFocus(m_hWndClient);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnDestroy(UINT, WPARAM, LPARAM, BOOL& bHandled)
+	{
+		if((GetStyle() & (WS_CHILD | WS_POPUP)) == 0)
+			::PostQuitMessage(1);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnToolTipTextA(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		LPNMTTDISPINFOA pDispInfo = (LPNMTTDISPINFOA)pnmh;
+		pDispInfo->szText[0] = 0;
+
+		if((idCtrl != 0) && !(pDispInfo->uFlags & TTF_IDISHWND))
+		{
+			const int cchBuff = 256;
+			char szBuff[cchBuff];
+			szBuff[0] = 0;
+			int nRet = ::LoadStringA(ModuleHelper::GetResourceInstance(), idCtrl, szBuff, cchBuff);
+			for(int i = 0; i < nRet; i++)
+			{
+				if(szBuff[i] == '\n')
+				{
+					SecureHelper::strncpyA_x(pDispInfo->szText, _countof(pDispInfo->szText), &szBuff[i + 1], _TRUNCATE);
+					break;
+				}
+			}
+#if (_WIN32_IE >= 0x0300)
+			if(nRet > 0)   // string was loaded, save it
+				pDispInfo->uFlags |= TTF_DI_SETITEM;
+#endif // (_WIN32_IE >= 0x0300)
+		}
+
+		return 0;
+	}
+
+	LRESULT OnToolTipTextW(int idCtrl, LPNMHDR pnmh, BOOL& /*bHandled*/)
+	{
+		LPNMTTDISPINFOW pDispInfo = (LPNMTTDISPINFOW)pnmh;
+		pDispInfo->szText[0] = 0;
+
+		if((idCtrl != 0) && !(pDispInfo->uFlags & TTF_IDISHWND))
+		{
+			const int cchBuff = 256;
+			wchar_t szBuff[cchBuff];
+			szBuff[0] = 0;
+			int nRet = ::LoadStringW(ModuleHelper::GetResourceInstance(), idCtrl, szBuff, cchBuff);
+			for(int i = 0; i < nRet; i++)
+			{
+				if(szBuff[i] == L'\n')
+				{
+					SecureHelper::strncpyW_x(pDispInfo->szText, _countof(pDispInfo->szText), &szBuff[i + 1], _TRUNCATE);
+					break;
+				}
+			}
+#if (_WIN32_IE >= 0x0300)
+			if(nRet > 0)   // string was loaded, save it
+				pDispInfo->uFlags |= TTF_DI_SETITEM;
+#endif // (_WIN32_IE >= 0x0300)
+		}
+
+		return 0;
+	}
+#endif // !_WIN32_WCE
+
+// Implementation - chevron menu support
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	bool PrepareChevronMenu(_ChevronMenuInfo& cmi)
+	{
+		// get rebar and toolbar
+		REBARBANDINFO rbbi = { RunTimeHelper::SizeOf_REBARBANDINFO() };
+		rbbi.fMask = RBBIM_CHILD;
+		BOOL bRet = (BOOL)::SendMessage(cmi.lpnm->hdr.hwndFrom, RB_GETBANDINFO, cmi.lpnm->uBand, (LPARAM)&rbbi);
+		ATLASSERT(bRet);
+
+		// assume the band is a toolbar
+		ATL::CWindow wnd = rbbi.hwndChild;
+		int nCount = (int)wnd.SendMessage(TB_BUTTONCOUNT);
+		if(nCount <= 0)   // probably not a toolbar
+			return false;
+
+		// check if it's a command bar
+		CMenuHandle menuCmdBar = (HMENU)wnd.SendMessage(CBRM_GETMENU);
+		cmi.bCmdBar = (menuCmdBar.m_hMenu != NULL);
+
+		// build a menu from hidden items
+		CMenuHandle menu;
+		bRet = menu.CreatePopupMenu();
+		ATLASSERT(bRet);
+		RECT rcClient = { 0 };
+		bRet = wnd.GetClientRect(&rcClient);
+		ATLASSERT(bRet);
+		for(int i = 0; i < nCount; i++)
+		{
+			TBBUTTON tbb = { 0 };
+			bRet = (BOOL)wnd.SendMessage(TB_GETBUTTON, i, (LPARAM)&tbb);
+			ATLASSERT(bRet);
+			// skip hidden buttons
+			if((tbb.fsState & TBSTATE_HIDDEN) != 0)
+				continue;
+			RECT rcButton = { 0 };
+			bRet = (BOOL)wnd.SendMessage(TB_GETITEMRECT, i, (LPARAM)&rcButton);
+			ATLASSERT(bRet);
+			bool bEnabled = ((tbb.fsState & TBSTATE_ENABLED) != 0);
+			if(rcButton.right > rcClient.right)
+			{
+				if(tbb.fsStyle & BTNS_SEP)
+				{
+					if(menu.GetMenuItemCount() > 0)
+						menu.AppendMenu(MF_SEPARATOR);
+				}
+				else if(cmi.bCmdBar)
+				{
+					const int cchBuff = 200;
+					TCHAR szBuff[cchBuff] = { 0 };
+					CMenuItemInfo mii;
+					mii.fMask = MIIM_TYPE | MIIM_SUBMENU;
+					mii.dwTypeData = szBuff;
+					mii.cch = cchBuff;
+					bRet = menuCmdBar.GetMenuItemInfo(i, TRUE, &mii);
+					ATLASSERT(bRet);
+					// Note: CmdBar currently supports only drop-down items
+					ATLASSERT(::IsMenu(mii.hSubMenu));
+					bRet = menu.AppendMenu(MF_STRING | MF_POPUP | (bEnabled ? MF_ENABLED : MF_GRAYED), (UINT_PTR)mii.hSubMenu, mii.dwTypeData);
+					ATLASSERT(bRet);
+				}
+				else
+				{
+					// get button's text
+					const int cchBuff = 200;
+					TCHAR szBuff[cchBuff] = { 0 };
+					LPTSTR lpstrText = szBuff;
+					TBBUTTONINFO tbbi = { 0 };
+					tbbi.cbSize = sizeof(TBBUTTONINFO);
+					tbbi.dwMask = TBIF_TEXT;
+					tbbi.pszText = szBuff;
+					tbbi.cchText = cchBuff;
+					if(wnd.SendMessage(TB_GETBUTTONINFO, tbb.idCommand, (LPARAM)&tbbi) == -1 || lstrlen(szBuff) == 0)
+					{
+						// no text for this button, try a resource string
+						lpstrText = _T("");
+						int nRet = ::LoadString(ModuleHelper::GetResourceInstance(), tbb.idCommand, szBuff, cchBuff);
+						for(int n = 0; n < nRet; n++)
+						{
+							if(szBuff[n] == _T('\n'))
+							{
+								lpstrText = &szBuff[n + 1];
+								break;
+							}
+						}
+					}
+					bRet = menu.AppendMenu(MF_STRING | (bEnabled ? MF_ENABLED : MF_GRAYED), tbb.idCommand, lpstrText);
+					ATLASSERT(bRet);
+				}
+			}
+		}
+
+		if(menu.GetMenuItemCount() == 0)   // no hidden buttons after all
+		{
+			menu.DestroyMenu();
+			::MessageBeep((UINT)-1);
+			return false;
+		}
+
+		cmi.hMenu = menu;
+		return true;
+	}
+
+	void DisplayChevronMenu(_ChevronMenuInfo& cmi)
+	{
+#ifndef TPM_VERPOSANIMATION
+		const UINT TPM_VERPOSANIMATION = 0x1000L;   // Menu animation flag
+#endif
+		// convert chevron rect to screen coordinates
+		ATL::CWindow wndFrom = cmi.lpnm->hdr.hwndFrom;
+		POINT pt = { cmi.lpnm->rc.left, cmi.lpnm->rc.bottom };
+		wndFrom.MapWindowPoints(NULL, &pt, 1);
+		RECT rc = cmi.lpnm->rc;
+		wndFrom.MapWindowPoints(NULL, &rc);
+		// set up flags and rect
+		UINT uMenuFlags = TPM_LEFTBUTTON | TPM_VERTICAL | TPM_LEFTALIGN | TPM_TOPALIGN | (!AtlIsOldWindows() ? TPM_VERPOSANIMATION : 0);
+		TPMPARAMS TPMParams = { 0 };
+		TPMParams.cbSize = sizeof(TPMPARAMS);
+		TPMParams.rcExclude = rc;
+		// check if this window has a command bar
+		HWND hWndCmdBar = (HWND)::SendMessage(m_hWnd, CBRM_GETCMDBAR, 0, 0L);
+		if(::IsWindow(hWndCmdBar))
+		{
+			CBRPOPUPMENU CBRPopupMenu = { sizeof(CBRPOPUPMENU), cmi.hMenu, uMenuFlags, pt.x, pt.y, &TPMParams };
+			::SendMessage(hWndCmdBar, CBRM_TRACKPOPUPMENU, 0, (LPARAM)&CBRPopupMenu);
+		}
+		else
+		{
+			CMenuHandle menu = cmi.hMenu;
+			menu.TrackPopupMenuEx(uMenuFlags, pt.x, pt.y, m_hWnd, &TPMParams);
+		}
+	}
+
+	void CleanupChevronMenu(_ChevronMenuInfo& cmi)
+	{
+		CMenuHandle menu = cmi.hMenu;
+		// if menu is from a command bar, detach submenus so they are not destroyed
+		if(cmi.bCmdBar)
+		{
+			for(int i = menu.GetMenuItemCount() - 1; i >=0; i--)
+				menu.RemoveMenu(i, MF_BYPOSITION);
+		}
+		// destroy menu
+		menu.DestroyMenu();
+		// convert chevron rect to screen coordinates
+		ATL::CWindow wndFrom = cmi.lpnm->hdr.hwndFrom;
+		RECT rc = cmi.lpnm->rc;
+		wndFrom.MapWindowPoints(NULL, &rc);
+		// eat next message if click is on the same button
+		MSG msg = { 0 };
+		if(::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_NOREMOVE) && ::PtInRect(&rc, msg.pt))
+			::PeekMessage(&msg, m_hWnd, WM_LBUTTONDOWN, WM_LBUTTONDOWN, PM_REMOVE);
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+};
+
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CFrameWinTraits>
+class ATL_NO_VTABLE CFrameWindowImpl : public CFrameWindowImplBase< TBase, TWinTraits >
+{
+public:
+	HWND Create(HWND hWndParent = NULL, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
+	{
+		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
+
+		dwStyle = T::GetWndStyle(dwStyle);
+		dwExStyle = T::GetWndExStyle(dwExStyle);
+
+		if(rect.m_lpRect == NULL)
+			rect.m_lpRect = &TBase::rcDefault;
+
+		return CFrameWindowImplBase< TBase, TWinTraits >::Create(hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, hMenu, atom, lpCreateParam);
+	}
+
+	HWND CreateEx(HWND hWndParent = NULL, ATL::_U_RECT rect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
+	{
+		const int cchName = 256;
+		TCHAR szWindowName[cchName];
+		szWindowName[0] = 0;
+#ifndef _WIN32_WCE
+		::LoadString(ModuleHelper::GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, cchName);
+		HMENU hMenu = ::LoadMenu(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));
+#else // CE specific
+		::LoadString(ModuleHelper::GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, cchName);
+
+		// This always needs to be NULL for Windows CE.
+		// Frame Window menus have to go onto the CommandBar.
+		// Use CreateSimpleCECommandBar
+		HMENU hMenu = NULL;
+#endif // _WIN32_WCE
+
+		T* pT = static_cast<T*>(this);
+		HWND hWnd = pT->Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
+
+		if(hWnd != NULL)
+			m_hAccel = ::LoadAccelerators(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));
+
+		return hWnd;
+	}
+
+	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		if(nResourceID == 0)
+			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
+#ifndef _WIN32_WCE
+		ATLASSERT(!::IsWindow(m_hWndToolBar));
+		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
+		return (m_hWndToolBar != NULL);
+#else // CE specific
+		HWND hWnd= T::CreateSimpleToolBarCtrl(m_hWndCECommandBar, nResourceID, TRUE, dwStyle, nID);
+		return (hWnd != NULL);
+#endif // _WIN32_WCE
+	}
+
+#ifdef _WIN32_WCE
+	// CE specific variant that returns the handle of the toolbar
+	HWND CreateSimpleCEToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		if(nResourceID == 0)
+			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
+
+		return T::CreateSimpleToolBarCtrl(m_hWndCECommandBar, nResourceID, TRUE, dwStyle, nID);
+	}
+#endif // _WIN32_WCE
+
+// message map and handlers
+	typedef CFrameWindowImplBase< TBase, TWinTraits >   _baseClass;
+
+	BEGIN_MSG_MAP(CFrameWindowImpl)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+#ifndef _ATL_NO_REBAR_SUPPORT
+#if (_WIN32_IE >= 0x0400)
+		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
+#endif // (_WIN32_IE >= 0x0400)
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+#endif // !_ATL_NO_REBAR_SUPPORT
+		CHAIN_MSG_MAP(_baseClass)
+	END_MSG_MAP()
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(wParam != SIZE_MINIMIZED)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdateLayout();
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+#ifndef _ATL_NO_REBAR_SUPPORT
+#if (_WIN32_IE >= 0x0400)
+	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout(FALSE);
+		return 0;
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
+		if(!pT->PrepareChevronMenu(cmi))
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+		// display a popup menu with hidden items
+		pT->DisplayChevronMenu(cmi);
+		// cleanup
+		pT->CleanupChevronMenu(cmi);
+		return 0;
+	}
+#endif // (_WIN32_IE >= 0x0500) && !defined(_WIN32_WCE)
+#endif // !_ATL_NO_REBAR_SUPPORT
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// AtlCreateSimpleToolBar - helper for creating simple toolbars
+
+#ifndef _WIN32_WCE
+
+inline HWND AtlCreateSimpleToolBar(HWND hWndParent, UINT nResourceID, BOOL bInitialSeparator = FALSE, 
+		DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+{
+	return CFrameWindowImplBase<>::CreateSimpleToolBarCtrl(hWndParent, nResourceID, bInitialSeparator, dwStyle, nID);
+}
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMDIWindow
+
+#ifndef _WIN32_WCE
+
+#ifndef _WTL_MDIWINDOWMENU_TEXT
+#define _WTL_MDIWINDOWMENU_TEXT	_T("&Window")
+#endif
+
+class CMDIWindow : public ATL::CWindow
+{
+public:
+// Data members
+	HWND m_hWndMDIClient;
+	HMENU m_hMenu;
+
+// Constructors
+	CMDIWindow(HWND hWnd = NULL) : ATL::CWindow(hWnd), m_hWndMDIClient(NULL), m_hMenu(NULL)
+	{ }
+
+	CMDIWindow& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// Operations
+	HWND MDIGetActive(BOOL* lpbMaximized = NULL)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		return (HWND)::SendMessage(m_hWndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM)lpbMaximized);
+	}
+
+	void MDIActivate(HWND hWndChildToActivate)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		ATLASSERT(::IsWindow(hWndChildToActivate));
+		::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE, (WPARAM)hWndChildToActivate, 0);
+	}
+
+	void MDINext(HWND hWndChild, BOOL bPrevious = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		ATLASSERT(hWndChild == NULL || ::IsWindow(hWndChild));
+		::SendMessage(m_hWndMDIClient, WM_MDINEXT, (WPARAM)hWndChild, (LPARAM)bPrevious);
+	}
+
+	void MDIMaximize(HWND hWndChildToMaximize)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		ATLASSERT(::IsWindow(hWndChildToMaximize));
+		::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)hWndChildToMaximize, 0);
+	}
+
+	void MDIRestore(HWND hWndChildToRestore)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		ATLASSERT(::IsWindow(hWndChildToRestore));
+		::SendMessage(m_hWndMDIClient, WM_MDIRESTORE, (WPARAM)hWndChildToRestore, 0);
+	}
+
+	void MDIDestroy(HWND hWndChildToDestroy)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		ATLASSERT(::IsWindow(hWndChildToDestroy));
+		::SendMessage(m_hWndMDIClient, WM_MDIDESTROY, (WPARAM)hWndChildToDestroy, 0);
+	}
+
+	BOOL MDICascade(UINT uFlags = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDICASCADE, (WPARAM)uFlags, 0);
+	}
+
+	BOOL MDITile(UINT uFlags = MDITILE_HORIZONTAL)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		return (BOOL)::SendMessage(m_hWndMDIClient, WM_MDITILE, (WPARAM)uFlags, 0);
+	}
+
+	void MDIIconArrange()
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0);
+	}
+
+	HMENU MDISetMenu(HMENU hMenuFrame, HMENU hMenuWindow)
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDISETMENU, (WPARAM)hMenuFrame, (LPARAM)hMenuWindow);
+	}
+
+	HMENU MDIRefreshMenu()
+	{
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+		return (HMENU)::SendMessage(m_hWndMDIClient, WM_MDIREFRESHMENU, 0, 0);
+	}
+
+// Additional operations
+	static HMENU GetStandardWindowMenu(HMENU hMenu)
+	{
+		int nCount = ::GetMenuItemCount(hMenu);
+		if(nCount == -1)
+			return NULL;
+		int nLen = ::GetMenuString(hMenu, nCount - 2, NULL, 0, MF_BYPOSITION);
+		if(nLen == 0)
+			return NULL;
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpszText = buff.Allocate(nLen + 1);
+		if(lpszText == NULL)
+			return NULL;
+		if(::GetMenuString(hMenu, nCount - 2, lpszText, nLen + 1, MF_BYPOSITION) != nLen)
+			return NULL;
+		if(lstrcmp(lpszText, _WTL_MDIWINDOWMENU_TEXT) != 0)
+			return NULL;
+		return ::GetSubMenu(hMenu, nCount - 2);
+	}
+
+	void SetMDIFrameMenu()
+	{
+		HMENU hWindowMenu = GetStandardWindowMenu(m_hMenu);
+		MDISetMenu(m_hMenu, hWindowMenu);
+		MDIRefreshMenu();
+		::DrawMenuBar(GetMDIFrame());
+	}
+
+	HWND GetMDIFrame() const
+	{
+		return ::GetParent(m_hWndMDIClient);
+	}
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMDIFrameWindowImpl
+
+#ifndef _WIN32_WCE
+
+// MDI child command chaining macro (only for MDI frame windows)
+#define CHAIN_MDI_CHILD_COMMANDS() \
+	if(uMsg == WM_COMMAND) \
+	{ \
+		HWND hWndChild = MDIGetActive(); \
+		if(hWndChild != NULL) \
+			::SendMessage(hWndChild, uMsg, wParam, lParam); \
+	}
+
+template <class T, class TBase = CMDIWindow, class TWinTraits = ATL::CFrameWinTraits>
+class ATL_NO_VTABLE CMDIFrameWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
+{
+public:
+	HWND Create(HWND hWndParent = NULL, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			HMENU hMenu = NULL, LPVOID lpCreateParam = NULL)
+	{
+		m_hMenu = hMenu;
+		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
+
+		dwStyle = T::GetWndStyle(dwStyle);
+		dwExStyle = T::GetWndExStyle(dwExStyle);
+
+		if(rect.m_lpRect == NULL)
+			rect.m_lpRect = &TBase::rcDefault;
+
+		return CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, hMenu, atom, lpCreateParam);
+	}
+
+	HWND CreateEx(HWND hWndParent = NULL, ATL::_U_RECT rect = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
+	{
+		const int cchName = 256;
+		TCHAR szWindowName[cchName];
+		szWindowName[0] = 0;
+		::LoadString(ModuleHelper::GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, cchName);
+		HMENU hMenu = ::LoadMenu(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));
+
+		T* pT = static_cast<T*>(this);
+		HWND hWnd = pT->Create(hWndParent, rect, szWindowName, dwStyle, dwExStyle, hMenu, lpCreateParam);
+
+		if(hWnd != NULL)
+			m_hAccel = ::LoadAccelerators(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));
+
+		return hWnd;
+	}
+
+	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		ATLASSERT(!::IsWindow(m_hWndToolBar));
+		if(nResourceID == 0)
+			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
+		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
+		return (m_hWndToolBar != NULL);
+	}
+
+	virtual WNDPROC GetWindowProc()
+	{
+		return MDIFrameWindowProc;
+	}
+
+	static LRESULT CALLBACK MDIFrameWindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		CMDIFrameWindowImpl< T, TBase, TWinTraits >* pThis = (CMDIFrameWindowImpl< T, TBase, TWinTraits >*)hWnd;
+		// set a ptr to this message and save the old value
+#if (_ATL_VER >= 0x0700)
+		ATL::_ATL_MSG msg(pThis->m_hWnd, uMsg, wParam, lParam);
+		const ATL::_ATL_MSG* pOldMsg = pThis->m_pCurrentMsg;
+#else // !(_ATL_VER >= 0x0700)
+		MSG msg = { pThis->m_hWnd, uMsg, wParam, lParam, 0, { 0, 0 } };
+		const MSG* pOldMsg = pThis->m_pCurrentMsg;
+#endif // !(_ATL_VER >= 0x0700)
+		pThis->m_pCurrentMsg = &msg;
+		// pass to the message map to process
+		LRESULT lRes = 0;
+		BOOL bRet = pThis->ProcessWindowMessage(pThis->m_hWnd, uMsg, wParam, lParam, lRes, 0);
+		// restore saved value for the current message
+		ATLASSERT(pThis->m_pCurrentMsg == &msg);
+		pThis->m_pCurrentMsg = pOldMsg;
+		// do the default processing if message was not handled
+		if(!bRet)
+		{
+			if(uMsg != WM_NCDESTROY)
+				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
+			else
+			{
+				// unsubclass, if needed
+				LONG_PTR pfnWndProc = ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC);
+				lRes = pThis->DefWindowProc(uMsg, wParam, lParam);
+				if(pThis->m_pfnSuperWindowProc != ::DefWindowProc && ::GetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC) == pfnWndProc)
+					::SetWindowLongPtr(pThis->m_hWnd, GWLP_WNDPROC, (LONG_PTR)pThis->m_pfnSuperWindowProc);
+#if (_ATL_VER >= 0x0700)
+				// mark window as destryed
+				pThis->m_dwState |= WINSTATE_DESTROYED;
+#else // !(_ATL_VER >= 0x0700)
+				// clear out window handle
+				HWND hWnd = pThis->m_hWnd;
+				pThis->m_hWnd = NULL;
+				// clean up after window is destroyed
+				pThis->OnFinalMessage(hWnd);
+#endif // !(_ATL_VER >= 0x0700)
+			}
+		}
+#if (_ATL_VER >= 0x0700)
+		if(pThis->m_dwState & WINSTATE_DESTROYED && pThis->m_pCurrentMsg == NULL)
+		{
+			// clear out window handle
+			HWND hWnd = pThis->m_hWnd;
+			pThis->m_hWnd = NULL;
+			pThis->m_dwState &= ~WINSTATE_DESTROYED;
+			// clean up after window is destroyed
+			pThis->OnFinalMessage(hWnd);
+		}
+#endif // (_ATL_VER >= 0x0700)
+		return lRes;
+	}
+
+	// Overriden to call DefWindowProc which uses DefFrameProc
+	LRESULT DefWindowProc()
+	{
+		const MSG* pMsg = m_pCurrentMsg;
+		LRESULT lRes = 0;
+		if (pMsg != NULL)
+			lRes = DefWindowProc(pMsg->message, pMsg->wParam, pMsg->lParam);
+		return lRes;
+	}
+
+	LRESULT DefWindowProc(UINT uMsg, WPARAM wParam, LPARAM lParam)
+	{
+		return ::DefFrameProc(m_hWnd, m_hWndMDIClient, uMsg, wParam, lParam);
+	}
+
+	BOOL PreTranslateMessage(MSG* pMsg)
+	{
+		if(CFrameWindowImplBase<TBase, TWinTraits>::PreTranslateMessage(pMsg))
+			return TRUE;
+		return ::TranslateMDISysAccel(m_hWndMDIClient, pMsg);
+	}
+
+	HWND CreateMDIClient(HMENU hWindowMenu = NULL, UINT nID = ATL_IDW_CLIENT, UINT nFirstChildID = ATL_IDM_FIRST_MDICHILD)
+	{
+		DWORD dwStyle = WS_VISIBLE | WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS | MDIS_ALLCHILDSTYLES;
+		DWORD dwExStyle = WS_EX_CLIENTEDGE;
+
+		CLIENTCREATESTRUCT ccs = { 0 };
+		ccs.hWindowMenu = hWindowMenu;
+		ccs.idFirstChild = nFirstChildID;
+
+		if((GetStyle() & (WS_HSCROLL | WS_VSCROLL)) != 0)
+		{
+			// parent MDI frame's scroll styles move to the MDICLIENT
+			dwStyle |= (GetStyle() & (WS_HSCROLL | WS_VSCROLL));
+
+			// fast way to turn off the scrollbar bits (without a resize)
+			ModifyStyle(WS_HSCROLL | WS_VSCROLL, 0, SWP_NOREDRAW | SWP_FRAMECHANGED);
+		}
+
+		// Create MDICLIENT window
+		m_hWndClient = ::CreateWindowEx(dwExStyle, _T("MDIClient"), NULL,
+			dwStyle, 0, 0, 1, 1, m_hWnd, (HMENU)LongToHandle(nID),
+			ModuleHelper::GetModuleInstance(), (LPVOID)&ccs);
+		if (m_hWndClient == NULL)
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("MDI Frame failed to create MDICLIENT.\n"));
+			return NULL;
+		}
+
+		// Move it to the top of z-order
+		::BringWindowToTop(m_hWndClient);
+
+		// set as MDI client window
+		m_hWndMDIClient = m_hWndClient;
+
+		// update to proper size
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout();
+
+		return m_hWndClient;
+	}
+
+	typedef CFrameWindowImplBase<TBase, TWinTraits >   _baseClass;
+
+	BEGIN_MSG_MAP(CMDIFrameWindowImpl)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
+		MESSAGE_HANDLER(WM_MDISETMENU, OnMDISetMenu)
+#ifndef _ATL_NO_REBAR_SUPPORT
+#if (_WIN32_IE >= 0x0400)
+		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
+#endif // (_WIN32_IE >= 0x0400)
+#if (_WIN32_IE >= 0x0500)
+		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_ATL_NO_REBAR_SUPPORT
+		CHAIN_MSG_MAP(_baseClass)
+	END_MSG_MAP()
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(wParam != SIZE_MINIMIZED)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdateLayout();
+		}
+		// message must be handled, otherwise DefFrameProc would resize the client again
+		return 0;
+	}
+
+	LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		// don't allow CFrameWindowImplBase to handle this one
+		return DefWindowProc(uMsg, wParam, lParam);
+	}
+
+	LRESULT OnMDISetMenu(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		SetMDIFrameMenu();
+		return 0;
+	}
+
+#ifndef _ATL_NO_REBAR_SUPPORT
+#if (_WIN32_IE >= 0x0400)
+	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout(FALSE);
+		return 0;
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500)
+	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
+		if(!pT->PrepareChevronMenu(cmi))
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+		// display a popup menu with hidden items
+		pT->DisplayChevronMenu(cmi);
+		// cleanup
+		pT->CleanupChevronMenu(cmi);
+		return 0;
+	}
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_ATL_NO_REBAR_SUPPORT
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMDIChildWindowImpl
+
+#ifndef _WIN32_WCE
+
+template <class T, class TBase = CMDIWindow, class TWinTraits = ATL::CMDIChildWinTraits>
+class ATL_NO_VTABLE CMDIChildWindowImpl : public CFrameWindowImplBase<TBase, TWinTraits >
+{
+public:
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			UINT nMenuID = 0, LPVOID lpCreateParam = NULL)
+	{
+		ATOM atom = T::GetWndClassInfo().Register(&m_pfnSuperWindowProc);
+
+		if(nMenuID != 0)
+			m_hMenu = ::LoadMenu(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(nMenuID));
+
+		dwStyle = T::GetWndStyle(dwStyle);
+		dwExStyle = T::GetWndExStyle(dwExStyle);
+
+		dwExStyle |= WS_EX_MDICHILD;   // force this one
+		m_pfnSuperWindowProc = ::DefMDIChildProc;
+		m_hWndMDIClient = hWndParent;
+		ATLASSERT(::IsWindow(m_hWndMDIClient));
+
+		if(rect.m_lpRect == NULL)
+			rect.m_lpRect = &TBase::rcDefault;
+
+		// If the currently active MDI child is maximized, we want to create this one maximized too
+		ATL::CWindow wndParent = hWndParent;
+		BOOL bMaximized = FALSE;
+		wndParent.SendMessage(WM_MDIGETACTIVE, 0, (LPARAM)&bMaximized);
+		if(bMaximized)
+			wndParent.SetRedraw(FALSE);
+
+		HWND hWnd = CFrameWindowImplBase<TBase, TWinTraits >::Create(hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, (UINT)0U, atom, lpCreateParam);
+
+		if(bMaximized)
+		{
+			// Maximize and redraw everything
+			if(hWnd != NULL)
+				MDIMaximize(hWnd);
+			wndParent.SetRedraw(TRUE);
+			wndParent.RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_ALLCHILDREN);
+			::SetFocus(GetMDIFrame());   // focus will be set back to this window
+		}
+		else if(hWnd != NULL && ::IsWindowVisible(m_hWnd) && !::IsChild(hWnd, ::GetFocus()))
+		{
+			::SetFocus(hWnd);
+		}
+
+		return hWnd;
+	}
+
+	HWND CreateEx(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR lpcstrWindowName = NULL, DWORD dwStyle = 0, DWORD dwExStyle = 0, LPVOID lpCreateParam = NULL)
+	{
+		const int cchName = 256;
+		TCHAR szWindowName[cchName];
+		szWindowName[0] = 0;
+		if(lpcstrWindowName == NULL)
+		{
+			::LoadString(ModuleHelper::GetResourceInstance(), T::GetWndClassInfo().m_uCommonResourceID, szWindowName, cchName);
+			lpcstrWindowName = szWindowName;
+		}
+
+		T* pT = static_cast<T*>(this);
+		HWND hWnd = pT->Create(hWndParent, rect, lpcstrWindowName, dwStyle, dwExStyle, T::GetWndClassInfo().m_uCommonResourceID, lpCreateParam);
+
+		if(hWnd != NULL)
+			m_hAccel = ::LoadAccelerators(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE(T::GetWndClassInfo().m_uCommonResourceID));
+
+		return hWnd;
+	}
+
+	BOOL CreateSimpleToolBar(UINT nResourceID = 0, DWORD dwStyle = ATL_SIMPLE_TOOLBAR_STYLE, UINT nID = ATL_IDW_TOOLBAR)
+	{
+		ATLASSERT(!::IsWindow(m_hWndToolBar));
+		if(nResourceID == 0)
+			nResourceID = T::GetWndClassInfo().m_uCommonResourceID;
+		m_hWndToolBar = T::CreateSimpleToolBarCtrl(m_hWnd, nResourceID, TRUE, dwStyle, nID);
+		return (m_hWndToolBar != NULL);
+	}
+
+	BOOL UpdateClientEdge(LPRECT lpRect = NULL)
+	{
+		// only adjust for active MDI child window
+		HWND hWndChild = MDIGetActive();
+		if(hWndChild != NULL && hWndChild != m_hWnd)
+			return FALSE;
+
+		// need to adjust the client edge style as max/restore happens
+		DWORD dwStyle = ::GetWindowLong(m_hWndMDIClient, GWL_EXSTYLE);
+		DWORD dwNewStyle = dwStyle;
+		if(hWndChild != NULL && ((GetExStyle() & WS_EX_CLIENTEDGE) == 0) && ((GetStyle() & WS_MAXIMIZE) != 0))
+			dwNewStyle &= ~(WS_EX_CLIENTEDGE);
+		else
+			dwNewStyle |= WS_EX_CLIENTEDGE;
+
+		if(dwStyle != dwNewStyle)
+		{
+			// SetWindowPos will not move invalid bits
+			::RedrawWindow(m_hWndMDIClient, NULL, NULL,
+				RDW_INVALIDATE | RDW_ALLCHILDREN);
+			// remove/add WS_EX_CLIENTEDGE to MDI client area
+			::SetWindowLong(m_hWndMDIClient, GWL_EXSTYLE, dwNewStyle);
+			::SetWindowPos(m_hWndMDIClient, NULL, 0, 0, 0, 0,
+				SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE |
+				SWP_NOZORDER | SWP_NOCOPYBITS);
+
+			// return new client area
+			if (lpRect != NULL)
+				::GetClientRect(m_hWndMDIClient, lpRect);
+
+			return TRUE;
+		}
+
+		return FALSE;
+	}
+
+	typedef CFrameWindowImplBase<TBase, TWinTraits >   _baseClass;
+	BEGIN_MSG_MAP(CMDIChildWindowImpl)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_WINDOWPOSCHANGED, OnWindowPosChanged)
+		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
+		MESSAGE_HANDLER(WM_MENUSELECT, OnMenuSelect)
+		MESSAGE_HANDLER(WM_MDIACTIVATE, OnMDIActivate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+#ifndef _ATL_NO_REBAR_SUPPORT
+#if (_WIN32_IE >= 0x0400)
+		NOTIFY_CODE_HANDLER(RBN_AUTOSIZE, OnReBarAutoSize)
+#endif // (_WIN32_IE >= 0x0400)
+#if (_WIN32_IE >= 0x0500)
+		NOTIFY_CODE_HANDLER(RBN_CHEVRONPUSHED, OnChevronPushed)
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_ATL_NO_REBAR_SUPPORT
+		CHAIN_MSG_MAP(_baseClass)
+	END_MSG_MAP()
+
+	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		DefWindowProc(uMsg, wParam, lParam);   // needed for MDI children
+		if(wParam != SIZE_MINIMIZED)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->UpdateLayout();
+		}
+		return 0;
+	}
+
+	LRESULT OnWindowPosChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		// update MDI client edge and adjust MDI child rect
+		LPWINDOWPOS lpWndPos = (LPWINDOWPOS)lParam;
+
+		if(!(lpWndPos->flags & SWP_NOSIZE))
+		{
+			RECT rectClient;
+			if(UpdateClientEdge(&rectClient) && ((GetStyle() & WS_MAXIMIZE) != 0))
+			{
+				::AdjustWindowRectEx(&rectClient, GetStyle(), FALSE, GetExStyle());
+				lpWndPos->x = rectClient.left;
+				lpWndPos->y = rectClient.top;
+				lpWndPos->cx = rectClient.right - rectClient.left;
+				lpWndPos->cy = rectClient.bottom - rectClient.top;
+			}
+		}
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		LRESULT lRes = DefWindowProc(uMsg, wParam, lParam);
+
+		// Activate this MDI window if needed
+		if(lRes == MA_ACTIVATE || lRes == MA_ACTIVATEANDEAT)
+		{
+			if(MDIGetActive() != m_hWnd)
+				MDIActivate(m_hWnd);
+		}
+
+		return lRes;
+	}
+
+	LRESULT OnMenuSelect(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		return ::SendMessage(GetMDIFrame(), uMsg, wParam, lParam);
+	}
+
+	LRESULT OnMDIActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if((HWND)lParam == m_hWnd && m_hMenu != NULL)
+			SetMDIFrameMenu();
+		else if((HWND)lParam == NULL)
+			::SendMessage(GetMDIFrame(), WM_MDISETMENU, 0, 0);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_hMenu != NULL)
+		{
+			::DestroyMenu(m_hMenu);
+			m_hMenu = NULL;
+		}
+		UpdateClientEdge();
+		bHandled = FALSE;
+		return 1;
+	}
+
+#ifndef _ATL_NO_REBAR_SUPPORT
+#if (_WIN32_IE >= 0x0400)
+	LRESULT OnReBarAutoSize(int /*idCtrl*/, LPNMHDR /*pnmh*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout(FALSE);
+		return 0;
+	}
+#endif // (_WIN32_IE >= 0x0400)
+
+#if (_WIN32_IE >= 0x0500)
+	LRESULT OnChevronPushed(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		_ChevronMenuInfo cmi = { NULL, (LPNMREBARCHEVRON)pnmh, false };
+		if(!pT->PrepareChevronMenu(cmi))
+		{
+			bHandled = FALSE;
+			return 1;
+		}
+		// display a popup menu with hidden items
+		pT->DisplayChevronMenu(cmi);
+		// cleanup
+		pT->CleanupChevronMenu(cmi);
+		return 0;
+	}
+#endif // (_WIN32_IE >= 0x0500)
+#endif // !_ATL_NO_REBAR_SUPPORT
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// COwnerDraw - MI class for owner-draw support
+
+template <class T>
+class COwnerDraw
+{
+public:
+#if (_ATL_VER < 0x0700)
+	BOOL m_bHandledOD;
+
+	BOOL IsMsgHandled() const
+	{
+		return m_bHandledOD;
+	}
+	void SetMsgHandled(BOOL bHandled)
+	{
+		m_bHandledOD = bHandled;
+	}
+#endif // (_ATL_VER < 0x0700)
+
+// Message map and handlers
+	BEGIN_MSG_MAP(COwnerDraw< T >)
+		MESSAGE_HANDLER(WM_DRAWITEM, OnDrawItem)
+		MESSAGE_HANDLER(WM_MEASUREITEM, OnMeasureItem)
+		MESSAGE_HANDLER(WM_COMPAREITEM, OnCompareItem)
+		MESSAGE_HANDLER(WM_DELETEITEM, OnDeleteItem)
+	ALT_MSG_MAP(1)
+		MESSAGE_HANDLER(OCM_DRAWITEM, OnDrawItem)
+		MESSAGE_HANDLER(OCM_MEASUREITEM, OnMeasureItem)
+		MESSAGE_HANDLER(OCM_COMPAREITEM, OnCompareItem)
+		MESSAGE_HANDLER(OCM_DELETEITEM, OnDeleteItem)
+	END_MSG_MAP()
+
+	LRESULT OnDrawItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetMsgHandled(TRUE);
+		pT->DrawItem((LPDRAWITEMSTRUCT)lParam);
+		bHandled = pT->IsMsgHandled();
+		return (LRESULT)TRUE;
+	}
+
+	LRESULT OnMeasureItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetMsgHandled(TRUE);
+		pT->MeasureItem((LPMEASUREITEMSTRUCT)lParam);
+		bHandled = pT->IsMsgHandled();
+		return (LRESULT)TRUE;
+	}
+
+	LRESULT OnCompareItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetMsgHandled(TRUE);
+		bHandled = pT->IsMsgHandled();
+		return (LRESULT)pT->CompareItem((LPCOMPAREITEMSTRUCT)lParam);
+	}
+
+	LRESULT OnDeleteItem(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetMsgHandled(TRUE);
+		pT->DeleteItem((LPDELETEITEMSTRUCT)lParam);
+		bHandled = pT->IsMsgHandled();
+		return (LRESULT)TRUE;
+	}
+
+// Overrideables
+	void DrawItem(LPDRAWITEMSTRUCT /*lpDrawItemStruct*/)
+	{
+		// must be implemented
+		ATLASSERT(FALSE);
+	}
+
+	void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct)
+	{
+		if(lpMeasureItemStruct->CtlType != ODT_MENU)
+		{
+			// return default height for a system font
+			T* pT = static_cast<T*>(this);
+			HWND hWnd = pT->GetDlgItem(lpMeasureItemStruct->CtlID);
+			CClientDC dc(hWnd);
+			TEXTMETRIC tm = { 0 };
+			dc.GetTextMetrics(&tm);
+
+			lpMeasureItemStruct->itemHeight = tm.tmHeight;
+		}
+		else
+			lpMeasureItemStruct->itemHeight = ::GetSystemMetrics(SM_CYMENU);
+	}
+
+	int CompareItem(LPCOMPAREITEMSTRUCT /*lpCompareItemStruct*/)
+	{
+		// all items are equal
+		return 0;
+	}
+
+	void DeleteItem(LPDELETEITEMSTRUCT /*lpDeleteItemStruct*/)
+	{
+		// default - nothing
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Update UI macros
+
+// these build the Update UI map inside a class definition
+#define BEGIN_UPDATE_UI_MAP(thisClass) \
+	static const CUpdateUIBase::_AtlUpdateUIMap* GetUpdateUIMap() \
+	{ \
+		static const _AtlUpdateUIMap theMap[] = \
+		{
+
+#define UPDATE_ELEMENT(nID, wType) \
+			{ nID,  wType },
+
+#define END_UPDATE_UI_MAP() \
+			{ (WORD)-1, 0 } \
+		}; \
+		return theMap; \
+	}
+
+///////////////////////////////////////////////////////////////////////////////
+// CUpdateUI - manages UI elements updating
+
+class CUpdateUIBase
+{
+public:
+	// constants
+	enum
+	{
+		// UI element type
+		UPDUI_MENUPOPUP		= 0x0001,
+		UPDUI_MENUBAR		= 0x0002,
+		UPDUI_CHILDWINDOW	= 0x0004,
+		UPDUI_TOOLBAR		= 0x0008,
+		UPDUI_STATUSBAR		= 0x0010,
+		// state
+		UPDUI_ENABLED		= 0x0000,
+		UPDUI_DISABLED		= 0x0100,
+		UPDUI_CHECKED		= 0x0200,
+		UPDUI_CHECKED2		= 0x0400,
+		UPDUI_RADIO		= 0x0800,
+		UPDUI_DEFAULT		= 0x1000,
+		UPDUI_TEXT		= 0x2000,
+		// internal state
+		UPDUI_CLEARDEFAULT	= 0x4000,
+	};
+
+	// element data
+	struct _AtlUpdateUIElement
+	{
+		HWND m_hWnd;
+		WORD m_wType;
+
+		bool operator ==(const _AtlUpdateUIElement& e) const
+		{ return (m_hWnd == e.m_hWnd && m_wType == e.m_wType); }
+	};
+
+	// map data
+	struct _AtlUpdateUIMap
+	{
+		WORD m_nID;
+		WORD m_wType;
+
+		bool operator ==(const _AtlUpdateUIMap& e) const
+		{ return (m_nID == e.m_nID && m_wType == e.m_wType); }
+	};
+
+	// instance data
+	struct _AtlUpdateUIData
+	{
+		WORD m_wState;
+		union
+		{
+			void* m_lpData;
+			LPTSTR m_lpstrText;
+			struct
+			{
+				WORD m_nIDFirst;
+				WORD m_nIDLast;
+			};
+		};
+
+		bool operator ==(const _AtlUpdateUIData& e) const
+		{ return (m_wState == e.m_wState && m_lpData == e.m_lpData); }
+	};
+
+	ATL::CSimpleArray<_AtlUpdateUIElement> m_UIElements;   // elements data
+	const _AtlUpdateUIMap* m_pUIMap;                       // static UI data
+	_AtlUpdateUIData* m_pUIData;                           // instance UI data
+	WORD m_wDirtyType;                                     // global dirty flag
+
+	bool m_bBlockAccelerators;
+
+
+// Constructor, destructor
+	CUpdateUIBase() : m_pUIMap(NULL), m_pUIData(NULL), m_wDirtyType(0), m_bBlockAccelerators(false)
+	{ }
+
+	~CUpdateUIBase()
+	{
+		if(m_pUIMap != NULL && m_pUIData != NULL)
+		{
+			const _AtlUpdateUIMap* pUIMap = m_pUIMap;
+			_AtlUpdateUIData* pUIData = m_pUIData;
+			while(pUIMap->m_nID != (WORD)-1)
+			{
+				if(pUIData->m_wState & UPDUI_TEXT)
+					delete [] pUIData->m_lpstrText;
+				pUIMap++;
+				pUIData++;
+			}
+			delete [] m_pUIData;
+		}
+	}
+
+// Check for disabled commands
+	bool UIGetBlockAccelerators() const
+	{
+		return m_bBlockAccelerators;
+	}
+
+	bool UISetBlockAccelerators(bool bBlock)
+	{
+		bool bOld = m_bBlockAccelerators;
+		m_bBlockAccelerators = bBlock;
+		return bOld;
+	}
+
+// Add elements
+	BOOL UIAddMenuBar(HWND hWnd)                // menu bar (main menu)
+	{
+		if(hWnd == NULL)
+			return FALSE;
+		_AtlUpdateUIElement e;
+		e.m_hWnd = hWnd;
+		e.m_wType = UPDUI_MENUBAR;
+		return m_UIElements.Add(e);
+	}
+
+	BOOL UIAddToolBar(HWND hWnd)                // toolbar
+	{
+		if(hWnd == NULL)
+			return FALSE;
+		_AtlUpdateUIElement e;
+		e.m_hWnd = hWnd;
+		e.m_wType = UPDUI_TOOLBAR;
+		return m_UIElements.Add(e);
+	}
+
+	BOOL UIAddStatusBar(HWND hWnd)              // status bar
+	{
+		if(hWnd == NULL)
+			return FALSE;
+		_AtlUpdateUIElement e;
+		e.m_hWnd = hWnd;
+		e.m_wType = UPDUI_STATUSBAR;
+		return m_UIElements.Add(e);
+	}
+
+	BOOL UIAddChildWindowContainer(HWND hWnd)   // child window
+	{
+		if(hWnd == NULL)
+			return FALSE;
+		_AtlUpdateUIElement e;
+		e.m_hWnd = hWnd;
+		e.m_wType = UPDUI_CHILDWINDOW;
+		return m_UIElements.Add(e);
+	}
+
+// Message map for popup menu updates and accelerator blocking
+	BEGIN_MSG_MAP(CUpdateUIBase)
+		MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitMenuPopup)
+		MESSAGE_HANDLER(WM_COMMAND, OnCommand)
+	END_MSG_MAP()
+
+	LRESULT OnInitMenuPopup(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+		HMENU hMenu = (HMENU)wParam;
+		if(hMenu == NULL)
+			return 1;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return 1;
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		while(pMap->m_nID != (WORD)-1)
+		{
+			if(pMap->m_wType & UPDUI_MENUPOPUP)
+			{
+				UIUpdateMenuBarElement(pMap->m_nID, pUIData, hMenu);
+
+				if((pUIData->m_wState & UPDUI_RADIO) != 0)
+					::CheckMenuRadioItem(hMenu, pUIData->m_nIDFirst, pUIData->m_nIDLast, pMap->m_nID, MF_BYCOMMAND);
+			}
+			pMap++;
+			pUIData++;
+		}
+		return 0;
+	}
+
+	LRESULT OnCommand(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		bHandled = FALSE;
+		if(m_bBlockAccelerators && HIWORD(wParam) == 1)   // accelerators only
+		{
+			int nID = LOWORD(wParam);
+			if((UIGetState(nID) & UPDUI_DISABLED) == UPDUI_DISABLED)
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("CUpdateUIBase::OnCommand - blocked disabled command 0x%4.4X\n"), nID);
+				bHandled = TRUE;   // eat the command, UI item is disabled
+			}
+		}
+		return 0;
+	}
+
+// methods for setting UI element state
+	BOOL UIEnable(int nID, BOOL bEnable, BOOL bForceUpdate = FALSE)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{
+				if(bEnable)
+				{
+					if(pUIData->m_wState & UPDUI_DISABLED)
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState &= ~UPDUI_DISABLED;
+					}
+				}
+				else
+				{
+					if(!(pUIData->m_wState & UPDUI_DISABLED))
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState |= UPDUI_DISABLED;
+					}
+				}
+
+				if(bForceUpdate)
+					pUIData->m_wState |= pMap->m_wType;
+				if(pUIData->m_wState & pMap->m_wType)
+					m_wDirtyType |= pMap->m_wType;
+
+				break;   // found
+			}
+		}
+
+		return TRUE;
+	}
+
+	BOOL UISetCheck(int nID, int nCheck, BOOL bForceUpdate = FALSE)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{
+				switch(nCheck)
+				{
+				case 0:
+					if((pUIData->m_wState & UPDUI_CHECKED) || (pUIData->m_wState & UPDUI_CHECKED2))
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState &= ~(UPDUI_CHECKED | UPDUI_CHECKED2);
+					}
+					break;
+				case 1:
+					if(!(pUIData->m_wState & UPDUI_CHECKED))
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState &= ~UPDUI_CHECKED2;
+						pUIData->m_wState |= UPDUI_CHECKED;
+					}
+					break;
+				case 2:
+					if(!(pUIData->m_wState & UPDUI_CHECKED2))
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState &= ~UPDUI_CHECKED;
+						pUIData->m_wState |= UPDUI_CHECKED2;
+					}
+					break;
+				}
+
+				if(bForceUpdate)
+					pUIData->m_wState |= pMap->m_wType;
+				if(pUIData->m_wState & pMap->m_wType)
+					m_wDirtyType |= pMap->m_wType;
+
+				break;   // found
+			}
+		}
+
+		return TRUE;
+	}
+
+	// variant that supports bool (checked/not-checked, no intermediate state)
+	BOOL UISetCheck(int nID, bool bCheck, BOOL bForceUpdate = FALSE)
+	{
+		return UISetCheck(nID, bCheck ? 1 : 0, bForceUpdate);
+	}
+
+	BOOL UISetRadio(int nID, BOOL bRadio, BOOL bForceUpdate = FALSE)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{
+				if(bRadio)
+				{
+					if(!(pUIData->m_wState & UPDUI_RADIO))
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState |= UPDUI_RADIO;
+					}
+				}
+				else
+				{
+					if(pUIData->m_wState & UPDUI_RADIO)
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState &= ~UPDUI_RADIO;
+					}
+				}
+
+				if(bForceUpdate)
+					pUIData->m_wState |= pMap->m_wType;
+				if(pUIData->m_wState & pMap->m_wType)
+					m_wDirtyType |= pMap->m_wType;
+
+				break;   // found
+			}
+		}
+
+		return TRUE;
+	}
+
+	// for menu items
+	BOOL UISetRadioMenuItem(int nID, int nIDFirst, int nIDLast, BOOL bForceUpdate = FALSE)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{
+				pUIData->m_wState |= pMap->m_wType;
+				pUIData->m_wState |= UPDUI_RADIO;
+				pUIData->m_nIDFirst = (WORD)nIDFirst;
+				pUIData->m_nIDLast = (WORD)nIDLast;
+
+				if(bForceUpdate)
+					pUIData->m_wState |= pMap->m_wType;
+				if(pUIData->m_wState & pMap->m_wType)
+					m_wDirtyType |= pMap->m_wType;
+			}
+			else if(pMap->m_nID >= nIDFirst && pMap->m_nID <= nIDLast)
+			{
+				if(pUIData->m_wState & UPDUI_RADIO)
+				{
+					pUIData->m_wState &= ~pMap->m_wType;
+					pUIData->m_wState &= ~UPDUI_RADIO;
+					pUIData->m_nIDFirst = 0;
+					pUIData->m_nIDLast = 0;
+				}
+			}
+
+			if(pMap->m_nID == nIDLast)
+				break;
+		}
+
+		return TRUE;
+	}
+
+	BOOL UISetText(int nID, LPCTSTR lpstrText, BOOL bForceUpdate = FALSE)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+		if(lpstrText == NULL)
+			lpstrText = _T("");
+
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{
+				if(pUIData->m_lpstrText == NULL || lstrcmp(pUIData->m_lpstrText, lpstrText))
+				{
+					delete [] pUIData->m_lpstrText;
+					pUIData->m_lpstrText = NULL;
+					int nStrLen = lstrlen(lpstrText);
+					ATLTRY(pUIData->m_lpstrText = new TCHAR[nStrLen + 1]);
+					if(pUIData->m_lpstrText == NULL)
+					{
+						ATLTRACE2(atlTraceUI, 0, _T("UISetText - memory allocation failed\n"));
+						break;
+					}
+					SecureHelper::strcpy_x(pUIData->m_lpstrText, nStrLen + 1, lpstrText);
+					pUIData->m_wState |= (UPDUI_TEXT | pMap->m_wType);
+				}
+
+				if(bForceUpdate)
+					pUIData->m_wState |= (UPDUI_TEXT | pMap->m_wType);
+				if(pUIData->m_wState & pMap->m_wType)
+					m_wDirtyType |= pMap->m_wType;
+
+				break;   // found
+			}
+		}
+
+		return TRUE;
+	}
+
+	BOOL UISetDefault(int nID, BOOL bDefault, BOOL bForceUpdate = FALSE)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{
+				if(bDefault)
+				{
+					if((pUIData->m_wState & UPDUI_DEFAULT) == 0)
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState |= UPDUI_DEFAULT;
+					}
+				}
+				else
+				{
+					if((pUIData->m_wState & UPDUI_DEFAULT) != 0)
+					{
+						pUIData->m_wState |= pMap->m_wType;
+						pUIData->m_wState &= ~UPDUI_DEFAULT;
+						pUIData->m_wState |= UPDUI_CLEARDEFAULT;
+					}
+				}
+
+				if(bForceUpdate)
+					pUIData->m_wState |= pMap->m_wType;
+				if(pUIData->m_wState & pMap->m_wType)
+					m_wDirtyType |= pMap->m_wType;
+
+				break;   // found
+			}
+		}
+
+		return TRUE;
+	}
+
+// methods for complete state set/get
+	BOOL UISetState(int nID, DWORD dwState)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+			{		
+				pUIData->m_wState = (WORD)(dwState | pMap->m_wType);
+				m_wDirtyType |= pMap->m_wType;
+				break;   // found
+			}
+		}
+		return TRUE;
+	}
+
+	DWORD UIGetState(int nID)
+	{
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return 0;
+		for( ; pMap->m_nID != (WORD)-1; pMap++, pUIData++)
+		{
+			if(nID == (int)pMap->m_nID)
+				return pUIData->m_wState;
+		}
+		return 0;
+	}
+
+// methods for updating UI
+#ifndef _WIN32_WCE
+	BOOL UIUpdateMenuBar(BOOL bForceUpdate = FALSE, BOOL bMainMenu = FALSE)
+	{
+		if(!(m_wDirtyType & UPDUI_MENUBAR) && !bForceUpdate)
+			return TRUE;
+
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		while(pMap->m_nID != (WORD)-1)
+		{
+			for(int i = 0; i < m_UIElements.GetSize(); i++)
+			{
+				if(m_UIElements[i].m_wType == UPDUI_MENUBAR)
+				{
+					HMENU hMenu = ::GetMenu(m_UIElements[i].m_hWnd);
+					if(hMenu != NULL && (pUIData->m_wState & UPDUI_MENUBAR) && (pMap->m_wType & UPDUI_MENUBAR))
+						UIUpdateMenuBarElement(pMap->m_nID, pUIData, hMenu);
+				}
+				if(bMainMenu)
+					::DrawMenuBar(m_UIElements[i].m_hWnd);
+			}
+			pMap++;
+			pUIData->m_wState &= ~UPDUI_MENUBAR;
+			if(pUIData->m_wState & UPDUI_TEXT)
+			{
+				delete [] pUIData->m_lpstrText;
+				pUIData->m_lpstrText = NULL;
+				pUIData->m_wState &= ~UPDUI_TEXT;
+			}
+			pUIData++;
+		}
+
+		m_wDirtyType &= ~UPDUI_MENUBAR;
+		return TRUE;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL UIUpdateToolBar(BOOL bForceUpdate = FALSE)
+	{
+		if(!(m_wDirtyType & UPDUI_TOOLBAR) && !bForceUpdate)
+			return TRUE;
+
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		while(pMap->m_nID != (WORD)-1)
+		{
+			for(int i = 0; i < m_UIElements.GetSize(); i++)
+			{
+				if(m_UIElements[i].m_wType == UPDUI_TOOLBAR)
+				{
+					if((pUIData->m_wState & UPDUI_TOOLBAR) && (pMap->m_wType & UPDUI_TOOLBAR))
+						UIUpdateToolBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
+				}
+			}
+			pMap++;
+			pUIData->m_wState &= ~UPDUI_TOOLBAR;
+			pUIData++;
+		}
+
+		m_wDirtyType &= ~UPDUI_TOOLBAR;
+		return TRUE;
+	}
+
+	BOOL UIUpdateStatusBar(BOOL bForceUpdate = FALSE)
+	{
+		if(!(m_wDirtyType & UPDUI_STATUSBAR) && !bForceUpdate)
+			return TRUE;
+
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		while(pMap->m_nID != (WORD)-1)
+		{
+			for(int i = 0; i < m_UIElements.GetSize(); i++)
+			{
+				if(m_UIElements[i].m_wType == UPDUI_STATUSBAR)
+				{
+					if((pUIData->m_wState & UPDUI_STATUSBAR) && (pMap->m_wType & UPDUI_STATUSBAR))
+						UIUpdateStatusBarElement(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
+				}
+			}
+			pMap++;
+			pUIData->m_wState &= ~UPDUI_STATUSBAR;
+			if(pUIData->m_wState & UPDUI_TEXT)
+			{
+				delete [] pUIData->m_lpstrText;
+				pUIData->m_lpstrText = NULL;
+				pUIData->m_wState &= ~UPDUI_TEXT;
+			}
+			pUIData++;
+		}
+
+		m_wDirtyType &= ~UPDUI_STATUSBAR;
+		return TRUE;
+	}
+
+	BOOL UIUpdateChildWindows(BOOL bForceUpdate = FALSE)
+	{
+		if(!(m_wDirtyType & UPDUI_CHILDWINDOW) && !bForceUpdate)
+			return TRUE;
+
+		const _AtlUpdateUIMap* pMap = m_pUIMap;
+		_AtlUpdateUIData* pUIData = m_pUIData;
+		if(pUIData == NULL)
+			return FALSE;
+
+		while(pMap->m_nID != (WORD)-1)
+		{
+			for(int i = 0; i < m_UIElements.GetSize(); i++)
+			{
+				if(m_UIElements[i].m_wType == UPDUI_CHILDWINDOW)
+				{
+					if((pUIData->m_wState & UPDUI_CHILDWINDOW) && (pMap->m_wType & UPDUI_CHILDWINDOW))
+						UIUpdateChildWindow(pMap->m_nID, pUIData, m_UIElements[i].m_hWnd);
+				}
+			}
+			pMap++;
+			pUIData->m_wState &= ~UPDUI_CHILDWINDOW;
+			if(pUIData->m_wState & UPDUI_TEXT)
+			{
+				delete [] pUIData->m_lpstrText;
+				pUIData->m_lpstrText = NULL;
+				pUIData->m_wState &= ~UPDUI_TEXT;
+			}
+			pUIData++;
+		}
+
+		m_wDirtyType &= ~UPDUI_CHILDWINDOW;
+		return TRUE;
+	}
+
+// internal element specific methods
+	static void UIUpdateMenuBarElement(int nID, _AtlUpdateUIData* pUIData, HMENU hMenu)
+	{
+#ifndef _WIN32_WCE
+		if((pUIData->m_wState & UPDUI_CLEARDEFAULT) != 0)
+		{
+			::SetMenuDefaultItem(hMenu, (UINT)-1, 0);
+			pUIData->m_wState &= ~UPDUI_CLEARDEFAULT;
+		}
+#endif // !_WIN32_WCE
+
+		CMenuItemInfo mii;
+		mii.fMask = MIIM_STATE;
+		mii.wID = nID;
+
+#ifndef _WIN32_WCE
+		if((pUIData->m_wState & UPDUI_DISABLED) != 0)
+			mii.fState |= MFS_DISABLED | MFS_GRAYED;
+		else
+			mii.fState |= MFS_ENABLED;
+
+		if((pUIData->m_wState & UPDUI_CHECKED) != 0)
+			mii.fState |= MFS_CHECKED;
+		else
+			mii.fState |= MFS_UNCHECKED;
+
+		if((pUIData->m_wState & UPDUI_DEFAULT) != 0)
+			mii.fState |= MFS_DEFAULT;
+#else // CE specific
+		// ::SetMenuItemInfo() can't disable or check menu items
+		// on Windows CE, so we have to do that directly
+		UINT uEnable = MF_BYCOMMAND;
+		if((pUIData->m_wState & UPDUI_DISABLED) != 0)
+			uEnable |= MF_GRAYED;
+		else
+			uEnable |= MF_ENABLED;
+		::EnableMenuItem(hMenu, nID, uEnable);
+
+		UINT uCheck = MF_BYCOMMAND;
+		if((pUIData->m_wState & UPDUI_CHECKED) != 0)
+			uCheck |= MF_CHECKED;
+		else
+			uCheck |= MF_UNCHECKED;
+		::CheckMenuItem(hMenu, nID, uCheck);
+#endif // _WIN32_WCE
+
+		if((pUIData->m_wState & UPDUI_TEXT) != 0)
+		{
+			CMenuItemInfo miiNow;
+			miiNow.fMask = MIIM_TYPE;
+			miiNow.wID = nID;
+			if(::GetMenuItemInfo(hMenu, nID, FALSE, &miiNow))
+			{
+				mii.fMask |= MIIM_TYPE;
+				// MFT_BITMAP and MFT_SEPARATOR don't go together with MFT_STRING
+#ifndef _WIN32_WCE
+				mii.fType |= (miiNow.fType & ~(MFT_BITMAP | MFT_SEPARATOR)) | MFT_STRING;
+#else // CE specific
+				mii.fType |= (miiNow.fType & ~(MFT_SEPARATOR)) | MFT_STRING;
+#endif // _WIN32_WCE
+				mii.dwTypeData = pUIData->m_lpstrText;
+			}
+		}
+
+		::SetMenuItemInfo(hMenu, nID, FALSE, &mii);
+	}
+
+	static void UIUpdateToolBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndToolBar)
+	{
+		// Note: only handles enabled/disabled, checked state, and radio (press)
+		::SendMessage(hWndToolBar, TB_ENABLEBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
+		::SendMessage(hWndToolBar, TB_CHECKBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED) ? TRUE : FALSE);
+		::SendMessage(hWndToolBar, TB_INDETERMINATE, nID, (LPARAM)(pUIData->m_wState & UPDUI_CHECKED2) ? TRUE : FALSE);
+		::SendMessage(hWndToolBar, TB_PRESSBUTTON, nID, (LPARAM)(pUIData->m_wState & UPDUI_RADIO) ? TRUE : FALSE);
+	}
+
+	static void UIUpdateStatusBarElement(int nID, _AtlUpdateUIData* pUIData, HWND hWndStatusBar)
+	{
+		// Note: only handles text
+		if(pUIData->m_wState & UPDUI_TEXT)
+			::SendMessage(hWndStatusBar, SB_SETTEXT, nID, (LPARAM)pUIData->m_lpstrText);
+	}
+
+	static void UIUpdateChildWindow(int nID, _AtlUpdateUIData* pUIData, HWND hWnd)
+	{
+		HWND hChild = ::GetDlgItem(hWnd, nID);
+
+		::EnableWindow(hChild, (pUIData->m_wState & UPDUI_DISABLED) ? FALSE : TRUE);
+		// for check and radio, assume that window is a button
+		int nCheck = BST_UNCHECKED;
+		if(pUIData->m_wState & UPDUI_CHECKED || pUIData->m_wState & UPDUI_RADIO)
+			nCheck = BST_CHECKED;
+		else if(pUIData->m_wState & UPDUI_CHECKED2)
+			nCheck = BST_INDETERMINATE;
+		::SendMessage(hChild, BM_SETCHECK, nCheck, 0L);
+		if(pUIData->m_wState & UPDUI_DEFAULT)
+		{
+			DWORD dwRet = (DWORD)::SendMessage(hWnd, DM_GETDEFID, 0, 0L);
+			if(HIWORD(dwRet) == DC_HASDEFID)
+			{
+				HWND hOldDef = ::GetDlgItem(hWnd, (int)(short)LOWORD(dwRet));
+				// remove BS_DEFPUSHBUTTON
+				::SendMessage(hOldDef, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE, 0));
+			}
+			::SendMessage(hWnd, DM_SETDEFID, nID, 0L);
+		}
+		if(pUIData->m_wState & UPDUI_TEXT)
+			::SetWindowText(hChild, pUIData->m_lpstrText);
+	}
+};
+
+template <class T>
+class CUpdateUI : public CUpdateUIBase
+{
+public:
+	CUpdateUI()
+	{
+		T* pT = static_cast<T*>(this);
+		pT;
+		const _AtlUpdateUIMap* pMap = pT->GetUpdateUIMap();
+		m_pUIMap = pMap;
+		ATLASSERT(m_pUIMap != NULL);
+		int nCount;
+		for(nCount = 1; pMap->m_nID != (WORD)-1; nCount++)
+			pMap++;
+
+		// check for duplicates (debug only)
+#ifdef _DEBUG
+		for(int i = 0; i < nCount; i++)
+		{
+			for(int j = 0; j < nCount; j++)
+			{
+				// shouldn't have duplicates in the update UI map
+				if(i != j)
+					ATLASSERT(m_pUIMap[j].m_nID != m_pUIMap[i].m_nID);
+			}
+		}
+#endif // _DEBUG
+
+		ATLTRY(m_pUIData = new _AtlUpdateUIData[nCount]);
+		ATLASSERT(m_pUIData != NULL);
+
+		if(m_pUIData != NULL)
+			memset(m_pUIData, 0, sizeof(_AtlUpdateUIData) * nCount);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDynamicUpdateUI - allows update elements to dynamically added and removed
+//                    in addition to a static update UI map
+
+template <class T>
+class CDynamicUpdateUI : public CUpdateUIBase
+{
+public:
+// Data members
+	ATL::CSimpleArray<_AtlUpdateUIMap> m_arrUIMap;     // copy of the static UI data
+	ATL::CSimpleArray<_AtlUpdateUIData> m_arrUIData;   // instance UI data
+
+// Constructor/destructor
+	CDynamicUpdateUI()
+	{
+		T* pT = static_cast<T*>(this);
+		pT;
+		const _AtlUpdateUIMap* pMap = pT->GetUpdateUIMap();
+		ATLASSERT(pMap != NULL);
+
+		for(;;)
+		{
+			BOOL bRet = m_arrUIMap.Add(*(_AtlUpdateUIMap*)pMap);
+			ATLASSERT(bRet);
+
+			if(bRet != FALSE)
+			{
+				_AtlUpdateUIData data = { 0, NULL };
+				bRet = m_arrUIData.Add(data);
+				ATLASSERT(bRet);
+			}
+
+			if(pMap->m_nID == (WORD)-1)
+				break;
+
+			pMap++;
+		}
+
+		ATLASSERT(m_arrUIMap.GetSize() == m_arrUIData.GetSize());
+
+#ifdef _DEBUG
+		// check for duplicates (debug only)
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			for(int j = 0; j < m_arrUIMap.GetSize(); j++)
+			{
+				// shouldn't have duplicates in the update UI map
+				if(i != j)
+					ATLASSERT(m_arrUIMap[j].m_nID != m_arrUIMap[i].m_nID);
+			}
+		}
+#endif // _DEBUG
+
+		// Set internal data pointers to point to the new data arrays
+		m_pUIMap = m_arrUIMap.m_aT;
+		m_pUIData = m_arrUIData.m_aT;
+	}
+
+	~CDynamicUpdateUI()
+	{
+		for(int i = 0; i < m_arrUIData.GetSize(); i++)
+		{
+			if((m_arrUIData[i].m_wState & UPDUI_TEXT) != 0)
+				delete [] m_arrUIData[i].m_lpstrText;
+		}
+
+		// Reset internal data pointers (memory will be released by CSimpleArray d-tor)
+		m_pUIMap = NULL;
+		m_pUIData = NULL;
+	}
+
+// Methods for dynamically adding and removing update elements
+	bool UIAddUpdateElement(WORD nID, WORD wType)
+	{
+		// check for duplicates
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			// shouldn't have duplicates in the update UI map
+			ATLASSERT(m_arrUIMap[i].m_nID != nID);
+			if(m_arrUIMap[i].m_nID == nID)
+				return false;
+		}
+
+		bool bRetVal = false;
+
+		// Add new end element
+		_AtlUpdateUIMap uumEnd = { (WORD)-1, 0 };
+		BOOL bRet = m_arrUIMap.Add(uumEnd);
+		ATLASSERT(bRet);
+
+		if(bRet != FALSE)
+		{
+			_AtlUpdateUIData uud = { 0, NULL };
+			bRet = m_arrUIData.Add(uud);
+			ATLASSERT(bRet);
+
+			// Set new data to the previous end element
+			if(bRet != FALSE)
+			{
+				int nSize = m_arrUIMap.GetSize();
+				_AtlUpdateUIMap uum = { nID, wType };
+				m_arrUIMap.SetAtIndex(nSize - 2, uum);
+				m_arrUIData.SetAtIndex(nSize - 2, uud);
+
+				// Set internal data pointers again, just in case that memory moved
+				m_pUIMap = m_arrUIMap.m_aT;
+				m_pUIData = m_arrUIData.m_aT;
+
+				bRetVal = true;
+			}
+		}
+
+		return bRetVal;
+	}
+
+	bool UIRemoveUpdateElement(WORD nID)
+	{
+		bool bRetVal = false;
+
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			if(m_arrUIMap[i].m_nID == nID)
+			{
+				BOOL bRet = m_arrUIMap.RemoveAt(i);
+				ATLASSERT(bRet);
+				bRet = m_arrUIData.RemoveAt(i);
+				ATLASSERT(bRet);
+
+				bRetVal = true;
+				break;
+			}
+		}
+
+		return bRetVal;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAutoUpdateUI : Automatic mapping of UI elements
+
+template <class T>
+class CAutoUpdateUI : public CDynamicUpdateUI<T>
+{
+public:
+	LPCTSTR UIGetText(int nID)
+	{
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			if(m_arrUIMap[i].m_nID == nID)
+ 				return m_arrUIData[i].m_lpstrText;
+		}
+
+		return NULL;
+	}
+
+// Element
+	template <WORD t_wType>
+	bool UIAddElement(UINT nID)
+	{
+		// check for existing UI map element
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			if(m_arrUIMap[i].m_nID == nID)
+			{
+				// set requested type
+				m_arrUIMap[i].m_wType |= t_wType;
+				return true;
+			}
+		}
+
+		// Add element to UI map with requested type
+		return UIAddUpdateElement((WORD)nID, t_wType);
+	}
+
+	template <WORD t_wType>
+	bool UIRemoveElement(UINT nID)
+	{
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			if(m_arrUIMap[i].m_nID == nID) // matching UI map element
+			{
+				WORD wType = m_arrUIMap[i].m_wType & ~t_wType;
+				if (wType) // has other types 
+				{
+					m_arrUIMap[i].m_wType = wType; // keep other types
+					return true;
+				}
+				else
+				{
+					return UIRemoveUpdateElement((WORD)nID);
+				}
+			}
+		}
+
+		return false;
+	}
+
+// Menu
+	bool UIAddMenu(HMENU hMenu, bool bSetText = false)
+	{
+#if defined(_WIN32_WCE) && (_ATL_VER >= 0x0800)
+		using ATL::GetMenuString;
+#endif
+		ATLASSERT(::IsMenu(hMenu));
+		MENUITEMINFO mii = {sizeof(MENUITEMINFO), MIIM_TYPE | MIIM_ID | MIIM_SUBMENU};
+
+		// Complete the UI map
+		for (INT uItem = 0; CMenuHandle(hMenu).GetMenuItemInfo(uItem, TRUE, &mii); uItem++)
+		{
+			if(mii.hSubMenu)
+			{
+				// Add submenu to UI map
+				UIAddMenu(mii.hSubMenu, bSetText);
+			}
+			else if (mii.wID)
+			{
+				// Add element to UI map
+				UIAddElement<UPDUI_MENUPOPUP>(mii.wID);
+#if !defined(_WIN32_WCE) || (_ATL_VER >= 0x0800)
+				if (bSetText)
+				{
+					TCHAR sText[64] = { 0 };
+					if (GetMenuString(hMenu, uItem, sText, 64, MF_BYPOSITION))
+						UISetText(mii.wID, sText);
+				}
+#else
+				bSetText;
+#endif // !defined(_WIN32_WCE) || (_ATL_VER >= 0x0800)
+			}
+		}
+
+		return true;
+	}
+
+	bool UIAddMenu(UINT uID, bool bSetText = false)
+	{
+		CMenu menu;
+		ATLVERIFY(menu.LoadMenu(uID));
+		return UIAddMenu(menu, bSetText);
+	}
+
+// ToolBar
+#ifndef BTNS_SEP
+  #define BTNS_SEP TBSTYLE_SEP
+#endif // BTNS_SEP compatibility
+
+#if !defined(_WIN32_WCE) || (defined(_AUTOUI_CE_TOOLBAR) && defined(TBIF_BYINDEX))
+	bool UIAddToolBar(HWND hWndToolBar)
+	{
+		ATLASSERT(::IsWindow(hWndToolBar));
+		TBBUTTONINFO tbbi = {sizeof TBBUTTONINFO, TBIF_COMMAND | TBIF_STYLE | TBIF_BYINDEX};
+
+		// Add toolbar buttons
+		for (int uItem = 0; ::SendMessage(hWndToolBar, TB_GETBUTTONINFO, uItem, (LPARAM)&tbbi) != -1; uItem++)
+		{
+			if (tbbi.fsStyle ^ BTNS_SEP)
+				UIAddElement<UPDUI_TOOLBAR>(tbbi.idCommand);
+		}
+
+		// Add embedded controls if any
+		if (::GetWindow(hWndToolBar, GW_CHILD))
+			UIAddChildWindowContainer(hWndToolBar);
+
+		return (CUpdateUIBase::UIAddToolBar(hWndToolBar) != FALSE);
+	}
+#endif // !defined(_WIN32_WCE) || (defined(_AUTOUI_CE_TOOLBAR) && defined(TBIF_BYINDEX))
+
+// Container
+	bool UIAddChildWindowContainer(HWND hWnd)
+	{
+		ATLASSERT(::IsWindow(hWnd));
+
+		// Add children controls if any
+		for (ATL::CWindow wCtl = ::GetWindow(hWnd, GW_CHILD); wCtl.IsWindow(); wCtl = wCtl.GetWindow(GW_HWNDNEXT))
+		{
+			if (int id = wCtl.GetDlgCtrlID())
+				UIAddElement<UPDUI_CHILDWINDOW>(id);
+		}
+
+		return (CUpdateUIBase::UIAddChildWindowContainer(hWnd) != FALSE);
+	}
+
+// StatusBar
+	BOOL UIUpdateStatusBar(BOOL bForceUpdate = FALSE)
+	{
+		if(!(m_wDirtyType & UPDUI_STATUSBAR) && !bForceUpdate)
+			return TRUE;
+
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			for(int e = 0; e < m_UIElements.GetSize(); e++)
+			{
+				if((m_UIElements[e].m_wType == UPDUI_STATUSBAR) && 
+				   (m_arrUIMap[i].m_wType & UPDUI_STATUSBAR) && 
+				   (m_arrUIData[i].m_wState & UPDUI_STATUSBAR))
+				{
+					UIUpdateStatusBarElement(m_arrUIMap[i].m_nID, &m_arrUIData[i], m_UIElements[e].m_hWnd);
+					m_arrUIData[i].m_wState &= ~UPDUI_STATUSBAR;
+					if(m_arrUIData[i].m_wState & UPDUI_TEXT)
+						m_arrUIData[i].m_wState &= ~UPDUI_TEXT;
+				}
+			}
+		}
+
+		m_wDirtyType &= ~UPDUI_STATUSBAR;
+		return TRUE;
+	}
+
+	bool UIAddStatusBar(HWND hWndStatusBar, INT nPanes = 1)
+	{
+		ATLASSERT(::IsWindow(hWndStatusBar));
+
+		// Add StatusBar panes
+		for (int iPane = 0; iPane < nPanes; iPane++)
+			UIAddElement<UPDUI_STATUSBAR>(ID_DEFAULT_PANE + iPane);
+
+		return (CUpdateUIBase::UIAddStatusBar(hWndStatusBar) != FALSE);
+	}
+
+// UI Map used if derived class has none
+	BEGIN_UPDATE_UI_MAP(CAutoUpdateUI)
+	END_UPDATE_UI_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDialogResize - provides support for resizing dialog controls
+//                 (works for any window that has child controls)
+
+// Put CDialogResize in the list of base classes for a dialog (or even plain window),
+// then implement DLGRESIZE map by specifying controls and groups of control
+// and using DLSZ_* values to specify how are they supposed to be resized.
+//
+// Notes:
+// - Resizeable border (WS_THICKFRAME style) should be set in the dialog template
+//   for top level dialogs (popup or overlapped), so that users can resize the dialog.
+// - Some flags cannot be combined; for instance DLSZ_CENTER_X overrides DLSZ_SIZE_X,
+//   DLSZ_SIZE_X overrides DLSZ_MOVE_X. X and Y flags can be combined.
+// - Order of controls is important - group controls are resized and moved based
+//   on the position of the previous control in a group.
+
+// dialog resize map macros
+#define BEGIN_DLGRESIZE_MAP(thisClass) \
+	static const _AtlDlgResizeMap* GetDlgResizeMap() \
+	{ \
+		static const _AtlDlgResizeMap theMap[] = \
+		{
+
+#define END_DLGRESIZE_MAP() \
+			{ -1, 0 }, \
+		}; \
+		return theMap; \
+	}
+
+#define DLGRESIZE_CONTROL(id, flags) \
+		{ id, flags },
+
+#define BEGIN_DLGRESIZE_GROUP() \
+		{ -1, _DLSZ_BEGIN_GROUP },
+
+#define END_DLGRESIZE_GROUP() \
+		{ -1, _DLSZ_END_GROUP },
+
+
+template <class T>
+class CDialogResize
+{
+public:
+// Data declarations and members
+	enum
+	{
+		DLSZ_SIZE_X		= 0x00000001,
+		DLSZ_SIZE_Y		= 0x00000002,
+		DLSZ_MOVE_X		= 0x00000004,
+		DLSZ_MOVE_Y		= 0x00000008,
+		DLSZ_REPAINT		= 0x00000010,
+		DLSZ_CENTER_X		= 0x00000020,
+		DLSZ_CENTER_Y		= 0x00000040,
+
+		// internal use only
+		_DLSZ_BEGIN_GROUP	= 0x00001000,
+		_DLSZ_END_GROUP		= 0x00002000,
+		_DLSZ_GRIPPER		= 0x00004000
+	};
+
+	struct _AtlDlgResizeMap
+	{
+		int m_nCtlID;
+		DWORD m_dwResizeFlags;
+	};
+
+	struct _AtlDlgResizeData
+	{
+		int m_nCtlID;
+		DWORD m_dwResizeFlags;
+		RECT m_rect;
+
+		int GetGroupCount() const
+		{
+			return (int)LOBYTE(HIWORD(m_dwResizeFlags));
+		}
+
+		void SetGroupCount(int nCount)
+		{
+			ATLASSERT(nCount > 0 && nCount < 256);
+			DWORD dwCount = (DWORD)MAKELONG(0, MAKEWORD(nCount, 0));
+			m_dwResizeFlags &= 0xFF00FFFF;
+			m_dwResizeFlags |= dwCount;
+		}
+
+		bool operator ==(const _AtlDlgResizeData& r) const
+		{ return (m_nCtlID == r.m_nCtlID && m_dwResizeFlags == r.m_dwResizeFlags); }
+	};
+
+	ATL::CSimpleArray<_AtlDlgResizeData> m_arrData;
+	SIZE m_sizeDialog;
+	POINT m_ptMinTrackSize;
+	bool m_bGripper;
+
+
+// Constructor
+	CDialogResize() : m_bGripper(false)
+	{
+		m_sizeDialog.cx = 0;
+		m_sizeDialog.cy = 0;
+		m_ptMinTrackSize.x = -1;
+		m_ptMinTrackSize.y = -1;
+	}
+
+// Operations
+	void DlgResize_Init(bool bAddGripper = true, bool bUseMinTrackSize = true, DWORD dwForceStyle = WS_CLIPCHILDREN)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		DWORD dwStyle = pT->GetStyle();
+
+#ifdef _DEBUG
+		// Debug only: Check if top level dialogs have a resizeable border.
+		if(((dwStyle & WS_CHILD) == 0) && ((dwStyle & WS_THICKFRAME) == 0))
+			ATLTRACE2(atlTraceUI, 0, _T("DlgResize_Init - warning: top level dialog without the WS_THICKFRAME style - user cannot resize it\n"));
+#endif // _DEBUG
+
+		// Force specified styles (default WS_CLIPCHILDREN reduces flicker)
+		if((dwStyle & dwForceStyle) != dwForceStyle)
+			pT->ModifyStyle(0, dwForceStyle);
+
+		// Adding this style removes an empty icon that dialogs with WS_THICKFRAME have.
+		// Setting icon to NULL is required when XP themes are active.
+		// Note: This will not prevent adding an icon for the dialog using SetIcon()
+		if((dwStyle & WS_CHILD) == 0)
+		{
+			pT->ModifyStyleEx(0, WS_EX_DLGMODALFRAME);
+			if(pT->GetIcon(FALSE) == NULL)
+				pT->SetIcon(NULL, FALSE);
+		}
+
+		// Cleanup in case of multiple initialization
+		// block: first check for the gripper control, destroy it if needed
+		{
+			ATL::CWindow wndGripper = pT->GetDlgItem(ATL_IDW_STATUS_BAR);
+			if(wndGripper.IsWindow() && m_arrData.GetSize() > 0 && (m_arrData[0].m_dwResizeFlags & _DLSZ_GRIPPER) != 0)
+				wndGripper.DestroyWindow();
+		}
+		// clear out everything else
+		m_arrData.RemoveAll();
+		m_sizeDialog.cx = 0;
+		m_sizeDialog.cy = 0;
+		m_ptMinTrackSize.x = -1;
+		m_ptMinTrackSize.y = -1;
+
+		// Get initial dialog client size
+		RECT rectDlg = { 0 };
+		pT->GetClientRect(&rectDlg);
+		m_sizeDialog.cx = rectDlg.right;
+		m_sizeDialog.cy = rectDlg.bottom;
+
+#ifndef _WIN32_WCE
+		// Create gripper if requested
+		m_bGripper = false;
+		if(bAddGripper)
+		{
+			// shouldn't exist already
+			ATLASSERT(!::IsWindow(pT->GetDlgItem(ATL_IDW_STATUS_BAR)));
+			if(!::IsWindow(pT->GetDlgItem(ATL_IDW_STATUS_BAR)))
+			{
+				ATL::CWindow wndGripper;
+				wndGripper.Create(_T("SCROLLBAR"), pT->m_hWnd, rectDlg, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | SBS_SIZEBOX | SBS_SIZEGRIP | SBS_SIZEBOXBOTTOMRIGHTALIGN, 0, ATL_IDW_STATUS_BAR);
+				ATLASSERT(wndGripper.IsWindow());
+				if(wndGripper.IsWindow())
+				{
+					m_bGripper = true;
+					RECT rectCtl = { 0 };
+					wndGripper.GetWindowRect(&rectCtl);
+					::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rectCtl, 2);
+					_AtlDlgResizeData data = { ATL_IDW_STATUS_BAR, DLSZ_MOVE_X | DLSZ_MOVE_Y | DLSZ_REPAINT | _DLSZ_GRIPPER, { rectCtl.left, rectCtl.top, rectCtl.right, rectCtl.bottom } };
+					m_arrData.Add(data);
+				}
+			}
+		}
+#else // CE specific
+		bAddGripper;   // avoid level 4 warning
+#endif // _WIN32_WCE
+
+		// Get min track position if requested
+		if(bUseMinTrackSize)
+		{
+			if((dwStyle & WS_CHILD) != 0)
+			{
+				RECT rect = { 0 };
+				pT->GetClientRect(&rect);
+				m_ptMinTrackSize.x = rect.right - rect.left;
+				m_ptMinTrackSize.y = rect.bottom - rect.top;
+			}
+			else
+			{
+				RECT rect = { 0 };
+				pT->GetWindowRect(&rect);
+				m_ptMinTrackSize.x = rect.right - rect.left;
+				m_ptMinTrackSize.y = rect.bottom - rect.top;
+			}
+		}
+
+		// Walk the map and initialize data
+		const _AtlDlgResizeMap* pMap = pT->GetDlgResizeMap();
+		ATLASSERT(pMap != NULL);
+		int nGroupStart = -1;
+		for(int nCount = 1; !(pMap->m_nCtlID == -1 && pMap->m_dwResizeFlags == 0); nCount++, pMap++)
+		{
+			if(pMap->m_nCtlID == -1)
+			{
+				switch(pMap->m_dwResizeFlags)
+				{
+				case _DLSZ_BEGIN_GROUP:
+					ATLASSERT(nGroupStart == -1);
+					nGroupStart = m_arrData.GetSize();
+					break;
+				case _DLSZ_END_GROUP:
+					{
+						ATLASSERT(nGroupStart != -1);
+						int nGroupCount = m_arrData.GetSize() - nGroupStart;
+						m_arrData[nGroupStart].SetGroupCount(nGroupCount);
+						nGroupStart = -1;
+					}
+					break;
+				default:
+					ATLASSERT(FALSE && _T("Invalid DLGRESIZE Map Entry"));
+					break;
+				}
+			}
+			else
+			{
+				// this ID conflicts with the default gripper one
+				ATLASSERT(m_bGripper ? (pMap->m_nCtlID != ATL_IDW_STATUS_BAR) : TRUE);
+
+				ATL::CWindow ctl = pT->GetDlgItem(pMap->m_nCtlID);
+				ATLASSERT(ctl.IsWindow());
+				RECT rectCtl = { 0 };
+				ctl.GetWindowRect(&rectCtl);
+				::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rectCtl, 2);
+
+				DWORD dwGroupFlag = (nGroupStart != -1 && m_arrData.GetSize() == nGroupStart) ? _DLSZ_BEGIN_GROUP : 0;
+				_AtlDlgResizeData data = { pMap->m_nCtlID, pMap->m_dwResizeFlags | dwGroupFlag, { rectCtl.left, rectCtl.top, rectCtl.right, rectCtl.bottom } };
+				m_arrData.Add(data);
+			}
+		}
+		ATLASSERT((nGroupStart == -1) && _T("No End Group Entry in the DLGRESIZE Map"));
+	}
+
+	void DlgResize_UpdateLayout(int cxWidth, int cyHeight)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		// Restrict minimum size if requested
+		if(((pT->GetStyle() & WS_CHILD) != 0) && m_ptMinTrackSize.x != -1 && m_ptMinTrackSize.y != -1)
+		{
+			if(cxWidth < m_ptMinTrackSize.x)
+				cxWidth = m_ptMinTrackSize.x;
+			if(cyHeight < m_ptMinTrackSize.y)
+				cyHeight = m_ptMinTrackSize.y;
+		}
+
+		BOOL bVisible = pT->IsWindowVisible();
+		if(bVisible)
+			pT->SetRedraw(FALSE);
+
+		for(int i = 0; i < m_arrData.GetSize(); i++)
+		{
+			if((m_arrData[i].m_dwResizeFlags & _DLSZ_BEGIN_GROUP) != 0)   // start of a group
+			{
+				int nGroupCount = m_arrData[i].GetGroupCount();
+				ATLASSERT(nGroupCount > 0 && i + nGroupCount - 1 < m_arrData.GetSize());
+				RECT rectGroup = m_arrData[i].m_rect;
+
+				int j = 1;
+				for(j = 1; j < nGroupCount; j++)
+				{
+					rectGroup.left = min(rectGroup.left, m_arrData[i + j].m_rect.left);
+					rectGroup.top = min(rectGroup.top, m_arrData[i + j].m_rect.top);
+					rectGroup.right = max(rectGroup.right, m_arrData[i + j].m_rect.right);
+					rectGroup.bottom = max(rectGroup.bottom, m_arrData[i + j].m_rect.bottom);
+				}
+
+				for(j = 0; j < nGroupCount; j++)
+				{
+					_AtlDlgResizeData* pDataPrev = NULL;
+					if(j > 0)
+						pDataPrev = &(m_arrData[i + j - 1]);
+					pT->DlgResize_PositionControl(cxWidth, cyHeight, rectGroup, m_arrData[i + j], true, pDataPrev);
+				}
+
+				i += nGroupCount - 1;   // increment to skip all group controls
+			}
+			else // one control entry
+			{
+				RECT rectGroup = { 0, 0, 0, 0 };
+				pT->DlgResize_PositionControl(cxWidth, cyHeight, rectGroup, m_arrData[i], false);
+			}
+		}
+
+		if(bVisible)
+			pT->SetRedraw(TRUE);
+
+		pT->RedrawWindow(NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CDialogResize)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_GETMINMAXINFO, OnGetMinMaxInfo)
+#endif // _WIN32_WCE
+	END_MSG_MAP()
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+#ifndef _WIN32_WCE
+		if(m_bGripper)
+		{
+			ATL::CWindow wndGripper = pT->GetDlgItem(ATL_IDW_STATUS_BAR);
+			if(wParam == SIZE_MAXIMIZED)
+				wndGripper.ShowWindow(SW_HIDE);
+			else if(wParam == SIZE_RESTORED)
+				wndGripper.ShowWindow(SW_SHOW);
+		}
+#endif // _WIN32_WCE
+		if(wParam != SIZE_MINIMIZED)
+		{
+			ATLASSERT(::IsWindow(pT->m_hWnd));
+			pT->DlgResize_UpdateLayout(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
+		}
+		return 0;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnGetMinMaxInfo(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		if(m_ptMinTrackSize.x != -1 && m_ptMinTrackSize.y != -1)
+		{
+			LPMINMAXINFO lpMMI = (LPMINMAXINFO)lParam;
+			lpMMI->ptMinTrackSize =  m_ptMinTrackSize;
+		}
+		return 0;
+	}
+#endif // _WIN32_WCE
+
+// Implementation
+	bool DlgResize_PositionControl(int cxWidth, int cyHeight, RECT& rectGroup, _AtlDlgResizeData& data, bool bGroup, 
+	                               _AtlDlgResizeData* pDataPrev = NULL)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		ATL::CWindow ctl;
+		RECT rectCtl = { 0 };
+
+		ctl = pT->GetDlgItem(data.m_nCtlID);
+		if(!ctl.GetWindowRect(&rectCtl))
+			return false;
+		::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rectCtl, 2);
+
+		if(bGroup)
+		{
+			if((data.m_dwResizeFlags & DLSZ_CENTER_X) != 0)
+			{
+				int cxRight = rectGroup.right + cxWidth - m_sizeDialog.cx;
+				int cxCtl = data.m_rect.right - data.m_rect.left;
+				rectCtl.left = rectGroup.left + (cxRight - rectGroup.left - cxCtl) / 2;
+				rectCtl.right = rectCtl.left + cxCtl;
+			}
+			else if((data.m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_MOVE_X)) != 0)
+			{
+				rectCtl.left = rectGroup.left + ::MulDiv(data.m_rect.left - rectGroup.left, rectGroup.right - rectGroup.left + (cxWidth - m_sizeDialog.cx), rectGroup.right - rectGroup.left);
+
+				if((data.m_dwResizeFlags & DLSZ_SIZE_X) != 0)
+				{
+					rectCtl.right = rectGroup.left + ::MulDiv(data.m_rect.right - rectGroup.left, rectGroup.right - rectGroup.left + (cxWidth - m_sizeDialog.cx), rectGroup.right - rectGroup.left);
+
+					if(pDataPrev != NULL)
+					{
+						ATL::CWindow ctlPrev = pT->GetDlgItem(pDataPrev->m_nCtlID);
+						RECT rcPrev = { 0 };
+						ctlPrev.GetWindowRect(&rcPrev);
+						::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rcPrev, 2);
+						int dxAdjust = (rectCtl.left - rcPrev.right) - (data.m_rect.left - pDataPrev->m_rect.right);
+						rcPrev.right += dxAdjust;
+						ctlPrev.SetWindowPos(NULL, &rcPrev, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
+					}
+				}
+				else
+				{
+					rectCtl.right = rectCtl.left + (data.m_rect.right - data.m_rect.left);
+				}
+			}
+
+			if((data.m_dwResizeFlags & DLSZ_CENTER_Y) != 0)
+			{
+				int cyBottom = rectGroup.bottom + cyHeight - m_sizeDialog.cy;
+				int cyCtl = data.m_rect.bottom - data.m_rect.top;
+				rectCtl.top = rectGroup.top + (cyBottom - rectGroup.top - cyCtl) / 2;
+				rectCtl.bottom = rectCtl.top + cyCtl;
+			}
+			else if((data.m_dwResizeFlags & (DLSZ_SIZE_Y | DLSZ_MOVE_Y)) != 0)
+			{
+				rectCtl.top = rectGroup.top + ::MulDiv(data.m_rect.top - rectGroup.top, rectGroup.bottom - rectGroup.top + (cyHeight - m_sizeDialog.cy), rectGroup.bottom - rectGroup.top);
+
+				if((data.m_dwResizeFlags & DLSZ_SIZE_Y) != 0)
+				{
+					rectCtl.bottom = rectGroup.top + ::MulDiv(data.m_rect.bottom - rectGroup.top, rectGroup.bottom - rectGroup.top + (cyHeight - m_sizeDialog.cy), rectGroup.bottom - rectGroup.top);
+
+					if(pDataPrev != NULL)
+					{
+						ATL::CWindow ctlPrev = pT->GetDlgItem(pDataPrev->m_nCtlID);
+						RECT rcPrev = { 0 };
+						ctlPrev.GetWindowRect(&rcPrev);
+						::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rcPrev, 2);
+						int dxAdjust = (rectCtl.top - rcPrev.bottom) - (data.m_rect.top - pDataPrev->m_rect.bottom);
+						rcPrev.bottom += dxAdjust;
+						ctlPrev.SetWindowPos(NULL, &rcPrev, SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOMOVE);
+					}
+				}
+				else
+				{
+					rectCtl.bottom = rectCtl.top + (data.m_rect.bottom - data.m_rect.top);
+				}
+			}
+		}
+		else // no group
+		{
+			if((data.m_dwResizeFlags & DLSZ_CENTER_X) != 0)
+			{
+				int cxCtl = data.m_rect.right - data.m_rect.left;
+				rectCtl.left = (cxWidth - cxCtl) / 2;
+				rectCtl.right = rectCtl.left + cxCtl;
+			}
+			else if((data.m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_MOVE_X)) != 0)
+			{
+				rectCtl.right = data.m_rect.right + (cxWidth - m_sizeDialog.cx);
+
+				if((data.m_dwResizeFlags & DLSZ_MOVE_X) != 0)
+					rectCtl.left = rectCtl.right - (data.m_rect.right - data.m_rect.left);
+			}
+
+			if((data.m_dwResizeFlags & DLSZ_CENTER_Y) != 0)
+			{
+				int cyCtl = data.m_rect.bottom - data.m_rect.top;
+				rectCtl.top = (cyHeight - cyCtl) / 2;
+				rectCtl.bottom = rectCtl.top + cyCtl;
+			}
+			else if((data.m_dwResizeFlags & (DLSZ_SIZE_Y | DLSZ_MOVE_Y)) != 0)
+			{
+				rectCtl.bottom = data.m_rect.bottom + (cyHeight - m_sizeDialog.cy);
+
+				if((data.m_dwResizeFlags & DLSZ_MOVE_Y) != 0)
+					rectCtl.top = rectCtl.bottom - (data.m_rect.bottom - data.m_rect.top);
+			}
+		}
+
+		if((data.m_dwResizeFlags & DLSZ_REPAINT) != 0)
+			ctl.Invalidate();
+
+		if((data.m_dwResizeFlags & (DLSZ_SIZE_X | DLSZ_SIZE_Y | DLSZ_MOVE_X | DLSZ_MOVE_Y | DLSZ_REPAINT | DLSZ_CENTER_X | DLSZ_CENTER_Y)) != 0)
+			ctl.SetWindowPos(NULL, &rectCtl, SWP_NOZORDER | SWP_NOACTIVATE);
+
+		return true;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDoubleBufferImpl - Provides double-buffer painting support to any window
+
+template <class T>
+class CDoubleBufferImpl
+{
+public:
+// Overrideables
+	void DoPaint(CDCHandle /*dc*/)
+	{
+		// must be implemented in a derived class
+		ATLASSERT(FALSE);
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CDoubleBufferImpl)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+#endif // !_WIN32_WCE
+	END_MSG_MAP()
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background painting needed
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		if(wParam != NULL)
+		{
+			RECT rect = { 0 };
+			pT->GetClientRect(&rect);
+			CMemoryDC dcMem((HDC)wParam, rect);
+			pT->DoPaint(dcMem.m_hDC);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			CMemoryDC dcMem(dc.m_hDC, dc.m_ps.rcPaint);
+			pT->DoPaint(dcMem.m_hDC);
+		}
+
+		return 0;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDoubleBufferWindowImpl - Implements a double-buffer painting window
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CDoubleBufferWindowImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >, public CDoubleBufferImpl< T >
+{
+public:
+	BEGIN_MSG_MAP(CDoubleBufferWindowImpl)
+		CHAIN_MSG_MAP(CDoubleBufferImpl< T >)
+	END_MSG_MAP()
+};
+
+
+// command bar support
+#if !defined(__ATLCTRLW_H__) && !defined(_WIN32_WCE)
+  #undef CBRM_GETMENU
+  #undef CBRM_TRACKPOPUPMENU
+  #undef CBRM_GETCMDBAR
+  #undef CBRPOPUPMENU
+#endif // !defined(__ATLCTRLW_H__) && !defined(_WIN32_WCE)
+
+}; // namespace WTL
+
+#endif // __ATLFRAME_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlgdi.h b/GLideN64/src/GLideNUI-wtl/WTL/atlgdi.h
new file mode 100644
index 00000000..71892d8e
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlgdi.h
@@ -0,0 +1,3891 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLGDI_H__
+#define __ATLGDI_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlgdi.h requires atlapp.h to be included first
+#endif
+
+
+// protect template members from windowsx.h macros
+#ifdef _INC_WINDOWSX
+  #undef CopyRgn
+  #undef CreateBrush
+  #undef CreatePen
+  #undef SelectBrush
+  #undef SelectPen
+  #undef SelectFont
+  #undef SelectBitmap
+#endif // _INC_WINDOWSX
+
+// required libraries
+#if !defined(_ATL_NO_MSIMG) && !defined(_WIN32_WCE)
+  #pragma comment(lib, "msimg32.lib")
+#endif // !defined(_ATL_NO_MSIMG) && !defined(_WIN32_WCE)
+#if !defined(_ATL_NO_OPENGL) && !defined(_WIN32_WCE)
+  #pragma comment(lib, "opengl32.lib")
+#endif // !defined(_ATL_NO_OPENGL) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CPenT<t_bManaged>
+// CBrushT<t_bManaged>
+// CLogFont
+// CFontT<t_bManaged>
+// CBitmapT<t_bManaged>
+// CPaletteT<t_bManaged>
+// CRgnT<t_bManaged>
+// CDCT<t_bManaged>
+// CPaintDC
+// CClientDC
+// CWindowDC
+// CMemoryDC
+// CEnhMetaFileInfo
+// CEnhMetaFileT<t_bManaged>
+// CEnhMetaFileDC
+//
+// Global functions:
+//   AtlGetBitmapResourceInfo()
+//   AtlGetBitmapResourceBitsPerPixel()
+//   AtlIsAlphaBitmapResource()
+//   AtlIsDib16()
+//   AtlGetDibColorTableSize()
+//   AtlGetDibNumColors(),
+//   AtlGetDibBitmap()
+//   AtlCopyBitmap()
+//   AtlCreatePackedDib16()
+//   AtlSetClipboardDib16()
+//   AtlGetClipboardDib()
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// Bitmap resource helpers to extract bitmap information for a bitmap resource
+
+inline LPBITMAPINFOHEADER AtlGetBitmapResourceInfo(HMODULE hModule, ATL::_U_STRINGorID image)
+{
+	HRSRC hResource = ::FindResource(hModule, image.m_lpstr, RT_BITMAP);
+	ATLASSERT(hResource != NULL);
+	HGLOBAL hGlobal = ::LoadResource(hModule, hResource);
+	ATLASSERT(hGlobal != NULL);
+	LPBITMAPINFOHEADER pBitmapInfoHeader = (LPBITMAPINFOHEADER)::LockResource(hGlobal);
+	ATLASSERT(pBitmapInfoHeader != NULL);
+	return pBitmapInfoHeader;
+}
+
+inline WORD AtlGetBitmapResourceBitsPerPixel(HMODULE hModule, ATL::_U_STRINGorID image)
+{
+	LPBITMAPINFOHEADER pBitmapInfoHeader = AtlGetBitmapResourceInfo(hModule, image);
+	ATLASSERT(pBitmapInfoHeader != NULL);
+	return pBitmapInfoHeader->biBitCount;
+}
+
+inline WORD AtlGetBitmapResourceBitsPerPixel(ATL::_U_STRINGorID image)
+{
+	return AtlGetBitmapResourceBitsPerPixel(ModuleHelper::GetResourceInstance(), image);
+}
+
+///////////////////////////////////////////////////////////////////////////////
+// 32-bit (alpha channel) bitmap resource helper
+
+// Note: 32-bit (alpha channel) images work only on Windows XP with Common Controls version 6.
+// If you want your app to work on older version of Windows, load non-alpha images if Common
+// Controls version is less than 6.
+
+inline bool AtlIsAlphaBitmapResource(ATL::_U_STRINGorID image)
+{
+	return (AtlGetBitmapResourceBitsPerPixel(image) == 32);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPen
+
+template <bool t_bManaged>
+class CPenT
+{
+public:
+// Data members
+	HPEN m_hPen;
+
+// Constructor/destructor/operators
+	CPenT(HPEN hPen = NULL) : m_hPen(hPen)
+	{ }
+
+	~CPenT()
+	{
+		if(t_bManaged && m_hPen != NULL)
+			DeleteObject();
+	}
+
+	CPenT<t_bManaged>& operator =(HPEN hPen)
+	{
+		Attach(hPen);
+		return *this;
+	}
+
+	void Attach(HPEN hPen)
+	{
+		if(t_bManaged && m_hPen != NULL && m_hPen != hPen)
+			::DeleteObject(m_hPen);
+		m_hPen = hPen;
+	}
+
+	HPEN Detach()
+	{
+		HPEN hPen = m_hPen;
+		m_hPen = NULL;
+		return hPen;
+	}
+
+	operator HPEN() const { return m_hPen; }
+
+	bool IsNull() const { return (m_hPen == NULL); }
+
+// Create methods
+	HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
+	{
+		ATLASSERT(m_hPen == NULL);
+		m_hPen = ::CreatePen(nPenStyle, nWidth, crColor);
+		return m_hPen;
+	}
+
+#ifndef _WIN32_WCE
+	HPEN CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL)
+	{
+		ATLASSERT(m_hPen == NULL);
+		m_hPen = ::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount, lpStyle);
+		return m_hPen;
+	}
+#endif // !_WIN32_WCE
+
+	HPEN CreatePenIndirect(LPLOGPEN lpLogPen)
+	{
+		ATLASSERT(m_hPen == NULL);
+		m_hPen = ::CreatePenIndirect(lpLogPen);
+		return m_hPen;
+	}
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hPen != NULL);
+		BOOL bRet = ::DeleteObject(m_hPen);
+		if(bRet)
+			m_hPen = NULL;
+		return bRet;
+	}
+
+// Attributes
+	int GetLogPen(LOGPEN* pLogPen) const
+	{
+		ATLASSERT(m_hPen != NULL);
+		return ::GetObject(m_hPen, sizeof(LOGPEN), pLogPen);
+	}
+
+	bool GetLogPen(LOGPEN& LogPen) const
+	{
+		ATLASSERT(m_hPen != NULL);
+		return (::GetObject(m_hPen, sizeof(LOGPEN), &LogPen) == sizeof(LOGPEN));
+	}
+
+#ifndef _WIN32_WCE
+	int GetExtLogPen(EXTLOGPEN* pLogPen) const
+	{
+		ATLASSERT(m_hPen != NULL);
+		return ::GetObject(m_hPen, sizeof(EXTLOGPEN), pLogPen);
+	}
+
+	bool GetExtLogPen(EXTLOGPEN& ExtLogPen) const
+	{
+		ATLASSERT(m_hPen != NULL);
+		return (::GetObject(m_hPen, sizeof(EXTLOGPEN), &ExtLogPen) == sizeof(EXTLOGPEN));
+	}
+#endif // !_WIN32_WCE
+};
+
+typedef CPenT<false>   CPenHandle;
+typedef CPenT<true>    CPen;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBrush
+
+template <bool t_bManaged>
+class CBrushT
+{
+public:
+// Data members
+	HBRUSH m_hBrush;
+
+// Constructor/destructor/operators
+	CBrushT(HBRUSH hBrush = NULL) : m_hBrush(hBrush)
+	{ }
+
+	~CBrushT()
+	{
+		if(t_bManaged && m_hBrush != NULL)
+			DeleteObject();
+	}
+
+	CBrushT<t_bManaged>& operator =(HBRUSH hBrush)
+	{
+		Attach(hBrush);
+		return *this;
+	}
+
+	void Attach(HBRUSH hBrush)
+	{
+		if(t_bManaged && m_hBrush != NULL && m_hBrush != hBrush)
+			::DeleteObject(m_hBrush);
+		m_hBrush = hBrush;
+	}
+
+	HBRUSH Detach()
+	{
+		HBRUSH hBrush = m_hBrush;
+		m_hBrush = NULL;
+		return hBrush;
+	}
+
+	operator HBRUSH() const { return m_hBrush; }
+
+	bool IsNull() const { return (m_hBrush == NULL); }
+
+// Create methods
+	HBRUSH CreateSolidBrush(COLORREF crColor)
+	{
+		ATLASSERT(m_hBrush == NULL);
+		m_hBrush = ::CreateSolidBrush(crColor);
+		return m_hBrush;
+	}
+
+#ifndef _WIN32_WCE
+	HBRUSH CreateHatchBrush(int nIndex, COLORREF crColor)
+	{
+		ATLASSERT(m_hBrush == NULL);
+		m_hBrush = ::CreateHatchBrush(nIndex, crColor);
+		return m_hBrush;
+	}
+#endif // !_WIN32_WCE
+
+#if !defined(_WIN32_WCE) || (_ATL_VER >= 0x0800)
+	HBRUSH CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
+	{
+		ATLASSERT(m_hBrush == NULL);
+#ifndef _WIN32_WCE
+		m_hBrush = ::CreateBrushIndirect(lpLogBrush);
+#else // CE specific
+		m_hBrush = ATL::CreateBrushIndirect(lpLogBrush);
+#endif // _WIN32_WCE
+		return m_hBrush;
+	}
+#endif // !defined(_WIN32_WCE) || (_ATL_VER >= 0x0800)
+
+	HBRUSH CreatePatternBrush(HBITMAP hBitmap)
+	{
+		ATLASSERT(m_hBrush == NULL);
+		m_hBrush = ::CreatePatternBrush(hBitmap);
+		return m_hBrush;
+	}
+
+	HBRUSH CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
+	{
+		ATLASSERT(hPackedDIB != NULL);
+		const void* lpPackedDIB = GlobalLock(hPackedDIB);
+		ATLASSERT(lpPackedDIB != NULL);
+		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
+		GlobalUnlock(hPackedDIB);
+		return m_hBrush;
+	}
+
+	HBRUSH CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
+	{
+		ATLASSERT(m_hBrush == NULL);
+		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
+		return m_hBrush;
+	}
+
+	HBRUSH CreateSysColorBrush(int nIndex)
+	{
+		ATLASSERT(m_hBrush == NULL);
+		m_hBrush = ::GetSysColorBrush(nIndex);
+		return m_hBrush;
+	}
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hBrush != NULL);
+		BOOL bRet = ::DeleteObject(m_hBrush);
+		if(bRet)
+			m_hBrush = NULL;
+		return bRet;
+	}
+
+// Attributes
+	int GetLogBrush(LOGBRUSH* pLogBrush) const
+	{
+		ATLASSERT(m_hBrush != NULL);
+		return ::GetObject(m_hBrush, sizeof(LOGBRUSH), pLogBrush);
+	}
+
+	bool GetLogBrush(LOGBRUSH& LogBrush) const
+	{
+		ATLASSERT(m_hBrush != NULL);
+		return (::GetObject(m_hBrush, sizeof(LOGBRUSH), &LogBrush) == sizeof(LOGBRUSH));
+	}
+};
+
+typedef CBrushT<false>   CBrushHandle;
+typedef CBrushT<true>    CBrush;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFont
+
+class CLogFont : public LOGFONT
+{
+public:
+	CLogFont()
+	{
+		memset(this, 0, sizeof(LOGFONT));
+	}
+
+	CLogFont(const LOGFONT& lf)
+	{
+		Copy(&lf);
+	}
+
+	CLogFont(HFONT hFont)
+	{
+		ATLASSERT(::GetObjectType(hFont) == OBJ_FONT);
+		::GetObject(hFont, sizeof(LOGFONT), (LOGFONT*)this);
+	}
+
+	HFONT CreateFontIndirect()
+	{
+		return ::CreateFontIndirect(this);
+	}
+
+	void SetBold()
+	{
+		lfWeight = FW_BOLD;
+	}
+
+	bool IsBold() const
+	{
+		return (lfWeight >= FW_BOLD);
+	}
+
+	void MakeBolder(int iScale = 1)
+	{
+		lfWeight += FW_BOLD * iScale;
+	}
+
+	void MakeLarger(int iScale)
+	{
+		if(lfHeight > 0)
+			lfHeight += iScale;
+		else
+			lfHeight -= iScale;
+	}
+
+	void SetHeight(LONG nPointSize, HDC hDC = NULL)
+	{
+		HDC hDC1 = (hDC != NULL) ? hDC : ::GetDC(NULL);
+		// For MM_TEXT mapping mode
+		lfHeight = -::MulDiv(nPointSize, ::GetDeviceCaps(hDC1, LOGPIXELSY), 72);
+		if(hDC == NULL)
+			::ReleaseDC(NULL, hDC1);
+	}
+
+	LONG GetHeight(HDC hDC = NULL) const
+	{
+		HDC hDC1 = (hDC != NULL) ? hDC : ::GetDC(NULL);
+		// For MM_TEXT mapping mode
+		LONG nPointSize = ::MulDiv(-lfHeight, 72, ::GetDeviceCaps(hDC1, LOGPIXELSY));
+		if(hDC == NULL)
+			::ReleaseDC(NULL, hDC1);
+
+		return nPointSize;
+	}
+
+	LONG GetDeciPointHeight(HDC hDC = NULL) const
+	{
+		HDC hDC1 = (hDC != NULL) ? hDC : ::GetDC(NULL);
+#ifndef _WIN32_WCE
+		POINT ptOrg = { 0, 0 };
+		::DPtoLP(hDC1, &ptOrg, 1);
+		POINT pt = { 0, 0 };
+		pt.y = abs(lfHeight) + ptOrg.y;
+		::LPtoDP(hDC1, &pt,1);
+		LONG nDeciPoint = ::MulDiv(pt.y, 720, ::GetDeviceCaps(hDC1, LOGPIXELSY));   // 72 points/inch, 10 decipoints/point
+#else // CE specific
+		// DP and LP are always the same on CE
+		LONG nDeciPoint = ::MulDiv(abs(lfHeight), 720, ::GetDeviceCaps(hDC1, LOGPIXELSY));   // 72 points/inch, 10 decipoints/point
+#endif // _WIN32_WCE
+		if(hDC == NULL)
+			::ReleaseDC(NULL, hDC1);
+
+		return nDeciPoint;
+	}
+
+	void SetHeightFromDeciPoint(LONG nDeciPtHeight, HDC hDC = NULL)
+	{
+		HDC hDC1 = (hDC != NULL) ? hDC : ::GetDC(NULL);
+#ifndef _WIN32_WCE
+		POINT pt = { 0, 0 };
+		pt.y = ::MulDiv(::GetDeviceCaps(hDC1, LOGPIXELSY), nDeciPtHeight, 720);   // 72 points/inch, 10 decipoints/point
+		::DPtoLP(hDC1, &pt, 1);
+		POINT ptOrg = { 0, 0 };
+		::DPtoLP(hDC1, &ptOrg, 1);
+		lfHeight = -abs(pt.y - ptOrg.y);
+#else // CE specific
+		// DP and LP are always the same on CE
+		lfHeight = -abs(::MulDiv(::GetDeviceCaps(hDC1, LOGPIXELSY), nDeciPtHeight, 720));   // 72 points/inch, 10 decipoints/point
+#endif // _WIN32_WCE
+		if(hDC == NULL)
+			::ReleaseDC(NULL, hDC1);
+	}
+
+#ifndef _WIN32_WCE
+	void SetCaptionFont()
+	{
+		NONCLIENTMETRICS ncm = { RunTimeHelper::SizeOf_NONCLIENTMETRICS() };
+		ATLVERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
+		Copy(&ncm.lfCaptionFont);
+	}
+
+	void SetMenuFont()
+	{
+		NONCLIENTMETRICS ncm = { RunTimeHelper::SizeOf_NONCLIENTMETRICS() };
+		ATLVERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
+		Copy(&ncm.lfMenuFont);
+	}
+
+	void SetStatusFont()
+	{
+		NONCLIENTMETRICS ncm = { RunTimeHelper::SizeOf_NONCLIENTMETRICS() };
+		ATLVERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
+		Copy(&ncm.lfStatusFont);
+	}
+
+	void SetMessageBoxFont()
+	{
+		NONCLIENTMETRICS ncm = { RunTimeHelper::SizeOf_NONCLIENTMETRICS() };
+		ATLVERIFY(::SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
+		Copy(&ncm.lfMessageFont);
+	}
+#endif // !_WIN32_WCE
+
+	void Copy(const LOGFONT* pLogFont)
+	{
+		ATLASSERT(pLogFont != NULL);
+		*(LOGFONT*)this = *pLogFont;
+	}
+
+	CLogFont& operator =(const CLogFont& src)
+	{
+		Copy(&src);
+		return *this;
+	}
+
+	CLogFont& operator =(const LOGFONT& src)
+	{
+		Copy(&src);
+		return *this;
+	}
+
+	CLogFont& operator =(HFONT hFont)
+	{
+		ATLASSERT(::GetObjectType(hFont) == OBJ_FONT);
+		::GetObject(hFont, sizeof(LOGFONT), (LOGFONT*)this);
+		return *this;
+	}
+
+	bool operator ==(const LOGFONT& logfont) const
+	{
+		return(logfont.lfHeight == lfHeight &&
+		       logfont.lfWidth == lfWidth &&
+		       logfont.lfEscapement == lfEscapement &&
+		       logfont.lfOrientation == lfOrientation &&
+		       logfont.lfWeight == lfWeight &&
+		       logfont.lfItalic == lfItalic &&
+		       logfont.lfUnderline == lfUnderline &&
+		       logfont.lfStrikeOut == lfStrikeOut &&
+		       logfont.lfCharSet == lfCharSet &&
+		       logfont.lfOutPrecision == lfOutPrecision &&
+		       logfont.lfClipPrecision == lfClipPrecision &&
+		       logfont.lfQuality == lfQuality &&
+		       logfont.lfPitchAndFamily == lfPitchAndFamily &&
+		       lstrcmp(logfont.lfFaceName, lfFaceName) == 0);
+	}
+};
+
+
+template <bool t_bManaged>
+class CFontT
+{
+public:
+// Data members
+	HFONT m_hFont;
+
+// Constructor/destructor/operators
+	CFontT(HFONT hFont = NULL) : m_hFont(hFont)
+	{ }
+
+	~CFontT()
+	{
+		if(t_bManaged && m_hFont != NULL)
+			DeleteObject();
+	}
+
+	CFontT<t_bManaged>& operator =(HFONT hFont)
+	{
+		Attach(hFont);
+		return *this;
+	}
+
+	void Attach(HFONT hFont)
+	{
+		if(t_bManaged && m_hFont != NULL && m_hFont != hFont)
+			::DeleteObject(m_hFont);
+		m_hFont = hFont;
+	}
+
+	HFONT Detach()
+	{
+		HFONT hFont = m_hFont;
+		m_hFont = NULL;
+		return hFont;
+	}
+
+	operator HFONT() const { return m_hFont; }
+
+	bool IsNull() const { return (m_hFont == NULL); }
+
+// Create methods
+	HFONT CreateFontIndirect(const LOGFONT* lpLogFont)
+	{
+		ATLASSERT(m_hFont == NULL);
+		m_hFont = ::CreateFontIndirect(lpLogFont);
+		return m_hFont;
+	}
+
+#if !defined(_WIN32_WCE) && (_WIN32_WINNT >= 0x0500)
+	HFONT CreateFontIndirectEx(CONST ENUMLOGFONTEXDV* penumlfex)
+	{
+		ATLASSERT(m_hFont == NULL);
+		m_hFont = ::CreateFontIndirectEx(penumlfex);
+		return m_hFont;
+	}
+#endif // !defined(_WIN32_WCE) && (_WIN32_WINNT >= 0x0500)
+
+#if !defined(_WIN32_WCE) || (_ATL_VER >= 0x0800)
+	HFONT CreateFont(int nHeight, int nWidth, int nEscapement,
+			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
+			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
+			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
+			LPCTSTR lpszFacename)
+	{
+		ATLASSERT(m_hFont == NULL);
+#ifndef _WIN32_WCE
+		m_hFont = ::CreateFont(nHeight, nWidth, nEscapement,
+			nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
+			nCharSet, nOutPrecision, nClipPrecision, nQuality,
+			nPitchAndFamily, lpszFacename);
+#else // CE specific
+		m_hFont = ATL::CreateFont(nHeight, nWidth, nEscapement,
+			nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
+			nCharSet, nOutPrecision, nClipPrecision, nQuality,
+			nPitchAndFamily, lpszFacename);
+#endif // _WIN32_WCE
+		return m_hFont;
+	}
+#endif // !defined(_WIN32_WCE) || (_ATL_VER >= 0x0800)
+
+	HFONT CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, HDC hDC = NULL, bool bBold = false, bool bItalic = false)
+	{
+		LOGFONT logFont = { 0 };
+		logFont.lfCharSet = DEFAULT_CHARSET;
+		logFont.lfHeight = nPointSize;
+		SecureHelper::strncpy_x(logFont.lfFaceName, _countof(logFont.lfFaceName), lpszFaceName, _TRUNCATE);
+
+		if(bBold)
+			logFont.lfWeight = FW_BOLD;
+		if(bItalic)
+			logFont.lfItalic = (BYTE)TRUE;
+
+		return CreatePointFontIndirect(&logFont, hDC);
+	}
+
+	HFONT CreatePointFontIndirect(const LOGFONT* lpLogFont, HDC hDC = NULL)
+	{
+		HDC hDC1 = (hDC != NULL) ? hDC : ::GetDC(NULL);
+
+		// convert nPointSize to logical units based on hDC
+		LOGFONT logFont = *lpLogFont;
+#ifndef _WIN32_WCE
+		POINT pt = { 0, 0 };
+		pt.y = ::MulDiv(::GetDeviceCaps(hDC1, LOGPIXELSY), logFont.lfHeight, 720);   // 72 points/inch, 10 decipoints/point
+		::DPtoLP(hDC1, &pt, 1);
+		POINT ptOrg = { 0, 0 };
+		::DPtoLP(hDC1, &ptOrg, 1);
+		logFont.lfHeight = -abs(pt.y - ptOrg.y);
+#else // CE specific
+		// DP and LP are always the same on CE
+		logFont.lfHeight = -abs(::MulDiv(::GetDeviceCaps(hDC1, LOGPIXELSY), logFont.lfHeight, 720));   // 72 points/inch, 10 decipoints/point
+#endif // _WIN32_WCE
+
+		if(hDC == NULL)
+			::ReleaseDC(NULL, hDC1);
+
+		return CreateFontIndirect(&logFont);
+	}
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hFont != NULL);
+		BOOL bRet = ::DeleteObject(m_hFont);
+		if(bRet)
+			m_hFont = NULL;
+		return bRet;
+	}
+
+// Attributes
+	int GetLogFont(LOGFONT* pLogFont) const
+	{
+		ATLASSERT(m_hFont != NULL);
+		return ::GetObject(m_hFont, sizeof(LOGFONT), pLogFont);
+	}
+
+	bool GetLogFont(LOGFONT& LogFont) const
+	{
+		ATLASSERT(m_hFont != NULL);
+		return (::GetObject(m_hFont, sizeof(LOGFONT), &LogFont) == sizeof(LOGFONT));
+	}
+};
+
+typedef CFontT<false>   CFontHandle;
+typedef CFontT<true>    CFont;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBitmap
+
+template <bool t_bManaged>
+class CBitmapT
+{
+public:
+// Data members
+	HBITMAP m_hBitmap;
+
+// Constructor/destructor/operators
+	CBitmapT(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
+	{ }
+
+	~CBitmapT()
+	{
+		if(t_bManaged && m_hBitmap != NULL)
+			DeleteObject();
+	}
+
+	CBitmapT<t_bManaged>& operator =(HBITMAP hBitmap)
+	{
+		Attach(hBitmap);
+		return *this;
+	}
+
+	void Attach(HBITMAP hBitmap)
+	{
+		if(t_bManaged && m_hBitmap != NULL&& m_hBitmap != hBitmap)
+			::DeleteObject(m_hBitmap);
+		m_hBitmap = hBitmap;
+	}
+
+	HBITMAP Detach()
+	{
+		HBITMAP hBitmap = m_hBitmap;
+		m_hBitmap = NULL;
+		return hBitmap;
+	}
+
+	operator HBITMAP() const { return m_hBitmap; }
+
+	bool IsNull() const { return (m_hBitmap == NULL); }
+
+// Create and load methods
+	HBITMAP LoadBitmap(ATL::_U_STRINGorID bitmap)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::LoadBitmap(ModuleHelper::GetResourceInstance(), bitmap.m_lpstr);
+		return m_hBitmap;
+	}
+
+	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
+		return m_hBitmap;
+	}
+
+#ifndef _WIN32_WCE
+	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateMappedBitmap(ModuleHelper::GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
+		return m_hBitmap;
+	}
+#endif // !_WIN32_WCE
+
+	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitsPerPixel, const void* lpBits)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitsPerPixel, lpBits);
+		return m_hBitmap;
+	}
+
+#ifndef _WIN32_WCE
+	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
+		return m_hBitmap;
+	}
+#endif // !_WIN32_WCE
+
+	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
+		return m_hBitmap;
+	}
+
+#ifndef _WIN32_WCE
+	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
+		return m_hBitmap;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		BOOL bRet = ::DeleteObject(m_hBitmap);
+		if(bRet)
+			m_hBitmap = NULL;
+		return bRet;
+	}
+
+// Attributes
+	int GetBitmap(BITMAP* pBitMap) const
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
+	}
+
+	bool GetBitmap(BITMAP& bm) const
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return (::GetObject(m_hBitmap, sizeof(BITMAP), &bm) == sizeof(BITMAP));
+	}
+
+	bool GetSize(SIZE& size) const
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		BITMAP bm = { 0 };
+		if(!GetBitmap(&bm))
+			return false;
+		size.cx = bm.bmWidth;
+		size.cy = bm.bmHeight;
+		return true;
+	}
+
+#ifndef _WIN32_WCE
+	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
+	}
+#endif // !_WIN32_WCE
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 410)
+	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 410)
+
+#ifndef _WIN32_WCE
+	BOOL GetBitmapDimension(LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
+	}
+
+	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
+	}
+
+// DIB support
+	HBITMAP CreateDIBitmap(HDC hDC, CONST BITMAPINFOHEADER* lpbmih, DWORD dwInit, CONST VOID* lpbInit, CONST BITMAPINFO* lpbmi, UINT uColorUse)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateDIBitmap(hDC, lpbmih, dwInit, lpbInit, lpbmi, uColorUse);
+		return m_hBitmap;
+	}
+#endif // !_WIN32_WCE
+
+	HBITMAP CreateDIBSection(HDC hDC, CONST BITMAPINFO* lpbmi, UINT uColorUse, VOID** ppvBits, HANDLE hSection, DWORD dwOffset)
+	{
+		ATLASSERT(m_hBitmap == NULL);
+		m_hBitmap = ::CreateDIBSection(hDC, lpbmi, uColorUse, ppvBits, hSection, dwOffset);
+		return m_hBitmap;
+	}
+
+#ifndef _WIN32_WCE
+	int GetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines,  LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT uColorUse) const
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::GetDIBits(hDC, m_hBitmap, uStartScan, cScanLines,  lpvBits, lpbmi, uColorUse);
+	}
+
+	int SetDIBits(HDC hDC, UINT uStartScan, UINT cScanLines, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse)
+	{
+		ATLASSERT(m_hBitmap != NULL);
+		return ::SetDIBits(hDC, m_hBitmap, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);
+	}
+#endif // !_WIN32_WCE
+};
+
+typedef CBitmapT<false>   CBitmapHandle;
+typedef CBitmapT<true>    CBitmap;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPalette
+
+template <bool t_bManaged>
+class CPaletteT
+{
+public:
+// Data members
+	HPALETTE m_hPalette;
+
+// Constructor/destructor/operators
+	CPaletteT(HPALETTE hPalette = NULL) : m_hPalette(hPalette)
+	{ }
+
+	~CPaletteT()
+	{
+		if(t_bManaged && m_hPalette != NULL)
+			DeleteObject();
+	}
+
+	CPaletteT<t_bManaged>& operator =(HPALETTE hPalette)
+	{
+		Attach(hPalette);
+		return *this;
+	}
+
+	void Attach(HPALETTE hPalette)
+	{
+		if(t_bManaged && m_hPalette != NULL && m_hPalette != hPalette)
+			::DeleteObject(m_hPalette);
+		m_hPalette = hPalette;
+	}
+
+	HPALETTE Detach()
+	{
+		HPALETTE hPalette = m_hPalette;
+		m_hPalette = NULL;
+		return hPalette;
+	}
+
+	operator HPALETTE() const { return m_hPalette; }
+
+	bool IsNull() const { return (m_hPalette == NULL); }
+
+// Create methods
+	HPALETTE CreatePalette(LPLOGPALETTE lpLogPalette)
+	{
+		ATLASSERT(m_hPalette == NULL);
+		m_hPalette = ::CreatePalette(lpLogPalette);
+		return m_hPalette;
+	}
+
+#ifndef _WIN32_WCE
+	HPALETTE CreateHalftonePalette(HDC hDC)
+	{
+		ATLASSERT(m_hPalette == NULL);
+		ATLASSERT(hDC != NULL);
+		m_hPalette = ::CreateHalftonePalette(hDC);
+		return m_hPalette;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hPalette != NULL);
+		BOOL bRet = ::DeleteObject(m_hPalette);
+		if(bRet)
+			m_hPalette = NULL;
+		return bRet;
+	}
+
+// Attributes
+	int GetEntryCount() const
+	{
+		ATLASSERT(m_hPalette != NULL);
+		WORD nEntries = 0;
+		::GetObject(m_hPalette, sizeof(WORD), &nEntries);
+		return (int)nEntries;
+	}
+
+	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const
+	{
+		ATLASSERT(m_hPalette != NULL);
+		return ::GetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
+	}
+
+	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
+	{
+		ATLASSERT(m_hPalette != NULL);
+		return ::SetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
+	}
+
+// Operations
+#ifndef _WIN32_WCE
+	void AnimatePalette(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
+	{
+		ATLASSERT(m_hPalette != NULL);
+		::AnimatePalette(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
+	}
+
+	BOOL ResizePalette(UINT nNumEntries)
+	{
+		ATLASSERT(m_hPalette != NULL);
+		return ::ResizePalette(m_hPalette, nNumEntries);
+	}
+#endif // !_WIN32_WCE
+
+	UINT GetNearestPaletteIndex(COLORREF crColor) const
+	{
+		ATLASSERT(m_hPalette != NULL);
+		return ::GetNearestPaletteIndex(m_hPalette, crColor);
+	}
+};
+
+typedef CPaletteT<false>   CPaletteHandle;
+typedef CPaletteT<true>    CPalette;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRgn
+
+template <bool t_bManaged>
+class CRgnT
+{
+public:
+// Data members
+	HRGN m_hRgn;
+
+// Constructor/destructor/operators
+	CRgnT(HRGN hRgn = NULL) : m_hRgn(hRgn)
+	{ }
+
+	~CRgnT()
+	{
+		if(t_bManaged && m_hRgn != NULL)
+			DeleteObject();
+	}
+
+	CRgnT<t_bManaged>& operator =(HRGN hRgn)
+	{
+		Attach(hRgn);
+		return *this;
+	}
+
+	void Attach(HRGN hRgn)
+	{
+		if(t_bManaged && m_hRgn != NULL && m_hRgn != hRgn)
+			::DeleteObject(m_hRgn);
+		m_hRgn = hRgn;
+	}
+
+	HRGN Detach()
+	{
+		HRGN hRgn = m_hRgn;
+		m_hRgn = NULL;
+		return hRgn;
+	}
+
+	operator HRGN() const { return m_hRgn; }
+
+	bool IsNull() const { return (m_hRgn == NULL); }
+
+// Create methods
+	HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreateRectRgn(x1, y1, x2, y2);
+		return m_hRgn;
+	}
+
+	HRGN CreateRectRgnIndirect(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreateRectRgnIndirect(lpRect);
+		return m_hRgn;
+	}
+
+#ifndef _WIN32_WCE
+	HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreateEllipticRgn(x1, y1, x2, y2);
+		return m_hRgn;
+	}
+
+	HRGN CreateEllipticRgnIndirect(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreateEllipticRgnIndirect(lpRect);
+		return m_hRgn;
+	}
+
+	HRGN CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreatePolygonRgn(lpPoints, nCount, nMode);
+		return m_hRgn;
+	}
+
+	HRGN CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode);
+		return m_hRgn;
+	}
+
+	HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
+		return m_hRgn;
+	}
+
+	HRGN CreateFromPath(HDC hDC)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		ATLASSERT(hDC != NULL);
+		m_hRgn = ::PathToRegion(hDC);
+		return m_hRgn;
+	}
+
+	HRGN CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
+	{
+		ATLASSERT(m_hRgn == NULL);
+		m_hRgn = ::ExtCreateRegion(lpXForm, nCount, pRgnData);
+		return m_hRgn;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hRgn != NULL);
+		BOOL bRet = ::DeleteObject(m_hRgn);
+		if(bRet)
+			m_hRgn = NULL;
+		return bRet;
+	}
+
+// Operations
+	void SetRectRgn(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		::SetRectRgn(m_hRgn, x1, y1, x2, y2);
+	}
+
+	void SetRectRgn(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		::SetRectRgn(m_hRgn, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
+	}
+
+	int CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, int nCombineMode)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::CombineRgn(m_hRgn, hRgnSrc1, hRgnSrc2, nCombineMode);
+	}
+
+	int CombineRgn(HRGN hRgnSrc, int nCombineMode)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::CombineRgn(m_hRgn, m_hRgn, hRgnSrc, nCombineMode);
+	}
+
+	int CopyRgn(HRGN hRgnSrc)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::CombineRgn(m_hRgn, hRgnSrc, NULL, RGN_COPY);
+	}
+
+	BOOL EqualRgn(HRGN hRgn) const
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::EqualRgn(m_hRgn, hRgn);
+	}
+
+	int OffsetRgn(int x, int y)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::OffsetRgn(m_hRgn, x, y);
+	}
+
+	int OffsetRgn(POINT point)
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::OffsetRgn(m_hRgn, point.x, point.y);
+	}
+
+	int GetRgnBox(LPRECT lpRect) const
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::GetRgnBox(m_hRgn, lpRect);
+	}
+
+	BOOL PtInRegion(int x, int y) const
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::PtInRegion(m_hRgn, x, y);
+	}
+
+	BOOL PtInRegion(POINT point) const
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::PtInRegion(m_hRgn, point.x, point.y);
+	}
+
+	BOOL RectInRegion(LPCRECT lpRect) const
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return ::RectInRegion(m_hRgn, lpRect);
+	}
+
+	int GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
+	{
+		ATLASSERT(m_hRgn != NULL);
+		return (int)::GetRegionData(m_hRgn, nDataSize, lpRgnData);
+	}
+};
+
+typedef CRgnT<false>   CRgnHandle;
+typedef CRgnT<true>    CRgn;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDC - The device context class
+
+template <bool t_bManaged>
+class CDCT
+{
+public:
+// Data members
+	HDC m_hDC;
+
+// Constructor/destructor/operators
+	CDCT(HDC hDC = NULL) : m_hDC(hDC)
+	{
+	}
+
+	~CDCT()
+	{
+		if(t_bManaged && m_hDC != NULL)
+			::DeleteDC(Detach());
+	}
+
+	CDCT<t_bManaged>& operator =(HDC hDC)
+	{
+		Attach(hDC);
+		return *this;
+	}
+
+	void Attach(HDC hDC)
+	{
+		if(t_bManaged && m_hDC != NULL && m_hDC != hDC)
+			::DeleteDC(m_hDC);
+		m_hDC = hDC;
+	}
+
+	HDC Detach()
+	{
+		HDC hDC = m_hDC;
+		m_hDC = NULL;
+		return hDC;
+	}
+
+	operator HDC() const { return m_hDC; }
+
+	bool IsNull() const { return (m_hDC == NULL); }
+
+// Operations
+#ifndef _WIN32_WCE
+	HWND WindowFromDC() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::WindowFromDC(m_hDC);
+	}
+#endif // !_WIN32_WCE
+
+	CPenHandle GetCurrentPen() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return CPenHandle((HPEN)::GetCurrentObject(m_hDC, OBJ_PEN));
+	}
+
+	CBrushHandle GetCurrentBrush() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return CBrushHandle((HBRUSH)::GetCurrentObject(m_hDC, OBJ_BRUSH));
+	}
+
+	CPaletteHandle GetCurrentPalette() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return CPaletteHandle((HPALETTE)::GetCurrentObject(m_hDC, OBJ_PAL));
+	}
+
+	CFontHandle GetCurrentFont() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return CFontHandle((HFONT)::GetCurrentObject(m_hDC, OBJ_FONT));
+	}
+
+	CBitmapHandle GetCurrentBitmap() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return CBitmapHandle((HBITMAP)::GetCurrentObject(m_hDC, OBJ_BITMAP));
+	}
+
+	HDC CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName, LPCTSTR lpszOutput, const DEVMODE* lpInitData)
+	{
+		ATLASSERT(m_hDC == NULL);
+		m_hDC = ::CreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData);
+		return m_hDC;
+	}
+
+	HDC CreateCompatibleDC(HDC hDC = NULL)
+	{
+		ATLASSERT(m_hDC == NULL);
+		m_hDC = ::CreateCompatibleDC(hDC);
+		return m_hDC;
+	}
+
+	BOOL DeleteDC()
+	{
+		if(m_hDC == NULL)
+			return FALSE;
+		BOOL bRet = ::DeleteDC(m_hDC);
+		if(bRet)
+			m_hDC = NULL;
+		return bRet;
+	}
+
+// Device-Context Functions
+	int SaveDC()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SaveDC(m_hDC);
+	}
+
+	BOOL RestoreDC(int nSavedDC)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::RestoreDC(m_hDC, nSavedDC);
+	}
+
+	int GetDeviceCaps(int nIndex) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetDeviceCaps(m_hDC, nIndex);
+	}
+
+#ifndef _WIN32_WCE
+	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetBoundsRect(m_hDC, lpRectBounds, flags);
+	}
+
+	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetBoundsRect(m_hDC, lpRectBounds, flags);
+	}
+
+	BOOL ResetDC(const DEVMODE* lpDevMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ResetDC(m_hDC, lpDevMode) != NULL;
+	}
+
+// Drawing-Tool Functions
+	BOOL GetBrushOrg(LPPOINT lpPoint) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetBrushOrgEx(m_hDC, lpPoint);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL SetBrushOrg(int x, int y, LPPOINT lpPoint = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetBrushOrgEx(m_hDC, x, y, lpPoint);
+	}
+
+	BOOL SetBrushOrg(POINT point, LPPOINT lpPointRet = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetBrushOrgEx(m_hDC, point.x, point.y, lpPointRet);
+	}
+
+#ifndef _WIN32_WCE
+	int EnumObjects(int nObjectType, int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
+	{
+		ATLASSERT(m_hDC != NULL);
+#ifdef STRICT
+		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, lpData);
+#else
+		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, (LPVOID)lpData);
+#endif
+	}
+#endif // !_WIN32_WCE
+
+// Type-safe selection helpers
+	HPEN SelectPen(HPEN hPen)
+	{
+		ATLASSERT(m_hDC != NULL);
+#ifndef _WIN32_WCE
+		ATLASSERT(hPen == NULL || ::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN);
+#else // CE specific
+		ATLASSERT(hPen == NULL || ::GetObjectType(hPen) == OBJ_PEN);
+#endif // _WIN32_WCE
+		return (HPEN)::SelectObject(m_hDC, hPen);
+	}
+
+	HBRUSH SelectBrush(HBRUSH hBrush)
+	{
+		ATLASSERT(m_hDC != NULL);
+		ATLASSERT(hBrush == NULL || ::GetObjectType(hBrush) == OBJ_BRUSH);
+		return (HBRUSH)::SelectObject(m_hDC, hBrush);
+	}
+
+	HFONT SelectFont(HFONT hFont)
+	{
+		ATLASSERT(m_hDC != NULL);
+		ATLASSERT(hFont == NULL || ::GetObjectType(hFont) == OBJ_FONT);
+		return (HFONT)::SelectObject(m_hDC, hFont);
+	}
+
+	HBITMAP SelectBitmap(HBITMAP hBitmap)
+	{
+		ATLASSERT(m_hDC != NULL);
+		ATLASSERT(hBitmap == NULL || ::GetObjectType(hBitmap) == OBJ_BITMAP);
+		return (HBITMAP)::SelectObject(m_hDC, hBitmap);
+	}
+
+	int SelectRgn(HRGN hRgn)       // special return for regions
+	{
+		ATLASSERT(m_hDC != NULL);
+		ATLASSERT(hRgn == NULL || ::GetObjectType(hRgn) == OBJ_REGION);
+		return PtrToInt(::SelectObject(m_hDC, hRgn));
+	}
+
+// Type-safe selection helpers for stock objects
+	HPEN SelectStockPen(int nPen)
+	{
+		ATLASSERT(m_hDC != NULL);
+#if (_WIN32_WINNT >= 0x0500)
+		ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN || nPen == DC_PEN);
+#else
+		ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN);
+#endif // !(_WIN32_WINNT >= 0x0500)
+		return SelectPen((HPEN)::GetStockObject(nPen));
+	}
+
+	HBRUSH SelectStockBrush(int nBrush)
+	{
+#if (_WIN32_WINNT >= 0x0500)
+		ATLASSERT((nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH) || nBrush == DC_BRUSH);
+#else
+		ATLASSERT(nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH);
+#endif // !(_WIN32_WINNT >= 0x0500)
+		return SelectBrush((HBRUSH)::GetStockObject(nBrush));
+	}
+
+	HFONT SelectStockFont(int nFont)
+	{
+#ifndef _WIN32_WCE
+		ATLASSERT((nFont >= OEM_FIXED_FONT && nFont <= SYSTEM_FIXED_FONT) || nFont == DEFAULT_GUI_FONT);
+#else // CE specific
+		ATLASSERT(nFont == SYSTEM_FONT);
+#endif // _WIN32_WCE
+		return SelectFont((HFONT)::GetStockObject(nFont));
+	}
+
+	HPALETTE SelectStockPalette(int nPalette, BOOL bForceBackground)
+	{
+		ATLASSERT(nPalette == DEFAULT_PALETTE); // the only one supported
+		return SelectPalette((HPALETTE)::GetStockObject(nPalette), bForceBackground);
+	}
+
+// Color and Color Palette Functions
+	COLORREF GetNearestColor(COLORREF crColor) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetNearestColor(m_hDC, crColor);
+	}
+
+	HPALETTE SelectPalette(HPALETTE hPalette, BOOL bForceBackground)
+	{
+		ATLASSERT(m_hDC != NULL);
+
+		return ::SelectPalette(m_hDC, hPalette, bForceBackground);
+	}
+
+	UINT RealizePalette()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::RealizePalette(m_hDC);
+	}
+
+#ifndef _WIN32_WCE
+	void UpdateColors()
+	{
+		ATLASSERT(m_hDC != NULL);
+		::UpdateColors(m_hDC);
+	}
+#endif // !_WIN32_WCE
+
+// Drawing-Attribute Functions
+	COLORREF GetBkColor() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetBkColor(m_hDC);
+	}
+
+	int GetBkMode() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetBkMode(m_hDC);
+	}
+
+#ifndef _WIN32_WCE
+	int GetPolyFillMode() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetPolyFillMode(m_hDC);
+	}
+
+	int GetROP2() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetROP2(m_hDC);
+	}
+
+	int GetStretchBltMode() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetStretchBltMode(m_hDC);
+	}
+#endif // !_WIN32_WCE
+
+	COLORREF GetTextColor() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextColor(m_hDC);
+	}
+
+	COLORREF SetBkColor(COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetBkColor(m_hDC, crColor);
+	}
+
+	int SetBkMode(int nBkMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetBkMode(m_hDC, nBkMode);
+	}
+
+#ifndef _WIN32_WCE
+	int SetPolyFillMode(int nPolyFillMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetPolyFillMode(m_hDC, nPolyFillMode);
+	}
+#endif // !_WIN32_WCE
+
+	int SetROP2(int nDrawMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetROP2(m_hDC, nDrawMode);
+	}
+
+#ifndef _WIN32_WCE
+	int SetStretchBltMode(int nStretchMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetStretchBltMode(m_hDC, nStretchMode);
+	}
+#endif // !_WIN32_WCE
+
+	COLORREF SetTextColor(COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetTextColor(m_hDC, crColor);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetColorAdjustment(m_hDC, lpColorAdjust);
+	}
+
+	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetColorAdjustment(m_hDC, lpColorAdjust);
+	}
+
+// Mapping Functions
+	int GetMapMode() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetMapMode(m_hDC);
+	}
+
+	BOOL GetViewportOrg(LPPOINT lpPoint) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetViewportOrgEx(m_hDC, lpPoint);
+	}
+
+	int SetMapMode(int nMapMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetMapMode(m_hDC, nMapMode);
+	}
+#endif // !_WIN32_WCE
+
+	// Viewport Origin
+	BOOL SetViewportOrg(int x, int y, LPPOINT lpPoint = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetViewportOrgEx(m_hDC, x, y, lpPoint);
+	}
+
+	BOOL SetViewportOrg(POINT point, LPPOINT lpPointRet = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return SetViewportOrg(point.x, point.y, lpPointRet);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL OffsetViewportOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, lpPoint);
+	}
+
+	// Viewport Extent
+	BOOL GetViewportExt(LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetViewportExtEx(m_hDC, lpSize);
+	}
+
+	BOOL SetViewportExt(int x, int y, LPSIZE lpSize = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetViewportExtEx(m_hDC, x, y, lpSize);
+	}
+
+	BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return SetViewportExt(size.cx, size.cy, lpSizeRet);
+	}
+
+	BOOL ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
+	}
+#endif // !_WIN32_WCE
+
+	// Window Origin
+#ifndef _WIN32_WCE
+	BOOL GetWindowOrg(LPPOINT lpPoint) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetWindowOrgEx(m_hDC, lpPoint);
+	}
+
+	BOOL SetWindowOrg(int x, int y, LPPOINT lpPoint = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetWindowOrgEx(m_hDC, x, y, lpPoint);
+	}
+
+	BOOL SetWindowOrg(POINT point, LPPOINT lpPointRet = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return SetWindowOrg(point.x, point.y, lpPointRet);
+	}
+
+	BOOL OffsetWindowOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, lpPoint);
+	}
+
+	// Window extent
+	BOOL GetWindowExt(LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetWindowExtEx(m_hDC, lpSize);
+	}
+
+	BOOL SetWindowExt(int x, int y, LPSIZE lpSize = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetWindowExtEx(m_hDC, x, y, lpSize);
+	}
+
+	BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return SetWindowExt(size.cx, size.cy, lpSizeRet);
+	}
+
+	BOOL ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
+	}
+
+// Coordinate Functions
+	BOOL DPtoLP(LPPOINT lpPoints, int nCount = 1) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DPtoLP(m_hDC, lpPoints, nCount);
+	}
+
+	BOOL DPtoLP(LPRECT lpRect) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DPtoLP(m_hDC, (LPPOINT)lpRect, 2);
+	}
+
+	BOOL DPtoLP(LPSIZE lpSize) const
+	{
+		SIZE sizeWinExt = { 0, 0 };
+		if(!GetWindowExt(&sizeWinExt))
+			return FALSE;
+		SIZE sizeVpExt = { 0, 0 };
+		if(!GetViewportExt(&sizeVpExt))
+			return FALSE;
+		lpSize->cx = ::MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
+		lpSize->cy = ::MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
+		return TRUE;
+	}
+
+	BOOL LPtoDP(LPPOINT lpPoints, int nCount = 1) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::LPtoDP(m_hDC, lpPoints, nCount);
+	}
+
+	BOOL LPtoDP(LPRECT lpRect) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::LPtoDP(m_hDC, (LPPOINT)lpRect, 2);
+	}
+
+	BOOL LPtoDP(LPSIZE lpSize) const
+	{
+		SIZE sizeWinExt = { 0, 0 };
+		if(!GetWindowExt(&sizeWinExt))
+			return FALSE;
+		SIZE sizeVpExt = { 0, 0 };
+		if(!GetViewportExt(&sizeVpExt))
+			return FALSE;
+		lpSize->cx = ::MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
+		lpSize->cy = ::MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
+		return TRUE;
+	}
+
+// Special Coordinate Functions (useful for dealing with metafiles and OLE)
+	#define HIMETRIC_INCH   2540    // HIMETRIC units per inch
+
+	void DPtoHIMETRIC(LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		int nMapMode;
+		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
+		{
+			// when using a constrained map mode, map against physical inch
+			((CDCHandle*)this)->SetMapMode(MM_HIMETRIC);
+			DPtoLP(lpSize);
+			((CDCHandle*)this)->SetMapMode(nMapMode);
+		}
+		else
+		{
+			// map against logical inch for non-constrained mapping modes
+			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
+			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
+			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
+			lpSize->cx = ::MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
+			lpSize->cy = ::MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
+		}
+	}
+
+	void HIMETRICtoDP(LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		int nMapMode;
+		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
+		{
+			// when using a constrained map mode, map against physical inch
+			((CDCHandle*)this)->SetMapMode(MM_HIMETRIC);
+			LPtoDP(lpSize);
+			((CDCHandle*)this)->SetMapMode(nMapMode);
+		}
+		else
+		{
+			// map against logical inch for non-constrained mapping modes
+			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
+			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
+			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
+			lpSize->cx = ::MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
+			lpSize->cy = ::MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
+		}
+	}
+
+	void LPtoHIMETRIC(LPSIZE lpSize) const
+	{
+		LPtoDP(lpSize);
+		DPtoHIMETRIC(lpSize);
+	}
+
+	void HIMETRICtoLP(LPSIZE lpSize) const
+	{
+		HIMETRICtoDP(lpSize);
+		DPtoLP(lpSize);
+	}
+#endif // !_WIN32_WCE
+
+// Region Functions
+	BOOL FillRgn(HRGN hRgn, HBRUSH hBrush)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FillRgn(m_hDC, hRgn, hBrush);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, int nWidth, int nHeight)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FrameRgn(m_hDC, hRgn, hBrush, nWidth, nHeight);
+	}
+
+	BOOL InvertRgn(HRGN hRgn)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::InvertRgn(m_hDC, hRgn);
+	}
+
+	BOOL PaintRgn(HRGN hRgn)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PaintRgn(m_hDC, hRgn);
+	}
+#endif // !_WIN32_WCE
+
+// Clipping Functions
+	int GetClipBox(LPRECT lpRect) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetClipBox(m_hDC, lpRect);
+	}
+
+	int GetClipRgn(CRgn& region) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(region.IsNull())
+			region.CreateRectRgn(0, 0, 0, 0);
+
+		int nRet = ::GetClipRgn(m_hDC, region);
+		if(nRet != 1)
+			region.DeleteObject();
+
+		return nRet;
+	}
+
+#ifndef _WIN32_WCE
+	BOOL PtVisible(int x, int y) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PtVisible(m_hDC, x, y);
+	}
+
+	BOOL PtVisible(POINT point) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PtVisible(m_hDC, point.x, point.y);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL RectVisible(LPCRECT lpRect) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::RectVisible(m_hDC, lpRect);
+	}
+
+	int SelectClipRgn(HRGN hRgn)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SelectClipRgn(m_hDC, (HRGN)hRgn);
+	}
+
+	int ExcludeClipRect(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
+	}
+
+	int ExcludeClipRect(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
+	}
+
+#ifndef _WIN32_WCE
+	int ExcludeUpdateRgn(HWND hWnd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ExcludeUpdateRgn(m_hDC, hWnd);
+	}
+#endif // !_WIN32_WCE
+
+	int IntersectClipRect(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
+	}
+
+	int IntersectClipRect(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
+	}
+
+#ifndef _WIN32_WCE
+	int OffsetClipRgn(int x, int y)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::OffsetClipRgn(m_hDC, x, y);
+	}
+
+	int OffsetClipRgn(SIZE size)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::OffsetClipRgn(m_hDC, size.cx, size.cy);
+	}
+
+	int SelectClipRgn(HRGN hRgn, int nMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ExtSelectClipRgn(m_hDC, hRgn, nMode);
+	}
+#endif // !_WIN32_WCE
+
+// Line-Output Functions
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+	BOOL GetCurrentPosition(LPPOINT lpPoint) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCurrentPositionEx(m_hDC, lpPoint);
+	}
+
+	BOOL MoveTo(int x, int y, LPPOINT lpPoint = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::MoveToEx(m_hDC, x, y, lpPoint);
+	}
+
+	BOOL MoveTo(POINT point, LPPOINT lpPointRet = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return MoveTo(point.x, point.y, lpPointRet);
+	}
+
+	BOOL LineTo(int x, int y)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::LineTo(m_hDC, x, y);
+	}
+
+	BOOL LineTo(POINT point)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return LineTo(point.x, point.y);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+
+#ifndef _WIN32_WCE
+	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
+	}
+
+	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Arc(m_hDC, lpRect->left, lpRect->top,
+			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
+			ptEnd.x, ptEnd.y);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL Polyline(LPPOINT lpPoints, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Polyline(m_hDC, lpPoints, nCount);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle);
+	}
+
+	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
+	}
+
+	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ArcTo(lpRect->left, lpRect->top, lpRect->right,
+		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
+	}
+
+	int GetArcDirection() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetArcDirection(m_hDC);
+	}
+
+	int SetArcDirection(int nArcDirection)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetArcDirection(m_hDC, nArcDirection);
+	}
+
+	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
+	}
+
+	BOOL PolylineTo(const POINT* lpPoints, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PolylineTo(m_hDC, lpPoints, nCount);
+	}
+
+	BOOL PolyPolyline(const POINT* lpPoints,
+		const DWORD* lpPolyPoints, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount);
+	}
+
+	BOOL PolyBezier(const POINT* lpPoints, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PolyBezier(m_hDC, lpPoints, nCount);
+	}
+
+	BOOL PolyBezierTo(const POINT* lpPoints, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PolyBezierTo(m_hDC, lpPoints, nCount);
+	}
+#endif // !_WIN32_WCE
+
+// Simple Drawing Functions
+	BOOL FillRect(LPCRECT lpRect, HBRUSH hBrush)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FillRect(m_hDC, lpRect, hBrush);
+	}
+
+	BOOL FillRect(LPCRECT lpRect, int nColorIndex)
+	{
+		ATLASSERT(m_hDC != NULL);
+#ifndef _WIN32_WCE
+		return ::FillRect(m_hDC, lpRect, (HBRUSH)LongToPtr(nColorIndex + 1));
+#else // CE specific
+		return ::FillRect(m_hDC, lpRect, ::GetSysColorBrush(nColorIndex));
+#endif // _WIN32_WCE
+	}
+
+#ifndef _WIN32_WCE
+	BOOL FrameRect(LPCRECT lpRect, HBRUSH hBrush)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FrameRect(m_hDC, lpRect, hBrush);
+	}
+#endif // !_WIN32_WCE
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 420)
+	BOOL InvertRect(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::InvertRect(m_hDC, lpRect);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 420)
+
+	BOOL DrawIcon(int x, int y, HICON hIcon)
+	{
+		ATLASSERT(m_hDC != NULL);
+#ifndef _WIN32_WCE
+		return ::DrawIcon(m_hDC, x, y, hIcon);
+#else // CE specific
+		return ::DrawIconEx(m_hDC, x, y, hIcon, 0, 0, 0, NULL, DI_NORMAL);
+#endif // _WIN32_WCE
+	}
+
+	BOOL DrawIcon(POINT point, HICON hIcon)
+	{
+		ATLASSERT(m_hDC != NULL);
+#ifndef _WIN32_WCE
+		return ::DrawIcon(m_hDC, point.x, point.y, hIcon);
+#else // CE specific
+		return ::DrawIconEx(m_hDC, point.x, point.y, hIcon, 0, 0, 0, NULL, DI_NORMAL);
+#endif // _WIN32_WCE
+	}
+
+	BOOL DrawIconEx(int x, int y, HICON hIcon, int cxWidth, int cyWidth, UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL, UINT uFlags = DI_NORMAL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawIconEx(m_hDC, x, y, hIcon, cxWidth, cyWidth, uStepIfAniCur, hbrFlickerFreeDraw, uFlags);
+	}
+
+	BOOL DrawIconEx(POINT point, HICON hIcon, SIZE size, UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL, UINT uFlags = DI_NORMAL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawIconEx(m_hDC, point.x, point.y, hIcon, size.cx, size.cy, uStepIfAniCur, hbrFlickerFreeDraw, uFlags);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_BITMAP);
+	}
+
+	BOOL DrawState(POINT pt, SIZE size, HICON hIcon, UINT nFlags, HBRUSH hBrush = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hIcon, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_ICON);
+	}
+
+	BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nFlags, BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));
+	}
+
+	BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc, LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawState(m_hDC, hBrush, lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_COMPLEX);
+	}
+#endif // !_WIN32_WCE
+
+// Ellipse and Polygon Functions
+#ifndef _WIN32_WCE
+	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
+	}
+
+	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Chord(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
+	}
+#endif // !_WIN32_WCE
+
+	void DrawFocusRect(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hDC != NULL);
+		::DrawFocusRect(m_hDC, lpRect);
+	}
+
+	BOOL Ellipse(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Ellipse(m_hDC, x1, y1, x2, y2);
+	}
+
+	BOOL Ellipse(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Ellipse(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
+	}
+
+	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Pie(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL Polygon(LPPOINT lpPoints, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Polygon(m_hDC, lpPoints, nCount);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL Rectangle(int x1, int y1, int x2, int y2)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Rectangle(m_hDC, x1, y1, x2, y2);
+	}
+
+	BOOL Rectangle(LPCRECT lpRect)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Rectangle(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
+	}
+
+	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3);
+	}
+
+	BOOL RoundRect(LPCRECT lpRect, POINT point)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::RoundRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, point.x, point.y);
+	}
+
+// Bitmap Functions
+	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop);
+	}
+
+	BOOL BitBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
+		int xSrc, int ySrc, DWORD dwRop)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::BitBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, dwRop);
+	}
+
+	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::StretchBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, dwRop);
+	}
+
+	COLORREF GetPixel(int x, int y) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetPixel(m_hDC, x, y);
+	}
+
+	COLORREF GetPixel(POINT point) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetPixel(m_hDC, point.x, point.y);
+	}
+
+	COLORREF SetPixel(int x, int y, COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetPixel(m_hDC, x, y, crColor);
+	}
+
+	COLORREF SetPixel(POINT point, COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetPixel(m_hDC, point.x, point.y, crColor);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL FloodFill(int x, int y, COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FloodFill(m_hDC, x, y, crColor);
+	}
+
+	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, HBITMAP hMaskBitmap, int xMask, int yMask, DWORD dwRop)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, int xSrc, int ySrc, int nWidth, int nHeight, HBITMAP hMaskBitmap, int xMask, int yMask)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PlgBlt(m_hDC, lpPoint, hSrcDC, xSrc, ySrc, nWidth, nHeight, hMaskBitmap, xMask, yMask);
+	}
+
+	BOOL SetPixelV(int x, int y, COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetPixelV(m_hDC, x, y, crColor);
+	}
+
+	BOOL SetPixelV(POINT point, COLORREF crColor)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetPixelV(m_hDC, point.x, point.y, crColor);
+	}
+#endif // !_WIN32_WCE
+
+#if !defined(_ATL_NO_MSIMG) || defined(_WIN32_WCE)
+#ifndef _WIN32_WCE
+	BOOL TransparentBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, UINT crTransparent)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::TransparentBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent);
+	}
+#else // CE specific
+	BOOL TransparentImage(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, UINT crTransparent)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::TransparentImage(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, crTransparent);
+	}
+#endif // _WIN32_WCE
+
+#if (!defined(_WIN32_WCE) || (_WIN32_WCE >= 420))
+	BOOL GradientFill(const PTRIVERTEX pVertices, DWORD nVertices, void* pMeshElements, DWORD nMeshElements, DWORD dwMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GradientFill(m_hDC, pVertices, nVertices, pMeshElements, nMeshElements, dwMode);
+	}
+
+	BOOL GradientFillRect(RECT& rect, COLORREF clr1, COLORREF clr2, bool bHorizontal)
+	{
+		ATLASSERT(m_hDC != NULL);
+
+		TRIVERTEX arrTvx[2] = { { 0 }, { 0 } };
+
+		arrTvx[0].x = rect.left;
+		arrTvx[0].y = rect.top;
+		arrTvx[0].Red = MAKEWORD(0, GetRValue(clr1));
+		arrTvx[0].Green = MAKEWORD(0, GetGValue(clr1));
+		arrTvx[0].Blue = MAKEWORD(0, GetBValue(clr1));
+		arrTvx[0].Alpha = 0;
+
+		arrTvx[1].x = rect.right;
+		arrTvx[1].y = rect.bottom;
+		arrTvx[1].Red = MAKEWORD(0, GetRValue(clr2));
+		arrTvx[1].Green = MAKEWORD(0, GetGValue(clr2));
+		arrTvx[1].Blue = MAKEWORD(0, GetBValue(clr2));
+		arrTvx[1].Alpha = 0;
+
+		GRADIENT_RECT gr = { 0, 1 };
+
+		return ::GradientFill(m_hDC, arrTvx, 2, &gr, 1, bHorizontal ? GRADIENT_FILL_RECT_H : GRADIENT_FILL_RECT_V);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 420)
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE > 0x500)
+	BOOL AlphaBlend(int x, int y, int nWidth, int nHeight, HDC hSrcDC, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, BLENDFUNCTION bf)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::AlphaBlend(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, bf);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE > 0x500)
+#endif //  !defined(_ATL_NO_MSIMG) || defined(_WIN32_WCE)
+
+// Extra bitmap functions
+	// Helper function for painting a disabled toolbar or menu bitmap
+	// This function can take either an HBITMAP (for SS) or a DC with 
+	//           the bitmap already painted (for cmdbar)
+	BOOL DitherBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC, HBITMAP hBitmap, int xSrc, int ySrc,
+			HBRUSH hBrushBackground = ::GetSysColorBrush(COLOR_3DFACE),
+			HBRUSH hBrush3DEffect = ::GetSysColorBrush(COLOR_3DHILIGHT),
+			HBRUSH hBrushDisabledImage = ::GetSysColorBrush(COLOR_3DSHADOW))
+	{
+		ATLASSERT(m_hDC != NULL || hBitmap != NULL);
+		ATLASSERT(nWidth > 0 && nHeight > 0);
+		
+		// Create a generic DC for all BitBlts
+		CDCHandle dc = (hSrcDC != NULL) ? hSrcDC : ::CreateCompatibleDC(m_hDC);
+		ATLASSERT(dc.m_hDC != NULL);
+		if(dc.m_hDC == NULL)
+			return FALSE;
+		
+		// Create a DC for the monochrome DIB section
+		CDC dcBW = ::CreateCompatibleDC(m_hDC);
+		ATLASSERT(dcBW.m_hDC != NULL);
+		if(dcBW.m_hDC == NULL)
+		{
+			if(hSrcDC == NULL)
+				dc.DeleteDC();
+			return FALSE;
+		}
+
+		// Create the monochrome DIB section with a black and white palette
+		struct RGBBWBITMAPINFO
+		{
+			BITMAPINFOHEADER bmiHeader; 
+			RGBQUAD bmiColors[2]; 
+		};
+
+		RGBBWBITMAPINFO rgbBWBitmapInfo = 
+		{
+			{ sizeof(BITMAPINFOHEADER), nWidth, nHeight, 1, 1, BI_RGB, 0, 0, 0, 0, 0 },
+			{ { 0x00, 0x00, 0x00, 0x00 }, { 0xFF, 0xFF, 0xFF, 0x00 } }
+		};
+
+		VOID* pbitsBW;
+		CBitmap bmpBW = ::CreateDIBSection(dcBW, (LPBITMAPINFO)&rgbBWBitmapInfo, DIB_RGB_COLORS, &pbitsBW, NULL, 0);
+		ATLASSERT(bmpBW.m_hBitmap != NULL);
+		if(bmpBW.m_hBitmap == NULL)
+		{
+			if(hSrcDC == NULL)
+				dc.DeleteDC();
+			return FALSE;
+		}
+		
+		// Attach the monochrome DIB section and the bitmap to the DCs
+		HBITMAP hbmOldBW = dcBW.SelectBitmap(bmpBW);
+		HBITMAP hbmOldDC = NULL;
+		if(hBitmap != NULL)
+			hbmOldDC = dc.SelectBitmap(hBitmap);
+
+		// Block: Dark gray removal: we want (128, 128, 128) pixels to become black and not white
+		{
+			CDC dcTemp1 = ::CreateCompatibleDC(m_hDC);
+			CDC dcTemp2 = ::CreateCompatibleDC(m_hDC);
+			CBitmap bmpTemp1;
+			bmpTemp1.CreateCompatibleBitmap(dc, nWidth, nHeight);
+			CBitmap bmpTemp2;
+			bmpTemp2.CreateBitmap(nWidth, nHeight, 1, 1, NULL);
+			HBITMAP hOldBmp1 = dcTemp1.SelectBitmap(bmpTemp1);
+			HBITMAP hOldBmp2 = dcTemp2.SelectBitmap(bmpTemp2);
+			// Let's copy our image, it will be altered
+			dcTemp1.BitBlt(0, 0, nWidth, nHeight, dc, xSrc, ySrc, SRCCOPY);
+
+			// All dark gray pixels will become white, the others black
+			dcTemp1.SetBkColor(RGB(128, 128, 128));
+			dcTemp2.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);
+			// Do an XOR to set to black these white pixels
+			dcTemp1.BitBlt(0, 0, nWidth, nHeight, dcTemp2, 0, 0, SRCINVERT);
+
+			// BitBlt the bitmap into the monochrome DIB section
+			// The DIB section will do a true monochrome conversion
+			// The magenta background being closer to white will become white
+			dcBW.BitBlt(0, 0, nWidth, nHeight, dcTemp1, 0, 0, SRCCOPY);
+
+			// Cleanup
+			dcTemp1.SelectBitmap(hOldBmp1);
+			dcTemp2.SelectBitmap(hOldBmp2);
+		}
+		
+		// Paint the destination rectangle using hBrushBackground
+		if(hBrushBackground != NULL)
+		{
+			RECT rc = { x, y, x + nWidth, y + nHeight };
+			FillRect(&rc, hBrushBackground);
+		}
+
+		// BitBlt the black bits in the monochrome bitmap into hBrush3DEffect color in the destination DC
+		// The magic ROP comes from the Charles Petzold's book
+		HBRUSH hOldBrush = SelectBrush(hBrush3DEffect);
+		BitBlt(x + 1, y + 1, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);
+
+		// BitBlt the black bits in the monochrome bitmap into hBrushDisabledImage color in the destination DC
+		SelectBrush(hBrushDisabledImage);
+		BitBlt(x, y, nWidth, nHeight, dcBW, 0, 0, 0xB8074A);
+
+		SelectBrush(hOldBrush);
+		dcBW.SelectBitmap(hbmOldBW);
+		dc.SelectBitmap(hbmOldDC);
+
+		if(hSrcDC == NULL)
+			dc.DeleteDC();
+
+		return TRUE;
+	}
+
+// Text Functions
+#ifndef _WIN32_WCE
+	BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount = -1)
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(nCount == -1)
+			nCount = lstrlen(lpszString);
+		return ::TextOut(m_hDC, x, y, lpszString, nCount);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect, LPCTSTR lpszString, UINT nCount = -1, LPINT lpDxWidths = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(nCount == -1)
+			nCount = lstrlen(lpszString);
+		return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString, nCount, lpDxWidths);
+	}
+
+#ifndef _WIN32_WCE
+	SIZE TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount = -1, int nTabPositions = 0, LPINT lpnTabStopPositions = NULL, int nTabOrigin = 0)
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(nCount == -1)
+			nCount = lstrlen(lpszString);
+		LONG lRes = ::TabbedTextOut(m_hDC, x, y, lpszString, nCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
+		SIZE size = { GET_X_LPARAM(lRes), GET_Y_LPARAM(lRes) };
+		return size;
+	}
+#endif // !_WIN32_WCE
+
+	int DrawText(LPCTSTR lpstrText, int cchText, LPRECT lpRect, UINT uFormat)
+	{
+		ATLASSERT(m_hDC != NULL);
+#ifndef _WIN32_WCE
+		ATLASSERT((uFormat & DT_MODIFYSTRING) == 0);
+#endif // !_WIN32_WCE
+		return ::DrawText(m_hDC, lpstrText, cchText, lpRect, uFormat);
+	}
+
+	int DrawText(LPTSTR lpstrText, int cchText, LPRECT lpRect, UINT uFormat)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawText(m_hDC, lpstrText, cchText, lpRect, uFormat);
+	}
+
+#ifndef _WIN32_WCE
+	int DrawTextEx(LPTSTR lpstrText, int cchText, LPRECT lpRect, UINT uFormat, LPDRAWTEXTPARAMS lpDTParams = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawTextEx(m_hDC, lpstrText, cchText, lpRect, uFormat, lpDTParams);
+	}
+#endif // !_WIN32_WCE
+
+#if (_WIN32_WINNT >= 0x0501)
+	int DrawShadowText(LPCWSTR lpstrText, int cchText, LPRECT lpRect, DWORD dwFlags, COLORREF clrText, COLORREF clrShadow, int xOffset, int yOffset)
+	{
+		ATLASSERT(m_hDC != NULL);
+		// This function is present only if comctl32.dll version 6 is loaded;
+		// we use LoadLibrary/GetProcAddress to allow apps compiled with
+		// _WIN32_WINNT >= 0x0501 to run on older Windows/CommCtrl
+		int nRet = 0;
+		HMODULE hCommCtrlDLL = ::LoadLibrary(_T("comctl32.dll"));
+		ATLASSERT(hCommCtrlDLL != NULL);
+		if(hCommCtrlDLL != NULL)
+		{
+			typedef int (WINAPI *PFN_DrawShadowText)(HDC hDC, LPCWSTR lpstrText, UINT cchText, LPRECT lpRect, DWORD dwFlags, COLORREF clrText, COLORREF clrShadow, int xOffset, int yOffset);
+			PFN_DrawShadowText pfnDrawShadowText = (PFN_DrawShadowText)::GetProcAddress(hCommCtrlDLL, "DrawShadowText");
+			ATLASSERT(pfnDrawShadowText != NULL);   // this function requires CommCtrl6
+			if(pfnDrawShadowText != NULL)
+				nRet = pfnDrawShadowText(m_hDC, lpstrText, cchText, lpRect, dwFlags, clrText, clrShadow, xOffset, yOffset);
+			::FreeLibrary(hCommCtrlDLL);
+		}
+		return nRet;
+	}
+#endif // (_WIN32_WINNT >= 0x0501)
+
+	BOOL GetTextExtent(LPCTSTR lpszString, int nCount, LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(nCount == -1)
+			nCount = lstrlen(lpszString);
+		return ::GetTextExtentPoint32(m_hDC, lpszString, nCount, lpSize);
+	}
+
+	BOOL GetTextExtentExPoint(LPCTSTR lpszString, int cchString, LPSIZE lpSize, int nMaxExtent, LPINT lpnFit = NULL, LPINT alpDx = NULL)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextExtentExPoint(m_hDC, lpszString, cchString, nMaxExtent, lpnFit, alpDx, lpSize);
+	}
+
+#ifndef _WIN32_WCE
+	DWORD GetTabbedTextExtent(LPCTSTR lpszString, int nCount = -1, int nTabPositions = 0, LPINT lpnTabStopPositions = NULL) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(nCount == -1)
+			nCount = lstrlen(lpszString);
+		return ::GetTabbedTextExtent(m_hDC, lpszString, nCount, nTabPositions, lpnTabStopPositions);
+	}
+
+	BOOL GrayString(HBRUSH hBrush, BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData, int nCount, int x, int y, int nWidth, int nHeight)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GrayString(m_hDC, hBrush, (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight);
+	}
+#endif // !_WIN32_WCE
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+	UINT GetTextAlign() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextAlign(m_hDC);
+	}
+
+	UINT SetTextAlign(UINT nFlags)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetTextAlign(m_hDC, nFlags);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+
+	int GetTextFace(LPTSTR lpszFacename, int nCount) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextFace(m_hDC, nCount, lpszFacename);
+	}
+
+	int GetTextFaceLen() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextFace(m_hDC, 0, NULL);
+	}
+
+#ifndef _ATL_NO_COM
+#ifdef _OLEAUTO_H_
+	BOOL GetTextFace(BSTR& bstrFace) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(m_hDC != NULL);
+		ATLASSERT(bstrFace == NULL);
+
+		int nLen = GetTextFaceLen();
+		if(nLen == 0)
+			return FALSE;
+
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpszText = buff.Allocate(nLen);
+		if(lpszText == NULL)
+			return FALSE;
+
+		if(!GetTextFace(lpszText, nLen))
+			return FALSE;
+
+		bstrFace = ::SysAllocString(T2OLE(lpszText));
+		return (bstrFace != NULL) ? TRUE : FALSE;
+	}
+#endif
+#endif // !_ATL_NO_COM
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetTextFace(_CSTRING_NS::CString& strFace) const
+	{
+		ATLASSERT(m_hDC != NULL);
+
+		int nLen = GetTextFaceLen();
+		if(nLen == 0)
+			return 0;
+
+		LPTSTR lpstr = strFace.GetBufferSetLength(nLen);
+		if(lpstr == NULL)
+			return 0;
+		int nRet = GetTextFace(lpstr, nLen);
+		strFace.ReleaseBuffer();
+		return nRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextMetrics(m_hDC, lpMetrics);
+	}
+
+#ifndef _WIN32_WCE
+	int SetTextJustification(int nBreakExtra, int nBreakCount)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
+	}
+
+	int GetTextCharacterExtra() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextCharacterExtra(m_hDC);
+	}
+
+	int SetTextCharacterExtra(int nCharExtra)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetTextCharacterExtra(m_hDC, nCharExtra);
+	}
+#endif // !_WIN32_WCE
+
+// Advanced Drawing
+	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags);
+	}
+
+	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawFrameControl(m_hDC, lpRect, nType, nState);
+	}
+
+// Scrolling Functions
+	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip, HRGN hRgnUpdate, LPRECT lpRectUpdate)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ScrollDC(m_hDC, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);
+	}
+
+// Font Functions
+#ifndef _WIN32_WCE
+	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer);
+	}
+
+	// GetCharWidth32 is not supported under Win9x
+	BOOL GetCharWidth32(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharWidth32(m_hDC, nFirstChar, nLastChar, lpBuffer);
+	}
+
+	DWORD SetMapperFlags(DWORD dwFlag)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetMapperFlags(m_hDC, dwFlag);
+	}
+
+	BOOL GetAspectRatioFilter(LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetAspectRatioFilterEx(m_hDC, lpSize);
+	}
+
+	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharABCWidths(m_hDC, nFirstChar, nLastChar, lpabc);
+	}
+
+	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetFontData(m_hDC, dwTable, dwOffset, lpData, cbData);
+	}
+
+	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetKerningPairs(m_hDC, nPairs, lpkrnpair);
+	}
+
+	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetOutlineTextMetrics(m_hDC, cbData, lpotm);
+	}
+
+	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm, DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetGlyphOutline(m_hDC, nChar, nFormat, lpgm, cbBuffer, lpBuffer, lpmat2);
+	}
+
+	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABCFLOAT lpABCF) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharABCWidthsFloat(m_hDC, nFirstChar, nLastChar, lpABCF);
+	}
+
+	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, float* lpFloatBuffer) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharWidthFloat(m_hDC, nFirstChar, nLastChar, lpFloatBuffer);
+	}
+#endif // !_WIN32_WCE
+
+// Printer/Device Escape Functions
+#ifndef _WIN32_WCE
+	int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);
+	}
+#endif // !_WIN32_WCE
+
+	int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
+		int nOutputSize, LPSTR lpszOutputData)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);
+	}
+
+#ifndef _WIN32_WCE
+	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData);
+	}
+#endif // !_WIN32_WCE
+
+	// Escape helpers
+#if !defined(_WIN32_WCE) || ((_WIN32_WCE >= 200) && defined(StartDoc))
+	int StartDoc(LPCTSTR lpszDocName)  // old Win3.0 version
+	{
+		DOCINFO di = { 0 };
+		di.cbSize = sizeof(DOCINFO);
+		di.lpszDocName = lpszDocName;
+		return StartDoc(&di);
+	}
+
+	int StartDoc(LPDOCINFO lpDocInfo)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::StartDoc(m_hDC, lpDocInfo);
+	}
+
+	int StartPage()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::StartPage(m_hDC);
+	}
+
+	int EndPage()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::EndPage(m_hDC);
+	}
+
+	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn);
+	}
+
+	int AbortDoc()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::AbortDoc(m_hDC);
+	}
+
+	int EndDoc()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::EndDoc(m_hDC);
+	}
+#endif // !defined(_WIN32_WCE) || ((_WIN32_WCE >= 200) && defined(StartDoc))
+
+// MetaFile Functions
+#ifndef _WIN32_WCE
+	BOOL PlayMetaFile(HMETAFILE hMF)
+	{
+		ATLASSERT(m_hDC != NULL);
+		if(::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
+		{
+			// playing metafile in metafile, just use core windows API
+			return ::PlayMetaFile(m_hDC, hMF);
+		}
+
+		// for special playback, lParam == pDC
+		return ::EnumMetaFile(m_hDC, hMF, EnumMetaFileProc, (LPARAM)this);
+	}
+
+	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::PlayEnhMetaFile(m_hDC, hEnhMetaFile, lpBounds);
+	}
+
+	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData) // can be used for enhanced metafiles only
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GdiComment(m_hDC, nDataSize, pCommentData);
+	}
+
+	// Special handling for metafile playback
+	static int CALLBACK EnumMetaFileProc(HDC hDC, HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
+	{
+		CDCHandle* pDC = (CDCHandle*)lParam;
+
+		switch (pMetaRec->rdFunction)
+		{
+		case META_SETMAPMODE:
+			pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SETWINDOWEXT:
+			pDC->SetWindowExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SETWINDOWORG:
+			pDC->SetWindowOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SETVIEWPORTEXT:
+			pDC->SetViewportExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SETVIEWPORTORG:
+			pDC->SetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SCALEWINDOWEXT:
+			pDC->ScaleWindowExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2], 
+				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SCALEVIEWPORTEXT:
+			pDC->ScaleViewportExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
+				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_OFFSETVIEWPORTORG:
+			pDC->OffsetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SAVEDC:
+			pDC->SaveDC();
+			break;
+		case META_RESTOREDC:
+			pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
+			break;
+		case META_SETBKCOLOR:
+			pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
+			break;
+		case META_SETTEXTCOLOR:
+			pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
+			break;
+
+		// need to watch out for SelectObject(HFONT), for custom font mapping
+		case META_SELECTOBJECT:
+			{
+				HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
+				UINT nObjType = ::GetObjectType(hObject);
+				if(nObjType == 0)
+				{
+					// object type is unknown, determine if it is a font
+					HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
+					HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
+					HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
+					if(hObjOld == hStockFont)
+					{
+						// got the stock object back, so must be selecting a font
+						pDC->SelectFont((HFONT)hObject);
+						break;  // don't play the default record
+					}
+					else
+					{
+						// didn't get the stock object back, so restore everything
+						::SelectObject(pDC->m_hDC, hFontOld);
+						::SelectObject(pDC->m_hDC, hObjOld);
+					}
+					// and fall through to PlayMetaFileRecord...
+				}
+				else if(nObjType == OBJ_FONT)
+				{
+					// play back as CDCHandle::SelectFont(HFONT)
+					pDC->SelectFont((HFONT)hObject);
+					break;  // don't play the default record
+				}
+			}
+			// fall through...
+
+		default:
+			::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
+			break;
+		}
+
+		return 1;
+	}
+#endif // !_WIN32_WCE
+
+// Path Functions
+#ifndef _WIN32_WCE
+	BOOL AbortPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::AbortPath(m_hDC);
+	}
+
+	BOOL BeginPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::BeginPath(m_hDC);
+	}
+
+	BOOL CloseFigure()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::CloseFigure(m_hDC);
+	}
+
+	BOOL EndPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::EndPath(m_hDC);
+	}
+
+	BOOL FillPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FillPath(m_hDC);
+	}
+
+	BOOL FlattenPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::FlattenPath(m_hDC);
+	}
+
+	BOOL StrokeAndFillPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::StrokeAndFillPath(m_hDC);
+	}
+
+	BOOL StrokePath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::StrokePath(m_hDC);
+	}
+
+	BOOL WidenPath()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::WidenPath(m_hDC);
+	}
+
+	BOOL GetMiterLimit(PFLOAT pfMiterLimit) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetMiterLimit(m_hDC, pfMiterLimit);
+	}
+
+	BOOL SetMiterLimit(float fMiterLimit)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetMiterLimit(m_hDC, fMiterLimit, NULL);
+	}
+
+	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetPath(m_hDC, lpPoints, lpTypes, nCount);
+	}
+
+	BOOL SelectClipPath(int nMode)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SelectClipPath(m_hDC, nMode);
+	}
+#endif // !_WIN32_WCE
+
+// Misc Helper Functions
+	static CBrushHandle PASCAL GetHalftoneBrush()
+	{
+		HBRUSH halftoneBrush = NULL;
+		WORD grayPattern[8];
+		for(int i = 0; i < 8; i++)
+			grayPattern[i] = (WORD)(0x5555 << (i & 1));
+		HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, &grayPattern);
+		if(grayBitmap != NULL)
+		{
+			halftoneBrush = ::CreatePatternBrush(grayBitmap);
+			DeleteObject(grayBitmap);
+		}
+		return CBrushHandle(halftoneBrush);
+	}
+
+	void DrawDragRect(LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast, HBRUSH hBrush = NULL, HBRUSH hBrushLast = NULL)
+	{
+		// first, determine the update region and select it
+		CRgn rgnOutside;
+		rgnOutside.CreateRectRgnIndirect(lpRect);
+		RECT rect = *lpRect;
+		::InflateRect(&rect, -size.cx, -size.cy);
+		::IntersectRect(&rect, &rect, lpRect);
+		CRgn rgnInside;
+		rgnInside.CreateRectRgnIndirect(&rect);
+		CRgn rgnNew;
+		rgnNew.CreateRectRgn(0, 0, 0, 0);
+		rgnNew.CombineRgn(rgnOutside, rgnInside, RGN_XOR);
+
+		HBRUSH hBrushOld = NULL;
+		CBrush brushHalftone;
+		if(hBrush == NULL)
+			brushHalftone = hBrush = CDCHandle::GetHalftoneBrush();
+		if(hBrushLast == NULL)
+			hBrushLast = hBrush;
+
+		CRgn rgnLast;
+		CRgn rgnUpdate;
+		if(lpRectLast != NULL)
+		{
+			// find difference between new region and old region
+			rgnLast.CreateRectRgn(0, 0, 0, 0);
+			rgnOutside.SetRectRgn(lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
+			rect = *lpRectLast;
+			::InflateRect(&rect, -sizeLast.cx, -sizeLast.cy);
+			::IntersectRect(&rect, &rect, lpRectLast);
+			rgnInside.SetRectRgn(rect.left, rect.top, rect.right, rect.bottom);
+			rgnLast.CombineRgn(rgnOutside, rgnInside, RGN_XOR);
+
+			// only diff them if brushes are the same
+			if(hBrush == hBrushLast)
+			{
+				rgnUpdate.CreateRectRgn(0, 0, 0, 0);
+				rgnUpdate.CombineRgn(rgnLast, rgnNew, RGN_XOR);
+			}
+		}
+		if(hBrush != hBrushLast && lpRectLast != NULL)
+		{
+			// brushes are different -- erase old region first
+			SelectClipRgn(rgnLast);
+			GetClipBox(&rect);
+			hBrushOld = SelectBrush(hBrushLast);
+			PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
+			SelectBrush(hBrushOld);
+			hBrushOld = NULL;
+		}
+
+		// draw into the update/new region
+		SelectClipRgn(rgnUpdate.IsNull() ? rgnNew : rgnUpdate);
+		GetClipBox(&rect);
+		hBrushOld = SelectBrush(hBrush);
+		PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
+
+		// cleanup DC
+		if(hBrushOld != NULL)
+			SelectBrush(hBrushOld);
+		SelectClipRgn(NULL);
+	}
+
+	void FillSolidRect(LPCRECT lpRect, COLORREF clr)
+	{
+		ATLASSERT(m_hDC != NULL);
+
+		COLORREF clrOld = ::SetBkColor(m_hDC, clr);
+		ATLASSERT(clrOld != CLR_INVALID);
+		if(clrOld != CLR_INVALID)
+		{
+			::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
+			::SetBkColor(m_hDC, clrOld);
+		}
+	}
+
+	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
+	{
+		ATLASSERT(m_hDC != NULL);
+
+		RECT rect = { x, y, x + cx, y + cy };
+		FillSolidRect(&rect, clr);
+	}
+
+	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight)
+	{
+		Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
+			lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
+	}
+
+	void Draw3dRect(int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight)
+	{
+		FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
+		FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
+		FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
+		FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
+	}
+
+// DIB support
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 410)
+	int SetDIBitsToDevice(int x, int y, DWORD dwWidth, DWORD dwHeight, int xSrc, int ySrc, UINT uStartScan, UINT cScanLines, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetDIBitsToDevice(m_hDC, x, y, dwWidth, dwHeight, xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, uColorUse);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 410)
+
+#if !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+	int StretchDIBits(int x, int y, int nWidth, int nHeight, int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, CONST VOID* lpvBits, CONST BITMAPINFO* lpbmi, UINT uColorUse, DWORD dwRop)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::StretchDIBits(m_hDC, x, y, nWidth, nHeight, xSrc, ySrc, nSrcWidth, nSrcHeight, lpvBits, lpbmi, uColorUse, dwRop);
+	}
+
+	UINT GetDIBColorTable(UINT uStartIndex, UINT cEntries, RGBQUAD* pColors) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetDIBColorTable(m_hDC, uStartIndex, cEntries, pColors);
+	}
+
+	UINT SetDIBColorTable(UINT uStartIndex, UINT cEntries, CONST RGBQUAD* pColors)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetDIBColorTable(m_hDC, uStartIndex, cEntries, pColors);
+	}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 400)
+
+// OpenGL support
+#if !defined(_ATL_NO_OPENGL) && !defined(_WIN32_WCE)
+	int ChoosePixelFormat(CONST PIXELFORMATDESCRIPTOR* ppfd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ChoosePixelFormat(m_hDC, ppfd);
+	}
+
+	int DescribePixelFormat(int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::DescribePixelFormat(m_hDC, iPixelFormat, nBytes, ppfd);
+	}
+
+	int GetPixelFormat() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetPixelFormat(m_hDC);
+	}
+
+	BOOL SetPixelFormat(int iPixelFormat, CONST PIXELFORMATDESCRIPTOR* ppfd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetPixelFormat(m_hDC, iPixelFormat, ppfd);
+	}
+
+	BOOL SwapBuffers()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SwapBuffers(m_hDC);
+	}
+
+	HGLRC wglCreateContext()
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglCreateContext(m_hDC);
+	}
+
+	HGLRC wglCreateLayerContext(int iLayerPlane)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglCreateLayerContext(m_hDC, iLayerPlane);
+	}
+
+	BOOL wglMakeCurrent(HGLRC hglrc)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglMakeCurrent(m_hDC, hglrc);
+	}
+
+	BOOL wglUseFontBitmaps(DWORD dwFirst, DWORD dwCount, DWORD listBase)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglUseFontBitmaps(m_hDC, dwFirst, dwCount, listBase);
+	}
+
+	BOOL wglUseFontOutlines(DWORD dwFirst, DWORD dwCount, DWORD listBase, FLOAT deviation, FLOAT extrusion, int format, LPGLYPHMETRICSFLOAT lpgmf)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglUseFontOutlines(m_hDC, dwFirst, dwCount, listBase, deviation, extrusion, format, lpgmf);
+	}
+
+	BOOL wglDescribeLayerPlane(int iPixelFormat, int iLayerPlane, UINT nBytes, LPLAYERPLANEDESCRIPTOR plpd)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglDescribeLayerPlane(m_hDC, iPixelFormat, iLayerPlane, nBytes, plpd);
+	}
+
+	int wglSetLayerPaletteEntries(int iLayerPlane, int iStart, int cEntries, CONST COLORREF* pclr)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglSetLayerPaletteEntries(m_hDC, iLayerPlane, iStart, cEntries, pclr);
+	}
+
+	int wglGetLayerPaletteEntries(int iLayerPlane, int iStart, int cEntries, COLORREF* pclr)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglGetLayerPaletteEntries(m_hDC, iLayerPlane, iStart, cEntries, pclr);
+	}
+
+	BOOL wglRealizeLayerPalette(int iLayerPlane, BOOL bRealize)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglRealizeLayerPalette(m_hDC, iLayerPlane, bRealize);
+	}
+
+	BOOL wglSwapLayerBuffers(UINT uPlanes)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::wglSwapLayerBuffers(m_hDC, uPlanes);
+	}
+#endif // !defined(_ATL_NO_OPENGL) && !defined(_WIN32_WCE)
+
+// New for Windows 2000 only
+#if (_WIN32_WINNT >= 0x0500)
+	COLORREF GetDCPenColor() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetDCPenColor(m_hDC);
+	}
+
+	COLORREF SetDCPenColor(COLORREF clr)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetDCPenColor(m_hDC, clr);
+	}
+
+	COLORREF GetDCBrushColor() const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetDCBrushColor(m_hDC);
+	}
+
+	COLORREF SetDCBrushColor(COLORREF clr)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::SetDCBrushColor(m_hDC, clr);
+	}
+
+#ifndef _WIN32_WCE
+	DWORD GetFontUnicodeRanges(LPGLYPHSET lpgs) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetFontUnicodeRanges(m_hDC, lpgs);
+	}
+#endif // !_WIN32_WCE
+
+	DWORD GetGlyphIndices(LPCTSTR lpstr, int cch, LPWORD pgi, DWORD dwFlags) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetGlyphIndices(m_hDC, lpstr, cch, pgi, dwFlags);
+	}
+
+	BOOL GetTextExtentPointI(LPWORD pgiIn, int cgi, LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextExtentPointI(m_hDC, pgiIn, cgi, lpSize);
+	}
+
+	BOOL GetTextExtentExPointI(LPWORD pgiIn, int cgi, int nMaxExtent, LPINT lpnFit, LPINT alpDx, LPSIZE lpSize) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetTextExtentExPointI(m_hDC, pgiIn, cgi, nMaxExtent, lpnFit, alpDx, lpSize);
+	}
+
+	BOOL GetCharWidthI(UINT giFirst, UINT cgi, LPWORD pgi, LPINT lpBuffer) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharWidthI(m_hDC, giFirst, cgi, pgi, lpBuffer);
+	}
+
+	BOOL GetCharABCWidthsI(UINT giFirst, UINT cgi, LPWORD pgi, LPABC lpabc) const
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::GetCharABCWidthsI(m_hDC, giFirst, cgi, pgi, lpabc);
+	}
+#endif // (_WIN32_WINNT >= 0x0500)
+
+// New for Windows 2000 and Windows 98
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+	BOOL ColorCorrectPalette(HPALETTE hPalette, DWORD dwFirstEntry, DWORD dwNumOfEntries)
+	{
+		ATLASSERT(m_hDC != NULL);
+		return ::ColorCorrectPalette(m_hDC, hPalette, dwFirstEntry, dwNumOfEntries);
+	}
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+};
+
+typedef CDCT<false>   CDCHandle;
+typedef CDCT<true>    CDC;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDC Helpers
+
+class CPaintDC : public CDC
+{
+public:
+// Data members
+	HWND m_hWnd;
+	PAINTSTRUCT m_ps;
+
+// Constructor/destructor
+	CPaintDC(HWND hWnd)
+	{
+		ATLASSERT(::IsWindow(hWnd));
+		m_hWnd = hWnd;
+		m_hDC = ::BeginPaint(hWnd, &m_ps);
+	}
+
+	~CPaintDC()
+	{
+		ATLASSERT(m_hDC != NULL);
+		ATLASSERT(::IsWindow(m_hWnd));
+		::EndPaint(m_hWnd, &m_ps);
+		Detach();
+	}
+};
+
+class CClientDC : public CDC
+{
+public:
+// Data members
+	HWND m_hWnd;
+
+// Constructor/destructor
+	CClientDC(HWND hWnd)
+	{
+		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
+		m_hWnd = hWnd;
+		m_hDC = ::GetDC(hWnd);
+	}
+
+	~CClientDC()
+	{
+		ATLASSERT(m_hDC != NULL);
+		::ReleaseDC(m_hWnd, Detach());
+	}
+};
+
+class CWindowDC : public CDC
+{
+public:
+// Data members
+	HWND m_hWnd;
+
+// Constructor/destructor
+	CWindowDC(HWND hWnd)
+	{
+		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
+		m_hWnd = hWnd;
+		m_hDC = ::GetWindowDC(hWnd);
+	}
+
+	~CWindowDC()
+	{
+		ATLASSERT(m_hDC != NULL);
+		::ReleaseDC(m_hWnd, Detach());
+	}
+};
+
+class CMemoryDC : public CDC
+{
+public:
+// Data members
+	HDC m_hDCOriginal;
+	RECT m_rcPaint;
+	CBitmap m_bmp;
+	HBITMAP m_hBmpOld;
+
+// Constructor/destructor
+	CMemoryDC(HDC hDC, RECT& rcPaint) : m_hDCOriginal(hDC), m_hBmpOld(NULL)
+	{
+		m_rcPaint = rcPaint;
+		CreateCompatibleDC(m_hDCOriginal);
+		ATLASSERT(m_hDC != NULL);
+		m_bmp.CreateCompatibleBitmap(m_hDCOriginal, m_rcPaint.right - m_rcPaint.left, m_rcPaint.bottom - m_rcPaint.top);
+		ATLASSERT(m_bmp.m_hBitmap != NULL);
+		m_hBmpOld = SelectBitmap(m_bmp);
+		SetViewportOrg(-m_rcPaint.left, -m_rcPaint.top);
+	}
+
+	~CMemoryDC()
+	{
+		::BitBlt(m_hDCOriginal, m_rcPaint.left, m_rcPaint.top, m_rcPaint.right - m_rcPaint.left, m_rcPaint.bottom - m_rcPaint.top, m_hDC, m_rcPaint.left, m_rcPaint.top, SRCCOPY);
+		SelectBitmap(m_hBmpOld);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Enhanced metafile support
+
+#ifndef _WIN32_WCE
+
+class CEnhMetaFileInfo
+{
+public:
+// Data members
+	HENHMETAFILE m_hEMF;
+	BYTE* m_pBits;
+	TCHAR* m_pDesc;
+	ENHMETAHEADER m_header;
+	PIXELFORMATDESCRIPTOR m_pfd;
+
+// Constructor/destructor
+	CEnhMetaFileInfo(HENHMETAFILE hEMF) : m_pBits(NULL), m_pDesc(NULL), m_hEMF(hEMF)
+	{ }
+
+	~CEnhMetaFileInfo()
+	{
+		delete [] m_pBits;
+		delete [] m_pDesc;
+	}
+
+// Operations
+	BYTE* GetEnhMetaFileBits()
+	{
+		ATLASSERT(m_hEMF != NULL);
+		UINT nBytes = ::GetEnhMetaFileBits(m_hEMF, 0, NULL);
+		delete [] m_pBits;
+		m_pBits = NULL;
+		ATLTRY(m_pBits = new BYTE[nBytes]);
+		if (m_pBits != NULL)
+			::GetEnhMetaFileBits(m_hEMF, nBytes, m_pBits);
+		return m_pBits;
+	}
+
+	LPTSTR GetEnhMetaFileDescription()
+	{
+		ATLASSERT(m_hEMF != NULL);
+		UINT nLen = ::GetEnhMetaFileDescription(m_hEMF, 0, NULL);
+		delete [] m_pDesc;
+		m_pDesc = NULL;
+		ATLTRY(m_pDesc = new TCHAR[nLen]);
+		if (m_pDesc != NULL)
+			nLen = ::GetEnhMetaFileDescription(m_hEMF, nLen, m_pDesc);
+		return m_pDesc;
+	}
+
+	ENHMETAHEADER* GetEnhMetaFileHeader()
+	{
+		ATLASSERT(m_hEMF != NULL);
+		memset(&m_header, 0, sizeof(m_header));
+		m_header.iType = EMR_HEADER;
+		m_header.nSize = sizeof(ENHMETAHEADER);
+		UINT n = ::GetEnhMetaFileHeader(m_hEMF, sizeof(ENHMETAHEADER), &m_header);
+		return (n != 0) ? &m_header : NULL;
+	}
+
+	PIXELFORMATDESCRIPTOR* GetEnhMetaFilePixelFormat()
+	{
+		ATLASSERT(m_hEMF != NULL);
+		memset(&m_pfd, 0, sizeof(m_pfd));
+		UINT n = ::GetEnhMetaFilePixelFormat(m_hEMF, sizeof(m_pfd), &m_pfd);
+		return (n != 0) ? &m_pfd : NULL;
+	}
+};
+
+
+template <bool t_bManaged>
+class CEnhMetaFileT
+{
+public:
+// Data members
+	HENHMETAFILE m_hEMF;
+
+// Constructor/destructor
+	CEnhMetaFileT(HENHMETAFILE hEMF = NULL) : m_hEMF(hEMF)
+	{
+	}
+
+	~CEnhMetaFileT()
+	{
+		if(t_bManaged && m_hEMF != NULL)
+			DeleteObject();
+	}
+
+// Operations
+	CEnhMetaFileT<t_bManaged>& operator =(HENHMETAFILE hEMF)
+	{
+		Attach(hEMF);
+		return *this;
+	}
+
+	void Attach(HENHMETAFILE hEMF)
+	{
+		if(t_bManaged && m_hEMF != NULL && m_hEMF != hEMF)
+			DeleteObject();
+		m_hEMF = hEMF;
+	}
+
+	HENHMETAFILE Detach()
+	{
+		HENHMETAFILE hEMF = m_hEMF;
+		m_hEMF = NULL;
+		return hEMF;
+	}
+
+	operator HENHMETAFILE() const { return m_hEMF; }
+
+	bool IsNull() const { return (m_hEMF == NULL); }
+
+	BOOL DeleteObject()
+	{
+		ATLASSERT(m_hEMF != NULL);
+		BOOL bRet = ::DeleteEnhMetaFile(m_hEMF);
+		m_hEMF = NULL;
+		return bRet;
+	}
+
+	UINT GetEnhMetaFileBits(UINT cbBuffer, LPBYTE lpbBuffer) const
+	{
+		ATLASSERT(m_hEMF != NULL);
+		return ::GetEnhMetaFileBits(m_hEMF, cbBuffer, lpbBuffer);
+	}
+
+	UINT GetEnhMetaFileDescription(UINT cchBuffer, LPTSTR lpszDescription) const
+	{
+		ATLASSERT(m_hEMF != NULL);
+		return ::GetEnhMetaFileDescription(m_hEMF, cchBuffer, lpszDescription);
+	}
+
+	UINT GetEnhMetaFileHeader(LPENHMETAHEADER lpemh) const
+	{
+		ATLASSERT(m_hEMF != NULL);
+		lpemh->iType = EMR_HEADER;
+		lpemh->nSize = sizeof(ENHMETAHEADER);
+		return ::GetEnhMetaFileHeader(m_hEMF, sizeof(ENHMETAHEADER), lpemh);
+	}
+
+	UINT GetEnhMetaFilePaletteEntries(UINT cEntries, LPPALETTEENTRY lppe) const
+	{
+		ATLASSERT(m_hEMF != NULL);
+		return ::GetEnhMetaFilePaletteEntries(m_hEMF, cEntries, lppe);
+	}
+
+	UINT GetEnhMetaFilePixelFormat(DWORD cbBuffer, PIXELFORMATDESCRIPTOR* ppfd) const
+	{
+		ATLASSERT(m_hEMF != NULL);
+		return ::GetEnhMetaFilePixelFormat(m_hEMF, cbBuffer, ppfd);
+	}
+};
+
+typedef CEnhMetaFileT<false>   CEnhMetaFileHandle;
+typedef CEnhMetaFileT<true>    CEnhMetaFile;
+
+
+class CEnhMetaFileDC : public CDC
+{
+public:
+// Constructor/destructor
+	CEnhMetaFileDC()
+	{
+	}
+
+	CEnhMetaFileDC(HDC hdc, LPCRECT lpRect)
+	{
+		Create(hdc, NULL, lpRect, NULL);
+		ATLASSERT(m_hDC != NULL);
+	}
+
+	CEnhMetaFileDC(HDC hdcRef, LPCTSTR lpFilename, LPCRECT lpRect, LPCTSTR lpDescription)
+	{
+		Create(hdcRef, lpFilename, lpRect, lpDescription);
+		ATLASSERT(m_hDC != NULL);
+	}
+
+	~CEnhMetaFileDC()
+	{
+		HENHMETAFILE hEMF = Close();
+		if (hEMF != NULL)
+			::DeleteEnhMetaFile(hEMF);
+	}
+
+// Operations
+	void Create(HDC hdcRef, LPCTSTR lpFilename, LPCRECT lpRect, LPCTSTR lpDescription)
+	{
+		ATLASSERT(m_hDC == NULL);
+		m_hDC = ::CreateEnhMetaFile(hdcRef, lpFilename, lpRect, lpDescription);
+	}
+
+	HENHMETAFILE Close()
+	{
+		HENHMETAFILE hEMF = NULL;
+		if (m_hDC != NULL)
+		{
+			hEMF = ::CloseEnhMetaFile(m_hDC);
+			m_hDC = NULL;
+		}
+		return hEMF;
+	}
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// WinCE compatible clipboard CF_DIB format support functions
+
+#ifndef _WTL_NO_DIB16
+
+#define DIBINFO16_BITFIELDS { 31744, 992, 31 }
+
+// DIBINFO16 - To avoid color table problems in WinCE we only create this type of Dib
+struct DIBINFO16 // a BITMAPINFO with 2 additional color bitfields
+{
+    BITMAPINFOHEADER    bmiHeader;
+    RGBQUAD             bmiColors[3];
+
+	DIBINFO16(SIZE size) 
+	{
+		BITMAPINFOHEADER bmih = { sizeof(BITMAPINFOHEADER), size.cx, size.cy, 
+		                          1, 16, BI_BITFIELDS, 2 * size.cx * size.cy , 0, 0, 3 };
+		DWORD dw[3] = DIBINFO16_BITFIELDS ;
+
+		bmiHeader = bmih;
+		SecureHelper::memcpy_x(bmiColors, sizeof(bmiColors), dw, 3 * sizeof(DWORD));
+	}
+};
+
+
+// AtlxxxDibxxx minimal packed DIB implementation and helpers to copy and paste CF_DIB
+ 
+inline bool AtlIsDib16(LPBITMAPINFOHEADER pbmih)
+{
+	return (pbmih->biBitCount == 16) && (pbmih->biCompression == BI_BITFIELDS);
+}
+
+inline int AtlGetDibColorTableSize(LPBITMAPINFOHEADER pbmih)
+{
+	switch (pbmih->biBitCount) 
+	{
+		case  2:
+		case  4:
+		case  8:
+			return pbmih->biClrUsed ? pbmih->biClrUsed : 1 << pbmih->biBitCount;
+		case 24:
+			break;
+		case 16:
+		case 32:
+			return pbmih->biCompression == BI_BITFIELDS ? 3 : 0;
+		default:
+			ATLASSERT(FALSE);   // should never come here
+	}
+
+	return 0;
+}
+
+inline int AtlGetDibNumColors(LPBITMAPINFOHEADER pbmih)
+{
+	switch (pbmih->biBitCount) 
+	{
+		case  2:
+		case  4:
+		case  8: 
+			if (pbmih->biClrUsed)
+				return pbmih->biClrUsed;
+			else
+				break;
+		case 16: 
+			if (pbmih->biCompression == BI_BITFIELDS )
+				return 1 << 15;
+			else
+				break;
+		case 24:
+			break;
+		case 32: 
+			if (pbmih->biCompression == BI_BITFIELDS )
+				return 1 << 24;
+			else
+				break;
+		default:
+			ATLASSERT(FALSE);
+	}
+
+	return 1 << pbmih->biBitCount;
+}
+
+inline HBITMAP AtlGetDibBitmap(LPBITMAPINFO pbmi)
+{
+	CDC dc(NULL);
+	void* pBits = NULL;
+
+	LPBYTE pDibBits = (LPBYTE)pbmi + sizeof(BITMAPINFOHEADER) + AtlGetDibColorTableSize(&pbmi->bmiHeader) * sizeof(RGBQUAD);
+	HBITMAP hbm = CreateDIBSection(dc, pbmi, DIB_RGB_COLORS, &pBits, NULL, NULL);
+	if (hbm != NULL)
+	{
+		int cbBits = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biHeight * pbmi->bmiHeader.biBitCount / 8;
+		SecureHelper::memcpy_x(pBits, cbBits, pDibBits, pbmi->bmiHeader.biSizeImage);
+	}
+
+	return hbm;
+}
+	
+inline HBITMAP AtlCopyBitmap(HBITMAP hbm, SIZE sizeDst, bool bAsBitmap = false)
+{
+	CDC hdcSrc = CreateCompatibleDC(NULL);
+	CDC hdcDst = CreateCompatibleDC(NULL);
+
+	CBitmapHandle hbmOld = NULL, hbmOld2 = NULL, bmSrc = hbm;
+
+	CBitmap bmNew = NULL;
+
+	SIZE sizeSrc = { 0 };
+	bmSrc.GetSize(sizeSrc);
+
+	hbmOld = hdcSrc.SelectBitmap(bmSrc);
+
+	if (bAsBitmap)
+	{
+		bmNew.CreateCompatibleBitmap(hdcSrc, sizeDst.cx, sizeDst.cy);
+	}
+	else
+	{
+		DIBINFO16 dib16(sizeDst);
+		LPVOID pBits = NULL;
+		bmNew = CreateDIBSection(hdcDst, (const BITMAPINFO*)&dib16, DIB_RGB_COLORS, &pBits, NULL, NULL);
+	}
+	
+	ATLASSERT(!bmNew.IsNull());
+
+	hbmOld2 = hdcDst.SelectBitmap(bmNew);
+	BOOL bOK = FALSE;
+
+	if ((sizeDst.cx == sizeSrc.cx) && (sizeDst.cy == sizeSrc.cy))
+		bOK = hdcDst.BitBlt(0, 0, sizeDst.cx, sizeDst.cy, hdcSrc, 0, 0, SRCCOPY);
+	else
+		bOK = hdcDst.StretchBlt(0, 0, sizeDst.cx, sizeDst.cy, hdcSrc, 0, 0, sizeSrc.cx, sizeSrc.cy, SRCCOPY);
+
+	hdcSrc.SelectBitmap(hbmOld);
+	hdcDst.SelectBitmap(hbmOld2);
+
+	if (bOK == FALSE)
+		bmNew.DeleteObject();
+
+	return bmNew.Detach();
+}
+
+inline HLOCAL AtlCreatePackedDib16(HBITMAP hbm, SIZE size)
+{
+	DIBSECTION ds = { 0 };
+	LPBYTE pDib = NULL;
+	bool bCopied = false;
+
+	bool bOK = GetObject(hbm, sizeof(ds), &ds) == sizeof(ds);
+	if ((bOK == FALSE) || (ds.dsBm.bmBits == NULL) || (AtlIsDib16(&ds.dsBmih) == FALSE) || 
+	    (ds.dsBmih.biWidth != size.cx ) || (ds.dsBmih.biHeight != size.cy ))
+	{
+		if ((hbm = AtlCopyBitmap(hbm, size)) != NULL)
+		{
+			bCopied = true;
+			bOK = GetObject(hbm, sizeof(ds), &ds) == sizeof(ds);
+		}
+		else
+		{
+			bOK = FALSE;
+		}
+	}
+
+	if((bOK != FALSE) && (AtlIsDib16(&ds.dsBmih) != FALSE) && (ds.dsBm.bmBits != NULL))
+	{
+		pDib = (LPBYTE)LocalAlloc(LMEM_ZEROINIT, sizeof(DIBINFO16) + ds.dsBmih.biSizeImage);
+		if (pDib != NULL)
+		{
+			SecureHelper::memcpy_x(pDib, sizeof(DIBINFO16) + ds.dsBmih.biSizeImage, &ds.dsBmih, sizeof(DIBINFO16));
+			SecureHelper::memcpy_x(pDib + sizeof(DIBINFO16), ds.dsBmih.biSizeImage, ds.dsBm.bmBits, ds.dsBmih.biSizeImage);
+		}
+	}
+
+	if (bCopied == true)
+		DeleteObject(hbm);
+
+	return (HLOCAL)pDib;
+}
+
+inline bool AtlSetClipboardDib16(HBITMAP hbm, SIZE size, HWND hWnd)
+{
+	ATLASSERT(::IsWindow(hWnd));
+	BOOL bOK = OpenClipboard(hWnd);
+	if (bOK != FALSE)
+	{
+		bOK = EmptyClipboard();
+		if (bOK != FALSE)
+		{
+			HLOCAL hDib = AtlCreatePackedDib16(hbm, size);
+			if (hDib != NULL)
+			{
+				bOK = SetClipboardData(CF_DIB, hDib) != NULL;
+				if (bOK == FALSE)  
+					LocalFree(hDib);
+			}
+			else
+			{
+				bOK = FALSE;
+			}
+		}
+		CloseClipboard();
+	}
+
+	return (bOK != FALSE);
+}
+
+inline HBITMAP AtlGetClipboardDib(HWND hWnd)
+{
+	ATLASSERT(::IsWindow(hWnd) != FALSE);
+	HBITMAP hbm = NULL;
+	if  (OpenClipboard(hWnd) != FALSE)
+	{
+		LPBITMAPINFO pbmi = (LPBITMAPINFO)GetClipboardData(CF_DIB);
+		if (pbmi != NULL)
+			hbm = AtlGetDibBitmap(pbmi);
+		CloseClipboard();
+	}
+
+	return hbm;
+}
+
+#endif // _WTL_NO_DIB16
+
+}; // namespace WTL
+
+#endif // __ATLGDI_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlmisc.h b/GLideN64/src/GLideNUI-wtl/WTL/atlmisc.h
new file mode 100644
index 00000000..0ee6d75a
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlmisc.h
@@ -0,0 +1,3746 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLMISC_H__
+#define __ATLMISC_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlmisc.h requires atlapp.h to be included first
+#endif
+
+
+#ifdef _ATL_TMP_NO_CSTRING
+  #define _WTL_NO_CSTRING
+#endif
+
+#if defined(_WTL_USE_CSTRING) && defined(_WTL_NO_CSTRING)
+	#error Conflicting options - both _WTL_USE_CSTRING and _WTL_NO_CSTRING are defined
+#endif // defined(_WTL_USE_CSTRING) && defined(_WTL_NO_CSTRING)
+
+#if !defined(_WTL_USE_CSTRING) && !defined(_WTL_NO_CSTRING)
+  #define _WTL_USE_CSTRING
+#endif // !defined(_WTL_USE_CSTRING) && !defined(_WTL_NO_CSTRING)
+
+#ifndef _WTL_NO_CSTRING
+  #if defined(_ATL_USE_CSTRING_FLOAT) && defined(_ATL_MIN_CRT)
+	#error Cannot use CString floating point formatting with _ATL_MIN_CRT defined
+  #endif // defined(_ATL_USE_CSTRING_FLOAT) && defined(_ATL_MIN_CRT)
+#endif // !_WTL_NO_CSTRING
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CSize
+// CPoint
+// CRect
+// CString
+//
+// CRecentDocumentListBase<T, t_cchItemLen, t_nFirstID, t_nLastID>
+// CRecentDocumentList
+// CFindFile
+//
+// Global functions:
+//   AtlGetStockPen()
+//   AtlGetStockBrush()
+//   AtlGetStockFont()
+//   AtlGetStockPalette()
+//
+//   AtlCompactPath()
+
+
+namespace WTL
+{
+
+#ifndef _WTL_NO_WTYPES
+
+// forward declarations
+class CSize;
+class CPoint;
+class CRect;
+
+///////////////////////////////////////////////////////////////////////////////
+// CSize - Wrapper for Windows SIZE structure.
+
+class CSize : public SIZE
+{
+public:
+// Constructors
+	CSize()
+	{
+		cx = 0;
+		cy = 0;
+	}
+
+	CSize(int initCX, int initCY)
+	{
+		cx = initCX;
+		cy = initCY;
+	}
+
+	CSize(SIZE initSize)
+	{
+		*(SIZE*)this = initSize;
+	}
+
+	CSize(POINT initPt)
+	{
+		*(POINT*)this = initPt;
+	}
+
+	CSize(DWORD dwSize)
+	{
+		cx = (short)LOWORD(dwSize);
+		cy = (short)HIWORD(dwSize);
+	}
+
+// Operations
+	BOOL operator ==(SIZE size) const
+	{
+		return (cx == size.cx && cy == size.cy);
+	}
+
+	BOOL operator !=(SIZE size) const
+	{
+		return (cx != size.cx || cy != size.cy);
+	}
+
+	void operator +=(SIZE size)
+	{
+		cx += size.cx;
+		cy += size.cy;
+	}
+
+	void operator -=(SIZE size)
+	{
+		cx -= size.cx;
+		cy -= size.cy;
+	}
+
+	void SetSize(int CX, int CY)
+	{
+		cx = CX;
+		cy = CY;
+	}
+
+// Operators returning CSize values
+	CSize operator +(SIZE size) const
+	{
+		return CSize(cx + size.cx, cy + size.cy);
+	}
+
+	CSize operator -(SIZE size) const
+	{
+		return CSize(cx - size.cx, cy - size.cy);
+	}
+
+	CSize operator -() const
+	{
+		return CSize(-cx, -cy);
+	}
+
+// Operators returning CPoint values
+	CPoint operator +(POINT point) const;
+	CPoint operator -(POINT point) const;
+
+// Operators returning CRect values
+	CRect operator +(const RECT* lpRect) const;
+	CRect operator -(const RECT* lpRect) const;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPoint - Wrapper for Windows POINT structure.
+
+class CPoint : public POINT
+{
+public:
+// Constructors
+	CPoint()
+	{
+		x = 0;
+		y = 0;
+	}
+
+	CPoint(int initX, int initY)
+	{
+		x = initX;
+		y = initY;
+	}
+
+	CPoint(POINT initPt)
+	{
+		*(POINT*)this = initPt;
+	}
+
+	CPoint(SIZE initSize)
+	{
+		*(SIZE*)this = initSize;
+	}
+
+	CPoint(DWORD dwPoint)
+	{
+		x = (short)LOWORD(dwPoint);
+		y = (short)HIWORD(dwPoint);
+	}
+
+// Operations
+	void Offset(int xOffset, int yOffset)
+	{
+		x += xOffset;
+		y += yOffset;
+	}
+
+	void Offset(POINT point)
+	{
+		x += point.x;
+		y += point.y;
+	}
+
+	void Offset(SIZE size)
+	{
+		x += size.cx;
+		y += size.cy;
+	}
+
+	BOOL operator ==(POINT point) const
+	{
+		return (x == point.x && y == point.y);
+	}
+
+	BOOL operator !=(POINT point) const
+	{
+		return (x != point.x || y != point.y);
+	}
+
+	void operator +=(SIZE size)
+	{
+		x += size.cx;
+		y += size.cy;
+	}
+
+	void operator -=(SIZE size)
+	{
+		x -= size.cx;
+		y -= size.cy;
+	}
+
+	void operator +=(POINT point)
+	{
+		x += point.x;
+		y += point.y;
+	}
+
+	void operator -=(POINT point)
+	{
+		x -= point.x;
+		y -= point.y;
+	}
+
+	void SetPoint(int X, int Y)
+	{
+		x = X;
+		y = Y;
+	}
+
+// Operators returning CPoint values
+	CPoint operator +(SIZE size) const
+	{
+		return CPoint(x + size.cx, y + size.cy);
+	}
+
+	CPoint operator -(SIZE size) const
+	{
+		return CPoint(x - size.cx, y - size.cy);
+	}
+
+	CPoint operator -() const
+	{
+		return CPoint(-x, -y);
+	}
+
+	CPoint operator +(POINT point) const
+	{
+		return CPoint(x + point.x, y + point.y);
+	}
+
+// Operators returning CSize values
+	CSize operator -(POINT point) const
+	{
+		return CSize(x - point.x, y - point.y);
+	}
+
+// Operators returning CRect values
+	CRect operator +(const RECT* lpRect) const;
+	CRect operator -(const RECT* lpRect) const;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRect - Wrapper for Windows RECT structure.
+
+class CRect : public RECT
+{
+public:
+// Constructors
+	CRect()
+	{
+		left = 0;
+		top = 0;
+		right = 0;
+		bottom = 0;
+	}
+
+	CRect(int l, int t, int r, int b)
+	{
+		left = l;
+		top = t;
+		right = r;
+		bottom = b;
+	}
+
+	CRect(const RECT& srcRect)
+	{
+		::CopyRect(this, &srcRect);
+	}
+
+	CRect(LPCRECT lpSrcRect)
+	{
+		::CopyRect(this, lpSrcRect);
+	}
+
+	CRect(POINT point, SIZE size)
+	{
+		right = (left = point.x) + size.cx;
+		bottom = (top = point.y) + size.cy;
+	}
+
+	CRect(POINT topLeft, POINT bottomRight)
+	{
+		left = topLeft.x;
+		top = topLeft.y;
+		right = bottomRight.x;
+		bottom = bottomRight.y;
+	}
+
+// Attributes (in addition to RECT members)
+	int Width() const
+	{
+		return right - left;
+	}
+
+	int Height() const
+	{
+		return bottom - top;
+	}
+
+	CSize Size() const
+	{
+		return CSize(right - left, bottom - top);
+	}
+
+	CPoint& TopLeft()
+	{
+		return *((CPoint*)this);
+	}
+
+	CPoint& BottomRight()
+	{
+		return *((CPoint*)this + 1);
+	}
+
+	const CPoint& TopLeft() const
+	{
+		return *((CPoint*)this);
+	}
+
+	const CPoint& BottomRight() const
+	{
+		return *((CPoint*)this + 1);
+	}
+
+	CPoint CenterPoint() const
+	{
+		return CPoint((left + right) / 2, (top + bottom) / 2);
+	}
+
+	// convert between CRect and LPRECT/LPCRECT (no need for &)
+	operator LPRECT()
+	{
+		return this;
+	}
+
+	operator LPCRECT() const
+	{
+		return this;
+	}
+
+	BOOL IsRectEmpty() const
+	{
+		return ::IsRectEmpty(this);
+	}
+
+	BOOL IsRectNull() const
+	{
+		return (left == 0 && right == 0 && top == 0 && bottom == 0);
+	}
+
+	BOOL PtInRect(POINT point) const
+	{
+		return ::PtInRect(this, point);
+	}
+
+// Operations
+	void SetRect(int x1, int y1, int x2, int y2)
+	{
+		::SetRect(this, x1, y1, x2, y2);
+	}
+
+	void SetRect(POINT topLeft, POINT bottomRight)
+	{
+		::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y);
+	}
+
+	void SetRectEmpty()
+	{
+		::SetRectEmpty(this);
+	}
+
+	void CopyRect(LPCRECT lpSrcRect)
+	{
+		::CopyRect(this, lpSrcRect);
+	}
+
+	BOOL EqualRect(LPCRECT lpRect) const
+	{
+		return ::EqualRect(this, lpRect);
+	}
+
+	void InflateRect(int x, int y)
+	{
+		::InflateRect(this, x, y);
+	}
+
+	void InflateRect(SIZE size)
+	{
+		::InflateRect(this, size.cx, size.cy);
+	}
+
+	void InflateRect(LPCRECT lpRect)
+	{
+		left -= lpRect->left;
+		top -= lpRect->top;
+		right += lpRect->right;
+		bottom += lpRect->bottom;
+	}
+
+	void InflateRect(int l, int t, int r, int b)
+	{
+		left -= l;
+		top -= t;
+		right += r;
+		bottom += b;
+	}
+
+	void DeflateRect(int x, int y)
+	{
+		::InflateRect(this, -x, -y);
+	}
+
+	void DeflateRect(SIZE size)
+	{
+		::InflateRect(this, -size.cx, -size.cy);
+	}
+
+	void DeflateRect(LPCRECT lpRect)
+	{
+		left += lpRect->left;
+		top += lpRect->top;
+		right -= lpRect->right;
+		bottom -= lpRect->bottom;
+	}
+
+	void DeflateRect(int l, int t, int r, int b)
+	{
+		left += l;
+		top += t;
+		right -= r;
+		bottom -= b;
+	}
+
+	void OffsetRect(int x, int y)
+	{
+		::OffsetRect(this, x, y);
+	}
+	void OffsetRect(SIZE size)
+	{
+		::OffsetRect(this, size.cx, size.cy);
+	}
+
+	void OffsetRect(POINT point)
+	{
+		::OffsetRect(this, point.x, point.y);
+	}
+
+	void NormalizeRect()
+	{
+		int nTemp;
+		if (left > right)
+		{
+			nTemp = left;
+			left = right;
+			right = nTemp;
+		}
+		if (top > bottom)
+		{
+			nTemp = top;
+			top = bottom;
+			bottom = nTemp;
+		}
+	}
+
+	// absolute position of rectangle
+	void MoveToY(int y)
+	{
+		bottom = Height() + y;
+		top = y;
+	}
+
+	void MoveToX(int x)
+	{
+		right = Width() + x;
+		left = x;
+	}
+
+	void MoveToXY(int x, int y)
+	{
+		MoveToX(x);
+		MoveToY(y);
+	}
+
+	void MoveToXY(POINT pt)
+	{
+		MoveToX(pt.x);
+		MoveToY(pt.y);
+	}
+
+	// operations that fill '*this' with result
+	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
+	{
+		return ::IntersectRect(this, lpRect1, lpRect2);
+	}
+
+	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
+	{
+		return ::UnionRect(this, lpRect1, lpRect2);
+	}
+
+	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
+	{
+		return ::SubtractRect(this, lpRectSrc1, lpRectSrc2);
+	}
+
+// Additional Operations
+	void operator =(const RECT& srcRect)
+	{
+		::CopyRect(this, &srcRect);
+	}
+
+	BOOL operator ==(const RECT& rect) const
+	{
+		return ::EqualRect(this, &rect);
+	}
+
+	BOOL operator !=(const RECT& rect) const
+	{
+		return !::EqualRect(this, &rect);
+	}
+
+	void operator +=(POINT point)
+	{
+		::OffsetRect(this, point.x, point.y);
+	}
+
+	void operator +=(SIZE size)
+	{
+		::OffsetRect(this, size.cx, size.cy);
+	}
+
+	void operator +=(LPCRECT lpRect)
+	{
+		InflateRect(lpRect);
+	}
+
+	void operator -=(POINT point)
+	{
+		::OffsetRect(this, -point.x, -point.y);
+	}
+
+	void operator -=(SIZE size)
+	{
+		::OffsetRect(this, -size.cx, -size.cy);
+	}
+
+	void operator -=(LPCRECT lpRect)
+	{
+		DeflateRect(lpRect);
+	}
+
+	void operator &=(const RECT& rect)
+	{
+		::IntersectRect(this, this, &rect);
+	}
+
+	void operator |=(const RECT& rect)
+	{
+		::UnionRect(this, this, &rect);
+	}
+
+// Operators returning CRect values
+	CRect operator +(POINT pt) const
+	{
+		CRect rect(*this);
+		::OffsetRect(&rect, pt.x, pt.y);
+		return rect;
+	}
+
+	CRect operator -(POINT pt) const
+	{
+		CRect rect(*this);
+		::OffsetRect(&rect, -pt.x, -pt.y);
+		return rect;
+	}
+
+	CRect operator +(LPCRECT lpRect) const
+	{
+		CRect rect(this);
+		rect.InflateRect(lpRect);
+		return rect;
+	}
+
+	CRect operator +(SIZE size) const
+	{
+		CRect rect(*this);
+		::OffsetRect(&rect, size.cx, size.cy);
+		return rect;
+	}
+
+	CRect operator -(SIZE size) const
+	{
+		CRect rect(*this);
+		::OffsetRect(&rect, -size.cx, -size.cy);
+		return rect;
+	}
+
+	CRect operator -(LPCRECT lpRect) const
+	{
+		CRect rect(this);
+		rect.DeflateRect(lpRect);
+		return rect;
+	}
+
+	CRect operator &(const RECT& rect2) const
+	{
+		CRect rect;
+		::IntersectRect(&rect, this, &rect2);
+		return rect;
+	}
+
+	CRect operator |(const RECT& rect2) const
+	{
+		CRect rect;
+		::UnionRect(&rect, this, &rect2);
+		return rect;
+	}
+
+	CRect MulDiv(int nMultiplier, int nDivisor) const
+	{
+		return CRect(
+			::MulDiv(left, nMultiplier, nDivisor),
+			::MulDiv(top, nMultiplier, nDivisor),
+			::MulDiv(right, nMultiplier, nDivisor),
+			::MulDiv(bottom, nMultiplier, nDivisor));
+	}
+};
+
+
+// CSize implementation
+
+inline CPoint CSize::operator +(POINT point) const
+{ return CPoint(cx + point.x, cy + point.y); }
+
+inline CPoint CSize::operator -(POINT point) const
+{ return CPoint(cx - point.x, cy - point.y); }
+
+inline CRect CSize::operator +(const RECT* lpRect) const
+{ return CRect(lpRect) + *this; }
+
+inline CRect CSize::operator -(const RECT* lpRect) const
+{ return CRect(lpRect) - *this; }
+
+
+// CPoint implementation
+
+inline CRect CPoint::operator +(const RECT* lpRect) const
+{ return CRect(lpRect) + *this; }
+
+inline CRect CPoint::operator -(const RECT* lpRect) const
+{ return CRect(lpRect) - *this; }
+
+#endif // !_WTL_NO_WTYPES
+
+
+// WTL::CSize or ATL::CSize scalar operators 
+
+#if !defined(_WTL_NO_SIZE_SCALAR) && (!defined(_WTL_NO_WTYPES) || defined(__ATLTYPES_H__))
+
+template <class Num>
+inline CSize operator *(SIZE s, Num n) 
+{
+	return CSize((int)(s.cx * n), (int)(s.cy * n));
+};
+
+template <class Num>
+inline void operator *=(SIZE & s, Num n)
+{
+	s = s * n;
+};	
+
+template <class Num>
+inline CSize operator /(SIZE s, Num n) 
+{
+	return CSize((int)(s.cx / n), (int)(s.cy / n));
+};
+
+template <class Num>
+inline void operator /=(SIZE & s, Num n)
+{
+	s = s / n;
+};	
+
+#endif // !defined(_WTL_NO_SIZE_SCALAR) && (!defined(_WTL_NO_WTYPES) || defined(__ATLTYPES_H__))
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CString - String class
+
+#ifndef _WTL_NO_CSTRING
+
+struct CStringData
+{
+	long nRefs;     // reference count
+	int nDataLength;
+	int nAllocLength;
+	// TCHAR data[nAllocLength]
+
+	TCHAR* data()
+	{ return (TCHAR*)(this + 1); }
+};
+
+// Globals
+
+// For an empty string, m_pchData will point here
+// (note: avoids special case of checking for NULL m_pchData)
+// empty string data (and locked)
+_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0 };
+_declspec(selectany) CStringData* _atltmpDataNil = (CStringData*)&rgInitData;
+_declspec(selectany) LPCTSTR _atltmpPchNil = (LPCTSTR)(((BYTE*)&rgInitData) + sizeof(CStringData));
+
+
+class CString
+{
+public:
+// Constructors
+	CString()
+	{
+		Init();
+	}
+
+	CString(const CString& stringSrc)
+	{
+		ATLASSERT(stringSrc.GetData()->nRefs != 0);
+		if (stringSrc.GetData()->nRefs >= 0)
+		{
+			ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
+			m_pchData = stringSrc.m_pchData;
+			InterlockedIncrement(&GetData()->nRefs);
+		}
+		else
+		{
+			Init();
+			*this = stringSrc.m_pchData;
+		}
+	}
+
+	CString(TCHAR ch, int nRepeat = 1)
+	{
+		ATLASSERT(!_istlead(ch));   // can't create a lead byte string
+		Init();
+		if (nRepeat >= 1)
+		{
+			if(AllocBuffer(nRepeat))
+			{
+#ifdef _UNICODE
+				for (int i = 0; i < nRepeat; i++)
+					m_pchData[i] = ch;
+#else
+				memset(m_pchData, ch, nRepeat);
+#endif
+			}
+		}
+	}
+
+	CString(LPCTSTR lpsz)
+	{
+		Init();
+		if (lpsz != NULL && HIWORD(lpsz) == NULL)
+		{
+			UINT nID = LOWORD((DWORD_PTR)lpsz);
+			if (!LoadString(nID))
+				ATLTRACE2(atlTraceUI, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
+		}
+		else
+		{
+			int nLen = SafeStrlen(lpsz);
+			if (nLen != 0)
+			{
+				if(AllocBuffer(nLen))
+					SecureHelper::memcpy_x(m_pchData, (nLen + 1) * sizeof(TCHAR), lpsz, nLen * sizeof(TCHAR));
+			}
+		}
+	}
+
+#ifdef _UNICODE
+	CString(LPCSTR lpsz)
+	{
+		Init();
+#if defined(_WIN32_WCE) && (_ATL_VER >= 0x0800)
+		int nSrcLen = (lpsz != NULL) ? ATL::lstrlenA(lpsz) : 0;
+#else
+		int nSrcLen = (lpsz != NULL) ? lstrlenA(lpsz) : 0;
+#endif
+		if (nSrcLen != 0)
+		{
+			if(AllocBuffer(nSrcLen))
+			{
+				_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
+				ReleaseBuffer();
+			}
+		}
+	}
+#else // !_UNICODE
+	CString(LPCWSTR lpsz)
+	{
+		Init();
+		int nSrcLen = (lpsz != NULL) ? (int)wcslen(lpsz) : 0;
+		if (nSrcLen != 0)
+		{
+			if(AllocBuffer(nSrcLen * 2))
+			{
+				_wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1);
+				ReleaseBuffer();
+			}
+		}
+	}
+#endif // !_UNICODE
+
+	CString(LPCTSTR lpch, int nLength)
+	{
+		Init();
+		if (nLength != 0)
+		{
+			if(AllocBuffer(nLength))
+				SecureHelper::memcpy_x(m_pchData, (nLength + 1) * sizeof(TCHAR), lpch, nLength * sizeof(TCHAR));
+		}
+	}
+
+#ifdef _UNICODE
+	CString(LPCSTR lpsz, int nLength)
+	{
+		Init();
+		if (nLength != 0)
+		{
+			if(AllocBuffer(nLength))
+			{
+				int n = ::MultiByteToWideChar(CP_ACP, 0, lpsz, nLength, m_pchData, nLength + 1);
+				ReleaseBuffer((n >= 0) ? n : -1);
+			}
+		}
+	}
+#else // !_UNICODE
+	CString(LPCWSTR lpsz, int nLength)
+	{
+		Init();
+		if (nLength != 0)
+		{
+			if(((nLength * 2) > nLength) && AllocBuffer(nLength * 2))
+			{
+				int n = ::WideCharToMultiByte(CP_ACP, 0, lpsz, nLength, m_pchData, (nLength * 2) + 1, NULL, NULL);
+				ReleaseBuffer((n >= 0) ? n : -1);
+			}
+		}
+	}
+#endif // !_UNICODE
+
+	CString(const unsigned char* lpsz)
+	{
+		Init();
+		*this = (LPCSTR)lpsz;
+	}
+
+// Attributes & Operations
+	int GetLength() const   // as an array of characters
+	{
+		return GetData()->nDataLength;
+	}
+
+	BOOL IsEmpty() const
+	{
+		return GetData()->nDataLength == 0;
+	}
+
+	void Empty()   // free up the data
+	{
+		if (GetData()->nDataLength == 0)
+			return;
+
+		if (GetData()->nRefs >= 0)
+			Release();
+		else
+			*this = _T("");
+
+		ATLASSERT(GetData()->nDataLength == 0);
+		ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
+	}
+
+	TCHAR GetAt(int nIndex) const   // 0 based
+	{
+		ATLASSERT(nIndex >= 0);
+		ATLASSERT(nIndex < GetData()->nDataLength);
+		return m_pchData[nIndex];
+	}
+
+	TCHAR operator [](int nIndex) const   // same as GetAt
+	{
+		// same as GetAt
+		ATLASSERT(nIndex >= 0);
+		ATLASSERT(nIndex < GetData()->nDataLength);
+		return m_pchData[nIndex];
+	}
+
+	void SetAt(int nIndex, TCHAR ch)
+	{
+		ATLASSERT(nIndex >= 0);
+		ATLASSERT(nIndex < GetData()->nDataLength);
+
+		CopyBeforeWrite();
+		m_pchData[nIndex] = ch;
+	}
+
+	operator LPCTSTR() const   // as a C string
+	{
+		return m_pchData;
+	}
+
+	// overloaded assignment
+	CString& operator =(const CString& stringSrc)
+	{
+		if (m_pchData != stringSrc.m_pchData)
+		{
+			if ((GetData()->nRefs < 0 && GetData() != _atltmpDataNil) || stringSrc.GetData()->nRefs < 0)
+			{
+				// actual copy necessary since one of the strings is locked
+				AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
+			}
+			else
+			{
+				// can just copy references around
+				Release();
+				ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
+				m_pchData = stringSrc.m_pchData;
+				InterlockedIncrement(&GetData()->nRefs);
+			}
+		}
+		return *this;
+	}
+
+	CString& operator =(TCHAR ch)
+	{
+		ATLASSERT(!_istlead(ch));   // can't set single lead byte
+		AssignCopy(1, &ch);
+		return *this;
+	}
+
+#ifdef _UNICODE
+	CString& operator =(char ch)
+	{
+		*this = (TCHAR)ch;
+		return *this;
+	}
+#endif
+
+	CString& operator =(LPCTSTR lpsz)
+	{
+		ATLASSERT(lpsz == NULL || _IsValidString(lpsz));
+		AssignCopy(SafeStrlen(lpsz), lpsz);
+		return *this;
+	}
+
+#ifdef _UNICODE
+	CString& operator =(LPCSTR lpsz)
+	{
+#if defined(_WIN32_WCE) && (_ATL_VER >= 0x0800)
+		int nSrcLen = (lpsz != NULL) ? ATL::lstrlenA(lpsz) : 0;
+#else
+		int nSrcLen = (lpsz != NULL) ? lstrlenA(lpsz) : 0;
+#endif
+		if(AllocBeforeWrite(nSrcLen))
+		{
+			_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
+			ReleaseBuffer();
+		}
+		return *this;
+	}
+#else // !_UNICODE
+	CString& operator =(LPCWSTR lpsz)
+	{
+		int nSrcLen = (lpsz != NULL) ? (int)wcslen(lpsz) : 0;
+		if(AllocBeforeWrite(nSrcLen * 2))
+		{
+			_wcstombsz(m_pchData, lpsz, (nSrcLen * 2) + 1);
+			ReleaseBuffer();
+		}
+		return *this;
+	}
+#endif  // !_UNICODE
+
+	CString& operator =(const unsigned char* lpsz)
+	{
+		*this = (LPCSTR)lpsz;
+		return *this;
+	}
+
+	// string concatenation
+	CString& operator +=(const CString& string)
+	{
+		ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
+		return *this;
+	}
+
+	CString& operator +=(TCHAR ch)
+	{
+		ConcatInPlace(1, &ch);
+		return *this;
+	}
+
+#ifdef _UNICODE
+	CString& operator +=(char ch)
+	{
+		*this += (TCHAR)ch;
+		return *this;
+	}
+#endif
+
+	CString& operator +=(LPCTSTR lpsz)
+	{
+		ATLASSERT(lpsz == NULL || _IsValidString(lpsz));
+		ConcatInPlace(SafeStrlen(lpsz), lpsz);
+		return *this;
+	}
+
+	friend CString __stdcall operator +(const CString& string1, const CString& string2);
+	friend CString __stdcall operator +(const CString& string, TCHAR ch);
+	friend CString __stdcall operator +(TCHAR ch, const CString& string);
+#ifdef _UNICODE
+	friend CString __stdcall operator +(const CString& string, char ch);
+	friend CString __stdcall operator +(char ch, const CString& string);
+#endif
+	friend CString __stdcall operator +(const CString& string, LPCTSTR lpsz);
+	friend CString __stdcall operator +(LPCTSTR lpsz, const CString& string);
+
+	// string comparison
+	int Compare(LPCTSTR lpsz) const   // straight character (MBCS/Unicode aware)
+	{
+		return _cstrcmp(m_pchData, lpsz);
+	}
+
+	int CompareNoCase(LPCTSTR lpsz) const   // ignore case (MBCS/Unicode aware)
+	{
+		return _cstrcmpi(m_pchData, lpsz);
+	}
+
+#ifndef _WIN32_WCE
+	// CString::Collate is often slower than Compare but is MBSC/Unicode
+	//  aware as well as locale-sensitive with respect to sort order.
+	int Collate(LPCTSTR lpsz) const   // NLS aware
+	{
+		return _cstrcoll(m_pchData, lpsz);
+	}
+
+	int CollateNoCase(LPCTSTR lpsz) const   // ignore case
+	{
+		return _cstrcolli(m_pchData, lpsz);
+	}
+#endif // !_WIN32_WCE
+
+	// simple sub-string extraction
+	CString Mid(int nFirst, int nCount) const
+	{
+		// out-of-bounds requests return sensible things
+		if (nFirst < 0)
+			nFirst = 0;
+		if (nCount < 0)
+			nCount = 0;
+
+		if (nFirst + nCount > GetData()->nDataLength)
+			nCount = GetData()->nDataLength - nFirst;
+		if (nFirst > GetData()->nDataLength)
+			nCount = 0;
+
+		CString dest;
+		AllocCopy(dest, nCount, nFirst, 0);
+		return dest;
+	}
+
+	CString Mid(int nFirst) const
+	{
+		return Mid(nFirst, GetData()->nDataLength - nFirst);
+	}
+
+	CString Left(int nCount) const
+	{
+		if (nCount < 0)
+			nCount = 0;
+		else if (nCount > GetData()->nDataLength)
+			nCount = GetData()->nDataLength;
+
+		CString dest;
+		AllocCopy(dest, nCount, 0, 0);
+		return dest;
+	}
+
+	CString Right(int nCount) const
+	{
+		if (nCount < 0)
+			nCount = 0;
+		else if (nCount > GetData()->nDataLength)
+			nCount = GetData()->nDataLength;
+
+		CString dest;
+		AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
+		return dest;
+	}
+
+	CString SpanIncluding(LPCTSTR lpszCharSet) const   // strspn equivalent
+	{
+		ATLASSERT(_IsValidString(lpszCharSet));
+		return Left(_cstrspn(m_pchData, lpszCharSet));
+	}
+
+	CString SpanExcluding(LPCTSTR lpszCharSet) const   // strcspn equivalent
+	{
+		ATLASSERT(_IsValidString(lpszCharSet));
+		return Left(_cstrcspn(m_pchData, lpszCharSet));
+	}
+
+	// upper/lower/reverse conversion
+	void MakeUpper()
+	{
+		CopyBeforeWrite();
+		CharUpper(m_pchData);
+	}
+
+	void MakeLower()
+	{
+		CopyBeforeWrite();
+		CharLower(m_pchData);
+	}
+
+	void MakeReverse()
+	{
+		CopyBeforeWrite();
+		_cstrrev(m_pchData);
+	}
+
+	// trimming whitespace (either side)
+	void TrimRight()
+	{
+		CopyBeforeWrite();
+
+		// find beginning of trailing spaces by starting at beginning (DBCS aware)
+		LPTSTR lpsz = m_pchData;
+		LPTSTR lpszLast = NULL;
+		while (*lpsz != _T('\0'))
+		{
+			if (_cstrisspace(*lpsz))
+			{
+				if (lpszLast == NULL)
+					lpszLast = lpsz;
+			}
+			else
+			{
+				lpszLast = NULL;
+			}
+			lpsz = ::CharNext(lpsz);
+		}
+
+		if (lpszLast != NULL)
+		{
+			// truncate at trailing space start
+			*lpszLast = _T('\0');
+			GetData()->nDataLength = (int)(DWORD_PTR)(lpszLast - m_pchData);
+		}
+	}
+
+	void TrimLeft()
+	{
+		CopyBeforeWrite();
+
+		// find first non-space character
+		LPCTSTR lpsz = m_pchData;
+		while (_cstrisspace(*lpsz))
+			lpsz = ::CharNext(lpsz);
+
+		// fix up data and length
+		int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
+		SecureHelper::memmove_x(m_pchData, (GetData()->nAllocLength + 1) * sizeof(TCHAR), lpsz, (nDataLength + 1) * sizeof(TCHAR));
+		GetData()->nDataLength = nDataLength;
+	}
+
+	// remove continuous occurrences of chTarget starting from right
+	void TrimRight(TCHAR chTarget)
+	{
+		// find beginning of trailing matches
+		// by starting at beginning (DBCS aware)
+
+		CopyBeforeWrite();
+		LPTSTR lpsz = m_pchData;
+		LPTSTR lpszLast = NULL;
+
+		while (*lpsz != _T('\0'))
+		{
+			if (*lpsz == chTarget)
+			{
+				if (lpszLast == NULL)
+					lpszLast = lpsz;
+			}
+			else
+				lpszLast = NULL;
+			lpsz = ::CharNext(lpsz);
+		}
+
+		if (lpszLast != NULL)
+		{
+			// truncate at left-most matching character
+			*lpszLast = _T('\0');
+			GetData()->nDataLength = (int)(DWORD_PTR)(lpszLast - m_pchData);
+		}
+	}
+
+	// remove continuous occcurrences of characters in passed string, starting from right
+	void TrimRight(LPCTSTR lpszTargetList)
+	{
+		// find beginning of trailing matches by starting at beginning (DBCS aware)
+
+		CopyBeforeWrite();
+		LPTSTR lpsz = m_pchData;
+		LPTSTR lpszLast = NULL;
+
+		while (*lpsz != _T('\0'))
+		{
+			TCHAR* pNext = ::CharNext(lpsz);
+			if(pNext > lpsz + 1)
+			{
+				if (_cstrchr_db(lpszTargetList, *lpsz, *(lpsz + 1)) != NULL)
+				{
+					if (lpszLast == NULL)
+						lpszLast = lpsz;
+				}
+				else
+				{
+					lpszLast = NULL;
+				}
+			}
+			else
+			{
+				if (_cstrchr(lpszTargetList, *lpsz) != NULL)
+				{
+					if (lpszLast == NULL)
+						lpszLast = lpsz;
+				}
+				else
+				{
+					lpszLast = NULL;
+				}
+			}
+
+			lpsz = pNext;
+		}
+
+		if (lpszLast != NULL)
+		{
+			// truncate at left-most matching character
+			*lpszLast = _T('\0');
+			GetData()->nDataLength = (int)(DWORD_PTR)(lpszLast - m_pchData);
+		}
+	}
+
+	// remove continuous occurrences of chTarget starting from left
+	void TrimLeft(TCHAR chTarget)
+	{
+		// find first non-matching character
+
+		CopyBeforeWrite();
+		LPCTSTR lpsz = m_pchData;
+
+		while (chTarget == *lpsz)
+			lpsz = ::CharNext(lpsz);
+
+		if (lpsz != m_pchData)
+		{
+			// fix up data and length
+			int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
+			SecureHelper::memmove_x(m_pchData, (GetData()->nAllocLength + 1) * sizeof(TCHAR), lpsz, (nDataLength + 1) * sizeof(TCHAR));
+			GetData()->nDataLength = nDataLength;
+		}
+	}
+
+	// remove continuous occcurrences of characters in passed string, starting from left
+	void TrimLeft(LPCTSTR lpszTargets)
+	{
+		// if we're not trimming anything, we're not doing any work
+		if (SafeStrlen(lpszTargets) == 0)
+			return;
+
+		CopyBeforeWrite();
+		LPCTSTR lpsz = m_pchData;
+
+		while (*lpsz != _T('\0'))
+		{
+			TCHAR* pNext = ::CharNext(lpsz);
+			if(pNext > lpsz + 1)
+			{
+				if (_cstrchr_db(lpszTargets, *lpsz, *(lpsz + 1)) == NULL)
+					break;
+			}
+			else
+			{
+				if (_cstrchr(lpszTargets, *lpsz) == NULL)
+					break;
+			}
+			lpsz = pNext;
+		}
+
+		if (lpsz != m_pchData)
+		{
+			// fix up data and length
+			int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
+			SecureHelper::memmove_x(m_pchData, (GetData()->nAllocLength + 1) * sizeof(TCHAR), lpsz, (nDataLength + 1) * sizeof(TCHAR));
+			GetData()->nDataLength = nDataLength;
+		}
+	}
+
+	// advanced manipulation
+	// replace occurrences of chOld with chNew
+	int Replace(TCHAR chOld, TCHAR chNew)
+	{
+		int nCount = 0;
+
+		// short-circuit the nop case
+		if (chOld != chNew)
+		{
+			// otherwise modify each character that matches in the string
+			CopyBeforeWrite();
+			LPTSTR psz = m_pchData;
+			LPTSTR pszEnd = psz + GetData()->nDataLength;
+			while (psz < pszEnd)
+			{
+				// replace instances of the specified character only
+				if (*psz == chOld)
+				{
+					*psz = chNew;
+					nCount++;
+				}
+				psz = ::CharNext(psz);
+			}
+		}
+		return nCount;
+	}
+
+	// replace occurrences of substring lpszOld with lpszNew;
+	// empty lpszNew removes instances of lpszOld
+	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
+	{
+		// can't have empty or NULL lpszOld
+
+		int nSourceLen = SafeStrlen(lpszOld);
+		if (nSourceLen == 0)
+			return 0;
+		int nReplacementLen = SafeStrlen(lpszNew);
+
+		// loop once to figure out the size of the result string
+		int nCount = 0;
+		LPTSTR lpszStart = m_pchData;
+		LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
+		LPTSTR lpszTarget = NULL;
+		while (lpszStart < lpszEnd)
+		{
+			while ((lpszTarget = (TCHAR*)_cstrstr(lpszStart, lpszOld)) != NULL)
+			{
+				nCount++;
+				lpszStart = lpszTarget + nSourceLen;
+			}
+			lpszStart += lstrlen(lpszStart) + 1;
+		}
+
+		// if any changes were made, make them
+		if (nCount > 0)
+		{
+			CopyBeforeWrite();
+
+			// if the buffer is too small, just allocate a new buffer (slow but sure)
+			int nOldLength = GetData()->nDataLength;
+			int nNewLength =  nOldLength + (nReplacementLen - nSourceLen) * nCount;
+			if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
+			{
+				CStringData* pOldData = GetData();
+				LPTSTR pstr = m_pchData;
+				if(!AllocBuffer(nNewLength))
+					return -1;
+				SecureHelper::memcpy_x(m_pchData, (nNewLength + 1) * sizeof(TCHAR), pstr, pOldData->nDataLength * sizeof(TCHAR));
+				CString::Release(pOldData);
+			}
+			// else, we just do it in-place
+			lpszStart = m_pchData;
+			lpszEnd = m_pchData + GetData()->nDataLength;
+
+			// loop again to actually do the work
+			while (lpszStart < lpszEnd)
+			{
+				while ((lpszTarget = (TCHAR*)_cstrstr(lpszStart, lpszOld)) != NULL)
+				{
+					int nBalance = nOldLength - ((int)(DWORD_PTR)(lpszTarget - m_pchData) + nSourceLen);
+					int cchBuffLen = GetData()->nAllocLength - (int)(DWORD_PTR)(lpszTarget - m_pchData);
+					SecureHelper::memmove_x(lpszTarget + nReplacementLen, (cchBuffLen - nReplacementLen + 1) * sizeof(TCHAR), lpszTarget + nSourceLen, nBalance * sizeof(TCHAR));
+					SecureHelper::memcpy_x(lpszTarget, (cchBuffLen + 1) * sizeof(TCHAR), lpszNew, nReplacementLen * sizeof(TCHAR));
+					lpszStart = lpszTarget + nReplacementLen;
+					lpszStart[nBalance] = _T('\0');
+					nOldLength += (nReplacementLen - nSourceLen);
+				}
+				lpszStart += lstrlen(lpszStart) + 1;
+			}
+			ATLASSERT(m_pchData[nNewLength] == _T('\0'));
+			GetData()->nDataLength = nNewLength;
+		}
+
+		return nCount;
+	}
+
+	// remove occurrences of chRemove
+	int Remove(TCHAR chRemove)
+	{
+		CopyBeforeWrite();
+
+		LPTSTR pstrSource = m_pchData;
+		LPTSTR pstrDest = m_pchData;
+		LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;
+
+		while (pstrSource < pstrEnd)
+		{
+			if (*pstrSource != chRemove)
+			{
+				*pstrDest = *pstrSource;
+				pstrDest = ::CharNext(pstrDest);
+			}
+			pstrSource = ::CharNext(pstrSource);
+		}
+		*pstrDest = _T('\0');
+		int nCount = (int)(DWORD_PTR)(pstrSource - pstrDest);
+		GetData()->nDataLength -= nCount;
+
+		return nCount;
+	}
+
+	// insert character at zero-based index; concatenates if index is past end of string
+	int Insert(int nIndex, TCHAR ch)
+	{
+		CopyBeforeWrite();
+
+		if (nIndex < 0)
+			nIndex = 0;
+
+		int nNewLength = GetData()->nDataLength;
+		if (nIndex > nNewLength)
+			nIndex = nNewLength;
+		nNewLength++;
+
+		if (GetData()->nAllocLength < nNewLength)
+		{
+			CStringData* pOldData = GetData();
+			LPTSTR pstr = m_pchData;
+			if(!AllocBuffer(nNewLength))
+				return -1;
+			SecureHelper::memcpy_x(m_pchData, (nNewLength + 1) * sizeof(TCHAR), pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
+			CString::Release(pOldData);
+		}
+
+		// move existing bytes down
+		SecureHelper::memmove_x(m_pchData + nIndex + 1, (GetData()->nAllocLength - nIndex) * sizeof(TCHAR), m_pchData + nIndex, (nNewLength - nIndex) * sizeof(TCHAR));
+		m_pchData[nIndex] = ch;
+		GetData()->nDataLength = nNewLength;
+
+		return nNewLength;
+	}
+
+	// insert substring at zero-based index; concatenates if index is past end of string
+	int Insert(int nIndex, LPCTSTR pstr)
+	{
+		if (nIndex < 0)
+			nIndex = 0;
+
+		int nInsertLength = SafeStrlen(pstr);
+		int nNewLength = GetData()->nDataLength;
+		if (nInsertLength > 0)
+		{
+			CopyBeforeWrite();
+			if (nIndex > nNewLength)
+				nIndex = nNewLength;
+			nNewLength += nInsertLength;
+
+			if (GetData()->nAllocLength < nNewLength)
+			{
+				CStringData* pOldData = GetData();
+				LPTSTR pstr = m_pchData;
+				if(!AllocBuffer(nNewLength))
+					return -1;
+				SecureHelper::memcpy_x(m_pchData, (nNewLength + 1) * sizeof(TCHAR), pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
+				CString::Release(pOldData);
+			}
+
+			// move existing bytes down
+			SecureHelper::memmove_x(m_pchData + nIndex + nInsertLength, (GetData()->nAllocLength + 1 - nIndex - nInsertLength) * sizeof(TCHAR), m_pchData + nIndex, (nNewLength - nIndex - nInsertLength + 1) * sizeof(TCHAR));
+			SecureHelper::memcpy_x(m_pchData + nIndex, (GetData()->nAllocLength + 1 - nIndex) * sizeof(TCHAR), pstr, nInsertLength * sizeof(TCHAR));
+			GetData()->nDataLength = nNewLength;
+		}
+
+		return nNewLength;
+	}
+
+	// delete nCount characters starting at zero-based index
+	int Delete(int nIndex, int nCount = 1)
+	{
+		if (nIndex < 0)
+			nIndex = 0;
+		int nLength = GetData()->nDataLength;
+		if (nCount > 0 && nIndex < nLength)
+		{
+			if((nIndex + nCount) > nLength)
+				nCount = nLength - nIndex;
+			CopyBeforeWrite();
+			int nBytesToCopy = nLength - (nIndex + nCount) + 1;
+
+			SecureHelper::memmove_x(m_pchData + nIndex, (GetData()->nAllocLength + 1 - nIndex) * sizeof(TCHAR), m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
+			nLength -= nCount;
+			GetData()->nDataLength = nLength;
+		}
+
+		return nLength;
+	}
+
+	// searching (return starting index, or -1 if not found)
+	// look for a single character match
+	int Find(TCHAR ch) const   // like "C" strchr
+	{
+		return Find(ch, 0);
+	}
+
+	int ReverseFind(TCHAR ch) const
+	{
+		// find last single character
+		LPCTSTR lpsz = _cstrrchr(m_pchData, (_TUCHAR)ch);
+
+		// return -1 if not found, distance from beginning otherwise
+		return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
+	}
+
+	int Find(TCHAR ch, int nStart) const   // starting at index
+	{
+		int nLength = GetData()->nDataLength;
+		if (nStart < 0 || nStart >= nLength)
+			return -1;
+
+		// find first single character
+		LPCTSTR lpsz = _cstrchr(m_pchData + nStart, (_TUCHAR)ch);
+
+		// return -1 if not found and index otherwise
+		return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
+	}
+
+	int FindOneOf(LPCTSTR lpszCharSet) const
+	{
+		ATLASSERT(_IsValidString(lpszCharSet));
+		LPCTSTR lpsz = _cstrpbrk(m_pchData, lpszCharSet);
+		return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
+	}
+
+	// look for a specific sub-string
+	// find a sub-string (like strstr)
+	int Find(LPCTSTR lpszSub) const   // like "C" strstr
+	{
+		return Find(lpszSub, 0);
+	}
+
+	int Find(LPCTSTR lpszSub, int nStart) const   // starting at index
+	{
+		ATLASSERT(_IsValidString(lpszSub));
+
+		int nLength = GetData()->nDataLength;
+		if (nStart < 0 || nStart > nLength)
+			return -1;
+
+		// find first matching substring
+		LPCTSTR lpsz = _cstrstr(m_pchData + nStart, lpszSub);
+
+		// return -1 for not found, distance from beginning otherwise
+		return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
+	}
+
+	// Concatentation for non strings
+	CString& Append(int n)
+	{
+		const int cchBuff = 12;
+		TCHAR szBuffer[cchBuff] = { 0 };
+		SecureHelper::wsprintf_x(szBuffer, cchBuff, _T("%d"), n);
+		ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
+		return *this;
+	}
+
+	// simple formatting
+	// formatting (using wsprintf style formatting)
+	BOOL __cdecl Format(LPCTSTR lpszFormat, ...)
+	{
+		ATLASSERT(_IsValidString(lpszFormat));
+
+		va_list argList;
+		va_start(argList, lpszFormat);
+		BOOL bRet = FormatV(lpszFormat, argList);
+		va_end(argList);
+		return bRet;
+	}
+
+	BOOL __cdecl Format(UINT nFormatID, ...)
+	{
+		CString strFormat;
+		BOOL bRet = strFormat.LoadString(nFormatID);
+		ATLASSERT(bRet != 0);
+
+		va_list argList;
+		va_start(argList, nFormatID);
+		bRet = FormatV(strFormat, argList);
+		va_end(argList);
+		return bRet;
+	}
+
+	BOOL FormatV(LPCTSTR lpszFormat, va_list argList)
+	{
+		ATLASSERT(_IsValidString(lpszFormat));
+
+		enum _FormatModifiers
+		{
+			FORCE_ANSI =	0x10000,
+			FORCE_UNICODE =	0x20000,
+			FORCE_INT64 =	0x40000
+		};
+
+		va_list argListSave = argList;
+
+		// make a guess at the maximum length of the resulting string
+		int nMaxLen = 0;
+		for (LPCTSTR lpsz = lpszFormat; *lpsz != _T('\0'); lpsz = ::CharNext(lpsz))
+		{
+			// handle '%' character, but watch out for '%%'
+			if (*lpsz != _T('%') || *(lpsz = ::CharNext(lpsz)) == _T('%'))
+			{
+				nMaxLen += (int)(::CharNext(lpsz) - lpsz);
+				continue;
+			}
+
+			int nItemLen = 0;
+
+			// handle '%' character with format
+			int nWidth = 0;
+			for (; *lpsz != _T('\0'); lpsz = ::CharNext(lpsz))
+			{
+				// check for valid flags
+				if (*lpsz == _T('#'))
+					nMaxLen += 2;   // for '0x'
+				else if (*lpsz == _T('*'))
+					nWidth = va_arg(argList, int);
+				else if (*lpsz == _T('-') || *lpsz == _T('+') || *lpsz == _T('0') || *lpsz == _T(' '))
+					;
+				else // hit non-flag character
+					break;
+			}
+			// get width and skip it
+			if (nWidth == 0)
+			{
+				// width indicated by
+				nWidth = _cstrtoi(lpsz);
+				for (; *lpsz != _T('\0') && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
+					;
+			}
+			ATLASSERT(nWidth >= 0);
+
+			int nPrecision = 0;
+			if (*lpsz == _T('.'))
+			{
+				// skip past '.' separator (width.precision)
+				lpsz = ::CharNext(lpsz);
+
+				// get precision and skip it
+				if (*lpsz == _T('*'))
+				{
+					nPrecision = va_arg(argList, int);
+					lpsz = ::CharNext(lpsz);
+				}
+				else
+				{
+					nPrecision = _cstrtoi(lpsz);
+					for (; *lpsz != _T('\0') && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
+						;
+				}
+				ATLASSERT(nPrecision >= 0);
+			}
+
+			// should be on type modifier or specifier
+			int nModifier = 0;
+			if(lpsz[0] == _T('I') && lpsz[1] == _T('6') && lpsz[2] == _T('4'))
+			{
+				lpsz += 3;
+				nModifier = FORCE_INT64;
+			}
+			else
+			{
+				switch (*lpsz)
+				{
+				// modifiers that affect size
+				case _T('h'):
+					nModifier = FORCE_ANSI;
+					lpsz = ::CharNext(lpsz);
+					break;
+				case _T('l'):
+					nModifier = FORCE_UNICODE;
+					lpsz = ::CharNext(lpsz);
+					break;
+
+				// modifiers that do not affect size
+				case _T('F'):
+				case _T('N'):
+				case _T('L'):
+					lpsz = ::CharNext(lpsz);
+					break;
+				}
+			}
+
+			// now should be on specifier
+			switch (*lpsz | nModifier)
+			{
+			// single characters
+			case _T('c'):
+			case _T('C'):
+				nItemLen = 2;
+				va_arg(argList, TCHAR);
+				break;
+			case _T('c') | FORCE_ANSI:
+			case _T('C') | FORCE_ANSI:
+				nItemLen = 2;
+				va_arg(argList, char);
+				break;
+			case _T('c') | FORCE_UNICODE:
+			case _T('C') | FORCE_UNICODE:
+				nItemLen = 2;
+				va_arg(argList, WCHAR);
+				break;
+
+			// strings
+			case _T('s'):
+			{
+				LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
+				if (pstrNextArg == NULL)
+				{
+					nItemLen = 6;  // "(null)"
+				}
+				else
+				{
+					nItemLen = lstrlen(pstrNextArg);
+					nItemLen = max(1, nItemLen);
+				}
+				break;
+			}
+
+			case _T('S'):
+			{
+#ifndef _UNICODE
+				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
+				if (pstrNextArg == NULL)
+				{
+					nItemLen = 6;  // "(null)"
+				}
+				else
+				{
+					nItemLen = (int)wcslen(pstrNextArg);
+					nItemLen = max(1, nItemLen);
+				}
+#else // _UNICODE
+				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
+				if (pstrNextArg == NULL)
+				{
+					nItemLen = 6; // "(null)"
+				}
+				else
+				{
+#if defined(_WIN32_WCE) && (_ATL_VER >= 0x0800)
+					nItemLen = ATL::lstrlenA(pstrNextArg);
+#else
+					nItemLen = lstrlenA(pstrNextArg);
+#endif
+					nItemLen = max(1, nItemLen);
+				}
+#endif // _UNICODE
+				break;
+			}
+
+			case _T('s') | FORCE_ANSI:
+			case _T('S') | FORCE_ANSI:
+			{
+				LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
+				if (pstrNextArg == NULL)
+				{
+					nItemLen = 6; // "(null)"
+				}
+				else
+				{
+#if defined(_WIN32_WCE) && (_ATL_VER >= 0x0800)
+					nItemLen = ATL::lstrlenA(pstrNextArg);
+#else
+					nItemLen = lstrlenA(pstrNextArg);
+#endif
+					nItemLen = max(1, nItemLen);
+				}
+				break;
+			}
+
+			case _T('s') | FORCE_UNICODE:
+			case _T('S') | FORCE_UNICODE:
+			{
+				LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
+				if (pstrNextArg == NULL)
+				{
+					nItemLen = 6; // "(null)"
+				}
+				else
+				{
+					nItemLen = (int)wcslen(pstrNextArg);
+					nItemLen = max(1, nItemLen);
+				}
+				break;
+			}
+			}
+
+			// adjust nItemLen for strings
+			if (nItemLen != 0)
+			{
+				nItemLen = max(nItemLen, nWidth);
+				if (nPrecision != 0)
+					nItemLen = min(nItemLen, nPrecision);
+			}
+			else
+			{
+				switch (*lpsz)
+				{
+				// integers
+				case _T('d'):
+				case _T('i'):
+				case _T('u'):
+				case _T('x'):
+				case _T('X'):
+				case _T('o'):
+					if (nModifier & FORCE_INT64)
+						va_arg(argList, __int64);
+					else
+						va_arg(argList, int);
+					nItemLen = 32;
+					nItemLen = max(nItemLen, nWidth + nPrecision);
+					break;
+
+#ifndef _ATL_USE_CSTRING_FLOAT
+				case _T('e'):
+				case _T('E'):
+				case _T('f'):
+				case _T('g'):
+				case _T('G'):
+					ATLASSERT(!"Floating point (%%e, %%E, %%f, %%g, and %%G) is not supported by the WTL::CString class.");
+#ifndef _DEBUG
+					::OutputDebugString(_T("Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class."));
+#ifndef _WIN32_WCE
+					::DebugBreak();
+#else // CE specific
+					DebugBreak();
+#endif // _WIN32_WCE
+#endif // !_DEBUG
+					break;
+#else // _ATL_USE_CSTRING_FLOAT
+				case _T('e'):
+				case _T('E'):
+				case _T('g'):
+				case _T('G'):
+					va_arg(argList, double);
+					nItemLen = 128;
+					nItemLen = max(nItemLen, nWidth + nPrecision);
+					break;
+				case _T('f'):
+					{
+						double f = va_arg(argList, double);
+						// 312 == strlen("-1+(309 zeroes).")
+						// 309 zeroes == max precision of a double
+						// 6 == adjustment in case precision is not specified,
+						//   which means that the precision defaults to 6
+						int cchLen = max(nWidth, 312 + nPrecision + 6);
+						CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+						LPTSTR pszTemp = buff.Allocate(cchLen);
+						if(pszTemp != NULL)
+						{
+							SecureHelper::sprintf_x(pszTemp, cchLen, _T("%*.*f"), nWidth, nPrecision + 6, f);
+							nItemLen = (int)_tcslen(pszTemp);
+						}
+						else
+						{
+							nItemLen = cchLen;
+						}
+					}
+					break;
+#endif // _ATL_USE_CSTRING_FLOAT
+
+				case _T('p'):
+					va_arg(argList, void*);
+					nItemLen = 32;
+					nItemLen = max(nItemLen, nWidth + nPrecision);
+					break;
+
+				// no output
+				case _T('n'):
+					va_arg(argList, int*);
+					break;
+
+				default:
+					ATLASSERT(FALSE);  // unknown formatting option
+				}
+			}
+
+			// adjust nMaxLen for output nItemLen
+			nMaxLen += nItemLen;
+		}
+
+		if(GetBuffer(nMaxLen) == NULL)
+			return FALSE;
+#ifndef _ATL_USE_CSTRING_FLOAT
+		int nRet = SecureHelper::wvsprintf_x(m_pchData, GetAllocLength() + 1, lpszFormat, argListSave);
+#else // _ATL_USE_CSTRING_FLOAT
+		int nRet = SecureHelper::vsprintf_x(m_pchData, GetAllocLength() + 1, lpszFormat, argListSave);
+#endif // _ATL_USE_CSTRING_FLOAT
+		nRet;   // ref
+		ATLASSERT(nRet <= GetAllocLength());
+		ReleaseBuffer();
+
+		va_end(argListSave);
+		return TRUE;
+	}
+
+	// formatting for localization (uses FormatMessage API)
+	// formatting (using FormatMessage style formatting)
+	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...)
+	{
+		// format message into temporary buffer lpszTemp
+		va_list argList;
+		va_start(argList, lpszFormat);
+		LPTSTR lpszTemp;
+		BOOL bRet = TRUE;
+
+		if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
+				lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
+			bRet = FALSE;
+
+		// assign lpszTemp into the resulting string and free the temporary
+		*this = lpszTemp;
+		LocalFree(lpszTemp);
+		va_end(argList);
+		return bRet;
+	}
+
+	BOOL __cdecl FormatMessage(UINT nFormatID, ...)
+	{
+		// get format string from string table
+		CString strFormat;
+		BOOL bRetTmp = strFormat.LoadString(nFormatID);
+		bRetTmp;   // ref
+		ATLASSERT(bRetTmp != 0);
+
+		// format message into temporary buffer lpszTemp
+		va_list argList;
+		va_start(argList, nFormatID);
+		LPTSTR lpszTemp;
+		BOOL bRet = TRUE;
+
+		if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
+				strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
+			bRet = FALSE;
+
+		// assign lpszTemp into the resulting string and free lpszTemp
+		*this = lpszTemp;
+		LocalFree(lpszTemp);
+		va_end(argList);
+		return bRet;
+	}
+
+	// Windows support
+	BOOL LoadString(UINT nID)   // load from string resource (255 chars max.)
+	{
+#ifdef _UNICODE
+		const int CHAR_FUDGE = 1;   // one TCHAR unused is good enough
+#else
+		const int CHAR_FUDGE = 2;   // two BYTES unused for case of DBC last char
+#endif
+
+		// try fixed buffer first (to avoid wasting space in the heap)
+		TCHAR szTemp[256];
+		int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
+		int nLen = _LoadString(nID, szTemp, nCount);
+		if (nCount - nLen > CHAR_FUDGE)
+		{
+			*this = szTemp;
+			return (nLen > 0);
+		}
+
+		// try buffer size of 512, then larger size until entire string is retrieved
+		int nSize = 256;
+		do
+		{
+			nSize += 256;
+			LPTSTR lpstr = GetBuffer(nSize - 1);
+			if(lpstr == NULL)
+			{
+				nLen = 0;
+				break;
+			}
+			nLen = _LoadString(nID, lpstr, nSize);
+		} while (nSize - nLen <= CHAR_FUDGE);
+		ReleaseBuffer();
+
+		return (nLen > 0);
+	}
+
+#ifndef _UNICODE
+	// ANSI <-> OEM support (convert string in place)
+	void AnsiToOem()
+	{
+		CopyBeforeWrite();
+		::AnsiToOem(m_pchData, m_pchData);
+	}
+
+	void OemToAnsi()
+	{
+		CopyBeforeWrite();
+		::OemToAnsi(m_pchData, m_pchData);
+	}
+#endif
+
+#ifndef _ATL_NO_COM
+	// OLE BSTR support (use for OLE automation)
+	BSTR AllocSysString() const
+	{
+#if defined(_UNICODE) || defined(OLE2ANSI)
+		BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
+#else
+		int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
+			GetData()->nDataLength, NULL, NULL);
+		BSTR bstr = ::SysAllocStringLen(NULL, nLen);
+		if(bstr != NULL)
+			MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
+#endif
+		return bstr;
+	}
+
+	BSTR SetSysString(BSTR* pbstr) const
+	{
+#if defined(_UNICODE) || defined(OLE2ANSI)
+		::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
+#else
+		int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
+			GetData()->nDataLength, NULL, NULL);
+		if(::SysReAllocStringLen(pbstr, NULL, nLen))
+			MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
+#endif
+		ATLASSERT(*pbstr != NULL);
+		return *pbstr;
+	}
+#endif // !_ATL_NO_COM
+
+	// Access to string implementation buffer as "C" character array
+	LPTSTR GetBuffer(int nMinBufLength)
+	{
+		ATLASSERT(nMinBufLength >= 0);
+
+		if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
+		{
+			// we have to grow the buffer
+			CStringData* pOldData = GetData();
+			int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
+			if (nMinBufLength < nOldLen)
+				nMinBufLength = nOldLen;
+
+			if(!AllocBuffer(nMinBufLength))
+				return NULL;
+
+			SecureHelper::memcpy_x(m_pchData, (nMinBufLength + 1) * sizeof(TCHAR), pOldData->data(), (nOldLen + 1) * sizeof(TCHAR));
+			GetData()->nDataLength = nOldLen;
+			CString::Release(pOldData);
+		}
+		ATLASSERT(GetData()->nRefs <= 1);
+
+		// return a pointer to the character storage for this string
+		ATLASSERT(m_pchData != NULL);
+		return m_pchData;
+	}
+
+	void ReleaseBuffer(int nNewLength = -1)
+	{
+		CopyBeforeWrite();   // just in case GetBuffer was not called
+
+		if (nNewLength == -1)
+			nNewLength = lstrlen(m_pchData);   // zero terminated
+
+		ATLASSERT(nNewLength <= GetData()->nAllocLength);
+		GetData()->nDataLength = nNewLength;
+		m_pchData[nNewLength] = _T('\0');
+	}
+
+	LPTSTR GetBufferSetLength(int nNewLength)
+	{
+		ATLASSERT(nNewLength >= 0);
+
+		if(GetBuffer(nNewLength) == NULL)
+			return NULL;
+
+		GetData()->nDataLength = nNewLength;
+		m_pchData[nNewLength] = _T('\0');
+		return m_pchData;
+	}
+
+	void FreeExtra()
+	{
+		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
+		if (GetData()->nDataLength != GetData()->nAllocLength)
+		{
+			CStringData* pOldData = GetData();
+			if(AllocBuffer(GetData()->nDataLength))
+			{
+				SecureHelper::memcpy_x(m_pchData, (GetData()->nAllocLength + 1) * sizeof(TCHAR), pOldData->data(), pOldData->nDataLength * sizeof(TCHAR));
+				ATLASSERT(m_pchData[GetData()->nDataLength] == _T('\0'));
+				CString::Release(pOldData);
+			}
+		}
+		ATLASSERT(GetData() != NULL);
+	}
+
+	// Use LockBuffer/UnlockBuffer to turn refcounting off
+	LPTSTR LockBuffer()
+	{
+		LPTSTR lpsz = GetBuffer(0);
+		if(lpsz != NULL)
+			GetData()->nRefs = -1;
+		return lpsz;
+	}
+
+	void UnlockBuffer()
+	{
+		ATLASSERT(GetData()->nRefs == -1);
+		if (GetData() != _atltmpDataNil)
+			GetData()->nRefs = 1;
+	}
+
+// Implementation
+public:
+	~CString()   //  free any attached data
+	{
+		if (GetData() != _atltmpDataNil)
+		{
+			if (InterlockedDecrement(&GetData()->nRefs) <= 0)
+				delete[] (BYTE*)GetData();
+		}
+	}
+
+	int GetAllocLength() const
+	{
+		return GetData()->nAllocLength;
+	}
+
+	static BOOL __stdcall _IsValidString(LPCTSTR lpsz, int /*nLength*/ = -1)
+	{
+		return (lpsz != NULL) ? TRUE : FALSE;
+	}
+
+protected:
+	LPTSTR m_pchData;   // pointer to ref counted string data
+
+	// implementation helpers
+	CStringData* GetData() const
+	{
+		ATLASSERT(m_pchData != NULL);
+		return ((CStringData*)m_pchData) - 1;
+	}
+
+	void Init()
+	{
+		m_pchData = _GetEmptyString().m_pchData;
+	}
+
+	BOOL AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const
+	{
+		// will clone the data attached to this string
+		// allocating 'nExtraLen' characters
+		// Places results in uninitialized string 'dest'
+		// Will copy the part or all of original data to start of new string
+
+		BOOL bRet = FALSE;
+		int nNewLen = nCopyLen + nExtraLen;
+		if (nNewLen == 0)
+		{
+			dest.Init();
+			bRet = TRUE;
+		}
+		else if(nNewLen >= nCopyLen)
+		{
+			if(dest.AllocBuffer(nNewLen))
+			{
+				SecureHelper::memcpy_x(dest.m_pchData, (nNewLen + 1) * sizeof(TCHAR), m_pchData + nCopyIndex, nCopyLen * sizeof(TCHAR));
+				bRet = TRUE;
+			}
+		}
+
+		return bRet;
+	}
+
+	// always allocate one extra character for '\0' termination
+	// assumes [optimistically] that data length will equal allocation length
+	BOOL AllocBuffer(int nLen)
+	{
+		ATLASSERT(nLen >= 0);
+		ATLASSERT(nLen <= INT_MAX - 1);   // max size (enough room for 1 extra)
+
+		if (nLen == 0)
+		{
+			Init();
+		}
+		else
+		{
+			CStringData* pData = NULL;
+			ATLTRY(pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen + 1) * sizeof(TCHAR)]);
+			if(pData == NULL)
+				return FALSE;
+
+			pData->nRefs = 1;
+			pData->data()[nLen] = _T('\0');
+			pData->nDataLength = nLen;
+			pData->nAllocLength = nLen;
+			m_pchData = pData->data();
+		}
+
+		return TRUE;
+	}
+
+	// Assignment operators
+	//  All assign a new value to the string
+	//      (a) first see if the buffer is big enough
+	//      (b) if enough room, copy on top of old buffer, set size and type
+	//      (c) otherwise free old string data, and create a new one
+	//
+	//  All routines return the new string (but as a 'const CString&' so that
+	//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
+	//
+	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
+	{
+		if(AllocBeforeWrite(nSrcLen))
+		{
+			SecureHelper::memcpy_x(m_pchData, (nSrcLen + 1) * sizeof(TCHAR), lpszSrcData, nSrcLen * sizeof(TCHAR));
+			GetData()->nDataLength = nSrcLen;
+			m_pchData[nSrcLen] = _T('\0');
+		}
+	}
+
+	// Concatenation
+	// NOTE: "operator +" is done as friend functions for simplicity
+	//      There are three variants:
+	//          CString + CString
+	// and for ? = TCHAR, LPCTSTR
+	//          CString + ?
+	//          ? + CString
+	BOOL ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data)
+	{
+		// -- master concatenation routine
+		// Concatenate two sources
+		// -- assume that 'this' is a new CString object
+
+		BOOL bRet = TRUE;
+		int nNewLen = nSrc1Len + nSrc2Len;
+		if(nNewLen < nSrc1Len || nNewLen < nSrc2Len)
+		{
+			bRet = FALSE;
+		}
+		else if(nNewLen != 0)
+		{
+			bRet = AllocBuffer(nNewLen);
+			if (bRet)
+			{
+				SecureHelper::memcpy_x(m_pchData, (nNewLen + 1) * sizeof(TCHAR), lpszSrc1Data, nSrc1Len * sizeof(TCHAR));
+				SecureHelper::memcpy_x(m_pchData + nSrc1Len, (nNewLen + 1 - nSrc1Len) * sizeof(TCHAR), lpszSrc2Data, nSrc2Len * sizeof(TCHAR));
+			}
+		}
+		return bRet;
+	}
+
+	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
+	{
+		//  -- the main routine for += operators
+
+		// concatenating an empty string is a no-op!
+		if (nSrcLen == 0)
+			return;
+
+		// if the buffer is too small, or we have a width mis-match, just
+		//   allocate a new buffer (slow but sure)
+		if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
+		{
+			// we have to grow the buffer, use the ConcatCopy routine
+			CStringData* pOldData = GetData();
+			if (ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData))
+			{
+				ATLASSERT(pOldData != NULL);
+				CString::Release(pOldData);
+			}
+		}
+		else
+		{
+			// fast concatenation when buffer big enough
+			SecureHelper::memcpy_x(m_pchData + GetData()->nDataLength, (GetData()->nAllocLength + 1) * sizeof(TCHAR), lpszSrcData, nSrcLen * sizeof(TCHAR));
+			GetData()->nDataLength += nSrcLen;
+			ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
+			m_pchData[GetData()->nDataLength] = _T('\0');
+		}
+	}
+
+	void CopyBeforeWrite()
+	{
+		if (GetData()->nRefs > 1)
+		{
+			CStringData* pData = GetData();
+			Release();
+			if(AllocBuffer(pData->nDataLength))
+				SecureHelper::memcpy_x(m_pchData, (GetData()->nAllocLength + 1) * sizeof(TCHAR), pData->data(), (pData->nDataLength + 1) * sizeof(TCHAR));
+		}
+		ATLASSERT(GetData()->nRefs <= 1);
+	}
+
+	BOOL AllocBeforeWrite(int nLen)
+	{
+		BOOL bRet = TRUE;
+		if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
+		{
+			Release();
+			bRet = AllocBuffer(nLen);
+		}
+		ATLASSERT(GetData()->nRefs <= 1);
+		return bRet;
+	}
+
+	void Release()
+	{
+		if (GetData() != _atltmpDataNil)
+		{
+			ATLASSERT(GetData()->nRefs != 0);
+			if (InterlockedDecrement(&GetData()->nRefs) <= 0)
+				delete[] (BYTE*)GetData();
+			Init();
+		}
+	}
+
+	static void PASCAL Release(CStringData* pData)
+	{
+		if (pData != _atltmpDataNil)
+		{
+			ATLASSERT(pData->nRefs != 0);
+			if (InterlockedDecrement(&pData->nRefs) <= 0)
+				delete[] (BYTE*)pData;
+		}
+	}
+
+	static int PASCAL SafeStrlen(LPCTSTR lpsz)
+	{
+		return (lpsz == NULL) ? 0 : lstrlen(lpsz);
+	}
+
+	static int __stdcall _LoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
+	{
+#ifdef _DEBUG
+		// LoadString without annoying warning from the Debug kernel if the
+		//  segment containing the string is not present
+		if (::FindResource(ModuleHelper::GetResourceInstance(), MAKEINTRESOURCE((nID >> 4) + 1), RT_STRING) == NULL)
+		{
+			lpszBuf[0] = _T('\0');
+			return 0;   // not found
+		}
+#endif // _DEBUG
+
+		int nLen = ::LoadString(ModuleHelper::GetResourceInstance(), nID, lpszBuf, nMaxBuf);
+		if (nLen == 0)
+			lpszBuf[0] = _T('\0');
+
+		return nLen;
+	}
+
+	static const CString& __stdcall _GetEmptyString()
+	{
+		return *(CString*)&_atltmpPchNil;
+	}
+
+// CString conversion helpers
+	static int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
+	{
+		if (count == 0 && mbstr != NULL)
+			return 0;
+
+		int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, (int)count, NULL, NULL);
+		ATLASSERT(mbstr == NULL || result <= (int)count);
+		if (result > 0)
+			mbstr[result - 1] = 0;
+		return result;
+	}
+
+	static int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
+	{
+		if (count == 0 && wcstr != NULL)
+			return 0;
+
+		int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1, wcstr, (int)count);
+		ATLASSERT(wcstr == NULL || result <= (int)count);
+		if (result > 0)
+			wcstr[result - 1] = 0;
+		return result;
+	}
+
+// Helpers to avoid CRT startup code
+#ifdef _ATL_MIN_CRT
+	static const TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
+	{
+		// strchr for '\0' should succeed
+		while (*p != 0)
+		{
+			if (*p == ch)
+				break;
+			p = ::CharNext(p);
+		}
+		return (*p == ch) ? p : NULL;
+	}
+
+	static TCHAR* _cstrrev(TCHAR* pStr)
+	{
+		// optimize NULL, zero-length, and single-char case
+		if ((pStr == NULL) || (pStr[0] == _T('\0')) || (pStr[1] == _T('\0')))
+			return pStr;
+
+		TCHAR* p = pStr;
+
+		while (*p != 0) 
+		{
+			TCHAR* pNext = ::CharNext(p);
+			if(pNext > p + 1)
+			{
+				char p1 = *(char*)p;
+				*(char*)p = *(char*)(p + 1);
+				*(char*)(p + 1) = p1;
+			}
+			p = pNext;
+		}
+
+		p--;
+		TCHAR* q = pStr;
+
+		while (q < p)
+		{
+			TCHAR t = *q;
+			*q = *p;
+			*p = t;
+			q++;
+			p--;
+		}
+		return pStr;
+	}
+
+	static const TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
+	{
+		int nLen = lstrlen(pCharSet);
+		if (nLen == 0)
+			return (TCHAR*)pStr;
+
+		const TCHAR* pRet = NULL;
+		const TCHAR* pCur = pStr;
+		while((pCur = _cstrchr(pCur, *pCharSet)) != NULL)
+		{
+			if(memcmp(pCur, pCharSet, nLen * sizeof(TCHAR)) == 0)
+			{
+				pRet = pCur;
+				break;
+			}
+			pCur = ::CharNext(pCur);
+		}
+		return pRet;
+	}
+
+	static int _cstrspn(const TCHAR* pStr, const TCHAR* pCharSet)
+	{
+		int nRet = 0;
+		const TCHAR* p = pStr;
+		while (*p != 0)
+		{
+			const TCHAR* pNext = ::CharNext(p);
+			if(pNext > p + 1)
+			{
+				if(_cstrchr_db(pCharSet, *p, *(p + 1)) == NULL)
+					break;
+				nRet += 2;
+			}
+			else
+			{
+				if(_cstrchr(pCharSet, *p) == NULL)
+					break;
+				nRet++;
+			}
+			p = pNext;
+		}
+		return nRet;
+	}
+
+	static int _cstrcspn(const TCHAR* pStr, const TCHAR* pCharSet)
+	{
+		int nRet = 0;
+		TCHAR* p = (TCHAR*)pStr;
+		while (*p != 0)
+		{
+			TCHAR* pNext = ::CharNext(p);
+			if(pNext > p + 1)
+			{
+				if(_cstrchr_db(pCharSet, *p, *(p + 1)) != NULL)
+					break;
+				nRet += 2;
+			}
+			else
+			{
+				if(_cstrchr(pCharSet, *p) != NULL)
+					break;
+				nRet++;
+			}
+			p = pNext;
+		}
+		return nRet;
+	}
+
+	static const TCHAR* _cstrpbrk(const TCHAR* p, const TCHAR* lpszCharSet)
+	{
+		int n = _cstrcspn(p, lpszCharSet);
+		return (p[n] != 0) ? &p[n] : NULL;
+	}
+
+	static int _cstrcmp(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		return lstrcmp(pstrOne, pstrOther);
+	}
+
+	static int _cstrcmpi(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		return lstrcmpi(pstrOne, pstrOther);
+	}
+
+	static int _cstrcoll(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		int nRet = CompareString(GetThreadLocale(), 0, pstrOne, -1, pstrOther, -1);
+		ATLASSERT(nRet != 0);
+		return nRet - 2;   // convert to strcmp convention
+	}
+
+	static int _cstrcolli(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		int nRet = CompareString(GetThreadLocale(), NORM_IGNORECASE, pstrOne, -1, pstrOther, -1);
+		ATLASSERT(nRet != 0);
+		return nRet - 2;   // convert to strcmp convention
+	}
+#else // !_ATL_MIN_CRT
+	static const TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
+	{
+		return _tcschr(p, ch);
+	}
+
+	static TCHAR* _cstrrev(TCHAR* pStr)
+	{
+		return _tcsrev(pStr);
+	}
+
+	static const TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
+	{
+		return _tcsstr(pStr, pCharSet);
+	}
+
+	static int _cstrspn(const TCHAR* pStr, const TCHAR* pCharSet)
+	{
+		return (int)_tcsspn(pStr, pCharSet);
+	}
+
+	static int _cstrcspn(const TCHAR* pStr, const TCHAR* pCharSet)
+	{
+		return (int)_tcscspn(pStr, pCharSet);
+	}
+
+	static const TCHAR* _cstrpbrk(const TCHAR* p, const TCHAR* lpszCharSet)
+	{
+		return _tcspbrk(p, lpszCharSet);
+	}
+
+	static int _cstrcmp(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		return _tcscmp(pstrOne, pstrOther);
+	}
+
+	static int _cstrcmpi(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		return _tcsicmp(pstrOne, pstrOther);
+	}
+
+#ifndef _WIN32_WCE
+	static int _cstrcoll(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		return _tcscoll(pstrOne, pstrOther);
+	}
+
+	static int _cstrcolli(const TCHAR* pstrOne, const TCHAR* pstrOther)
+	{
+		return _tcsicoll(pstrOne, pstrOther);
+	}
+#endif // !_WIN32_WCE
+#endif // !_ATL_MIN_CRT
+
+	static const TCHAR* _cstrrchr(const TCHAR* p, TCHAR ch)
+	{
+		return MinCrtHelper::_strrchr(p, ch);
+	}
+
+	static int _cstrisdigit(TCHAR ch)
+	{
+		return MinCrtHelper::_isdigit(ch);
+	}
+
+	static int _cstrisspace(TCHAR ch)
+	{
+		return MinCrtHelper::_isspace(ch);
+	}
+
+	static int _cstrtoi(const TCHAR* nptr)
+	{
+		return MinCrtHelper::_atoi(nptr);
+	}
+
+	static const TCHAR* _cstrchr_db(const TCHAR* p, TCHAR ch1, TCHAR ch2)
+	{
+		const TCHAR* lpsz = NULL;
+		while (*p != 0)
+		{
+			if (*p == ch1 && *(p + 1) == ch2)
+			{
+				lpsz = p;
+				break;
+			}
+			p = ::CharNext(p);
+		}
+		return lpsz;
+	}
+};
+
+
+// Compare helpers
+
+inline bool __stdcall operator ==(const CString& s1, const CString& s2)
+{ return s1.Compare(s2) == 0; }
+
+inline bool __stdcall operator ==(const CString& s1, LPCTSTR s2)
+{ return s1.Compare(s2) == 0; }
+
+inline bool __stdcall operator ==(LPCTSTR s1, const CString& s2)
+{ return s2.Compare(s1) == 0; }
+
+inline bool __stdcall operator !=(const CString& s1, const CString& s2)
+{ return s1.Compare(s2) != 0; }
+
+inline bool __stdcall operator !=(const CString& s1, LPCTSTR s2)
+{ return s1.Compare(s2) != 0; }
+
+inline bool __stdcall operator !=(LPCTSTR s1, const CString& s2)
+{ return s2.Compare(s1) != 0; }
+
+inline bool __stdcall operator <(const CString& s1, const CString& s2)
+{ return s1.Compare(s2) < 0; }
+
+inline bool __stdcall operator <(const CString& s1, LPCTSTR s2)
+{ return s1.Compare(s2) < 0; }
+
+inline bool __stdcall operator <(LPCTSTR s1, const CString& s2)
+{ return s2.Compare(s1) > 0; }
+
+inline bool __stdcall operator >(const CString& s1, const CString& s2)
+{ return s1.Compare(s2) > 0; }
+
+inline bool __stdcall operator >(const CString& s1, LPCTSTR s2)
+{ return s1.Compare(s2) > 0; }
+
+inline bool __stdcall operator >(LPCTSTR s1, const CString& s2)
+{ return s2.Compare(s1) < 0; }
+
+inline bool __stdcall operator <=(const CString& s1, const CString& s2)
+{ return s1.Compare(s2) <= 0; }
+
+inline bool __stdcall operator <=(const CString& s1, LPCTSTR s2)
+{ return s1.Compare(s2) <= 0; }
+
+inline bool __stdcall operator <=(LPCTSTR s1, const CString& s2)
+{ return s2.Compare(s1) >= 0; }
+
+inline bool __stdcall operator >=(const CString& s1, const CString& s2)
+{ return s1.Compare(s2) >= 0; }
+
+inline bool __stdcall operator >=(const CString& s1, LPCTSTR s2)
+{ return s1.Compare(s2) >= 0; }
+
+inline bool __stdcall operator >=(LPCTSTR s1, const CString& s2)
+{ return s2.Compare(s1) <= 0; }
+
+
+// CString "operator +" functions
+
+inline CString __stdcall operator +(const CString& string1, const CString& string2)
+{
+	CString s;
+	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, string2.GetData()->nDataLength, string2.m_pchData);
+	return s;
+}
+
+inline CString __stdcall operator +(const CString& string, TCHAR ch)
+{
+	CString s;
+	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData, 1, &ch);
+	return s;
+}
+
+inline CString __stdcall operator +(TCHAR ch, const CString& string)
+{
+	CString s;
+	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
+	return s;
+}
+
+#ifdef _UNICODE
+inline CString __stdcall operator +(const CString& string, char ch)
+{
+	return string + (TCHAR)ch;
+}
+
+inline CString __stdcall operator +(char ch, const CString& string)
+{
+	return (TCHAR)ch + string;
+}
+#endif // _UNICODE
+
+inline CString __stdcall operator +(const CString& string, LPCTSTR lpsz)
+{
+	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz));
+	CString s;
+	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData, CString::SafeStrlen(lpsz), lpsz);
+	return s;
+}
+
+inline CString __stdcall operator +(LPCTSTR lpsz, const CString& string)
+{
+	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz));
+	CString s;
+	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength, string.m_pchData);
+	return s;
+}
+
+#endif // !_WTL_NO_CSTRING
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRecentDocumentList - MRU List Support
+
+#ifndef _WIN32_WCE
+
+#ifndef _WTL_MRUEMPTY_TEXT
+  #define _WTL_MRUEMPTY_TEXT	_T("(empty)")
+#endif
+
+// forward declaration
+inline bool AtlCompactPath(LPTSTR lpstrOut, LPCTSTR lpstrIn, int cchLen);
+
+template <class T, int t_cchItemLen = MAX_PATH, int t_nFirstID = ID_FILE_MRU_FIRST, int t_nLastID = ID_FILE_MRU_LAST>
+class CRecentDocumentListBase
+{
+public:
+// Declarations
+	struct _DocEntry
+	{
+		TCHAR szDocName[t_cchItemLen];
+		bool operator ==(const _DocEntry& de) const
+		{ return (lstrcmpi(szDocName, de.szDocName) == 0); }
+	};
+
+	enum
+	{
+		m_nMaxEntries_Min = 2,
+		m_nMaxEntries_Max = t_nLastID - t_nFirstID + 1,
+		m_cchMaxItemLen_Min = 6,
+		m_cchMaxItemLen_Max = t_cchItemLen,
+		m_cchItemNameLen = 11
+	};
+
+// Data members
+	ATL::CSimpleArray<_DocEntry> m_arrDocs;
+	int m_nMaxEntries;   // default is 4
+	HMENU m_hMenu;
+
+	TCHAR m_szNoEntries[t_cchItemLen];
+
+	int m_cchMaxItemLen;
+
+// Constructor
+	CRecentDocumentListBase() : m_hMenu(NULL), m_nMaxEntries(4), m_cchMaxItemLen(-1)
+	{
+		// These ASSERTs verify values of the template arguments
+		ATLASSERT(t_cchItemLen > m_cchMaxItemLen_Min);
+		ATLASSERT(m_nMaxEntries_Max > m_nMaxEntries_Min);
+	}
+
+// Attributes
+	HMENU GetMenuHandle() const
+	{
+		return m_hMenu;
+	}
+
+	void SetMenuHandle(HMENU hMenu)
+	{
+		ATLASSERT(hMenu == NULL || ::IsMenu(hMenu));
+		m_hMenu = hMenu;
+		if(m_hMenu == NULL || (::GetMenuString(m_hMenu, t_nFirstID, m_szNoEntries, t_cchItemLen, MF_BYCOMMAND) == 0))
+		{
+			T* pT = static_cast<T*>(this);
+			pT;   // avoid level 4 warning
+			SecureHelper::strncpy_x(m_szNoEntries, _countof(m_szNoEntries), pT->GetMRUEmptyText(), _TRUNCATE);
+		}
+	}
+
+	int GetMaxEntries() const
+	{
+		return m_nMaxEntries;
+	}
+
+	void SetMaxEntries(int nMaxEntries)
+	{
+		ATLASSERT(nMaxEntries >= m_nMaxEntries_Min && nMaxEntries <= m_nMaxEntries_Max);
+		if(nMaxEntries < m_nMaxEntries_Min)
+			nMaxEntries = m_nMaxEntries_Min;
+		else if(nMaxEntries > m_nMaxEntries_Max)
+			nMaxEntries = m_nMaxEntries_Max;
+		m_nMaxEntries = nMaxEntries;
+	}
+
+	int GetMaxItemLength() const
+	{
+		return m_cchMaxItemLen;
+	}
+
+	void SetMaxItemLength(int cchMaxLen)
+	{
+		ATLASSERT((cchMaxLen >= m_cchMaxItemLen_Min && cchMaxLen <= m_cchMaxItemLen_Max) || cchMaxLen == -1);
+		if(cchMaxLen != -1)
+		{
+			if(cchMaxLen < m_cchMaxItemLen_Min)
+				cchMaxLen = m_cchMaxItemLen_Min;
+			else if(cchMaxLen > m_cchMaxItemLen_Max)
+				cchMaxLen = m_cchMaxItemLen_Max;
+		}
+		m_cchMaxItemLen = cchMaxLen;
+		T* pT = static_cast<T*>(this);
+		pT->UpdateMenu();
+	}
+
+// Operations
+	BOOL AddToList(LPCTSTR lpstrDocName)
+	{
+		_DocEntry de;
+		errno_t nRet = SecureHelper::strncpy_x(de.szDocName, _countof(de.szDocName), lpstrDocName, _TRUNCATE);
+		if(nRet != 0 && nRet != STRUNCATE)
+			return FALSE;
+
+		for(int i = 0; i < m_arrDocs.GetSize(); i++)
+		{
+			if(lstrcmpi(m_arrDocs[i].szDocName, lpstrDocName) == 0)
+			{
+				m_arrDocs.RemoveAt(i);
+				break;
+			}
+		}
+
+		if(m_arrDocs.GetSize() == m_nMaxEntries)
+			m_arrDocs.RemoveAt(0);
+
+		BOOL bRet = m_arrDocs.Add(de);
+		if(bRet)
+		{
+			T* pT = static_cast<T*>(this);
+			bRet = pT->UpdateMenu();
+		}
+		return bRet;
+	}
+
+	// This function is deprecated because it is not safe. 
+	// Use the version below that accepts the buffer length.
+#if (_MSC_VER >= 1300)
+	__declspec(deprecated)
+#endif
+	BOOL GetFromList(int /*nItemID*/, LPTSTR /*lpstrDocName*/)
+	{
+		ATLASSERT(FALSE);
+		return FALSE;
+	}
+
+	BOOL GetFromList(int nItemID, LPTSTR lpstrDocName, int cchLength)
+	{
+		int nIndex = m_arrDocs.GetSize() - (nItemID - t_nFirstID) - 1;
+		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
+			return FALSE;
+		if(lstrlen(m_arrDocs[nIndex].szDocName) >= cchLength)
+			return FALSE;
+		SecureHelper::strcpy_x(lpstrDocName, cchLength, m_arrDocs[nIndex].szDocName);
+
+		return TRUE;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	BOOL GetFromList(int nItemID, _CSTRING_NS::CString& strDocName)
+	{
+		int nIndex = m_arrDocs.GetSize() - (nItemID - t_nFirstID) - 1;
+		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
+			return FALSE;
+		strDocName = m_arrDocs[nIndex].szDocName;
+		return TRUE;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	BOOL RemoveFromList(int nItemID)
+	{
+		int nIndex = m_arrDocs.GetSize() - (nItemID - t_nFirstID) - 1;
+		BOOL bRet = m_arrDocs.RemoveAt(nIndex);
+		if(bRet)
+		{
+			T* pT = static_cast<T*>(this);
+			bRet = pT->UpdateMenu();
+		}
+		return bRet;
+	}
+
+	BOOL MoveToTop(int nItemID)
+	{
+		int nIndex = m_arrDocs.GetSize() - (nItemID - t_nFirstID) - 1;
+		if(nIndex < 0 || nIndex >= m_arrDocs.GetSize())
+			return FALSE;
+		_DocEntry de;
+		de = m_arrDocs[nIndex];
+		m_arrDocs.RemoveAt(nIndex);
+		BOOL bRet = m_arrDocs.Add(de);
+		if(bRet)
+		{
+			T* pT = static_cast<T*>(this);
+			bRet = pT->UpdateMenu();
+		}
+		return bRet;
+	}
+
+	BOOL ReadFromRegistry(LPCTSTR lpstrRegKey)
+	{
+		T* pT = static_cast<T*>(this);
+		CRegKeyEx rkParent;
+		CRegKeyEx rk;
+
+		LONG lRet = rkParent.Open(HKEY_CURRENT_USER, lpstrRegKey);
+		if(lRet != ERROR_SUCCESS)
+			return FALSE;
+		lRet = rk.Open(rkParent, pT->GetRegKeyName());
+		if(lRet != ERROR_SUCCESS)
+			return FALSE;
+
+		DWORD dwRet = 0;
+		lRet = rk.QueryDWORDValue(pT->GetRegCountName(), dwRet);
+		if(lRet != ERROR_SUCCESS)
+			return FALSE;
+		SetMaxEntries(dwRet);
+
+		m_arrDocs.RemoveAll();
+
+		TCHAR szRetString[t_cchItemLen] = { 0 };
+		_DocEntry de;
+
+		for(int nItem = m_nMaxEntries; nItem > 0; nItem--)
+		{
+			TCHAR szBuff[m_cchItemNameLen] = { 0 };
+			SecureHelper::wsprintf_x(szBuff, m_cchItemNameLen, pT->GetRegItemName(), nItem);
+			ULONG ulCount = t_cchItemLen;
+			lRet = rk.QueryStringValue(szBuff, szRetString, &ulCount);
+			if(lRet == ERROR_SUCCESS)
+			{
+				SecureHelper::strcpy_x(de.szDocName, _countof(de.szDocName), szRetString);
+				m_arrDocs.Add(de);
+			}
+		}
+
+		rk.Close();
+		rkParent.Close();
+
+		return pT->UpdateMenu();
+	}
+
+	BOOL WriteToRegistry(LPCTSTR lpstrRegKey)
+	{
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		CRegKeyEx rkParent;
+		CRegKeyEx rk;
+
+		LONG lRet = rkParent.Create(HKEY_CURRENT_USER, lpstrRegKey);
+		if(lRet != ERROR_SUCCESS)
+			return FALSE;
+		lRet = rk.Create(rkParent, pT->GetRegKeyName());
+		if(lRet != ERROR_SUCCESS)
+			return FALSE;
+
+		lRet = rk.SetDWORDValue(pT->GetRegCountName(), m_nMaxEntries);
+		ATLASSERT(lRet == ERROR_SUCCESS);
+
+		// set new values
+		int nItem;
+		for(nItem = m_arrDocs.GetSize(); nItem > 0; nItem--)
+		{
+			TCHAR szBuff[m_cchItemNameLen] = { 0 };
+			SecureHelper::wsprintf_x(szBuff, m_cchItemNameLen, pT->GetRegItemName(), nItem);
+			TCHAR szDocName[t_cchItemLen] = { 0 };
+			GetFromList(t_nFirstID + nItem - 1, szDocName, t_cchItemLen);
+			lRet = rk.SetStringValue(szBuff, szDocName);
+			ATLASSERT(lRet == ERROR_SUCCESS);
+		}
+
+		// delete unused keys
+		for(nItem = m_arrDocs.GetSize() + 1; nItem < m_nMaxEntries_Max; nItem++)
+		{
+			TCHAR szBuff[m_cchItemNameLen] = { 0 };
+			SecureHelper::wsprintf_x(szBuff, m_cchItemNameLen, pT->GetRegItemName(), nItem);
+			rk.DeleteValue(szBuff);
+		}
+
+		rk.Close();
+		rkParent.Close();
+
+		return TRUE;
+	}
+
+// Implementation
+	BOOL UpdateMenu()
+	{
+		if(m_hMenu == NULL)
+			return FALSE;
+		ATLASSERT(::IsMenu(m_hMenu));
+
+		int nItems = ::GetMenuItemCount(m_hMenu);
+		int nInsertPoint;
+		for(nInsertPoint = 0; nInsertPoint < nItems; nInsertPoint++)
+		{
+			CMenuItemInfo mi;
+			mi.fMask = MIIM_ID;
+			::GetMenuItemInfo(m_hMenu, nInsertPoint, TRUE, &mi);
+			if (mi.wID == t_nFirstID)
+				break;
+		}
+		ATLASSERT(nInsertPoint < nItems && "You need a menu item with an ID = t_nFirstID");
+
+		int nItem;
+		for(nItem = t_nFirstID; nItem < t_nFirstID + m_nMaxEntries; nItem++)
+		{
+			// keep the first one as an insertion point
+			if (nItem != t_nFirstID)
+				::DeleteMenu(m_hMenu, nItem, MF_BYCOMMAND);
+		}
+
+		TCHAR szItemText[t_cchItemLen + 6] = { 0 };   // add space for &, 2 digits, and a space
+		int nSize = m_arrDocs.GetSize();
+		nItem = 0;
+		if(nSize > 0)
+		{
+			for(nItem = 0; nItem < nSize; nItem++)
+			{
+				if(m_cchMaxItemLen == -1)
+				{
+					SecureHelper::wsprintf_x(szItemText, t_cchItemLen + 6, _T("&%i %s"), nItem + 1, m_arrDocs[nSize - 1 - nItem].szDocName);
+				}
+				else
+				{
+					TCHAR szBuff[t_cchItemLen] = { 0 };
+					T* pT = static_cast<T*>(this);
+					pT;   // avoid level 4 warning
+					bool bRet = pT->CompactDocumentName(szBuff, m_arrDocs[nSize - 1 - nItem].szDocName, m_cchMaxItemLen);
+					bRet;   // avoid level 4 warning
+					ATLASSERT(bRet);
+					SecureHelper::wsprintf_x(szItemText, t_cchItemLen + 6, _T("&%i %s"), nItem + 1, szBuff);
+				}
+				::InsertMenu(m_hMenu, nInsertPoint + nItem, MF_BYPOSITION | MF_STRING, t_nFirstID + nItem, szItemText);
+			}
+		}
+		else	// empty
+		{
+			::InsertMenu(m_hMenu, nInsertPoint, MF_BYPOSITION | MF_STRING, t_nFirstID, m_szNoEntries);
+			::EnableMenuItem(m_hMenu, t_nFirstID, MF_GRAYED);
+			nItem++;
+		}
+		::DeleteMenu(m_hMenu, nInsertPoint + nItem, MF_BYPOSITION);
+
+		return TRUE;
+	}
+
+// Overrideables
+	// override to provide a different method of compacting document names
+	static bool CompactDocumentName(LPTSTR lpstrOut, LPCTSTR lpstrIn, int cchLen)
+	{
+		return AtlCompactPath(lpstrOut, lpstrIn, cchLen);
+	}
+
+	static LPCTSTR GetRegKeyName()
+	{
+		return _T("Recent Document List");
+	}
+
+	static LPCTSTR GetRegCountName()
+	{
+		return _T("DocumentCount");
+	}
+
+	static LPCTSTR GetRegItemName()
+	{
+		// Note: This string is a format string used with wsprintf().
+		// Resulting formatted string must be m_cchItemNameLen or less 
+		// characters long, including the terminating null character.
+		return _T("Document%i");
+	}
+
+	static LPCTSTR GetMRUEmptyText()
+	{
+		return _WTL_MRUEMPTY_TEXT;
+	}
+};
+
+class CRecentDocumentList : public CRecentDocumentListBase<CRecentDocumentList>
+{
+public:
+// nothing here
+};
+
+#endif // _WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFindFile - file search helper class
+
+class CFindFile
+{
+public:
+// Data members
+	WIN32_FIND_DATA m_fd;
+	TCHAR m_lpszRoot[MAX_PATH];
+	TCHAR m_chDirSeparator;
+	HANDLE m_hFind;
+	BOOL m_bFound;
+
+// Constructor/destructor
+	CFindFile() : m_hFind(NULL), m_chDirSeparator(_T('\\')), m_bFound(FALSE)
+	{ }
+
+	~CFindFile()
+	{
+		Close();
+	}
+
+// Attributes
+	ULONGLONG GetFileSize() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		ULARGE_INTEGER nFileSize = { 0 };
+
+		if(m_bFound)
+		{
+			nFileSize.LowPart = m_fd.nFileSizeLow;
+			nFileSize.HighPart = m_fd.nFileSizeHigh;
+		}
+		else
+		{
+			nFileSize.QuadPart = 0;
+		}
+
+		return nFileSize.QuadPart;
+	}
+
+	BOOL GetFileName(LPTSTR lpstrFileName, int cchLength) const
+	{
+		ATLASSERT(m_hFind != NULL);
+		if(lstrlen(m_fd.cFileName) >= cchLength)
+			return FALSE;
+
+		if(m_bFound)
+			SecureHelper::strcpy_x(lpstrFileName, cchLength, m_fd.cFileName);
+
+		return m_bFound;
+	}
+
+	BOOL GetFilePath(LPTSTR lpstrFilePath, int cchLength) const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		int nLen = lstrlen(m_lpszRoot);
+#ifndef _WIN32_WCE
+		ATLASSERT(nLen > 0);
+		if(nLen == 0)
+			return FALSE;
+
+		bool bAddSep = (m_lpszRoot[nLen - 1] != _T('\\') && m_lpszRoot[nLen - 1] !=_T('/'));
+#else // CE specific
+		// allow diskless devices (nLen == 0)
+		bool bAddSep = ((nLen == 0) || (m_lpszRoot[nLen - 1] != _T('\\') && m_lpszRoot[nLen - 1] !=_T('/')));
+#endif // _WIN32_WCE
+
+		if((lstrlen(m_lpszRoot) + (bAddSep ?  1 : 0)) >= cchLength)
+			return FALSE;
+
+		SecureHelper::strcpy_x(lpstrFilePath, cchLength, m_lpszRoot);
+
+		if(bAddSep)
+		{
+			TCHAR szSeparator[2] = { m_chDirSeparator, 0 };
+			SecureHelper::strcat_x(lpstrFilePath, cchLength, szSeparator);
+		}
+
+		SecureHelper::strcat_x(lpstrFilePath, cchLength, m_fd.cFileName);
+
+		return TRUE;
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetFileTitle(LPTSTR lpstrFileTitle, int cchLength) const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		TCHAR szBuff[MAX_PATH] = { 0 };
+		if(!GetFileName(szBuff, MAX_PATH))
+			return FALSE;
+
+		if(lstrlen(szBuff) >= cchLength || cchLength < 1)
+			return FALSE;
+
+		// find the last dot
+		LPTSTR pstrDot  = MinCrtHelper::_strrchr(szBuff, _T('.'));
+		if(pstrDot != NULL)
+			*pstrDot = 0;
+
+		SecureHelper::strcpy_x(lpstrFileTitle, cchLength, szBuff);
+
+		return TRUE;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL GetFileURL(LPTSTR lpstrFileURL, int cchLength) const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		TCHAR szBuff[MAX_PATH] = { 0 };
+		if(!GetFilePath(szBuff, MAX_PATH))
+			return FALSE;
+		LPCTSTR lpstrFileURLPrefix = _T("file://");
+		if(lstrlen(szBuff) + lstrlen(lpstrFileURLPrefix) >= cchLength)
+			return FALSE;
+		SecureHelper::strcpy_x(lpstrFileURL, cchLength, lpstrFileURLPrefix);
+		SecureHelper::strcat_x(lpstrFileURL, cchLength, szBuff);
+
+		return TRUE;
+	}
+
+	BOOL GetRoot(LPTSTR lpstrRoot, int cchLength) const
+	{
+		ATLASSERT(m_hFind != NULL);
+		if(lstrlen(m_lpszRoot) >= cchLength)
+			return FALSE;
+
+		SecureHelper::strcpy_x(lpstrRoot, cchLength, m_lpszRoot);
+
+		return TRUE;
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	_CSTRING_NS::CString GetFileName() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		_CSTRING_NS::CString ret;
+
+		if(m_bFound)
+			ret = m_fd.cFileName;
+		return ret;
+	}
+
+	_CSTRING_NS::CString GetFilePath() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		_CSTRING_NS::CString strResult = m_lpszRoot;
+		int nLen = strResult.GetLength();
+#ifndef _WIN32_WCE
+		ATLASSERT(nLen > 0);
+		if(nLen == 0)
+			return strResult;
+
+		if((strResult[nLen - 1] != _T('\\')) && (strResult[nLen - 1] != _T('/')))
+#else // CE specific
+		// allow diskless devices (nLen == 0)
+		if((nLen == 0) || ((strResult[nLen - 1] != _T('\\')) && (strResult[nLen - 1] != _T('/'))))
+#endif // _WIN32_WCE
+			strResult += m_chDirSeparator;
+		strResult += GetFileName();
+		return strResult;
+	}
+
+#ifndef _WIN32_WCE
+	_CSTRING_NS::CString GetFileTitle() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		_CSTRING_NS::CString strResult;
+		GetFileTitle(strResult.GetBuffer(MAX_PATH), MAX_PATH);
+		strResult.ReleaseBuffer();
+
+		return strResult;
+	}
+#endif // !_WIN32_WCE
+
+	_CSTRING_NS::CString GetFileURL() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		_CSTRING_NS::CString strResult("file://");
+		strResult += GetFilePath();
+		return strResult;
+	}
+
+	_CSTRING_NS::CString GetRoot() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		_CSTRING_NS::CString str = m_lpszRoot;
+		return str;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	BOOL GetLastWriteTime(FILETIME* pTimeStamp) const
+	{
+		ATLASSERT(m_hFind != NULL);
+		ATLASSERT(pTimeStamp != NULL);
+
+		if(m_bFound && pTimeStamp != NULL)
+		{
+			*pTimeStamp = m_fd.ftLastWriteTime;
+			return TRUE;
+		}
+
+		return FALSE;
+	}
+
+	BOOL GetLastAccessTime(FILETIME* pTimeStamp) const
+	{
+		ATLASSERT(m_hFind != NULL);
+		ATLASSERT(pTimeStamp != NULL);
+
+		if(m_bFound && pTimeStamp != NULL)
+		{
+			*pTimeStamp = m_fd.ftLastAccessTime;
+			return TRUE;
+		}
+
+		return FALSE;
+	}
+
+	BOOL GetCreationTime(FILETIME* pTimeStamp) const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		if(m_bFound && pTimeStamp != NULL)
+		{
+			*pTimeStamp = m_fd.ftCreationTime;
+			return TRUE;
+		}
+
+		return FALSE;
+	}
+
+	BOOL MatchesMask(DWORD dwMask) const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		if(m_bFound)
+			return ((m_fd.dwFileAttributes & dwMask) != 0);
+
+		return FALSE;
+	}
+
+	BOOL IsDots() const
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		// return TRUE if the file name is "." or ".." and
+		// the file is a directory
+
+		BOOL bResult = FALSE;
+		if(m_bFound && IsDirectory())
+		{
+			if(m_fd.cFileName[0] == _T('.') && (m_fd.cFileName[1] == _T('\0') || (m_fd.cFileName[1] == _T('.') && m_fd.cFileName[2] == _T('\0'))))
+				bResult = TRUE;
+		}
+
+		return bResult;
+	}
+
+	BOOL IsReadOnly() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_READONLY);
+	}
+
+	BOOL IsDirectory() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_DIRECTORY);
+	}
+
+	BOOL IsCompressed() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_COMPRESSED);
+	}
+
+	BOOL IsSystem() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_SYSTEM);
+	}
+
+	BOOL IsHidden() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_HIDDEN);
+	}
+
+	BOOL IsTemporary() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_TEMPORARY);
+	}
+
+	BOOL IsNormal() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_NORMAL);
+	}
+
+	BOOL IsArchived() const
+	{
+		return MatchesMask(FILE_ATTRIBUTE_ARCHIVE);
+	}
+
+// Operations
+	BOOL FindFile(LPCTSTR pstrName = NULL)
+	{
+		Close();
+
+		if(pstrName == NULL)
+		{
+			pstrName = _T("*.*");
+		}
+		else if(lstrlen(pstrName) >= MAX_PATH)
+		{
+			ATLASSERT(FALSE);
+			return FALSE;
+		}
+
+		SecureHelper::strcpy_x(m_fd.cFileName, _countof(m_fd.cFileName), pstrName);
+
+		m_hFind = ::FindFirstFile(pstrName, &m_fd);
+
+		if(m_hFind == INVALID_HANDLE_VALUE)
+			return FALSE;
+
+#ifndef _WIN32_WCE
+		bool bFullPath = (::GetFullPathName(pstrName, MAX_PATH, m_lpszRoot, NULL) != 0);
+#else // CE specific
+		errno_t nRet = SecureHelper::strncpy_x(m_lpszRoot, _countof(m_lpszRoot), pstrName, _TRUNCATE);
+		bool bFullPath = (nRet == 0 || nRet == STRUNCATE);
+#endif // _WIN32_WCE
+
+		// passed name isn't a valid path but was found by the API
+		ATLASSERT(bFullPath);
+		if(!bFullPath)
+		{
+			Close();
+			::SetLastError(ERROR_INVALID_NAME);
+			return FALSE;
+		}
+		else
+		{
+			// find the last forward or backward whack
+			LPTSTR pstrBack  = MinCrtHelper::_strrchr(m_lpszRoot, _T('\\'));
+			LPTSTR pstrFront = MinCrtHelper::_strrchr(m_lpszRoot, _T('/'));
+
+			if(pstrFront != NULL || pstrBack != NULL)
+			{
+				if(pstrFront == NULL)
+					pstrFront = m_lpszRoot;
+				if(pstrBack == NULL)
+					pstrBack = m_lpszRoot;
+
+				// from the start to the last whack is the root
+
+				if(pstrFront >= pstrBack)
+					*pstrFront = _T('\0');
+				else
+					*pstrBack = _T('\0');
+			}
+		}
+
+		m_bFound = TRUE;
+
+		return TRUE;
+	}
+
+	BOOL FindNextFile()
+	{
+		ATLASSERT(m_hFind != NULL);
+
+		if(m_hFind == NULL)
+			return FALSE;
+
+		if(!m_bFound)
+			return FALSE;
+
+		m_bFound = ::FindNextFile(m_hFind, &m_fd);
+
+		return m_bFound;
+	}
+
+	void Close()
+	{
+		m_bFound = FALSE;
+
+		if(m_hFind != NULL && m_hFind != INVALID_HANDLE_VALUE)
+		{
+			::FindClose(m_hFind);
+			m_hFind = NULL;
+		}
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Global functions for stock GDI objects
+
+inline HPEN AtlGetStockPen(int nPen)
+{
+#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN32_WCE)
+	ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN || nPen == DC_PEN);
+#else
+	ATLASSERT(nPen == WHITE_PEN || nPen == BLACK_PEN || nPen == NULL_PEN);
+#endif
+	return (HPEN)::GetStockObject(nPen);
+}
+
+inline HBRUSH AtlGetStockBrush(int nBrush)
+{
+#if (_WIN32_WINNT >= 0x0500) && !defined(_WIN32_WCE)
+	ATLASSERT((nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH) || nBrush == DC_BRUSH);
+#else
+	ATLASSERT(nBrush >= WHITE_BRUSH && nBrush <= HOLLOW_BRUSH);
+#endif
+	return (HBRUSH)::GetStockObject(nBrush);
+}
+
+inline HFONT AtlGetStockFont(int nFont)
+{
+#ifndef _WIN32_WCE
+	ATLASSERT((nFont >= OEM_FIXED_FONT && nFont <= SYSTEM_FIXED_FONT) || nFont == DEFAULT_GUI_FONT);
+#else // CE specific
+	ATLASSERT(nFont == SYSTEM_FONT);
+#endif // _WIN32_WCE
+	return (HFONT)::GetStockObject(nFont);
+}
+
+inline HPALETTE AtlGetStockPalette(int nPalette)
+{
+	ATLASSERT(nPalette == DEFAULT_PALETTE); // the only one supported
+	return (HPALETTE)::GetStockObject(nPalette);
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Global function for compacting a path by replacing parts with ellipsis
+
+// helper for multi-byte character sets
+inline bool _IsDBCSTrailByte(LPCTSTR lpstr, int nChar)
+{
+#ifndef _UNICODE
+	int i = nChar;
+	for( ; i > 0; i--)
+	{
+		if(!::IsDBCSLeadByte(lpstr[i - 1]))
+			break;
+	}
+	return ((nChar > 0) && (((nChar - i) & 1) != 0));
+#else // _UNICODE
+	lpstr; nChar;
+	return false;
+#endif // _UNICODE
+}
+
+inline bool AtlCompactPath(LPTSTR lpstrOut, LPCTSTR lpstrIn, int cchLen)
+{
+	ATLASSERT(lpstrOut != NULL);
+	ATLASSERT(lpstrIn != NULL);
+	ATLASSERT(cchLen > 0);
+
+	LPCTSTR szEllipsis = _T("...");
+	const int cchEndEllipsis = 3;
+	const int cchMidEllipsis = 4;
+
+	if(lstrlen(lpstrIn) < cchLen)
+	{
+		SecureHelper::strcpy_x(lpstrOut, cchLen, lpstrIn);
+		return true;
+	}
+
+	lpstrOut[0] = 0;
+
+	// check if the separator is a slash or a backslash
+	TCHAR chSlash = _T('\\');
+	for(LPTSTR lpstr = (LPTSTR)lpstrIn; *lpstr != 0; lpstr = ::CharNext(lpstr))
+	{
+		if((*lpstr == _T('/')) || (*lpstr == _T('\\')))
+			chSlash = *lpstr;
+	}
+
+	// find the filename portion of the path
+	LPCTSTR lpstrFileName = lpstrIn;
+	for(LPCTSTR pPath = lpstrIn; *pPath; pPath = ::CharNext(pPath))
+	{
+		if((pPath[0] == _T('\\') || pPath[0] == _T(':') || pPath[0] == _T('/'))
+				&& pPath[1] && pPath[1] != _T('\\') && pPath[1] != _T('/'))
+			lpstrFileName = pPath + 1;
+	}
+	int cchFileName = lstrlen(lpstrFileName);
+
+	// handle just the filename without a path
+	if(lpstrFileName == lpstrIn && cchLen > cchEndEllipsis)
+	{
+		bool bRet = (SecureHelper::strncpy_x(lpstrOut, cchLen, lpstrIn, cchLen - cchEndEllipsis - 1) == 0);
+		if(bRet)
+		{
+#ifndef _UNICODE
+			if(_IsDBCSTrailByte(lpstrIn, cchLen - cchEndEllipsis))
+				lpstrOut[cchLen - cchEndEllipsis - 1] = 0;
+#endif // _UNICODE
+			SecureHelper::strcat_x(lpstrOut, cchLen, szEllipsis);
+		}
+		return bRet;
+	}
+
+	// handle just ellipsis
+	if((cchLen < (cchMidEllipsis + cchEndEllipsis)))
+	{
+		for(int i = 0; i < cchLen - 1; i++)
+			lpstrOut[i] = ((i + 1) == cchMidEllipsis) ? chSlash : _T('.');
+		lpstrOut[cchLen - 1] = 0;
+		return true;
+	}
+
+	// calc how much we have to copy
+	int cchToCopy = cchLen - (cchMidEllipsis + cchFileName) - 1;
+
+	if(cchToCopy < 0)
+		cchToCopy = 0;
+
+#ifndef _UNICODE
+	if(cchToCopy > 0 && _IsDBCSTrailByte(lpstrIn, cchToCopy))
+		cchToCopy--;
+#endif // _UNICODE
+
+	bool bRet = (SecureHelper::strncpy_x(lpstrOut, cchLen, lpstrIn, cchToCopy) == 0);
+	if(!bRet)
+		return false;
+
+	// add ellipsis
+	SecureHelper::strcat_x(lpstrOut, cchLen, szEllipsis);
+	if(!bRet)
+		return false;
+	TCHAR szSlash[2] = { chSlash, 0 };
+	SecureHelper::strcat_x(lpstrOut, cchLen, szSlash);
+	if(!bRet)
+		return false;
+
+	// add filename (and ellipsis, if needed)
+	if(cchLen > (cchMidEllipsis + cchFileName))
+	{
+		SecureHelper::strcat_x(lpstrOut, cchLen, lpstrFileName);
+	}
+	else
+	{
+		cchToCopy = cchLen - cchMidEllipsis - cchEndEllipsis - 1;
+#ifndef _UNICODE
+		if(cchToCopy > 0 && _IsDBCSTrailByte(lpstrFileName, cchToCopy))
+			cchToCopy--;
+#endif // _UNICODE
+		bRet = (SecureHelper::strncpy_x(&lpstrOut[cchMidEllipsis], cchLen - cchMidEllipsis, lpstrFileName, cchToCopy) == 0);
+		if(bRet)
+			SecureHelper::strcat_x(lpstrOut, cchLen, szEllipsis);
+	}
+
+	return bRet;
+}
+
+}; // namespace WTL
+
+#endif // __ATLMISC_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlprint.h b/GLideN64/src/GLideNUI-wtl/WTL/atlprint.h
new file mode 100644
index 00000000..03971a0e
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlprint.h
@@ -0,0 +1,1109 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLPRINT_H__
+#define __ATLPRINT_H__
+
+#pragma once
+
+#ifdef _WIN32_WCE
+	#error atlprint.h is not supported on Windows CE
+#endif
+
+#ifndef __ATLAPP_H__
+	#error atlprint.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atlprint.h requires atlwin.h to be included first
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CPrinterInfo<t_nInfo>
+// CPrinterT<t_bManaged>
+// CDevModeT<t_bManaged>
+// CPrinterDC
+// CPrintJobInfo
+// CPrintJob
+// CPrintPreview
+// CPrintPreviewWindowImpl<T, TBase, TWinTraits>
+// CPrintPreviewWindow
+// CZoomPrintPreviewWindowImpl<T, TBase, TWinTraits>
+// CZoomPrintPreviewWindow
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrinterInfo - This class wraps all of the PRINTER_INFO_* structures
+//                and provided by ::GetPrinter.
+
+template <unsigned int t_nInfo>
+class _printer_info
+{
+public:
+	typedef void infotype;
+};
+
+template <> class _printer_info<1> { public: typedef PRINTER_INFO_1 infotype; };
+template <> class _printer_info<2> { public: typedef PRINTER_INFO_2 infotype; };
+template <> class _printer_info<3> { public: typedef PRINTER_INFO_3 infotype; };
+template <> class _printer_info<4> { public: typedef PRINTER_INFO_4 infotype; };
+template <> class _printer_info<5> { public: typedef PRINTER_INFO_5 infotype; };
+template <> class _printer_info<6> { public: typedef PRINTER_INFO_6 infotype; };
+template <> class _printer_info<7> { public: typedef PRINTER_INFO_7 infotype; };
+// these are not in the old (vc6.0) headers
+#ifdef _ATL_USE_NEW_PRINTER_INFO
+template <> class _printer_info<8> { public: typedef PRINTER_INFO_8 infotype; };
+template <> class _printer_info<9> { public: typedef PRINTER_INFO_9 infotype; };
+#endif // _ATL_USE_NEW_PRINTER_INFO
+
+
+template <unsigned int t_nInfo>
+class CPrinterInfo
+{
+public:
+// Data members
+	typename _printer_info<t_nInfo>::infotype* m_pi;
+
+// Constructor/destructor
+	CPrinterInfo() : m_pi(NULL)
+	{ }
+
+	CPrinterInfo(HANDLE hPrinter) : m_pi(NULL)
+	{
+		GetPrinterInfo(hPrinter);
+	}
+
+	~CPrinterInfo()
+	{
+		Cleanup();
+	}
+
+// Operations
+	bool GetPrinterInfo(HANDLE hPrinter)
+	{
+		Cleanup();
+		return GetPrinterInfoHelper(hPrinter, (BYTE**)&m_pi, t_nInfo);
+	}
+
+// Implementation
+	void Cleanup()
+	{
+		delete [] (BYTE*)m_pi;
+		m_pi = NULL;
+	}
+
+	static bool GetPrinterInfoHelper(HANDLE hPrinter, BYTE** pi, int nIndex)
+	{
+		ATLASSERT(pi != NULL);
+		DWORD dw = 0;
+		BYTE* pb = NULL;
+		::GetPrinter(hPrinter, nIndex, NULL, 0, &dw);
+		if (dw > 0)
+		{
+			ATLTRY(pb = new BYTE[dw]);
+			if (pb != NULL)
+			{
+				memset(pb, 0, dw);
+				DWORD dwNew;
+				if (!::GetPrinter(hPrinter, nIndex, pb, dw, &dwNew))
+				{
+					delete [] pb;
+					pb = NULL;
+				}
+			}
+		}
+		*pi = pb;
+		return (pb != NULL);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrinter - Wrapper class for a HANDLE to a printer
+
+template <bool t_bManaged>
+class CPrinterT
+{
+public:
+// Data members
+	HANDLE m_hPrinter;
+
+// Constructor/destructor
+	CPrinterT(HANDLE hPrinter = NULL) : m_hPrinter(hPrinter)
+	{ }
+
+	~CPrinterT()
+	{
+		ClosePrinter();
+	}
+
+// Operations
+	CPrinterT& operator =(HANDLE hPrinter)
+	{
+		if (hPrinter != m_hPrinter)
+		{
+			ClosePrinter();
+			m_hPrinter = hPrinter;
+		}
+		return *this;
+	}
+
+	bool IsNull() const { return (m_hPrinter == NULL); }
+
+	bool OpenPrinter(HANDLE hDevNames, const DEVMODE* pDevMode = NULL)
+	{
+		bool b = false;
+		DEVNAMES* pdn = (DEVNAMES*)::GlobalLock(hDevNames);
+		if (pdn != NULL)
+		{
+			LPTSTR lpszPrinterName = (LPTSTR)pdn + pdn->wDeviceOffset;
+			b = OpenPrinter(lpszPrinterName, pDevMode);
+			::GlobalUnlock(hDevNames);
+		}
+		return b;
+	}
+
+	bool OpenPrinter(LPCTSTR lpszPrinterName, const DEVMODE* pDevMode = NULL)
+	{
+		ClosePrinter();
+		PRINTER_DEFAULTS pdefs = { NULL, (DEVMODE*)pDevMode, PRINTER_ACCESS_USE };
+		::OpenPrinter((LPTSTR) lpszPrinterName, &m_hPrinter, (pDevMode == NULL) ? NULL : &pdefs);
+
+		return (m_hPrinter != NULL);
+	}
+
+	bool OpenPrinter(LPCTSTR lpszPrinterName, PRINTER_DEFAULTS* pprintdefs)
+	{
+		ClosePrinter();
+		::OpenPrinter((LPTSTR) lpszPrinterName, &m_hPrinter, pprintdefs);
+		return (m_hPrinter != NULL);
+	}
+
+	bool OpenDefaultPrinter(const DEVMODE* pDevMode = NULL)
+	{
+		ClosePrinter();
+		const int cchBuff = 512;
+		TCHAR buffer[cchBuff];
+		buffer[0] = 0;
+		::GetProfileString(_T("windows"), _T("device"), _T(",,,"), buffer, cchBuff);
+		int nLen = lstrlen(buffer);
+		if (nLen != 0)
+		{
+			LPTSTR lpsz = buffer;
+			while (*lpsz)
+			{
+				if (*lpsz == _T(','))
+				{
+					*lpsz = 0;
+					break;
+				}
+				lpsz = CharNext(lpsz);
+			}
+			PRINTER_DEFAULTS pdefs = { NULL, (DEVMODE*)pDevMode, PRINTER_ACCESS_USE };
+			::OpenPrinter(buffer, &m_hPrinter, (pDevMode == NULL) ? NULL : &pdefs);
+		}
+		return m_hPrinter != NULL;
+	}
+
+	void ClosePrinter()
+	{
+		if (m_hPrinter != NULL)
+		{
+			if (t_bManaged)
+				::ClosePrinter(m_hPrinter);
+			m_hPrinter = NULL;
+		}
+	}
+
+	bool PrinterProperties(HWND hWnd = NULL)
+	{
+		if (hWnd == NULL)
+			hWnd = ::GetActiveWindow();
+		return !!::PrinterProperties(hWnd, m_hPrinter);
+	}
+
+	HANDLE CopyToHDEVNAMES() const
+	{
+		HANDLE h = NULL;
+		CPrinterInfo<5> pinfon5;
+		CPrinterInfo<2> pinfon2;
+		LPTSTR lpszPrinterName = NULL;
+		// Some printers fail for PRINTER_INFO_5 in some situations
+		if (pinfon5.GetPrinterInfo(m_hPrinter))
+			lpszPrinterName = pinfon5.m_pi->pPrinterName;
+		else if (pinfon2.GetPrinterInfo(m_hPrinter))
+			lpszPrinterName = pinfon2.m_pi->pPrinterName;
+		if (lpszPrinterName != NULL)
+		{
+			int nLen = sizeof(DEVNAMES) + (lstrlen(lpszPrinterName) + 1) * sizeof(TCHAR);
+			h = ::GlobalAlloc(GMEM_MOVEABLE, nLen);
+			BYTE* pv = (BYTE*)::GlobalLock(h);
+			DEVNAMES* pdev = (DEVNAMES*)pv;
+			if (pv != NULL)
+			{
+				memset(pv, 0, nLen);
+				pdev->wDeviceOffset = sizeof(DEVNAMES) / sizeof(TCHAR);
+				pv = pv + sizeof(DEVNAMES); // now points to end
+				SecureHelper::strcpy_x((LPTSTR)pv, lstrlen(lpszPrinterName) + 1, lpszPrinterName);
+				::GlobalUnlock(h);
+			}
+		}
+		return h;
+	}
+
+	HDC CreatePrinterDC(const DEVMODE* pdm = NULL) const
+	{
+		CPrinterInfo<5> pinfo5;
+		CPrinterInfo<2> pinfo2;
+		HDC hDC = NULL;
+		LPTSTR lpszPrinterName = NULL;
+		// Some printers fail for PRINTER_INFO_5 in some situations
+		if (pinfo5.GetPrinterInfo(m_hPrinter))
+			lpszPrinterName = pinfo5.m_pi->pPrinterName;
+		else if (pinfo2.GetPrinterInfo(m_hPrinter))
+			lpszPrinterName = pinfo2.m_pi->pPrinterName;
+		if (lpszPrinterName != NULL)
+			hDC = ::CreateDC(NULL, lpszPrinterName, NULL, pdm);
+		return hDC;
+	}
+
+	HDC CreatePrinterIC(const DEVMODE* pdm = NULL) const
+	{
+		CPrinterInfo<5> pinfo5;
+		CPrinterInfo<2> pinfo2;
+		HDC hDC = NULL;
+		LPTSTR lpszPrinterName = NULL;
+		// Some printers fail for PRINTER_INFO_5 in some situations
+		if (pinfo5.GetPrinterInfo(m_hPrinter))
+			lpszPrinterName = pinfo5.m_pi->pPrinterName;
+		else if (pinfo2.GetPrinterInfo(m_hPrinter))
+			lpszPrinterName = pinfo2.m_pi->pPrinterName;
+		if (lpszPrinterName != NULL)
+			hDC = ::CreateIC(NULL, lpszPrinterName, NULL, pdm);
+		return hDC;
+	}
+
+	void Attach(HANDLE hPrinter)
+	{
+		ClosePrinter();
+		m_hPrinter = hPrinter;
+	}
+
+	HANDLE Detach()
+	{
+		HANDLE hPrinter = m_hPrinter;
+		m_hPrinter = NULL;
+		return hPrinter;
+	}
+
+	operator HANDLE() const { return m_hPrinter; }
+};
+
+typedef CPrinterT<false>   CPrinterHandle;
+typedef CPrinterT<true>    CPrinter;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CDevMode - Wrapper class for DEVMODE
+
+template <bool t_bManaged>
+class CDevModeT
+{
+public:
+// Data members
+	HANDLE m_hDevMode;
+	DEVMODE* m_pDevMode;
+
+// Constructor/destructor
+	CDevModeT(HANDLE hDevMode = NULL) : m_hDevMode(hDevMode)
+	{
+		m_pDevMode = (m_hDevMode != NULL) ? (DEVMODE*)::GlobalLock(m_hDevMode) : NULL;
+	}
+
+	~CDevModeT()
+	{
+		Cleanup();
+	}
+
+// Operations
+	CDevModeT<t_bManaged>& operator =(HANDLE hDevMode)
+	{
+		Attach(hDevMode);
+		return *this;
+	}
+
+	void Attach(HANDLE hDevModeNew)
+	{
+		Cleanup();
+		m_hDevMode = hDevModeNew;
+		m_pDevMode = (m_hDevMode != NULL) ? (DEVMODE*)::GlobalLock(m_hDevMode) : NULL;
+	}
+
+	HANDLE Detach()
+	{
+		if (m_hDevMode != NULL)
+			::GlobalUnlock(m_hDevMode);
+		HANDLE hDevMode = m_hDevMode;
+		m_hDevMode = NULL;
+		return hDevMode;
+	}
+
+	bool IsNull() const { return (m_hDevMode == NULL); }
+
+	bool CopyFromPrinter(HANDLE hPrinter)
+	{
+		CPrinterInfo<2> pinfo;
+		bool b = pinfo.GetPrinterInfo(hPrinter);
+		if (b)
+		 b = CopyFromDEVMODE(pinfo.m_pi->pDevMode);
+		return b;
+	}
+
+	bool CopyFromDEVMODE(const DEVMODE* pdm)
+	{
+		if (pdm == NULL)
+			return false;
+		int nSize = pdm->dmSize + pdm->dmDriverExtra;
+		HANDLE h = ::GlobalAlloc(GMEM_MOVEABLE, nSize);
+		if (h != NULL)
+		{
+			void* p = ::GlobalLock(h);
+			SecureHelper::memcpy_x(p, nSize, pdm, nSize);
+			::GlobalUnlock(h);
+		}
+		Attach(h);
+		return (h != NULL);
+	}
+
+	bool CopyFromHDEVMODE(HANDLE hdm)
+	{
+		bool b = false;
+		if (hdm != NULL)
+		{
+			DEVMODE* pdm = (DEVMODE*)::GlobalLock(hdm);
+			b = CopyFromDEVMODE(pdm);
+			::GlobalUnlock(hdm);
+		}
+		return b;
+	}
+
+	HANDLE CopyToHDEVMODE()
+	{
+		if ((m_hDevMode == NULL) || (m_pDevMode == NULL))
+			return NULL;
+		int nSize = m_pDevMode->dmSize + m_pDevMode->dmDriverExtra;
+		HANDLE h = ::GlobalAlloc(GMEM_MOVEABLE, nSize);
+		if (h != NULL)
+		{
+			void* p = ::GlobalLock(h);
+			SecureHelper::memcpy_x(p, nSize, m_pDevMode, nSize);
+			::GlobalUnlock(h);
+		}
+		return h;
+	}
+
+	// If this devmode was for another printer, this will create a new devmode
+	// based on the existing devmode, but retargeted at the new printer
+	bool UpdateForNewPrinter(HANDLE hPrinter)
+	{
+		bool bRet = false;
+		LONG nLen = ::DocumentProperties(NULL, hPrinter, NULL, NULL, NULL, 0);
+		CTempBuffer<DEVMODE, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		DEVMODE* pdm = buff.AllocateBytes(nLen);
+		if(pdm != NULL)
+		{
+			memset(pdm, 0, nLen);
+			LONG l = ::DocumentProperties(NULL, hPrinter, NULL, pdm, m_pDevMode, DM_IN_BUFFER | DM_OUT_BUFFER);
+			if (l == IDOK)
+				bRet = CopyFromDEVMODE(pdm);
+		}
+
+		return bRet;
+	}
+
+	bool DocumentProperties(HANDLE hPrinter, HWND hWnd = NULL)
+	{
+		CPrinterInfo<1> pi;
+		pi.GetPrinterInfo(hPrinter);
+		if (hWnd == NULL)
+			hWnd = ::GetActiveWindow();
+
+		bool bRet = false;
+		LONG nLen = ::DocumentProperties(hWnd, hPrinter, pi.m_pi->pName, NULL, NULL, 0);
+		CTempBuffer<DEVMODE, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		DEVMODE* pdm = buff.AllocateBytes(nLen);
+		if(pdm != NULL)
+		{
+			memset(pdm, 0, nLen);
+			LONG l = ::DocumentProperties(hWnd, hPrinter, pi.m_pi->pName, pdm, m_pDevMode, DM_IN_BUFFER | DM_OUT_BUFFER | DM_PROMPT);
+			if (l == IDOK)
+				bRet = CopyFromDEVMODE(pdm);
+		}
+
+		return bRet;
+	}
+
+	operator HANDLE() const { return m_hDevMode; }
+
+	operator DEVMODE*() const { return m_pDevMode; }
+
+// Implementation
+	void Cleanup()
+	{
+		if (m_hDevMode != NULL)
+		{
+			::GlobalUnlock(m_hDevMode);
+			if(t_bManaged)
+				::GlobalFree(m_hDevMode);
+			m_hDevMode = NULL;
+		}
+	}
+};
+
+typedef CDevModeT<false>   CDevModeHandle;
+typedef CDevModeT<true>    CDevMode;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrinterDC
+
+class CPrinterDC : public CDC
+{
+public:
+// Constructors/destructor
+	CPrinterDC()
+	{
+		CPrinter printer;
+		printer.OpenDefaultPrinter();
+		Attach(printer.CreatePrinterDC());
+		ATLASSERT(m_hDC != NULL);
+	}
+
+	CPrinterDC(HANDLE hPrinter, const DEVMODE* pdm = NULL)
+	{
+		CPrinterHandle p;
+		p.Attach(hPrinter);
+		Attach(p.CreatePrinterDC(pdm));
+		ATLASSERT(m_hDC != NULL);
+	}
+
+	~CPrinterDC()
+	{
+		DeleteDC();
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrintJob - Wraps a set of tasks for a specific printer (StartDoc/EndDoc)
+//             Handles aborting, background printing
+
+// Defines callbacks used by CPrintJob (not a COM interface)
+class ATL_NO_VTABLE IPrintJobInfo
+{
+public:
+	virtual void BeginPrintJob(HDC hDC) = 0;                // allocate handles needed, etc.
+	virtual void EndPrintJob(HDC hDC, bool bAborted) = 0;   // free handles, etc.
+	virtual void PrePrintPage(UINT nPage, HDC hDC) = 0;
+	virtual bool PrintPage(UINT nPage, HDC hDC) = 0;
+	virtual void PostPrintPage(UINT nPage, HDC hDC) = 0;
+	// If you want per page devmodes, return the DEVMODE* to use for nPage.
+	// You can optimize by only returning a new DEVMODE* when it is different
+	// from the one for nLastPage, otherwise return NULL.
+	// When nLastPage==0, the current DEVMODE* will be the default passed to
+	// StartPrintJob.
+	// Note: During print preview, nLastPage will always be "0".
+	virtual DEVMODE* GetNewDevModeForPage(UINT nLastPage, UINT nPage) = 0;
+	virtual bool IsValidPage(UINT nPage) = 0;
+};
+
+// Provides a default implementatin for IPrintJobInfo
+// Typically, MI'd into a document or view class
+class ATL_NO_VTABLE CPrintJobInfo : public IPrintJobInfo
+{
+public:
+	virtual void BeginPrintJob(HDC /*hDC*/)   // allocate handles needed, etc
+	{
+	}
+
+	virtual void EndPrintJob(HDC /*hDC*/, bool /*bAborted*/)   // free handles, etc
+	{
+	}
+
+	virtual void PrePrintPage(UINT /*nPage*/, HDC hDC)
+	{
+		m_nPJState = ::SaveDC(hDC);
+	}
+
+	virtual bool PrintPage(UINT /*nPage*/, HDC /*hDC*/) = 0;
+
+	virtual void PostPrintPage(UINT /*nPage*/, HDC hDC)
+	{
+		RestoreDC(hDC, m_nPJState);
+	}
+
+	virtual DEVMODE* GetNewDevModeForPage(UINT /*nLastPage*/, UINT /*nPage*/)
+	{
+		return NULL;
+	}
+
+	virtual bool IsValidPage(UINT /*nPage*/)
+	{
+		return true;
+	}
+
+// Implementation - data
+	int m_nPJState;
+};
+
+
+class CPrintJob
+{
+public:
+// Data members
+	CPrinterHandle m_printer;
+	IPrintJobInfo* m_pInfo;
+	DEVMODE* m_pDefDevMode;
+	DOCINFO m_docinfo;
+	int m_nJobID;
+	bool m_bCancel;
+	bool m_bComplete;
+	unsigned long m_nStartPage;
+	unsigned long m_nEndPage;
+
+// Constructor/destructor
+	CPrintJob() : m_nJobID(0), m_bCancel(false), m_bComplete(true)
+	{ }
+
+	~CPrintJob()
+	{
+		ATLASSERT(IsJobComplete()); // premature destruction?
+	}
+
+// Operations
+	bool IsJobComplete() const
+	{
+		return m_bComplete;
+	}
+
+	bool StartPrintJob(bool bBackground, HANDLE hPrinter, DEVMODE* pDefaultDevMode,
+			IPrintJobInfo* pInfo, LPCTSTR lpszDocName, 
+			unsigned long nStartPage, unsigned long nEndPage,
+			bool bPrintToFile = false, LPCTSTR lpstrOutputFile = NULL)
+	{
+		ATLASSERT(m_bComplete); // previous job not done yet?
+		if (pInfo == NULL)
+			return false;
+
+		memset(&m_docinfo, 0, sizeof(m_docinfo));
+		m_docinfo.cbSize = sizeof(m_docinfo);
+		m_docinfo.lpszDocName = lpszDocName;
+		m_pInfo = pInfo;
+		m_nStartPage = nStartPage;
+		m_nEndPage = nEndPage;
+		m_printer.Attach(hPrinter);
+		m_pDefDevMode = pDefaultDevMode;
+		m_bComplete = false;
+
+		if(bPrintToFile)
+			m_docinfo.lpszOutput = (lpstrOutputFile != NULL) ? lpstrOutputFile : _T("FILE:");
+
+		if (!bBackground)
+		{
+			m_bComplete = true;
+			return StartHelper();
+		}
+
+		// Create a thread and return
+		DWORD dwThreadID = 0;
+#if !defined(_ATL_MIN_CRT) && defined(_MT)
+		HANDLE hThread = (HANDLE)_beginthreadex(NULL, 0, (UINT (WINAPI*)(void*))StartProc, this, 0, (UINT*)&dwThreadID);
+#else
+		HANDLE hThread = ::CreateThread(NULL, 0, StartProc, (void*)this, 0, &dwThreadID);
+#endif
+		if (hThread == NULL)
+			return false;
+
+		::CloseHandle(hThread);
+
+		return true;
+	}
+
+// Implementation
+	static DWORD WINAPI StartProc(void* p)
+	{
+		CPrintJob* pThis = (CPrintJob*)p;
+		pThis->StartHelper();
+		pThis->m_bComplete = true;
+		return 0;
+	}
+
+	bool StartHelper()
+	{
+		CDC dcPrinter;
+		dcPrinter.Attach(m_printer.CreatePrinterDC(m_pDefDevMode));
+		if (dcPrinter.IsNull())
+			return false;
+			
+		m_nJobID = ::StartDoc(dcPrinter, &m_docinfo);
+		if (m_nJobID <= 0)
+			return false;
+
+		m_pInfo->BeginPrintJob(dcPrinter);
+
+		// print all the pages now
+		unsigned long nLastPage = 0;
+		for (unsigned long nPage = m_nStartPage; nPage <= m_nEndPage; nPage++)
+		{
+			if (!m_pInfo->IsValidPage(nPage))
+				break;
+			DEVMODE* pdm = m_pInfo->GetNewDevModeForPage(nLastPage, nPage);
+			if (pdm != NULL)
+				dcPrinter.ResetDC(pdm);
+			dcPrinter.StartPage();
+			m_pInfo->PrePrintPage(nPage, dcPrinter);
+			if (!m_pInfo->PrintPage(nPage, dcPrinter))
+				m_bCancel = true;
+			m_pInfo->PostPrintPage(nPage, dcPrinter);
+			dcPrinter.EndPage();
+			if (m_bCancel)
+				break;
+			nLastPage = nPage;
+		}
+
+		m_pInfo->EndPrintJob(dcPrinter, m_bCancel);
+		if (m_bCancel)
+			::AbortDoc(dcPrinter);
+		else
+			::EndDoc(dcPrinter);
+		m_nJobID = 0;
+		return true;
+	}
+
+	// Cancels a print job. Can be called asynchronously.
+	void CancelPrintJob()
+	{
+		m_bCancel = true;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrintPreview - Adds print preview support to an existing window
+
+class CPrintPreview
+{
+public:
+// Data members
+	IPrintJobInfo* m_pInfo;
+	CPrinterHandle m_printer;
+	CEnhMetaFile m_meta;
+	DEVMODE* m_pDefDevMode;
+	DEVMODE* m_pCurDevMode;
+	SIZE m_sizeCurPhysOffset;
+
+// Constructor
+	CPrintPreview() : m_pInfo(NULL), m_pDefDevMode(NULL), m_pCurDevMode(NULL)
+	{
+		m_sizeCurPhysOffset.cx = 0;
+		m_sizeCurPhysOffset.cy = 0;
+	}
+
+// Operations
+	void SetPrintPreviewInfo(HANDLE hPrinter, DEVMODE* pDefaultDevMode, IPrintJobInfo* pji)
+	{
+		m_printer.Attach(hPrinter);
+		m_pDefDevMode = pDefaultDevMode;
+		m_pInfo = pji;
+		m_nCurPage = 0;
+		m_pCurDevMode = NULL;
+	}
+
+	void SetEnhMetaFile(HENHMETAFILE hEMF)
+	{
+		m_meta = hEMF;
+	}
+
+	void SetPage(int nPage)
+	{
+		if (!m_pInfo->IsValidPage(nPage))
+			return;
+		m_nCurPage = nPage;
+		m_pCurDevMode = m_pInfo->GetNewDevModeForPage(0, nPage);
+		if (m_pCurDevMode == NULL)
+			m_pCurDevMode = m_pDefDevMode;
+		CDC dcPrinter = m_printer.CreatePrinterDC(m_pCurDevMode);
+
+		int iWidth = dcPrinter.GetDeviceCaps(PHYSICALWIDTH); 
+		int iHeight = dcPrinter.GetDeviceCaps(PHYSICALHEIGHT); 
+		int nLogx = dcPrinter.GetDeviceCaps(LOGPIXELSX);
+		int nLogy = dcPrinter.GetDeviceCaps(LOGPIXELSY);
+
+		RECT rcMM = { 0, 0, ::MulDiv(iWidth, 2540, nLogx), ::MulDiv(iHeight, 2540, nLogy) };
+
+		m_sizeCurPhysOffset.cx = dcPrinter.GetDeviceCaps(PHYSICALOFFSETX);
+		m_sizeCurPhysOffset.cy = dcPrinter.GetDeviceCaps(PHYSICALOFFSETY);
+		
+		CEnhMetaFileDC dcMeta(dcPrinter, &rcMM);
+		m_pInfo->PrePrintPage(nPage, dcMeta);
+		m_pInfo->PrintPage(nPage, dcMeta);
+		m_pInfo->PostPrintPage(nPage, dcMeta);
+		m_meta.Attach(dcMeta.Close());
+	}
+
+	void GetPageRect(RECT& rc, LPRECT prc)
+	{
+		int x1 = rc.right-rc.left;
+		int y1 = rc.bottom - rc.top;
+		if ((x1 < 0) || (y1 < 0))
+			return;
+
+		CEnhMetaFileInfo emfinfo(m_meta);
+		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();
+
+		// Compute whether we are OK vertically or horizontally
+		int x2 = pmh->szlDevice.cx;
+		int y2 = pmh->szlDevice.cy;
+		int y1p = MulDiv(x1, y2, x2);
+		int x1p = MulDiv(y1, x2, y2);
+		ATLASSERT((x1p <= x1) || (y1p <= y1));
+		if (x1p <= x1)
+		{
+			prc->left = rc.left + (x1 - x1p) / 2;
+			prc->right = prc->left + x1p;
+			prc->top = rc.top;
+			prc->bottom = rc.bottom;
+		}
+		else
+		{
+			prc->left = rc.left;
+			prc->right = rc.right;
+			prc->top = rc.top + (y1 - y1p) / 2;
+			prc->bottom = prc->top + y1p;
+		}
+	}
+
+// Painting helpers
+	void DoPaint(CDCHandle dc)
+	{
+		// this one is not used
+	}
+
+	void DoPaint(CDCHandle dc, RECT& rc)
+	{
+		CEnhMetaFileInfo emfinfo(m_meta);
+		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();
+		int nOffsetX = MulDiv(m_sizeCurPhysOffset.cx, rc.right-rc.left, pmh->szlDevice.cx);
+		int nOffsetY = MulDiv(m_sizeCurPhysOffset.cy, rc.bottom-rc.top, pmh->szlDevice.cy);
+
+		dc.OffsetWindowOrg(-nOffsetX, -nOffsetY);
+		dc.PlayMetaFile(m_meta, &rc);
+	}
+
+// Implementation - data
+	int m_nCurPage;
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CPrintPreviewWindow - Implements a print preview window
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CPrintPreviewWindowImpl : public ATL::CWindowImpl<T, TBase, TWinTraits>, public CPrintPreview
+{
+public:
+	DECLARE_WND_CLASS_EX(NULL, CS_VREDRAW | CS_HREDRAW, -1)
+
+	enum { m_cxOffset = 10, m_cyOffset = 10 };
+
+// Constructor
+	CPrintPreviewWindowImpl() : m_nMaxPage(0), m_nMinPage(0)
+	{ }
+
+// Operations
+	void SetPrintPreviewInfo(HANDLE hPrinter, DEVMODE* pDefaultDevMode, 
+		IPrintJobInfo* pji, int nMinPage, int nMaxPage)
+	{
+		CPrintPreview::SetPrintPreviewInfo(hPrinter, pDefaultDevMode, pji);
+		m_nMinPage = nMinPage;
+		m_nMaxPage = nMaxPage;
+	}
+
+	bool NextPage()
+	{
+		if (m_nCurPage == m_nMaxPage)
+			return false;
+		SetPage(m_nCurPage + 1);
+		Invalidate();
+		return true;
+	}
+
+	bool PrevPage()
+	{
+		if (m_nCurPage == m_nMinPage)
+			return false;
+		if (m_nCurPage == 0)
+			return false;
+		SetPage(m_nCurPage - 1);
+		Invalidate();
+		return true;
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CPrintPreviewWindowImpl)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+	END_MSG_MAP()
+
+	LRESULT OnEraseBkgnd(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no need for the background
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		RECT rc = { 0 };
+
+		if(wParam != NULL)
+		{
+			pT->DoPrePaint((HDC)wParam, rc);
+			pT->DoPaint((HDC)wParam, rc);
+		}
+		else
+		{
+			CPaintDC dc(m_hWnd);
+			pT->DoPrePaint(dc.m_hDC, rc);
+			pT->DoPaint(dc.m_hDC, rc);
+		}
+
+		return 0;
+	}
+
+// Painting helper
+	void DoPrePaint(CDCHandle dc, RECT& rc)
+	{
+		RECT rcClient = { 0 };
+		GetClientRect(&rcClient);
+		RECT rcArea = rcClient;
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		::InflateRect(&rcArea, -pT->m_cxOffset, -pT->m_cyOffset);
+		if (rcArea.left > rcArea.right)
+			rcArea.right = rcArea.left;
+		if (rcArea.top > rcArea.bottom)
+			rcArea.bottom = rcArea.top;
+		GetPageRect(rcArea, &rc);
+		CRgn rgn1, rgn2;
+		rgn1.CreateRectRgnIndirect(&rc);
+		rgn2.CreateRectRgnIndirect(&rcClient);
+		rgn2.CombineRgn(rgn1, RGN_DIFF);
+		dc.SelectClipRgn(rgn2);
+		dc.FillRect(&rcClient, COLOR_BTNSHADOW);
+		dc.SelectClipRgn(NULL);
+		dc.FillRect(&rc, (HBRUSH)::GetStockObject(WHITE_BRUSH));
+	}
+
+// Implementation - data
+	int m_nMinPage;
+	int m_nMaxPage;
+};
+
+
+class CPrintPreviewWindow : public CPrintPreviewWindowImpl<CPrintPreviewWindow>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_PrintPreview"), CS_VREDRAW | CS_HREDRAW, -1)
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CZoomPrintPreviewWindowImpl - Implements print preview window with zooming
+
+#ifdef __ATLSCRL_H__
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CZoomPrintPreviewWindowImpl : public CPrintPreviewWindowImpl< T, TBase, TWinTraits >, public CZoomScrollImpl< T >
+{
+public:
+	bool m_bSized;
+
+	CZoomPrintPreviewWindowImpl()  
+	{
+		SetScrollExtendedStyle(SCRL_DISABLENOSCROLL);
+		InitZoom();
+	}
+
+	// should be called to reset data members before recreating window 
+	void InitZoom()
+	{
+		m_bSized = false;	
+		m_nZoomMode = ZOOMMODE_OFF;
+		m_fZoomScaleMin = 1.0;
+		m_fZoomScale = 1.0;
+	}
+
+	BEGIN_MSG_MAP(CZoomPrintPreviewWindowImpl)
+		MESSAGE_HANDLER(WM_SETCURSOR, CZoomScrollImpl< T >::OnSetCursor)
+		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, CZoomScrollImpl< T >::OnLButtonDown)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, CZoomScrollImpl< T >::OnMouseMove)
+		MESSAGE_HANDLER(WM_LBUTTONUP, CZoomScrollImpl< T >::OnLButtonUp)
+		MESSAGE_HANDLER(WM_CAPTURECHANGED, CZoomScrollImpl< T >::OnCaptureChanged)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
+	END_MSG_MAP()
+	
+	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		SIZE sizeClient = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
+		POINT ptOffset = m_ptOffset;
+		SIZE sizeAll = m_sizeAll;
+		SetScrollSize(sizeClient);
+		if(sizeAll.cx > 0)
+			ptOffset.x = ::MulDiv(ptOffset.x, m_sizeAll.cx, sizeAll.cx);
+		if(sizeAll.cy > 0)
+			ptOffset.y = ::MulDiv(ptOffset.y, m_sizeAll.cy, sizeAll.cy);
+		SetScrollOffset(ptOffset);
+		CScrollImpl< T >::OnSize(uMsg, wParam, lParam, bHandled);
+		if(!m_bSized)
+		{
+			m_bSized = true;
+			T* pT = static_cast<T*>(this);
+			pT->ShowScrollBar(SB_HORZ, TRUE);
+			pT->ShowScrollBar(SB_VERT, TRUE);
+		}
+		return 0;
+	}
+
+	LRESULT OnEraseBkgnd(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		RECT rc = { 0 };
+
+		if(wParam != NULL)
+		{
+			CDCHandle dc = (HDC)wParam;
+			int nMapModeSav = dc.GetMapMode();
+			dc.SetMapMode(MM_ANISOTROPIC);
+			SIZE szWindowExt = { 0, 0 };
+			dc.SetWindowExt(m_sizeLogAll, &szWindowExt);
+			SIZE szViewportExt = { 0, 0 };
+			dc.SetViewportExt(m_sizeAll, &szViewportExt);
+			POINT ptViewportOrg = { 0, 0 };
+			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y, &ptViewportOrg);
+
+			pT->DoPrePaint(dc, rc);
+			pT->DoPaint(dc, rc);
+
+			dc.SetMapMode(nMapModeSav);
+			dc.SetWindowExt(szWindowExt);
+			dc.SetViewportExt(szViewportExt);
+			dc.SetViewportOrg(ptViewportOrg);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			pT->PrepareDC(dc.m_hDC);
+			pT->DoPrePaint(dc.m_hDC, rc);
+			pT->DoPaint(dc.m_hDC, rc);
+		}
+
+		return 0;
+	}
+
+	// Painting helpers
+	void DoPaint(CDCHandle dc)
+	{
+		// this one is not used
+	}
+
+	void DoPrePaint(CDCHandle dc, RECT& rc)
+	{
+		RECT rcClient;
+		GetClientRect(&rcClient);
+		RECT rcArea = rcClient;
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		::InflateRect(&rcArea, -pT->m_cxOffset, -pT->m_cyOffset);
+		if (rcArea.left > rcArea.right)
+			rcArea.right = rcArea.left;
+		if (rcArea.top > rcArea.bottom)
+			rcArea.bottom = rcArea.top;
+		GetPageRect(rcArea, &rc);
+		HBRUSH hbrOld = dc.SelectBrush(::GetSysColorBrush(COLOR_BTNSHADOW));
+		dc.PatBlt(rcClient.left, rcClient.top, rc.left - rcClient.left, rcClient.bottom - rcClient.top, PATCOPY);
+		dc.PatBlt(rc.left, rcClient.top, rc.right - rc.left, rc.top - rcClient.top, PATCOPY);
+		dc.PatBlt(rc.right, rcClient.top, rcClient.right - rc.right, rcClient.bottom - rcClient.top, PATCOPY);
+		dc.PatBlt(rc.left, rc.bottom, rc.right - rc.left, rcClient.bottom - rc.bottom, PATCOPY);
+		dc.SelectBrush((HBRUSH)::GetStockObject(WHITE_BRUSH));
+		dc.PatBlt(rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, PATCOPY);
+		dc.SelectBrush(::GetSysColorBrush(COLOR_3DDKSHADOW));
+		dc.PatBlt(rc.right, rc.top + 4, 4, rc.bottom - rc.top, PATCOPY);
+		dc.PatBlt(rc.left + 4, rc.bottom, rc.right - rc.left, 4, PATCOPY);
+		dc.SelectBrush(hbrOld);
+	}
+
+	void DoPaint(CDCHandle dc, RECT& rc)
+	{
+		CEnhMetaFileInfo emfinfo(m_meta);
+		ENHMETAHEADER* pmh = emfinfo.GetEnhMetaFileHeader();
+		int nOffsetX = MulDiv(m_sizeCurPhysOffset.cx, rc.right-rc.left, pmh->szlDevice.cx);
+		int nOffsetY = MulDiv(m_sizeCurPhysOffset.cy, rc.bottom-rc.top, pmh->szlDevice.cy);
+
+		dc.OffsetWindowOrg(-nOffsetX, -nOffsetY);
+		dc.PlayMetaFile(m_meta, &rc);
+	}
+};
+
+class CZoomPrintPreviewWindow : public CZoomPrintPreviewWindowImpl<CZoomPrintPreviewWindow>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_ZoomPrintPreview"), CS_VREDRAW | CS_HREDRAW, -1)
+};
+
+#endif // __ATLSCRL_H__
+
+}; // namespace WTL
+
+#endif // __ATLPRINT_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlres.h b/GLideN64/src/GLideNUI-wtl/WTL/atlres.h
new file mode 100644
index 00000000..4a5d8afd
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlres.h
@@ -0,0 +1,263 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLRES_H__
+#define __ATLRES_H__
+
+#pragma once
+
+#if defined(_WIN32_WCE) && !defined(__ATLRESCE_H__)
+	#error Use atlresCE.h instead of atlres.h for Windows CE
+#endif
+
+
+#ifdef RC_INVOKED
+#ifndef _INC_WINDOWS
+
+  #define _INC_WINDOWS
+
+  #ifndef _WIN32_WCE
+    #define VS_VERSION_INFO     1
+
+    #ifdef APSTUDIO_INVOKED
+      #define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
+    #endif // APSTUDIO_INVOKED
+
+    #ifndef WINVER
+      #define WINVER 0x0400   // default to Windows Version 4.0
+    #endif // !WINVER
+
+    #include <winresrc.h>
+
+    // operation messages sent to DLGINIT
+    #define LB_ADDSTRING    (WM_USER+1)
+    #define CB_ADDSTRING    (WM_USER+3)
+  #endif // !_WIN32_WCE
+
+  #ifdef APSTUDIO_INVOKED
+    #undef APSTUDIO_HIDDEN_SYMBOLS
+  #endif // APSTUDIO_INVOKED
+
+  #ifdef IDC_STATIC
+    #undef IDC_STATIC
+  #endif // IDC_STATIC
+  #define IDC_STATIC      (-1)
+
+#endif // !_INC_WINDOWS
+#endif // RC_INVOKED
+
+#ifdef APSTUDIO_INVOKED
+  #define APSTUDIO_HIDDEN_SYMBOLS
+#endif // APSTUDIO_INVOKED
+
+///////////////////////////////////////////////////////////////////////////////
+// ATL resource types
+
+#ifndef RC_INVOKED
+  #define RT_DLGINIT  MAKEINTRESOURCE(240)
+  #define RT_TOOLBAR  MAKEINTRESOURCE(241)
+#endif // RC_INVOKED
+
+///////////////////////////////////////////////////////////////////////////////
+
+#ifdef APSTUDIO_INVOKED
+  #undef APSTUDIO_HIDDEN_SYMBOLS
+#endif // APSTUDIO_INVOKED
+
+///////////////////////////////////////////////////////////////////////////////
+// Standard window components
+
+#define ID_SEPARATOR                    0       // special separator value
+#define ID_DEFAULT_PANE                 0       // default status bar pane
+
+#ifndef RC_INVOKED  // code only
+// standard control bars (IDW = window ID)
+  #define ATL_IDW_TOOLBAR               0xE800  // main Toolbar for window
+  #define ATL_IDW_STATUS_BAR            0xE801  // Status bar window
+  #define ATL_IDW_COMMAND_BAR           0xE802  // Command bar window
+
+// parts of a frame window
+  #define ATL_IDW_CLIENT                0xE900
+  #define ATL_IDW_PANE_FIRST            0xE900  // first pane (256 max)
+  #define ATL_IDW_PANE_LAST             0xE9FF
+  #define ATL_IDW_HSCROLL_FIRST         0xEA00  // first Horz scrollbar (16 max)
+  #define ATL_IDW_VSCROLL_FIRST         0xEA10  // first Vert scrollbar (16 max)
+
+  #define ATL_IDW_SIZE_BOX              0xEA20  // size box for splitters
+  #define ATL_IDW_PANE_SAVE             0xEA21  // to shift ATL_IDW_PANE_FIRST
+
+// bands for a rebar
+  #define ATL_IDW_BAND_FIRST            0xEB00
+  #define ATL_IDW_BAND_LAST             0xEBFF
+#endif // !RC_INVOKED
+
+///////////////////////////////////////////////////////////////////////////////
+// Standard Commands
+
+// File commands
+#define ID_FILE_NEW                     0xE100
+#define ID_FILE_OPEN                    0xE101
+#define ID_FILE_CLOSE                   0xE102
+#define ID_FILE_SAVE                    0xE103
+#define ID_FILE_SAVE_AS                 0xE104
+#define ID_FILE_PAGE_SETUP              0xE105
+#define ID_FILE_PRINT_SETUP             0xE106
+#define ID_FILE_PRINT                   0xE107
+#define ID_FILE_PRINT_DIRECT            0xE108
+#define ID_FILE_PRINT_PREVIEW           0xE109
+#define ID_FILE_UPDATE                  0xE10A
+#define ID_FILE_SAVE_COPY_AS            0xE10B
+#define ID_FILE_SEND_MAIL               0xE10C
+
+#define ID_FILE_MRU_FIRST               0xE110
+#define ID_FILE_MRU_FILE1               0xE110          // range - 16 max
+#define ID_FILE_MRU_FILE2               0xE111
+#define ID_FILE_MRU_FILE3               0xE112
+#define ID_FILE_MRU_FILE4               0xE113
+#define ID_FILE_MRU_FILE5               0xE114
+#define ID_FILE_MRU_FILE6               0xE115
+#define ID_FILE_MRU_FILE7               0xE116
+#define ID_FILE_MRU_FILE8               0xE117
+#define ID_FILE_MRU_FILE9               0xE118
+#define ID_FILE_MRU_FILE10              0xE119
+#define ID_FILE_MRU_FILE11              0xE11A
+#define ID_FILE_MRU_FILE12              0xE11B
+#define ID_FILE_MRU_FILE13              0xE11C
+#define ID_FILE_MRU_FILE14              0xE11D
+#define ID_FILE_MRU_FILE15              0xE11E
+#define ID_FILE_MRU_FILE16              0xE11F
+#define ID_FILE_MRU_LAST                0xE11F
+
+// Edit commands
+#define ID_EDIT_CLEAR                   0xE120
+#define ID_EDIT_CLEAR_ALL               0xE121
+#define ID_EDIT_COPY                    0xE122
+#define ID_EDIT_CUT                     0xE123
+#define ID_EDIT_FIND                    0xE124
+#define ID_EDIT_PASTE                   0xE125
+#define ID_EDIT_PASTE_LINK              0xE126
+#define ID_EDIT_PASTE_SPECIAL           0xE127
+#define ID_EDIT_REPEAT                  0xE128
+#define ID_EDIT_REPLACE                 0xE129
+#define ID_EDIT_SELECT_ALL              0xE12A
+#define ID_EDIT_UNDO                    0xE12B
+#define ID_EDIT_REDO                    0xE12C
+
+// Window commands
+#define ID_WINDOW_NEW                   0xE130
+#define ID_WINDOW_ARRANGE               0xE131
+#define ID_WINDOW_CASCADE               0xE132
+#define ID_WINDOW_TILE_HORZ             0xE133
+#define ID_WINDOW_TILE_VERT             0xE134
+#define ID_WINDOW_SPLIT                 0xE135
+#ifndef RC_INVOKED      // code only
+  #define ATL_IDM_WINDOW_FIRST          0xE130
+  #define ATL_IDM_WINDOW_LAST           0xE13F
+  #define ATL_IDM_FIRST_MDICHILD        0xFF00  // window list starts here
+  #define ATL_IDM_LAST_MDICHILD         0xFFFD
+#endif // !RC_INVOKED
+// TabView
+#define ID_WINDOW_TABFIRST              0xFF00	// = ATL_IDM_FIRST_MDICHILD
+#define ID_WINDOW_TABLAST               0xFFFD
+#define ID_WINDOW_SHOWTABLIST           0xFFFE
+
+// Help and App commands
+#define ID_APP_ABOUT                    0xE140
+#define ID_APP_EXIT                     0xE141
+#define ID_HELP_INDEX                   0xE142
+#define ID_HELP_FINDER                  0xE143
+#define ID_HELP_USING                   0xE144
+#define ID_CONTEXT_HELP                 0xE145      // shift-F1
+// special commands for processing help
+#define ID_HELP                         0xE146      // first attempt for F1
+#define ID_DEFAULT_HELP                 0xE147      // last attempt
+
+// Misc
+#define ID_NEXT_PANE                    0xE150
+#define ID_PREV_PANE                    0xE151
+#define ID_PANE_CLOSE                   0xE152
+
+// Format
+#define ID_FORMAT_FONT                  0xE160
+
+// Scroll
+#define ID_SCROLL_UP                    0xE170
+#define ID_SCROLL_DOWN                  0xE171
+#define ID_SCROLL_PAGE_UP               0xE172
+#define ID_SCROLL_PAGE_DOWN             0xE173
+#define ID_SCROLL_TOP                   0xE174
+#define ID_SCROLL_BOTTOM                0xE175
+#define ID_SCROLL_LEFT                  0xE176
+#define ID_SCROLL_RIGHT                 0xE177
+#define ID_SCROLL_PAGE_LEFT             0xE178
+#define ID_SCROLL_PAGE_RIGHT            0xE179
+#define ID_SCROLL_ALL_LEFT              0xE17A
+#define ID_SCROLL_ALL_RIGHT             0xE17B
+
+// OLE commands
+#define ID_OLE_INSERT_NEW               0xE200
+#define ID_OLE_EDIT_LINKS               0xE201
+#define ID_OLE_EDIT_CONVERT             0xE202
+#define ID_OLE_EDIT_CHANGE_ICON         0xE203
+#define ID_OLE_EDIT_PROPERTIES          0xE204
+#define ID_OLE_VERB_FIRST               0xE210     // range - 16 max
+#ifndef RC_INVOKED      // code only
+  #define ID_OLE_VERB_LAST              0xE21F
+#endif // !RC_INVOKED
+
+// View commands (same number used as IDW used for toolbar and status bar)
+#define ID_VIEW_TOOLBAR                 0xE800
+#define ID_VIEW_STATUS_BAR              0xE801
+#define ID_VIEW_REFRESH                 0xE803
+#define ID_VIEW_RIBBON                  0xE804 // Ribbon
+
+///////////////////////////////////////////////////////////////////////////////
+// Standard control IDs
+
+#ifdef IDC_STATIC
+  #undef IDC_STATIC
+#endif // IDC_STATIC
+#define IDC_STATIC              (-1)     // all static controls
+
+///////////////////////////////////////////////////////////////////////////////
+// Standard string error/warnings
+
+// idle status bar message
+#define ATL_IDS_IDLEMESSAGE             0xE001
+
+#ifndef RC_INVOKED      // code only
+  #define ATL_IDS_SCFIRST               0xEF00
+#endif // !RC_INVOKED
+
+#define ATL_IDS_SCSIZE                  0xEF00
+#define ATL_IDS_SCMOVE                  0xEF01
+#define ATL_IDS_SCMINIMIZE              0xEF02
+#define ATL_IDS_SCMAXIMIZE              0xEF03
+#define ATL_IDS_SCNEXTWINDOW            0xEF04
+#define ATL_IDS_SCPREVWINDOW            0xEF05
+#define ATL_IDS_SCCLOSE                 0xEF06
+#define ATL_IDS_SCRESTORE               0xEF12
+#define ATL_IDS_SCTASKLIST              0xEF13
+
+#define ATL_IDS_MDICHILD                0xEF1F
+#define ATL_IDS_MRU_FILE                0xEFDA
+
+///////////////////////////////////////////////////////////////////////////////
+// Misc. control IDs
+
+// Property Sheet control id's (determined with Spy++)
+#define ID_APPLY_NOW                    0x3021
+#define ID_WIZBACK                      0x3023
+#define ID_WIZNEXT                      0x3024
+#define ID_WIZFINISH                    0x3025
+#define ATL_IDC_TAB_CONTROL             0x3020
+
+#endif // __ATLRES_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlresce.h b/GLideN64/src/GLideNUI-wtl/WTL/atlresce.h
new file mode 100644
index 00000000..96211ee6
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlresce.h
@@ -0,0 +1,93 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLRESCE_H__
+#define __ATLRESCE_H__
+
+#pragma once
+
+#ifndef _WIN32_WCE
+	#error atlresCE.h is only for Windows CE
+#endif
+
+
+#ifdef RC_INVOKED
+#ifndef _INC_WINDOWS
+
+  #define VS_VERSION_INFO     1
+
+  #ifdef APSTUDIO_INVOKED
+    #define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
+  #endif // APSTUDIO_INVOKED
+
+  #ifndef WINVER
+    #define WINVER 0x0400   // default to Windows Version 4.0
+  #endif // !WINVER
+
+  #if !defined(WCEOLE_ENABLE_DIALOGEX)
+    #define DIALOGEX DIALOG DISCARDABLE
+  #endif
+
+  #include <commctrl.h>
+  #define  SHMENUBAR RCDATA
+
+  #if defined(SHELLSDK_MODULES_AYGSHELL)
+    #include <aygshell.h> 
+  #else
+    #define NOMENU                 0xFFFF
+    #define IDS_SHNEW              1
+    #define IDM_SHAREDNEW          10
+    #define IDM_SHAREDNEWDEFAULT   11
+  #endif
+  #ifndef I_IMAGENONE
+	#define I_IMAGENONE            (-2)
+  #endif
+
+  #include <windows.h>
+
+#endif // !_INC_WINDOWS
+#endif // RC_INVOKED
+
+#include "atlres.h"
+
+#ifdef APSTUDIO_INVOKED
+	#undef APSTUDIO_HIDDEN_SYMBOLS
+#endif // APSTUDIO_INVOKED
+
+// Visual Studio dialog editor bug fix
+#ifndef DS_FIXEDSYS 
+	#define DS_FIXEDSYS 0
+#endif
+
+#define IDC_INFOSTATIC 0xFFFE   // == IDC_STATIC -1
+
+///////////////////////////////////////////////////////////////////////////////
+// Smartphone and PPC 2005 Resource IDs
+
+// Command and associated string resource IDs
+#define ID_MENU_OK                      0xE790
+#define ID_MENU_CANCEL                  0xE791
+#define ID_MENU							0xE792
+#define ID_ACTION						0xE793
+#define ID_VIEW_FULLSCREEN              0xE802
+
+// MenuBar resource IDs
+#define ATL_IDM_MENU_DONE               0xE701
+#define ATL_IDM_MENU_CANCEL             0xE702
+#define ATL_IDM_MENU_DONECANCEL         0xE703
+
+// Default device MenuBar control ID and MenuBar resource ID
+#define ATL_IDW_MENU_BAR				0xE802  
+
+// SmartPhone spinned controls ID offset for CSpinCtrl
+#define ATL_IDW_SPIN_ID                 9999
+
+#endif // __ATLRESCE_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlribbon.h b/GLideN64/src/GLideNUI-wtl/WTL/atlribbon.h
new file mode 100644
index 00000000..c1dfd0f8
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlribbon.h
@@ -0,0 +1,3446 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLRIBBON_H__
+#define __ATLRIBBON_H__
+
+#pragma once
+
+#if (_MSC_VER < 1500)
+	#error atlribbon.h requires Visual C++ 2008 compiler or higher
+#endif
+
+#ifndef _UNICODE
+	#error atlribbon.h requires the Unicode character set
+#endif
+
+#if !defined(NTDDI_WIN7) || (NTDDI_VERSION < NTDDI_WIN7)
+	#error atlribbon.h requires the Windows 7 SDK or higher
+#endif
+
+#ifdef _WIN32_WCE
+	#error atlribbon.h is not supported on Windows CE
+#endif
+
+#ifndef __ATLAPP_H__
+	#error atlribbon.h requires atlapp.h to be included first
+#endif
+
+#if (_ATL_VER < 0x0700)
+	#include <shlwapi.h>
+	#pragma comment(lib, "shlwapi.lib")
+#endif
+
+#include <atlmisc.h>    // for RecentDocumentList classes
+#include <atlframe.h>   // for Frame and UpdateUI classes
+#include <atlctrls.h>   // required for atlctrlw.h
+#include <atlctrlw.h>   // for CCommandBarCtrl
+
+#if !defined(_WTL_USE_CSTRING) && !defined(__ATLSTR_H__)
+  #pragma warning(disable : 4530)   // unwind semantics not enabled
+  #include <string>
+  #pragma warning(default : 4530)
+#endif
+
+#include <dwmapi.h>
+#pragma comment(lib, "dwmapi.lib")
+
+#include <UIRibbon.h>
+#include <UIRibbonPropertyHelpers.h>
+#pragma comment(lib, "propsys.lib")
+
+#include <Richedit.h>   // for CHARFORMAT2
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CRibbonUpdateUI : Automatic mapping of ribbon UI elements
+//
+// RibbonUI::Text
+// RibbonUI::CharFormat
+// RibbonUI::ICtrl
+// RibbonUI::CtrlImpl
+// RibbonUI::CommandCtrlImpl
+// RibbonUI::ItemProperty
+// RibbonUI::CollectionImplBase
+// RibbonUI::CollectionImpl
+// RibbonUI::TextCollectionImpl
+// RibbonUI::ItemCollectionImpl
+// RibbonUI::ComboCollectionImpl
+// RibbonUI::CommandCollectionImpl
+// RibbonUI::ToolbarCollectionImpl
+// RibbonUI::SimpleCollectionImpl
+// RibbonUI::CollectionCtrlImpl
+// RibbonUI::ToolbarGalleryCtrlImpl
+// RibbonUI::SimpleCollectionCtrlImpl
+// RibbonUI::RecentItemsCtrlImpl
+// RibbonUI::FontCtrlImpl
+// RibbonUI::ColorCtrlImpl
+// RibbonUI::SpinnerCtrlImpl
+//
+// RibbonUI::CRibbonImpl
+//	 CRibbonImpl::CRibbonComboCtrl
+//	 CRibbonImpl::CRibbonItemGalleryCtrl
+//	 CRibbonImpl::CRibbonCommandGalleryCtrl
+//	 CRibbonImpl::CRibbonToolbarGalleryCtrl
+//	 CRibbonImpl::CRibbonSimpleComboCtrl
+//	 CRibbonImpl::CRibbonSimpleGalleryCtrl
+//	 CRibbonImpl::CRibbonRecentItemsCtrl
+//	 CRibbonImpl::CRibbonColorCtrl
+//	 CRibbonImpl::CRibbonFontCtrl
+//	 CRibbonImpl::CRibbonSpinnerCtrl
+//	 CRibbonImpl::CRibbonFloatSpinnerCtrl
+//	 CRibbonImpl::CRibbonCommandCtrl
+//
+// CRibbonFrameWindowImplBase
+// CRibbonFrameWindowImpl
+// CRibbonMDIFrameWindowImpl
+// CRibbonPersist
+//
+// Global functions:
+//   RibbonUI::SetPropertyVal()
+//   RibbonUI::GetImage()
+
+
+// Constants
+
+#ifndef RIBBONUI_MAX_TEXT
+  #define RIBBONUI_MAX_TEXT 128
+#endif
+
+#define TWIPS_PER_POINT 20   // For font size
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CRibbonUpdateUI : Automatic mapping of ribbon UI elements
+
+template <class T>
+class CRibbonUpdateUI : public CAutoUpdateUI<T>
+{
+public:
+	enum
+	{
+		UPDUI_RIBBON = 0x0080, 
+		UPDUI_PERSIST = 0x0020
+	};
+
+	bool IsRibbonElement(const _AtlUpdateUIMap& UIMap)
+	{
+		return (UIMap.m_wType & UPDUI_RIBBON) != 0;
+	}
+
+	bool IsRibbonID(UINT nID)
+	{
+		for(int i = 0; i < m_arrUIMap.GetSize(); i++)
+		{
+			if(m_arrUIMap[i].m_nID == nID)
+				return IsRibbonElement(m_arrUIMap[i]);
+		}
+
+		return false;
+	}
+
+// Element
+	bool UIAddRibbonElement(UINT nID)
+	{
+		return UIAddElement<UPDUI_RIBBON>(nID);
+	}
+
+	bool UIRemoveRibbonElement(UINT nID)
+	{
+		return UIRemoveElement<UPDUI_RIBBON>(nID);
+	}
+
+	bool UIPersistElement(UINT nID, bool bPersist = true)
+	{
+		return bPersist ?
+			UIAddElement<UPDUI_PERSIST>(nID) :
+			UIRemoveElement<UPDUI_PERSIST>(nID);
+	}
+
+// methods for Ribbon elements
+	BOOL UISetText(int nID, LPCWSTR sText, BOOL bForceUpdate = FALSE)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bRes = CUpdateUIBase::UISetText(nID, sText, bForceUpdate);
+		if (pT->IsRibbonUI() && IsRibbonID(nID))
+			bRes = SUCCEEDED(pT->InvalidateProperty(nID, UI_PKEY_Label));
+		return bRes;
+	}
+
+	BOOL UISetText(int nID, UINT uIdResource, BOOL bForceUpdate = FALSE)
+	{
+		CTempBuffer<WCHAR> sText(RIBBONUI_MAX_TEXT);
+		return AtlLoadString(uIdResource, sText, RIBBONUI_MAX_TEXT) ? 
+			UISetText(nID, sText, bForceUpdate) :
+			E_FAIL;
+	}
+
+	LPCTSTR UIGetText(int nID)
+	{
+		T* pT = static_cast<T*>(this);
+		LPCTSTR sUI = CAutoUpdateUI::UIGetText(nID);
+		
+		// replace 'tab' by 'space' for RibbonUI elements
+		if (sUI && pT->IsRibbonUI() && IsRibbonID(nID) && wcschr(sUI, L'\t'))
+		{
+			static WCHAR sText[RIBBONUI_MAX_TEXT] = { 0 };
+			wcscpy_s(sText, sUI);
+			*wcschr(sText, L'\t') = L' ';
+			return sText;
+		}
+		else
+		{
+			return sUI;
+		}
+	}
+
+	BOOL UIEnable(int nID, BOOL bEnable, BOOL bForceUpdate = FALSE)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bRes = CUpdateUIBase::UIEnable(nID, bEnable, bForceUpdate);
+		if (pT->IsRibbonUI() && IsRibbonID(nID))
+			bRes = SUCCEEDED(pT->SetProperty((WORD)nID, UI_PKEY_Enabled, bEnable));
+		return bRes;
+	}
+
+	BOOL UISetCheck(int nID, INT nCheck, BOOL bForceUpdate = FALSE)
+	{
+		if ((nCheck == 0) || (nCheck == 1))
+			return UISetCheck(nID, nCheck != 0, bForceUpdate);
+		else
+			return CUpdateUIBase::UISetCheck(nID, nCheck, bForceUpdate);
+	}
+
+	BOOL UISetCheck(int nID, bool bCheck, BOOL bForceUpdate = FALSE)
+	{
+		T* pT = static_cast<T*>(this);
+		BOOL bRes = CUpdateUIBase::UISetCheck(nID, bCheck, bForceUpdate);
+		if (bRes && pT->IsRibbonUI() && IsRibbonID(nID))
+			bRes = SUCCEEDED(pT->SetProperty((WORD)nID, UI_PKEY_BooleanValue, bCheck));
+		return bRes;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// RibbonUI namespace
+//
+
+namespace RibbonUI
+{
+
+// Minimal string allocation support for various PROPERTYKEY values
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+  typedef _CSTRING_NS::CString Text;
+#else
+  class Text : public std::wstring
+  {
+  public:
+	Text(std::wstring& s) : std::wstring(s)
+	{ }
+	Text(LPCWSTR s) : std::wstring(s)
+	{ }
+	Text()
+	{ }
+	bool IsEmpty()
+	{
+		return empty();
+	}
+	operator LPCWSTR()
+	{
+		return c_str();
+	}
+	Text& operator =(LPCWSTR s)
+	{
+		return static_cast<Text&>(std::wstring::operator =(s));
+	}
+  };
+#endif
+
+// PROPERTYKEY enum and helpers
+enum k_KEY
+{
+	// state
+	k_Enabled = 1, k_BooleanValue = 200, 
+	// text properties
+	k_LabelDescription = 2, k_Keytip = 3, k_Label = 4, k_TooltipDescription = 5, k_TooltipTitle = 6, 
+	// image properties
+	k_LargeImage = 7, k_LargeHighContrastImage = 8, k_SmallImage = 9, k_SmallHighContrastImage = 10,
+	// collection properties
+	k_ItemsSource = 101, k_Categories = 102, k_SelectedItem = 104,
+	// collection item properties
+	k_CommandId = 100, k_CategoryId = 103, k_CommandType = 105, k_ItemImage = 106,
+	// combo control property
+	k_StringValue = 202,
+	// spinner control properties
+	k_DecimalValue = 201, k_MaxValue = 203, k_MinValue, k_Increment, k_DecimalPlaces, k_FormatString, k_RepresentativeString = 208,
+	// font control properties
+	k_FontProperties = 300, k_FontProperties_Family, k_FontProperties_Size, k_FontProperties_Bold, k_FontProperties_Italic = 304, 
+	k_FontProperties_Underline = 305, k_FontProperties_Strikethrough, k_FontProperties_VerticalPositioning, k_FontProperties_ForegroundColor = 308, 
+	k_FontProperties_BackgroundColor = 309, k_FontProperties_ForegroundColorType, k_FontProperties_BackgroundColorType, k_FontProperties_ChangedProperties = 312, 
+	k_FontProperties_DeltaSize = 313, 
+	// recent items properties
+	k_RecentItems = 350, k_Pinned = 351,
+	// color control properties
+	k_Color = 400, k_ColorType = 401, k_ColorMode, 
+	k_ThemeColorsCategoryLabel = 403, k_StandardColorsCategoryLabel, k_RecentColorsCategoryLabel = 405, k_AutomaticColorLabel = 406, 
+	k_NoColorLabel = 407, k_MoreColorsLabel = 408, 
+	k_ThemeColors = 409, k_StandardColors = 410, k_ThemeColorsTooltips = 411, k_StandardColorsTooltips = 412,
+	// Ribbon state
+	k_Viewable = 1000, k_Minimized = 1001, k_QuickAccessToolbarDock = 1002, k_ContextAvailable = 1100,
+	// Ribbon UI colors
+	k_GlobalBackgroundColor = 2000, k_GlobalHighlightColor, k_GlobalTextColor = 2002
+};
+
+inline k_KEY k_(REFPROPERTYKEY key)
+{
+	return (k_KEY)key.fmtid.Data1;
+}
+
+// PROPERTYKEY value assignment and specializations
+//
+template <typename V>
+HRESULT SetPropertyVal(REFPROPERTYKEY key, V val, PROPVARIANT* ppv)
+{
+	switch (k_(key))
+	{
+	case k_Enabled:
+	case k_BooleanValue:
+		return InitPropVariantFromBoolean(val, ppv);
+	default:
+		return UIInitPropertyFromUInt32(key, val, ppv);
+	}
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, DOUBLE val, PROPVARIANT* ppv)
+{
+	return SetPropertyVal(key, (LONG)val, ppv);
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, IUIImage* val, PROPVARIANT* ppv)
+{
+	HRESULT hr = UIInitPropertyFromImage(key, val, ppv);
+	ATLVERIFY(val->Release() == 1);
+	return hr;
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, IUnknown* val, PROPVARIANT* ppv)
+{
+	return UIInitPropertyFromInterface(key, val, ppv);
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, IPropertyStore* val, PROPVARIANT* ppv)
+{
+	return UIInitPropertyFromInterface(key, val, ppv);
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, SAFEARRAY* val, PROPVARIANT* ppv)
+{
+	return UIInitPropertyFromIUnknownArray(key, val, ppv);
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, DECIMAL* val, PROPVARIANT* ppv)
+{
+	return UIInitPropertyFromDecimal(key, *val, ppv);
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, bool val, PROPVARIANT* ppv)
+{
+	return UIInitPropertyFromBoolean(key, val, ppv);
+}
+
+inline HRESULT SetPropertyVal(REFPROPERTYKEY key, LPCWSTR val, PROPVARIANT* ppv)
+{
+	return UIInitPropertyFromString(key, val, ppv);
+}
+
+// CharFormat helper struct for RibbonUI font control
+//
+struct CharFormat : CHARFORMAT2
+{
+	// Default constructor
+	CharFormat()
+	{
+		cbSize = sizeof CHARFORMAT2;
+		Reset();
+	}
+
+	// Copy constructor
+	CharFormat(const CharFormat& cf)
+	{
+		CopyMemory(this, &cf, sizeof CHARFORMAT2);
+	}
+
+	// Assign operator
+	CharFormat& operator =(const CharFormat& cf)
+	{
+		CopyMemory(this, &cf, sizeof CHARFORMAT2);
+		return (*this);
+	}
+
+	void Reset()
+	{
+		uValue = dwMask = dwEffects = 0;
+		PropVariantInit(&propvar);
+	}
+
+	void operator <<(IPropertyStore* pStore)
+	{
+		if (pStore == NULL)
+		{
+			ATLASSERT(FALSE);
+			return;
+		}
+
+		static void (CharFormat::*Getk_[])(IPropertyStore*) = 
+		{
+			&CharFormat::Getk_Family, 
+			&CharFormat::Getk_FontProperties_Size, 
+			&CharFormat::Getk_MaskEffect<CFM_BOLD, CFE_BOLD, UI_PKEY_FontProperties_Bold>,
+			&CharFormat::Getk_MaskEffect<CFM_ITALIC, CFE_ITALIC, UI_PKEY_FontProperties_Italic>,
+			&CharFormat::Getk_MaskEffect<CFM_UNDERLINE, CFE_UNDERLINE, UI_PKEY_FontProperties_Underline>,
+			&CharFormat::Getk_MaskEffect<CFM_STRIKEOUT, CFE_STRIKEOUT, UI_PKEY_FontProperties_Strikethrough>,
+			&CharFormat::Getk_VerticalPositioning, 
+			&CharFormat::Getk_Color<CFM_COLOR, UI_PKEY_FontProperties_ForegroundColor>, 
+			&CharFormat::Getk_Color<CFM_BACKCOLOR, UI_PKEY_FontProperties_BackgroundColor>, 
+			&CharFormat::Getk_ColorType<CFM_COLOR, CFE_AUTOCOLOR, UI_SWATCHCOLORTYPE_AUTOMATIC, UI_PKEY_FontProperties_ForegroundColorType>,
+			&CharFormat::Getk_ColorType<CFM_BACKCOLOR, CFE_AUTOBACKCOLOR, UI_SWATCHCOLORTYPE_NOCOLOR, UI_PKEY_FontProperties_BackgroundColorType>,
+		};
+
+		DWORD nProps = 0;
+		Reset();
+
+		ATLVERIFY(SUCCEEDED(pStore->GetCount(&nProps)));
+		for (DWORD iProp = 0; iProp < nProps; iProp++)
+		{
+			PROPERTYKEY key;	
+			ATLVERIFY(SUCCEEDED(pStore->GetAt(iProp, &key)));
+			ATLASSERT(k_(key) >= k_FontProperties_Family);
+
+			if (k_(key) <= k_FontProperties_BackgroundColorType)
+				(this->*Getk_[k_(key) - k_FontProperties_Family])(pStore);
+		}
+	}
+
+	void operator >>(IPropertyStore* pStore)
+	{
+		if (pStore == NULL)
+		{
+			ATLASSERT(FALSE);
+			return;
+		}
+
+		PutFace(pStore);
+		PutSize(pStore);
+		PutMaskEffect(CFM_BOLD, CFE_BOLD, UI_PKEY_FontProperties_Bold, pStore);
+		PutMaskEffect(CFM_ITALIC, CFE_ITALIC, UI_PKEY_FontProperties_Italic, pStore);
+		PutMaskEffect(CFM_UNDERLINE, CFE_UNDERLINE, UI_PKEY_FontProperties_Underline, pStore);
+		PutMaskEffect(CFM_STRIKEOUT, CFE_STRIKEOUT, UI_PKEY_FontProperties_Strikethrough, pStore);
+		PutVerticalPos(pStore);
+		PutColor(pStore);
+		PutBackColor(pStore);
+	}
+
+private:
+	PROPVARIANT propvar;
+	UINT uValue;
+
+	// Getk_ functions
+	void Getk_Family(IPropertyStore* pStore)
+	{
+		if (SUCCEEDED(pStore->GetValue(UI_PKEY_FontProperties_Family, &propvar)))
+		{
+			PropVariantToString(propvar, szFaceName, LF_FACESIZE);
+			if (*szFaceName)
+				dwMask |= CFM_FACE;
+		}
+	}
+
+	void Getk_FontProperties_Size(IPropertyStore* pStore)
+	{
+		if (SUCCEEDED(pStore->GetValue(UI_PKEY_FontProperties_Size, &propvar)))
+		{
+			DECIMAL decSize;
+			UIPropertyToDecimal(UI_PKEY_FontProperties_Size, propvar, &decSize);
+			DOUBLE dSize;
+			VarR8FromDec(&decSize, &dSize);
+			if (dSize > 0)
+			{
+				dwMask |= CFM_SIZE;
+				yHeight = (LONG)(dSize * TWIPS_PER_POINT);
+			}
+		}
+	}
+
+	template <DWORD t_dwMask, DWORD t_dwEffects, REFPROPERTYKEY key>
+	void Getk_MaskEffect(IPropertyStore* pStore)
+	{
+		if (SUCCEEDED(pStore->GetValue(key, &propvar)))
+		{
+			UIPropertyToUInt32(key, propvar, &uValue);
+			if ((UI_FONTPROPERTIES)uValue != UI_FONTPROPERTIES_NOTAVAILABLE)
+			{
+				dwMask |= t_dwMask;
+				dwEffects |= ((UI_FONTPROPERTIES) uValue == UI_FONTPROPERTIES_SET) ? t_dwEffects : 0;
+			}
+		}	
+	}
+
+	void Getk_VerticalPositioning(IPropertyStore* pStore)
+	{
+		if (SUCCEEDED(pStore->GetValue(UI_PKEY_FontProperties_VerticalPositioning, &propvar)))
+		{
+			UIPropertyToUInt32(UI_PKEY_FontProperties_VerticalPositioning, propvar, &uValue);
+			UI_FONTVERTICALPOSITION uVerticalPosition = (UI_FONTVERTICALPOSITION) uValue;
+			if ((uVerticalPosition != UI_FONTVERTICALPOSITION_NOTAVAILABLE))
+			{
+				dwMask |= (CFM_SUPERSCRIPT | CFM_SUBSCRIPT);
+				if (uVerticalPosition != UI_FONTVERTICALPOSITION_NOTSET)
+				{
+					dwEffects |= (uVerticalPosition == UI_FONTVERTICALPOSITION_SUPERSCRIPT) ? CFE_SUPERSCRIPT : CFE_SUBSCRIPT;
+				}
+			}
+		}
+	}
+
+	template <DWORD t_dwMask, REFPROPERTYKEY key>
+	void Getk_Color(IPropertyStore* pStore)
+	{
+		UINT32 color;
+		if (SUCCEEDED(pStore->GetValue(key, &propvar)))
+		{
+			UIPropertyToUInt32(key, propvar, &color);
+			dwMask |= t_dwMask;
+
+			if (t_dwMask == CFM_COLOR)
+				crTextColor = color;
+			else
+				crBackColor = color;
+		}
+	}
+
+	template <DWORD t_dwMask, DWORD t_dwEffects, UI_SWATCHCOLORTYPE t_type, REFPROPERTYKEY key>
+	void Getk_ColorType(IPropertyStore* pStore)
+	{
+		if (SUCCEEDED(pStore->GetValue(key, &propvar)))
+		{
+			UIPropertyToUInt32(key, propvar, &uValue);
+			if (t_type == (UI_SWATCHCOLORTYPE)uValue)
+			{
+				dwMask |= t_dwMask;
+				dwEffects |= t_dwEffects;
+			}
+		}
+	}
+
+	// Put functions
+	void PutMaskEffect(WORD dwMaskVal, WORD dwEffectVal, REFPROPERTYKEY key, IPropertyStore* pStore)
+	{
+		PROPVARIANT propvar;
+		UI_FONTPROPERTIES uProp = UI_FONTPROPERTIES_NOTAVAILABLE;
+		if ((dwMask & dwMaskVal) != 0)
+			uProp = dwEffects & dwEffectVal ? UI_FONTPROPERTIES_SET : UI_FONTPROPERTIES_NOTSET;
+		SetPropertyVal(key, uProp, &propvar);
+		pStore->SetValue(key, propvar);
+	}
+
+	void PutVerticalPos(IPropertyStore* pStore)
+	{
+		PROPVARIANT propvar;
+		UI_FONTVERTICALPOSITION uProp = UI_FONTVERTICALPOSITION_NOTAVAILABLE;
+
+		if ((dwMask & CFE_SUBSCRIPT) != 0)
+		{
+			if ((dwMask & CFM_SUBSCRIPT) && (dwEffects & CFE_SUBSCRIPT))
+				uProp = UI_FONTVERTICALPOSITION_SUBSCRIPT;
+			else
+				uProp = UI_FONTVERTICALPOSITION_SUPERSCRIPT;
+		}
+		else if ((dwMask & CFM_OFFSET) != 0)
+		{
+			if (yOffset > 0)
+				uProp = UI_FONTVERTICALPOSITION_SUPERSCRIPT;
+			else if (yOffset < 0)
+				uProp = UI_FONTVERTICALPOSITION_SUBSCRIPT;
+		}
+
+		SetPropertyVal(UI_PKEY_FontProperties_VerticalPositioning, uProp, &propvar);
+		pStore->SetValue(UI_PKEY_FontProperties_VerticalPositioning, propvar);
+	}
+
+	void PutFace(IPropertyStore* pStore)
+	{
+		PROPVARIANT propvar;
+		SetPropertyVal(UI_PKEY_FontProperties_Family, 
+			dwMask & CFM_FACE ? szFaceName : L"", &propvar);
+		pStore->SetValue(UI_PKEY_FontProperties_Family, propvar);
+	}
+
+	void PutSize(IPropertyStore* pStore)
+	{
+		PROPVARIANT propvar;
+		DECIMAL decVal;
+
+		if ((dwMask & CFM_SIZE) != 0)
+			VarDecFromR8((DOUBLE)yHeight / TWIPS_PER_POINT, &decVal);
+		else
+			VarDecFromI4(0, &decVal);
+
+		SetPropertyVal(UI_PKEY_FontProperties_Size, &decVal, &propvar);
+		pStore->SetValue(UI_PKEY_FontProperties_Size, propvar);
+	}
+
+	void PutColor(IPropertyStore* pStore)
+	{
+		if ((dwMask & CFM_COLOR) != 0)
+			if ((dwEffects & CFE_AUTOCOLOR) == 0)
+			{
+				SetPropertyVal(UI_PKEY_FontProperties_ForegroundColorType, UI_SWATCHCOLORTYPE_RGB, &propvar);
+				pStore->SetValue(UI_PKEY_FontProperties_ForegroundColorType, propvar);
+				
+				SetPropertyVal(UI_PKEY_FontProperties_ForegroundColor, crTextColor, &propvar);
+				pStore->SetValue(UI_PKEY_FontProperties_ForegroundColor, propvar);
+			}
+			else
+			{
+				SetPropertyVal(UI_PKEY_FontProperties_ForegroundColorType, UI_SWATCHCOLORTYPE_AUTOMATIC, &propvar);
+				pStore->SetValue(UI_PKEY_FontProperties_ForegroundColorType, propvar);
+			}
+	}
+
+	void PutBackColor(IPropertyStore* pStore)
+	{
+		if (((dwMask & CFM_BACKCOLOR) != 0) && ((dwEffects & CFE_AUTOBACKCOLOR) == 0))
+		{
+			SetPropertyVal(UI_PKEY_FontProperties_BackgroundColorType, UI_SWATCHCOLORTYPE_RGB, &propvar);
+			pStore->SetValue(UI_PKEY_FontProperties_BackgroundColorType, propvar);
+				
+			SetPropertyVal(UI_PKEY_FontProperties_BackgroundColor, crBackColor, &propvar);
+			pStore->SetValue(UI_PKEY_FontProperties_BackgroundColor, propvar);
+		}
+		else
+		{
+			SetPropertyVal(UI_PKEY_FontProperties_BackgroundColorType, UI_SWATCHCOLORTYPE_NOCOLOR, &propvar);
+			pStore->SetValue(UI_PKEY_FontProperties_BackgroundColorType, propvar);
+		}
+	}
+};
+
+// IUIImage helper
+//
+inline IUIImage* GetImage(HBITMAP hbm, UI_OWNERSHIP owner)
+{
+	ATLASSERT(hbm);
+	IUIImage* pIUII = NULL;
+	ATL::CComPtr<IUIImageFromBitmap> pIFB;
+
+	if SUCCEEDED(pIFB.CoCreateInstance(CLSID_UIRibbonImageFromBitmapFactory))
+		ATLVERIFY(SUCCEEDED(pIFB->CreateImage(hbm, owner, &pIUII)));
+
+	return pIUII;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Ribbon control classes
+
+// RibbonUI::ICtrl abstract interface of RibbonUI::CRibbonImpl and all RibbonUI control classes
+//
+struct ICtrl
+{
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* pCommandExecutionProperties) = 0;
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue) = 0;
+};
+
+// RibbonUI::CtrlImpl base class for all ribbon controls
+//
+template <class T, UINT t_ID>
+class ATL_NO_VTABLE CtrlImpl : public ICtrl
+{
+protected:
+	T* m_pWndRibbon;
+
+public:
+	typedef T WndRibbon;
+
+	CtrlImpl() : m_pWndRibbon(T::pWndRibbon)
+	{ }
+
+	WndRibbon& GetWndRibbon()
+	{
+		return *m_pWndRibbon;
+	}
+
+	static WORD GetID()
+	{
+		return t_ID;
+	}
+
+	Text m_sTxt[5];
+
+	// Operations
+	HRESULT Invalidate()
+	{
+		return GetWndRibbon().InvalidateCtrl(GetID());
+	}
+
+	HRESULT Invalidate(REFPROPERTYKEY key, UI_INVALIDATIONS flags = UI_INVALIDATIONS_PROPERTY)
+	{
+		return GetWndRibbon().InvalidateProperty(GetID(), key, flags);
+	}
+
+	HRESULT SetText(REFPROPERTYKEY key, LPCWSTR sTxt, bool bUpdate = false)
+	{
+		ATLASSERT((k_(key) <= k_TooltipTitle) && (k_(key) >= k_LabelDescription));
+
+		m_sTxt[k_(key) - k_LabelDescription] = sTxt;
+
+		return bUpdate ?
+			GetWndRibbon().InvalidateProperty(GetID(), key) :
+			S_OK;
+	}
+
+	// Implementation
+	template <typename V>
+	HRESULT SetProperty(REFPROPERTYKEY key, V val)
+	{
+		return GetWndRibbon().SetProperty(GetID(), key, val);
+	}
+
+	HRESULT OnGetText(REFPROPERTYKEY key, PROPVARIANT* ppv)
+	{
+		ATLASSERT((k_(key) <= k_TooltipTitle) && (k_(key) >= k_LabelDescription));
+
+		const INT iText = k_(key) - k_LabelDescription;
+		if (m_sTxt[iText].IsEmpty())
+			if (LPCWSTR sText = GetWndRibbon().OnRibbonQueryText(GetID(), key))
+				m_sTxt[iText] = sText;
+
+		return !m_sTxt[iText].IsEmpty() ?
+			SetPropertyVal(key, (LPCWSTR)m_sTxt[iText], ppv) :
+			S_OK;
+	}
+
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* pCommandExecutionProperties)
+	{
+		ATLASSERT(nCmdID == t_ID);
+		return GetWndRibbon().DoExecute(nCmdID, verb, key, ppropvarValue, pCommandExecutionProperties);
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT(nCmdID == t_ID);
+
+		const INT iMax = k_TooltipTitle - k_LabelDescription;
+		const INT iVal = k_(key) - k_LabelDescription;
+
+		return (iVal <= iMax) && (iVal >= 0) ?
+			OnGetText(key, ppropvarNewValue) :
+			GetWndRibbon().DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+	}
+};
+
+// CommandCtrlImpl base class for most ribbon controls
+//
+template <class T, UINT t_ID>
+class CommandCtrlImpl : public CtrlImpl<T, t_ID>
+{
+public:
+	CBitmap m_hbm[4];
+
+	HRESULT SetImage(REFPROPERTYKEY key, HBITMAP hbm, bool bUpdate = false)
+	{
+		ATLASSERT((k_(key) <= k_SmallHighContrastImage) && (k_(key) >= k_LargeImage));
+			
+		m_hbm[k_(key) - k_LargeImage].Attach(hbm);
+
+		return bUpdate ?
+			GetWndRibbon().InvalidateProperty(GetID(), key) :
+			S_OK;
+	}
+
+	HRESULT OnGetImage(REFPROPERTYKEY key, PROPVARIANT* ppv)
+	{
+		ATLASSERT((k_(key) <= k_SmallHighContrastImage) && (k_(key) >= k_LargeImage));
+
+		const INT iImage = k_(key) - k_LargeImage;
+
+		if (m_hbm[iImage].IsNull())
+			m_hbm[iImage] = GetWndRibbon().OnRibbonQueryImage(GetID(), key);
+
+		return m_hbm[iImage].IsNull() ?
+			E_NOTIMPL :
+			SetPropertyVal(key, GetImage(m_hbm[iImage], UI_OWNERSHIP_COPY), ppv);
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT (nCmdID == GetID());
+
+		return (k_(key) <= k_SmallHighContrastImage) && (k_(key) >= k_LargeImage) ?
+			OnGetImage(key, ppropvarNewValue) :
+			CtrlImpl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Ribbon collection base classes
+
+// ItemProperty class: ribbon callback for each item in a collection
+//
+template <class TCollection>
+class ItemProperty : public IUISimplePropertySet
+{
+public:
+	ItemProperty(UINT i, TCollection* pCollection) : m_Index(i), m_pCollection(pCollection)
+	{ }
+
+	const UINT m_Index;
+	TCollection* m_pCollection;
+
+	// IUISimplePropertySet method.
+	STDMETHODIMP GetValue(REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		return m_pCollection->OnGetItem(m_Index, key, value);
+	}
+
+	// IUnknown methods.
+	STDMETHODIMP_(ULONG) AddRef()
+	{
+		return 1;
+	}
+
+	STDMETHODIMP_(ULONG) Release()
+	{
+		return 1;
+	}
+
+	STDMETHODIMP QueryInterface(REFIID iid, void** ppv)
+	{
+		if ((iid == __uuidof(IUnknown)) || (iid == __uuidof(IUISimplePropertySet)))
+		{
+			*ppv = this;
+			return S_OK;
+		}
+		else
+		{
+			return E_NOINTERFACE;
+		}
+	}
+};
+
+
+// CollectionImplBase: base class for all RibbonUI collections
+//
+template <class TCollection, size_t t_size>
+class CollectionImplBase
+{
+	typedef CollectionImplBase<TCollection, t_size> thisClass;
+
+public:
+	CollectionImplBase()
+	{
+		for (int i = 0; i < t_size; i++)
+			m_apItems[i] = new ItemProperty<TCollection>(i, static_cast<TCollection*>(this));
+	}
+
+	~CollectionImplBase()
+	{
+		for (int i = 0; i < t_size; i++)
+			delete m_apItems[i];
+	}
+
+// Data members
+	ItemProperty<TCollection>* m_apItems[t_size];
+};
+
+// CollectionImpl: handles categories and collecton resizing
+//
+template <class TCtrl, size_t t_items, size_t t_categories>
+class CollectionImpl : public CollectionImplBase<CollectionImpl<TCtrl, t_items, t_categories>, t_items + t_categories>
+{
+	typedef CollectionImpl<TCtrl, t_items, t_categories> thisClass;
+public:
+	typedef thisClass Collection;
+
+	CollectionImpl() : m_size(t_items)
+	{
+		FillMemory(m_auItemCat, sizeof m_auItemCat, 0xff); // UI_COLLECTION_INVALIDINDEX
+	}
+
+	UINT32 m_auItemCat[t_items];
+	Text m_asCatName[max(t_categories, 1)];
+	size_t m_size;
+
+// Operations
+	HRESULT SetItemCategory(UINT uItem, UINT uCat, bool bUpdate = false)
+	{
+		ATLASSERT((uItem < t_items) && (uCat < t_categories));
+
+		m_auItemCat[uItem] = uCat;
+
+		return bUpdate ? InvalidateItems() : S_OK;
+	}
+
+	HRESULT SetCategoryText(UINT uCat, LPCWSTR sText, bool bUpdate = false)
+	{
+		ATLASSERT(uCat < t_categories);
+
+		m_asCatName[uCat] = sText;
+
+		return bUpdate ? InvalidateCategories() : S_OK;
+	}
+
+	HRESULT Resize(size_t size, bool bUpdate = false)
+	{
+		ATLASSERT(size <= t_items);
+
+		m_size = size;
+
+		return bUpdate ? InvalidateItems() : S_OK;
+	}
+
+// Implementation
+	HRESULT OnGetItem(UINT uIndex, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(uIndex < t_items + t_categories);
+		TCtrl* pCtrl = static_cast<TCtrl*>(this);
+
+		return uIndex < t_items ?
+			pCtrl->DoGetItem(uIndex, key, value) :
+			pCtrl->DoGetCategory(uIndex - t_items, key, value);
+	}
+
+	HRESULT DoGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(k_(key) == k_CategoryId);
+		UINT32 uCat = UI_COLLECTION_INVALIDINDEX;
+
+		if (t_categories != 0)
+		{
+			if (m_auItemCat[uItem] == UI_COLLECTION_INVALIDINDEX)
+			{
+				TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+				m_auItemCat[uItem] = ribbon.OnRibbonQueryItemCategory(TCtrl::GetID(), uItem);
+			}
+			uCat = m_auItemCat[uItem];
+		}
+
+		return SetPropertyVal(key, uCat, value);
+	}
+
+	HRESULT DoGetCategory(UINT uCat, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		HRESULT hr = S_OK;
+
+		switch (k_(key))
+		{
+		case k_Label:
+			if (m_asCatName[uCat].IsEmpty())
+			{
+				TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+				m_asCatName[uCat] = ribbon.OnRibbonQueryCategoryText(TCtrl::GetID(), uCat);
+			}
+			hr = SetPropertyVal(key, (LPCWSTR)m_asCatName[uCat], value);
+			break;
+		case k_CategoryId:
+			hr = SetPropertyVal(key, uCat, value);
+			break;
+		default:
+			ATLASSERT(FALSE);
+			break;
+		}
+
+		return hr;
+	}
+
+	HRESULT InvalidateItems()
+	{
+		return static_cast<TCtrl*>(this)->Invalidate(UI_PKEY_ItemsSource);
+	}
+
+	HRESULT InvalidateCategories()
+	{
+		return static_cast<TCtrl*>(this)->Invalidate(UI_PKEY_Categories);
+	}
+
+	HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                         const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* /*ppropvarNewValue*/)
+	{
+		ATLASSERT(nCmdID == TCtrl::GetID());
+		nCmdID;   // avoid level 4 warning
+
+		HRESULT hr = E_NOTIMPL;
+		switch (k_(key))
+		{
+		case k_ItemsSource:
+			{
+				ATL::CComQIPtr<IUICollection> pIUICollection(ppropvarCurrentValue->punkVal);
+				ATLASSERT(pIUICollection);
+				hr = pIUICollection->Clear();
+				for (UINT i = 0; i < m_size; i++)
+				{
+					if FAILED(hr = pIUICollection->Add(m_apItems[i]))
+						break;
+				}
+				ATLASSERT(SUCCEEDED(hr));
+			}
+			break;
+		case k_Categories:
+			if (t_categories != 0)
+			{
+				ATL::CComQIPtr<IUICollection> pIUICategory(ppropvarCurrentValue->punkVal);
+				ATLASSERT(pIUICategory.p);
+				hr = pIUICategory->Clear();
+				for (UINT i = t_items; i < t_items + t_categories; i++)
+				{
+					if FAILED(hr = pIUICategory->Add(m_apItems[i]))
+						break;
+				}
+				ATLASSERT(SUCCEEDED(hr));
+			}
+			break;
+		}
+
+		return hr;
+	}
+};
+
+// TextCollectionImpl: handles item labels and selection
+//
+template <class TCtrl, size_t t_items, size_t t_categories = 0>
+class TextCollectionImpl : public CollectionImpl<TCtrl, t_items, t_categories>
+{
+	typedef TextCollectionImpl<TCtrl, t_items, t_categories> thisClass;
+public:
+	typedef thisClass TextCollection;
+
+	TextCollectionImpl() : m_uSelected(UI_COLLECTION_INVALIDINDEX)
+	{ }
+
+	Text m_asText[t_items];
+	UINT m_uSelected;
+
+	// Operations
+	HRESULT SetItemText(UINT uItem, LPCWSTR sText, bool bUpdate = false)
+	{
+		ATLASSERT(uItem < t_items);
+
+		m_asText[uItem] = sText;
+
+		return bUpdate ? InvalidateItems() : S_OK;
+	}
+
+	UINT GetSelected()
+	{
+		return m_uSelected;
+	}
+
+	HRESULT Select(UINT uItem, bool bUpdate = false)
+	{
+		ATLASSERT((uItem < t_items) || (uItem == UI_COLLECTION_INVALIDINDEX));
+
+		m_uSelected = uItem;
+
+		TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+		return bUpdate ?
+			ribbon.SetProperty(TCtrl::GetID(), UI_PKEY_SelectedItem, uItem) : 
+			S_OK;
+	}
+
+// Implementation
+ 	HRESULT DoGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(uItem < t_items);
+
+		if (k_(key) == k_Label)
+		{
+			if (m_asText[uItem].IsEmpty())
+			{
+				TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+				m_asText[uItem] = ribbon.OnRibbonQueryItemText(TCtrl::GetID(), uItem);
+			}
+			return SetPropertyVal(key, (LPCWSTR)m_asText[uItem], value);
+		}
+		else
+		{
+			return Collection::DoGetItem(uItem, key, value);
+		}
+	}
+
+	HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                         const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT(nCmdID == TCtrl::GetID());
+
+		if (k_(key) == k_SelectedItem)
+		{
+			TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+			UINT uSel = UI_COLLECTION_INVALIDINDEX;
+			if ((m_uSelected == UI_COLLECTION_INVALIDINDEX) &&
+			    ribbon.OnRibbonQuerySelectedItem(TCtrl::GetID(), uSel))
+				m_uSelected = uSel;
+
+			return SetPropertyVal(key, m_uSelected, ppropvarNewValue);
+		}
+		else
+		{
+			return Collection::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+		}
+	}
+};
+
+// ItemCollectionImpl: handles item image
+//
+template <class TCtrl, size_t t_items, size_t t_categories = 0>
+class ItemCollectionImpl : public TextCollectionImpl<TCtrl, t_items, t_categories>
+{
+	typedef ItemCollectionImpl<TCtrl, t_items, t_categories> thisClass;
+public:
+	typedef thisClass ItemCollection;
+	
+	ItemCollectionImpl()
+	{
+		ZeroMemory(m_aBitmap, sizeof m_aBitmap);
+	}
+
+	CBitmap m_aBitmap[t_items];
+
+	// Operations
+	HRESULT SetItemImage(UINT uIndex, HBITMAP hbm, bool bUpdate = false)
+	{
+		ATLASSERT(uIndex < t_items);
+
+		m_aBitmap[uIndex] = hbm;
+
+		return bUpdate ? InvalidateItems() : S_OK;
+	}
+
+// Implementation
+	HRESULT DoGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(uItem < t_items);
+
+		if (k_(key) == k_ItemImage)
+		{
+			if (m_aBitmap[uItem].IsNull())
+			{
+				TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+				m_aBitmap[uItem] = ribbon.OnRibbonQueryItemImage(TCtrl::GetID(), uItem);
+			}
+			return m_aBitmap[uItem].IsNull() ?
+				E_NOTIMPL :
+				SetPropertyVal(key, GetImage(m_aBitmap[uItem], UI_OWNERSHIP_COPY), value);
+		}
+		else
+		{
+			return TextCollection::DoGetItem(uItem, key, value);
+		}
+	}
+};
+
+// ComboCollectionImpl: handles combo text
+//
+template <class TCtrl, size_t t_items, size_t t_categories = 0>
+class ComboCollectionImpl : public ItemCollectionImpl<TCtrl, t_items, t_categories>
+{
+	typedef ComboCollectionImpl<TCtrl, t_items, t_categories> thisClass;
+public:
+	typedef thisClass ComboCollection;
+
+	// Operations
+	HRESULT SetComboText(LPCWSTR sText)
+	{
+		TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+		return ribbon.IsRibbonUI() ? 
+			ribbon.SetProperty(TCtrl::GetID(), UI_PKEY_StringValue, sText) : 
+			S_OK;
+	}
+
+	LPCWSTR GetComboText()
+	{
+		static WCHAR sCombo[RIBBONUI_MAX_TEXT] = { 0 };
+		TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+		PROPVARIANT var;
+		if (ribbon.IsRibbonUI())
+		{
+			HRESULT hr = ribbon.GetIUIFrameworkPtr()->GetUICommandProperty(TCtrl::GetID(), UI_PKEY_StringValue, &var);
+			hr = PropVariantToString(var, sCombo, RIBBONUI_MAX_TEXT);
+			return sCombo;
+		}
+		return NULL;
+	}
+};
+
+// CommandCollectionImpl: handles RibbonUI command collection controls
+//
+template <class TCtrl, size_t t_items, size_t t_categories = 0>
+class CommandCollectionImpl : public CollectionImpl<TCtrl, t_items, t_categories>
+{
+	typedef CommandCollectionImpl<TCtrl, t_items, t_categories> thisClass;
+public:
+	typedef thisClass CommandCollection;
+
+	CommandCollectionImpl()
+	{
+		ZeroMemory(m_auCmd, sizeof m_auCmd);
+		ZeroMemory(m_aCmdType, sizeof m_aCmdType);
+	}
+
+	UINT32 m_auCmd[t_items];
+	BYTE m_aCmdType[t_items];
+
+	// Operations
+	HRESULT SetItemCommand(UINT uItem, UINT32 uCommandID, bool bUpdate = false)
+	{
+		ATLASSERT(uItem < t_items);
+
+		if (uCommandID == m_auCmd[uItem])
+			return S_OK;
+
+		TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+
+		m_auCmd[uItem] = uCommandID;
+		if (uCommandID != 0)
+			ribbon.UIAddRibbonElement(uCommandID);
+
+		return bUpdate ? InvalidateItems() : S_OK;
+	}
+
+	HRESULT SetItemCommandType(UINT uItem, UI_COMMANDTYPE type, bool bUpdate = false)
+	{
+		ATLASSERT(uItem < t_items);
+
+		m_aCmdType[uItem] = (BYTE)type;
+
+		return bUpdate ? InvalidateItems() : S_OK;
+	}
+
+// Implementation
+ 	HRESULT DoGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(uItem < t_items);
+		TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+
+		HRESULT hr = E_FAIL;
+		switch (k_(key))
+		{
+		case k_CommandId:
+			if (m_auCmd[uItem] == 0)
+				SetItemCommand(uItem, ribbon.OnRibbonQueryItemCommand(TCtrl::GetID(), uItem));
+			hr = SetPropertyVal(key, m_auCmd[uItem], value);
+			break;
+		case k_CommandType:
+			if (m_aCmdType[uItem] == UI_COMMANDTYPE_UNKNOWN)
+				SetItemCommandType(uItem, ribbon.OnRibbonQueryItemCommandType(TCtrl::GetID(), uItem));
+			hr = SetPropertyVal(key, UINT32(m_aCmdType[uItem]), value);
+			break;
+		case k_CategoryId:
+		default:
+			hr = Collection::DoGetItem(uItem, key, value);
+			break;
+		}
+
+		return hr;
+	}
+
+	HRESULT Select(UINT /*uItem*/, bool /*bUpdate*/ = false)
+	{
+		ATLASSERT(FALSE);
+		return S_OK;
+	}
+};
+
+// SimpleCollectionImpl: collection class for ribbon simple collection controls
+//
+template <class TCtrl, size_t t_size, UI_COMMANDTYPE t_CommandType = UI_COMMANDTYPE_ACTION>
+class SimpleCollectionImpl : public CollectionImplBase<SimpleCollectionImpl<TCtrl, t_size>, t_size>
+{
+	typedef SimpleCollectionImpl<TCtrl, t_size, t_CommandType> thisClass;
+public:
+	typedef CollectionImplBase<thisClass, t_size> CollectionBase;
+	typedef thisClass SimpleCollection;
+
+// Implementation
+	HRESULT OnGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(uItem < t_size);
+		TCtrl::WndRibbon& ribbon = static_cast<TCtrl*>(this)->GetWndRibbon();
+
+		HRESULT hr = E_NOTIMPL;
+		switch (k_(key))
+		{
+		case k_ItemImage:
+			if (HBITMAP hbm = ribbon.DefRibbonQueryItemImage(TCtrl::GetID(), uItem))
+				hr = SetPropertyVal(key, GetImage(hbm, UI_OWNERSHIP_TRANSFER), value);
+			break;
+		case k_Label:
+			if (LPCWSTR sText = ribbon.DefRibbonQueryItemText(TCtrl::GetID(), uItem))
+				hr = SetPropertyVal(key, (LPCWSTR)sText, value);
+			break;
+		case k_CommandType:
+			hr = SetPropertyVal(key, t_CommandType, value);
+			break;
+		case k_CommandId:
+			hr = SetPropertyVal(key, ribbon.DefRibbonQueryItemCommand(TCtrl::GetID(), uItem), value);
+			break;
+		case k_CategoryId:
+			hr = SetPropertyVal(key, UI_COLLECTION_INVALIDINDEX, value);
+			break;
+		default:
+			ATLASSERT(FALSE);
+			break;
+		}
+
+		return hr;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Ribbon collection control classes
+
+// CollectionCtrlImpl: specializable class for ribbon collection controls
+//
+template <class T, UINT t_ID, class TCollection>
+class CollectionCtrlImpl : public CommandCtrlImpl<T, t_ID>, public TCollection
+{
+	typedef CollectionCtrlImpl<T, t_ID, TCollection> thisClass;
+public:
+	typedef CommandCtrlImpl<T, t_ID> CommandCtrl;
+	typedef TCollection Collection;
+
+	// Implementation
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT(nCmdID == GetID());
+		ATLASSERT(ppropvarNewValue);
+
+		HRESULT hr = Collection::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+		if FAILED(hr)
+			hr = CommandCtrl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+
+		return hr;
+	}
+
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* /*pCommandExecutionProperties*/)
+	{
+		ATLASSERT (nCmdID == GetID());
+		nCmdID; // avoid level4 warning
+
+		if (key == NULL) // gallery button pressed
+		{
+			GetWndRibbon().OnRibbonItemSelected(GetID(), UI_EXECUTIONVERB_EXECUTE, UI_COLLECTION_INVALIDINDEX);
+			return S_OK;
+		}
+
+		ATLASSERT(k_(*key) == k_SelectedItem);
+		ATLASSERT(ppropvarValue);
+
+		HRESULT hr = S_OK;
+		UINT32 uSel = 0xffff;
+		hr = UIPropertyToUInt32(*key, *ppropvarValue, &uSel);
+
+		if (SUCCEEDED(hr))
+		{
+			if (GetWndRibbon().OnRibbonItemSelected(GetID(), verb, uSel))
+				TCollection::Select(uSel);
+		}
+
+		return hr;
+	}
+};
+
+// ToolbarGalleryCtrlImpl: base class for ribbon toolbar gallery controls
+//
+template <class T, UINT t_ID, UINT t_idTB, size_t t_size>
+class ToolbarGalleryCtrlImpl : public CollectionCtrlImpl<T, t_ID, CommandCollectionImpl<ToolbarGalleryCtrlImpl<T, t_ID, t_idTB, t_size>, t_size>>
+{
+public:
+	ToolbarGalleryCtrlImpl()
+	{
+		CResource tbres;
+		ATLVERIFY(tbres.Load(RT_TOOLBAR, t_idTB));
+		_AtlToolBarData* pData = (_AtlToolBarData*)tbres.Lock();
+		ATLASSERT(pData);
+		ATLASSERT(pData->wVersion == 1);
+
+		WORD* pItems = pData->items();
+		INT j = 0;
+		for (int i = 0; (i < pData->wItemCount) && (j < t_size); i++)
+		{
+			if (pItems[i] != 0)
+			{
+				m_aCmdType[j] = UI_COMMANDTYPE_ACTION;
+				m_auCmd[j++] = pItems[i];
+			}
+		}
+
+		if (j < t_size)
+			Resize(j);
+	}
+
+ 	HRESULT DoGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT(uItem < m_size);
+		ATLASSERT(m_auCmd[uItem]);
+
+		HRESULT hr = E_FAIL;
+		switch (k_(key))
+		{
+		case k_CommandId:
+			hr = SetPropertyVal(key, m_auCmd[uItem], value);
+			break;
+		case k_CommandType:
+			hr = SetPropertyVal(key, UINT32(m_aCmdType[uItem]), value);
+			break;
+		case k_CategoryId:
+			hr = SetPropertyVal(key, UI_COLLECTION_INVALIDINDEX, value);
+			break;
+		default:
+			ATLASSERT(FALSE);
+			break;
+		}
+
+		return hr;
+	}
+};
+
+
+// SimpleCollectionCtrlImpl: base class for simple gallery and listbox controls
+//
+template <class T, UINT t_ID, size_t t_size, UI_COMMANDTYPE t_CommandType = UI_COMMANDTYPE_ACTION>
+class SimpleCollectionCtrlImpl : 
+		public CommandCtrlImpl<T, t_ID>,
+		public SimpleCollectionImpl<SimpleCollectionCtrlImpl<T, t_ID, t_size, t_CommandType>, t_size, t_CommandType>
+{
+	typedef SimpleCollectionCtrlImpl<T, t_ID, t_size, t_CommandType> thisClass;
+public:
+	typedef thisClass SimpleCollection;
+
+	SimpleCollectionCtrlImpl() : m_uSelected(0)
+	{ }
+
+	UINT m_uSelected;
+
+	HRESULT Select(UINT uItem, bool bUpdate = false)
+	{
+		ATLASSERT((uItem < t_size) || (uItem == UI_COLLECTION_INVALIDINDEX));
+
+		m_uSelected = uItem;
+
+		return bUpdate ? 
+			GetWndRibbon().SetProperty(GetID(), UI_PKEY_SelectedItem, uItem) : 
+			S_OK;
+	}
+
+	// Implementation
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT(nCmdID == GetID());
+		ATLASSERT(ppropvarNewValue != NULL);
+
+		HRESULT hr = S_OK;
+		switch (k_(key))
+		{
+		case k_ItemsSource:
+			{
+				ATL::CComQIPtr<IUICollection> pIUICollection(ppropvarCurrentValue->punkVal);
+				ATLASSERT(pIUICollection.p);
+				hr = pIUICollection->Clear();
+				for (UINT i = 0; i < t_size; i++)
+				{
+					if FAILED(hr = pIUICollection->Add(m_apItems[i]))
+						break;
+				}
+				ATLASSERT(SUCCEEDED(hr));
+			}
+			break;
+		case k_SelectedItem:
+			hr = SetPropertyVal(UI_PKEY_SelectedItem, m_uSelected, ppropvarNewValue);
+			break;
+		default:
+			hr = CommandCtrlImpl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+			break;
+		}
+
+		return hr;
+	}
+
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* /*pCommandExecutionProperties*/)
+	{
+		ATLASSERT (nCmdID == GetID());
+		nCmdID;   // avoid level 4 warning
+		
+		HRESULT hr = S_OK;
+		if (key == NULL) // gallery button pressed
+		{
+			GetWndRibbon().OnRibbonItemSelected(GetID(), UI_EXECUTIONVERB_EXECUTE, UI_COLLECTION_INVALIDINDEX);
+			return hr;
+		}
+		ATLASSERT(k_(*key) == k_SelectedItem);
+		ATLASSERT(ppropvarValue);
+
+		if SUCCEEDED(hr = UIPropertyToUInt32(*key, *ppropvarValue, &m_uSelected))
+			GetWndRibbon().OnRibbonItemSelected(GetID(), verb, m_uSelected);
+
+		return hr;
+	}
+};
+
+// RecentItemsCtrlImpl
+//
+template <class T, UINT t_ID, class TDocList = CRecentDocumentList>
+class RecentItemsCtrlImpl : 
+		public CtrlImpl<T, t_ID>,
+		public CollectionImplBase<RecentItemsCtrlImpl<T, t_ID, TDocList>, TDocList::m_nMaxEntries_Max>,
+		public TDocList
+{
+	typedef RecentItemsCtrlImpl<T, t_ID, TDocList> thisClass;
+public:
+	typedef thisClass RecentItems;
+
+	// Implementation
+	HRESULT OnGetItem(UINT uItem, REFPROPERTYKEY key, PROPVARIANT *value)
+	{
+		ATLASSERT((INT)uItem < GetMaxEntries());
+
+		LPCWSTR sPath = m_arrDocs[uItem].szDocName;
+		HRESULT hr = E_NOTIMPL;
+		switch (k_(key))
+		{
+		case k_Label:
+			hr = SetPropertyVal(key, GetWndRibbon().OnRibbonQueryRecentItemName(sPath), value);
+			break;
+		case k_LabelDescription:
+			hr = SetPropertyVal(key, sPath, value);
+			break;
+		default:
+			ATLASSERT(FALSE);
+			break;
+		}
+
+		return hr;
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT(nCmdID == GetID());
+		ATLASSERT(ppropvarNewValue);
+
+		HRESULT hr = S_OK;
+		switch (k_(key))
+		{
+		case k_RecentItems:
+			if (SAFEARRAY* psa = SafeArrayCreateVector(VT_UNKNOWN, 0, m_arrDocs.GetSize()))
+			{
+				const int iLastIndex = m_arrDocs.GetSize() - 1;
+				for (LONG i = 0; i <= iLastIndex; i++)
+					SafeArrayPutElement(psa, &i, m_apItems[iLastIndex - i]); // reverse order
+
+				hr = SetPropertyVal(key, psa, ppropvarNewValue);
+				SafeArrayDestroy(psa);
+			}
+			break;
+		default:
+			hr = CtrlImpl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+			break;
+		}
+
+		return hr;
+	}
+
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* /*pCommandExecutionProperties*/)
+	{
+		ATLASSERT(nCmdID == GetID());
+		nCmdID;   // avoid level 4 warning
+		ATLASSERT(verb == UI_EXECUTIONVERB_EXECUTE);
+		verb;   // avoid level 4 warning
+		ATLASSERT((key) && (k_(*key) == k_SelectedItem));
+		ATLASSERT(ppropvarValue);
+
+		UINT32 uSel = 0xffff;
+		HRESULT hr = UIPropertyToUInt32(*key, *ppropvarValue, &uSel);
+		if SUCCEEDED(hr)
+		{
+			ATLASSERT(uSel < (UINT)GetMaxEntries());
+			GetWndRibbon().DefCommandExecute(ID_FILE_MRU_FIRST + uSel);
+		}
+
+		return hr;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Ribbon stand-alone control classes
+
+// FontCtrlImpl
+//
+template <class T, UINT t_ID>
+class FontCtrlImpl : public CtrlImpl<T, t_ID>
+{
+public:
+
+	CharFormat m_cf;
+
+// Implementation
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* pCommandExecutionProperties)
+	{
+		ATLASSERT (nCmdID == GetID());
+		nCmdID;   // avoid level 4 warning
+		ATLASSERT ((key) && (k_(*key) == k_FontProperties));
+		key;   // avoid level 4 warning
+
+		HRESULT hr = E_INVALIDARG;
+		switch (verb)
+		{
+			case UI_EXECUTIONVERB_PREVIEW:
+			case UI_EXECUTIONVERB_EXECUTE:
+				ATLASSERT(pCommandExecutionProperties);
+				PROPVARIANT propvar;
+
+				if (SUCCEEDED(hr = pCommandExecutionProperties->GetValue(UI_PKEY_FontProperties_ChangedProperties, &propvar)))
+					m_cf << ATL::CComQIPtr<IPropertyStore>(propvar.punkVal);
+				break;
+
+			case UI_EXECUTIONVERB_CANCELPREVIEW:
+				ATLASSERT(ppropvarValue);
+				ATL::CComPtr<IPropertyStore> pStore;
+
+				if (SUCCEEDED(hr = UIPropertyToInterface(UI_PKEY_FontProperties, *ppropvarValue, &pStore)))
+					m_cf << pStore;
+				break;
+		}
+
+		if (SUCCEEDED(hr))
+			GetWndRibbon().OnRibbonFontCtrlExecute(GetID(), verb, &m_cf);
+		else
+			ATLASSERT(FALSE);
+
+		return hr;
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		if ((k_(key) == k_FontProperties) && (GetWndRibbon().OnRibbonQueryFont(t_ID, m_cf)))
+		{
+			ATL::CComQIPtr<IPropertyStore> pStore(ppropvarCurrentValue->punkVal);
+			m_cf >> pStore;
+			return SetPropertyVal(key, pStore.p, ppropvarNewValue);
+		}
+		else
+		{
+			return CtrlImpl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+		}
+	}
+};
+
+// ColorCtrlImpl
+//
+template <class T, UINT t_ID>
+class ColorCtrlImpl : public CommandCtrlImpl<T, t_ID>
+{
+public:
+	ColorCtrlImpl() : m_colorType(UI_SWATCHCOLORTYPE_NOCOLOR), m_color(0x800080) /*MAGENTA*/
+	{ }
+
+	COLORREF m_color;
+	UINT32 m_colorType; // value in UI_SWATCHCOLORTYPE
+	Text m_sLabels[6]; // k_MoreColorsLabel to k_ThemeColorsCategoryLabel
+	ATL::CSimpleArray<COLORREF> m_aColors[2];
+	ATL::CSimpleArray<LPCWSTR> m_aTooltips[2];
+
+	// Operations
+	HRESULT SetColor(COLORREF color, bool bUpdate = false)
+	{
+		if (m_colorType != UI_SWATCHCOLORTYPE_RGB)
+			SetColorType(UI_SWATCHCOLORTYPE_RGB, bUpdate);
+		m_color = color;
+		return bUpdate ? SetProperty(UI_PKEY_Color, color) : S_OK;
+	}
+
+	HRESULT SetColorType(UI_SWATCHCOLORTYPE type, bool bUpdate = false)
+	{
+		m_colorType = type;
+		return bUpdate ? SetProperty(UI_PKEY_ColorType, type) : S_OK;
+	}
+
+	HRESULT SetColorLabel(REFPROPERTYKEY key, LPCWSTR sLabel, bool bUpdate = false)
+	{
+		ATLASSERT((k_(key) >= k_ThemeColorsCategoryLabel) && (k_(key) <= k_MoreColorsLabel));
+		m_sLabels[k_(key) - k_ThemeColorsCategoryLabel] = sLabel;
+		return bUpdate ? SetProperty(key, sLabel) : S_OK;
+	}
+
+	HRESULT SetColorArray(REFPROPERTYKEY key, COLORREF* pColor, bool bUpdate = false)
+	{
+		ATLASSERT((k_(key) == k_ThemeColors) || (k_(key) == k_StandardColors));
+
+		const INT ic = k_(key) - k_ThemeColors;
+		m_aColors[ic].RemoveAll();
+		while (*pColor != 0x800080) /*MAGENTA*/
+			m_aColors[ic].Add(*pColor++);
+
+		if (bUpdate)
+		{
+			PROPVARIANT var;
+			if SUCCEEDED(InitPropVariantFromUInt32Vector(m_aColors[ic].GetData(), m_aColors[ic].GetSize(), &var))
+				return SetProperty(key, var);
+			else
+				return E_INVALIDARG;
+		}
+		else
+		{
+			return S_OK;
+		}
+	}
+
+	HRESULT SetColorTooltips(REFPROPERTYKEY key, LPCWSTR* ppsTT, bool bUpdate = false)
+	{
+		ATLASSERT((k_(key) == k_ThemeColorsTooltips) || (k_(key) == k_StandardColorsTooltips));
+
+		const INT ic = k_(key) - k_ThemeColorsTooltips;
+		m_aTooltips[ic].RemoveAll();
+		while (*ppsTT)
+			m_aTooltips[ic].Add(*ppsTT++);
+
+		if (bUpdate)
+		{
+			PROPVARIANT var;
+			if SUCCEEDED(InitPropVariantFromStringVector(m_aTooltips[ic].GetData(), m_aTooltips[ic].GetSize(), &var))
+				return SetProperty(key, var);
+			else
+				return E_INVALIDARG;
+		}
+		else
+		{
+			return S_OK;
+		}
+	}
+
+	// Implementation
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* pCommandExecutionProperties)
+	{
+		ATLASSERT (nCmdID == GetID());
+		nCmdID;   // avoid level 4 warning
+		ATLASSERT (key && (k_(*key) == k_ColorType));
+		key;   // avoid level 4 warning
+		ATLASSERT (ppropvarValue);
+
+		HRESULT hr = PropVariantToUInt32(*ppropvarValue, &m_colorType);
+		ATLASSERT(SUCCEEDED(hr));
+
+		if (SUCCEEDED(hr) && (m_colorType == UI_SWATCHCOLORTYPE_RGB))
+		{
+			ATLASSERT(pCommandExecutionProperties);
+			PROPVARIANT var;
+			if SUCCEEDED(hr = pCommandExecutionProperties->GetValue(UI_PKEY_Color, &var))
+				hr = PropVariantToUInt32(var, &m_color);
+		}
+
+		if SUCCEEDED(hr)
+			GetWndRibbon().OnRibbonColorCtrlExecute(GetID(), verb, (UI_SWATCHCOLORTYPE)m_colorType/*uType*/, m_color);
+		else
+			ATLASSERT(FALSE); // something was wrong
+
+		return hr;
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT (nCmdID == GetID());
+
+		HRESULT hr = E_NOTIMPL;
+
+		switch (k_(key))
+		{
+		case k_ColorType:
+			hr = SetPropertyVal(key, m_colorType, ppropvarNewValue);
+			break;
+		case k_Color:
+			if (m_color == 0x800080) /*MAGENTA*/
+				m_color = GetWndRibbon().OnRibbonQueryColor(GetID());
+			hr = SetPropertyVal(key, m_color, ppropvarNewValue);
+			break;
+		case k_ColorMode:
+			break;
+		case k_ThemeColorsCategoryLabel:
+		case k_StandardColorsCategoryLabel:
+		case k_RecentColorsCategoryLabel:
+		case k_AutomaticColorLabel:
+		case k_NoColorLabel:
+		case k_MoreColorsLabel:
+			{
+				const UINT iLabel = k_(key) - k_ThemeColorsCategoryLabel;
+				if (m_sLabels[iLabel].IsEmpty())
+					if (LPCWSTR psLabel = GetWndRibbon().OnRibbonQueryColorLabel(GetID(), key))
+						m_sLabels[iLabel] = psLabel;
+				if (!m_sLabels[iLabel].IsEmpty())
+					hr = SetPropertyVal(key, (LPCWSTR)m_sLabels[iLabel], ppropvarNewValue);
+			}
+			break;
+		case k_ThemeColors:
+		case k_StandardColors:
+			{
+				const INT ic = k_(key) - k_ThemeColors;
+				if (!m_aColors[ic].GetSize())
+					if (COLORREF* pColor = GetWndRibbon().OnRibbonQueryColorArray(GetID(), key))
+						SetColorArray(key, pColor);
+				if (INT iMax = m_aColors[ic].GetSize())
+					hr = InitPropVariantFromUInt32Vector(m_aColors[ic].GetData(), iMax, ppropvarNewValue);
+			}
+			break;
+		case k_ThemeColorsTooltips:
+		case k_StandardColorsTooltips:
+			{
+				const INT ic = k_(key) - k_ThemeColorsTooltips;
+				if (m_aTooltips[ic].GetSize() == 0)
+					if (LPCWSTR* ppsTT = GetWndRibbon().OnRibbonQueryColorTooltips(GetID(), key))
+						SetColorTooltips(key, ppsTT);
+				if (INT iMax = m_aTooltips[ic].GetSize())
+					hr = InitPropVariantFromStringVector(m_aTooltips[ic].GetData(), iMax, ppropvarNewValue);
+			}
+			break;
+		default:
+			hr = CommandCtrlImpl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+			break;
+		}
+
+		return hr;
+	}
+};
+
+// SpinnerCtrlImpl
+//
+template <class T, UINT t_ID, typename V = LONG>
+class SpinnerCtrlImpl : public CtrlImpl<T, t_ID>
+{
+public:
+	SpinnerCtrlImpl()
+	{
+		m_Values[0] = m_Values[2] = m_Values[4] = 0;
+		m_Values[1] = 100;
+		m_Values[3] = 1;
+	}
+
+	V m_Values[5];
+		// k_DecimalValue = 201, k_MaxValue = 203, k_MinValue, k_Increment, k_DecimalPlaces
+		
+	Text m_FormatString;
+	Text m_RepresentativeString;
+
+	// Operations
+	HRESULT SetDecimalPlaces(V vPlaces, bool bUpdate = false)
+	{
+		return SetValue(UI_PKEY_DecimalPlaces, vPlaces, bUpdate);
+	}
+
+	HRESULT SetMin(V vMin, bool bUpdate = false)
+	{
+		return SetValue(UI_PKEY_MinValue, vMin, bUpdate);
+	}
+
+	HRESULT SetMax(V vMax, bool bUpdate = false)
+	{
+		return SetValue(UI_PKEY_MaxValue, vMax, bUpdate);
+	}
+
+	HRESULT SetVal(V vVal, bool bUpdate = false)
+	{
+		return SetValue(UI_PKEY_DecimalValue, vVal, bUpdate);
+	}
+
+	HRESULT SetIncrement(V vIncrement, bool bUpdate = false)
+	{
+		return SetValue(UI_PKEY_Increment, vIncrement, bUpdate);
+	}
+
+	HRESULT SetFormatString(LPCWSTR sFormat, bool bUpdate = false)
+	{
+		return SetText(UI_PKEY_FormatString, sFormat, bUpdate);
+	}
+
+	HRESULT SetRepresentativeString(LPCWSTR sRepresentative, bool bUpdate = false)
+	{
+		return SetText(UI_PKEY_RepresentativeString, sRepresentative, bUpdate);
+	}
+
+	// Implementation
+	HRESULT SetText(REFPROPERTYKEY key, LPCWSTR sText, bool bUpdate = false)
+	{
+		switch (k_(key))
+		{
+		case k_FormatString:
+			m_FormatString = sText;
+			break;
+		case k_RepresentativeString:
+			m_RepresentativeString = sText;
+			break;
+		default:
+			return CtrlImpl::SetText(key, sText, bUpdate);
+		}
+
+		return bUpdate ?
+			GetWndRibbon().InvalidateProperty(GetID(), key) :
+			S_OK;
+	}
+
+	HRESULT SetValue(REFPROPERTYKEY key, V val, bool bUpdate = false)
+	{
+		ATLASSERT((k_(key) <= k_DecimalPlaces) && (k_(key) >= k_DecimalValue));
+
+		const INT iVal = k_(key) == k_DecimalValue ? 0 : k_(key) - k_StringValue;
+		m_Values[iVal] = val;
+
+		if (bUpdate)
+		{
+			if(k_(key) == k_DecimalValue)
+			{
+				DECIMAL decVal;
+				InitDecimal(val, &decVal);
+				return SetProperty(key, &decVal);
+			}
+			else
+			{
+				return GetWndRibbon().InvalidateProperty(GetID(), key);
+			}
+		}
+		else
+		{
+			return S_OK;
+		}
+	}
+
+	HRESULT QueryValue(REFPROPERTYKEY key, LONG* plVal)
+	{
+		return GetWndRibbon().OnRibbonQuerySpinnerValue(GetID(), key, plVal);
+	}
+
+	HRESULT QueryValue(REFPROPERTYKEY key, DOUBLE* pdVal)
+	{
+		return GetWndRibbon().OnRibbonQueryFloatSpinnerValue(GetID(), key, pdVal);
+	}
+
+	HRESULT OnGetValue(REFPROPERTYKEY key, PROPVARIANT* ppv)
+	{
+		ATLASSERT((k_(key) <= k_DecimalPlaces) && (k_(key) >= k_DecimalValue));
+
+		const INT iVal = k_(key) == k_DecimalValue ? 0 : k_(key) - k_StringValue;
+
+		QueryValue(key, m_Values + iVal);
+
+		if (k_(key) == k_DecimalPlaces)
+		{
+			return SetPropertyVal(key, m_Values[iVal], ppv);
+		}
+		else
+		{
+			DECIMAL decVal;
+			InitDecimal(m_Values[iVal], &decVal);
+			return SetPropertyVal(key, &decVal, ppv);
+		}
+	}
+
+	HRESULT OnGetText(REFPROPERTYKEY key, Text& sVal, PROPVARIANT* ppv)
+	{
+		if (LPCWSTR sNew = GetWndRibbon().OnRibbonQueryText(GetID(), key))
+			sVal = sNew;
+		return SetPropertyVal(key, (LPCWSTR)sVal, ppv);
+	}
+
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* /*pCommandExecutionProperties*/)
+	{
+		ATLASSERT (nCmdID == GetID());
+		nCmdID;   // avoid level 4 warning
+		ATLASSERT (key && (k_(*key) == k_DecimalValue));
+		key;   // avoid level 4 warning
+		ATLASSERT (verb == UI_EXECUTIONVERB_EXECUTE);
+		verb;   // avoid level 4 warning
+
+		DECIMAL decVal;
+
+		HRESULT hr = UIPropertyToDecimal(UI_PKEY_DecimalValue, *ppropvarValue, &decVal);
+		hr = InitVal(m_Values[0], &decVal);
+
+		GetWndRibbon().OnRibbonSpinnerCtrlExecute(GetID(), &m_Values[0]);
+
+		return hr;
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                                 const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		ATLASSERT (nCmdID == GetID());
+
+		HRESULT hr = E_NOTIMPL;
+		switch (k_(key))
+		{
+		case k_DecimalPlaces:
+		case k_DecimalValue:
+		case k_Increment:
+		case k_MaxValue:
+		case k_MinValue:
+			hr = OnGetValue(key, ppropvarNewValue);
+			break;
+		case k_FormatString:
+			if (m_FormatString.IsEmpty())
+				return OnGetText(key, m_FormatString, ppropvarNewValue);
+			break;
+		case k_RepresentativeString:
+			if (m_RepresentativeString.IsEmpty())
+				return OnGetText(key, m_RepresentativeString, ppropvarNewValue);
+			break;
+		default:
+			hr = CtrlImpl::DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);
+			break;
+		}
+
+		return hr;
+	}
+
+	// decimal conversion helpers
+	static HRESULT InitDecimal(LONG& val, DECIMAL* pDecimal)
+	{
+		return ::VarDecFromI4(val, pDecimal);
+	}
+
+	static HRESULT InitDecimal(DOUBLE& val, DECIMAL* pDecimal)
+	{
+		return ::VarDecFromR8(val, pDecimal);
+	}
+
+	static HRESULT InitVal(LONG& val, const DECIMAL* pDecimal)
+	{
+		return ::VarI4FromDec(pDecimal, &val);
+	}
+
+	static HRESULT InitVal(DOUBLE& val, const DECIMAL* pDecimal)
+	{
+		return ::VarR8FromDec(pDecimal, &val);
+	}
+};
+
+// CRibbonImpl Ribbon implementation class
+//
+template <class T>
+class CRibbonImpl : 
+		public CRibbonUpdateUI<T>,
+		public ICtrl,
+		public IUIApplication,
+		public IUICommandHandler
+{
+	typedef CRibbonImpl<T> thisClass;
+public:
+	typedef thisClass Ribbon;
+	typedef T WndRibbon;
+
+	CRibbonImpl() : m_bRibbonUI(false), m_hgRibbonSettings(NULL)
+	{
+#ifdef _DEBUG
+		m_cRef = 1;
+#endif
+		pWndRibbon = static_cast<T*>(this);
+		HRESULT hr = ::CoInitialize(NULL);
+		if(SUCCEEDED(hr))
+			if (RunTimeHelper::IsRibbonUIAvailable())
+				hr = m_pIUIFramework.CoCreateInstance(CLSID_UIRibbonFramework);
+			else
+				ATLTRACE(L"Ribbon UI not available\n");
+
+		if FAILED(hr)
+			ATLTRACE(L"Ribbon construction failed\n");
+
+		ATLASSERT(SUCCEEDED(hr));
+	}
+
+	~CRibbonImpl()
+	{
+		::GlobalFree(m_hgRibbonSettings);
+		m_pIUIFramework.Release();
+		::CoUninitialize();
+	}
+
+	ICtrl& GetRibbonCtrl(UINT)
+	{
+		return static_cast<ICtrl&>(*this);
+	}
+
+	ATL::CComPtr<IUIFramework> m_pIUIFramework;
+	HGLOBAL m_hgRibbonSettings;
+	bool m_bRibbonUI;
+
+	bool IsRibbonUI()
+	{
+		return m_bRibbonUI;
+	}
+
+	IUIFramework* GetIUIFrameworkPtr()
+	{
+		return m_pIUIFramework;
+	}
+
+	template <typename I>
+	I* GetRibbonViewPtr(UINT32 uID)
+	{
+		ATLASSERT(m_pIUIFramework);
+		ATL::CComPtr<I> pI;
+		return m_pIUIFramework->GetView(uID, __uuidof(I), (void**) &pI) == S_OK ?
+			pI : 
+			NULL;
+	}
+
+	IUIRibbon* GetRibbonPtr()
+	{
+		return GetRibbonViewPtr<IUIRibbon>(0);
+	}
+
+	IUIContextualUI* GetMenuPtr(UINT32 uID)
+	{
+		ATLASSERT(uID);
+		return GetRibbonViewPtr<IUIContextualUI>(uID);
+	}
+
+	UINT GetRibbonHeight()
+	{
+		ATLASSERT(IsRibbonUI());
+
+		UINT32 cy = 0;
+		if (ATL::CComPtr<IUIRibbon> pIUIRibbon = GetRibbonPtr())
+			pIUIRibbon->GetHeight(&cy);
+		return cy;
+	}
+
+	HRESULT CreateRibbon(LPCWSTR sResName = L"APPLICATION_RIBBON")
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(GetIUIFrameworkPtr() && !IsRibbonUI());
+		ATLASSERT(pT->IsWindow());
+
+		HRESULT hr = m_pIUIFramework->Initialize(pT->m_hWnd, this);
+
+		if (hr == S_OK)
+			hr = m_pIUIFramework->LoadUI(ModuleHelper::GetResourceInstance(), sResName);
+			
+		return hr;
+	}
+
+	HRESULT DestroyRibbon()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(GetIUIFrameworkPtr() && IsRibbonUI());
+		ATLASSERT(pT->IsWindow());
+
+		HRESULT hRes = m_pIUIFramework->Destroy();
+		if (!RunTimeHelper::IsWin7())
+			pT->SetWindowRgn(NULL, TRUE); // Vista Basic bug workaround
+		return hRes;
+	}
+
+// Ribbon persistency
+	HRESULT operator >>(IStream* pIStream)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(pIStream);
+
+		HRESULT hr = E_FAIL;
+		if (ATL::CComPtr<IUIRibbon> pIUIRibbon = GetRibbonPtr())
+		{
+			const LARGE_INTEGER li0 = { 0 };
+			pIStream->Seek(li0, STREAM_SEEK_SET, NULL);
+			hr = pIUIRibbon->SaveSettingsToStream(pIStream);
+			pIStream->Commit(STGC_DEFAULT);
+		}
+
+		return hr;
+	}
+
+	HRESULT operator <<(IStream* pIStream)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(pIStream);
+
+		HRESULT hr = E_FAIL;
+		if (ATL::CComPtr<IUIRibbon> pIUIRibbon = GetRibbonPtr())
+		{
+			const LARGE_INTEGER li0 = { 0 };
+			pIStream->Seek(li0, STREAM_SEEK_SET, NULL);
+			hr = pIUIRibbon->LoadSettingsFromStream(pIStream);
+		}
+
+		return hr;
+	}
+
+	void ResetRibbonSettings()
+	{
+		if (m_hgRibbonSettings != NULL)
+		{
+			::GlobalFree(m_hgRibbonSettings);
+			m_hgRibbonSettings = NULL;
+		}
+	}
+
+	HRESULT SaveRibbonSettings()
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(static_cast<T*>(this)->IsWindow());
+
+		HRESULT hr = E_FAIL;
+		ATL::CComPtr<IStream> pIStream;
+
+		if SUCCEEDED(hr = ::CreateStreamOnHGlobal(m_hgRibbonSettings, FALSE, &pIStream))
+			hr = *this >> pIStream;
+
+		if (SUCCEEDED(hr) && (m_hgRibbonSettings == NULL))
+			hr = ::GetHGlobalFromStream(pIStream, &m_hgRibbonSettings);
+
+		if FAILED(hr)
+			ResetRibbonSettings();
+
+		return hr;
+	}
+
+	HRESULT RestoreRibbonSettings()
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(m_hgRibbonSettings);
+		ATLASSERT(static_cast<T*>(this)->IsWindow());
+
+		HRESULT hr = E_FAIL;
+		ATL::CComPtr<IStream> pIStream;
+
+		if SUCCEEDED(hr = ::CreateStreamOnHGlobal(m_hgRibbonSettings, FALSE, &pIStream))
+			hr = *this << pIStream;
+
+		if FAILED(hr)
+			ResetRibbonSettings();
+
+		return hr;
+	}
+
+// QAT dock states
+	UI_CONTROLDOCK GetQATDock()
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(IsRibbonUI());
+
+		UINT32 uDock = 0;
+		PROPVARIANT propvar;
+		ATL::CComQIPtr<IPropertyStore>pIPS(GetRibbonPtr());
+
+		if ((pIPS != NULL) && SUCCEEDED(pIPS->GetValue(UI_PKEY_QuickAccessToolbarDock, &propvar)) &&
+			SUCCEEDED(UIPropertyToUInt32(UI_PKEY_QuickAccessToolbarDock, propvar, &uDock)))
+				return (UI_CONTROLDOCK)uDock;
+
+		ATLASSERT(FALSE); // something was wrong
+		return (UI_CONTROLDOCK)0;
+	}
+
+	bool SetQATDock(UI_CONTROLDOCK dockState)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(IsRibbonUI());
+
+		PROPVARIANT propvar;
+		ATLVERIFY(SUCCEEDED(SetPropertyVal(UI_PKEY_QuickAccessToolbarDock, dockState, &propvar)));
+
+		ATL::CComQIPtr<IPropertyStore>pIPS(GetRibbonPtr());
+		if ((pIPS != NULL) && SUCCEEDED(pIPS->SetValue(UI_PKEY_QuickAccessToolbarDock, propvar)))
+		{
+			pIPS->Commit();
+			return true;
+		}
+
+		ATLASSERT(FALSE); // something was wrong
+		return false;
+	}
+
+// Ribbon display states
+	bool GetRibbonDisplayState(REFPROPERTYKEY key)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(IsRibbonUI());
+		ATLASSERT((k_(key) == k_Viewable) || (k_(key) == k_Minimized));
+
+		PROPVARIANT propvar;
+		ATL::CComQIPtr<IPropertyStore>pIPS(GetRibbonPtr());
+
+		if ((pIPS != NULL) && SUCCEEDED(pIPS->GetValue(key, &propvar)))
+		{
+			BOOL bState = FALSE;
+			if SUCCEEDED(UIPropertyToBoolean(key, propvar, &bState))
+				return (bState != FALSE);
+		}
+
+		ATLASSERT(FALSE); // something was wrong
+		return false;
+	}
+
+	bool SetRibbonDisplayState(REFPROPERTYKEY key, bool bState = true)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(IsRibbonUI());
+		ATLASSERT((k_(key) == k_Viewable) || (k_(key) == k_Minimized));
+
+		PROPVARIANT propvar;
+		ATLVERIFY(SUCCEEDED(SetPropertyVal(key, bState, &propvar)));
+
+		ATL::CComQIPtr<IPropertyStore>pIPS(GetRibbonPtr());
+
+		if ((pIPS != NULL) && SUCCEEDED(pIPS->SetValue(key, propvar)))
+		{
+			pIPS->Commit();
+			return true;
+		}
+
+		ATLASSERT(FALSE); // something was wrong
+		return false;
+	}
+
+	bool IsRibbonMinimized()
+	{
+		return GetRibbonDisplayState(UI_PKEY_Minimized);
+	}
+
+	bool MinimizeRibbon(bool bMinimize = true)
+	{
+		return SetRibbonDisplayState(UI_PKEY_Minimized, bMinimize);
+	}
+
+	bool IsRibbonHidden()
+	{
+		return !GetRibbonDisplayState(UI_PKEY_Viewable);
+	}
+
+	bool HideRibbon(bool bHide = true)
+	{
+		return SetRibbonDisplayState(UI_PKEY_Viewable, !bHide);
+	}
+
+// Ribbon colors
+	UI_HSBCOLOR GetRibbonColor(REFPROPERTYKEY key)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(IsRibbonUI());
+		ATLASSERT((k_(key) >= k_GlobalBackgroundColor) && (k_(key) <= k_GlobalTextColor));
+
+		PROPVARIANT propvar;
+		ATL::CComQIPtr<IPropertyStore>pIPS(GetIUIFrameworkPtr());
+
+		if ((pIPS != NULL) && SUCCEEDED(pIPS->GetValue(key, &propvar)))
+		{
+			UINT32 color = 0;
+			if SUCCEEDED(UIPropertyToUInt32(key, propvar, &color))
+				return color;
+		}
+
+		ATLASSERT(FALSE); // something was wrong
+		return 0;
+	}
+
+	bool SetRibbonColor(REFPROPERTYKEY key, UI_HSBCOLOR color)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+		ATLASSERT(IsRibbonUI());
+		ATLASSERT((k_(key) >= k_GlobalBackgroundColor) && (k_(key) <= k_GlobalTextColor));
+
+		PROPVARIANT propvar;
+		ATLVERIFY(SUCCEEDED(SetPropertyVal(key, color, &propvar)));
+
+		ATL::CComQIPtr<IPropertyStore>pIPS(GetIUIFrameworkPtr());
+
+		if ((pIPS != NULL) && SUCCEEDED(pIPS->SetValue(key, propvar)))
+		{
+			pIPS->Commit();
+			return true;
+		}
+
+		ATLASSERT(FALSE); // something was wrong
+		return false;
+	}
+
+// Ribbon modes
+	HRESULT SetRibbonModes(INT32 iModes)
+	{
+		ATLASSERT(IsRibbonUI());
+		return GetIUIFrameworkPtr()->SetModes(iModes);
+	}
+
+// Ribbon contextual tab
+	UI_CONTEXTAVAILABILITY GetRibbonContextAvail(UINT32 uID)
+	{
+		ATLASSERT(GetIUIFrameworkPtr());
+
+		PROPVARIANT propvar;
+		if (IsRibbonUI() && 
+		    SUCCEEDED(GetIUIFrameworkPtr()->GetUICommandProperty(uID, UI_PKEY_ContextAvailable, &propvar)))
+		{
+			UINT uav;
+			if (SUCCEEDED(PropVariantToUInt32(propvar, &uav)))
+			{
+				CUpdateUIBase::UIEnable(uID, uav != UI_CONTEXTAVAILABILITY_NOTAVAILABLE);
+				CUpdateUIBase::UISetCheck(uID, uav == UI_CONTEXTAVAILABILITY_ACTIVE);
+				return (UI_CONTEXTAVAILABILITY)uav;
+			}
+		}
+
+		return UI_CONTEXTAVAILABILITY_NOTAVAILABLE;
+	}
+
+	HRESULT SetRibbonContextAvail(UINT32 uID, UI_CONTEXTAVAILABILITY cav)
+	{
+		CUpdateUIBase::UIEnable(uID, cav != UI_CONTEXTAVAILABILITY_NOTAVAILABLE);
+		CUpdateUIBase::UISetCheck(uID, cav == UI_CONTEXTAVAILABILITY_ACTIVE);
+		
+		return SetProperty((WORD)uID, UI_PKEY_ContextAvailable, UINT32(cav));
+	}
+
+// Ribbon context menu
+	bool HasRibbonMenu(UINT32 uID)
+	{
+		ATL::CComPtr<IUIContextualUI> pI = GetMenuPtr(uID);
+		return pI != NULL;
+	}
+
+	HRESULT TrackRibbonMenu(UINT32 uID, INT32 x, INT32 y)
+	{
+		ATLASSERT(HasRibbonMenu(uID));
+
+		return IsRibbonUI() ?
+			ATL::CComPtr<IUIContextualUI>(GetMenuPtr(uID))->ShowAtLocation(x, y) :
+			E_FAIL;
+	}
+
+	HRESULT TrackRibbonMenu(UINT32 uID, LPARAM lParam)
+	{
+		return TrackRibbonMenu(uID, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
+	}
+
+// Overrideables
+	HBITMAP OnRibbonQueryImage(UINT nCmdID, REFPROPERTYKEY /*key*/)
+	{
+		return DefRibbonQueryImage(nCmdID);
+	}
+
+	LPCWSTR OnRibbonQueryText(UINT nCmdID, REFPROPERTYKEY key)
+	{
+		return DefRibbonQueryText(nCmdID, key);
+	}
+
+	bool OnRibbonQueryState(UINT nCmdID, REFPROPERTYKEY key)
+	{
+		return DefRibbonQueryState(nCmdID, key);
+	}
+
+	UI_CONTEXTAVAILABILITY OnRibbonQueryTabAvail(UINT nCmdID)
+	{
+		DWORD dwState = UIGetState(nCmdID);
+		return ((dwState & UPDUI_DISABLED) == UPDUI_DISABLED) ? 
+			UI_CONTEXTAVAILABILITY_NOTAVAILABLE :
+			(((dwState & UPDUI_CHECKED) == UPDUI_CHECKED) ? 
+				UI_CONTEXTAVAILABILITY_ACTIVE : 
+				UI_CONTEXTAVAILABILITY_AVAILABLE);
+	}
+
+	LPCWSTR OnRibbonQueryComboText(UINT32 /*uCtrlID*/)
+	{
+		return NULL;
+	}
+
+	LPCWSTR OnRibbonQueryCategoryText(UINT32 /*uCtrlID*/, UINT32 /*uCat*/)
+	{
+		return L"Category";
+	}
+
+	UINT32 OnRibbonQueryItemCategory(UINT32 /*uCtrlID*/, UINT32 /*uItem*/)
+	{
+		return 0;
+	}
+
+	LPCWSTR OnRibbonQueryItemText(UINT32 uCtrlID, UINT32 uItem)
+	{
+		return DefRibbonQueryItemText(uCtrlID, uItem);
+	}
+
+	bool OnRibbonQuerySelectedItem(UINT32 /*uCtrlID*/, UINT32& /*uSel*/)
+	{
+		return false;
+	}
+
+	HBITMAP OnRibbonQueryItemImage(UINT32 uCtrlID, UINT32 uItem)
+	{
+		return DefRibbonQueryItemImage(uCtrlID, uItem);
+	}
+
+	UINT32 OnRibbonQueryItemCommand(UINT32 uCtrlID, UINT32 uItem)
+	{
+		return DefRibbonQueryItemCommand(uCtrlID, uItem);
+	}
+
+	UI_COMMANDTYPE OnRibbonQueryItemCommandType(UINT32 /*uCtrlID*/, UINT32 /*uItem*/)
+	{
+		return UI_COMMANDTYPE_ACTION;
+	}
+
+	LPCWSTR OnRibbonQueryRecentItemName(LPCWSTR sPath)
+	{
+		return ::PathFindFileName(sPath);
+	}
+
+	bool OnRibbonQueryFont(UINT /*nId*/, CHARFORMAT2& /*cf*/)
+	{
+		return false;
+	}
+
+	bool OnRibbonQuerySpinnerValue(UINT /*nCmdID*/, REFPROPERTYKEY /*key*/, LONG* /*pVal*/)
+	{
+		return false;
+	}
+
+	bool OnRibbonQueryFloatSpinnerValue(UINT /*nCmdID*/, REFPROPERTYKEY /*key*/, DOUBLE* /*pVal*/)
+	{
+		return false;
+	}
+
+	COLORREF OnRibbonQueryColor(UINT /*nCmdID*/)
+	{
+		return 0x800080; /*MAGENTA*/
+	}
+
+	LPCWSTR OnRibbonQueryColorLabel(UINT /*nCmdID*/, REFPROPERTYKEY /*key*/)
+	{
+		return NULL;
+	}
+
+	COLORREF* OnRibbonQueryColorArray(UINT /*nCmdID*/, REFPROPERTYKEY /*key*/)
+	{
+		return NULL;
+	}
+
+	LPCWSTR* OnRibbonQueryColorTooltips(UINT /*nCmdID*/, REFPROPERTYKEY /*key*/)
+	{
+		return NULL;
+	}
+
+	bool OnRibbonItemSelected(UINT32 uCtrlID, UI_EXECUTIONVERB verb, UINT32 uItem)
+	{
+		DefCommandExecute(MAKELONG(uCtrlID, verb), uItem);
+		return true;
+	}
+
+	void OnRibbonColorCtrlExecute(UINT32 uCtrlID, UI_EXECUTIONVERB verb, UI_SWATCHCOLORTYPE uType, COLORREF color)
+	{
+		DefRibbonColorCtrlExecute(uCtrlID, verb, uType, color);
+	}
+
+	void OnRibbonFontCtrlExecute(UINT32 uCtrlID, UI_EXECUTIONVERB verb, CHARFORMAT2* pcf)
+	{
+		DefCommandExecute(MAKELONG(uCtrlID, verb), (LPARAM)pcf);
+	}
+
+	void OnRibbonSpinnerCtrlExecute(UINT32 uCtrlID, LONG* pVal)
+	{
+		DefCommandExecute(uCtrlID, *pVal);
+	}
+
+	void OnRibbonSpinnerCtrlExecute(UINT32 uCtrlID, DOUBLE* pVal)
+	{
+		DefCommandExecute(uCtrlID, (LPARAM)pVal);
+	}
+
+	void OnRibbonCommandExecute(UINT32 uCmdID)
+	{
+		DefCommandExecute(uCmdID);
+	}
+
+// Default implementations
+	HBITMAP DefRibbonQueryImage(UINT nCmdID)
+	{
+		return AtlLoadBitmapImage(nCmdID, LR_CREATEDIBSECTION);
+	}
+
+	bool DefRibbonQueryState(UINT nCmdID, REFPROPERTYKEY key)
+	{
+		DWORD dwState = UIGetState(nCmdID);
+		bool bRet = false;
+		switch (k_(key))
+		{
+		case k_BooleanValue:
+			bRet = (dwState & UPDUI_CHECKED) == UPDUI_CHECKED;
+			break;
+		case k_Enabled:
+			bRet = (dwState & UPDUI_DISABLED) != UPDUI_DISABLED;
+			break;
+		default:
+			ATLASSERT(FALSE);
+			break;
+		}
+
+		return bRet;
+	}
+
+	LPCTSTR DefRibbonQueryText(UINT nCmdID, REFPROPERTYKEY key)
+	{
+		static WCHAR sText[RIBBONUI_MAX_TEXT] = { 0 };
+
+		if (k_(key) == k_Label)
+			 return UIGetText(nCmdID);
+
+		if (AtlLoadString(nCmdID, sText, RIBBONUI_MAX_TEXT))
+		{
+			PWCHAR pTitle = wcschr(sText, L'\n');
+			switch (k_(key))
+			{
+			case k_Keytip:
+				if (PWCHAR pAmp = wcschr(sText, L'&'))
+					pTitle = pAmp;
+				if (pTitle != NULL)
+					*(pTitle + 2) = NULL; // fall through
+			case k_TooltipTitle:
+				return pTitle ? ++pTitle : NULL;
+			case k_TooltipDescription:
+			case k_LabelDescription:
+				if (pTitle != NULL)
+					*pTitle = NULL;
+				return sText;
+			}
+		}
+
+		return NULL;
+	}
+
+	LPCWSTR DefRibbonQueryItemText(UINT32 uCtrlID, UINT32 uItem)
+	{
+		return DefRibbonQueryText(uCtrlID + 1 + uItem, UI_PKEY_LabelDescription);
+	}
+
+	HBITMAP DefRibbonQueryItemImage(UINT32 uCtrlID, UINT32 uItem)
+	{
+		return DefRibbonQueryImage(uCtrlID + 1 + uItem);
+	}
+
+	UINT32 DefRibbonQueryItemCommand(UINT32 uCtrlID, UINT32 uItem)
+	{
+		return uCtrlID + 1 + uItem;
+	}
+
+	void DefRibbonColorCtrlExecute(UINT32 uCtrlID, UI_EXECUTIONVERB verb, UI_SWATCHCOLORTYPE uType, COLORREF color)
+	{
+		switch(uType)
+		{
+		case UI_SWATCHCOLORTYPE_RGB:
+			break;
+		case UI_SWATCHCOLORTYPE_AUTOMATIC:
+			color = ::GetSysColor(COLOR_WINDOWTEXT);
+			break;
+		case UI_SWATCHCOLORTYPE_NOCOLOR:
+			color = ::GetSysColor(COLOR_WINDOW);
+			break;
+		default:
+			ATLASSERT(FALSE);
+			break;
+		}
+
+		DefCommandExecute(MAKELONG(uCtrlID, verb), color);
+	}
+
+	void DefCommandExecute(UINT32 uCmd, LPARAM lParam = 0)
+	{
+		static_cast<T*>(this)->PostMessage(WM_COMMAND, uCmd, lParam);
+	}
+
+// Elements setting helpers
+	HRESULT InvalidateCtrl(UINT32 nID)
+	{
+		return IsRibbonUI() ?
+			GetIUIFrameworkPtr()->InvalidateUICommand(nID, UI_INVALIDATIONS_ALLPROPERTIES, NULL) :
+			E_FAIL;
+	}
+
+	HRESULT InvalidateProperty(UINT32 nID, REFPROPERTYKEY key, UI_INVALIDATIONS flags = UI_INVALIDATIONS_PROPERTY)
+	{
+		return IsRibbonUI() ?
+			GetIUIFrameworkPtr()->InvalidateUICommand(nID, flags, &key) :
+			E_FAIL;
+	}
+
+	template <typename V>
+	HRESULT SetProperty(WORD wID, REFPROPERTYKEY key, V val)
+	{
+		if (IsRibbonUI())
+		{
+			PROPVARIANT var;
+			if (SUCCEEDED(RibbonUI::SetPropertyVal(key, val, &var)))
+			{
+				return SetProperty(wID, key, var);
+			}
+			return E_INVALIDARG;
+		}
+		else
+		{
+			return E_FAIL;
+		}
+	}
+
+	template <>
+	HRESULT SetProperty(WORD nID, REFPROPERTYKEY key, PROPVARIANT var)
+	{
+		return IsRibbonUI() ?
+			GetIUIFrameworkPtr()->SetUICommandProperty(nID, key, var) :
+			E_FAIL;
+	}
+
+// Interfaces
+	// IUIApplication
+	STDMETHODIMP OnViewChanged(UINT32, UI_VIEWTYPE, IUnknown*, UI_VIEWVERB verb, INT32)
+	{
+		switch (verb)
+		{			
+		case UI_VIEWVERB_CREATE:
+			m_bRibbonUI = true;
+			if (m_hgRibbonSettings != NULL)
+				RestoreRibbonSettings();
+			break;
+		case UI_VIEWVERB_SIZE:
+			static_cast<T*>(this)->UpdateLayout(FALSE);
+			break;
+		case UI_VIEWVERB_DESTROY:
+			SaveRibbonSettings();
+			m_bRibbonUI = false;
+			break;
+		}
+
+		return S_OK;
+	}
+
+	STDMETHODIMP OnCreateUICommand(UINT32 nCmdID, UI_COMMANDTYPE typeID, IUICommandHandler** ppCommandHandler)
+	{
+		UIAddRibbonElement(nCmdID);
+		if (typeID == UI_COMMANDTYPE_CONTEXT)
+			CUpdateUIBase::UIEnable(nCmdID, false);
+		*ppCommandHandler = this;
+		return S_OK;
+	}
+
+	STDMETHODIMP OnDestroyUICommand(UINT32 nCmdID, UI_COMMANDTYPE, IUICommandHandler*)
+	{
+		UIRemoveRibbonElement(nCmdID);
+		return S_OK;
+	}
+
+	// IUICommandHandler
+	STDMETHODIMP Execute(UINT nCmdID,
+		UI_EXECUTIONVERB verb, 
+		const PROPERTYKEY* key,
+		const PROPVARIANT* ppropvarValue,
+		IUISimplePropertySet* pCommandExecutionProperties)
+	{
+		T* pT =static_cast<T*>(this);
+		return pT->GetRibbonCtrl(nCmdID).DoExecute(nCmdID, verb, key, ppropvarValue, pCommandExecutionProperties);	
+	}
+
+	STDMETHODIMP UpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+	                            const PROPVARIANT* ppropvarCurrentValue, PROPVARIANT* ppropvarNewValue)
+	{
+		T* pT =static_cast<T*>(this);
+		return pT->GetRibbonCtrl(nCmdID).DoUpdateProperty(nCmdID, key, ppropvarCurrentValue, ppropvarNewValue);	
+	}
+
+#ifdef _DEBUG
+	// IUnknown methods (heavyweight)
+	STDMETHODIMP_(ULONG) AddRef()
+	{
+		return InterlockedIncrement(&m_cRef);
+	}
+
+	STDMETHODIMP_(ULONG) Release()
+	{
+		LONG cRef = InterlockedDecrement(&m_cRef);
+		if (cRef == 0) // NoOp for breakpoint
+		{
+			cRef = 0;
+		}
+
+		return cRef;
+	}
+
+	STDMETHODIMP QueryInterface(REFIID iid, void** ppv)
+	{
+		if (ppv == NULL)
+		{
+			return E_POINTER;
+		}
+		else if ((iid == __uuidof(IUnknown)) ||
+		         (iid == __uuidof(IUICommandHandler)) ||
+		         (iid == __uuidof(IUIApplication)))
+		{
+			*ppv = this;
+			AddRef();
+			return S_OK;
+		}
+		else
+		{
+			return E_NOINTERFACE;
+		}
+	}
+
+	LONG m_cRef;
+#else
+	// IUnknown methods (lightweight)
+	STDMETHODIMP QueryInterface(REFIID iid, void** ppv)
+	{
+		if ((iid == __uuidof(IUnknown)) ||
+		    (iid == __uuidof(IUICommandHandler)) ||
+		    (iid == __uuidof(IUIApplication)))
+		{
+			*ppv = this;
+			return S_OK;
+		}
+		return E_NOINTERFACE;
+	}
+	ULONG STDMETHODCALLTYPE AddRef()
+	{
+		return 1;
+	}
+	ULONG STDMETHODCALLTYPE Release()
+	{
+		return 1;
+	}
+#endif
+
+// CRibbonImpl ICtrl implementation
+	virtual HRESULT DoExecute(UINT nCmdID, UI_EXECUTIONVERB verb, 
+	                          const PROPERTYKEY* key, const PROPVARIANT* ppropvarValue,
+	                          IUISimplePropertySet* /*pCommandExecutionProperties*/)
+	{
+		if (key != NULL)
+		{
+			if(k_(*key) != k_BooleanValue)
+			{
+				ATLTRACE(L"Control ID %d is not handled\n", nCmdID);
+				return E_NOTIMPL;
+			}
+			BOOL bChecked = FALSE;
+			ATLVERIFY(SUCCEEDED(PropVariantToBoolean(*ppropvarValue, &bChecked)));
+			CUpdateUIBase::UISetCheck(nCmdID, bChecked);
+		}
+
+		ATLASSERT(verb == UI_EXECUTIONVERB_EXECUTE);
+		verb;   // avoid level 4 warning
+
+		static_cast<T*>(this)->OnRibbonCommandExecute(nCmdID);
+		
+		return S_OK;
+	}
+
+	virtual HRESULT DoUpdateProperty(UINT nCmdID, REFPROPERTYKEY key, 
+		const PROPVARIANT* /*ppropvarCurrentValue*/, PROPVARIANT* ppropvarNewValue)
+	{
+		T* pT = static_cast<T*>(this);
+		HRESULT hr = E_NOTIMPL;
+		switch (k_(key))
+		{
+		case k_LargeImage:
+		case k_LargeHighContrastImage:
+		case k_SmallImage:
+		case k_SmallHighContrastImage:
+			if (HBITMAP hbm = pT->OnRibbonQueryImage(nCmdID, key))
+				hr = SetPropertyVal(key, GetImage(hbm, UI_OWNERSHIP_TRANSFER), ppropvarNewValue);
+			break;
+		case k_Label:
+		case k_Keytip:
+		case k_TooltipTitle:
+		case k_TooltipDescription:
+		case k_LabelDescription:
+			if (LPCWSTR sText = pT->OnRibbonQueryText(nCmdID, key))
+				hr = SetPropertyVal(key, sText, ppropvarNewValue);
+			break;
+		case k_BooleanValue:
+		case k_Enabled:
+			hr = SetPropertyVal(key, pT->OnRibbonQueryState(nCmdID, key), ppropvarNewValue);
+			break;
+		case k_ContextAvailable:
+			hr = SetPropertyVal(key, pT->OnRibbonQueryTabAvail(nCmdID), ppropvarNewValue);
+			break;
+		}
+
+		return hr;
+	}
+
+// CRibbonImpl::CRibbonXXXCtrl specialized classes
+	 //CRibbonComboCtrl
+	template <UINT t_ID, size_t t_items, size_t t_categories = 0>
+	class CRibbonComboCtrl : public CollectionCtrlImpl<T, t_ID, ComboCollectionImpl<CRibbonComboCtrl<t_ID, t_items, t_categories>, t_items, t_categories>>
+	{
+	public:
+		CRibbonComboCtrl()
+		{ }
+	};
+
+	// CRibbonItemGalleryCtrl
+	template <UINT t_ID, size_t t_items, size_t t_categories = 0>
+	class CRibbonItemGalleryCtrl : public CollectionCtrlImpl<T, t_ID, ItemCollectionImpl<CRibbonItemGalleryCtrl<t_ID, t_items, t_categories>, t_items, t_categories>>
+	{
+	public:
+		CRibbonItemGalleryCtrl()
+		{ }
+	};
+
+	// CRibbonCommandGalleryCtrl
+	template <UINT t_ID, size_t t_items, size_t t_categories = 0>
+	class CRibbonCommandGalleryCtrl : public CollectionCtrlImpl<T, t_ID, CommandCollectionImpl<CRibbonCommandGalleryCtrl<t_ID, t_items, t_categories>, t_items, t_categories>>
+	{
+	public:
+		CRibbonCommandGalleryCtrl()
+		{ }
+	};
+
+	// CRibbonToolbarGalleryCtrl
+	template <UINT t_ID, UINT t_idTB, size_t t_size>
+	class CRibbonToolbarGalleryCtrl : public ToolbarGalleryCtrlImpl<T, t_ID, t_idTB, t_size>
+	{ };
+
+	// CRibbonSimpleComboCtrl
+	template <UINT t_ID, size_t t_size>
+	class CRibbonSimpleComboCtrl : public SimpleCollectionCtrlImpl<T, t_ID, t_size>
+	{ };
+
+	// CRibbonSimpleGalleryCtrl
+	template <UINT t_ID, size_t t_size, UI_COMMANDTYPE t_CommandType = UI_COMMANDTYPE_ACTION>
+	class CRibbonSimpleGalleryCtrl : public SimpleCollectionCtrlImpl<T, t_ID, t_size, t_CommandType>
+	{ };
+
+	//CRibbonRecentItemsCtrl
+	template <UINT t_ID, class TDocList = CRecentDocumentList>
+	class CRibbonRecentItemsCtrl : public RecentItemsCtrlImpl<T, t_ID, TDocList>
+	{
+	public:
+		CRibbonRecentItemsCtrl()
+		{ }
+	};
+
+	// CRibbonColorCtrl
+	template <UINT t_ID>
+	class CRibbonColorCtrl : public ColorCtrlImpl<T, t_ID>
+	{
+	public:
+		CRibbonColorCtrl()
+		{ }
+	};
+
+	 //CRibbonFontCtrl
+	template <UINT t_ID>
+	class CRibbonFontCtrl : public FontCtrlImpl<T, t_ID>
+	{
+	public:
+		CRibbonFontCtrl()
+		{ }
+	};
+
+	// CRibbonSpinnerCtrl
+	template <UINT t_ID>
+	class CRibbonSpinnerCtrl : public SpinnerCtrlImpl<T, t_ID, LONG>
+	{
+	public:
+		CRibbonSpinnerCtrl()
+		{ }
+	};
+
+	// CRibbonFloatSpinnerCtrl
+	template <UINT t_ID>
+	class CRibbonFloatSpinnerCtrl : public SpinnerCtrlImpl<T, t_ID, DOUBLE>
+	{
+	public:
+		CRibbonFloatSpinnerCtrl()
+		{
+			m_Values[4] = 1; // 1 decimal
+		}
+	};
+
+	// CRibbonCommandCtrl
+	template <UINT t_ID>
+	class CRibbonCommandCtrl : public CommandCtrlImpl<T, t_ID>
+	{
+	public:
+		CRibbonCommandCtrl()
+		{ }
+	};
+
+// Control classes access to T instance (re-initialized in constructor)
+	static T* pWndRibbon;
+};
+
+template <class T>
+__declspec(selectany) T* CRibbonImpl<T>::pWndRibbon;
+
+// Control map element
+#pragma warning (disable : 4510 610) // missing default constructor
+typedef struct
+{
+	UINT uID;
+	ICtrl& ctrl;
+} _ribbonCtrl;
+#pragma warning (default : 4510 610) // missing default constructor
+
+}; // namespace RibbonUI
+
+
+///////////////////////////////////////////////////////////////////////////////
+// RibbonUI Control map
+
+// Control map macros
+#define BEGIN_RIBBON_CONTROL_MAP(theClass) \
+	RibbonUI::ICtrl& GetRibbonCtrl(UINT id) \
+	{ \
+		RibbonUI::_ribbonCtrl _ctrls[] = \
+		{
+
+#define RIBBON_CONTROL(member) {member.GetID(), static_cast<RibbonUI::ICtrl&>(member)},
+
+#define END_RIBBON_CONTROL_MAP() \
+		{0, *this} \
+	}; \
+	int i = 0; \
+	for(; i < _countof(_ctrls) - 1; i++) \
+		if (_ctrls[i].uID == id) \
+			break; \
+	return _ctrls[i].ctrl; \
+}
+
+// Control message map macros
+#define RIBBON_GALLERY_CONTROL_HANDLER(id, func) \
+	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((UI_EXECUTIONVERB)HIWORD(wParam), LOWORD(wParam), (UINT)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define RIBBON_COMBO_CONTROL_HANDLER(id, func) \
+	RIBBON_GALLERY_CONTROL_HANDLER(id, func)	
+
+#define RIBBON_FONT_CONTROL_HANDLER(id, func) \
+	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((UI_EXECUTIONVERB)HIWORD(wParam), LOWORD(wParam), (CHARFORMAT2*)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define RIBBON_COLOR_CONTROL_HANDLER(id, func) \
+	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((UI_EXECUTIONVERB)HIWORD(wParam), LOWORD(wParam), (COLORREF)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define RIBBON_SPINNER_CONTROL_HANDLER(id, func) \
+	if(uMsg == WM_COMMAND && id == wParam) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((WORD)wParam, (LONG)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define RIBBON_FLOATSPINNER_CONTROL_HANDLER(id, func) \
+	if(uMsg == WM_COMMAND && id == wParam) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((WORD)wParam, (DOUBLE*)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+// Handler prototypes
+/*
+	LRESULT OnRibbonGalleryCtrl(UI_EXECUTIONVERB verb, WORD wID, UINT uSel, BOOL& bHandled);
+	LRESULT OnRibbonComboCtrl(UI_EXECUTIONVERB verb, WORD wID, UINT uSel, BOOL& bHandled);
+	LRESULT OnRibbonFontCtrl(UI_EXECUTIONVERB verb, WORD wID, CHARFORMAT2* pcf, BOOL& bHandled);
+	LRESULT OnRibbonColorCtrl(UI_EXECUTIONVERB verb, WORD wID, COLORREF color, BOOL& bHandled);
+	LRESULT OnRibbonSpinnerCtrl(WORD wID, LONG lVal, BOOL& bHandled);
+	LRESULT OnRibbonFloatSpinnerCtrl(WORD wID, DOUBLE* pdVal, BOOL& bHandled);
+*/
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Ribbon frame classes
+
+// CRibbonFrameWindowImplBase
+//
+template <class T, class TFrameImpl>
+class ATL_NO_VTABLE CRibbonFrameWindowImplBase : public TFrameImpl, public RibbonUI::CRibbonImpl<T>
+{
+	typedef TFrameImpl baseFrame;
+	bool m_bUseCommandBarBitmaps;
+	bool m_bWin7Fix;
+
+public:
+// Construction
+	CRibbonFrameWindowImplBase(bool bUseCommandBarBitmaps = true) : 
+			m_bUseCommandBarBitmaps(bUseCommandBarBitmaps), m_bWin7Fix(false)
+	{
+		__if_not_exists(T::m_CmdBar)
+		{
+			m_bUseCommandBarBitmaps = false;
+		}
+	}
+
+// Win7 Aero fix helpers
+	void ResetFrame()
+	{
+		const MARGINS margins = { 0 };
+		::DwmExtendFrameIntoClientArea(m_hWnd, &margins);
+	}
+
+	INT CalcWin7Fix()
+	{
+		ResetFrame();
+		RECT rc = { 0 };
+		::AdjustWindowRectEx(&rc, T::GetWndStyle(0), GetMenu() != NULL, T::GetWndExStyle(0));
+		return -rc.top;
+	}
+
+	bool NeedWin7Fix()
+	{
+		BOOL bComp = FALSE;
+		return m_bWin7Fix && RunTimeHelper::IsWin7() && SUCCEEDED(DwmIsCompositionEnabled(&bComp)) && bComp;
+	}
+
+// Operations
+	bool UseCommandBarBitmaps(bool bUse)
+	{
+		__if_exists(T::m_CmdBar)
+		{
+			return m_bUseCommandBarBitmaps = bUse;
+		}
+		__if_not_exists(T::m_CmdBar)
+		{
+			bUse;   // avoid level 4 warning
+			return false;
+		}
+	}
+
+	bool ShowRibbonUI(bool bShow, INT32 imodes = UI_MAKEAPPMODE(0), LPCWSTR sResName = L"APPLICATION_RIBBON")
+	{
+		if (!RunTimeHelper::IsRibbonUIAvailable())
+			return false;
+
+		ATLASSERT(GetIUIFrameworkPtr());
+
+		if (IsRibbonUI() == bShow)
+			return bShow;
+
+		bool bVisible = (IsWindowVisible() != FALSE);
+		if(bVisible && !bShow)
+			SetRedraw(FALSE);
+
+		if (bShow && ::IsWindow(m_hWndToolBar))
+		{
+			::ShowWindow(m_hWndToolBar, SW_HIDE);
+			UpdateLayout();
+		}
+
+		m_bWin7Fix = !bShow;
+
+		HRESULT hr = bShow ? CreateRibbon(sResName) : DestroyRibbon();
+
+		m_bWin7Fix = SUCCEEDED(hr) && !bShow;
+
+		if (SUCCEEDED(hr))
+		{
+			if(::IsWindow(m_hWndToolBar) && !bShow)
+			{
+				::ShowWindow(m_hWndToolBar, SW_SHOWNA);
+				UpdateLayout(); 
+			}
+			else if (bShow)
+			{
+				PostMessage(WM_SIZE); 
+				SetRibbonModes(imodes);
+			}
+		}
+
+		if(bVisible && !bShow)
+		{
+			SetRedraw(TRUE);
+			RedrawWindow(NULL, NULL, RDW_FRAME | RDW_ERASE | RDW_INVALIDATE | RDW_UPDATENOW | RDW_ALLCHILDREN);
+		}
+
+		return SUCCEEDED(hr) ? bShow : !bShow;
+	}
+
+// Overrideables
+	HBITMAP OnRibbonQueryImage(UINT nCmdID, REFPROPERTYKEY key)
+	{
+		if ((key == UI_PKEY_SmallImage) && m_bUseCommandBarBitmaps)
+		{
+			if (HBITMAP hbm = GetCommandBarBitmap(nCmdID))
+				return (HBITMAP)::CopyImage(hbm, IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION);
+		}
+
+		return DefRibbonQueryImage(nCmdID);
+	}
+
+	BEGIN_MSG_MAP(CRibbonFrameWindowImplBase)
+		if (!IsRibbonUI() && NeedWin7Fix())
+		{
+			MESSAGE_HANDLER(WM_SIZING, OnSizing)
+			MESSAGE_HANDLER(WM_SIZE, OnSize)
+			MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
+			MESSAGE_HANDLER(WM_NCCALCSIZE, OnNCCalcSize)
+		}
+		CHAIN_MSG_MAP(CRibbonUpdateUI<T>)
+		CHAIN_MSG_MAP(baseFrame)
+	END_MSG_MAP()
+
+// Message handlers for Win7 Aero
+	LRESULT OnSizing(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		switch (wParam)
+		{		
+		case WMSZ_TOP:
+		case WMSZ_TOPLEFT:
+		case WMSZ_TOPRIGHT:
+			SetWindowPos(NULL, (LPRECT)lParam, SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED);
+			break;
+		default:
+			DefWindowProc();
+			break;
+		}
+
+		return 1; // handled
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if (wParam != SIZE_MINIMIZED)
+			SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnActivate(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(wParam != WA_INACTIVE)
+			SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER | SWP_FRAMECHANGED);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnNCCalcSize(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		ATLASSERT(!IsRibbonUI() && NeedWin7Fix());
+
+		LRESULT lRet = DefWindowProc();
+
+		if(wParam)
+		{
+			LPNCCALCSIZE_PARAMS pParams = (LPNCCALCSIZE_PARAMS)lParam;
+			pParams->rgrc[0].top = pParams->rgrc[1].top + CalcWin7Fix();
+		}
+
+		return lRet;
+	}
+
+// Overrides
+	void UpdateLayout(BOOL bResizeBars = TRUE)
+	{
+		RECT rect = { 0 };
+		GetClientRect(&rect);
+
+		if (IsRibbonUI() && !IsRibbonHidden())
+		{
+			rect.top += GetRibbonHeight(); 
+		}
+		else if (!IsRibbonUI() && NeedWin7Fix())
+		{
+			ResetFrame();
+		}
+
+		// position bars and offset their dimensions
+		UpdateBarsPosition(rect, bResizeBars);
+
+		// resize client window
+		if(m_hWndClient != NULL)
+			::SetWindowPos(m_hWndClient, NULL, rect.left, rect.top,
+				rect.right - rect.left, rect.bottom - rect.top,
+				SWP_NOZORDER | SWP_NOACTIVATE);
+	}
+
+	// Implementation
+	HBITMAP GetCommandBarBitmap(UINT nCmdID)
+	{
+		__if_exists (T::m_CmdBar)
+		{
+			ATLASSERT(RunTimeHelper::IsVista());
+			T* pT =static_cast<T*>(this);
+			int nIndex = pT->m_CmdBar.m_arrCommand.Find((WORD&)nCmdID);
+			return (nIndex == -1) ? NULL : pT->m_CmdBar.m_arrVistaBitmap[nIndex];
+		}
+		__if_not_exists (T::m_CmdBar)
+		{
+			nCmdID;   // avoid level 4 warning
+			return NULL;
+		}
+	}
+};
+
+// CRibbonFrameWindowImpl
+//
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CFrameWinTraits>
+class ATL_NO_VTABLE CRibbonFrameWindowImpl : public CRibbonFrameWindowImplBase<T, CFrameWindowImpl<T, TBase, TWinTraits>>
+{ };
+
+// CRibbonMDIFrameWindowImpl
+//
+template <class T, class TBase = CMDIWindow, class TWinTraits = ATL::CFrameWinTraits>
+class ATL_NO_VTABLE CRibbonMDIFrameWindowImpl : public CRibbonFrameWindowImplBase<T, CMDIFrameWindowImpl<T, TBase, TWinTraits>>
+{ };
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CRibbonPersist helper for RibbonUI persistency
+
+class CRibbonPersist
+{
+public:
+	CRibbonPersist(LPCWSTR sAppKey)
+	{
+		ATLASSERT(sAppKey && *sAppKey);
+		m_Key.Create(HKEY_CURRENT_USER, sAppKey);
+		ATLASSERT(m_Key.m_hKey);
+	}
+
+	CRegKeyEx m_Key;
+
+	LONG Save(bool bRibbonUI, HGLOBAL hgSettings = NULL)
+	{
+		CRegKeyEx key;
+		const DWORD dwUI = bRibbonUI;
+
+		LONG lRet = key.Create(m_Key, L"Ribbon");
+		if(lRet != ERROR_SUCCESS)
+			return lRet;
+		
+		lRet = key.SetDWORDValue(L"UI", dwUI);
+		if(lRet != ERROR_SUCCESS)
+			return lRet;
+
+		if (hgSettings != NULL)
+		{
+			LPBYTE pVal = (LPBYTE)::GlobalLock(hgSettings);
+			if (pVal != NULL)
+			{
+				lRet = key.SetBinaryValue(L"Settings", pVal, (ULONG)::GlobalSize(hgSettings));
+				::GlobalUnlock(hgSettings);
+			}
+			else
+			{
+				lRet = GetLastError();
+			}
+		}
+
+		return lRet;
+	}
+
+	LONG Restore(bool& bRibbonUI, HGLOBAL& hgSettings)
+	{
+		ATLASSERT(hgSettings == NULL);
+
+		CRegKeyEx key;
+
+		LONG lRet = key.Open(m_Key, L"Ribbon");
+		if(lRet != ERROR_SUCCESS)
+			return lRet;
+		
+		DWORD dwUI = 0xffff;
+		lRet = key.QueryDWORDValue(L"UI", dwUI);
+		if(lRet == ERROR_SUCCESS)
+			bRibbonUI = dwUI == 1;
+		else
+			return lRet;
+
+		ULONG ulSize = 0;
+		lRet = key.QueryBinaryValue(L"Settings", NULL, &ulSize);
+		if (lRet == ERROR_SUCCESS)
+		{
+			ATLASSERT(ulSize != 0);
+			
+			hgSettings = ::GlobalAlloc(GHND, ulSize);
+			if (hgSettings != NULL)
+			{
+				LPBYTE pData = (LPBYTE)::GlobalLock(hgSettings);
+				if (pData != NULL)
+				{
+					lRet = key.QueryBinaryValue(L"Settings", pData, &ulSize);
+				}
+				else
+				{
+					lRet = GetLastError();
+					::GlobalFree(hgSettings);
+					hgSettings = NULL;
+				}
+			}
+			else
+			{
+				lRet = GetLastError();
+			}
+		}
+		return lRet;
+	}
+
+	LONG Delete()
+	{
+		return m_Key.DeleteSubKey(L"Ribbon");
+	}
+};
+
+} // namespace WTL
+
+#endif // __ATLRIBBON_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlscrl.h b/GLideN64/src/GLideNUI-wtl/WTL/atlscrl.h
new file mode 100644
index 00000000..e93d07bc
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlscrl.h
@@ -0,0 +1,2007 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLSCRL_H__
+#define __ATLSCRL_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlscrl.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atlscrl.h requires atlwin.h to be included first
+#endif
+
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+  #include <zmouse.h>
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+
+#ifndef GET_WHEEL_DELTA_WPARAM
+  #define GET_WHEEL_DELTA_WPARAM(wParam)  ((short)HIWORD(wParam))
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CScrollImpl<T>
+// CScrollWindowImpl<T, TBase, TWinTraits>
+// CMapScrollImpl<T>
+// CMapScrollWindowImpl<T, TBase, TWinTraits>
+// CFSBWindowT<TBase>
+// CZoomScrollImpl<T>
+// CZoomScrollWindowImpl<T, TBase, TWinTraits>
+// CScrollContainerImpl<T, TBase, TWinTraits>
+// CScrollContainer
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CScrollImpl - Provides scrolling support to any window
+
+// Scroll extended styles
+#define SCRL_SCROLLCHILDREN	0x00000001
+#define SCRL_ERASEBACKGROUND	0x00000002
+#define SCRL_NOTHUMBTRACKING	0x00000004
+#if (WINVER >= 0x0500)
+#define SCRL_SMOOTHSCROLL	0x00000008
+#endif // (WINVER >= 0x0500)
+#define SCRL_DISABLENOSCROLLV	0x00000010
+#define SCRL_DISABLENOSCROLLH	0x00000020
+#define SCRL_DISABLENOSCROLL	(SCRL_DISABLENOSCROLLV | SCRL_DISABLENOSCROLLH)
+
+
+template <class T>
+class CScrollImpl
+{
+public:
+	enum { uSCROLL_FLAGS = SW_INVALIDATE };
+
+	POINT m_ptOffset;
+	SIZE m_sizeAll;
+	SIZE m_sizeLine;
+	SIZE m_sizePage;
+	SIZE m_sizeClient;
+	int m_zDelta;              // current wheel value
+	int m_nWheelLines;         // number of lines to scroll on wheel
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+	// Note that this message must be forwarded from a top level window
+	UINT m_uMsgMouseWheel;     // MSH_MOUSEWHEEL
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+	int m_zHDelta;              // current horizontal wheel value
+	int m_nHWheelChars;         // number of chars to scroll on horizontal wheel
+	UINT m_uScrollFlags;
+	DWORD m_dwExtendedStyle;   // scroll specific extended styles
+
+// Constructor
+	CScrollImpl() : m_zDelta(0), m_nWheelLines(3), 
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+			m_uMsgMouseWheel(0U), 
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+			m_zHDelta(0), m_nHWheelChars(3), 
+			m_uScrollFlags(0U), m_dwExtendedStyle(0)
+	{
+		m_ptOffset.x = 0;
+		m_ptOffset.y = 0;
+		m_sizeAll.cx = 0;
+		m_sizeAll.cy = 0;
+		m_sizePage.cx = 0;
+		m_sizePage.cy = 0;
+		m_sizeLine.cx = 0;
+		m_sizeLine.cy = 0;
+		m_sizeClient.cx = 0;
+		m_sizeClient.cy = 0;
+
+		SetScrollExtendedStyle(SCRL_SCROLLCHILDREN | SCRL_ERASEBACKGROUND);
+	}
+
+// Attributes & Operations
+	DWORD GetScrollExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+	DWORD SetScrollExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		// cache scroll flags
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		m_uScrollFlags = pT->uSCROLL_FLAGS | (IsScrollingChildren() ? SW_SCROLLCHILDREN : 0) | (IsErasingBackground() ? SW_ERASE : 0);
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+		m_uScrollFlags |= (IsSmoothScroll() ? SW_SMOOTHSCROLL : 0);
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+		return dwPrevStyle;
+	}
+
+	// offset operations
+	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		pT->AdjustScrollOffset(x, y);
+
+		int dx = m_ptOffset.x - x;
+		int dy = m_ptOffset.y - y;
+		m_ptOffset.x = x;
+		m_ptOffset.y = y;
+
+		// block: set horizontal scroll bar
+		{
+			SCROLLINFO si = { sizeof(SCROLLINFO) };
+			si.fMask = SIF_POS;
+			if((m_dwExtendedStyle & SCRL_DISABLENOSCROLLH) != 0)
+				si.fMask |= SIF_DISABLENOSCROLL;
+			si.nPos = m_ptOffset.x;
+			pT->SetScrollInfo(SB_HORZ, &si, bRedraw);
+		}
+
+		// block: set vertical scroll bar
+		{
+			SCROLLINFO si = { sizeof(SCROLLINFO) };
+			si.fMask = SIF_POS;
+			if((m_dwExtendedStyle & SCRL_DISABLENOSCROLLV) != 0)
+				si.fMask |= SIF_DISABLENOSCROLL;
+			si.nPos = m_ptOffset.y;
+			pT->SetScrollInfo(SB_VERT, &si, bRedraw);
+		}
+
+		// Move all children if needed
+		if(IsScrollingChildren() && (dx != 0 || dy != 0))
+		{
+			for(HWND hWndChild = ::GetWindow(pT->m_hWnd, GW_CHILD); hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
+			{
+				RECT rect = { 0 };
+				::GetWindowRect(hWndChild, &rect);
+				::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rect, 1);
+				::SetWindowPos(hWndChild, NULL, rect.left + dx, rect.top + dy, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
+			}
+		}
+
+		if(bRedraw)
+			pT->Invalidate();
+	}
+
+	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
+	{
+		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
+	}
+
+	void GetScrollOffset(POINT& ptOffset) const
+	{
+		ptOffset = m_ptOffset;
+	}
+
+	// size operations
+	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		m_sizeAll.cx = cx;
+		m_sizeAll.cy = cy;
+
+		int x = 0;
+		int y = 0;
+		if(!bResetOffset)
+		{
+			x = m_ptOffset.x;
+			y = m_ptOffset.y;
+			pT->AdjustScrollOffset(x, y);
+		}
+
+		int dx = m_ptOffset.x - x;
+		int dy = m_ptOffset.y - y;
+		m_ptOffset.x = x;
+		m_ptOffset.y = y;
+
+		// block: set horizontal scroll bar
+		{
+			SCROLLINFO si = { sizeof(SCROLLINFO) };
+			si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
+			if((m_dwExtendedStyle & SCRL_DISABLENOSCROLLH) != 0)
+				si.fMask |= SIF_DISABLENOSCROLL;
+			si.nMin = 0;
+			si.nMax = m_sizeAll.cx - 1;
+			si.nPage = m_sizeClient.cx;
+			si.nPos = m_ptOffset.x;
+			pT->SetScrollInfo(SB_HORZ, &si, bRedraw);
+		}
+
+		// block: set vertical scroll bar
+		{
+			SCROLLINFO si = { sizeof(SCROLLINFO) };
+			si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
+			if((m_dwExtendedStyle & SCRL_DISABLENOSCROLLV) != 0)
+				si.fMask |= SIF_DISABLENOSCROLL;
+			si.nMin = 0;
+			si.nMax = m_sizeAll.cy - 1;
+			si.nPage = m_sizeClient.cy;
+			si.nPos = m_ptOffset.y;
+			pT->SetScrollInfo(SB_VERT, &si, bRedraw);
+		}
+
+		// Move all children if needed
+		if(IsScrollingChildren() && (dx != 0 || dy != 0))
+		{
+			for(HWND hWndChild = ::GetWindow(pT->m_hWnd, GW_CHILD); hWndChild != NULL; hWndChild = ::GetWindow(hWndChild, GW_HWNDNEXT))
+			{
+				RECT rect = { 0 };
+				::GetWindowRect(hWndChild, &rect);
+				::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rect, 1);
+				::SetWindowPos(hWndChild, NULL, rect.left + dx, rect.top + dy, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
+			}
+		}
+
+		SetScrollLine(0, 0);
+		SetScrollPage(0, 0);
+
+		if(bRedraw)
+			pT->Invalidate();
+	}
+
+	void SetScrollSize(SIZE size, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		SetScrollSize(size.cx, size.cy, bRedraw, bResetOffset);
+	}
+
+	void GetScrollSize(SIZE& sizeWnd) const
+	{
+		sizeWnd = m_sizeAll;
+	}
+
+	// line operations
+	void SetScrollLine(int cxLine, int cyLine)
+	{
+		ATLASSERT(cxLine >= 0 && cyLine >= 0);
+		ATLASSERT(m_sizeAll.cx != 0 && m_sizeAll.cy != 0);
+
+		m_sizeLine.cx = T::CalcLineOrPage(cxLine, m_sizeAll.cx, 100);
+		m_sizeLine.cy = T::CalcLineOrPage(cyLine, m_sizeAll.cy, 100);
+	}
+
+	void SetScrollLine(SIZE sizeLine)
+	{
+		SetScrollLine(sizeLine.cx, sizeLine.cy);
+	}
+
+	void GetScrollLine(SIZE& sizeLine) const
+	{
+		sizeLine = m_sizeLine;
+	}
+
+	// page operations
+	void SetScrollPage(int cxPage, int cyPage)
+	{
+		ATLASSERT(cxPage >= 0 && cyPage >= 0);
+		ATLASSERT(m_sizeAll.cx != 0 && m_sizeAll.cy != 0);
+
+		m_sizePage.cx = T::CalcLineOrPage(cxPage, m_sizeAll.cx, 10);
+		m_sizePage.cy = T::CalcLineOrPage(cyPage, m_sizeAll.cy, 10);
+	}
+
+	void SetScrollPage(SIZE sizePage)
+	{
+		SetScrollPage(sizePage.cx, sizePage.cy);
+	}
+
+	void GetScrollPage(SIZE& sizePage) const
+	{
+		sizePage = m_sizePage;
+	}
+
+	// commands
+	void ScrollLineDown()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, SB_LINEDOWN, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+	}
+
+	void ScrollLineUp()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, SB_LINEUP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+	}
+
+	void ScrollPageDown()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, SB_PAGEDOWN, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+	}
+
+	void ScrollPageUp()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, SB_PAGEUP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+	}
+
+	void ScrollTop()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, SB_TOP, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+	}
+
+	void ScrollBottom()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, SB_BOTTOM, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+	}
+
+	void ScrollLineRight()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, SB_LINEDOWN, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+	}
+
+	void ScrollLineLeft()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, SB_LINEUP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+	}
+
+	void ScrollPageRight()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, SB_PAGEDOWN, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+	}
+
+	void ScrollPageLeft()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, SB_PAGEUP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+	}
+
+	void ScrollAllLeft()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, SB_TOP, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+	}
+
+	void ScrollAllRight()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, SB_BOTTOM, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+	}
+
+	// scroll to make point/view/window visible
+	void ScrollToView(POINT pt)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		RECT rect = { pt.x, pt.y, pt.x, pt.y };
+		pT->ScrollToView(rect);
+	}
+
+	void ScrollToView(RECT& rect)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		RECT rcClient = { 0 };
+		pT->GetClientRect(&rcClient);
+
+		int x = m_ptOffset.x;
+		if(rect.left < m_ptOffset.x)
+			x = rect.left;
+		else if(rect.right > (m_ptOffset.x + rcClient.right))
+			x = rect.right - rcClient.right;
+
+		int y = m_ptOffset.y;
+		if(rect.top < m_ptOffset.y)
+			y = rect.top;
+		else if(rect.bottom > (m_ptOffset.y + rcClient.bottom))
+			y = rect.bottom - rcClient.bottom;
+
+		SetScrollOffset(x, y);
+	}
+
+	void ScrollToView(HWND hWnd)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		RECT rect = { 0 };
+		::GetWindowRect(hWnd, &rect);
+		::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rect, 2);
+		ScrollToView(rect);
+	}
+
+	BEGIN_MSG_MAP(CScrollImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_VSCROLL, OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+		MESSAGE_HANDLER(m_uMsgMouseWheel, OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+		MESSAGE_HANDLER(WM_MOUSEHWHEEL, OnMouseHWheel)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+#endif // !_WIN32_WCE
+	// standard scroll commands
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, OnScrollAllRight)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		GetSystemSettings();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnVScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_VERT, (int)(short)LOWORD(wParam), (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+		return 0;
+	}
+
+	LRESULT OnHScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		pT->DoScroll(SB_HORZ, (int)(short)LOWORD(wParam), (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+		return 0;
+	}
+
+	LRESULT OnMouseWheel(UINT uMsg, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400) || defined(_WIN32_WCE)
+		uMsg;
+		int zDelta = (int)GET_WHEEL_DELTA_WPARAM(wParam);
+#else
+		int zDelta = (uMsg == WM_MOUSEWHEEL) ? (int)GET_WHEEL_DELTA_WPARAM(wParam) : (int)wParam;
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400) || defined(_WIN32_WCE))
+		int nScrollCode = (m_nWheelLines == WHEEL_PAGESCROLL) ? ((zDelta > 0) ? SB_PAGEUP : SB_PAGEDOWN) : ((zDelta > 0) ? SB_LINEUP : SB_LINEDOWN);
+		m_zDelta += zDelta;   // cumulative
+		int zTotal = (m_nWheelLines == WHEEL_PAGESCROLL) ? abs(m_zDelta) : abs(m_zDelta) * m_nWheelLines;
+		if(m_sizeAll.cy > m_sizeClient.cy)
+		{
+			for(int i = 0; i < zTotal; i += WHEEL_DELTA)
+			{
+				pT->DoScroll(SB_VERT, nScrollCode, (int&)m_ptOffset.y, m_sizeAll.cy, m_sizePage.cy, m_sizeLine.cy);
+				pT->UpdateWindow();
+			}
+		}
+		else		// can't scroll vertically, scroll horizontally
+		{
+			for(int i = 0; i < zTotal; i += WHEEL_DELTA)
+			{
+				pT->DoScroll(SB_HORZ, nScrollCode, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+				pT->UpdateWindow();
+			}
+		}
+		m_zDelta %= WHEEL_DELTA;
+
+		return 0;
+	}
+
+	LRESULT OnMouseHWheel(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		int zDelta = (int)GET_WHEEL_DELTA_WPARAM(wParam);
+		int nScrollCode = (m_nHWheelChars == WHEEL_PAGESCROLL) ? ((zDelta > 0) ? SB_PAGERIGHT : SB_PAGELEFT) : ((zDelta > 0) ? SB_LINERIGHT : SB_LINELEFT);
+		m_zHDelta += zDelta;   // cumulative
+		int zTotal = (m_nHWheelChars == WHEEL_PAGESCROLL) ? abs(m_zHDelta) : abs(m_zHDelta) * m_nHWheelChars;
+		if(m_sizeAll.cx > m_sizeClient.cx)
+		{
+			for(int i = 0; i < zTotal; i += WHEEL_DELTA)
+			{
+				pT->DoScroll(SB_HORZ, nScrollCode, (int&)m_ptOffset.x, m_sizeAll.cx, m_sizePage.cx, m_sizeLine.cx);
+				pT->UpdateWindow();
+			}
+		}
+		m_zHDelta %= WHEEL_DELTA;
+
+		return 0;
+	}
+
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		GetSystemSettings();
+		return 0;
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		m_sizeClient.cx = GET_X_LPARAM(lParam);
+		m_sizeClient.cy = GET_Y_LPARAM(lParam);
+
+		// block: set horizontal scroll bar
+		{
+			SCROLLINFO si = { sizeof(SCROLLINFO) };
+			si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
+			si.nMin = 0;
+			si.nMax = m_sizeAll.cx - 1;
+			if((m_dwExtendedStyle & SCRL_DISABLENOSCROLLH) != 0)
+				si.fMask |= SIF_DISABLENOSCROLL;
+			si.nPage = m_sizeClient.cx;
+			si.nPos = m_ptOffset.x;
+			pT->SetScrollInfo(SB_HORZ, &si, TRUE);
+		}
+
+		// block: set vertical scroll bar
+		{
+			SCROLLINFO si = { sizeof(SCROLLINFO) };
+			si.fMask = SIF_PAGE | SIF_RANGE | SIF_POS;
+			si.nMin = 0;
+			si.nMax = m_sizeAll.cy - 1;
+			if((m_dwExtendedStyle & SCRL_DISABLENOSCROLLV) != 0)
+				si.fMask |= SIF_DISABLENOSCROLL;
+			si.nPage = m_sizeClient.cy;
+			si.nPos = m_ptOffset.y;
+			pT->SetScrollInfo(SB_VERT, &si, TRUE);
+		}
+
+		int x = m_ptOffset.x;
+		int y = m_ptOffset.y;
+		if(pT->AdjustScrollOffset(x, y))
+		{
+			// Children will be moved in SetScrollOffset, if needed
+			pT->ScrollWindowEx(m_ptOffset.x - x, m_ptOffset.y - y, (m_uScrollFlags & ~SCRL_SCROLLCHILDREN));
+			SetScrollOffset(x, y, FALSE);
+		}
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		if(wParam != NULL)
+		{
+			CDCHandle dc = (HDC)wParam;
+			POINT ptViewportOrg = { 0, 0 };
+			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y, &ptViewportOrg);
+			pT->DoPaint(dc);
+			dc.SetViewportOrg(ptViewportOrg);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
+			pT->DoPaint(dc.m_hDC);
+		}
+		return 0;
+	}
+
+	// scrolling handlers
+	LRESULT OnScrollUp(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollLineUp();
+		return 0;
+	}
+
+	LRESULT OnScrollDown(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollLineDown();
+		return 0;
+	}
+
+	LRESULT OnScrollPageUp(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollPageUp();
+		return 0;
+	}
+
+	LRESULT OnScrollPageDown(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollPageDown();
+		return 0;
+	}
+
+	LRESULT OnScrollTop(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollTop();
+		return 0;
+	}
+
+	LRESULT OnScrollBottom(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollBottom();
+		return 0;
+	}
+
+	LRESULT OnScrollLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollLineLeft();
+		return 0;
+	}
+
+	LRESULT OnScrollRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollLineRight();
+		return 0;
+	}
+
+	LRESULT OnScrollPageLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollPageLeft();
+		return 0;
+	}
+
+	LRESULT OnScrollPageRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollPageRight();
+		return 0;
+	}
+
+	LRESULT OnScrollAllLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollAllLeft();
+		return 0;
+	}
+
+	LRESULT OnScrollAllRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		ScrollAllRight();
+		return 0;
+	}
+
+// Overrideables
+	void DoPaint(CDCHandle /*dc*/)
+	{
+		// must be implemented in a derived class
+		ATLASSERT(FALSE);
+	}
+
+// Implementation
+	void DoScroll(int nType, int nScrollCode, int& cxyOffset, int cxySizeAll, int cxySizePage, int cxySizeLine)
+	{
+		T* pT = static_cast<T*>(this);
+		RECT rect = { 0 };
+		pT->GetClientRect(&rect);
+		int cxyClient = (nType == SB_VERT) ? rect.bottom : rect.right;
+		int cxyMax = cxySizeAll - cxyClient;
+
+		if(cxyMax < 0)   // can't scroll, client area is bigger
+			return;
+
+		bool bUpdate = true;
+		int cxyScroll = 0;
+
+		switch(nScrollCode)
+		{
+		case SB_TOP:		// top or all left
+			cxyScroll = cxyOffset;
+			cxyOffset = 0;
+			break;
+		case SB_BOTTOM:		// bottom or all right
+			cxyScroll = cxyOffset - cxyMax;
+			cxyOffset = cxyMax;
+			break;
+		case SB_LINEUP:		// line up or line left
+			if(cxyOffset >= cxySizeLine)
+			{
+				cxyScroll = cxySizeLine;
+				cxyOffset -= cxySizeLine;
+			}
+			else
+			{
+				cxyScroll = cxyOffset;
+				cxyOffset = 0;
+			}
+			break;
+		case SB_LINEDOWN:	// line down or line right
+			if(cxyOffset < cxyMax - cxySizeLine)
+			{
+				cxyScroll = -cxySizeLine;
+				cxyOffset += cxySizeLine;
+			}
+			else
+			{
+				cxyScroll = cxyOffset - cxyMax;
+				cxyOffset = cxyMax;
+			}
+			break;
+		case SB_PAGEUP:		// page up or page left
+			if(cxyOffset >= cxySizePage)
+			{
+				cxyScroll = cxySizePage;
+				cxyOffset -= cxySizePage;
+			}
+			else
+			{
+				cxyScroll = cxyOffset;
+				cxyOffset = 0;
+			}
+			break;
+		case SB_PAGEDOWN:	// page down or page right
+			if(cxyOffset < cxyMax - cxySizePage)
+			{
+				cxyScroll = -cxySizePage;
+				cxyOffset += cxySizePage;
+			}
+			else
+			{
+				cxyScroll = cxyOffset - cxyMax;
+				cxyOffset = cxyMax;
+			}
+			break;
+		case SB_THUMBTRACK:
+			if(IsNoThumbTracking())
+				break;
+			// else fall through
+		case SB_THUMBPOSITION:
+			{
+				SCROLLINFO si = { sizeof(SCROLLINFO), SIF_TRACKPOS };
+				if(pT->GetScrollInfo(nType, &si))
+				{
+					cxyScroll = cxyOffset - si.nTrackPos;
+					cxyOffset = si.nTrackPos;
+				}
+			}
+			break;
+		case SB_ENDSCROLL:
+		default:
+			bUpdate = false;
+			break;
+		}
+
+		if(bUpdate && cxyScroll != 0)
+		{
+			pT->SetScrollPos(nType, cxyOffset, TRUE);
+			if(nType == SB_VERT)
+				pT->ScrollWindowEx(0, cxyScroll, m_uScrollFlags);
+			else
+				pT->ScrollWindowEx(cxyScroll, 0, m_uScrollFlags);
+		}
+	}
+
+	static int CalcLineOrPage(int nVal, int nMax, int nDiv)
+	{
+		if(nVal == 0)
+		{
+			nVal = nMax / nDiv;
+			if(nVal < 1)
+				nVal = 1;
+		}
+		else if(nVal > nMax)
+		{
+			nVal = nMax;
+		}
+
+		return nVal;
+	}
+
+	bool AdjustScrollOffset(int& x, int& y)
+	{
+		int xOld = x;
+		int yOld = y;
+
+		int cxMax = m_sizeAll.cx - m_sizeClient.cx;
+		if(x > cxMax)
+			x = (cxMax >= 0) ? cxMax : 0;
+		else if(x < 0)
+			x = 0;
+
+		int cyMax = m_sizeAll.cy - m_sizeClient.cy;
+		if(y > cyMax)
+			y = (cyMax >= 0) ? cyMax : 0;
+		else if(y < 0)
+			y = 0;
+
+		return (x != xOld || y != yOld);
+	}
+
+	void GetSystemSettings()
+	{
+#ifndef _WIN32_WCE
+#ifndef SPI_GETWHEELSCROLLLINES
+		const UINT SPI_GETWHEELSCROLLLINES = 104;
+#endif // !SPI_GETWHEELSCROLLLINES
+		::SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &m_nWheelLines, 0);
+
+#ifndef SPI_GETWHEELSCROLLCHARS
+		const UINT SPI_GETWHEELSCROLLCHARS = 0x006C;
+#endif // !SPI_GETWHEELSCROLLCHARS
+		::SystemParametersInfo(SPI_GETWHEELSCROLLCHARS, 0, &m_nHWheelChars, 0);
+
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		if(m_uMsgMouseWheel != 0)
+			m_uMsgMouseWheel = ::RegisterWindowMessage(MSH_MOUSEWHEEL);
+
+		HWND hWndWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
+		if(::IsWindow(hWndWheel))
+		{
+			UINT uMsgScrollLines = ::RegisterWindowMessage(MSH_SCROLL_LINES);
+			if(uMsgScrollLines != 0)
+				m_nWheelLines = (int)::SendMessage(hWndWheel, uMsgScrollLines, 0, 0L);
+		}
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+#endif // !_WIN32_WCE
+	}
+
+	bool IsScrollingChildren() const
+	{
+		return (m_dwExtendedStyle & SCRL_SCROLLCHILDREN) != 0;
+	}
+
+	bool IsErasingBackground() const
+	{
+		return (m_dwExtendedStyle & SCRL_ERASEBACKGROUND) != 0;
+	}
+
+	bool IsNoThumbTracking() const
+	{
+		return (m_dwExtendedStyle & SCRL_NOTHUMBTRACKING) != 0;
+	}
+
+#if (WINVER >= 0x0500)
+	bool IsSmoothScroll() const
+	{
+		return (m_dwExtendedStyle & SCRL_SMOOTHSCROLL) != 0;
+	}
+#endif // (WINVER >= 0x0500)
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CScrollWindowImpl - Implements a scrollable window
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CScrollWindowImpl : public ATL::CWindowImpl<T, TBase, TWinTraits>, public CScrollImpl< T >
+{
+public:
+	BEGIN_MSG_MAP(CScrollWindowImpl)
+		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)) && !defined(_WIN32_WCE)
+		MESSAGE_HANDLER(WM_MOUSEHWHEEL, CScrollImpl< T >::OnMouseHWheel)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
+		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
+		MESSAGE_HANDLER(WM_PAINT, CScrollImpl< T >::OnPaint)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_PRINTCLIENT, CScrollImpl< T >::OnPaint)
+#endif // !_WIN32_WCE
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
+	END_MSG_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMapScrollImpl - Provides mapping and scrolling support to any window
+
+#ifndef _WIN32_WCE
+
+template <class T>
+class CMapScrollImpl : public CScrollImpl< T >
+{
+public:
+	int m_nMapMode;
+	RECT m_rectLogAll;
+	SIZE m_sizeLogLine;
+	SIZE m_sizeLogPage;
+
+// Constructor
+	CMapScrollImpl() : m_nMapMode(MM_TEXT)
+	{
+		::SetRectEmpty(&m_rectLogAll);
+		m_sizeLogPage.cx = 0;
+		m_sizeLogPage.cy = 0;
+		m_sizeLogLine.cx = 0;
+		m_sizeLogLine.cy = 0;
+	}
+
+// Attributes & Operations
+	// mapping mode operations
+	void SetScrollMapMode(int nMapMode)
+	{
+		ATLASSERT(nMapMode >= MM_MIN && nMapMode <= MM_MAX_FIXEDSCALE);
+		m_nMapMode = nMapMode;
+	}
+
+	int GetScrollMapMode() const
+	{
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+		return m_nMapMode;
+	}
+
+	// offset operations
+	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+		POINT ptOff = { x, y };
+		// block: convert logical to device units
+		{
+			CWindowDC dc(NULL);
+			dc.SetMapMode(m_nMapMode);
+			dc.LPtoDP(&ptOff);
+		}
+		CScrollImpl< T >::SetScrollOffset(ptOff, bRedraw);
+	}
+
+	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
+	{
+		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
+	}
+
+	void GetScrollOffset(POINT& ptOffset) const
+	{
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+		ptOffset = m_ptOffset;
+		// block: convert device to logical units
+		{
+			CWindowDC dc(NULL);
+			dc.SetMapMode(m_nMapMode);
+			dc.DPtoLP(&ptOffset);
+		}
+	}
+
+	// size operations
+	void SetScrollSize(int xMin, int yMin, int xMax, int yMax, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		ATLASSERT(xMax > xMin && yMax > yMin);
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+
+		::SetRect(&m_rectLogAll, xMin, yMin, xMax, yMax);
+
+		SIZE sizeAll = { 0 };
+		sizeAll.cx = xMax - xMin + 1;
+		sizeAll.cy = yMax - yMin + 1;
+		// block: convert logical to device units
+		{
+			CWindowDC dc(NULL);
+			dc.SetMapMode(m_nMapMode);
+			dc.LPtoDP(&sizeAll);
+		}
+		CScrollImpl< T >::SetScrollSize(sizeAll, bRedraw, bResetOffset);
+		SetScrollLine(0, 0);
+		SetScrollPage(0, 0);
+	}
+
+	void SetScrollSize(RECT& rcScroll, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		SetScrollSize(rcScroll.left, rcScroll.top, rcScroll.right, rcScroll.bottom, bRedraw, bResetOffset);
+	}
+
+	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		SetScrollSize(0, 0, cx, cy, bRedraw, bResetOffset);
+	}
+
+	void SetScrollSize(SIZE size, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		SetScrollSize(0, 0, size.cx, size.cy, bRedraw, bResetOffset);
+	}
+
+	void GetScrollSize(RECT& rcScroll) const
+	{
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+		rcScroll = m_rectLogAll;
+	}
+
+	// line operations
+	void SetScrollLine(int cxLine, int cyLine)
+	{
+		ATLASSERT(cxLine >= 0 && cyLine >= 0);
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+
+		m_sizeLogLine.cx = cxLine;
+		m_sizeLogLine.cy = cyLine;
+		SIZE sizeLine = m_sizeLogLine;
+		// block: convert logical to device units
+		{
+			CWindowDC dc(NULL);
+			dc.SetMapMode(m_nMapMode);
+			dc.LPtoDP(&sizeLine);
+		}
+		CScrollImpl< T >::SetScrollLine(sizeLine);
+	}
+
+	void SetScrollLine(SIZE sizeLine)
+	{
+		SetScrollLine(sizeLine.cx, sizeLine.cy);
+	}
+
+	void GetScrollLine(SIZE& sizeLine) const
+	{
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+		sizeLine = m_sizeLogLine;
+	}
+
+	// page operations
+	void SetScrollPage(int cxPage, int cyPage)
+	{
+		ATLASSERT(cxPage >= 0 && cyPage >= 0);
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+
+		m_sizeLogPage.cx = cxPage;
+		m_sizeLogPage.cy = cyPage;
+		SIZE sizePage = m_sizeLogPage;
+		// block: convert logical to device units
+		{
+			CWindowDC dc(NULL);
+			dc.SetMapMode(m_nMapMode);
+			dc.LPtoDP(&sizePage);
+		}
+		CScrollImpl< T >::SetScrollPage(sizePage);
+	}
+
+	void SetScrollPage(SIZE sizePage)
+	{
+		SetScrollPage(sizePage.cx, sizePage.cy);
+	}
+
+	void GetScrollPage(SIZE& sizePage) const
+	{
+		ATLASSERT(m_nMapMode >= MM_MIN && m_nMapMode <= MM_MAX_FIXEDSCALE);
+		sizePage = m_sizeLogPage;
+	}
+
+	BEGIN_MSG_MAP(CMapScrollImpl)
+		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(WM_MOUSEHWHEEL, CScrollImpl< T >::OnMouseHWheel)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
+		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
+	END_MSG_MAP()
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		if(wParam != NULL)
+		{
+			CDCHandle dc = (HDC)wParam;
+			int nMapModeSav = dc.GetMapMode();
+			dc.SetMapMode(m_nMapMode);
+			POINT ptViewportOrg = { 0, 0 };
+			if(m_nMapMode == MM_TEXT)
+				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y, &ptViewportOrg);
+			else
+				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y + m_sizeAll.cy, &ptViewportOrg);
+			POINT ptWindowOrg = { 0, 0 };
+			dc.SetWindowOrg(m_rectLogAll.left, m_rectLogAll.top, &ptWindowOrg);
+
+			pT->DoPaint(dc);
+
+			dc.SetMapMode(nMapModeSav);
+			dc.SetViewportOrg(ptViewportOrg);
+			dc.SetWindowOrg(ptWindowOrg);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			dc.SetMapMode(m_nMapMode);
+			if(m_nMapMode == MM_TEXT)
+				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
+			else
+				dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y + m_sizeAll.cy);
+			dc.SetWindowOrg(m_rectLogAll.left, m_rectLogAll.top);
+			pT->DoPaint(dc.m_hDC);
+		}
+		return 0;
+	}
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMapScrollWindowImpl - Implements scrolling window with mapping
+
+#ifndef _WIN32_WCE
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CMapScrollWindowImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >, public CMapScrollImpl< T >
+{
+public:
+	BEGIN_MSG_MAP(CMapScrollWindowImpl)
+		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(WM_MOUSEHWHEEL, CScrollImpl< T >::OnMouseHWheel)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
+		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
+		MESSAGE_HANDLER(WM_PAINT, CMapScrollImpl< T >::OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, CMapScrollImpl< T >::OnPaint)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
+	END_MSG_MAP()
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CFSBWindow - Use as a base instead of CWindow to get flat scroll bar support
+
+#if defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+template <class TBase = ATL::CWindow>
+class CFSBWindowT : public TBase, public CFlatScrollBarImpl<CFSBWindowT< TBase > >
+{
+public:
+// Constructors
+	CFSBWindowT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CFSBWindowT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+// CWindow overrides that use flat scroll bar API
+// (only those methods that are used by scroll window classes)
+	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return FlatSB_SetScrollPos(nBar, nPos, bRedraw);
+	}
+
+	BOOL GetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return FlatSB_GetScrollInfo(nBar, lpScrollInfo);
+	}
+
+	BOOL SetScrollInfo(int nBar, LPSCROLLINFO lpScrollInfo, BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return FlatSB_SetScrollInfo(nBar, lpScrollInfo, bRedraw);
+	}
+};
+
+typedef CFSBWindowT<ATL::CWindow>   CFSBWindow;
+
+#endif // defined(__ATLCTRLS_H__) && (_WIN32_IE >= 0x0400) && !defined(_WIN32_WCE)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CZoomScrollImpl - Provides zooming and scrolling support to any window
+
+#ifndef _WIN32_WCE
+
+// The zoom modes that can be set with the SetZoomMode method
+enum
+{
+	ZOOMMODE_OFF, 
+	ZOOMMODE_IN,   // If left mouse button is clicked or dragged, zoom in on point clicked or rectangle dragged.
+	ZOOMMODE_OUT   // If left mouse button clicked, zoom out on point clicked.
+};
+
+// Notification to parent that zoom scale changed as a result of user mouse action.
+#define ZSN_ZOOMCHANGED	(NM_FIRST - 50) 
+
+template <class T>
+class CZoomScrollImpl : public CScrollImpl< T >
+{
+public:
+	enum { m_cxyMinZoomRect = 12 };   // min rect size to zoom in on rect.
+
+// Data members
+	SIZE m_sizeLogAll;		
+	SIZE m_sizeLogLine;	
+	SIZE m_sizeLogPage;
+	float m_fZoomScale;
+	float m_fZoomScaleMin;
+	float m_fZoomDelta;   // Used in ZOOMMODE_IN and ZOOMMODE_OUT on left-button click.
+	int m_nZoomMode;		
+	RECT m_rcTrack;
+	bool m_bTracking;
+
+// Constructor
+	CZoomScrollImpl():
+			m_fZoomScale(1.0),
+			m_fZoomScaleMin(0.5),
+			m_fZoomDelta(0.5),
+			m_nZoomMode(ZOOMMODE_OFF),
+			m_bTracking(false)
+	{
+		m_sizeLogAll.cx = 0;
+		m_sizeLogAll.cy = 0;
+		m_sizeLogPage.cx = 0;
+		m_sizeLogPage.cy = 0;
+		m_sizeLogLine.cx = 0;
+		m_sizeLogLine.cy = 0;
+		::SetRectEmpty(&m_rcTrack);
+	}
+
+// Attributes & Operations
+
+	// size operations
+	void SetScrollSize(int cxLog, int cyLog, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		ATLASSERT(cxLog >= 0 && cyLog >= 0);
+
+		// Set up the defaults
+		if (cxLog == 0 && cyLog == 0)
+		{
+			cxLog = 1;
+			cyLog = 1;
+		}
+
+		m_sizeLogAll.cx = cxLog;
+		m_sizeLogAll.cy = cyLog;
+		SIZE sizeAll = { 0 };
+		sizeAll.cx = (int)((float)m_sizeLogAll.cx * m_fZoomScale);
+		sizeAll.cy = (int)((float)m_sizeLogAll.cy * m_fZoomScale);
+
+		CScrollImpl< T >::SetScrollSize(sizeAll, bRedraw, bResetOffset);
+	}
+
+	void SetScrollSize(SIZE sizeLog, BOOL bRedraw = TRUE, bool bResetOffset = true)
+	{
+		SetScrollSize(sizeLog.cx, sizeLog.cy, bRedraw, bResetOffset);
+	}
+
+	void GetScrollSize(SIZE& sizeLog) const
+	{
+		sizeLog = m_sizeLogAll;
+	}
+
+	// line operations
+	void SetScrollLine(int cxLogLine, int cyLogLine)
+	{
+		ATLASSERT(cxLogLine >= 0 && cyLogLine >= 0);
+
+		m_sizeLogLine.cx = cxLogLine;
+		m_sizeLogLine.cy = cyLogLine;
+
+		SIZE sizeLine = { 0 };
+		sizeLine.cx = (int)((float)m_sizeLogLine.cx * m_fZoomScale);
+		sizeLine.cy = (int)((float)m_sizeLogLine.cy * m_fZoomScale);
+		CScrollImpl< T >::SetScrollLine(sizeLine);
+	}
+
+	void SetScrollLine(SIZE sizeLogLine)
+	{
+		SetScrollLine(sizeLogLine.cx, sizeLogLine.cy);
+	}
+
+	void GetScrollLine(SIZE& sizeLogLine) const
+	{
+		sizeLogLine = m_sizeLogLine;
+	}
+
+	// page operations
+	void SetScrollPage(int cxLogPage, int cyLogPage)
+	{
+		ATLASSERT(cxLogPage >= 0 && cyLogPage >= 0);
+
+		m_sizeLogPage.cx = cxLogPage;
+		m_sizeLogPage.cy = cyLogPage;
+
+		SIZE sizePage = { 0 };
+		sizePage.cx = (int)((float)m_sizeLogPage.cx * m_fZoomScale);
+		sizePage.cy = (int)((float)m_sizeLogPage.cy * m_fZoomScale);
+
+		CScrollImpl< T >::SetScrollPage(sizePage);
+	}
+
+	void SetScrollPage(SIZE sizeLogPage)
+	{
+		SetScrollPage(sizeLogPage.cx, sizeLogPage.cy);
+	}
+
+	void GetScrollPage(SIZE& sizeLogPage) const
+	{
+		sizeLogPage = m_sizeLogPage;
+	}
+
+	void SetZoomScale(float fZoomScale)
+	{
+		ATLASSERT(fZoomScale > 0);
+
+		if(fZoomScale > 0 && fZoomScale >= m_fZoomScaleMin)
+			m_fZoomScale = fZoomScale;
+	}
+
+	float GetZoomScale() const
+	{
+		return m_fZoomScale;
+	}
+
+	void SetZoomScaleMin(float fZoomScaleMin)
+	{
+		m_fZoomScaleMin = fZoomScaleMin;
+	}
+
+	float GetZoomScaleMin() const
+	{
+		return m_fZoomScaleMin;
+	}
+
+	void SetZoomDelta(float fZoomDelta)
+	{
+		ATLASSERT(fZoomDelta >= 0);
+
+		if(fZoomDelta >= 0)
+			m_fZoomDelta = fZoomDelta;
+	}
+
+	float GetZoomDelta() const
+	{
+		return m_fZoomDelta;
+	}
+
+	void SetZoomMode(int nZoomMode)
+	{
+		m_nZoomMode = nZoomMode;
+	}
+
+	int GetZoomMode() const
+	{
+		return m_nZoomMode;
+	}
+
+	void Zoom(int x, int y, float fZoomScale)
+	{
+		if(fZoomScale <= 0)
+			return;
+
+		fZoomScale = max(fZoomScale, m_fZoomScaleMin);
+
+		T* pT = static_cast<T*>(this);
+		POINT pt = { x, y };
+		if(!pT->PtInDevRect(pt))
+			return;
+
+		pT->ViewDPtoLP(&pt);
+		pT->Zoom(fZoomScale, false);
+		pT->CenterOnLogicalPoint(pt);
+	}
+
+	void Zoom(POINT pt, float fZoomScale)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->Zoom(pt.x, pt.y, fZoomScale);
+	}
+
+	void Zoom(RECT& rc)
+	{
+		T* pT = static_cast<T*>(this);
+		RECT rcZoom = rc;
+		pT->NormalizeRect(rcZoom);
+		SIZE size = { rcZoom.right - rcZoom.left, rcZoom.bottom - rcZoom.top };
+		POINT pt = { rcZoom.left + size.cx / 2, rcZoom.top + size.cy / 2 };
+		if(size.cx < m_cxyMinZoomRect || size.cy < m_cxyMinZoomRect)
+		{
+			pT->Zoom(pt, m_fZoomScale + m_fZoomDelta);
+			return;
+		}
+
+		ATLASSERT(size.cx > 0 && size.cy > 0);
+		
+		float fScaleH = (float)(m_sizeClient.cx  + 1) / (float)size.cx;
+		float fScaleV = (float)(m_sizeClient.cy + 1) / (float)size.cy;
+		float fZoomScale = min(fScaleH, fScaleV) * m_fZoomScale;
+		pT->Zoom(pt, fZoomScale);		
+	}
+
+	void Zoom(float fZoomScale, bool bCenter = true)
+	{
+		if(fZoomScale <= 0)
+			return;
+
+		fZoomScale = max(fZoomScale, m_fZoomScaleMin);
+
+
+		T* pT = static_cast<T*>(this);
+		POINT pt = { 0 };
+		if(bCenter)
+		{
+			RECT rc;
+			::GetClientRect(pT->m_hWnd, &rc);
+			pt.x = rc.right / 2;
+			pt.y = rc.bottom / 2;
+			pT->ViewDPtoLP(&pt);
+		}
+
+		// Modify the Viewport extent
+		m_fZoomScale = fZoomScale;
+		SIZE sizeAll = { 0 };
+		sizeAll.cx = (int)((float)m_sizeLogAll.cx * fZoomScale);
+		sizeAll.cy = (int)((float)m_sizeLogAll.cy * fZoomScale);
+		
+		// Update scroll bars and window
+		CScrollImpl< T >::SetScrollSize(sizeAll);
+
+		if(bCenter)
+			pT->CenterOnLogicalPoint(pt);
+	}
+
+	// Helper functions
+	void PrepareDC(CDCHandle dc)
+	{
+		ATLASSERT(m_sizeAll.cx >= 0 && m_sizeAll.cy >= 0);
+		dc.SetMapMode(MM_ANISOTROPIC);
+		dc.SetWindowExt(m_sizeLogAll);
+		dc.SetViewportExt(m_sizeAll);
+		dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y);
+	}
+
+	void ViewDPtoLP(LPPOINT lpPoints, int nCount = 1)
+	{
+		ATLASSERT(lpPoints);
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+
+		CWindowDC dc(pT->m_hWnd);
+		pT->PrepareDC(dc.m_hDC);
+		dc.DPtoLP(lpPoints, nCount);
+	}
+
+	void ViewLPtoDP(LPPOINT lpPoints, int nCount = 1)
+	{
+		ATLASSERT(lpPoints);
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+	
+		CWindowDC dc(pT->m_hWnd);
+		pT->PrepareDC(dc.m_hDC);
+		dc.LPtoDP(lpPoints, nCount);
+	}
+
+	void ClientToDevice(POINT &pt)
+	{
+		pt.x += m_ptOffset.x;
+		pt.y += m_ptOffset.y;
+	}	 
+
+	void DeviceToClient(POINT &pt)
+	{
+		pt.x -= m_ptOffset.x;
+		pt.y -= m_ptOffset.y;
+	}
+
+	void CenterOnPoint(POINT pt)
+	{
+		T* pT = static_cast<T*>(this);
+		RECT rect;
+		pT->GetClientRect(&rect);
+
+		int xOfs = pt.x - (rect.right / 2) + m_ptOffset.x;
+		if(xOfs < 0)
+		{
+			xOfs = 0;
+		}
+		else 
+		{
+			int xMax = max((int)(m_sizeAll.cx - rect.right), 0);
+			if(xOfs > xMax)
+				xOfs = xMax;
+		}
+		
+		int yOfs = pt.y - (rect.bottom / 2) + m_ptOffset.y;
+		if(yOfs < 0)
+		{
+			yOfs = 0;
+		}
+		else 
+		{
+			int yMax = max((int)(m_sizeAll.cy - rect.bottom), 0);
+			if(yOfs > yMax)
+				yOfs = yMax;
+		}
+
+		CScrollImpl< T >::SetScrollOffset(xOfs, yOfs);
+	}
+
+	void CenterOnLogicalPoint(POINT ptLog)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->ViewLPtoDP(&ptLog);
+		pT->DeviceToClient(ptLog);
+		pT->CenterOnPoint(ptLog);
+	}
+
+	BOOL PtInDevRect(POINT pt)
+	{
+		RECT rc = { 0, 0, m_sizeAll.cx, m_sizeAll.cy };
+		::OffsetRect(&rc, -m_ptOffset.x, -m_ptOffset.y);
+		return ::PtInRect(&rc, pt);
+	}
+
+	void NormalizeRect(RECT& rc)
+	{
+		if(rc.left > rc.right) 
+		{
+			int r = rc.right;
+			rc.right = rc.left;
+			rc.left = r;
+		}
+		if(rc.top > rc.bottom)
+		{
+			int b = rc.bottom;
+			rc.bottom = rc.top;
+			rc.top = b;
+		}
+	}
+
+	void DrawTrackRect()
+	{
+		T* pT = static_cast<T*>(this);
+		const SIZE sizeLines = { 2, 2 };
+		RECT rc = m_rcTrack;
+		pT->NormalizeRect(rc);
+		if(!::IsRectEmpty(&rc))
+		{
+			::MapWindowPoints(pT->m_hWnd, NULL, (LPPOINT)&rc, 2);
+			CWindowDC dc(NULL);
+			dc.DrawDragRect(&rc, sizeLines, NULL, sizeLines);
+		}
+	}
+
+	void NotifyParentZoomChanged()
+	{
+		T* pT = static_cast<T*>(this);
+		int nId = pT->GetDlgCtrlID();
+		NMHDR nmhdr = { pT->m_hWnd, nId, ZSN_ZOOMCHANGED };
+		::SendMessage(pT->GetParent(), WM_NOTIFY, (WPARAM)nId, (LPARAM)&nmhdr);
+	}
+
+	BEGIN_MSG_MAP(CZoomScrollImpl)
+		MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
+		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(WM_MOUSEHWHEEL, CScrollImpl< T >::OnMouseHWheel)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
+		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
+		MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
+		MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
+	END_MSG_MAP()
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		ATLASSERT(m_sizeLogAll.cx >= 0 && m_sizeLogAll.cy >= 0);
+		ATLASSERT(m_sizeAll.cx >= 0 && m_sizeAll.cy >= 0);
+
+		if(wParam != NULL)
+		{
+			CDCHandle dc = (HDC)wParam;
+			int nMapModeSav = dc.GetMapMode();
+			dc.SetMapMode(MM_ANISOTROPIC);
+			SIZE szWindowExt = { 0, 0 };
+			dc.SetWindowExt(m_sizeLogAll, &szWindowExt);
+			SIZE szViewportExt = { 0, 0 };
+			dc.SetViewportExt(m_sizeAll, &szViewportExt);
+			POINT ptViewportOrg = { 0, 0 };
+			dc.SetViewportOrg(-m_ptOffset.x, -m_ptOffset.y, &ptViewportOrg);
+
+			pT->DoPaint(dc);
+
+			dc.SetMapMode(nMapModeSav);
+			dc.SetWindowExt(szWindowExt);
+			dc.SetViewportExt(szViewportExt);
+			dc.SetViewportOrg(ptViewportOrg);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			pT->PrepareDC(dc.m_hDC);
+			pT->DoPaint(dc.m_hDC);
+		}
+		return 0;
+	}
+
+	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(m_nZoomMode == ZOOMMODE_IN && !m_bTracking)
+		{
+			T* pT = static_cast<T*>(this);
+			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+			if(pT->PtInDevRect(pt))
+			{
+				pT->SetCapture();
+				m_bTracking = true;
+				::SetRect(&m_rcTrack, pt.x, pt.y, pt.x, pt.y);
+			}	
+		}
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		if(m_bTracking)
+		{
+			T* pT = static_cast<T*>(this);
+			POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
+			if(pT->PtInDevRect(pt))
+			{
+				pT->DrawTrackRect();
+				m_rcTrack.right = pt.x;
+				m_rcTrack.bottom = pt.y;
+				pT->DrawTrackRect();
+			}
+		}
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		::ReleaseCapture();
+		if(m_nZoomMode == ZOOMMODE_OUT)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->Zoom(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam), m_fZoomScale - m_fZoomDelta);
+			pT->NotifyParentZoomChanged();
+		}
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_bTracking)
+		{
+			m_bTracking = false;
+			T* pT = static_cast<T*>(this);
+			pT->DrawTrackRect();
+			pT->Zoom(m_rcTrack);
+			pT->NotifyParentZoomChanged();
+			::SetRectEmpty(&m_rcTrack);
+		}
+		bHandled = FALSE;
+		return 0;
+	}	
+
+	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		if(LOWORD(lParam) == HTCLIENT && m_nZoomMode != ZOOMMODE_OFF)
+		{
+			T* pT = static_cast<T*>(this);
+			if((HWND)wParam == pT->m_hWnd)
+			{
+				DWORD dwPos = ::GetMessagePos();
+				POINT pt = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
+				pT->ScreenToClient(&pt);
+				if(pT->PtInDevRect(pt))
+				{
+					::SetCursor(::LoadCursor(NULL, IDC_CROSS));
+					return 1;
+				}
+			}
+		}
+		bHandled = FALSE;
+		return 0;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CZoomScrollWindowImpl - Implements scrolling window with zooming
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CZoomScrollWindowImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >, public CZoomScrollImpl< T >
+{
+public:
+	BEGIN_MSG_MAP(CZoomScrollWindowImpl)
+		MESSAGE_HANDLER(WM_SETCURSOR, CZoomScrollImpl< T >::OnSetCursor)
+		MESSAGE_HANDLER(WM_VSCROLL, CScrollImpl< T >::OnVScroll)
+		MESSAGE_HANDLER(WM_HSCROLL, CScrollImpl< T >::OnHScroll)
+		MESSAGE_HANDLER(WM_MOUSEWHEEL, CScrollImpl< T >::OnMouseWheel)
+#if !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(m_uMsgMouseWheel, CScrollImpl< T >::OnMouseWheel)
+#endif // !((_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400))
+		MESSAGE_HANDLER(WM_MOUSEHWHEEL, CScrollImpl< T >::OnMouseHWheel)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CScrollImpl< T >::OnSettingChange)
+		MESSAGE_HANDLER(WM_SIZE, CScrollImpl< T >::OnSize)
+		MESSAGE_HANDLER(WM_PAINT, CZoomScrollImpl< T >::OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, CZoomScrollImpl< T >::OnPaint)
+		MESSAGE_HANDLER(WM_LBUTTONDOWN, CZoomScrollImpl< T >::OnLButtonDown)
+		MESSAGE_HANDLER(WM_MOUSEMOVE, CZoomScrollImpl< T >::OnMouseMove)
+		MESSAGE_HANDLER(WM_LBUTTONUP, CZoomScrollImpl< T >::OnLButtonUp)
+		MESSAGE_HANDLER(WM_CAPTURECHANGED, CZoomScrollImpl< T >::OnCaptureChanged)
+	ALT_MSG_MAP(1)
+		COMMAND_ID_HANDLER(ID_SCROLL_UP, CScrollImpl< T >::OnScrollUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_DOWN, CScrollImpl< T >::OnScrollDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_UP, CScrollImpl< T >::OnScrollPageUp)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_DOWN, CScrollImpl< T >::OnScrollPageDown)
+		COMMAND_ID_HANDLER(ID_SCROLL_TOP, CScrollImpl< T >::OnScrollTop)
+		COMMAND_ID_HANDLER(ID_SCROLL_BOTTOM, CScrollImpl< T >::OnScrollBottom)
+		COMMAND_ID_HANDLER(ID_SCROLL_LEFT, CScrollImpl< T >::OnScrollLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_RIGHT, CScrollImpl< T >::OnScrollRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_LEFT, CScrollImpl< T >::OnScrollPageLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_PAGE_RIGHT, CScrollImpl< T >::OnScrollPageRight)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_LEFT, CScrollImpl< T >::OnScrollAllLeft)
+		COMMAND_ID_HANDLER(ID_SCROLL_ALL_RIGHT, CScrollImpl< T >::OnScrollAllRight)
+	END_MSG_MAP()
+};
+
+#endif // !_WIN32_WCE
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CScrollContainer
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CScrollContainerImpl : public CScrollWindowImpl< T, TBase, TWinTraits >
+{
+public:
+	DECLARE_WND_CLASS_EX(NULL, 0, -1)
+
+	typedef CScrollWindowImpl< T, TBase, TWinTraits >   _baseClass;
+
+// Data members
+	ATL::CWindow m_wndClient;
+	bool m_bAutoSizeClient;
+	bool m_bDrawEdgeIfEmpty;
+
+// Constructor
+	CScrollContainerImpl() : m_bAutoSizeClient(true), m_bDrawEdgeIfEmpty(false)
+	{
+		// Set CScrollWindowImpl extended style
+		SetScrollExtendedStyle(SCRL_SCROLLCHILDREN);
+	}
+
+// Attributes
+	HWND GetClient() const
+	{
+		return m_wndClient;
+	}
+
+	HWND SetClient(HWND hWndClient, bool bClientSizeAsMin = true)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		HWND hWndOldClient = m_wndClient;
+		m_wndClient = hWndClient;
+
+		SetRedraw(FALSE);
+		SetScrollSize(1, 1, FALSE);
+
+		if(m_wndClient.m_hWnd != NULL)
+		{
+			m_wndClient.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
+
+			if(bClientSizeAsMin)
+			{
+				RECT rect = { 0 };
+				m_wndClient.GetWindowRect(&rect);
+				if((rect.right - rect.left) > 0 && (rect.bottom - rect.top) > 0)
+					SetScrollSize(rect.right - rect.left, rect.bottom - rect.top, FALSE);
+			}
+
+			T* pT = static_cast<T*>(this);
+			pT->UpdateLayout();
+		}
+
+		SetRedraw(TRUE);
+		RedrawWindow(NULL, NULL, RDW_INVALIDATE | RDW_FRAME | RDW_UPDATENOW | RDW_ALLCHILDREN);
+
+		return hWndOldClient;
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CScrollContainerImpl)
+		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		CHAIN_MSG_MAP(_baseClass)
+		FORWARD_NOTIFICATIONS()
+	ALT_MSG_MAP(1)
+		CHAIN_MSG_MAP_ALT(_baseClass, 1)
+	END_MSG_MAP()
+
+	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(m_wndClient.m_hWnd != NULL)
+			m_wndClient.SetFocus();
+
+		return 0;
+	}
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background needed
+	}
+
+	LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		BOOL bTmp = TRUE;
+		LRESULT lRet = _baseClass::OnSize(uMsg, wParam, lParam, bTmp);
+
+		T* pT = static_cast<T*>(this);
+		pT->UpdateLayout();
+
+		return lRet;
+	}
+
+// Overrides for CScrollWindowImpl
+	void DoPaint(CDCHandle dc)
+	{
+		if(!m_bAutoSizeClient || m_wndClient.m_hWnd == NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			RECT rect = { 0 };
+			pT->GetContainerRect(rect);
+
+			if(m_bDrawEdgeIfEmpty && m_wndClient.m_hWnd == NULL)
+				dc.DrawEdge(&rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
+
+			dc.FillRect(&rect, COLOR_APPWORKSPACE);
+		}
+	}
+
+	void ScrollToView(POINT pt)
+	{
+		CScrollWindowImpl< T, TBase, TWinTraits >::ScrollToView(pt);
+	}
+
+	void ScrollToView(RECT& rect)
+	{
+		CScrollWindowImpl< T, TBase, TWinTraits >::ScrollToView(rect);
+	}
+
+	void ScrollToView(HWND hWnd)   // client window coordinates
+	{
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		ATLASSERT(m_wndClient.IsWindow());
+
+		RECT rect = { 0 };
+		::GetWindowRect(hWnd, &rect);
+		::MapWindowPoints(NULL, m_wndClient.m_hWnd, (LPPOINT)&rect, 2);
+		ScrollToView(rect);
+	}
+
+// Implementation - overrideable methods
+	void UpdateLayout()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+
+		if(m_bAutoSizeClient && m_wndClient.m_hWnd != NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			RECT rect = { 0 };
+			pT->GetContainerRect(rect);
+
+			m_wndClient.SetWindowPos(NULL, &rect, SWP_NOZORDER | SWP_NOMOVE);
+		}
+		else
+		{
+			Invalidate();
+		}
+	}
+
+	void GetContainerRect(RECT& rect)
+	{
+		GetClientRect(&rect);
+
+		if(rect.right < m_sizeAll.cx)
+			rect.right = m_sizeAll.cx;
+
+		if(rect.bottom < m_sizeAll.cy)
+			rect.bottom = m_sizeAll.cy;
+	}
+};
+
+class CScrollContainer : public CScrollContainerImpl<CScrollContainer>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_ScrollContainer"), 0, -1)
+};
+
+}; // namespace WTL
+
+#endif // __ATLSCRL_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlsplit.h b/GLideN64/src/GLideNUI-wtl/WTL/atlsplit.h
new file mode 100644
index 00000000..8afffdab
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlsplit.h
@@ -0,0 +1,917 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLSPLIT_H__
+#define __ATLSPLIT_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlsplit.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atlsplit.h requires atlwin.h to be included first
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CSplitterImpl<T, t_bVertical>
+// CSplitterWindowImpl<T, t_bVertical, TBase, TWinTraits>
+// CSplitterWindowT<t_bVertical>
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CSplitterImpl - Provides splitter support to any window
+
+// Splitter panes constants
+#define SPLIT_PANE_LEFT			 0
+#define SPLIT_PANE_RIGHT		 1
+#define SPLIT_PANE_TOP			 SPLIT_PANE_LEFT
+#define SPLIT_PANE_BOTTOM		 SPLIT_PANE_RIGHT
+#define SPLIT_PANE_NONE			-1
+
+// Splitter extended styles
+#define SPLIT_PROPORTIONAL		0x00000001
+#define SPLIT_NONINTERACTIVE		0x00000002
+#define SPLIT_RIGHTALIGNED		0x00000004
+#define SPLIT_BOTTOMALIGNED		SPLIT_RIGHTALIGNED
+#define SPLIT_GRADIENTBAR		0x00000008
+#define SPLIT_FIXEDBARSIZE		0x00000010
+
+// Note: SPLIT_PROPORTIONAL and SPLIT_RIGHTALIGNED/SPLIT_BOTTOMALIGNED are 
+// mutually exclusive. If both are set, splitter defaults to SPLIT_PROPORTIONAL
+
+
+template <class T, bool t_bVertical = true>
+class CSplitterImpl
+{
+public:
+	enum { m_nPanesCount = 2, m_nPropMax = 10000 };
+
+	HWND m_hWndPane[m_nPanesCount];
+	RECT m_rcSplitter;
+	int m_xySplitterPos;
+	int m_nDefActivePane;
+	int m_cxySplitBar;              // splitter bar width/height
+	static HCURSOR m_hCursor;
+	int m_cxyMin;                   // minimum pane size
+	int m_cxyBarEdge;              	// splitter bar edge
+	bool m_bFullDrag;
+	int m_cxyDragOffset;
+	int m_nProportionalPos;
+	bool m_bUpdateProportionalPos;
+	DWORD m_dwExtendedStyle;       // splitter specific extended styles
+	int m_nSinglePane;             // single pane mode
+
+// Constructor
+	CSplitterImpl() :
+			m_xySplitterPos(-1), m_nDefActivePane(SPLIT_PANE_NONE), 
+			m_cxySplitBar(4), m_cxyMin(0), m_cxyBarEdge(0), m_bFullDrag(true), 
+			m_cxyDragOffset(0), m_nProportionalPos(0), m_bUpdateProportionalPos(true),
+			m_dwExtendedStyle(SPLIT_PROPORTIONAL),
+			m_nSinglePane(SPLIT_PANE_NONE)
+	{
+		m_hWndPane[SPLIT_PANE_LEFT] = NULL;
+		m_hWndPane[SPLIT_PANE_RIGHT] = NULL;
+
+		::SetRectEmpty(&m_rcSplitter);
+
+		if(m_hCursor == NULL)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CSplitterImpl::CSplitterImpl.\n"));
+				ATLASSERT(FALSE);
+				return;
+			}
+
+			if(m_hCursor == NULL)
+				m_hCursor = ::LoadCursor(NULL, t_bVertical ? IDC_SIZEWE : IDC_SIZENS);
+
+			lock.Unlock();
+		}
+	}
+
+// Attributes
+	void SetSplitterRect(LPRECT lpRect = NULL, bool bUpdate = true)
+	{
+		if(lpRect == NULL)
+		{
+			T* pT = static_cast<T*>(this);
+			pT->GetClientRect(&m_rcSplitter);
+		}
+		else
+		{
+			m_rcSplitter = *lpRect;
+		}
+
+		if(IsProportional())
+			UpdateProportionalPos();
+		else if(IsRightAligned())
+			UpdateRightAlignPos();
+
+		if(bUpdate)
+			UpdateSplitterLayout();
+	}
+
+	void GetSplitterRect(LPRECT lpRect) const
+	{
+		ATLASSERT(lpRect != NULL);
+		*lpRect = m_rcSplitter;
+	}
+
+	bool SetSplitterPos(int xyPos = -1, bool bUpdate = true)
+	{
+		if(xyPos == -1)   // -1 == middle
+		{
+			if(t_bVertical)
+				xyPos = (m_rcSplitter.right - m_rcSplitter.left - m_cxySplitBar - m_cxyBarEdge) / 2;
+			else
+				xyPos = (m_rcSplitter.bottom - m_rcSplitter.top - m_cxySplitBar - m_cxyBarEdge) / 2;
+		}
+
+		// Adjust if out of valid range
+		int cxyMax = 0;
+		if(t_bVertical)
+			cxyMax = m_rcSplitter.right - m_rcSplitter.left;
+		else
+			cxyMax = m_rcSplitter.bottom - m_rcSplitter.top;
+
+		if(xyPos < m_cxyMin + m_cxyBarEdge)
+			xyPos = m_cxyMin;
+		else if(xyPos > (cxyMax - m_cxySplitBar - m_cxyBarEdge - m_cxyMin))
+			xyPos = cxyMax - m_cxySplitBar - m_cxyBarEdge - m_cxyMin;
+
+		// Set new position and update if requested
+		bool bRet = (m_xySplitterPos != xyPos);
+		m_xySplitterPos = xyPos;
+
+		if(m_bUpdateProportionalPos)
+		{
+			if(IsProportional())
+				StoreProportionalPos();
+			else if(IsRightAligned())
+				StoreRightAlignPos();
+		}
+		else
+		{
+			m_bUpdateProportionalPos = true;
+		}
+
+		if(bUpdate && bRet)
+			UpdateSplitterLayout();
+
+		return bRet;
+	}
+
+	void SetSplitterPosPct(int nPct, bool bUpdate = true)
+	{
+		ATLASSERT(nPct >= 0 && nPct <= 100);
+
+		m_nProportionalPos = ::MulDiv(nPct, m_nPropMax, 100);
+		UpdateProportionalPos();
+
+		if(bUpdate)
+			UpdateSplitterLayout();
+	}
+
+	int GetSplitterPos() const
+	{
+		return m_xySplitterPos;
+	}
+
+	bool SetSinglePaneMode(int nPane = SPLIT_PANE_NONE)
+	{
+		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT || nPane == SPLIT_PANE_NONE);
+		if(!(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT || nPane == SPLIT_PANE_NONE))
+			return false;
+
+		if(nPane != SPLIT_PANE_NONE)
+		{
+			if(!::IsWindowVisible(m_hWndPane[nPane]))
+				::ShowWindow(m_hWndPane[nPane], SW_SHOW);
+			int nOtherPane = (nPane == SPLIT_PANE_LEFT) ? SPLIT_PANE_RIGHT : SPLIT_PANE_LEFT;
+			::ShowWindow(m_hWndPane[nOtherPane], SW_HIDE);
+			if(m_nDefActivePane != nPane)
+				m_nDefActivePane = nPane;
+		}
+		else if(m_nSinglePane != SPLIT_PANE_NONE)
+		{
+			int nOtherPane = (m_nSinglePane == SPLIT_PANE_LEFT) ? SPLIT_PANE_RIGHT : SPLIT_PANE_LEFT;
+			::ShowWindow(m_hWndPane[nOtherPane], SW_SHOW);
+		}
+
+		m_nSinglePane = nPane;
+		UpdateSplitterLayout();
+		return true;
+	}
+
+	int GetSinglePaneMode() const
+	{
+		return m_nSinglePane;
+	}
+
+	DWORD GetSplitterExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+	DWORD SetSplitterExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+#ifdef _DEBUG
+		if(IsProportional() && IsRightAligned())
+			ATLTRACE2(atlTraceUI, 0, _T("CSplitterImpl::SetSplitterExtendedStyle - SPLIT_PROPORTIONAL and SPLIT_RIGHTALIGNED are mutually exclusive, defaulting to SPLIT_PROPORTIONAL.\n"));
+#endif // _DEBUG
+		return dwPrevStyle;
+	}
+
+// Splitter operations
+	void SetSplitterPanes(HWND hWndLeftTop, HWND hWndRightBottom, bool bUpdate = true)
+	{
+		m_hWndPane[SPLIT_PANE_LEFT] = hWndLeftTop;
+		m_hWndPane[SPLIT_PANE_RIGHT] = hWndRightBottom;
+		ATLASSERT(m_hWndPane[SPLIT_PANE_LEFT] == NULL || m_hWndPane[SPLIT_PANE_RIGHT] == NULL || m_hWndPane[SPLIT_PANE_LEFT] != m_hWndPane[SPLIT_PANE_RIGHT]);
+		if(bUpdate)
+			UpdateSplitterLayout();
+	}
+
+	bool SetSplitterPane(int nPane, HWND hWnd, bool bUpdate = true)
+	{
+		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
+
+		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
+			return false;
+		m_hWndPane[nPane] = hWnd;
+		ATLASSERT(m_hWndPane[SPLIT_PANE_LEFT] == NULL || m_hWndPane[SPLIT_PANE_RIGHT] == NULL || m_hWndPane[SPLIT_PANE_LEFT] != m_hWndPane[SPLIT_PANE_RIGHT]);
+		if(bUpdate)
+			UpdateSplitterLayout();
+		return true;
+	}
+
+	HWND GetSplitterPane(int nPane) const
+	{
+		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
+
+		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
+			return false;
+		return m_hWndPane[nPane];
+	}
+
+	bool SetActivePane(int nPane)
+	{
+		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
+
+		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
+			return false;
+		if(m_nSinglePane != SPLIT_PANE_NONE && nPane != m_nSinglePane)
+			return false;
+		::SetFocus(m_hWndPane[nPane]);
+		m_nDefActivePane = nPane;
+		return true;
+	}
+
+	int GetActivePane() const
+	{
+		int nRet = SPLIT_PANE_NONE;
+		HWND hWndFocus = ::GetFocus();
+		if(hWndFocus != NULL)
+		{
+			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
+			{
+				if(hWndFocus == m_hWndPane[nPane] || ::IsChild(m_hWndPane[nPane], hWndFocus))
+				{
+					nRet = nPane;
+					break;
+				}
+			}
+		}
+		return nRet;
+	}
+
+	bool ActivateNextPane(bool bNext = true)
+	{
+		int nPane = m_nSinglePane;
+		if(nPane == SPLIT_PANE_NONE)
+		{
+			switch(GetActivePane())
+			{
+			case SPLIT_PANE_LEFT:
+				nPane = SPLIT_PANE_RIGHT;
+				break;
+			case SPLIT_PANE_RIGHT:
+				nPane = SPLIT_PANE_LEFT;
+				break;
+			default:
+				nPane = bNext ? SPLIT_PANE_LEFT : SPLIT_PANE_RIGHT;
+				break;
+			}
+		}
+		return SetActivePane(nPane);
+	}
+
+	bool SetDefaultActivePane(int nPane)
+	{
+		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
+
+		if(nPane != SPLIT_PANE_LEFT && nPane != SPLIT_PANE_RIGHT)
+			return false;
+		m_nDefActivePane = nPane;
+		return true;
+	}
+
+	bool SetDefaultActivePane(HWND hWnd)
+	{
+		for(int nPane = 0; nPane < m_nPanesCount; nPane++)
+		{
+			if(hWnd == m_hWndPane[nPane])
+			{
+				m_nDefActivePane = nPane;
+				return true;
+			}
+		}
+		return false;   // not found
+	}
+
+	int GetDefaultActivePane() const
+	{
+		return m_nDefActivePane;
+	}
+
+	void DrawSplitter(CDCHandle dc)
+	{
+		ATLASSERT(dc.m_hDC != NULL);
+		if(m_nSinglePane == SPLIT_PANE_NONE && m_xySplitterPos == -1)
+			return;
+
+		T* pT = static_cast<T*>(this);
+		if(m_nSinglePane == SPLIT_PANE_NONE)
+		{
+			pT->DrawSplitterBar(dc);
+
+			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
+			{
+				if(m_hWndPane[nPane] == NULL)
+					pT->DrawSplitterPane(dc, nPane);
+			}
+		}
+		else
+		{
+			if(m_hWndPane[m_nSinglePane] == NULL)
+				pT->DrawSplitterPane(dc, m_nSinglePane);
+		}
+	}
+
+// Overrideables
+	void DrawSplitterBar(CDCHandle dc)
+	{
+		RECT rect = { 0 };
+		if(GetSplitterBarRect(&rect))
+		{
+			dc.FillRect(&rect, COLOR_3DFACE);
+
+#if (!defined(_WIN32_WCE) || (_WIN32_WCE >= 420))
+			if((m_dwExtendedStyle & SPLIT_GRADIENTBAR) != 0)
+			{
+				RECT rect2 = rect;
+				if(t_bVertical)
+					rect2.left = (rect.left + rect.right) / 2 - 1;
+				else
+					rect2.top = (rect.top + rect.bottom) / 2 - 1;
+
+				dc.GradientFillRect(rect2, ::GetSysColor(COLOR_3DFACE), ::GetSysColor(COLOR_3DSHADOW), t_bVertical);
+			}
+#endif // !defined(_WIN32_WCE) || (_WIN32_WCE >= 420)
+
+			// draw 3D edge if needed
+			T* pT = static_cast<T*>(this);
+			if((pT->GetExStyle() & WS_EX_CLIENTEDGE) != 0)
+				dc.DrawEdge(&rect, EDGE_RAISED, t_bVertical ? (BF_LEFT | BF_RIGHT) : (BF_TOP | BF_BOTTOM));
+		}
+	}
+
+	// called only if pane is empty
+	void DrawSplitterPane(CDCHandle dc, int nPane)
+	{
+		RECT rect = { 0 };
+		if(GetSplitterPaneRect(nPane, &rect))
+		{
+			T* pT = static_cast<T*>(this);
+			if((pT->GetExStyle() & WS_EX_CLIENTEDGE) == 0)
+				dc.DrawEdge(&rect, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
+			dc.FillRect(&rect, COLOR_APPWORKSPACE);
+		}
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CSplitterImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+#endif // !_WIN32_WCE
+		if(IsInteractive())
+		{
+			MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
+			MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
+			MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
+			MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
+			MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDoubleClick)
+			MESSAGE_HANDLER(WM_CAPTURECHANGED, OnCaptureChanged)
+		}
+		MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
+#ifndef _WIN32_WCE
+		MESSAGE_HANDLER(WM_MOUSEACTIVATE, OnMouseActivate)
+#endif // !_WIN32_WCE
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->GetSystemSettings(false);
+
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		// try setting position if not set
+		if(m_nSinglePane == SPLIT_PANE_NONE && m_xySplitterPos == -1)
+			pT->SetSplitterPos();
+		// do painting
+		CPaintDC dc(pT->m_hWnd);
+		pT->DrawSplitter(dc.m_hDC);
+		return 0;
+	}
+
+	LRESULT OnSetCursor(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		if((HWND)wParam == pT->m_hWnd && LOWORD(lParam) == HTCLIENT)
+		{
+			DWORD dwPos = ::GetMessagePos();
+			POINT ptPos = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
+			pT->ScreenToClient(&ptPos);
+			if(IsOverSplitterBar(ptPos.x, ptPos.y))
+				return 1;
+		}
+
+		bHandled = FALSE;
+		return 0;
+	}
+
+	LRESULT OnMouseMove(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		int xPos = GET_X_LPARAM(lParam);
+		int yPos = GET_Y_LPARAM(lParam);
+		if((wParam & MK_LBUTTON) && ::GetCapture() == pT->m_hWnd)
+		{
+			int xyNewSplitPos = 0;
+			if(t_bVertical)
+				xyNewSplitPos = xPos - m_rcSplitter.left - m_cxyDragOffset;
+			else
+				xyNewSplitPos = yPos - m_rcSplitter.top - m_cxyDragOffset;
+
+			if(xyNewSplitPos == -1)   // avoid -1, that means middle
+				xyNewSplitPos = -2;
+
+			if(m_xySplitterPos != xyNewSplitPos)
+			{
+				if(m_bFullDrag)
+				{
+					if(pT->SetSplitterPos(xyNewSplitPos, true))
+						pT->UpdateWindow();
+				}
+				else
+				{
+					DrawGhostBar();
+					pT->SetSplitterPos(xyNewSplitPos, false);
+					DrawGhostBar();
+				}
+			}
+		}
+		else		// not dragging, just set cursor
+		{
+			if(IsOverSplitterBar(xPos, yPos))
+				::SetCursor(m_hCursor);
+			bHandled = FALSE;
+		}
+
+		return 0;
+	}
+
+	LRESULT OnLButtonDown(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
+	{
+		int xPos = GET_X_LPARAM(lParam);
+		int yPos = GET_Y_LPARAM(lParam);
+		if(IsOverSplitterBar(xPos, yPos))
+		{
+			T* pT = static_cast<T*>(this);
+			pT->SetCapture();
+			::SetCursor(m_hCursor);
+			if(!m_bFullDrag)
+				DrawGhostBar();
+			if(t_bVertical)
+				m_cxyDragOffset = xPos - m_rcSplitter.left - m_xySplitterPos;
+			else
+				m_cxyDragOffset = yPos - m_rcSplitter.top - m_xySplitterPos;
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnLButtonUp(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		::ReleaseCapture();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnLButtonDoubleClick(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetSplitterPos();   // middle
+		return 0;
+	}
+
+	LRESULT OnCaptureChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		if(!m_bFullDrag)
+		{
+			DrawGhostBar();
+			UpdateSplitterLayout();
+			T* pT = static_cast<T*>(this);
+			pT->UpdateWindow();
+		}
+		return 0;
+	}
+
+	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM, BOOL& bHandled)
+	{
+		if(m_nSinglePane == SPLIT_PANE_NONE)
+		{
+			if(m_nDefActivePane == SPLIT_PANE_LEFT || m_nDefActivePane == SPLIT_PANE_RIGHT)
+				::SetFocus(m_hWndPane[m_nDefActivePane]);
+		}
+		else
+		{
+			::SetFocus(m_hWndPane[m_nSinglePane]);
+		}
+		bHandled = FALSE;
+		return 1;
+	}
+
+#ifndef _WIN32_WCE
+	LRESULT OnMouseActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		LRESULT lRet = pT->DefWindowProc(uMsg, wParam, lParam);
+		if(lRet == MA_ACTIVATE || lRet == MA_ACTIVATEANDEAT)
+		{
+			DWORD dwPos = ::GetMessagePos();
+			POINT pt = { GET_X_LPARAM(dwPos), GET_Y_LPARAM(dwPos) };
+			pT->ScreenToClient(&pt);
+			RECT rcPane = { 0 };
+			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
+			{
+				if(GetSplitterPaneRect(nPane, &rcPane) && ::PtInRect(&rcPane, pt))
+				{
+					m_nDefActivePane = nPane;
+					break;
+				}
+			}
+		}
+		return lRet;
+	}
+#endif // !_WIN32_WCE
+
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->GetSystemSettings(true);
+
+		return 0;
+	}
+
+// Implementation - internal helpers
+	void UpdateSplitterLayout()
+	{
+		if(m_nSinglePane == SPLIT_PANE_NONE && m_xySplitterPos == -1)
+			return;
+
+		T* pT = static_cast<T*>(this);
+		RECT rect = { 0 };
+		if(m_nSinglePane == SPLIT_PANE_NONE)
+		{
+			if(GetSplitterBarRect(&rect))
+				pT->InvalidateRect(&rect);
+
+			for(int nPane = 0; nPane < m_nPanesCount; nPane++)
+			{
+				if(GetSplitterPaneRect(nPane, &rect))
+				{
+					if(m_hWndPane[nPane] != NULL)
+						::SetWindowPos(m_hWndPane[nPane], NULL, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER);
+					else
+						pT->InvalidateRect(&rect);
+				}
+			}
+		}
+		else
+		{
+			if(GetSplitterPaneRect(m_nSinglePane, &rect))
+			{
+				if(m_hWndPane[m_nSinglePane] != NULL)
+					::SetWindowPos(m_hWndPane[m_nSinglePane], NULL, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, SWP_NOZORDER);
+				else
+					pT->InvalidateRect(&rect);
+			}
+		}
+	}
+
+	bool GetSplitterBarRect(LPRECT lpRect) const
+	{
+		ATLASSERT(lpRect != NULL);
+		if(m_nSinglePane != SPLIT_PANE_NONE || m_xySplitterPos == -1)
+			return false;
+
+		if(t_bVertical)
+		{
+			lpRect->left = m_rcSplitter.left + m_xySplitterPos;
+			lpRect->top = m_rcSplitter.top;
+			lpRect->right = m_rcSplitter.left + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
+			lpRect->bottom = m_rcSplitter.bottom;
+		}
+		else
+		{
+			lpRect->left = m_rcSplitter.left;
+			lpRect->top = m_rcSplitter.top + m_xySplitterPos;
+			lpRect->right = m_rcSplitter.right;
+			lpRect->bottom = m_rcSplitter.top + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
+		}
+
+		return true;
+	}
+
+	bool GetSplitterPaneRect(int nPane, LPRECT lpRect) const
+	{
+		ATLASSERT(nPane == SPLIT_PANE_LEFT || nPane == SPLIT_PANE_RIGHT);
+		ATLASSERT(lpRect != NULL);
+		bool bRet = true;
+		if(m_nSinglePane != SPLIT_PANE_NONE)
+		{
+			if(nPane == m_nSinglePane)
+				*lpRect = m_rcSplitter;
+			else
+				bRet = false;
+		}
+		else if(nPane == SPLIT_PANE_LEFT)
+		{
+			if(t_bVertical)
+			{
+				lpRect->left = m_rcSplitter.left;
+				lpRect->top = m_rcSplitter.top;
+				lpRect->right = m_rcSplitter.left + m_xySplitterPos;
+				lpRect->bottom = m_rcSplitter.bottom;
+			}
+			else
+			{
+				lpRect->left = m_rcSplitter.left;
+				lpRect->top = m_rcSplitter.top;
+				lpRect->right = m_rcSplitter.right;
+				lpRect->bottom = m_rcSplitter.top + m_xySplitterPos;
+			}
+		}
+		else if(nPane == SPLIT_PANE_RIGHT)
+		{
+			if(t_bVertical)
+			{
+				lpRect->left = m_rcSplitter.left + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
+				lpRect->top = m_rcSplitter.top;
+				lpRect->right = m_rcSplitter.right;
+				lpRect->bottom = m_rcSplitter.bottom;
+			}
+			else
+			{
+				lpRect->left = m_rcSplitter.left;
+				lpRect->top = m_rcSplitter.top + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge;
+				lpRect->right = m_rcSplitter.right;
+				lpRect->bottom = m_rcSplitter.bottom;
+			}
+		}
+		else
+		{
+			bRet = false;
+		}
+		return bRet;
+	}
+
+	bool IsOverSplitterRect(int x, int y) const
+	{
+		// -1 == don't check
+		return ((x == -1 || (x >= m_rcSplitter.left && x <= m_rcSplitter.right)) &&
+			(y == -1 || (y >= m_rcSplitter.top && y <= m_rcSplitter.bottom)));
+	}
+
+	bool IsOverSplitterBar(int x, int y) const
+	{
+		if(m_nSinglePane != SPLIT_PANE_NONE)
+			return false;
+		if(m_xySplitterPos == -1 || !IsOverSplitterRect(x, y))
+			return false;
+		int xy = t_bVertical ? x : y;
+		int xyOff = t_bVertical ? m_rcSplitter.left : m_rcSplitter.top;
+		return ((xy >= (xyOff + m_xySplitterPos)) && (xy < xyOff + m_xySplitterPos + m_cxySplitBar + m_cxyBarEdge));
+	}
+
+	void DrawGhostBar()
+	{
+		RECT rect = { 0 };
+		if(GetSplitterBarRect(&rect))
+		{
+			// convert client to window coordinates
+			T* pT = static_cast<T*>(this);
+			RECT rcWnd = { 0 };
+			pT->GetWindowRect(&rcWnd);
+			::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rcWnd, 2);
+			::OffsetRect(&rect, -rcWnd.left, -rcWnd.top);
+
+			// invert the brush pattern (looks just like frame window sizing)
+			CWindowDC dc(pT->m_hWnd);
+			CBrush brush = CDCHandle::GetHalftoneBrush();
+			if(brush.m_hBrush != NULL)
+			{
+				CBrushHandle brushOld = dc.SelectBrush(brush);
+				dc.PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
+				dc.SelectBrush(brushOld);
+			}
+		}
+	}
+
+	void GetSystemSettings(bool bUpdate)
+	{
+		if((m_dwExtendedStyle & SPLIT_FIXEDBARSIZE) == 0)
+		{
+#ifndef _WIN32_WCE
+			m_cxySplitBar = ::GetSystemMetrics(t_bVertical ? SM_CXSIZEFRAME : SM_CYSIZEFRAME);
+#else // CE specific
+			m_cxySplitBar = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
+#endif // _WIN32_WCE
+		}
+
+		T* pT = static_cast<T*>(this);
+		if((pT->GetExStyle() & WS_EX_CLIENTEDGE))
+		{
+			m_cxyBarEdge = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
+			m_cxyMin = 0;
+		}
+		else
+		{
+			m_cxyBarEdge = 0;
+			m_cxyMin = 2 * ::GetSystemMetrics(t_bVertical ? SM_CXEDGE : SM_CYEDGE);
+		}
+
+#ifndef _WIN32_WCE
+		::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &m_bFullDrag, 0);
+#endif // !_WIN32_WCE
+
+		if(bUpdate)
+			UpdateSplitterLayout();
+	}
+
+	bool IsProportional() const
+	{
+		return ((m_dwExtendedStyle & SPLIT_PROPORTIONAL) != 0);
+	}
+
+	void StoreProportionalPos()
+	{
+		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left - m_cxySplitBar - m_cxyBarEdge) : (m_rcSplitter.bottom - m_rcSplitter.top - m_cxySplitBar - m_cxyBarEdge);
+		if(cxyTotal > 0)
+			m_nProportionalPos = ::MulDiv(m_xySplitterPos, m_nPropMax, cxyTotal);
+		else
+			m_nProportionalPos = 0;
+		ATLTRACE2(atlTraceUI, 0, _T("CSplitterImpl::StoreProportionalPos - %i\n"), m_nProportionalPos);
+	}
+
+	void UpdateProportionalPos()
+	{
+		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left - m_cxySplitBar - m_cxyBarEdge) : (m_rcSplitter.bottom - m_rcSplitter.top - m_cxySplitBar - m_cxyBarEdge);
+		if(cxyTotal > 0)
+		{
+			int xyNewPos = ::MulDiv(m_nProportionalPos, cxyTotal, m_nPropMax);
+			m_bUpdateProportionalPos = false;
+			T* pT = static_cast<T*>(this);
+			pT->SetSplitterPos(xyNewPos, false);
+		}
+	}
+
+	bool IsRightAligned() const
+	{
+		return ((m_dwExtendedStyle & SPLIT_RIGHTALIGNED) != 0);
+	}
+
+	void StoreRightAlignPos()
+	{
+		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left - m_cxySplitBar - m_cxyBarEdge) : (m_rcSplitter.bottom - m_rcSplitter.top - m_cxySplitBar - m_cxyBarEdge);
+		if(cxyTotal > 0)
+			m_nProportionalPos = cxyTotal - m_xySplitterPos;
+		else
+			m_nProportionalPos = 0;
+		ATLTRACE2(atlTraceUI, 0, _T("CSplitterImpl::StoreRightAlignPos - %i\n"), m_nProportionalPos);
+	}
+
+	void UpdateRightAlignPos()
+	{
+		int cxyTotal = t_bVertical ? (m_rcSplitter.right - m_rcSplitter.left - m_cxySplitBar - m_cxyBarEdge) : (m_rcSplitter.bottom - m_rcSplitter.top - m_cxySplitBar - m_cxyBarEdge);
+		if(cxyTotal > 0)
+		{
+			m_bUpdateProportionalPos = false;
+			T* pT = static_cast<T*>(this);
+			pT->SetSplitterPos(cxyTotal - m_nProportionalPos, false);
+		}
+	}
+
+	bool IsInteractive() const
+	{
+		return ((m_dwExtendedStyle & SPLIT_NONINTERACTIVE) == 0);
+	}
+};
+
+template <class T, bool t_bVertical> HCURSOR CSplitterImpl< T, t_bVertical>::m_hCursor = NULL;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CSplitterWindowImpl - Implements a splitter window
+
+template <class T, bool t_bVertical = true, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CSplitterWindowImpl : public ATL::CWindowImpl< T, TBase, TWinTraits >, public CSplitterImpl< T , t_bVertical >
+{
+public:
+	DECLARE_WND_CLASS_EX(NULL, CS_DBLCLKS, COLOR_WINDOW)
+
+	typedef CSplitterImpl< T , t_bVertical >   _baseClass;
+
+	BEGIN_MSG_MAP(CSplitterWindowImpl)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_SIZE, OnSize)
+		CHAIN_MSG_MAP(_baseClass)
+		FORWARD_NOTIFICATIONS()
+	END_MSG_MAP()
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		// handled, no background painting needed
+		return 1;
+	}
+
+	LRESULT OnSize(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(wParam != SIZE_MINIMIZED)
+			SetSplitterRect();
+
+		bHandled = FALSE;
+		return 1;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CSplitterWindow - Implements a splitter window to be used as is
+
+template <bool t_bVertical = true>
+class CSplitterWindowT : public CSplitterWindowImpl<CSplitterWindowT<t_bVertical>, t_bVertical>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_SplitterWindow"), CS_DBLCLKS, COLOR_WINDOW)
+};
+
+typedef CSplitterWindowT<true>    CSplitterWindow;
+typedef CSplitterWindowT<false>   CHorSplitterWindow;
+
+}; // namespace WTL
+
+#endif // __ATLSPLIT_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atltheme.h b/GLideN64/src/GLideNUI-wtl/WTL/atltheme.h
new file mode 100644
index 00000000..a5168b91
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atltheme.h
@@ -0,0 +1,1218 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLTHEME_H__
+#define __ATLTHEME_H__
+
+#pragma once
+
+#ifdef _WIN32_WCE
+	#error atltheme.h is not supported on Windows CE
+#endif
+
+#ifndef __ATLAPP_H__
+	#error atltheme.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atltheme.h requires atlwin.h to be included first
+#endif
+
+#if (_WIN32_WINNT < 0x0501)
+	#error atltheme.h requires _WIN32_WINNT >= 0x0501
+#endif // (_WIN32_WINNT < 0x0501)
+
+#if defined(_WTL_USE_VSSYM32) || (defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN))
+  #include <vssym32.h>
+#else
+  #ifndef TMSCHEMA_H
+  #include <tmschema.h>
+  #endif
+#endif
+
+#ifndef _UXTHEME_H_
+#include <uxtheme.h>
+#endif
+#pragma comment(lib, "uxtheme.lib")
+
+// Note: To create an application that also runs on older versions of Windows,
+// use delay load of uxtheme.dll and ensure that no calls to the Theme API are
+// made if theming is not supported. It is enough to check if m_hTheme is NULL.
+// Example:
+//	if(m_hTheme != NULL)
+//	{
+//		DrawThemeBackground(dc, BP_PUSHBUTTON, PBS_NORMAL, &rect, NULL);
+//		DrawThemeText(dc, BP_PUSHBUTTON, PBS_NORMAL, L"Button", -1, DT_SINGLELINE | DT_CENTER | DT_VCENTER, 0, &rect);
+//	}
+//	else
+//	{
+//		dc.DrawFrameControl(&rect, DFC_BUTTON, DFCS_BUTTONPUSH);
+//		dc.DrawText(_T("Button"), -1, &rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);
+//	}
+//
+// Delay load is NOT AUTOMATIC for VC++ 7, you have to link to delayimp.lib, 
+// and add uxtheme.dll in the Linker.Input.Delay Loaded DLLs section of the 
+// project properties.
+#if (_MSC_VER < 1300) && !defined(_WTL_NO_THEME_DELAYLOAD)
+  #pragma comment(lib, "delayimp.lib")
+  #pragma comment(linker, "/delayload:uxtheme.dll")
+#endif // (_MSC_VER < 1300) && !defined(_WTL_NO_THEME_DELAYLOAD)
+
+// Hack: Signatures in uxtheme.h changed - the only way to check which variant of uxtheme.h
+// is included is to check for presence of new defines MAX_THEMECOLOR and MAX_THEMESIZE
+#ifndef _WTL_NEW_UXTHEME
+  #if defined(MAX_THEMECOLOR) && defined(MAX_THEMESIZE)
+    #define _WTL_NEW_UXTHEME
+  #endif // defined(MAX_THEMECOLOR) && defined(MAX_THEMESIZE)
+#endif // _WTL_NEW_UXTHEME
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CTheme
+// CThemeImpl<T, TBase>
+//
+// CBufferedPaint
+// CBufferedPaintImpl<T>
+// CBufferedPaintWindowImpl<T, TBase, TWinTraits>
+// CBufferedAnimation
+// CBufferedAnimationImpl<T, TState>
+// CBufferedAnimationWindowImpl<T, TState, TBase, TWinTraits>
+//
+// Global functions:
+//   AtlDrawThemeClientEdge()
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// CTheme - wrapper for theme handle
+
+class CTheme
+{
+public:
+// Data members
+	HTHEME m_hTheme;
+	static int m_nIsThemingSupported;
+
+// Constructor
+	CTheme(HTHEME hTheme = NULL) : m_hTheme(hTheme)
+	{
+		IsThemingSupported();
+	}
+
+// Operators and helpers
+	bool IsThemeNull() const
+	{
+		return (m_hTheme == NULL);
+	}
+
+	CTheme& operator =(HTHEME hTheme)
+	{
+		m_hTheme = hTheme;
+		return *this;
+	}
+
+	operator HTHEME() const
+	{
+		return m_hTheme;
+	}
+
+	void Attach(HTHEME hTheme)
+	{
+		m_hTheme = hTheme;
+	}
+
+	HTHEME Detach()
+	{
+		HTHEME hTheme = m_hTheme;
+		m_hTheme = NULL;
+		return hTheme;
+	}
+
+// Theme support helper
+	static bool IsThemingSupported()
+	{
+		if(m_nIsThemingSupported == -1)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CTheme::IsThemingSupported.\n"));
+				ATLASSERT(FALSE);
+				return false;
+			}
+
+			if(m_nIsThemingSupported == -1)
+			{
+				HMODULE hThemeDLL = ::LoadLibrary(_T("uxtheme.dll"));
+				m_nIsThemingSupported = (hThemeDLL != NULL) ? 1 : 0;
+				if(hThemeDLL != NULL)
+					::FreeLibrary(hThemeDLL);
+			}
+
+			lock.Unlock();
+		}
+
+		ATLASSERT(m_nIsThemingSupported != -1);
+		return (m_nIsThemingSupported == 1);
+	}
+
+// Operations and theme properties
+	HTHEME OpenThemeData(HWND hWnd, LPCWSTR pszClassList)
+	{
+		if(!IsThemingSupported())
+			return NULL;
+
+		ATLASSERT(m_hTheme == NULL);
+		m_hTheme = ::OpenThemeData(hWnd, pszClassList);
+		return m_hTheme;
+	}
+
+	HRESULT CloseThemeData()
+	{
+		HRESULT hRet = S_FALSE;
+		if(m_hTheme != NULL)
+		{
+			hRet = ::CloseThemeData(m_hTheme);
+			if(SUCCEEDED(hRet))
+				m_hTheme = NULL;
+		}
+		return hRet;
+	}
+
+	HRESULT DrawThemeBackground(HDC hDC, int nPartID, int nStateID, LPCRECT pRect, LPCRECT pClipRect = NULL)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::DrawThemeBackground(m_hTheme, hDC, nPartID, nStateID, pRect, pClipRect);
+	}
+
+	HRESULT DrawThemeBackgroundEx(HDC hDC, int nPartID, int nStateID, LPCRECT pRect, const DTBGOPTS* pOptions = NULL)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::DrawThemeBackgroundEx(m_hTheme, hDC, nPartID, nStateID, pRect, pOptions);
+	}
+
+	HRESULT DrawThemeText(HDC hDC, int nPartID, int nStateID, LPCWSTR pszText, int nCharCount, DWORD dwTextFlags, DWORD dwTextFlags2, LPCRECT pRect)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::DrawThemeText(m_hTheme, hDC, nPartID, nStateID, pszText, nCharCount, dwTextFlags, dwTextFlags2, pRect);
+	}
+
+	HRESULT GetThemeBackgroundContentRect(HDC hDC, int nPartID, int nStateID,  LPCRECT pBoundingRect, LPRECT pContentRect) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeBackgroundContentRect(m_hTheme, hDC, nPartID, nStateID,  pBoundingRect, pContentRect);
+	}
+
+	HRESULT GetThemeBackgroundExtent(HDC hDC, int nPartID, int nStateID, LPCRECT pContentRect, LPRECT pExtentRect) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeBackgroundExtent(m_hTheme, hDC, nPartID, nStateID, pContentRect, pExtentRect);
+	}
+
+	HRESULT GetThemePartSize(HDC hDC, int nPartID, int nStateID, LPRECT pRect, enum THEMESIZE eSize, LPSIZE pSize) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemePartSize(m_hTheme, hDC, nPartID, nStateID, pRect, eSize, pSize);
+	}
+
+	HRESULT GetThemeTextExtent(HDC hDC, int nPartID, int nStateID, LPCWSTR pszText, int nCharCount, DWORD dwTextFlags, LPCRECT  pBoundingRect, LPRECT pExtentRect) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeTextExtent(m_hTheme, hDC, nPartID, nStateID, pszText, nCharCount, dwTextFlags, pBoundingRect, pExtentRect);
+	}
+
+	HRESULT GetThemeTextMetrics(HDC hDC, int nPartID, int nStateID, PTEXTMETRICW pTextMetric) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+#ifdef _WTL_NEW_UXTHEME
+		return ::GetThemeTextMetrics(m_hTheme, hDC, nPartID, nStateID, pTextMetric);
+#else // !_WTL_NEW_UXTHEME
+		// Note: The cast to PTEXTMETRIC is because uxtheme.h incorrectly uses it instead of PTEXTMETRICW
+		return ::GetThemeTextMetrics(m_hTheme, hDC, nPartID, nStateID, (PTEXTMETRIC)pTextMetric);
+#endif // !_WTL_NEW_UXTHEME
+	}
+
+	HRESULT GetThemeBackgroundRegion(HDC hDC, int nPartID, int nStateID, LPCRECT pRect, HRGN* pRegion) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeBackgroundRegion(m_hTheme, hDC, nPartID, nStateID, pRect, pRegion);
+	}
+
+	HRESULT HitTestThemeBackground(HDC hDC, int nPartID, int nStateID, DWORD dwOptions, LPCRECT pRect, HRGN hrgn, POINT ptTest, WORD* pwHitTestCode) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::HitTestThemeBackground(m_hTheme, hDC, nPartID, nStateID, dwOptions, pRect, hrgn, ptTest, pwHitTestCode);
+	}
+
+	HRESULT DrawThemeEdge(HDC hDC, int nPartID, int nStateID, LPCRECT pDestRect, UINT uEdge, UINT uFlags, LPRECT pContentRect = NULL)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::DrawThemeEdge(m_hTheme, hDC, nPartID, nStateID, pDestRect, uEdge, uFlags, pContentRect);
+	}
+
+	HRESULT DrawThemeIcon(HDC hDC, int nPartID, int nStateID, LPCRECT pRect, HIMAGELIST himl, int nImageIndex)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::DrawThemeIcon(m_hTheme, hDC, nPartID, nStateID, pRect, himl, nImageIndex);
+	}
+
+	BOOL IsThemePartDefined(int nPartID, int nStateID) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::IsThemePartDefined(m_hTheme, nPartID, nStateID);
+	}
+
+	BOOL IsThemeBackgroundPartiallyTransparent(int nPartID, int nStateID) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::IsThemeBackgroundPartiallyTransparent(m_hTheme, nPartID, nStateID);
+	}
+
+	HRESULT GetThemeColor(int nPartID, int nStateID, int nPropID, COLORREF* pColor) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeColor(m_hTheme, nPartID, nStateID, nPropID, pColor);
+	}
+
+	HRESULT GetThemeMetric(HDC hDC, int nPartID, int nStateID, int nPropID, int* pnVal) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeMetric(m_hTheme, hDC, nPartID, nStateID, nPropID, pnVal);
+	}
+
+	HRESULT GetThemeString(int nPartID, int nStateID, int nPropID, LPWSTR pszBuff, int cchMaxBuffChars) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeString(m_hTheme, nPartID, nStateID, nPropID, pszBuff, cchMaxBuffChars);
+	}
+
+	HRESULT GetThemeBool(int nPartID, int nStateID, int nPropID, BOOL* pfVal) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeBool(m_hTheme, nPartID, nStateID, nPropID, pfVal);
+	}
+
+	HRESULT GetThemeInt(int nPartID, int nStateID, int nPropID, int* pnVal) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeInt(m_hTheme, nPartID, nStateID, nPropID, pnVal);
+	}
+
+	HRESULT GetThemeEnumValue(int nPartID, int nStateID, int nPropID, int* pnVal) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeEnumValue(m_hTheme, nPartID, nStateID, nPropID, pnVal);
+	}
+
+	HRESULT GetThemePosition(int nPartID, int nStateID, int nPropID, LPPOINT pPoint) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemePosition(m_hTheme, nPartID, nStateID, nPropID, pPoint);
+	}
+
+	// deprecated
+	HRESULT GetThemeFont(int nPartID, HDC hDC, int nStateID, int nPropID, LOGFONTW* pFont) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+#ifdef _WTL_NEW_UXTHEME
+		return ::GetThemeFont(m_hTheme, hDC, nPartID, nStateID, nPropID, pFont);
+#else // !_WTL_NEW_UXTHEME
+		// Note: The cast to LOGFONT* is because uxtheme.h incorrectly uses it instead of LOGFONTW*
+		return ::GetThemeFont(m_hTheme, hDC, nPartID, nStateID, nPropID, (LOGFONT*)pFont);
+#endif // !_WTL_NEW_UXTHEME
+	}
+
+	HRESULT GetThemeFont(HDC hDC, int nPartID, int nStateID, int nPropID, LOGFONTW* pFont) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+#ifdef _WTL_NEW_UXTHEME
+		return ::GetThemeFont(m_hTheme, hDC, nPartID, nStateID, nPropID, pFont);
+#else // !_WTL_NEW_UXTHEME
+		// Note: The cast to LOGFONT* is because uxtheme.h incorrectly uses it instead of LOGFONTW*
+		return ::GetThemeFont(m_hTheme, hDC, nPartID, nStateID, nPropID, (LOGFONT*)pFont);
+#endif // !_WTL_NEW_UXTHEME
+	}
+
+	HRESULT GetThemeRect(int nPartID, int nStateID, int nPropID, LPRECT pRect) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeRect(m_hTheme, nPartID, nStateID, nPropID, pRect);
+	}
+
+	HRESULT GetThemeMargins(HDC hDC, int nPartID, int nStateID, int nPropID, LPRECT pRect, PMARGINS pMargins) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeMargins(m_hTheme, hDC, nPartID, nStateID, nPropID, pRect, pMargins);
+	}
+
+	HRESULT GetThemeIntList(int nPartID, int nStateID, int nPropID, INTLIST* pIntList) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeIntList(m_hTheme, nPartID, nStateID, nPropID, pIntList);
+	}
+
+	HRESULT GetThemePropertyOrigin(int nPartID, int nStateID, int nPropID, enum PROPERTYORIGIN* pOrigin) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemePropertyOrigin(m_hTheme, nPartID, nStateID, nPropID, pOrigin);
+	}
+
+	HRESULT GetThemeFilename(int nPartID, int nStateID, int nPropID, LPWSTR pszThemeFileName, int cchMaxBuffChars) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeFilename(m_hTheme, nPartID, nStateID, nPropID, pszThemeFileName, cchMaxBuffChars);
+	}
+
+	COLORREF GetThemeSysColor(int nColorID) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeSysColor(m_hTheme, nColorID);
+	}
+
+	HBRUSH GetThemeSysColorBrush(int nColorID) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeSysColorBrush(m_hTheme, nColorID);
+	}
+
+	int GetThemeSysSize(int nSizeID) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeSysSize(m_hTheme, nSizeID);
+	}
+
+	BOOL GetThemeSysBool(int nBoolID) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeSysBool(m_hTheme, nBoolID);
+	}
+
+	HRESULT GetThemeSysFont(int nFontID, LOGFONTW* plf) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+#ifdef _WTL_NEW_UXTHEME
+		return ::GetThemeSysFont(m_hTheme, nFontID, plf);
+#else // !_WTL_NEW_UXTHEME
+		// Note: The cast to LOGFONT* is because uxtheme.h incorrectly uses it instead of LOGFONTW*
+		return ::GetThemeSysFont(m_hTheme, nFontID, (LOGFONT*)plf);
+#endif // !_WTL_NEW_UXTHEME
+	}
+
+	HRESULT GetThemeSysString(int nStringID, LPWSTR pszStringBuff, int cchMaxStringChars) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeSysString(m_hTheme, nStringID, pszStringBuff, cchMaxStringChars);
+	}
+
+	HRESULT GetThemeSysInt(int nIntID, int* pnValue) const
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeSysInt(m_hTheme, nIntID, pnValue);
+	}
+
+#ifdef _WTL_NEW_UXTHEME
+	HTHEME OpenThemeDataEx(HWND hWnd, LPCWSTR pszClassList, DWORD dwFlags)
+	{
+		if(!IsThemingSupported())
+			return NULL;
+
+		ATLASSERT(m_hTheme == NULL);
+		m_hTheme = ::OpenThemeDataEx(hWnd, pszClassList, dwFlags);
+		return m_hTheme;
+	}
+
+	HRESULT DrawThemeTextEx(HDC hDC, int nPartID, int nStateID, LPCWSTR pszText, int cchText, DWORD dwTextFlags, LPRECT lpRect, const DTTOPTS* pOptions)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::DrawThemeTextEx(m_hTheme, hDC, nPartID, nStateID, pszText, cchText, dwTextFlags, lpRect, pOptions);
+	}
+
+	HRESULT GetThemeTransitionDuration(int nPartID, int nFromStateID, int nToStateID, int nPropID, DWORD& dwDuration)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeTransitionDuration(m_hTheme, nPartID, nFromStateID, nToStateID, nPropID, &dwDuration);
+	}
+#endif // _WTL_NEW_UXTHEME
+
+#if (_WIN32_WINNT >= 0x0600)
+	HRESULT GetThemeBitmap(int nPartID, int nStateID, int nPropID, ULONG uFlags, HBITMAP& hBitmap)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeBitmap(m_hTheme, nPartID, nStateID, nPropID, uFlags, &hBitmap);
+	}
+
+	HRESULT GetThemeStream(int nPartID, int nStateID, int nPropID, VOID** ppvStream, DWORD* pcbStream, HINSTANCE hInstance)
+	{
+		ATLASSERT(m_hTheme != NULL);
+		return ::GetThemeStream(m_hTheme, nPartID, nStateID, nPropID, ppvStream, pcbStream, hInstance);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+};
+
+__declspec(selectany) int CTheme::m_nIsThemingSupported = -1;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CThemeImpl - theme support implementation
+
+// Derive from this class to implement window with theme support.
+// Example:
+//	class CMyThemeWindow : public CWindowImpl<CMyThemeWindow>, public CThemeImpl<CMyThemeWindow>
+//	{
+//	...
+//		BEGIN_MSG_MAP(CMyThemeWindow)
+//			CHAIN_MSG_MAP(CThemeImpl<CMyThemeWindow>)
+//			...
+//		END_MSG_MAP()
+//	...
+//	};
+//
+// If you set theme class list, the class will automaticaly open/close/reopen theme data.
+
+
+// Helper for drawing theme client edge
+inline bool AtlDrawThemeClientEdge(HTHEME hTheme, HWND hWnd, HRGN hRgnUpdate = NULL, HBRUSH hBrush = NULL, int nPartID = 0, int nStateID = 0)
+{
+	ATLASSERT(hTheme != NULL);
+	ATLASSERT(::IsWindow(hWnd));
+
+	CWindowDC dc(hWnd);
+	if(dc.IsNull())
+		return false;
+
+	// Get border size
+	int cxBorder = GetSystemMetrics(SM_CXBORDER);
+	int cyBorder = GetSystemMetrics(SM_CYBORDER);
+	if(SUCCEEDED(::GetThemeInt(hTheme, nPartID, nStateID, TMT_SIZINGBORDERWIDTH, &cxBorder)))
+		cyBorder = cxBorder;
+
+	RECT rect;
+	::GetWindowRect(hWnd, &rect);            
+
+	// Remove the client edge from the update region
+	int cxEdge = GetSystemMetrics(SM_CXEDGE);
+	int cyEdge = GetSystemMetrics(SM_CYEDGE);
+	::InflateRect(&rect, -cxEdge, -cyEdge);
+	CRgn rgn;
+	rgn.CreateRectRgnIndirect(&rect);
+	if(rgn.IsNull())
+		return false;
+
+	if(hRgnUpdate != NULL)
+		rgn.CombineRgn(hRgnUpdate, rgn, RGN_AND);
+
+	::OffsetRect(&rect, -rect.left, -rect.top);
+
+	::OffsetRect(&rect, cxEdge, cyEdge);
+	dc.ExcludeClipRect(&rect);
+	::InflateRect(&rect, cxEdge, cyEdge);
+
+	::DrawThemeBackground(hTheme, dc, nPartID, nStateID, &rect, NULL);
+
+	// Use background brush too, since theme border might not cover everything
+	if(cxBorder < cxEdge && cyBorder < cyEdge)
+	{
+		if(hBrush == NULL)
+// need conditional code because types don't match in winuser.h
+#ifdef _WIN64
+			hBrush = (HBRUSH)::GetClassLongPtr(hWnd, GCLP_HBRBACKGROUND);
+#else
+			hBrush = (HBRUSH)UlongToPtr(::GetClassLongPtr(hWnd, GCLP_HBRBACKGROUND));
+#endif
+
+		::InflateRect(&rect, cxBorder - cxEdge, cyBorder - cyEdge);
+		dc.FillRect(&rect, hBrush);
+	}
+
+	::DefWindowProc(hWnd, WM_NCPAINT, (WPARAM)rgn.m_hRgn, 0L);
+
+	return true;
+}
+
+
+// Theme extended styles
+#define THEME_EX_3DCLIENTEDGE		0x00000001
+#define THEME_EX_THEMECLIENTEDGE	0x00000002
+
+template <class T, class TBase = CTheme>
+class CThemeImpl : public TBase
+{
+public:
+// Data members
+	LPWSTR m_lpstrThemeClassList;
+	DWORD m_dwExtendedStyle;   // theme specific extended styles
+
+// Constructor & destructor
+	CThemeImpl() : m_lpstrThemeClassList(NULL), m_dwExtendedStyle(0)
+	{ }
+
+	~CThemeImpl()
+	{
+		delete [] m_lpstrThemeClassList;
+	}
+
+// Attributes
+	bool SetThemeClassList(LPCWSTR lpstrThemeClassList)
+	{
+		if(m_lpstrThemeClassList != NULL)
+		{
+			delete [] m_lpstrThemeClassList;
+			m_lpstrThemeClassList = NULL;
+		}
+
+		if(lpstrThemeClassList == NULL)
+			return true;
+
+		int cchLen = lstrlenW(lpstrThemeClassList) + 1;
+		ATLTRY(m_lpstrThemeClassList = new WCHAR[cchLen]);
+		if(m_lpstrThemeClassList == NULL)
+			return false;
+
+		SecureHelper::strcpyW_x(m_lpstrThemeClassList, cchLen, lpstrThemeClassList);
+
+		return true;
+	}
+
+	bool GetThemeClassList(LPWSTR lpstrThemeClassList, int cchListBuffer) const
+	{
+		int cchLen = lstrlenW(m_lpstrThemeClassList) + 1;
+		if(cchListBuffer < cchLen)
+			return false;
+
+		SecureHelper::strcpyW_x(lpstrThemeClassList, cchListBuffer, m_lpstrThemeClassList);
+
+		return true;
+	}
+
+	LPCWSTR GetThemeClassList() const
+	{
+		return m_lpstrThemeClassList;
+	}
+
+	DWORD SetThemeExtendedStyle(DWORD dwExtendedStyle, DWORD dwMask = 0)
+	{
+		DWORD dwPrevStyle = m_dwExtendedStyle;
+		if(dwMask == 0)
+			m_dwExtendedStyle = dwExtendedStyle;
+		else
+			m_dwExtendedStyle = (m_dwExtendedStyle & ~dwMask) | (dwExtendedStyle & dwMask);
+		return dwPrevStyle;
+	}
+
+	DWORD GetThemeExtendedStyle() const
+	{
+		return m_dwExtendedStyle;
+	}
+
+// Operations
+	HTHEME OpenThemeData()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		ATLASSERT(m_lpstrThemeClassList != NULL);
+		if(m_lpstrThemeClassList == NULL)
+			return NULL;
+		CloseThemeData();
+		return TBase::OpenThemeData(pT->m_hWnd, m_lpstrThemeClassList);
+	}
+
+	HTHEME OpenThemeData(LPCWSTR pszClassList)
+	{
+		if(!SetThemeClassList(pszClassList))
+			return NULL;
+		return OpenThemeData();
+	}
+
+	HRESULT SetWindowTheme(LPCWSTR pszSubAppName, LPCWSTR pszSubIDList)
+	{
+		if(!IsThemingSupported())
+			return S_FALSE;
+
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::SetWindowTheme(pT->m_hWnd, pszSubAppName, pszSubIDList);
+	}
+
+	HTHEME GetWindowTheme() const
+	{
+		if(!IsThemingSupported())
+			return NULL;
+
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::GetWindowTheme(pT->m_hWnd);
+	}
+
+	HRESULT EnableThemeDialogTexture(DWORD dwFlags)
+	{
+		if(!IsThemingSupported())
+			return S_FALSE;
+
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::EnableThemeDialogTexture(pT->m_hWnd, dwFlags);
+	}
+
+	BOOL IsThemeDialogTextureEnabled() const
+	{
+		if(!IsThemingSupported())
+			return FALSE;
+
+		const T* pT = static_cast<const T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::IsThemeDialogTextureEnabled(pT->m_hWnd);
+	}
+
+	HRESULT DrawThemeParentBackground(HDC hDC, const RECT* pRect = NULL)
+	{
+		if(!IsThemingSupported())
+			return S_FALSE;
+
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+#ifdef _WTL_NEW_UXTHEME
+		return ::DrawThemeParentBackground(pT->m_hWnd, hDC, pRect);
+#else
+		return ::DrawThemeParentBackground(pT->m_hWnd, hDC, (RECT*)pRect);
+#endif
+	}
+
+#ifdef _WTL_NEW_UXTHEME
+	HRESULT SetWindowThemeAttribute(WINDOWTHEMEATTRIBUTETYPE type, PVOID pvAttribute, DWORD cbAttribute)
+	{
+		if(!IsThemingSupported())
+			return S_FALSE;
+
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::SetWindowThemeAttribute(pT->m_hWnd, type, pvAttribute, cbAttribute);
+	}
+
+	HRESULT SetWindowThemeNonClientAttributes(DWORD dwAttributes, DWORD dwMask)
+	{
+		if(!IsThemingSupported())
+			return S_FALSE;
+
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		WTA_OPTIONS opt = { dwAttributes, dwMask };
+		return ::SetWindowThemeAttribute(pT->m_hWnd, WTA_NONCLIENT, (PVOID)&opt, sizeof(opt));
+	}
+
+	HRESULT DrawThemeParentBackgroundEx(HDC hDC, DWORD dwFlags, const RECT* lpRect = NULL)
+	{
+		if(!IsThemingSupported())
+			return S_FALSE;
+
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		return ::DrawThemeParentBackgroundEx(pT->m_hWnd, hDC, dwFlags, lpRect);
+	}
+#endif // _WTL_NEW_UXTHEME
+
+// Message map and handlers
+	// Note: If you handle any of these messages in your derived class,
+	// it is better to put CHAIN_MSG_MAP at the start of your message map.
+	BEGIN_MSG_MAP(CThemeImpl)
+		MESSAGE_HANDLER(WM_CREATE, OnCreate)
+		MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
+		MESSAGE_HANDLER(WM_THEMECHANGED, OnThemeChanged)
+		MESSAGE_HANDLER(WM_NCPAINT, OnNcPaint)
+	END_MSG_MAP()
+
+	LRESULT OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if(m_lpstrThemeClassList != NULL)
+			OpenThemeData();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnDestroy(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		CloseThemeData();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnThemeChanged(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		CloseThemeData();
+		if(m_lpstrThemeClassList != NULL)
+			OpenThemeData();
+		bHandled = FALSE;
+		return 1;
+	}
+
+	LRESULT OnNcPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		LRESULT lRet = 0;
+		bHandled = FALSE;
+		if(IsThemingSupported() && ((pT->GetExStyle() & WS_EX_CLIENTEDGE) != 0))
+		{
+			if((m_dwExtendedStyle & THEME_EX_3DCLIENTEDGE) != 0)
+			{
+				lRet = ::DefWindowProc(pT->m_hWnd, uMsg, wParam, lParam);
+				bHandled = TRUE;
+			}
+			else if((m_hTheme != NULL) && ((m_dwExtendedStyle & THEME_EX_THEMECLIENTEDGE) != 0))
+			{
+				HRGN hRgn = (wParam != 1) ? (HRGN)wParam : NULL;
+				if(pT->DrawThemeClientEdge(hRgn))
+					bHandled = TRUE;
+			}
+		}
+		return lRet;
+	}
+
+// Drawing helper
+	bool DrawThemeClientEdge(HRGN hRgnUpdate)
+	{
+		T* pT = static_cast<T*>(this);
+		return AtlDrawThemeClientEdge(m_hTheme, pT->m_hWnd, hRgnUpdate, NULL, 0, 0);
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// Buffered Paint and Animation
+
+#ifdef _WTL_NEW_UXTHEME
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedPaintBase - Buffered Paint support for othe classes
+
+class CBufferedPaintBase
+{
+public:
+	static int m_nIsBufferedPaintSupported;
+
+	CBufferedPaintBase()
+	{
+		if(IsBufferedPaintSupported())
+			ATLVERIFY(SUCCEEDED(::BufferedPaintInit()));
+	}
+
+	~CBufferedPaintBase()
+	{
+		if(IsBufferedPaintSupported())
+			ATLVERIFY(SUCCEEDED(::BufferedPaintUnInit()));
+	}
+
+	static bool IsBufferedPaintSupported()
+	{
+		if(m_nIsBufferedPaintSupported == -1)
+		{
+			CStaticDataInitCriticalSectionLock lock;
+			if(FAILED(lock.Lock()))
+			{
+				ATLTRACE2(atlTraceUI, 0, _T("ERROR : Unable to lock critical section in CBufferedPaintBase::IsBufferedPaintSupported.\n"));
+				ATLASSERT(FALSE);
+				return false;
+			}
+
+			if(m_nIsBufferedPaintSupported == -1)
+				m_nIsBufferedPaintSupported = RunTimeHelper::IsVista() ? 1 : 0;
+
+			lock.Unlock();
+		}
+
+		ATLASSERT(m_nIsBufferedPaintSupported != -1);
+		return (m_nIsBufferedPaintSupported == 1);
+	}
+};
+
+__declspec(selectany) int CBufferedPaintBase::m_nIsBufferedPaintSupported = -1;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedPaint - support for buffered paint functions
+
+class CBufferedPaint
+{
+public:
+	HPAINTBUFFER m_hPaintBuffer;
+
+	CBufferedPaint() : m_hPaintBuffer(NULL)
+	{ }
+
+	~CBufferedPaint()
+	{
+		ATLVERIFY(SUCCEEDED(End()));
+	}
+
+	bool IsNull() const
+	{
+		return (m_hPaintBuffer == NULL);
+	}
+
+	HPAINTBUFFER Begin(HDC hdcTarget, const RECT* prcTarget, BP_BUFFERFORMAT dwFormat, BP_PAINTPARAMS* pPaintParams, HDC* phdcPaint)
+	{
+		ATLASSERT(m_hPaintBuffer == NULL);
+		m_hPaintBuffer = ::BeginBufferedPaint(hdcTarget, prcTarget, dwFormat, pPaintParams, phdcPaint);
+		return m_hPaintBuffer;
+	}
+
+	HRESULT End(BOOL bUpdate = TRUE)
+	{
+		HRESULT hRet = S_FALSE;
+		if(m_hPaintBuffer != NULL)
+		{
+			hRet = ::EndBufferedPaint(m_hPaintBuffer, bUpdate);
+			m_hPaintBuffer = NULL;
+		}
+		return hRet;
+	}
+
+	HRESULT GetTargetRect(LPRECT pRect) const
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::GetBufferedPaintTargetRect(m_hPaintBuffer, pRect);
+	}
+
+	HDC GetTargetDC() const
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::GetBufferedPaintTargetDC(m_hPaintBuffer);
+	}
+
+	HDC GetPaintDC() const
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::GetBufferedPaintDC(m_hPaintBuffer);
+	}
+
+	HRESULT GetBits(RGBQUAD** ppbBuffer, int* pcxRow) const
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::GetBufferedPaintBits(m_hPaintBuffer, ppbBuffer, pcxRow);
+	}
+
+	HRESULT Clear(const RECT* pRect = NULL)
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::BufferedPaintClear(m_hPaintBuffer, pRect);
+	}
+
+	HRESULT SetAlpha(BYTE alpha, const RECT* pRect = NULL)
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::BufferedPaintSetAlpha(m_hPaintBuffer, pRect, alpha);
+	}
+
+	HRESULT MakeOpaque(const RECT* pRect = NULL)
+	{
+		ATLASSERT(m_hPaintBuffer != NULL);
+		return ::BufferedPaintSetAlpha(m_hPaintBuffer, pRect, 255);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedPaintImpl - provides buffered paint for any window
+
+template <class T>
+class ATL_NO_VTABLE CBufferedPaintImpl : public CBufferedPaintBase
+{
+public:
+	CBufferedPaint m_BufferedPaint;
+	BP_BUFFERFORMAT m_dwFormat;
+	BP_PAINTPARAMS m_PaintParams;
+
+	CBufferedPaintImpl() : m_dwFormat(BPBF_TOPDOWNDIB)
+	{
+		memset(&m_PaintParams, 0, sizeof(BP_PAINTPARAMS));
+		m_PaintParams.cbSize = sizeof(BP_PAINTPARAMS);
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CBufferedPaintImpl)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+	END_MSG_MAP()
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background needed
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		if(wParam != NULL)
+		{
+			RECT rect = { 0 };
+			pT->GetClientRect(&rect);
+			pT->DoPaint((HDC)wParam, rect);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			pT->DoBufferedPaint(dc.m_hDC, dc.m_ps.rcPaint);
+		}
+
+		return 0;
+	}
+
+// Overrideables
+	void DoBufferedPaint(CDCHandle dc, RECT& rect)
+	{
+		HDC hDCPaint = NULL;
+		if(IsBufferedPaintSupported())
+			m_BufferedPaint.Begin(dc, &rect, m_dwFormat, &m_PaintParams, &hDCPaint);
+
+		T* pT = static_cast<T*>(this);
+		if(hDCPaint != NULL)
+			pT->DoPaint(hDCPaint, rect);
+		else
+			pT->DoPaint(dc.m_hDC, rect);
+
+		if(IsBufferedPaintSupported())
+			m_BufferedPaint.End();
+	}
+
+	void DoPaint(CDCHandle /*dc*/, RECT& /*rect*/)
+	{
+		// must be implemented in a derived class
+		ATLASSERT(FALSE);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedPaintWindowImpl - implements a window that uses buffered paint
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CBufferedPaintWindowImpl : 
+		public ATL::CWindowImpl<T, TBase, TWinTraits>, 
+		public CBufferedPaintImpl< T >
+{
+public:
+	BEGIN_MSG_MAP(CBufferedPaintWindowImpl)
+		CHAIN_MSG_MAP(CBufferedPaintImpl< T >)
+	END_MSG_MAP()
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedAnimation - support for buffered animation
+
+class CBufferedAnimation
+{
+public:
+	HANIMATIONBUFFER m_hAnimationBuffer;
+
+	CBufferedAnimation() : m_hAnimationBuffer(NULL)
+	{ }
+
+	~CBufferedAnimation()
+	{
+		ATLVERIFY(SUCCEEDED(End()));
+	}
+
+	bool IsNull() const
+	{
+		return (m_hAnimationBuffer == NULL);
+	}
+
+	HANIMATIONBUFFER Begin(HWND hWnd, HDC hDCTarget, const RECT* pRectTarget, BP_BUFFERFORMAT dwFormat, BP_PAINTPARAMS* pPaintParams, BP_ANIMATIONPARAMS* pAnimationParams, HDC* phdcFrom, HDC* phdcTo)
+	{
+		ATLASSERT(m_hAnimationBuffer == NULL);
+		m_hAnimationBuffer = ::BeginBufferedAnimation(hWnd, hDCTarget, pRectTarget, dwFormat, pPaintParams, pAnimationParams, phdcFrom, phdcTo);
+		return m_hAnimationBuffer;
+	}
+
+	HRESULT End(BOOL bUpdate = TRUE)
+	{
+		HRESULT hRet = S_FALSE;
+		if(m_hAnimationBuffer != NULL)
+		{
+			hRet = ::EndBufferedAnimation(m_hAnimationBuffer, bUpdate);
+			m_hAnimationBuffer = NULL;
+		}
+		return hRet;
+	}
+
+	static bool IsRendering(HWND hWnd, HDC hDC)
+	{
+		return (::BufferedPaintRenderAnimation(hWnd, hDC) != FALSE);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedAnimationImpl - provides buffered animation support for any window
+
+// Note: You can either use m_State and m_NewState to store the state information
+// for the animation change, or map your state to those data members. DoPaint()
+// should only rely on the state information that is passed to it.
+
+template <class T, class TState = DWORD_PTR>
+class ATL_NO_VTABLE CBufferedAnimationImpl : public CBufferedPaintBase
+{
+public:
+	BP_BUFFERFORMAT m_dwFormat;
+	BP_PAINTPARAMS m_PaintParams;
+	BP_ANIMATIONPARAMS m_AnimationParams;
+
+	TState m_State;
+	TState m_NewState;
+
+	CBufferedAnimationImpl(TState InitialState) : m_dwFormat(BPBF_TOPDOWNDIB)
+	{
+		memset(&m_PaintParams, 0, sizeof(BP_PAINTPARAMS));
+		m_PaintParams.cbSize = sizeof(BP_PAINTPARAMS);
+
+		memset(&m_AnimationParams, 0, sizeof(BP_ANIMATIONPARAMS));
+		m_AnimationParams.cbSize = sizeof(BP_ANIMATIONPARAMS);
+		m_AnimationParams.style = BPAS_LINEAR;
+		m_AnimationParams.dwDuration = 500;
+
+		T* pT = static_cast<T*>(this);
+		pT->SetState(InitialState);
+		pT->SetNewState(InitialState);
+	}
+
+	DWORD GetDuration() const
+	{
+		return m_AnimationParams.dwDuration;
+	}
+
+	void SetDuration(DWORD dwDuration)
+	{
+		m_AnimationParams.dwDuration = dwDuration;
+	}
+
+	void DoAnimation(TState NewState, const RECT* pRect = NULL)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->SetNewState(NewState);
+
+		pT->InvalidateRect(pRect, FALSE);
+		pT->UpdateWindow();
+
+		pT->SetState(NewState);
+	}
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CBufferedAnimationImpl)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnPaint)
+	END_MSG_MAP()
+
+	LRESULT OnEraseBackground(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		return 1;   // no background needed
+	}
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		if(wParam != NULL)
+		{
+			RECT rect = { 0 };
+			pT->GetClientRect(&rect);
+			pT->DoPaint((HDC)wParam, rect, m_NewState);
+		}
+		else
+		{
+			CPaintDC dc(pT->m_hWnd);
+			pT->DoAnimationPaint(dc.m_hDC, dc.m_ps.rcPaint);
+		}
+
+		return 0;
+	}
+
+// Overrideables
+	void SetState(TState State)
+	{
+		m_State = State;
+	}
+
+	void SetNewState(TState State)
+	{
+		m_NewState = State;
+	}
+
+	bool AreStatesEqual() const
+	{
+		return (m_State == m_NewState);
+	}
+
+	void DoAnimationPaint(CDCHandle dc, RECT& rect)
+	{
+		T* pT = static_cast<T*>(this);
+		if(IsBufferedPaintSupported() && CBufferedAnimation::IsRendering(pT->m_hWnd, dc))
+			return;
+
+		DWORD dwDurationSave = m_AnimationParams.dwDuration;
+		if(pT->AreStatesEqual())
+			m_AnimationParams.dwDuration = 0;
+
+		HDC hdcFrom = NULL, hdcTo = NULL;
+		CBufferedAnimation ba;
+		if(IsBufferedPaintSupported())
+			ba.Begin(pT->m_hWnd, dc, &rect, m_dwFormat, &m_PaintParams, &m_AnimationParams, &hdcFrom, &hdcTo);
+
+		if(!ba.IsNull())
+		{
+			if(hdcFrom != NULL)
+				pT->DoPaint(hdcFrom, rect, m_State);
+
+			if (hdcTo != NULL)
+				pT->DoPaint(hdcTo, rect, m_NewState);
+		}
+		else
+		{
+			pT->DoPaint(dc.m_hDC, rect, m_NewState);
+		}
+
+		m_AnimationParams.dwDuration = dwDurationSave;
+	}
+
+	void DoPaint(CDCHandle /*dc*/, RECT& /*rect*/, TState /*State*/)
+	{
+		// must be implemented in a derived class
+		ATLASSERT(FALSE);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CBufferedAnimationWindowImpl - implements a window that uses buffered animation
+
+template <class T, class TState = DWORD_PTR, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CBufferedAnimationWindowImpl : 
+		public ATL::CWindowImpl<T, TBase, TWinTraits>, 
+		public CBufferedAnimationImpl< T, TState >
+{
+public:
+	CBufferedAnimationWindowImpl(TState InitialState) : CBufferedAnimationImpl< T, TState >(InitialState)
+	{ }
+
+	typedef CBufferedAnimationImpl< T, TState >   _baseBufferedAnimation;
+	BEGIN_MSG_MAP(CBufferedAnimationWindowImpl)
+		CHAIN_MSG_MAP(_baseBufferedAnimation)
+	END_MSG_MAP()
+};
+
+#endif // _WTL_NEW_UXTHEME
+
+}; // namespace WTL
+
+#endif // __ATLTHEME_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atluser.h b/GLideN64/src/GLideNUI-wtl/WTL/atluser.h
new file mode 100644
index 00000000..31dd38f8
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atluser.h
@@ -0,0 +1,1391 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLUSER_H__
+#define __ATLUSER_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atluser.h requires atlapp.h to be included first
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CMenuItemInfo
+// CMenuT<t_bManaged>
+// CAcceleratorT<t_bManaged>
+// CIconT<t_bManaged>
+// CCursorT<t_bManaged>
+// CResource
+//
+// Global functions:
+//   AtlMessageBox()
+//
+//   AtlLoadAccelerators()
+//   AtlLoadMenu()
+//   AtlLoadBitmap()
+//   AtlLoadSysBitmap()
+//   AtlLoadCursor()
+//   AtlLoadSysCursor()
+//   AtlLoadIcon()
+//   AtlLoadSysIcon()
+//   AtlLoadBitmapImage()
+//   AtlLoadCursorImage()
+//   AtlLoadIconImage()
+//   AtlLoadSysBitmapImage()
+//   AtlLoadSysCursorImage()
+//   AtlLoadSysIconImage()
+//   AtlLoadString()
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// AtlMessageBox - accepts both memory and resource based strings
+
+inline int AtlMessageBox(HWND hWndOwner, ATL::_U_STRINGorID message, ATL::_U_STRINGorID title = (LPCTSTR)NULL, UINT uType = MB_OK | MB_ICONINFORMATION)
+{
+	ATLASSERT(hWndOwner == NULL || ::IsWindow(hWndOwner));
+
+	LPTSTR lpstrMessage = NULL;
+	if(IS_INTRESOURCE(message.m_lpstr))
+	{
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			ATLTRY(lpstrMessage = new TCHAR[nLen]);
+			if(lpstrMessage == NULL)
+			{
+				ATLASSERT(FALSE);
+				return 0;
+			}
+			int nRes = ::LoadString(ModuleHelper::GetResourceInstance(), LOWORD(message.m_lpstr), lpstrMessage, nLen);
+			if(nRes < nLen - 1)
+				break;
+			delete [] lpstrMessage;
+			lpstrMessage = NULL;
+		}
+
+		message.m_lpstr = lpstrMessage;
+	}
+
+	LPTSTR lpstrTitle = NULL;
+	if(IS_INTRESOURCE(title.m_lpstr) && LOWORD(title.m_lpstr) != 0)
+	{
+		for(int nLen = 256; ; nLen *= 2)
+		{
+			ATLTRY(lpstrTitle = new TCHAR[nLen]);
+			if(lpstrTitle == NULL)
+			{
+				ATLASSERT(FALSE);
+				return 0;
+			}
+			int nRes = ::LoadString(ModuleHelper::GetResourceInstance(), LOWORD(title.m_lpstr), lpstrTitle, nLen);
+			if(nRes < nLen - 1)
+				break;
+			delete [] lpstrTitle;
+			lpstrTitle = NULL;
+		}
+
+		title.m_lpstr = lpstrTitle;
+	}
+
+	int nRet = ::MessageBox(hWndOwner, message.m_lpstr, title.m_lpstr, uType);
+
+	delete [] lpstrMessage;
+	delete [] lpstrTitle;
+
+	return nRet;
+}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CMenu
+
+#if (WINVER >= 0x0500)
+  #ifndef MII_SIZEOF_STRUCT
+    #define MII_SIZEOF_STRUCT(structname, member)  (((int)((LPBYTE)(&((structname*)0)->member) - ((LPBYTE)((structname*)0)))) + sizeof(((structname*)0)->member))
+  #endif
+  #define MENUITEMINFO_SIZE_VERSION_400A  MII_SIZEOF_STRUCT(MENUITEMINFOA, cch)
+  #define MENUITEMINFO_SIZE_VERSION_400W  MII_SIZEOF_STRUCT(MENUITEMINFOW, cch)
+  #ifdef UNICODE
+    #define MENUITEMINFO_SIZE_VERSION_400  MENUITEMINFO_SIZE_VERSION_400W
+  #else
+    #define MENUITEMINFO_SIZE_VERSION_400  MENUITEMINFO_SIZE_VERSION_400A
+  #endif // !UNICODE
+#endif // (WINVER >= 0x0500)
+
+class CMenuItemInfo : public MENUITEMINFO
+{
+public:
+	CMenuItemInfo()
+	{
+		memset(this, 0, sizeof(MENUITEMINFO));
+		cbSize = sizeof(MENUITEMINFO);
+#if (WINVER >= 0x0500)
+		// adjust struct size if running on older version of Windows
+		if(AtlIsOldWindows())
+		{
+			ATLASSERT(cbSize > MENUITEMINFO_SIZE_VERSION_400);   // must be
+			cbSize = MENUITEMINFO_SIZE_VERSION_400;
+		}
+#endif // (WINVER >= 0x0500)
+	}
+};
+
+
+// forward declarations
+template <bool t_bManaged> class CMenuT;
+typedef CMenuT<false>   CMenuHandle;
+typedef CMenuT<true>    CMenu;
+
+
+template <bool t_bManaged>
+class CMenuT
+{
+public:
+// Data members
+	HMENU m_hMenu;
+
+// Constructor/destructor/operators
+	CMenuT(HMENU hMenu = NULL) : m_hMenu(hMenu)
+	{ }
+
+	~CMenuT()
+	{
+		if(t_bManaged && m_hMenu != NULL)
+			DestroyMenu();
+	}
+
+	CMenuT<t_bManaged>& operator =(HMENU hMenu)
+	{
+		Attach(hMenu);
+		return *this;
+	}
+
+	void Attach(HMENU hMenuNew)
+	{
+		ATLASSERT(::IsMenu(hMenuNew));
+		if(t_bManaged && m_hMenu != NULL && m_hMenu != hMenuNew)
+			::DestroyMenu(m_hMenu);
+		m_hMenu = hMenuNew;
+	}
+
+	HMENU Detach()
+	{
+		HMENU hMenu = m_hMenu;
+		m_hMenu = NULL;
+		return hMenu;
+	}
+
+	operator HMENU() const { return m_hMenu; }
+
+	bool IsNull() const { return (m_hMenu == NULL); }
+
+	BOOL IsMenu() const
+	{
+		return ::IsMenu(m_hMenu);
+	}
+
+// Create/destroy methods
+	BOOL CreateMenu()
+	{
+		ATLASSERT(m_hMenu == NULL);
+		m_hMenu = ::CreateMenu();
+		return (m_hMenu != NULL) ? TRUE : FALSE;
+	}
+
+	BOOL CreatePopupMenu()
+	{
+		ATLASSERT(m_hMenu == NULL);
+		m_hMenu = ::CreatePopupMenu();
+		return (m_hMenu != NULL) ? TRUE : FALSE;
+	}
+
+	BOOL LoadMenu(ATL::_U_STRINGorID menu)
+	{
+		ATLASSERT(m_hMenu == NULL);
+		m_hMenu = ::LoadMenu(ModuleHelper::GetResourceInstance(), menu.m_lpstr);
+		return (m_hMenu != NULL) ? TRUE : FALSE;
+	}
+
+#ifndef _WIN32_WCE
+	BOOL LoadMenuIndirect(const void* lpMenuTemplate)
+	{
+		ATLASSERT(m_hMenu == NULL);
+		m_hMenu = ::LoadMenuIndirect(lpMenuTemplate);
+		return (m_hMenu != NULL) ? TRUE : FALSE;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DestroyMenu()
+	{
+		if (m_hMenu == NULL)
+			return FALSE;
+		BOOL bRet = ::DestroyMenu(m_hMenu);
+		if(bRet)
+			m_hMenu = NULL;
+		return bRet;
+	}
+
+// Menu Operations
+	BOOL DeleteMenu(UINT nPosition, UINT nFlags)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::DeleteMenu(m_hMenu, nPosition, nFlags);
+	}
+
+	BOOL TrackPopupMenu(UINT nFlags, int x, int y, HWND hWnd, LPCRECT lpRect = NULL)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+#ifndef _WIN32_WCE
+#if (WINVER >= 0x0500)
+		x = _FixTrackMenuPopupX(x, y);
+#endif // !(WINVER >= 0x0500)
+		return ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0, hWnd, lpRect);
+#else // CE specific
+		lpRect;
+		return ::TrackPopupMenuEx(m_hMenu, nFlags, x, y, hWnd, NULL);
+#endif // _WIN32_WCE
+	}
+
+	BOOL TrackPopupMenuEx(UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm = NULL)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+		x = _FixTrackMenuPopupX(x, y);
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+		return ::TrackPopupMenuEx(m_hMenu, uFlags, x, y, hWnd, lptpm);
+	}
+
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+	// helper that fixes popup menu X position when it's off-screen
+	static int _FixTrackMenuPopupX(int x, int y)
+	{
+		POINT pt = { x, y };
+		HMONITOR hMonitor = ::MonitorFromPoint(pt, MONITOR_DEFAULTTONULL);
+		if(hMonitor == NULL)
+		{
+			HMONITOR hMonitorNear = ::MonitorFromPoint(pt, MONITOR_DEFAULTTONEAREST);
+			if(hMonitorNear != NULL)
+			{
+				MONITORINFO mi = { 0 };
+				mi.cbSize = sizeof(MONITORINFO);
+				if(::GetMonitorInfo(hMonitorNear, &mi) != FALSE)
+				{
+					if(x < mi.rcWork.left)
+						x = mi.rcWork.left;
+					else if(x > mi.rcWork.right)
+						x = mi.rcWork.right;
+				}
+			}
+		}
+
+		return x;
+	}
+
+	BOOL GetMenuInfo(LPMENUINFO lpMenuInfo) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuInfo(m_hMenu, lpMenuInfo);
+	}
+
+	BOOL SetMenuInfo(LPCMENUINFO lpMenuInfo)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::SetMenuInfo(m_hMenu, lpMenuInfo);
+	}
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+
+// Menu Item Operations
+	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem);
+	}
+
+	BOOL AppendMenu(UINT nFlags, HMENU hSubMenu, LPCTSTR lpszNewItem)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(::IsMenu(hSubMenu));
+		return ::AppendMenu(m_hMenu, nFlags | MF_POPUP, (UINT_PTR)hSubMenu, lpszNewItem);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL AppendMenu(UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
+	}
+
+	BOOL AppendMenu(UINT nFlags, HMENU hSubMenu, HBITMAP hBmp)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(::IsMenu(hSubMenu));
+		return ::AppendMenu(m_hMenu, nFlags | (MF_BITMAP | MF_POPUP), (UINT_PTR)hSubMenu, (LPCTSTR)hBmp);
+	}
+#endif // !_WIN32_WCE
+
+	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck);
+	}
+
+	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL HiliteMenuItem(HWND hWnd, UINT uIDHiliteItem, UINT uHilite)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::HiliteMenuItem(hWnd, m_hMenu, uIDHiliteItem, uHilite);
+	}
+
+	int GetMenuItemCount() const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuItemCount(m_hMenu);
+	}
+
+	UINT GetMenuItemID(int nPos) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuItemID(m_hMenu, nPos);
+	}
+
+	UINT GetMenuState(UINT nID, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuState(m_hMenu, nID, nFlags);
+	}
+
+	int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
+	}
+
+	int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
+	}
+
+#ifndef _ATL_NO_COM
+	BOOL GetMenuString(UINT nIDItem, BSTR& bstrText, UINT nFlags) const
+	{
+		USES_CONVERSION;
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(bstrText == NULL);
+
+		int nLen = GetMenuStringLen(nIDItem, nFlags);
+		if(nLen == 0)
+		{
+			bstrText = ::SysAllocString(OLESTR(""));
+			return (bstrText != NULL) ? TRUE : FALSE;
+		}
+
+		nLen++;   // increment to include terminating NULL char
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		LPTSTR lpszText = buff.Allocate(nLen);
+		if(lpszText == NULL)
+			return FALSE;
+
+		if(!GetMenuString(nIDItem, lpszText, nLen, nFlags))
+			return FALSE;
+
+		bstrText = ::SysAllocString(T2OLE(lpszText));
+		return (bstrText != NULL) ? TRUE : FALSE;
+	}
+#endif // !_ATL_NO_COM
+
+#elif (_ATL_VER >= 0x0800)
+	int GetMenuItemCount() const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ATL::GetMenuItemCount(m_hMenu);
+	}
+
+	UINT GetMenuItemID(int nPos) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ATL::GetMenuItemID(m_hMenu, nPos);
+	}
+
+	UINT GetMenuState(UINT nID, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ATL::GetMenuState(m_hMenu, nID, nFlags);
+	}
+
+	int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ATL::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
+	}
+
+	int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ATL::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
+	}
+#endif // (_ATL_VER >= 0x0800)
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	int GetMenuString(UINT nIDItem, _CSTRING_NS::CString& strText, UINT nFlags) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+
+		int nLen = GetMenuStringLen(nIDItem, nFlags);
+		if(nLen == 0)
+			return 0;
+
+		nLen++;   // increment to include terminating NULL char
+		LPTSTR lpstr = strText.GetBufferSetLength(nLen);
+		if(lpstr == NULL)
+			return 0;
+		int nRet = GetMenuString(nIDItem, lpstr, nLen, nFlags);
+		strText.ReleaseBuffer();
+		return nRet;
+	}
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+
+	CMenuHandle GetSubMenu(int nPos) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return CMenuHandle(::GetSubMenu(m_hMenu, nPos));
+	}
+
+	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
+	}
+
+	BOOL InsertMenu(UINT nPosition, UINT nFlags, HMENU hSubMenu, LPCTSTR lpszNewItem)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(::IsMenu(hSubMenu));
+		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_POPUP, (UINT_PTR)hSubMenu, lpszNewItem);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
+	}
+
+	BOOL InsertMenu(UINT nPosition, UINT nFlags, HMENU hSubMenu, HBITMAP hBmp)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(::IsMenu(hSubMenu));
+		return ::InsertMenu(m_hMenu, nPosition, nFlags | (MF_BITMAP | MF_POPUP), (UINT_PTR)hSubMenu, (LPCTSTR)hBmp);
+	}
+
+	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
+	}
+
+	BOOL ModifyMenu(UINT nPosition, UINT nFlags, HMENU hSubMenu, LPCTSTR lpszNewItem)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(::IsMenu(hSubMenu));
+		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_POPUP, (UINT_PTR)hSubMenu, lpszNewItem);
+	}
+
+	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT_PTR nIDNewItem, HBITMAP hBmp)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
+	}
+
+	BOOL ModifyMenu(UINT nPosition, UINT nFlags, HMENU hSubMenu, HBITMAP hBmp)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		ATLASSERT(::IsMenu(hSubMenu));
+		return ::ModifyMenu(m_hMenu, nPosition, nFlags | (MF_BITMAP | MF_POPUP), (UINT_PTR)hSubMenu, (LPCTSTR)hBmp);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL RemoveMenu(UINT nPosition, UINT nFlags)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::RemoveMenu(m_hMenu, nPosition, nFlags);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags, HBITMAP hBmpUnchecked, HBITMAP hBmpChecked)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags, hBmpUnchecked, hBmpChecked);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags);
+	}
+
+	BOOL GetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return (BOOL)::GetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
+	}
+
+	BOOL SetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return (BOOL)::SetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL InsertMenuItem(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return (BOOL)::InsertMenuItem(m_hMenu, uItem, bByPosition, lpmii);
+	}
+
+	UINT GetMenuDefaultItem(BOOL bByPosition = FALSE, UINT uFlags = 0U) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuDefaultItem(m_hMenu, (UINT)bByPosition, uFlags);
+	}
+
+	BOOL SetMenuDefaultItem(UINT uItem = (UINT)-1,  BOOL bByPosition = FALSE)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::SetMenuDefaultItem(m_hMenu, uItem, (UINT)bByPosition);
+	}
+
+	BOOL GetMenuItemRect(HWND hWnd, UINT uItem, LPRECT lprcItem) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuItemRect(hWnd, m_hMenu, uItem, lprcItem);
+	}
+
+	int MenuItemFromPoint(HWND hWnd, POINT point) const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::MenuItemFromPoint(hWnd, m_hMenu, point);
+	}
+
+// Context Help Functions
+	BOOL SetMenuContextHelpId(DWORD dwContextHelpId)
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId);
+	}
+
+	DWORD GetMenuContextHelpId() const
+	{
+		ATLASSERT(::IsMenu(m_hMenu));
+		return ::GetMenuContextHelpId(m_hMenu);
+	}
+#endif // !_WIN32_WCE
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAccelerator
+
+template <bool t_bManaged>
+class CAcceleratorT
+{
+public:
+	HACCEL m_hAccel;
+
+// Constructor/destructor/operators
+	CAcceleratorT(HACCEL hAccel = NULL) : m_hAccel(hAccel)
+	{ }
+
+	~CAcceleratorT()
+	{
+		if(t_bManaged && m_hAccel != NULL)
+			::DestroyAcceleratorTable(m_hAccel);
+	}
+
+	CAcceleratorT<t_bManaged>& operator =(HACCEL hAccel)
+	{
+		Attach(hAccel);
+		return *this;
+	}
+
+	void Attach(HACCEL hAccel)
+	{
+		if(t_bManaged && m_hAccel != NULL)
+			::DestroyAcceleratorTable(m_hAccel);
+		m_hAccel = hAccel;
+	}
+
+	HACCEL Detach()
+	{
+		HACCEL hAccel = m_hAccel;
+		m_hAccel = NULL;
+		return hAccel;
+	}
+
+	operator HACCEL() const { return m_hAccel; }
+
+	bool IsNull() const { return m_hAccel == NULL; }
+
+// Create/destroy methods
+	HACCEL LoadAccelerators(ATL::_U_STRINGorID accel)
+	{
+		ATLASSERT(m_hAccel == NULL);
+		m_hAccel = ::LoadAccelerators(ModuleHelper::GetResourceInstance(), accel.m_lpstr);
+		return m_hAccel;
+	}
+
+	HACCEL CreateAcceleratorTable(LPACCEL pAccel, int cEntries)
+	{
+		ATLASSERT(m_hAccel == NULL);
+		ATLASSERT(pAccel != NULL);
+		m_hAccel = ::CreateAcceleratorTable(pAccel, cEntries);
+		return m_hAccel;
+	}
+
+	void DestroyObject()
+	{
+		if(m_hAccel != NULL)
+		{
+			::DestroyAcceleratorTable(m_hAccel);
+			m_hAccel = NULL;
+		}
+	}
+
+// Operations
+#ifndef _WIN32_WCE
+	int CopyAcceleratorTable(LPACCEL lpAccelDst, int cEntries)
+	{
+		ATLASSERT(m_hAccel != NULL);
+		ATLASSERT(lpAccelDst != NULL);
+		return ::CopyAcceleratorTable(m_hAccel, lpAccelDst, cEntries);
+	}
+
+	int GetEntriesCount() const
+	{
+		ATLASSERT(m_hAccel != NULL);
+		return ::CopyAcceleratorTable(m_hAccel, NULL, 0);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL TranslateAccelerator(HWND hWnd, LPMSG pMsg)
+	{
+		ATLASSERT(m_hAccel != NULL);
+		ATLASSERT(::IsWindow(hWnd));
+		ATLASSERT(pMsg != NULL);
+		return ::TranslateAccelerator(hWnd, m_hAccel, pMsg);
+	}
+};
+
+typedef CAcceleratorT<false>   CAcceleratorHandle;
+typedef CAcceleratorT<true>    CAccelerator;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CIcon
+
+template <bool t_bManaged>
+class CIconT
+{
+public:
+	HICON m_hIcon;
+
+// Constructor/destructor/operators
+	CIconT(HICON hIcon = NULL) : m_hIcon(hIcon)
+	{ }
+
+	~CIconT()
+	{
+		if(t_bManaged && m_hIcon != NULL)
+			::DestroyIcon(m_hIcon);
+	}
+
+	CIconT<t_bManaged>& operator =(HICON hIcon)
+	{
+		Attach(hIcon);
+		return *this;
+	}
+
+	void Attach(HICON hIcon)
+	{
+		if(t_bManaged && m_hIcon != NULL)
+			::DestroyIcon(m_hIcon);
+		m_hIcon = hIcon;
+	}
+
+	HICON Detach()
+	{
+		HICON hIcon = m_hIcon;
+		m_hIcon = NULL;
+		return hIcon;
+	}
+
+	operator HICON() const { return m_hIcon; }
+
+	bool IsNull() const { return m_hIcon == NULL; }
+
+// Create/destroy methods
+	HICON LoadIcon(ATL::_U_STRINGorID icon)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		m_hIcon = ::LoadIcon(ModuleHelper::GetResourceInstance(), icon.m_lpstr);
+		return m_hIcon;
+	}
+
+	HICON LoadIcon(ATL::_U_STRINGorID icon, int cxDesired, int cyDesired, UINT fuLoad = 0)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		m_hIcon = (HICON) ::LoadImage(ModuleHelper::GetResourceInstance(), icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
+		return m_hIcon;
+	}
+
+#ifndef _WIN32_WCE
+	HICON LoadOEMIcon(LPCTSTR lpstrIconName)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(IsOEMIcon(lpstrIconName));
+		m_hIcon = ::LoadIcon(NULL, lpstrIconName);
+		return m_hIcon;
+	}
+
+	HICON CreateIcon(int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, CONST BYTE* lpbANDbits, CONST BYTE *lpbXORbits)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(lpbANDbits != NULL);
+		ATLASSERT(lpbXORbits != NULL);
+		m_hIcon = ::CreateIcon(ModuleHelper::GetResourceInstance(), nWidth, nHeight, cPlanes, cBitsPixel, lpbANDbits, lpbXORbits);
+		return m_hIcon;
+	}
+
+	HICON CreateIconFromResource(PBYTE pBits, DWORD dwResSize, DWORD dwVersion = 0x00030000)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(pBits != NULL);
+		m_hIcon = ::CreateIconFromResource(pBits, dwResSize, TRUE, dwVersion);
+		return m_hIcon;
+	}
+
+	HICON CreateIconFromResourceEx(PBYTE pbBits, DWORD cbBits, DWORD dwVersion = 0x00030000, int cxDesired = 0, int cyDesired = 0, UINT uFlags = LR_DEFAULTCOLOR)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(pbBits != NULL);
+		ATLASSERT(cbBits > 0);
+		m_hIcon = ::CreateIconFromResourceEx(pbBits, cbBits, TRUE, dwVersion, cxDesired, cyDesired, uFlags);
+		return m_hIcon;
+	}
+#endif // !_WIN32_WCE
+
+	HICON CreateIconIndirect(PICONINFO pIconInfo)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(pIconInfo != NULL);
+		m_hIcon = ::CreateIconIndirect(pIconInfo);
+		return m_hIcon;
+	}
+
+#ifndef _WIN32_WCE
+	HICON ExtractIcon(LPCTSTR lpszExeFileName, UINT nIconIndex)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(lpszExeFileName != NULL);
+		m_hIcon = ::ExtractIcon(ModuleHelper::GetModuleInstance(), lpszExeFileName, nIconIndex);
+		return m_hIcon;
+	}
+
+	HICON ExtractAssociatedIcon(HINSTANCE hInst, LPTSTR lpIconPath, LPWORD lpiIcon)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(lpIconPath != NULL);
+		ATLASSERT(lpiIcon != NULL);
+		m_hIcon = ::ExtractAssociatedIcon(hInst, lpIconPath, lpiIcon);
+		return m_hIcon;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DestroyIcon()
+	{
+		ATLASSERT(m_hIcon != NULL);
+		BOOL bRet = ::DestroyIcon(m_hIcon);
+		if(bRet != FALSE)
+			m_hIcon = NULL;
+		return bRet;
+	}
+
+// Operations
+#ifndef _WIN32_WCE
+	HICON CopyIcon()
+	{
+		ATLASSERT(m_hIcon != NULL);
+		return ::CopyIcon(m_hIcon);
+	}
+
+	HICON DuplicateIcon()
+	{
+		ATLASSERT(m_hIcon != NULL);
+		return ::DuplicateIcon(NULL, m_hIcon);
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DrawIcon(HDC hDC, int x, int y)
+	{
+		ATLASSERT(m_hIcon != NULL);
+#ifndef _WIN32_WCE
+		return ::DrawIcon(hDC, x, y, m_hIcon);
+#else // CE specific
+		return ::DrawIconEx(hDC, x, y, m_hIcon, 0, 0, 0, NULL, DI_NORMAL);
+#endif // _WIN32_WCE
+	}
+
+	BOOL DrawIcon(HDC hDC, POINT pt)
+	{
+		ATLASSERT(m_hIcon != NULL);
+#ifndef _WIN32_WCE
+		return ::DrawIcon(hDC, pt.x, pt.y, m_hIcon);
+#else // CE specific
+		return ::DrawIconEx(hDC, pt.x, pt.y, m_hIcon, 0, 0, 0, NULL, DI_NORMAL);
+#endif // _WIN32_WCE
+	}
+
+	BOOL DrawIconEx(HDC hDC, int x, int y, int cxWidth, int cyWidth, UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL, UINT uFlags = DI_NORMAL)
+	{
+		ATLASSERT(m_hIcon != NULL);
+		return ::DrawIconEx(hDC, x, y, m_hIcon, cxWidth, cyWidth, uStepIfAniCur, hbrFlickerFreeDraw, uFlags);
+	}
+
+	BOOL DrawIconEx(HDC hDC, POINT pt, SIZE size, UINT uStepIfAniCur = 0, HBRUSH hbrFlickerFreeDraw = NULL, UINT uFlags = DI_NORMAL)
+	{
+		ATLASSERT(m_hIcon != NULL);
+		return ::DrawIconEx(hDC, pt.x, pt.y, m_hIcon, size.cx, size.cy, uStepIfAniCur, hbrFlickerFreeDraw, uFlags);
+	}
+
+#ifndef _WIN32_WCE
+	BOOL GetIconInfo(PICONINFO pIconInfo) const
+	{
+		ATLASSERT(m_hIcon != NULL);
+		ATLASSERT(pIconInfo != NULL);
+		return ::GetIconInfo(m_hIcon, pIconInfo);
+	}
+
+#if (_WIN32_WINNT >= 0x0600)
+	BOOL GetIconInfoEx(PICONINFOEX pIconInfo) const
+	{
+		ATLASSERT(m_hIcon != NULL);
+		ATLASSERT(pIconInfo != NULL);
+		return ::GetIconInfoEx(m_hIcon, pIconInfo);
+	}
+#endif // (_WIN32_WINNT >= 0x0600)
+
+#if defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+	HRESULT LoadIconMetric(ATL::_U_STRINGorID icon, int lims)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		USES_CONVERSION;
+		return ::LoadIconMetric(ModuleHelper::GetResourceInstance(), T2CW(icon.m_lpstr), lims, &m_hIcon);
+	}
+
+	HRESULT LoadIconWithScaleDown(ATL::_U_STRINGorID icon, int cx, int cy)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		USES_CONVERSION;
+		return ::LoadIconWithScaleDown(ModuleHelper::GetResourceInstance(), T2CW(icon.m_lpstr), cx, cy, &m_hIcon);
+	}
+
+	HRESULT LoadOEMIconMetric(LPCTSTR lpstrIconName, int lims)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(IsOEMIcon(lpstrIconName));
+		return ::LoadIconMetric(NULL, (LPCWSTR)lpstrIconName, lims, &m_hIcon);
+	}
+
+	HRESULT LoadOEMIconWithScaleDown(LPCTSTR lpstrIconName, int cx, int cy)
+	{
+		ATLASSERT(m_hIcon == NULL);
+		ATLASSERT(IsOEMIcon(lpstrIconName));
+		USES_CONVERSION;
+		return ::LoadIconWithScaleDown(NULL, (LPCWSTR)lpstrIconName, cx, cy, &m_hIcon);
+	}
+#endif // defined(NTDDI_VERSION) && (NTDDI_VERSION >= NTDDI_LONGHORN)
+#endif // !_WIN32_WCE
+
+	// Helper
+#ifndef _WIN32_WCE
+	static bool IsOEMIcon(LPCTSTR lpstrIconName)
+	{
+#if (WINVER >= 0x0600)
+		return (lpstrIconName == IDI_APPLICATION || lpstrIconName == IDI_ASTERISK || lpstrIconName == IDI_EXCLAMATION ||
+		          lpstrIconName == IDI_HAND || lpstrIconName == IDI_QUESTION || lpstrIconName == IDI_WINLOGO ||
+		          lpstrIconName == IDI_SHIELD);
+#else // !(WINVER >= 0x0600)
+		return (lpstrIconName == IDI_APPLICATION || lpstrIconName == IDI_ASTERISK || lpstrIconName == IDI_EXCLAMATION ||
+		          lpstrIconName == IDI_HAND || lpstrIconName == IDI_QUESTION || lpstrIconName == IDI_WINLOGO);
+#endif // !(WINVER >= 0x0600)
+	}
+#endif // !_WIN32_WCE
+};
+
+typedef CIconT<false>   CIconHandle;
+typedef CIconT<true>    CIcon;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCursor
+
+// protect template member from a winuser.h macro
+#ifdef CopyCursor
+  #undef CopyCursor
+#endif
+
+template <bool t_bManaged>
+class CCursorT
+{
+public:
+	HCURSOR m_hCursor;
+
+// Constructor/destructor/operators
+	CCursorT(HCURSOR hCursor = NULL) : m_hCursor(hCursor)
+	{ }
+
+	~CCursorT()
+	{
+		if(t_bManaged && m_hCursor != NULL)
+			DestroyCursor();
+	}
+
+	CCursorT<t_bManaged>& operator =(HCURSOR hCursor)
+	{
+		Attach(hCursor);
+		return *this;
+	}
+
+	void Attach(HCURSOR hCursor)
+	{
+		if(t_bManaged && m_hCursor != NULL)
+			DestroyCursor();
+		m_hCursor = hCursor;
+	}
+
+	HCURSOR Detach()
+	{
+		HCURSOR hCursor = m_hCursor;
+		m_hCursor = NULL;
+		return hCursor;
+	}
+
+	operator HCURSOR() const { return m_hCursor; }
+
+	bool IsNull() const { return m_hCursor == NULL; }
+
+// Create/destroy methods
+	HCURSOR LoadCursor(ATL::_U_STRINGorID cursor)
+	{
+		ATLASSERT(m_hCursor == NULL);
+		m_hCursor = ::LoadCursor(ModuleHelper::GetResourceInstance(), cursor.m_lpstr);
+		return m_hCursor;
+	}
+
+	HCURSOR LoadSysCursor(LPCTSTR lpstrCursorName)
+	{
+		ATLASSERT(m_hCursor == NULL);
+#if (WINVER >= 0x0500)
+		ATLASSERT(lpstrCursorName == IDC_ARROW || lpstrCursorName == IDC_IBEAM || lpstrCursorName == IDC_WAIT ||
+			lpstrCursorName == IDC_CROSS || lpstrCursorName == IDC_UPARROW || lpstrCursorName == IDC_SIZE ||
+			lpstrCursorName == IDC_ICON || lpstrCursorName == IDC_SIZENWSE || lpstrCursorName == IDC_SIZENESW ||
+			lpstrCursorName == IDC_SIZEWE || lpstrCursorName == IDC_SIZENS || lpstrCursorName == IDC_SIZEALL ||
+			lpstrCursorName == IDC_NO || lpstrCursorName == IDC_APPSTARTING || lpstrCursorName == IDC_HELP ||
+			lpstrCursorName == IDC_HAND);
+#else // !(WINVER >= 0x0500)
+		ATLASSERT(lpstrCursorName == IDC_ARROW || lpstrCursorName == IDC_IBEAM || lpstrCursorName == IDC_WAIT ||
+			lpstrCursorName == IDC_CROSS || lpstrCursorName == IDC_UPARROW || lpstrCursorName == IDC_SIZE ||
+			lpstrCursorName == IDC_ICON || lpstrCursorName == IDC_SIZENWSE || lpstrCursorName == IDC_SIZENESW ||
+			lpstrCursorName == IDC_SIZEWE || lpstrCursorName == IDC_SIZENS || lpstrCursorName == IDC_SIZEALL ||
+			lpstrCursorName == IDC_NO || lpstrCursorName == IDC_APPSTARTING || lpstrCursorName == IDC_HELP);
+#endif // !(WINVER >= 0x0500)
+		m_hCursor = ::LoadCursor(NULL, lpstrCursorName);
+		return m_hCursor;
+	}
+
+	// deprecated
+	HCURSOR LoadOEMCursor(LPCTSTR lpstrCursorName)
+	{
+		return LoadSysCursor(lpstrCursorName);
+	}
+
+	HCURSOR LoadCursor(ATL::_U_STRINGorID cursor, int cxDesired, int cyDesired, UINT fuLoad = 0)
+	{
+		ATLASSERT(m_hCursor == NULL);
+		m_hCursor = (HCURSOR) ::LoadImage(ModuleHelper::GetResourceInstance(), cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
+		return m_hCursor;
+	}
+
+#ifndef _WIN32_WCE
+	HCURSOR LoadCursorFromFile(LPCTSTR pstrFilename)
+	{
+		ATLASSERT(m_hCursor == NULL);
+		ATLASSERT(pstrFilename != NULL);
+		m_hCursor = ::LoadCursorFromFile(pstrFilename);
+		return m_hCursor;
+	}
+#endif // !_WIN32_WCE
+
+#if !defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP)))
+	HCURSOR CreateCursor(int xHotSpot, int yHotSpot, int nWidth, int nHeight, CONST VOID *pvANDPlane, CONST VOID *pvXORPlane)
+	{
+		ATLASSERT(m_hCursor == NULL);
+		m_hCursor = ::CreateCursor(ModuleHelper::GetResourceInstance(), xHotSpot, yHotSpot, nWidth, nHeight, pvANDPlane, pvXORPlane);
+		return m_hCursor;
+	}
+#endif // !defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP)))
+
+#ifndef _WIN32_WCE
+	HCURSOR CreateCursorFromResource(PBYTE pBits, DWORD dwResSize, DWORD dwVersion = 0x00030000)
+	{
+		ATLASSERT(m_hCursor == NULL);
+		ATLASSERT(pBits != NULL);
+		m_hCursor = (HCURSOR)::CreateIconFromResource(pBits, dwResSize, FALSE, dwVersion);
+		return m_hCursor;
+	}
+
+	HCURSOR CreateCursorFromResourceEx(PBYTE pbBits, DWORD cbBits, DWORD dwVersion = 0x00030000, int cxDesired = 0, int cyDesired = 0, UINT uFlags = LR_DEFAULTCOLOR)
+	{
+		ATLASSERT(m_hCursor == NULL);
+		ATLASSERT(pbBits != NULL);
+		ATLASSERT(cbBits > 0);
+		m_hCursor = (HCURSOR)::CreateIconFromResourceEx(pbBits, cbBits, FALSE, dwVersion, cxDesired, cyDesired, uFlags);
+		return m_hCursor;
+	}
+#endif // !_WIN32_WCE
+
+	BOOL DestroyCursor()
+	{
+		ATLASSERT(m_hCursor != NULL);
+#if !defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP)))
+		BOOL bRet = ::DestroyCursor(m_hCursor);
+		if(bRet != FALSE)
+			m_hCursor = NULL;
+		return bRet;
+#else // !(!defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP))))
+		ATLTRACE2(atlTraceUI, 0, _T("Warning: This version of Windows CE does not have ::DestroyCursor()\n"));
+		return FALSE;
+#endif // !(!defined(_WIN32_WCE) || ((_WIN32_WCE >= 0x400) && !(defined(WIN32_PLATFORM_PSPC) || defined(WIN32_PLATFORM_WFSP))))
+	}
+
+// Operations
+#ifndef _WIN32_WCE
+	HCURSOR CopyCursor()
+	{
+		ATLASSERT(m_hCursor != NULL);
+		return (HCURSOR)::CopyIcon((HICON)m_hCursor);
+	}
+#endif // !_WIN32_WCE
+
+#if (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+	BOOL GetCursorInfo(LPCURSORINFO pCursorInfo)
+	{
+		ATLASSERT(m_hCursor != NULL);
+		ATLASSERT(pCursorInfo != NULL);
+		return ::GetCursorInfo(pCursorInfo);
+	}
+#endif // (WINVER >= 0x0500) && !defined(_WIN32_WCE)
+};
+
+typedef CCursorT<false>   CCursorHandle;
+typedef CCursorT<true>    CCursor;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CResource - Wraps a generic Windows resource.
+//             Use it with custom resource types other than the
+//             standard RT_CURSOR, RT_BITMAP, etc.
+
+class CResource
+{
+public:
+	HGLOBAL m_hGlobal;
+	HRSRC m_hResource;
+
+// Constructor/destructor
+	CResource() : m_hGlobal(NULL), m_hResource(NULL)
+	{ }
+
+	~CResource()
+	{
+		Release();
+	}
+
+// Load methods
+	bool Load(ATL::_U_STRINGorID Type, ATL::_U_STRINGorID ID)
+	{
+		ATLASSERT(m_hResource == NULL);
+		ATLASSERT(m_hGlobal == NULL);
+
+		m_hResource = ::FindResource(ModuleHelper::GetResourceInstance(), ID.m_lpstr, Type.m_lpstr);
+		if(m_hResource == NULL)
+			return false;
+
+		m_hGlobal = ::LoadResource(ModuleHelper::GetResourceInstance(), m_hResource);
+		if(m_hGlobal == NULL)
+		{
+			m_hResource = NULL;
+			return false;
+		}
+
+		return true;
+	}
+
+#ifndef _WIN32_WCE
+	bool LoadEx(ATL::_U_STRINGorID Type, ATL::_U_STRINGorID ID, WORD wLanguage)
+	{
+		ATLASSERT(m_hResource == NULL);
+		ATLASSERT(m_hGlobal == NULL);
+
+		m_hResource = ::FindResourceEx(ModuleHelper::GetResourceInstance(), ID.m_lpstr, Type.m_lpstr, wLanguage);
+		if(m_hResource == NULL)
+			return false;
+
+		m_hGlobal = ::LoadResource(ModuleHelper::GetResourceInstance(), m_hResource);
+		if(m_hGlobal == NULL)
+		{
+			m_hResource = NULL;
+			return false;
+		}
+
+		return true;
+	}
+#endif // !_WIN32_WCE
+
+// Misc. operations
+	DWORD GetSize() const
+	{
+		ATLASSERT(m_hResource != NULL);
+		return ::SizeofResource(ModuleHelper::GetResourceInstance(), m_hResource);
+	}
+
+	LPVOID Lock()
+	{
+		ATLASSERT(m_hResource != NULL);
+		ATLASSERT(m_hGlobal != NULL);
+		LPVOID pVoid = ::LockResource(m_hGlobal);
+		ATLASSERT(pVoid != NULL);
+		return pVoid;
+	}
+
+	void Release()
+	{
+		if(m_hGlobal != NULL)
+		{
+			FreeResource(m_hGlobal);
+			m_hGlobal = NULL;
+			m_hResource = NULL;
+		}
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Toolbar resource descriptor
+
+struct _AtlToolBarData
+{
+	WORD wVersion;
+	WORD wWidth;
+	WORD wHeight;
+	WORD wItemCount;
+
+	WORD* items()
+		{ return (WORD*)(this+1); }
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Global functions for loading resources
+
+inline HACCEL AtlLoadAccelerators(ATL::_U_STRINGorID table)
+{
+	return ::LoadAccelerators(ModuleHelper::GetResourceInstance(), table.m_lpstr);
+}
+
+inline HMENU AtlLoadMenu(ATL::_U_STRINGorID menu)
+{
+	return ::LoadMenu(ModuleHelper::GetResourceInstance(), menu.m_lpstr);
+}
+
+inline HBITMAP AtlLoadBitmap(ATL::_U_STRINGorID bitmap)
+{
+	return ::LoadBitmap(ModuleHelper::GetResourceInstance(), bitmap.m_lpstr);
+}
+
+#ifdef OEMRESOURCE
+inline HBITMAP AtlLoadSysBitmap(ATL::_U_STRINGorID bitmap)
+{
+#ifdef _DEBUG
+	WORD wID = (WORD)bitmap.m_lpstr;
+	ATLASSERT(wID >= 32734 && wID <= 32767);
+#endif // _DEBUG
+	return ::LoadBitmap(NULL, bitmap.m_lpstr);
+}
+#endif // OEMRESOURCE
+
+inline HCURSOR AtlLoadCursor(ATL::_U_STRINGorID cursor)
+{
+	return ::LoadCursor(ModuleHelper::GetResourceInstance(), cursor.m_lpstr);
+}
+
+inline HCURSOR AtlLoadSysCursor(LPCTSTR lpCursorName)
+{
+#if (WINVER >= 0x0500)
+	ATLASSERT(lpCursorName == IDC_ARROW || lpCursorName == IDC_IBEAM || lpCursorName == IDC_WAIT ||
+		lpCursorName == IDC_CROSS || lpCursorName == IDC_UPARROW || lpCursorName == IDC_SIZE ||
+		lpCursorName == IDC_ICON || lpCursorName == IDC_SIZENWSE || lpCursorName == IDC_SIZENESW ||
+		lpCursorName == IDC_SIZEWE || lpCursorName == IDC_SIZENS || lpCursorName == IDC_SIZEALL ||
+		lpCursorName == IDC_NO || lpCursorName == IDC_APPSTARTING || lpCursorName == IDC_HELP ||
+		lpCursorName == IDC_HAND);
+#else // !(WINVER >= 0x0500)
+	ATLASSERT(lpCursorName == IDC_ARROW || lpCursorName == IDC_IBEAM || lpCursorName == IDC_WAIT ||
+		lpCursorName == IDC_CROSS || lpCursorName == IDC_UPARROW || lpCursorName == IDC_SIZE ||
+		lpCursorName == IDC_ICON || lpCursorName == IDC_SIZENWSE || lpCursorName == IDC_SIZENESW ||
+		lpCursorName == IDC_SIZEWE || lpCursorName == IDC_SIZENS || lpCursorName == IDC_SIZEALL ||
+		lpCursorName == IDC_NO || lpCursorName == IDC_APPSTARTING || lpCursorName == IDC_HELP);
+#endif // !(WINVER >= 0x0500)
+	return ::LoadCursor(NULL, lpCursorName);
+}
+
+inline HICON AtlLoadIcon(ATL::_U_STRINGorID icon)
+{
+	return ::LoadIcon(ModuleHelper::GetResourceInstance(), icon.m_lpstr);
+}
+
+#ifndef _WIN32_WCE
+inline HICON AtlLoadSysIcon(LPCTSTR lpIconName)
+{
+#if (WINVER >= 0x0600)
+	ATLASSERT(lpIconName == IDI_APPLICATION || lpIconName == IDI_ASTERISK || lpIconName == IDI_EXCLAMATION ||
+	          lpIconName == IDI_HAND || lpIconName == IDI_QUESTION || lpIconName == IDI_WINLOGO ||
+	          lpIconName == IDI_SHIELD);
+#else // !(WINVER >= 0x0600)
+	ATLASSERT(lpIconName == IDI_APPLICATION || lpIconName == IDI_ASTERISK || lpIconName == IDI_EXCLAMATION ||
+	          lpIconName == IDI_HAND || lpIconName == IDI_QUESTION || lpIconName == IDI_WINLOGO);
+#endif // !(WINVER >= 0x0600)
+	return ::LoadIcon(NULL, lpIconName);
+}
+#endif // !_WIN32_WCE
+
+inline HBITMAP AtlLoadBitmapImage(ATL::_U_STRINGorID bitmap, UINT fuLoad = LR_DEFAULTCOLOR)
+{
+	return (HBITMAP)::LoadImage(ModuleHelper::GetResourceInstance(), bitmap.m_lpstr, IMAGE_BITMAP, 0, 0, fuLoad);
+}
+
+inline HCURSOR AtlLoadCursorImage(ATL::_U_STRINGorID cursor, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
+{
+	return (HCURSOR)::LoadImage(ModuleHelper::GetResourceInstance(), cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
+}
+
+inline HICON AtlLoadIconImage(ATL::_U_STRINGorID icon, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
+{
+	return (HICON)::LoadImage(ModuleHelper::GetResourceInstance(), icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
+}
+
+#ifdef OEMRESOURCE
+inline HBITMAP AtlLoadSysBitmapImage(WORD wBitmapID, UINT fuLoad = LR_DEFAULTCOLOR)
+{
+	ATLASSERT(wBitmapID >= 32734 && wBitmapID <= 32767);
+	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);   // this one doesn't load from a file
+	return (HBITMAP)::LoadImage(NULL, MAKEINTRESOURCE(wBitmapID), IMAGE_BITMAP, 0, 0, fuLoad);
+}
+#endif // OEMRESOURCE
+
+inline HCURSOR AtlLoadSysCursorImage(ATL::_U_STRINGorID cursor, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
+{
+#ifdef _DEBUG
+	WORD wID = (WORD)cursor.m_lpstr;
+	ATLASSERT((wID >= 32512 && wID <= 32516) || (wID >= 32640 && wID <= 32648) || (wID == 32650) || (wID == 32651));
+	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);   // this one doesn't load from a file
+#endif // _DEBUG
+	return (HCURSOR)::LoadImage(NULL, cursor.m_lpstr, IMAGE_CURSOR, cxDesired, cyDesired, fuLoad);
+}
+
+inline HICON AtlLoadSysIconImage(ATL::_U_STRINGorID icon, UINT fuLoad = LR_DEFAULTCOLOR | LR_DEFAULTSIZE, int cxDesired = 0, int cyDesired = 0)
+{
+#ifdef _DEBUG
+	WORD wID = (WORD)icon.m_lpstr;
+	ATLASSERT(wID >= 32512 && wID <= 32517);
+	ATLASSERT((fuLoad & LR_LOADFROMFILE) == 0);   // this one doesn't load from a file
+#endif // _DEBUG
+	return (HICON)::LoadImage(NULL, icon.m_lpstr, IMAGE_ICON, cxDesired, cyDesired, fuLoad);
+}
+
+#if (_ATL_VER < 0x0700)
+inline int AtlLoadString(UINT uID, LPTSTR lpBuffer, int nBufferMax)
+{
+	return ::LoadString(ModuleHelper::GetResourceInstance(), uID, lpBuffer, nBufferMax);
+}
+#else
+    
+using ATL::AtlLoadString;
+
+#endif // (_ATL_VER < 0x0700)
+
+#ifdef _WIN32_WCE // CE only direct access to the resource
+inline LPCTSTR AtlLoadString(UINT uID)
+{
+	LPCTSTR s = (LPCTSTR)::LoadString(ModuleHelper::GetResourceInstance(), uID, NULL, 0);
+#ifdef DEBUG // Check for null-termination
+	if(s != NULL)
+		// Note: RC -n <file.rc> compiles null-terminated resource strings
+		ATLASSERT(s[*((WORD*)s -1) - 1] == L'\0');
+#endif
+	return s;
+}
+#endif // _WIN32_WCE
+
+inline bool AtlLoadString(UINT uID, BSTR& bstrText)
+{
+	USES_CONVERSION;
+	ATLASSERT(bstrText == NULL);
+
+	LPTSTR lpstrText = NULL;
+	int nRes = 0;
+	for(int nLen = 256; ; nLen *= 2)
+	{
+		ATLTRY(lpstrText = new TCHAR[nLen]);
+		if(lpstrText == NULL)
+			break;
+		nRes = ::LoadString(ModuleHelper::GetResourceInstance(), uID, lpstrText, nLen);
+		if(nRes < nLen - 1)
+			break;
+		delete [] lpstrText;
+		lpstrText = NULL;
+	}
+
+	if(lpstrText != NULL)
+	{
+		if(nRes != 0)
+			bstrText = ::SysAllocString(T2OLE(lpstrText));
+		delete [] lpstrText;
+	}
+
+	return (bstrText != NULL) ? true : false;
+}
+
+}; // namespace WTL
+
+#endif // __ATLUSER_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlwince.h b/GLideN64/src/GLideNUI-wtl/WTL/atlwince.h
new file mode 100644
index 00000000..a06bcdd9
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlwince.h
@@ -0,0 +1,2987 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLWINCE_H__
+#define __ATLWINCE_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlwince.h requires atlapp.h to be included first
+#endif
+
+#ifndef __ATLWIN_H__
+	#error atlwince.h requires atlwin.h to be included first
+#endif
+
+#ifndef _WIN32_WCE
+	#error atlwince.h compiles under Windows CE only
+#endif
+
+#if (_WIN32_WCE < 300)
+	#error atlwince.h requires Windows CE 3.0 or higher.
+#endif
+
+#if defined(WIN32_PLATFORM_WFSP) &&  _MSC_VER < 1400 // EVC compiling SmartPhone code
+  #if (WIN32_PLATFORM_WFSP < 200)
+	#error atlwince.h requires Smartphone 2003 or higher
+  #endif
+#endif // WIN32_PLATFORM_WFSP
+
+#if defined(WIN32_PLATFORM_PSPC) &&  _MSC_VER < 1400 // EVC compiling Pocket PC code
+  #if (WIN32_PLATFORM_PSPC < 310)
+	#error atlwince.h requires Pocket PC 2002 or higher
+  #endif
+#endif // WIN32_PLATFORM_PSPC
+
+#if !defined(_AYGSHELL_H_) && !defined(__AYGSHELL_H__)
+	#error atlwince.h requires aygshell.h to be included first
+#else
+  #if defined(WIN32_PLATFORM_WFSP) && !defined(_TPCSHELL_H_)
+	#error SmartPhone dialog classes require tpcshell.h to be included first
+  #endif
+#endif
+
+#if (_MSC_VER >= 1400) // VS2005
+  #include <DeviceResolutionAware.h>
+  #define _WTL_CE_DRA
+#endif // (_MSC_VER >= 1400)
+
+#if !defined(_WTL_CE_NO_DIALOGS) &&  !defined(__ATLFRAME_H__)
+	#error Orientation aware dialog classes require atlframe.h to be included first
+#endif
+
+#if !defined(_WTL_CE_NO_APPWINDOW) &&  !defined(__ATLFRAME_H__)
+	#error Application window class require atlframe.h to be included first
+#endif
+
+#if !defined(_WTL_CE_NO_ZOOMSCROLL) &&  !defined(__ATLSCRL_H__)
+	#error ZoomScroll implementation requires atlscrl.h to be included first
+#endif
+
+#if !defined(_WTL_CE_NO_ZOOMSCROLL)
+  #if !(defined(__ATLTYPES_H__) || (defined(__ATLMISC_H__) && !defined(_WTL_NO_WTYPES)))
+	#error ZoomScroll requires _WTL_NO_WTYPES not to be defined and either atlmisc.h or atltypes.h to be included first
+  #endif // !(defined(__ATLTYPES_H__) || (defined(__ATLMISC_H__) && !defined(_WTL_NO_WTYPES)))
+#endif // !defined(_WTL_CE_NO_ZOOMSCROLL)
+
+#if !defined(WIN32_PLATFORM_WFSP) && !defined(WIN32_PLATFORM_PSPC)
+  #define _WTL_CE_NO_CONTROLS
+#endif // !defined(WIN32_PLATFORM_WFSP) && !defined(WIN32_PLATFORM_PSPC)
+
+#ifndef _WTL_CE_NO_CONTROLS
+  #ifndef __ATLCTRLS_H__
+	#error The PPC/SmartPhone controls classes require atlctrls.h to be included first
+  #endif
+
+  #include <htmlctrl.h>
+  #pragma comment(lib, "htmlview.lib")
+
+  #include <voicectl.h>
+  #pragma comment(lib, "voicectl.lib")
+
+  #ifdef WIN32_PLATFORM_PSPC
+    #include <richink.h>
+    #pragma comment(lib, "richink.lib")
+
+    #include <inkx.h>
+    #pragma comment(lib, "inkx.lib")
+
+    #include <doclist.h>
+    #pragma comment(lib, "doclist.lib")
+  #endif
+#endif
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// CStdDialogBase<T, t_shidiFlags, t_bModal> : Standard PPC/SmartPhone dialog base class
+// CStdDialogImplBase - Base implementation of standard dialog
+// CStdDialogImpl<T, t_shidiFlags, t_bModal> : Standard dialog implementation
+// CStdIndirectDialogImpl - implementation of standard indirect PPC/SmartPhone dialog
+// CStdAxDialogImpl<T, t_shidiFlags, t_bModal> : Standard AxDialog implementation
+// CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags> : Standard simple dialog
+// CStdDialogResizeImplBase - Base implementation of orientation resizing standard dialog
+// CStdDialogResizeImpl<T, t_shidiFlags, t_bModal> : Orientation resizing standard dialog implementation
+// CStdAxDialogResizeImpl - implementation of orientation resizing standard AxDialog
+// CStdSimpleDialogResizeImpl<T, t_wDlgTemplateID, t_shidiFlags> : Standard resizing simple dialog implementation
+// CStdOrientedDialogBase - Oriented PPC standard dialog base class
+// CStdOrientedDialogImplBase - Oriented PPC standard dialog base implementation
+// CStdOrientedDialogImpl<T, t_shidiFlags, t_bModal> : Oriented PPC standard dialog implementation
+// CStdAxOrientedDialogImpl - Oriented PPC standard AxDialog implementation
+// CStdSimpleOrientedDialog<t_wDlgTemplateID, t_wDlgLandscapeID, t_shidiFlags> : Standard simple orientable dialog
+//
+// CAppInfoBase	 : Helper for application state save/restore to registry
+// CAppInfoT<T> : CAppInfoBase constructed from a CAppWindow<T>
+// CAppWindowBase<T> : Base class for PPC/SmartPhone well-behaved application window or dialog
+// CAppWindow<T> : PPC/SmartPhone well-behaved application window class
+// CAppDialog<T> : PPC/SmartPhone well-behaved application dialog class
+// CAppStdDialogImplBase - Base implementation of standard application dialogs
+// CAppStdDialogImpl<T, t_shidiFlags, t_bModal> : Implementation of standard application dialog
+// CAppStdDialogResizeImpl - implementation of orientation resizing standard application dialog
+// CAppStdAxDialogImpl - Implementation of standard application AxDialog 
+// CAppStdAxDialogResizeImpl - implementation of orientation resizing standard application AxDialog
+// CAppStdOrientedDialogImpl - implementation of oriented PPC standard application dialog
+// CAppStdAxOrientedDialogImpl - implementation of oriented PPC standard application AxDialog
+//
+// CFullScreenFrame<T, t_bHasSip> : Full screen frame class
+//
+// CZoomScrollImpl<T> : WinCE zooming implementation
+//
+// CBottomTabViewImpl<T, TBase, TWinTraits> - CBottomTabView 
+// CHtmlCtrlT<TBase> - CHtmlCtrl
+// CRichInkCtrlT<TBase> - CRichInkCtrl
+// CInkXCtrlT<TBase> - CInkXCtrl
+// CVoiceRecorderCtrlT<TBase> - CVoiceRecorderCtrl
+// CDocListCtrlT<TBase> - CDocListCtrl
+// CCapEditT<TBase> - CCapEdit
+// CTTStaticT<TBase> - CTTStatic
+// CTTButtonT<TBase> - CTTButton
+//
+// CSpinCtrlT<TBase> - CSpinCtrl : SmartPhone specific UpDown control
+// CSpinned<TBase, t_bExpandOnly> : SmartPhone association of control and Spin
+// CSpinListBox : SmartPhone spinned ListBox control
+// CExpandListBox : SmartPhone expandable ListBox control
+// CExpandEdit : SmartPhone expandable Edit control
+// CExpandCapEdit : SmartPhone expandable CapEdit control
+//
+// Global functions:
+//   AtlCreateMenuBar()
+//   AtlCreateEmptyMenuBar()
+//   AtlIsEditFocus()
+//   AtlActivateBackKey()
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// MenuBar creation functions for property sheets and dialogs
+// Frame windows use CreateSimpleCEMenuBar
+
+inline HWND AtlCreateMenuBar(SHMENUBARINFO& mbi)
+{
+	ATLASSERT(::IsWindow(mbi.hwndParent));
+	ATLVERIFY(::SHCreateMenuBar(&mbi) != FALSE);
+	return mbi.hwndMB;
+};
+
+inline HWND AtlCreateMenuBar(HWND hWnd, UINT nToolBarId = ATL_IDW_TOOLBAR, DWORD dwFlags = 0, int nBmpId = 0, int cBmpImages = 0, COLORREF clrBk = 0)
+{
+	SHMENUBARINFO mbi = { sizeof(mbi), hWnd, dwFlags, nToolBarId, ModuleHelper::GetResourceInstance(), nBmpId, cBmpImages, 0, clrBk };
+	return AtlCreateMenuBar(mbi);
+}
+
+inline HWND AtlCreateEmptyMenuBar(HWND hWnd, bool bSip = true)
+{
+	SHMENUBARINFO embi = { sizeof(SHMENUBARINFO), hWnd, SHCMBF_EMPTYBAR };
+	if (!bSip)
+		embi.dwFlags |= SHCMBF_HIDESIPBUTTON;
+	
+	return AtlCreateMenuBar(embi);
+}
+	
+///////////////////////////////////////////////////////////////////////////////
+// Helper functions for SmartPhone back key handling
+
+inline bool AtlIsEditFocus()
+{
+	ATL::CWindow wCtrl = GetFocus();
+	if (wCtrl.IsWindow())
+	{
+		TCHAR szClassName[8] = {0};
+		ATLVERIFY(::GetClassName(wCtrl.m_hWnd, szClassName, 8));
+		return !_tcscmp(szClassName, _T("Edit")) || !_tcscmp(szClassName, WC_CAPEDIT);
+	}
+	return false;
+}
+
+#if defined WIN32_PLATFORM_WFSP
+inline void AtlActivateBackKey(HWND hMenuBar)
+{
+	ATLASSERT(::IsWindow(hMenuBar));
+	::SendMessage(hMenuBar, SHCMBM_OVERRIDEKEY, VK_TBACK,
+		MAKELPARAM(SHMBOF_NODEFAULT | SHMBOF_NOTIFY, SHMBOF_NODEFAULT | SHMBOF_NOTIFY));
+}
+#endif // WIN32_PLATFORM_WFSP
+
+// --- Standard PPC/SmartPhone dialogs ---
+
+#ifndef _WTL_CE_NO_DIALOGS
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdDialogBase - base class for standard PPC/SmartPhone dialogs
+
+#define WTL_STD_SHIDIF   SHIDIF_DONEBUTTON | SHIDIF_SIPDOWN | SHIDIF_SIZEDLGFULLSCREEN
+#define WTL_SP_SHIDIF    SHIDIF_SIZEDLGFULLSCREEN
+
+// Title setting macros
+#define WTL_DLG_TITLEHEIGHT(iHeight) static const int GetTitleHeight(){return iHeight;}
+#define WTL_DLG_NOTITLE	 WTL_DLG_TITLEHEIGHT(0)
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdDialogBase - Base class for standard PPC/SmartPhone dialog
+
+template <class T, UINT t_shidiFlags, bool t_bModal = true>
+class CStdDialogBase
+{
+public:
+#ifdef WIN32_PLATFORM_PSPC
+// Pocket PC only Dialog title handling
+	const int nTitleHeight;
+
+	CStdDialogBase() : nTitleHeight(T::GetTitleHeight())
+	{ }
+
+// Overloads
+	BOOL GetClientRect(LPRECT lpRect) 
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		BOOL bRes = ::GetClientRect(pT->m_hWnd, lpRect);
+		if (nTitleHeight)
+			lpRect->top += nTitleHeight + 1;
+		return bRes;
+	}
+
+	BOOL SetWindowText(LPCTSTR lpszString)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		BOOL bRes = ::SetWindowText(pT->m_hWnd, lpszString);
+		if (nTitleHeight != 0)
+			pT->DoPaintTitle();
+		return bRes;
+	}
+
+// Overrideables
+	static const int GetTitleHeight()
+	{
+	#ifdef _WTL_CE_DRA
+		return DRA::SCALEY(24);
+	#else // !_WTL_CE_DRA
+		CWindowDC dc(NULL);
+		return dc.GetDeviceCaps(LOGPIXELSY) >> 2; // LOGPIXELSY * 24 / 96,
+	#endif // !_WTL_CE_DRA
+	}
+
+	// Title painting
+	bool DoPaintTitle()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		TCHAR sTitle[48];
+
+		// Preparation
+		CPaintDC dc(pT->m_hWnd);
+		CFont fontTitle = AtlCreateBoldFont();
+		CFontHandle fontOld = dc.SelectFont(fontTitle);
+		dc.SetTextColor(GetSysColor(COLOR_HIGHLIGHT));
+		int nLen = pT->GetWindowText(sTitle, 48);
+		int nWidth = dc.GetDeviceCaps(HORZRES);
+
+		// Display title text
+		RECT rTitle = { 0, 0, nWidth, nTitleHeight };
+		dc.FillRect(&rTitle, COLOR_3DHIGHLIGHT);
+	#ifdef _WTL_CE_DRA
+		rTitle.left = DRA::SCALEX(8);
+	#else // !_WTL_CE_DRA
+		rTitle.left = nTitleHeight / 3; // 8 == 24 / 3
+	#endif // !_WTL_CE_DRA
+		dc.DrawText(sTitle, nLen, &rTitle, DT_VCENTER | DT_SINGLELINE);
+		dc.SelectFont(fontOld);
+
+		// Draw bottom line, 2 pixels thick if HI_RES_AWARE
+		CPenHandle penOld = dc.SelectStockPen(BLACK_PEN);
+		POINT line[4] = {{0, nTitleHeight}, {nWidth, nTitleHeight}, {0, nTitleHeight - 1}, {nWidth, nTitleHeight - 1}};
+
+	#ifdef _WTL_CE_DRA
+		int nSeg = DRA::SCALEY(1);
+	#else // !_WTL_CE_DRA
+		int nSeg = nTitleHeight / 24; 
+	#endif // !_WTL_CE_DRA
+
+		dc.Polyline(line, nSeg <= 2 ? nSeg * 2 : 4);
+		dc.SelectPen(penOld);
+
+		return false;
+	}
+
+	// Title preparation: move the dialog controls down to make room for title
+	void DialogTitleInit()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+
+		ATL::CWindow wCtl = pT->GetWindow(GW_CHILD);
+		while (wCtl.IsWindow())
+		{
+			RECT rCtl = { 0 };
+			wCtl.GetWindowRect(&rCtl);
+			::MapWindowPoints(NULL, pT->m_hWnd, (LPPOINT)&rCtl, 2);
+			::OffsetRect(&rCtl, 0, nTitleHeight);
+			wCtl.MoveWindow(&rCtl, FALSE);
+			wCtl = wCtl.GetWindow(GW_HWNDNEXT);
+		}
+	}
+
+	// SIP management
+	void DoSipInfo()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+
+		SIPINFO si = {sizeof(SIPINFO)};
+		SipGetInfo(&si);
+		if ((si.fdwFlags & SIPF_ON) ^ SIPF_ON) 
+			si.rcVisibleDesktop.bottom = si.rcSipRect.bottom;
+		pT->MoveWindow(&si.rcVisibleDesktop, FALSE);
+	}
+
+// Title painting handler
+	LRESULT OnPaintTitle(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		return bHandled = nTitleHeight ? pT->DoPaintTitle() : FALSE;
+	}
+
+// SIP handler
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		if (wParam == SPI_SETSIPINFO)
+		{
+			pT->DoSipInfo();
+			return TRUE;
+		}
+		return bHandled = FALSE;
+	}
+
+#elif defined WIN32_PLATFORM_WFSP
+// SmartPhone VK_TBACK key standard management
+	LRESULT OnHotKey(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		const UINT uModif = (UINT)LOWORD(lParam);
+		const UINT uVirtKey = (UINT)HIWORD(lParam);
+
+		if(uVirtKey == VK_TBACK)
+			if (AtlIsEditFocus())
+				::SHSendBackToFocusWindow(uMsg, wParam, lParam);
+			else if (uModif & MOD_KEYUP)
+					pT->StdCloseDialog(IDCANCEL);
+		return 1;
+	}
+
+ // SmartPhone MenuBar and VK_TBACK key initialization
+	void StdSPInit()
+	{
+		T* pT = static_cast<T*>(this);
+		HWND hMenuBar = ::SHFindMenuBar(pT->m_hWnd);
+
+		if (!hMenuBar && (t_shidiFlags & SHIDIF_DONEBUTTON))
+			hMenuBar = CreateMenuBar(ATL_IDM_MENU_DONE);
+
+		if(hMenuBar != NULL)
+			AtlActivateBackKey(hMenuBar);
+	}
+
+	void SetStaticBold()
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+
+		CFontHandle fontBold = AtlCreateBoldFont(pT->GetFont());
+
+		ATL::CWindow wCtl = pT->GetWindow(GW_CHILD);
+
+		while (wCtl.IsWindow())
+		{
+			if ((short int)wCtl.GetDlgCtrlID() == IDC_STATIC)
+				wCtl.SetFont(fontBold);
+			wCtl = wCtl.GetWindow(GW_HWNDNEXT);
+		}
+	}
+#endif // WIN32_PLATFORM_WFSP
+
+// Platform dependant initialization
+	void StdPlatformInit()
+	{
+		T* pT = static_cast<T*>(this);
+#ifdef WIN32_PLATFORM_PSPC // Pocket PC title initialization
+		if (nTitleHeight != 0)
+			pT->DialogTitleInit();
+#elif defined(WIN32_PLATFORM_WFSP)
+		pT->StdSPInit();
+		SetStaticBold();
+#endif // WIN32_PLATFORM_WFSP
+	}
+
+	// Menu bar creation
+	HWND CreateMenuBar(UINT uiMB = T::IDD, int nBmpImages = 0)
+	{
+		T* pT = static_cast<T*>(this);
+		return AtlCreateMenuBar(pT->m_hWnd, uiMB, 0, nBmpImages ? uiMB : 0, nBmpImages);
+	}
+
+	// Dialog closing
+	void StdCloseDialog(WORD wID)
+	{
+		T* pT = static_cast<T*>(this);
+		if (t_bModal)
+			::EndDialog(pT->m_hWnd, wID);
+		else
+			pT->DestroyWindow();
+	}
+
+	// Shell dialog layout initialization
+	void StdShidInit()
+	{
+		T* pT = static_cast<T*>(this);
+		SHINITDLGINFO shidi = { SHIDIM_FLAGS, pT->m_hWnd, t_shidiFlags };
+		::SHInitDialog(&shidi);
+	}
+
+// IDC_INFOSTATIC background setting
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		if (::GetDlgCtrlID((HWND)lParam) == IDC_INFOSTATIC)
+		{
+			::SetBkMode((HDC)wParam, TRANSPARENT);
+			return (LRESULT)::GetSysColorBrush(COLOR_INFOBK);
+		}
+		return bHandled = FALSE;
+	}
+
+// Menu dialog ending
+	LRESULT OnMenuClose(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->StdCloseDialog((WORD)(wID - ID_MENU_OK + IDOK));
+		return 0;
+	}
+
+// Standard dialog ending: may be used with any command
+	LRESULT OnCloseCmd(WORD /*wNotifyCode*/, WORD wID, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->StdCloseDialog(wID);
+		return 0;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdDialogImplBase - Base implementation of standard PPC/SmartPhone dialog
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true, class TBase = ATL::CDialogImpl< T > >
+class ATL_NO_VTABLE CStdDialogImplBase :
+		public TBase,
+		public CStdDialogBase<T, t_shidiFlags, t_bModal>
+{
+public:
+#ifdef WIN32_PLATFORM_PSPC
+	BOOL GetClientRect(LPRECT lpRect) 
+	{
+		return CStdDialogBase<T, t_shidiFlags, t_bModal>::GetClientRect(lpRect);
+	}
+
+	BOOL SetWindowText(LPCTSTR lpszString)
+	{
+		return CStdDialogBase<T, t_shidiFlags, t_bModal>::SetWindowText(lpszString);
+	}
+#endif
+
+	BEGIN_MSG_MAP(CStdDialogImplBase)
+#ifdef WIN32_PLATFORM_PSPC // Pocket PC title and SIP
+		MESSAGE_HANDLER(WM_PAINT, OnPaintTitle)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+#elif defined(WIN32_PLATFORM_WFSP) // SmartPhone VK_TBACK key
+		MESSAGE_HANDLER(WM_HOTKEY, OnHotKey)
+#endif
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnCloseCmd)
+		COMMAND_RANGE_HANDLER(ID_MENU_OK, ID_MENU_CANCEL, OnMenuClose)
+	END_MSG_MAP()
+	
+	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _DEBUG
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(t_bModal == pT->m_bModal);
+#endif
+		StdPlatformInit();
+		StdShidInit();
+		return bHandled = FALSE;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdDialogImpl - implementation of standard PPC/SmartPhone dialog
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true >
+class ATL_NO_VTABLE CStdDialogImpl : public CStdDialogImplBase< T, t_shidiFlags, t_bModal>
+{};
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdIndirectDialogImpl - implementation of standard indirect PPC/SmartPhone dialog
+
+#if defined __ATLDLGS_H__ 
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true>
+class ATL_NO_VTABLE CStdIndirectDialogImpl : 
+	public CIndirectDialogImpl< T, CMemDlgTemplate, CStdDialogImpl<T, t_shidiFlags, t_bModal> >
+{
+public:
+	typedef CIndirectDialogImpl< T, CMemDlgTemplate, CStdDialogImpl<T, t_shidiFlags, t_bModal> >	_baseClass;
+	typedef CStdDialogImpl<T, t_shidiFlags, t_bModal> _baseStd;
+
+	void CheckStyle()
+	{
+		// Mobile devices don't support DLGTEMPLATEEX
+		ATLASSERT(!m_Template.IsTemplateEx());
+
+		// Standard dialogs need only DS_CENTER
+		DWORD &dwStyle = m_Template.GetTemplatePtr()->style; 
+		if (dwStyle & DS_CENTER)
+			if(t_bModal)
+			{
+				ATLASSERT((dwStyle & WS_CHILD) != WS_CHILD);
+				dwStyle |= WS_POPUP;
+			}
+			else
+			{
+				if((dwStyle & WS_CHILD) != WS_CHILD)
+					dwStyle |= WS_POPUP;
+			}
+	}
+
+	INT_PTR DoModal(HWND hWndParent = ::GetActiveWindow(), LPARAM dwInitParam = NULL)
+	{
+		ATLASSERT(t_bModal);
+
+		if (!m_Template.IsValid())
+			CreateTemplate();
+
+		CheckStyle();
+
+		return _baseClass::DoModal(hWndParent, dwInitParam);
+	}
+
+	HWND Create(HWND hWndParent, LPARAM dwInitParam = NULL)
+	{
+		ATLASSERT(!t_bModal);
+
+		if (!m_Template.IsValid())
+			CreateTemplate();
+
+		CheckStyle();
+
+		return _baseClass::Create(hWndParent, dwInitParam);
+	}
+
+	BEGIN_MSG_MAP(CStdIndirectDialogImpl)
+		CHAIN_MSG_MAP(_baseStd)
+	END_MSG_MAP()
+
+};
+ 
+#endif // defined __ATLDLGS_H__ 
+
+#ifndef _ATL_NO_HOSTING
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdAxDialogImpl - implementation of standard  PPC/SmartPhone AxDialog
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true >
+class ATL_NO_VTABLE CStdAxDialogImpl : public CStdDialogImplBase< T, t_shidiFlags, t_bModal, ATL::CAxDialogImpl< T > >
+{};
+#endif // _ATL_NO_HOSTING
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdSimpleDialog - standard PPC/SmartPhone simple dialog with SHIDIF_xxx flags
+
+template <WORD t_wDlgTemplateID, UINT t_shidiFlags = WTL_STD_SHIDIF>
+class CStdSimpleDialog :
+		public ATL::CSimpleDialog<t_wDlgTemplateID, FALSE>,
+		public CStdDialogBase<CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags>, t_shidiFlags>
+{
+public:
+	typedef CStdDialogBase<CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags>, t_shidiFlags> baseClass;
+
+#ifdef WIN32_PLATFORM_PSPC
+	BOOL GetClientRect(LPRECT lpRect) 
+	{
+		return baseClass::GetClientRect(lpRect);
+	}
+
+	BOOL SetWindowText(LPCTSTR lpszString)
+	{
+		return baseClass::SetWindowText(lpszString);
+	}
+#endif
+
+	BEGIN_MSG_MAP(CStdSimpleDialog)
+#ifdef WIN32_PLATFORM_PSPC // Pocket PC title and SIP
+		MESSAGE_HANDLER(WM_PAINT, OnPaintTitle)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+#elif defined(WIN32_PLATFORM_WFSP) // SmartPhone VK_TBACK key
+		MESSAGE_HANDLER(WM_HOTKEY, OnHotKey)
+#endif
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_RANGE_HANDLER(ID_MENU_OK, ID_MENU_CANCEL, OnMenuClose)
+		COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, baseClass::OnCloseCmd)
+	END_MSG_MAP()
+
+	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		StdPlatformInit();
+		StdShidInit();
+		return bHandled = FALSE;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdDialogResizeImplBase - Base implementation of orientation resizing standard PPC/SmartPhone dialog
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true, class TBase = ATL::CDialogImpl<T> >
+class ATL_NO_VTABLE CStdDialogResizeImplBase :
+		public CStdDialogImplBase< T, t_shidiFlags, t_bModal, TBase>,
+		public CDialogResize<T>
+{
+public:
+	// Note: BEGIN_DLGRESIZE_MAP is required in the derived class.
+
+	BEGIN_MSG_MAP(CStdResizeDialogImplBase)
+#ifdef WIN32_PLATFORM_PSPC // Pocket PC title
+		MESSAGE_HANDLER(WM_PAINT, OnPaintTitle)
+#elif defined(WIN32_PLATFORM_WFSP) // SmartPhone VK_TBACK key
+		MESSAGE_HANDLER(WM_HOTKEY, OnHotKey)
+#endif
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnCloseCmd)
+		COMMAND_RANGE_HANDLER(ID_MENU_OK, ID_MENU_CANCEL, OnMenuClose)
+		CHAIN_MSG_MAP(CDialogResize< T >)
+	END_MSG_MAP()
+
+	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifdef _DEBUG
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(t_bModal == pT->m_bModal);
+#endif
+		StdPlatformInit();
+		DlgResize_Init(FALSE);
+		StdShidInit();
+		return bHandled = FALSE;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdDialogResizeImpl - implementation of orientation resizing standard PPC/SmartPhone dialog
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true >
+class ATL_NO_VTABLE CStdDialogResizeImpl : public CStdDialogResizeImplBase< T, t_shidiFlags, t_bModal>
+{};
+
+#ifndef _ATL_NO_HOSTING
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdAxDialogResizeImpl - implementation of orientation resizing standard PPC/SmartPhone AxDialog
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true >
+class ATL_NO_VTABLE CStdAxDialogResizeImpl : public CStdDialogResizeImplBase< T, t_shidiFlags, t_bModal, ATL::CAxDialogImpl<T> >
+{};
+#endif // _ATL_NO_HOSTING
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdSimpleDialogResizeImpl - implementation of standard resizing simple dialog with SHIDIF_xxx flags
+
+// Usage:
+//	class CMyDlg : public CStdSimpleDialogResize<CMyDlg,
+//		IDD_MYDLG, SHIDIF_DONEBUTTON | SHIDIF_FULLSCREENNOMENUBAR>
+//	{
+//	public:
+//		BEGIN_DLGRESIZE_MAP(CMyDlg)
+//		...
+//		END_DLGRESIZE_MAP()
+//	};
+
+template <class T, WORD t_wDlgTemplateID, UINT t_shidiFlags = WTL_STD_SHIDIF>
+class ATL_NO_VTABLE CStdSimpleDialogResizeImpl :
+		public CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags>,
+		public CDialogResize< T >
+{
+public:
+	typedef CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags>::baseClass baseClass;
+
+	BEGIN_MSG_MAP(CStdSimpleDialogResizeImpl)
+#ifdef WIN32_PLATFORM_PSPC // Pocket PC title
+		MESSAGE_HANDLER(WM_PAINT, OnPaintTitle)
+#elif defined(WIN32_PLATFORM_WFSP) // SmartPhone VK_TBACK key
+		MESSAGE_HANDLER(WM_HOTKEY, OnHotKey)
+#endif
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, baseClass::OnCloseCmd)
+		COMMAND_RANGE_HANDLER(ID_MENU_OK, ID_MENU_CANCEL, OnMenuClose)
+		CHAIN_MSG_MAP(CDialogResize< T >)
+	END_MSG_MAP()
+
+	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		StdPlatformInit();
+		DlgResize_Init(FALSE);
+		StdShidInit();
+		return bHandled = FALSE;
+	}
+};
+
+#if defined(_WTL_CE_DRA) && defined(WIN32_PLATFORM_PSPC)
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdOrientedDialogBase - Oriented PPC standard dialog base class
+
+template <class T>
+class CStdOrientedDialogBase
+{
+public:
+// Operation
+	BOOL SetOrientation(DRA::DisplayMode mode)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		ATLASSERT(mode == DRA::GetDisplayMode());
+		
+		// Derived dialog must enumerate TWO dialog templates with the same control ids and types ie:
+		// enum { IDD = IDD_MYDLG, IDD_LANDSCAPE = IDD_MYDLG_L };
+		UINT iResource = (mode == DRA::Landscape)? T::IDD_LANDSCAPE : T::IDD;
+
+		BOOL bRes = DRA::RelayoutDialog(ModuleHelper::GetResourceInstance(), pT->m_hWnd, MAKEINTRESOURCE(iResource));
+		pT->OnOrientation(mode);
+		return bRes;
+	}
+
+// Override
+	void OnOrientation(DRA::DisplayMode /*mode*/)
+	{}
+
+// Message handlers
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		if (wParam == SETTINGCHANGE_RESET)
+		{
+			SetOrientation(DRA::GetDisplayMode());
+			pT->StdPlatformInit();
+			pT->StdShidInit();
+		}
+		else if (wParam == SPI_SETSIPINFO)
+		{
+			pT->DoSipInfo();
+			return TRUE;
+		}
+		return bHandled = FALSE;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdOrientedDialogImplBase - Oriented PPC standard dialog base implementation
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true, class TBase = ATL::CDialogImpl<T> >
+class ATL_NO_VTABLE CStdOrientedDialogImplBase :
+		public CStdDialogImplBase< T, t_shidiFlags, t_bModal, TBase>,
+		public CStdOrientedDialogBase<T>
+{
+public:
+	BEGIN_MSG_MAP(CStdOrientedDialogImpl)
+		MESSAGE_HANDLER(WM_PAINT, OnPaintTitle)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, CStdOrientedDialogBase<T>::OnSettingChange)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, OnCloseCmd)
+		COMMAND_RANGE_HANDLER(ID_MENU_OK, ID_MENU_CANCEL, OnMenuClose)
+	END_MSG_MAP()
+
+	LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+#ifdef _DEBUG
+		ATLASSERT(t_bModal == pT->m_bModal);
+#endif
+		if (DRA::GetDisplayMode() == DRA::Landscape)
+			SetOrientation(DRA::Landscape);
+		pT->StdPlatformInit();
+		pT->StdShidInit();
+		return bHandled = FALSE;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdOrientedDialogImpl - Oriented PPC standard dialog implementation
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true >
+class ATL_NO_VTABLE CStdOrientedDialogImpl : public CStdOrientedDialogImplBase< T, t_shidiFlags, t_bModal>
+{};
+
+#ifndef _ATL_NO_HOSTING
+///////////////////////////////////////////////////////////////////////////////
+// CStdAxOrientedDialogImpl - Oriented PPC standard AxDialog implementation
+
+template <class T, UINT t_shidiFlags = WTL_STD_SHIDIF, bool t_bModal = true >
+class ATL_NO_VTABLE CStdAxOrientedDialogImpl : public CStdOrientedDialogImplBase< T, t_shidiFlags, t_bModal, ATL::CAxDialogImpl<T> >
+{};
+#endif // _ATL_NO_HOSTING
+
+///////////////////////////////////////////////////////////////////////////////
+// CStdSimpleOrientedDialog - Standard simple orientable dialog
+
+template <WORD t_wDlgTemplateID, WORD t_wDlgLandscapeID, UINT t_shidiFlags = WTL_STD_SHIDIF>
+class CStdSimpleOrientedDialog :
+		public CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags>,
+		public CStdOrientedDialogBase<CStdSimpleOrientedDialog<t_wDlgTemplateID, t_wDlgLandscapeID, t_shidiFlags> >
+{
+public:
+	typedef CStdSimpleDialog<t_wDlgTemplateID, t_shidiFlags>::baseClass baseClass;
+	typedef CStdOrientedDialogBase<CStdSimpleOrientedDialog<t_wDlgTemplateID, t_wDlgLandscapeID, t_shidiFlags> > baseOriented;
+
+	enum {IDD = t_wDlgTemplateID, IDD_LANDSCAPE = t_wDlgLandscapeID};
+
+	BEGIN_MSG_MAP(CStdSimpleDialog)
+		MESSAGE_HANDLER(WM_PAINT, OnPaintTitle)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, baseOriented::OnSettingChange)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+		COMMAND_RANGE_HANDLER(IDOK, IDCANCEL, baseClass::OnCloseCmd)
+		COMMAND_RANGE_HANDLER(ID_MENU_OK, ID_MENU_CANCEL, OnMenuClose)
+	END_MSG_MAP()
+
+		LRESULT OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if (DRA::GetDisplayMode() == DRA::Landscape)
+			SetOrientation(DRA::Landscape);
+		StdPlatformInit();
+		StdShidInit();
+		return bHandled = FALSE;
+	}
+};
+
+#endif // _WTL_CE_DRA
+
+
+#endif // _WTL_CE_NO_DIALOGS
+
+
+// --- PPC/SmartPhone application window and helpers ---
+
+#ifndef _WTL_CE_NO_APPWINDOW
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppInfoBase - Helper for application state save/restore to registry
+
+class CAppInfoBase
+{
+public:
+	CRegKeyEx m_Key;
+
+	CAppInfoBase(ATL::_U_STRINGorID sAppKey)
+	{
+		m_Key.Create(HKEY_CURRENT_USER, sAppKey.m_lpstr);
+		ATLASSERT(m_Key.m_hKey);
+	}
+
+	template <class V>
+	LONG Save(V& val, ATL::_U_STRINGorID sName)
+	{
+		return m_Key.SetBinaryValue(sName.m_lpstr, &val, sizeof(V));
+	}
+
+	template <class V>
+	LONG Save(int nb, V& val0, ATL::_U_STRINGorID sName)
+	{
+		return m_Key.SetBinaryValue(sName.m_lpstr, &val0, nb * sizeof(V));
+	}
+
+	template <class V>
+	LONG Restore(V& val, ATL::_U_STRINGorID sName)
+	{
+		ULONG bufSize = sizeof(V);
+		return m_Key.QueryBinaryValue(sName.m_lpstr, &val, &bufSize);
+	}
+
+	template <class V>
+	LONG Restore(int nb, V& val0, ATL::_U_STRINGorID sName)
+	{
+		ULONG bufSize = nb * sizeof(V);
+		return m_Key.QueryBinaryValue(sName.m_lpstr, &val0, &bufSize);
+	}
+
+#if defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	LONG Save(_CSTRING_NS::CString& sval, ATL::_U_STRINGorID sName)
+	{
+		return m_Key.SetStringValue(sName.m_lpstr, sval);
+	}
+
+	LONG Restore(_CSTRING_NS::CString& sval, ATL::_U_STRINGorID sName)
+	{
+		DWORD size = MAX_PATH;
+		LONG res = m_Key.QueryStringValue(sName.m_lpstr, sval.GetBuffer(size), &size);
+		sval.ReleaseBuffer();
+		return res;
+	}
+#else
+  #pragma message("Warning: CAppInfoBase compiles without CString support. Do not use CString in Save or Restore.")
+#endif // defined(_WTL_USE_CSTRING) || defined(__ATLSTR_H__)
+	
+	LONG Save(LPCTSTR sval, ATL::_U_STRINGorID sName)
+	{
+		return m_Key.SetStringValue(sName.m_lpstr, sval);
+	}
+
+	LONG Restore(LPTSTR sval, ATL::_U_STRINGorID sName, DWORD *plength)
+	{
+		return m_Key.QueryStringValue(sName.m_lpstr, sval, plength);
+	}
+	
+	LONG Delete(ATL::_U_STRINGorID sName)
+	{
+		return  m_Key.DeleteValue(sName.m_lpstr);
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppInfoT - CAppInfoBase constructed from a class with T::GetAppKey() 
+
+// Macro for declaring AppKey
+#define DECLARE_APPKEY(uAppKey) \
+	static LPCTSTR GetAppKey() \
+	{ \
+		static LPCTSTR sAppKey = ATL::_U_STRINGorID(uAppKey).m_lpstr; \
+		return sAppKey; \
+	}
+
+template <class T>
+class CAppInfoT : public CAppInfoBase
+{
+public:
+	CAppInfoT() : CAppInfoBase(T::GetAppKey()){}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppWindowBase - Base class for PPC/SmartPhone "well-behaved" application window or dialog
+
+// Macros for declaring frame WNDCLASS and AppKey
+#define DECLARE_APP_FRAME_CLASS(WndClassName, uCommonResourceID, uAppKey) \
+	DECLARE_FRAME_WND_CLASS(WndClassName, uCommonResourceID) \
+	DECLARE_APPKEY(uAppKey)
+
+#define DECLARE_APP_FRAME_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd, uAppKey) \
+	DECLARE_FRAME_WND_CLASS_EX(WndClassName, uCommonResourceID, style, bkgnd) \
+	DECLARE_APPKEY(uAppKey)
+
+template <class T>
+class CAppWindowBase
+{
+public:
+	typedef class CAppInfoT< T > CAppInfo;
+
+#ifndef WIN32_PLATFORM_WFSP
+	SHACTIVATEINFO m_sai; // NoOp on SmartPhones
+#endif // WIN32_PLATFORM_WFSP
+
+	bool m_bHibernate;
+
+	CAppWindowBase< T >() : m_bHibernate(false)
+	{
+#ifndef WIN32_PLATFORM_WFSP
+		SHACTIVATEINFO sai = { sizeof(SHACTIVATEINFO) };
+		m_sai = sai;
+#endif // WIN32_PLATFORM_WFSP
+	};
+
+	// Same as WTL 7.1 AppWizard generated ActivatePreviousInstance + SendMessage WM_COPYDATA
+	static HRESULT ActivatePreviousInstance(HINSTANCE hInstance, LPCTSTR  lpstrCmdLine, bool bDialog)
+	{
+		// requires T does DECLARE_APP_FRAME_CLASS, DECLARE_APP_FRAME_CLASS_EX or DECLARE_APP_DLG_CLASS
+		CFrameWndClassInfo& classInfo = T::GetWndClassInfo();
+
+		ATLVERIFY(::LoadString(hInstance, classInfo.m_uCommonResourceID, classInfo.m_szAutoName, sizeof(classInfo.m_szAutoName)/sizeof(classInfo.m_szAutoName[0])) != 0);
+
+		classInfo.m_wc.lpszClassName = classInfo.m_szAutoName;
+
+		const TCHAR* pszClass = classInfo.m_wc.lpszClassName;
+
+		if(NULL == pszClass || '\0' == *pszClass)
+		{
+			return E_FAIL;
+		}
+
+		const DWORD dRetryInterval = 100;
+		const int iMaxRetries = 25;
+
+		for(int i = 0; i < iMaxRetries; ++i)
+		{
+			HANDLE hMutex = CreateMutex(NULL, FALSE, pszClass);
+
+			DWORD dw = GetLastError();
+
+			if(NULL == hMutex)
+			{
+				HRESULT hr;
+
+				switch(dw)
+				{
+				case ERROR_INVALID_HANDLE:
+					// A non-mutext object with this name already exists.
+					hr = E_INVALIDARG;
+					break;
+				default:
+					// This should never happen...
+					hr = E_FAIL;
+				}
+
+				return hr;
+			}
+
+			// If the mutex already exists, then there should be another instance running
+			if(dw == ERROR_ALREADY_EXISTS)
+			{
+				CloseHandle(hMutex);
+				
+				HWND hwnd = NULL;
+				if (bDialog)
+					hwnd = FindWindow(NULL, pszClass);
+				else
+					hwnd = FindWindow(pszClass, NULL);
+
+				if(hwnd == NULL)
+				{
+					Sleep(dRetryInterval);
+					continue;
+				}
+				else
+				{
+					// Transmit our params to previous instance
+					if (lpstrCmdLine && *lpstrCmdLine)
+					{
+						COPYDATASTRUCT cd = { NULL, sizeof(TCHAR) * (wcslen(lpstrCmdLine) + 1), (PVOID)lpstrCmdLine };
+						::SendMessage(hwnd, WM_COPYDATA, NULL, (LPARAM)&cd);
+					}
+					// Set the previous instance as the foreground window
+					if(0 != SetForegroundWindow(reinterpret_cast<HWND>(reinterpret_cast<ULONG>(hwnd) | 0x1)))
+						return S_FALSE;
+				}
+			}
+			else
+			{
+				return S_OK;
+			}
+		}
+		return S_OK;
+	}
+
+// Operations overriden in derived class
+	bool AppHibernate(bool /*bHibernate*/)
+	{
+		return false;
+	}
+
+	bool AppNewInstance(LPCTSTR /*lpstrCmdLine*/)
+	{
+		return false;
+	}
+
+	void AppSave()
+	{
+	}
+
+#ifdef WIN32_PLATFORM_WFSP 
+	void AppBackKey() 
+	{
+		::SHNavigateBack();
+	}
+#endif
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CAppWindowBase)
+		MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
+#ifdef WIN32_PLATFORM_WFSP
+		MESSAGE_HANDLER(WM_HOTKEY, OnHotKey)
+#else
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+#endif // WIN32_PLATFORM_WFSP
+		MESSAGE_HANDLER(WM_HIBERNATE, OnHibernate)
+		MESSAGE_HANDLER(WM_COPYDATA, OnNewInstance)
+		MESSAGE_HANDLER(WM_CLOSE, OnClose)
+	END_MSG_MAP()
+
+	LRESULT OnActivate(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		if (m_bHibernate)
+			m_bHibernate = pT->AppHibernate(false);
+#ifndef WIN32_PLATFORM_WFSP
+		::SHHandleWMActivate(pT->m_hWnd, wParam, lParam, &m_sai, 0);
+#else
+		wParam;
+		lParam;
+#endif // WIN32_PLATFORM_WFSP
+		 return bHandled = FALSE;
+	}
+
+#ifdef WIN32_PLATFORM_WFSP
+// SmartPhone VK_TBACK key standard management
+	LRESULT OnHotKey(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		const UINT uModif = (UINT)LOWORD(lParam);
+		const UINT uVirtKey = (UINT)HIWORD(lParam);
+		if(uVirtKey == VK_TBACK)
+			if (AtlIsEditFocus())
+				::SHSendBackToFocusWindow(uMsg, wParam, lParam);
+			else if (uModif & MOD_KEYUP)
+				pT->AppBackKey();
+		return 1;
+	}
+
+#else // !WIN32_PLATFORM_WFSP
+// PPC SIP handling
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		bHandled = FALSE;
+		return ::SHHandleWMSettingChange(pT->m_hWnd, wParam, lParam, &m_sai);
+	}
+#endif // !WIN32_PLATFORM_WFSP
+
+	LRESULT OnHibernate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		return m_bHibernate = pT->AppHibernate(true);
+	}
+
+	LRESULT OnNewInstance(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;
+		return pT->AppNewInstance((LPCTSTR)pcds->lpData);
+	}
+
+	LRESULT OnClose(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->AppSave();
+		bHandled = FALSE;
+		return 1;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppWindow - PPC/SmartPhone "well-behaved" application window class
+
+template <class T>
+class CAppWindow : public CAppWindowBase< T >
+{
+public:
+	// Same as WTL 7.1 AppWizard generated Run + lpstrCmdLine in CreateEx
+	static int AppRun(LPTSTR lpstrCmdLine = NULL, int nCmdShow = SW_SHOWNORMAL)
+	{
+		CMessageLoop theLoop;
+		_Module.AddMessageLoop(&theLoop);
+
+		T wndMain;
+
+		if(wndMain.CreateEx(NULL, NULL, 0, 0, lpstrCmdLine) == NULL)
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("Main window creation failed!\n"));
+			return 0;
+		}
+
+		wndMain.ShowWindow(nCmdShow);
+
+		int nRet = theLoop.Run();
+
+		_Module.RemoveMessageLoop();
+		return nRet;
+	}
+
+	static HRESULT ActivatePreviousInstance(HINSTANCE hInstance, LPCTSTR  lpstrCmdLine)
+	{
+		return CAppWindowBase< T >::ActivatePreviousInstance(hInstance, lpstrCmdLine, false);
+	}
+};
+
+
+#ifndef _WTL_CE_NO_DIALOGS
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppDialog - PPC/SmartPhone "well-behaved" dialog application class
+
+// Macro for declaring dialog WNDCLASS and AppKey
+#define DECLARE_APP_DLG_CLASS(WndClassName, uCommonResourceID, uAppKey) \
+	static WTL::CFrameWndClassInfo& GetWndClassInfo() \
+	{ \
+		static WTL::CFrameWndClassInfo wc = \
+		{ \
+			{ 0, (WNDPROC)StartDialogProc, \
+			0, 0, NULL, NULL, NULL, (HBRUSH)(COLOR_WINDOW + 1), NULL, WndClassName }, \
+			NULL, NULL, IDC_ARROW, TRUE, 0, _T(""), uCommonResourceID \
+		}; \
+		return wc; \
+	}; \
+	DECLARE_APPKEY(uAppKey)
+
+template <class T>
+class CAppDialog : public CAppWindowBase< T >
+{
+public:
+	static int AppRun(LPTSTR lpstrCmdLine = NULL, int nCmdShow = SW_SHOWNORMAL)
+	{
+		CMessageLoop theLoop;
+		_Module.AddMessageLoop(&theLoop);
+
+		T dlgMain;
+
+		if(dlgMain.Create(NULL, (LPARAM)lpstrCmdLine) == NULL)
+		{
+			ATLTRACE2(atlTraceUI, 0, _T("Main dialog creation failed!\n"));
+			return 0;
+		}
+
+		dlgMain.ShowWindow(nCmdShow);
+
+		int nRet = theLoop.Run();
+
+		_Module.RemoveMessageLoop();
+		return nRet;
+	}
+
+	static HRESULT ActivatePreviousInstance(HINSTANCE hInstance, LPCTSTR  lpstrCmdLine)
+	{
+		return CAppWindowBase< T >::ActivatePreviousInstance(hInstance, lpstrCmdLine, true);
+	};
+};
+
+// PPC/SmartPhone standard application dialogs
+
+#ifdef WIN32_PLATFORM_WFSP
+#define WTL_APP_SHIDIF WTL_SP_SHIDIF
+#else
+#define WTL_APP_SHIDIF WTL_STD_SHIDIF
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdDialogImplBase - Base implementation of standard application dialogs
+
+template <class T, class TImplBase, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdDialogImplBase :
+		public TImplBase, 
+		public CAppDialog< T >
+{ 
+public:
+	WTL_DLG_NOTITLE;
+
+	void StdCloseDialog(int nVal)
+	{
+		T* pT = static_cast<T*>(this);
+		if (nVal != IDCANCEL)
+			pT->AppSave();
+		if (t_bModal == false)
+		{
+			pT->DestroyWindow();
+			::PostQuitMessage(nVal);
+		}
+		else
+			::EndDialog(pT->m_hWnd, nVal);
+	}
+	
+	BEGIN_MSG_MAP(CAppStdDialogImplBase)
+		MESSAGE_HANDLER(WM_CLOSE, OnSystemClose)
+		CHAIN_MSG_MAP(TImplBase)
+		CHAIN_MSG_MAP(CAppDialog< T >)
+	END_MSG_MAP()
+
+	LRESULT OnSystemClose(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+	{
+		T* pT = static_cast<T*>(this);
+		pT->StdCloseDialog(IDCANCEL);
+		return 0;
+	}
+};
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdDialogImpl - Implementation of standard application dialog 
+
+template <class T, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdDialogImpl :
+		public CAppStdDialogImplBase<T, CStdDialogImpl<T, t_shidiFlags, t_bModal>, t_shidiFlags, t_bModal>
+{};
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdDialogResizeImpl - implementation of orientation resizing standard application dialog
+
+template <class T, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdDialogResizeImpl :
+		public CAppStdDialogImplBase<T, CStdDialogResizeImpl<T, t_shidiFlags, t_bModal>, t_shidiFlags, t_bModal>
+{};
+
+#ifndef _ATL_NO_HOSTING
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdAxDialogImpl - Implementation of standard application AxDialog 
+
+template <class T, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdAxDialogImpl :
+		public CAppStdDialogImplBase<T, CStdAxDialogImpl<T, t_shidiFlags, t_bModal>, t_shidiFlags, t_bModal>
+{};
+
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdAxDialogResizeImpl - implementation of orientation resizing standard application AxDialog
+
+template <class T, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdAxDialogResizeImpl :
+		public CAppStdDialogImplBase<T, CStdAxDialogResizeImpl<T, t_shidiFlags, t_bModal>, t_shidiFlags, t_bModal>
+{};
+#endif // _ATL_NO_HOSTING
+
+#if defined(_WTL_CE_DRA) && defined(WIN32_PLATFORM_PSPC)
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdOrientedDialogImpl - implementation of oriented PPC standard application dialog
+
+template <class T, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdOrientedDialogImpl :
+		public CAppStdDialogImplBase<T, CStdOrientedDialogImpl<T, t_shidiFlags, t_bModal>, t_shidiFlags, t_bModal>
+{};
+
+#ifndef _ATL_NO_HOSTING
+///////////////////////////////////////////////////////////////////////////////
+// CAppStdAxOrientedDialogImpl - implementation of oriented PPC standard application AxDialog
+
+template <class T, UINT t_shidiFlags = WTL_APP_SHIDIF, bool t_bModal = false>
+class ATL_NO_VTABLE CAppStdAxOrientedDialogImpl :
+		public CAppStdDialogImplBase<T, CStdAxOrientedDialogImpl<T, t_shidiFlags, t_bModal>, t_shidiFlags, t_bModal>
+{};
+#endif // _ATL_NO_HOSTING
+
+#endif // defined(_WTL_CE_DRA) && defined(WIN32_PLATFORM_PSPC)
+
+#endif // _WTL_CE_NO_DIALOGS
+
+#endif // _WTL_CE_NO_APPWINDOW
+
+
+// --- Full screen support ---
+
+#ifndef _WTL_CE_NO_FULLSCREEN
+
+///////////////////////////////////////////////////////////////////////////////
+// CFullScreenFrame - full screen frame implementation
+
+template <class T, bool t_bHasSip = true>
+class CFullScreenFrame
+{
+public:
+	bool m_bFullScreen;
+
+	CFullScreenFrame() : m_bFullScreen(false)
+	{ }
+
+// Operation	
+	void SetFullScreen(bool bFull)
+	{
+		m_bFullScreen = bFull;
+		ShowTaskBar(!bFull, false);
+		ShowMenuBar(!bFull);
+	}
+
+// Manage TaskBar for modal dialogs and property sheets
+	template <class D>
+	int FSDoModal(D& dlg)
+	{
+		T* pT = static_cast<T*>(this);
+		pT;   // avoid level 4 warning
+		ATLASSERT(pT->IsWindow());
+		if (m_bFullScreen)   // Show taskbar if hidden
+			ShowTaskBar(true, false);
+		int iRet = dlg.DoModal();
+		if (m_bFullScreen)   // Hide taskbar if restored
+			ShowTaskBar(false);
+		return iRet;
+	}
+
+// Implementation
+	void ShowMenuBar(bool bShow)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		ATL::CWindow MenuBar = pT->m_hWndCECommandBar;
+		ATLASSERT(MenuBar.IsWindow());
+		MenuBar.ShowWindow(bShow ? SW_SHOWNORMAL : SW_HIDE);
+		pT->SizeToMenuBar();
+	}
+	
+	void ShowTaskBar(bool bShow, bool bRepaint = true)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(pT->IsWindow());
+		RECT rect = { 0 };
+		SystemParametersInfo(SPI_GETWORKAREA, NULL, &rect, FALSE);
+		if (!bShow)
+			rect.top = 0;
+
+#ifdef WIN32_PLATFORM_PSPC // Pocket PC code
+		UINT uShow = t_bHasSip ? SHFS_SHOWTASKBAR | SHFS_SHOWSIPBUTTON : SHFS_SHOWTASKBAR | SHFS_HIDESIPBUTTON;		
+		SHFullScreen(pT->m_hWnd, bShow ? uShow : SHFS_HIDETASKBAR | SHFS_HIDESIPBUTTON);
+#elif _WIN32_WCE > 0x500 // Smartphone 2005 code
+		SHFullScreen(pT->m_hWnd, bShow ? SHFS_SHOWTASKBAR : SHFS_HIDETASKBAR);
+#else // Smartphone 2003
+		HWND hTaskBar = FindWindow(_T("tray"), NULL);
+		ATLASSERT(::IsWindow(hTaskBar));
+		::ShowWindow(hTaskBar, bShow ? SW_SHOW : SW_HIDE);
+#endif // WIN32_PLATFORM_PSPC
+
+		pT->MoveWindow(&rect, bRepaint);
+	}
+
+// Message map and handler
+	BEGIN_MSG_MAP(CFullScreenFrame)
+		MESSAGE_HANDLER(WM_SETTINGCHANGE, OnSettingChange)
+		MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
+	END_MSG_MAP()
+
+	LRESULT OnSettingChange(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+#ifndef SETTINGCHANGE_RESET // not defined for PPC 2002
+	#define SETTINGCHANGE_RESET SPI_SETWORKAREA
+#endif
+		if (m_bFullScreen && (wParam == SETTINGCHANGE_RESET))
+			SetFullScreen(m_bFullScreen);
+		return bHandled = FALSE;
+	}
+
+	LRESULT OnActivate(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		if (m_bFullScreen)
+		{
+			ShowTaskBar(!wParam);
+			ShowMenuBar(!wParam);
+		}
+		return bHandled = FALSE;
+	}
+};
+
+#endif // _WTL_CE_NO_FULLSCREEN
+
+
+// --- WinCE zoom support ---
+
+#ifndef _WTL_CE_NO_ZOOMSCROLL
+
+///////////////////////////////////////////////////////////////////////////////
+// CZoomScrollImpl - WinCE zooming implementation on top of CScrollImpl
+
+template <class T>
+class  CZoomScrollImpl: public CScrollImpl< T >
+{
+public:
+// Data members
+	_WTYPES_NS::CSize m_sizeTrue;
+	double	m_fzoom;
+
+// Creation
+	CZoomScrollImpl() : m_sizeTrue(0), m_fzoom(1.)
+	{ }
+
+// Zoom operations and access
+	void SetZoomScrollSize(_WTYPES_NS::CSize sizeTrue, double fzoom = 1., BOOL bRedraw = TRUE)
+	{
+		ATLASSERT(fzoom > 0.);
+		m_sizeTrue = sizeTrue;
+		m_fzoom = fzoom;
+
+		CScrollImpl< T >::SetScrollSize(sizeTrue / fzoom, bRedraw);
+	}
+
+	void SetZoomScrollSize(int cx, int cy, double fzoom=1., BOOL bRedraw = TRUE)
+	{
+		SetZoomScrollSize(_WTYPES_NS::CSize(cx, cy), fzoom, bRedraw);
+	}
+
+	void SetZoom(double fzoom, BOOL bRedraw = TRUE)
+	{
+		_WTYPES_NS::CPoint ptCenter = WndtoTrue(m_sizeClient / 2);
+		_WTYPES_NS::CSize sizePage = GetScrollPage();
+		_WTYPES_NS::CSize sizeLine = GetScrollLine();
+
+		SetZoomScrollSize(GetScrollSize(), fzoom, bRedraw);
+
+		SetScrollLine(sizeLine);
+		SetScrollPage(sizePage);
+		_WTYPES_NS::CPoint ptOffset = ptCenter - (m_sizeClient / 2) * fzoom;
+		SetScrollOffset(ptOffset, bRedraw);
+	}
+
+	double GetZoom()
+	{
+		return m_fzoom;
+	}
+
+// CScrollImpl overrides
+	void SetScrollOffset(int x, int y, BOOL bRedraw = TRUE)
+	{
+		CScrollImpl< T >::SetScrollOffset((int)(x / m_fzoom), (int)(y / m_fzoom), bRedraw);
+	}
+
+	void SetScrollOffset(POINT ptOffset, BOOL bRedraw = TRUE)
+	{
+		SetScrollOffset(ptOffset.x, ptOffset.y, bRedraw);
+	}
+
+	void GetScrollOffset(POINT& ptOffset)
+	{
+		ptOffset.x = (LONG)(m_ptOffset.x * m_fzoom);
+		ptOffset.y = (LONG)(m_ptOffset.y * m_fzoom);
+	}
+
+	void SetScrollSize(int cx, int cy, BOOL bRedraw = TRUE)
+	{
+		SetZoomScrollSize(cx, cy, GetZoom(), bRedraw);
+	}
+
+	void SetScrollSize(SIZE sizeTrue, BOOL bRedraw = TRUE)
+	{
+		SetZoomScrollSize(sizeTrue, GetZoom(), bRedraw);
+	}
+
+	void GetScrollSize(SIZE& sizeTrue) const
+	{
+		sizeTrue = m_sizeTrue;
+	}
+
+	void SetScrollPage(int cxPage, int cyPage)
+	{
+		SetScrollPage(_WTYPES_NS::CSize(cxPage, cyPage));
+	}
+
+	void SetScrollPage(SIZE sizePage)
+	{
+		CScrollImpl< T >::SetScrollPage(sizePage / m_fzoom);
+	}
+
+	void GetScrollPage(SIZE& sizePage) const
+	{
+		sizePage = m_sizePage * m_fzoom;
+	}
+
+	void SetScrollLine(int cxLine, int cyLine)
+	{
+		SetScrollLine(_WTYPES_NS::CSize(cxLine, cyLine));
+	}
+
+	void SetScrollLine(SIZE sizeLine)
+	{
+		CScrollImpl< T >::SetScrollLine(sizeLine / m_fzoom);
+	}
+
+	void GetScrollLine(SIZE& sizeLine) const
+	{
+		sizeLine = m_sizeLine * m_fzoom;
+	}
+
+// Data access complements
+	_WTYPES_NS::CSize GetScrollSize()
+	{
+		return m_sizeTrue;
+	}
+
+	_WTYPES_NS::CSize GetScrollPage()
+	{
+		return m_sizePage * m_fzoom;
+	}
+
+	_WTYPES_NS::CSize GetScrollLine()
+	{
+		return m_sizeLine * m_fzoom;
+	}
+
+	_WTYPES_NS::CPoint GetScrollOffset()
+	{
+		return (_WTYPES_NS::CSize)m_ptOffset * m_fzoom;
+	}
+
+// Helper coordinate functions
+	_WTYPES_NS::CPoint WndtoTrue(CPoint ptW)
+	{
+		return (_WTYPES_NS::CSize)ptW * GetZoom() + GetScrollOffset();
+	}
+
+	void WndtoTrue(LPPOINT aptW, int nPts)   // in place coord transformation
+	{
+		for (int i = 0 ; i < nPts ; i++)
+			aptW[i] = WndtoTrue(aptW[i]);
+	}
+
+	void WndtoTrue(LPRECT prectW)   // in place coord transformation
+	{
+		WndtoTrue((LPPOINT)prectW, 2);
+	}
+
+	_WTYPES_NS::CPoint TruetoWnd(CPoint ptT)
+	{
+		return (ptT - GetScrollOffset()) / GetZoom();
+	}
+
+	void TruetoWnd(LPPOINT aptT, int nPts)   // in place coord transformation
+	{
+		for (int i = 0 ; i < nPts ; i++)
+			aptT[i] = TruetoWnd(aptT[i]);
+	}
+
+	void TruetoWnd(LPRECT prectT)   // in place coord transformation
+	{
+		TruetoWnd((LPPOINT)prectT, 2);
+	}
+
+// Drawing operations : assume adequate setting of data members
+	BOOL Draw(HBITMAP hbm, HDC hdestDC, DWORD dwROP = SRCCOPY)
+	{
+		CDC memDC = CreateCompatibleDC(hdestDC);
+		CBitmapHandle bmpOld = memDC.SelectBitmap(hbm);
+		BOOL bRes = Draw(memDC, hdestDC, dwROP);
+		memDC.SelectBitmap(bmpOld);
+		return bRes;
+	}
+
+	BOOL Draw(HDC hsourceDC, HDC hdestDC, DWORD dwROP = SRCCOPY)
+	{
+		CDCHandle destDC = hdestDC;
+		destDC.SetViewportOrg(0,0);
+		_WTYPES_NS::CPoint ptOffset = GetScrollOffset();
+		_WTYPES_NS::CSize sizeZClient = m_sizeClient * GetZoom();
+		return destDC.StretchBlt(0, 0, m_sizeClient.cx, m_sizeClient.cy, hsourceDC, ptOffset.x, ptOffset.y, sizeZClient.cx, sizeZClient.cy, dwROP);
+	}
+
+#ifdef _IMAGING_H
+	BOOL Draw(IImage* pIImage, HDC hdestDC)
+	{
+		CDCHandle destDC = hdestDC;
+		destDC.SetViewportOrg(0,0);
+		return SUCCEEDED(pIImage->Draw(destDC, _WTYPES_NS::CRect(-_WTYPES_NS::CPoint(m_ptOffset), m_sizeAll), NULL));
+	}
+#endif
+
+// Message map and handlers
+	BEGIN_MSG_MAP(CZoomScrollImpl< T >)
+		MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
+		CHAIN_MSG_MAP(CScrollImpl< T >)
+	END_MSG_MAP()
+	
+	LRESULT OnEraseBkgnd(UINT /*uMsg*/, WPARAM wParam, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = static_cast<T*>(this);
+		ATLASSERT(::IsWindow(pT->m_hWnd));
+		if ((GetScrollExtendedStyle() & SCRL_ERASEBACKGROUND))
+		{
+			_WTYPES_NS::CRect rect;
+			pT->GetClientRect(rect);
+			_WTYPES_NS::CSize sizeClient=rect.Size();
+
+			if (m_sizeAll.cx < sizeClient.cx || m_sizeAll.cy < sizeClient.cy)
+			{
+				CDCHandle hdc = (HDC)wParam;
+				HBRUSH hbr = GetSysColorBrush((int)T::GetWndClassInfo().m_wc.hbrBackground - 1);
+
+				if (m_sizeAll.cx < sizeClient.cx)
+				{
+					_WTYPES_NS::CRect rectBG(_WTYPES_NS::CPoint(m_sizeAll.cx, 0), sizeClient);
+					hdc.FillRect(rectBG, hbr);
+				}
+
+				if (m_sizeAll.cy < sizeClient.cy)
+				{
+					_WTYPES_NS::CRect rectBG(_WTYPES_NS::CPoint(0, m_sizeAll.cy), sizeClient);
+					hdc.FillRect(rectBG, hbr);
+				}
+			}
+		}
+		else
+		{
+			bHandled = FALSE;
+		}
+
+		return 1;
+ 	}
+};
+
+#endif // _WTL_CE_NO_ZOOMSCROLL
+
+#ifndef _WTL_CE_NO_CONTROLS
+
+// --- PPC bottom TabView control ---
+
+#if defined(__ATLCTRLX_H__) && defined(WIN32_PLATFORM_PSPC)
+
+///////////////////////////////////////////////////////////////////////////////
+// CBottomTabViewImpl
+
+template <class T, class TBase = ATL::CWindow, class TWinTraits = ATL::CControlWinTraits>
+class ATL_NO_VTABLE CBottomTabViewImpl : public CTabViewImpl<T, TBase, TWinTraits>
+{
+public:
+	DECLARE_WND_CLASS_EX(NULL, 0, COLOR_APPWORKSPACE)
+
+// Implementation overrideables
+	bool CreateTabControl()
+	{
+		m_tab.Create(m_hWnd, rcDefault, NULL, WS_CHILD | TCS_BOTTOM, 0, m_nTabID);
+
+		ATLASSERT(m_tab.m_hWnd != NULL);
+		if(m_tab.m_hWnd == NULL)
+			return false;
+
+		m_tab.SendMessage(CCM_SETVERSION, COMCTL32_VERSION);
+		m_tab.SetItemExtra(sizeof(TABVIEWPAGE));
+
+		T* pT = static_cast<T*>(this);
+		m_cyTabHeight = pT->CalcTabHeight();
+
+		return true;
+	}
+
+	int CalcTabHeight()
+	{
+		int nCount = m_tab.GetItemCount();
+		TCITEMEXTRA tcix = { 0 };
+		tcix.tciheader.mask = TCIF_TEXT;
+		tcix.tciheader.pszText = _T("NS");
+		int nIndex = m_tab.InsertItem(nCount, tcix);
+
+		RECT rect = { 0 };
+		SystemParametersInfo(SPI_GETWORKAREA, 0, &rect, 0);
+		RECT rcWnd = rect;
+
+		m_tab.AdjustRect(FALSE, &rect);
+		rcWnd.top = rect.bottom;
+		::AdjustWindowRectEx(&rcWnd, m_tab.GetStyle(), FALSE, m_tab.GetExStyle());
+		m_tab.DeleteItem(nIndex);
+
+		return rcWnd.bottom - rcWnd.top;
+	}
+
+	void UpdateLayout()
+	{
+		RECT rect;
+		GetClientRect(&rect);
+
+		if(m_tab.IsWindow() && ((m_tab.GetStyle() & WS_VISIBLE) != 0))
+			m_tab.SetWindowPos(NULL, 0, rect.bottom - m_cyTabHeight, rect.right - rect.left, m_cyTabHeight, SWP_NOZORDER /*| SWP_SHOWWINDOW*/);
+
+		if(m_nActivePage != -1)
+				::SetWindowPos(GetPageHWND(m_nActivePage), NULL, 0, 0, rect.right - rect.left, rect.bottom - m_cyTabHeight, SWP_NOZORDER);
+	}
+
+};
+
+class CBottomTabView : public CBottomTabViewImpl<CBottomTabView>
+{
+public:
+	DECLARE_WND_CLASS_EX(_T("WTL_BottomTabView"), 0, COLOR_APPWORKSPACE)
+};
+
+#endif // defined(__ATLCTRLX_H__) && defined(WIN32_PLATFORM_PSPC)
+
+
+// --- PPC/SmartPhone controls ---
+
+////////////////////////////////////////////////////////////////////////////////
+// These are wrapper classes for the Pocket PC 2002/2003 and SmartPhone 2003 controls
+// To implement a window based on a control, use following:
+// Example: Implementing a window based on a Html control
+//
+// class CMyHtml : CWindowImpl<CMyHtml, CHtmlCtrl>
+// {
+// public:
+//      BEGIN_MSG_MAP(CMyHtml)
+//          // put your message handler entries here
+//      END_MSG_MAP()
+// };
+///////////////////////////////////////////////////////////////////////////////
+
+///////////////////////////////////////////////////////////////////////////////
+// CHtmlCtrl
+
+template <class TBase>
+class CHtmlCtrlT : public TBase
+{
+public:
+// Constructors
+	CHtmlCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CHtmlCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		ATLASSERT(hWnd != NULL);   // Did you remember to call InitHTMLControl(hInstance) ??
+		return hWnd;
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_HTML;
+	}
+
+#if (_WIN32_WCE >= 400)
+	void AddStyle(LPCWSTR pszStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ADDSTYLE, 0, (LPARAM)pszStyle);
+	}
+#endif // (_WIN32_WCE >= 400)
+
+	void AddText(BOOL bPlainText, LPCSTR pszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ADDTEXT, (WPARAM)bPlainText, (LPARAM)pszText);
+	}
+
+	void AddHTML(LPCSTR pszHTML)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ADDTEXT, (WPARAM)FALSE, (LPARAM)pszHTML);
+	}
+
+	void AddText(BOOL bPlainText, LPCWSTR pszText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ADDTEXTW, (WPARAM)bPlainText, (LPARAM)pszText);
+	}
+
+	void AddHTML(LPCWSTR pszHTML)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ADDTEXTW, (WPARAM)FALSE, (LPARAM)pszHTML);
+	}
+
+	void Anchor(LPCSTR pszAnchor)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ANCHOR, 0, (LPARAM)pszAnchor);
+	}
+
+	void Anchor(LPCWSTR pszAnchor)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ANCHORW, 0, (LPARAM)pszAnchor);
+	}
+
+#if (_WIN32_WCE >= 420)
+	void GetBrowserDispatch(IDispatch** ppDispatch)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(ppDispatch);
+		ATLASSERT(*ppDispatch==NULL);
+		::SendMessage(m_hWnd, DTM_BROWSERDISPATCH, 0, (LPARAM)ppDispatch);
+	}
+	void GetDocumentDispatch(IDispatch** ppDispatch)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(ppDispatch);
+		ATLASSERT(*ppDispatch==NULL);
+		::SendMessage(m_hWnd, DTM_DOCUMENTDISPATCH , 0, (LPARAM)ppDispatch);
+	}
+#endif // (_WIN32_WCE >= 420)
+
+	void Clear()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_CLEAR, 0, 0L);
+	}
+
+	void EnableClearType(BOOL bEnable = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ENABLECLEARTYPE, 0, (LPARAM)bEnable);
+	}
+
+	void EnableContextMenu(BOOL bEnable = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ENABLECONTEXTMENU, 0, (LPARAM)bEnable);
+	}
+
+	void EnableScripting(BOOL bEnable = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ENABLESCRIPTING, 0, (LPARAM)bEnable);
+	}
+
+	void EnableShrink(BOOL bEnable = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ENABLESHRINK, 0, (LPARAM)bEnable);
+	}
+
+	void EndOfSource()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ENDOFSOURCE, 0, 0L);
+	}
+
+	void ImageFail(DWORD dwCookie)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_IMAGEFAIL, 0, (LPARAM)dwCookie);
+	}
+
+	int GetLayoutHeight() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DTM_LAYOUTHEIGHT, 0, 0L);
+	}
+
+	int GetLayoutWidth() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DTM_LAYOUTWIDTH, 0, 0L);
+	}
+
+	void Navigate(LPCTSTR pstrURL, UINT uFlags = 0)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrURL);
+		::SendMessage(m_hWnd, DTM_NAVIGATE, (WPARAM)uFlags, (LPARAM)pstrURL);
+	}
+
+	void SelectAll()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_SELECTALL, 0, 0L);
+	}
+
+	void SetImage(INLINEIMAGEINFO* pImageInfo)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pImageInfo);
+		::SendMessage(m_hWnd, DTM_SETIMAGE, 0, (LPARAM)pImageInfo);
+	}
+
+	void ZoomLevel(int iLevel)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_ZOOMLEVEL, 0, (LPARAM)iLevel);
+	}
+
+#if (_WIN32_WCE >= 400)
+	void Stop()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DTM_STOP, 0, 0L);
+	}
+#endif // (_WIN32_WCE >= 400)
+
+	void GetScriptDispatch(IDispatch** ppDispatch)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(ppDispatch);
+		ATLASSERT(*ppDispatch==NULL);
+		::SendMessage(m_hWnd, DTM_SCRIPTDISPATCH, 0, (LPARAM)ppDispatch);
+	}
+};
+
+typedef CHtmlCtrlT<ATL::CWindow> CHtmlCtrl;
+
+
+#ifdef WIN32_PLATFORM_PSPC
+
+///////////////////////////////////////////////////////////////////////////////
+// CRichInkCtrl
+
+template <class TBase>
+class CRichInkCtrlT : public TBase
+{
+public:
+// Constructors
+	CRichInkCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CRichInkCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		ATLASSERT(hWnd != NULL);   // Did you remember to call InitRichInkDLL() ??
+		return hWnd;
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_RICHINK;
+	}
+
+	BOOL CanPaste(UINT uFormat = 0) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANPASTE, (WPARAM)uFormat, 0L);
+	}
+
+	BOOL CanRedo() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANREDO, 0, 0L);
+	}
+
+	BOOL CanUndo() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0L);
+	}
+
+	void ClearAll(BOOL bRepaint = TRUE) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_CLEARALL, (WPARAM)bRepaint, 0L);
+	}
+
+	BOOL GetModify() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0L);
+	}
+
+	UINT GetPageStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETPAGESTYLE, 0, 0L);
+	}
+
+	UINT GetPenMode() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETPENMODE, 0, 0L);
+	}
+
+	UINT GetViewStyle() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETVIEW, 0, 0L);
+	}
+
+	UINT GetWrapMode() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETWRAPMODE, 0, 0L);
+	}
+
+	UINT GetZoomPercent() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_GETZOOMPERCENT, 0, 0L);
+	}
+
+	void InsertLinks(LPWSTR lpString, int cchLength = -1)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		if(cchLength == -1)
+			cchLength = lstrlen(lpString);
+		::SendMessage(m_hWnd, EM_INSERTLINKS, (WPARAM)cchLength, (LPARAM)lpString);
+	}
+
+	void RedoEvent()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_REDOEVENT, 0, 0L);
+	}
+
+	UINT SetInkLayer(UINT uLayer)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (UINT)::SendMessage(m_hWnd, EM_SETINKLAYER, (WPARAM)uLayer, 0L);
+	}
+
+	void SetPageStyle(UINT uStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETPAGESTYLE, (WPARAM)uStyle, 0L);
+	}
+
+	void SetPenMode(UINT uMode)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETPENMODE, (WPARAM)uMode, 0L);
+	}
+
+	void SetViewStyle(UINT uStyle)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETVIEW, (WPARAM)uStyle, 0L);
+	}
+
+	void SetViewAttributes(VIEWATTRIBUTES* pAttribs)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pAttribs);
+		::SendMessage(m_hWnd, EM_SETVIEWATTRIBUTES, 0, (LPARAM)pAttribs);
+	}
+
+	void SetWrapMode(UINT uMode)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETWRAPMODE, (WPARAM)uMode, 0L);
+	}
+
+	void SetZoomPercent(UINT uPercent)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETZOOMPERCENT, (WPARAM)uPercent, 0L);
+	}
+
+	LONG StreamIn(UINT uFormat, EDITSTREAM& es)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_STREAMIN, (WPARAM)uFormat, (LPARAM)&es);
+	}
+
+	LONG StreamOut(UINT uFormat, EDITSTREAM& es)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (LONG)::SendMessage(m_hWnd, EM_STREAMOUT, (WPARAM)uFormat, (LPARAM)&es);
+	}
+
+	void UndoEvent()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_UNDOEVENT, 0, 0L);
+	}
+
+	void Undo()
+	{
+		UndoEvent();
+	}
+
+// Standard EM_xxx messages
+	DWORD GetSel() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetViewStyle() != VT_DRAWINGVIEW);
+		return (DWORD)::SendMessage(m_hWnd, EM_GETSEL, 0, 0L);
+	}
+
+	void GetSel(int& nStartChar, int& nEndChar) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetViewStyle() != VT_DRAWINGVIEW);
+		::SendMessage(m_hWnd, EM_GETSEL, (WPARAM)&nStartChar, (LPARAM)&nEndChar);
+	}
+
+	void SetSel(int nStartChar, int nEndChar)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetViewStyle() != VT_DRAWINGVIEW);
+		::SendMessage(m_hWnd, EM_SETSEL, nStartChar, nEndChar);
+	}
+
+	void ReplaceSel(LPCTSTR lpszNewText, BOOL bCanUndo = FALSE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(GetViewStyle() != VT_DRAWINGVIEW);
+		::SendMessage(m_hWnd, EM_REPLACESEL, (WPARAM)bCanUndo, (LPARAM)lpszNewText);
+	}
+
+	void SetModify(BOOL bModified = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, EM_SETMODIFY, (WPARAM)bModified, 0L);
+	}
+
+	int GetTextLength() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, WM_GETTEXTLENGTH, 0, 0L);
+	}
+
+// Clipboard operations
+	void Clear()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CLEAR, 0, 0L);
+	}
+
+	void Copy()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_COPY, 0, 0L);
+	}
+
+	void Cut()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_CUT, 0, 0L);
+	}
+
+	void Paste()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, WM_PASTE, 0, 0L);
+	}
+};
+
+typedef CRichInkCtrlT<ATL::CWindow> CRichInkCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CInkXCtrl
+
+template <class TBase>
+class CInkXCtrlT : public TBase
+{
+public:
+// Constructors
+	CInkXCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CInkXCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = TBase::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		ATLASSERT(hWnd != NULL);   // Did you remember to call InitInkX() ??
+		return hWnd;
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_INKX;
+	}
+
+	static UINT GetHotRecordingMessage()
+	{
+		return ::RegisterWindowMessage(szHotRecording);
+	}
+
+	void ClearAll()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IM_CLEARALL, 0, 0L);
+	}
+
+	int GetData(BYTE* lpBuffer, INT cbBuffer) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpBuffer);
+		return (int)::SendMessage(m_hWnd, IM_GETDATA, (WPARAM)cbBuffer, (LPARAM)lpBuffer);
+	}
+
+	int GetDataLen() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, IM_GETDATALEN, 0, 0L);
+	}
+
+	CRichInkCtrl GetRichInk() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HWND)::SendMessage(m_hWnd, IM_GETRICHINK, 0, 0L);
+	}
+
+	BOOL IsRecording() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, IM_RECORDING, 0, 0L);
+	}
+
+	void ReInit()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IM_REINIT, 0, 0L);
+	}
+
+	void SetData(const BYTE* lpInkData, INT cbInkData)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(lpInkData);
+		::SendMessage(m_hWnd, IM_SETDATA, (WPARAM)cbInkData, (LPARAM)lpInkData);
+	}
+
+	void VoicePlay()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IM_VOICE_PLAY, 0, 0L);
+	}
+
+	BOOL IsVoicePlaying() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, IM_VOICE_PLAYING, 0, 0L);
+	}
+
+	BOOL VoiceRecord()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, IM_VOICE_RECORD, 0, 0L);
+	}
+
+	void VoiceStop()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IM_VOICE_STOP, 0, 0L);
+	}
+
+	void ShowVoiceBar(BOOL bShow = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, IM_VOICEBAR, (WPARAM)bShow, 0L);
+	}
+};
+
+typedef CInkXCtrlT<ATL::CWindow> CInkXCtrl;
+
+#endif // WIN32_PLATFORM_PSPC
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CVoiceRecorderCtrl
+
+template <class TBase>
+class CVoiceRecorderCtrlT : public TBase
+{
+public:
+// Constructors
+	CVoiceRecorderCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CVoiceRecorderCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, const POINT pt, LPTSTR pstrFileName, UINT nID, DWORD dwStyle = 0)
+	{
+		ATLASSERT(pstrFileName != NULL);
+		CM_VOICE_RECORDER cmvr = { 0 };
+		cmvr.cb = sizeof(CM_VOICE_RECORDER);
+		cmvr.dwStyle = dwStyle;
+		cmvr.xPos = pt.x;
+		cmvr.yPos = pt.y;
+		cmvr.hwndParent = hWndParent;
+		cmvr.id = nID;
+		cmvr.lpszRecordFileName = pstrFileName;
+		m_hWnd = VoiceRecorder_Create(&cmvr);
+		return m_hWnd;
+	}
+
+	HWND Create(LPCM_VOICE_RECORDER pAttribs)
+	{
+		ATLASSERT(pAttribs);
+		m_hWnd = VoiceRecorder_Create(pAttribs);
+		return m_hWnd;
+	}
+
+// Attributes
+	void Record()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, VRM_RECORD, 0, 0L);
+	}
+
+	void Play()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, VRM_PLAY, 0, 0L);
+	}
+
+	void Stop()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, VRM_STOP, 0, 0L);
+	}
+
+	void Cancel()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, VRM_CANCEL, 0, 0L);
+	}
+
+	void Done()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, VRM_OK, 0, 0L);
+	}
+};
+
+typedef CVoiceRecorderCtrlT<ATL::CWindow> CVoiceRecorderCtrl;
+
+
+#ifdef WIN32_PLATFORM_PSPC
+
+///////////////////////////////////////////////////////////////////////////////
+// CDocListCtrl
+
+template <class TBase>
+class CDocListCtrlT : public TBase
+{
+public:
+// Attributes
+	DOCLISTCREATE m_dlc;
+	TCHAR m_szPath[MAX_PATH];
+
+// Constructors
+	CDocListCtrlT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CDocListCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, WORD wId, LPCTSTR pszFolder = NULL, LPCTSTR pstrFilter = NULL,
+			WORD wFilterIndex = 0, DWORD dwFlags = DLF_SHOWEXTENSION)
+	{
+		ATLASSERT(pstrFilter != NULL);   // It seems to need a filter badly!!
+		::ZeroMemory(&m_dlc, sizeof(DOCLISTCREATE));
+		::ZeroMemory(m_szPath, sizeof(m_szPath));
+		if(pszFolder != NULL)
+			SecureHelper::strncpy_x(m_szPath, MAX_PATH, pszFolder, MAX_PATH - 1);
+		m_dlc.dwStructSize = sizeof(DOCLISTCREATE);
+		m_dlc.hwndParent = hWndParent;
+		m_dlc.pszFolder = m_szPath;
+		m_dlc.pstrFilter = pstrFilter;
+		m_dlc.wFilterIndex = wFilterIndex;
+		m_dlc.wId = wId;
+		m_dlc.dwFlags = dwFlags;
+		m_hWnd = DocList_Create(&m_dlc);
+		return m_hWnd;
+	}
+
+	HWND Create(DOCLISTCREATE* pDlc)
+	{
+		m_dlc = *pDlc;
+		m_hWnd = DocList_Create(&m_dlc);
+		return m_hWnd;
+	}
+
+// Attributes
+	void DeleteSel()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_DELETESEL, 0, 0L);
+	}
+
+	void DisableUpdates()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_DISABLEUPDATES, 0, 0L);
+	}
+
+	void EnableUpdates()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_ENABLEUPDATES, 0, 0L);
+	}
+
+	int GetFilterIndex() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DLM_GETFILTERINDEX, 0, 0L);
+	}
+
+	int GetItemCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DLM_GETITEMCOUNT, 0, 0L);
+	}
+
+	int GetNextItem(int iIndex, DWORD dwRelation = LVNI_ALL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DLM_GETNEXTITEM, (WPARAM)iIndex, (LPARAM)dwRelation);
+	}
+
+	int GetFirstItem(DWORD dwRelation = LVNI_ALL) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DLM_GETNEXTITEM, (WPARAM)-1, (LPARAM)dwRelation);
+	}
+
+	BOOL GetNextWave(int* pIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pIndex);
+		return (BOOL)::SendMessage(m_hWnd, DLM_GETNEXTWAVE, 0, (LPARAM)pIndex);
+	}
+
+	BOOL GetPrevWave(int* pIndex) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pIndex);
+		return (BOOL)::SendMessage(m_hWnd, DLM_GETPREVWAVE, 0, (LPARAM)pIndex);
+	}
+
+	int GetSelCount() const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DLM_GETSELCOUNT, 0, 0L);
+	}
+
+	BOOL GetSelPathName(LPTSTR pstrPath, int cchMax) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrPath);
+		return (BOOL)::SendMessage(m_hWnd, DLM_GETSELPATHNAME, (WPARAM)cchMax, (LPARAM)pstrPath);
+	}
+
+	void ReceiveIR(LPCTSTR pstrPath) const
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrPath);
+		::SendMessage(m_hWnd, DLM_RECEIVEIR, 0, (LPARAM)pstrPath);
+	}
+
+	void Refresh()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_REFRESH, 0, 0L);
+	}
+
+	BOOL RenameMoveSelectedItems()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DLM_RENAMEMOVE, 0, 0L);
+	}
+
+	int SelectAll()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (int)::SendMessage(m_hWnd, DLM_SELECTALL, 0, 0L);
+	}
+
+	HRESULT SelectItem(LPCTSTR pstrPath, BOOL bVisible = TRUE)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrPath);
+		return (HRESULT)::SendMessage(m_hWnd, DLM_SELECTITEM, (WPARAM)bVisible, (LPARAM)pstrPath);
+	}
+
+	void SendEMail(LPCTSTR pstrAttachment)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_SENDEMAIL, 0, (LPARAM)pstrAttachment);
+	}
+
+	void SendIR(LPCTSTR pstrPath)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_SENDIR, 0, (LPARAM)pstrPath);
+	}
+
+	HRESULT SetFilterIndex(int iIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HRESULT)::SendMessage(m_hWnd, DLM_SETFILTERINDEX, (WPARAM)iIndex, 0L);
+	}
+
+	void SetFolder(LPCTSTR pstrPath)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrPath);
+		::SendMessage(m_hWnd, DLM_SETFOLDER, 0, (LPARAM)pstrPath);
+	}
+
+	BOOL SetItemState(int iIndex, const LVITEM* pItem)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pItem);
+		return (BOOL)::SendMessage(m_hWnd, DLM_SETITEMSTATE, (WPARAM)iIndex, (LPARAM)pItem);
+	}
+
+	BOOL SetItemState(int iIndex, UINT uState, UINT uMask)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		LV_ITEM lvi = { 0 };
+		lvi.stateMask = uMask;
+		lvi.state = uState;
+		return (BOOL)::SendMessage(m_hWnd, DLM_SETITEMSTATE, (WPARAM)iIndex, (LPARAM)&lvi);
+	}
+
+	void SetOneItem(int iIndex, LPCVOID pPA)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_SETONEITEM, (WPARAM)iIndex, (LPARAM)pPA);
+	}
+
+	void SetSelect(int iIndex)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		::SendMessage(m_hWnd, DLM_SETSELECT, (WPARAM)iIndex, 0L);
+	}
+
+	void SetSelPathName(LPCTSTR pstrPath)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrPath);
+		::SendMessage(m_hWnd, DLM_SETSELPATHNAME, 0, (LPARAM)pstrPath);
+	}
+
+	BOOL SetSortOrder()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DLM_SETSORTORDER, 0, 0L);
+	}
+
+	HRESULT Update()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (HRESULT)::SendMessage(m_hWnd, DLM_UPDATE, 0, 0L);
+	}
+
+	BOOL ValidateFolder()
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return (BOOL)::SendMessage(m_hWnd, DLM_VALIDATEFOLDER, 0, 0L);
+	}
+
+// Functions
+	BOOL GetFirstSelectedWaveFile(int* pIndex, LPTSTR szPath, const size_t cchPath)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return DocList_GetFirstSelectedWaveFile(m_hWnd, pIndex, szPath, cchPath);
+	}
+
+	BOOL GetNextSelectedWaveFile(int* pIndex, LPTSTR szPath, const size_t cchPath)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		return DocList_GetNextSelectedWaveFile(m_hWnd, pIndex, szPath, cchPath);
+	}
+};
+
+typedef CDocListCtrlT<ATL::CWindow> CDocListCtrl;
+
+#endif // WIN32_PLATFORM_PSPC
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CCapEdit
+
+template <class TBase>
+class CCapEditT : public TBase
+{
+public:
+// Constructors
+	CCapEditT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CCapEditT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = /*TBase*/CWindow::Create(GetWndClassName(), hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		ATLASSERT(hWnd != NULL);   // Did you remember to call SHInitExtraControls() ??
+		return hWnd;
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_CAPEDIT;
+	}
+};
+
+typedef CCapEditT<WTL::CEdit> CCapEdit;
+
+///////////////////////////////////////////////////////////////////////////////
+// CTTStatic
+
+#ifndef WIN32_PLATFORM_WFSP // Tooltips not supported on SmartPhone
+
+template <class TBase>
+class CTTStaticT : public TBase
+{
+public:
+// Constructors
+	CTTStaticT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CTTStaticT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = TBase::Create(hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		ATLASSERT(hWnd != NULL);   // Did you remember to call SHInitExtraControls() ??
+		return hWnd;
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_TSTATIC;
+	}
+
+// Operations
+	BOOL SetToolTipText(LPCTSTR pstrTipText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrTipText);
+		ATLASSERT(lstrlen(pstrTipText) <= 253);
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		int cchLen = lstrlen(pstrTipText) + 3;
+		LPTSTR pstr = buff.Allocate(cchLen);
+		if(pstr == NULL)
+			return FALSE;
+		SecureHelper::strcpy_x(pstr, cchLen, _T("~~"));
+		SecureHelper::strcat_x(pstr, cchLen, pstrTipText);
+		return SetWindowText(pstr);
+	}
+};
+
+typedef CTTStaticT<WTL::CStatic> CTTStatic;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CTTButton
+
+template <class TBase>
+class CTTButtonT : public TBase
+{
+public:
+// Constructors
+	CTTButtonT(HWND hWnd = NULL) : TBase(hWnd)
+	{ }
+
+	CTTButtonT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szWindowName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+		HWND hWnd = TBase::Create(hWndParent, rect.m_lpRect, szWindowName, dwStyle, dwExStyle, MenuOrID.m_hMenu, lpCreateParam);
+		ATLASSERT(hWnd != NULL);   // Did you remember to call SHInitExtraControls() ??
+		return hWnd;
+	}
+
+// Attributes
+	static LPCTSTR GetWndClassName()
+	{
+		return WC_TBUTTON;
+	}
+
+// Operations
+	BOOL SetToolTipText(LPCTSTR pstrTipText)
+	{
+		ATLASSERT(::IsWindow(m_hWnd));
+		ATLASSERT(pstrTipText);
+		ATLASSERT(lstrlen(pstrTipText) <= 253);
+		CTempBuffer<TCHAR, _WTL_STACK_ALLOC_THRESHOLD> buff;
+		int cchLen = lstrlen(pstrTipText) + 3;
+		LPTSTR pstr = buff.Allocate(cchLen);
+		if(pstr == NULL)
+			return FALSE;
+		SecureHelper::strcpy_x(pstr, cchLen, _T("~~"));
+		SecureHelper::strcat_x(pstr, cchLen, pstrTipText);
+		return SetWindowText(pstr);
+	}
+};
+
+typedef CTTButtonT<WTL::CButton> CTTButton;
+
+#endif // !WIN32_PLATFORM_WFSP
+
+
+// --- SmartPhone specific controls ---
+
+#ifdef WIN32_PLATFORM_WFSP
+
+///////////////////////////////////////////////////////////////////////////////
+// CSpinCtrlT - CSpinCtrl : SmartPhone adapted UpDown control
+
+template <class TBase>
+class CSpinCtrlT : public CUpDownCtrlT< TBase >
+{
+public:
+// Constructors
+	CSpinCtrlT(HWND hWnd = NULL) : CUpDownCtrlT< TBase >(hWnd)
+	{ }
+
+	CSpinCtrlT< TBase >& operator =(HWND hWnd)
+	{
+		m_hWnd = hWnd;
+		return *this;
+	}
+
+	HWND Create(HWND hWndParent, HWND hBuddy, DWORD dwStyle, int nID, LPCTSTR szExpandedName = NULL)
+	{
+		ATLASSERT(::IsWindow(hWndParent));
+		CUpDownCtrlT< TBase >::Create(hWndParent, NULL, szExpandedName, dwStyle, 0, nID, NULL);
+		ATLASSERT(m_hWnd != NULL);   // Did you remember to call AtlInitCommonControls(ICC_UPDOWN_CLASS)?
+		if (hBuddy != NULL)
+		{
+			ATLASSERT(::IsWindow(hBuddy));
+			SetBuddy(hBuddy);
+		}
+		return m_hWnd;
+	}
+};
+
+typedef CSpinCtrlT<ATL::CWindow> CSpinCtrl;
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CSpinned - SmartPhone association of control and Spin
+
+template <class TBase, bool t_bExpandOnly>
+class CSpinned : public TBase
+{
+public:
+	CSpinCtrl m_SpinCtrl;
+	DWORD m_dwSpinnedStyle;
+
+// Constructors
+	CSpinned(HWND hWnd = NULL) : TBase(hWnd)
+	{
+		m_dwSpinnedStyle = WS_VISIBLE | UDS_ALIGNRIGHT | UDS_EXPANDABLE;
+		
+		if (t_bExpandOnly == true)
+			m_dwSpinnedStyle |= UDS_NOSCROLL;
+		else
+			m_dwSpinnedStyle |= UDS_HORZ | UDS_ARROWKEYS | UDS_SETBUDDYINT | UDS_WRAP;
+
+		if (hWnd != NULL)
+			AttachOrCreateSpinCtrl();
+	}
+
+	CSpinned<TBase, t_bExpandOnly>& operator =(HWND hWnd)
+	{
+		Attach(hWnd);
+		return *this;
+	}
+
+	void Attach(HWND hWnd)
+	{
+		ATLASSERT(!IsWindow());
+		TBase* pT = static_cast<TBase*>(this);
+		pT->m_hWnd = hWnd;
+		if (hWnd != NULL)
+			AttachOrCreateSpinCtrl();
+	}
+
+	HWND Create(HWND hWndParent, ATL::_U_RECT rect = NULL, LPCTSTR szExpandedName = NULL,
+			DWORD dwStyle = 0, DWORD dwExStyle = 0,
+			ATL::_U_MENUorID MenuOrID = 0U, LPVOID lpCreateParam = NULL)
+	{
+
+		TBase* pT = static_cast<TBase*>(this);
+		TBase::Create(hWndParent, rect, NULL, dwStyle, dwExStyle, MenuOrID, lpCreateParam);
+		ATLASSERT(pT->m_hWnd != NULL);
+
+		m_SpinCtrl.Create(hWndParent, pT->m_hWnd, m_dwSpinnedStyle, ATL_IDW_SPIN_ID + (int)MenuOrID.m_hMenu, szExpandedName);
+
+		ATLASSERT(m_SpinCtrl.m_hWnd != NULL);   // Did you remember to call AtlInitCommonControls(ICC_UPDOWN_CLASS)?
+
+		return pT->m_hWnd;
+	}
+
+// Attributes
+	CSpinCtrl& GetSpinCtrl()
+	{
+		return m_SpinCtrl;
+	}
+
+// Implementation
+	// Attach our existing SpinCtrl or create one
+	bool AttachOrCreateSpinCtrl()
+	{
+		TBase* pT = static_cast<TBase*>(this);
+
+		HWND hSpin = ::GetDlgItem(pT->GetParent(), ATL_IDW_SPIN_ID + pT->GetDlgCtrlID());
+
+		if (hSpin != NULL)
+		{
+			m_SpinCtrl.Attach(hSpin);
+#ifdef DEBUG
+			TCHAR sClassName[16];
+			::GetClassName(hSpin, sClassName, 16);
+			ATLASSERT(!_tcscmp(sClassName, UPDOWN_CLASS));
+			ATLASSERT(m_SpinCtrl.GetBuddy().m_hWnd == pT->m_hWnd);
+#endif // DEBUG
+		}
+		else
+		{
+			m_SpinCtrl.Create(pT->GetParent(), pT->m_hWnd, m_dwSpinnedStyle, ATL_IDW_SPIN_ID + pT->GetDlgCtrlID());
+		}
+
+		return m_SpinCtrl.m_hWnd != NULL;
+	}
+};
+
+
+///////////////////////////////////////////////////////////////////////////////
+// CSpinListBox - SmartPhone spinned ListBox control
+// CExpandListBox - SmartPhone expandable ListBox control
+// CExpandEdit - SmartPhone expandable Edit control
+// CExpandCapEdit - SmartPhone expandable CapEdit control
+
+typedef CSpinned<CListBox, false>   CSpinListBox;
+typedef CSpinned<CListBox, true>    CExpandListBox;
+typedef CSpinned<CEdit, true>		CExpandEdit;
+typedef CSpinned<CCapEdit, true>    CExpandCapEdit;
+
+#endif // WIN32_PLATFORM_WFSP
+
+#endif // _WTL_CE_NO_CONTROLS
+
+}; // namespace WTL
+
+#endif // __ATLWINCE_H__
diff --git a/GLideN64/src/GLideNUI-wtl/WTL/atlwinx.h b/GLideN64/src/GLideNUI-wtl/WTL/atlwinx.h
new file mode 100644
index 00000000..0e55bce2
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/WTL/atlwinx.h
@@ -0,0 +1,595 @@
+// Windows Template Library - WTL version 8.1
+// Copyright (C) Microsoft Corporation. All rights reserved.
+//
+// This file is a part of the Windows Template Library.
+// The use and distribution terms for this software are covered by the
+// Common Public License 1.0 (http://opensource.org/licenses/cpl1.0.php)
+// which can be found in the file CPL.TXT at the root of this distribution.
+// By using this software in any fashion, you are agreeing to be bound by
+// the terms of this license. You must not remove this notice, or
+// any other, from this software.
+
+#ifndef __ATLWINX_H__
+#define __ATLWINX_H__
+
+#pragma once
+
+#ifndef __ATLAPP_H__
+	#error atlwinx.h requires atlapp.h to be included first
+#endif
+
+#if (_ATL_VER >= 0x0700)
+  #include <atlwin.h>
+#endif // (_ATL_VER >= 0x0700)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Classes in this file:
+//
+// _U_RECT
+// _U_MENUorID
+// _U_STRINGorID
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Command Chaining Macros
+
+#define CHAIN_COMMANDS(theChainClass) \
+	if(uMsg == WM_COMMAND) \
+		CHAIN_MSG_MAP(theChainClass)
+
+#define CHAIN_COMMANDS_ALT(theChainClass, msgMapID) \
+	if(uMsg == WM_COMMAND) \
+		CHAIN_MSG_MAP_ALT(theChainClass, msgMapID)
+
+#define CHAIN_COMMANDS_MEMBER(theChainMember) \
+	if(uMsg == WM_COMMAND) \
+		CHAIN_MSG_MAP_MEMBER(theChainMember)
+
+#define CHAIN_COMMANDS_ALT_MEMBER(theChainMember, msgMapID) \
+	if(uMsg == WM_COMMAND) \
+		CHAIN_MSG_MAP_ALT_MEMBER(theChainMember, msgMapID)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Macros for parent message map to selectively reflect control messages
+
+// NOTE: ReflectNotifications is a member of ATL's CWindowImplRoot
+//  (and overridden in 2 cases - CContainedWindowT and CAxHostWindow)
+//  Since we can't modify ATL, we'll provide the needed additions
+//  in a separate function (that is not a member of CWindowImplRoot)
+
+namespace WTL
+{
+
+inline LRESULT WtlReflectNotificationsFiltered(HWND hWndParent, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled,
+                                               UINT uMsgFilter = WM_NULL, UINT_PTR idFromFilter = 0, HWND hWndChildFilter = NULL)
+{
+	if((uMsgFilter != WM_NULL) && (uMsgFilter != uMsg))
+	{
+		// The notification message doesn't match the filter.
+		bHandled = FALSE;
+		return 1;
+	}
+
+	HWND hWndChild = NULL;
+	UINT_PTR idFrom = 0;
+
+	switch(uMsg)
+	{
+	case WM_COMMAND:
+		if(lParam != NULL)	// not from a menu
+		{
+			hWndChild = (HWND)lParam;
+			idFrom = (UINT_PTR)LOWORD(wParam);
+		}
+		break;
+	case WM_NOTIFY:
+		hWndChild = ((LPNMHDR)lParam)->hwndFrom;
+		idFrom = ((LPNMHDR)lParam)->idFrom;
+		break;
+#ifndef _WIN32_WCE
+	case WM_PARENTNOTIFY:
+		switch(LOWORD(wParam))
+		{
+		case WM_CREATE:
+		case WM_DESTROY:
+			hWndChild = (HWND)lParam;
+			idFrom = (UINT_PTR)HIWORD(wParam);
+			break;
+		default:
+			hWndChild = ::GetDlgItem(hWndParent, HIWORD(wParam));
+			idFrom = (UINT_PTR)::GetDlgCtrlID(hWndChild);
+			break;
+		}
+		break;
+#endif // !_WIN32_WCE
+	case WM_DRAWITEM:
+		if(wParam)	// not from a menu
+		{
+			hWndChild = ((LPDRAWITEMSTRUCT)lParam)->hwndItem;
+			idFrom = (UINT_PTR)wParam;
+		}
+		break;
+	case WM_MEASUREITEM:
+		if(wParam)	// not from a menu
+		{
+			hWndChild = ::GetDlgItem(hWndParent, ((LPMEASUREITEMSTRUCT)lParam)->CtlID);
+			idFrom = (UINT_PTR)wParam;
+		}
+		break;
+	case WM_COMPAREITEM:
+		if(wParam)	// not from a menu
+		{
+			hWndChild = ((LPCOMPAREITEMSTRUCT)lParam)->hwndItem;
+			idFrom = (UINT_PTR)wParam;
+		}
+		break;
+	case WM_DELETEITEM:
+		if(wParam)	// not from a menu
+		{
+			hWndChild = ((LPDELETEITEMSTRUCT)lParam)->hwndItem;
+			idFrom = (UINT_PTR)wParam;
+		}
+		break;
+	case WM_VKEYTOITEM:
+	case WM_CHARTOITEM:
+	case WM_HSCROLL:
+	case WM_VSCROLL:
+		hWndChild = (HWND)lParam;
+		idFrom = (UINT_PTR)::GetDlgCtrlID(hWndChild);
+		break;
+	case WM_CTLCOLORBTN:
+	case WM_CTLCOLORDLG:
+	case WM_CTLCOLOREDIT:
+	case WM_CTLCOLORLISTBOX:
+	case WM_CTLCOLORMSGBOX:
+	case WM_CTLCOLORSCROLLBAR:
+	case WM_CTLCOLORSTATIC:
+		hWndChild = (HWND)lParam;
+		idFrom = (UINT_PTR)::GetDlgCtrlID(hWndChild);
+		break;
+	default:
+		break;
+	}
+
+	if((hWndChild == NULL) ||
+		((hWndChildFilter != NULL) && (hWndChildFilter != hWndChild)))
+	{
+		// Either hWndChild isn't valid, or
+		// hWndChild doesn't match the filter.
+		bHandled = FALSE;
+		return 1;
+	}
+
+	if((idFromFilter != 0) && (idFromFilter != idFrom))
+	{
+		// The dialog control id doesn't match the filter.
+		bHandled = FALSE;
+		return 1;
+	}
+
+	ATLASSERT(::IsWindow(hWndChild));
+	LRESULT lResult = ::SendMessage(hWndChild, OCM__BASE + uMsg, wParam, lParam);
+	if((lResult == 0) && (uMsg >= WM_CTLCOLORMSGBOX) && (uMsg <= WM_CTLCOLORSTATIC))
+	{
+		// Try to prevent problems with WM_CTLCOLOR* messages when
+		// the message wasn't really handled
+		bHandled = FALSE;
+	}
+
+	return lResult;
+}
+
+}; // namespace WTL
+
+// Try to prevent problems with WM_CTLCOLOR* messages when
+// the message wasn't really handled
+#define REFLECT_NOTIFICATIONS_EX() \
+{ \
+	bHandled = TRUE; \
+	lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+	if((lResult == 0) && (uMsg >= WM_CTLCOLORMSGBOX) && (uMsg <= WM_CTLCOLORSTATIC)) \
+		bHandled = FALSE; \
+	if(bHandled) \
+		return TRUE; \
+}
+
+#define REFLECT_NOTIFICATIONS_MSG_FILTERED(uMsgFilter) \
+	{ \
+		bHandled = TRUE; \
+		lResult = WTL::WtlReflectNotificationsFiltered(m_hWnd, uMsg, wParam, lParam, bHandled, uMsgFilter, 0, NULL); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFICATIONS_ID_FILTERED(idFromFilter) \
+	{ \
+		bHandled = TRUE; \
+		lResult = WTL::WtlReflectNotificationsFiltered(m_hWnd, uMsg, wParam, lParam, bHandled, WM_NULL, idFromFilter, NULL); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFICATIONS_HWND_FILTERED(hWndChildFilter) \
+	{ \
+		bHandled = TRUE; \
+		lResult = WTL::WtlReflectNotificationsFiltered(m_hWnd, uMsg, wParam, lParam, bHandled, WM_NULL, 0, hWndChildFilter); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFICATIONS_MSG_ID_FILTERED(uMsgFilter, idFromFilter) \
+	{ \
+		bHandled = TRUE; \
+		lResult = WTL::WtlReflectNotificationsFiltered(m_hWnd, uMsg, wParam, lParam, bHandled, uMsgFilter, idFromFilter, NULL); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFICATIONS_MSG_HWND_FILTERED(uMsgFilter, hWndChildFilter) \
+	{ \
+		bHandled = TRUE; \
+		lResult = WTL::WtlReflectNotificationsFiltered(m_hWnd, uMsg, wParam, lParam, bHandled, uMsgFilter, 0, hWndChildFilter); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_COMMAND(id, code) \
+	if(uMsg == WM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_COMMAND_ID(id) \
+	if(uMsg == WM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_COMMAND_CODE(code) \
+	if(uMsg == WM_COMMAND && code == HIWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_COMMAND_RANGE(idFirst, idLast) \
+	if(uMsg == WM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_COMMAND_RANGE_CODE(idFirst, idLast, code) \
+	if(uMsg == WM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFY(id, cd) \
+	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFY_ID(id) \
+	if(uMsg == WM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFY_CODE(cd) \
+	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFY_RANGE(idFirst, idLast) \
+	if(uMsg == WM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECT_NOTIFY_RANGE_CODE(idFirst, idLast, cd) \
+	if(uMsg == WM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = ReflectNotifications(uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Reflected message handler macros for message maps (for ATL 3.0)
+
+#if (_ATL_VER < 0x0700)
+
+#define REFLECTED_COMMAND_HANDLER(id, code, func) \
+	if(uMsg == OCM_COMMAND && id == LOWORD(wParam) && code == HIWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_COMMAND_ID_HANDLER(id, func) \
+	if(uMsg == OCM_COMMAND && id == LOWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_COMMAND_CODE_HANDLER(code, func) \
+	if(uMsg == OCM_COMMAND && code == HIWORD(wParam)) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_COMMAND_RANGE_HANDLER(idFirst, idLast, func) \
+	if(uMsg == OCM_COMMAND && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_COMMAND_RANGE_CODE_HANDLER(idFirst, idLast, code, func) \
+	if(uMsg == OCM_COMMAND && code == HIWORD(wParam) && LOWORD(wParam) >= idFirst  && LOWORD(wParam) <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func(HIWORD(wParam), LOWORD(wParam), (HWND)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_NOTIFY_HANDLER(id, cd, func) \
+	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom && cd == ((LPNMHDR)lParam)->code) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_NOTIFY_ID_HANDLER(id, func) \
+	if(uMsg == OCM_NOTIFY && id == ((LPNMHDR)lParam)->idFrom) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_NOTIFY_CODE_HANDLER(cd, func) \
+	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_NOTIFY_RANGE_HANDLER(idFirst, idLast, func) \
+	if(uMsg == OCM_NOTIFY && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#define REFLECTED_NOTIFY_RANGE_CODE_HANDLER(idFirst, idLast, cd, func) \
+	if(uMsg == OCM_NOTIFY && cd == ((LPNMHDR)lParam)->code && ((LPNMHDR)lParam)->idFrom >= idFirst && ((LPNMHDR)lParam)->idFrom <= idLast) \
+	{ \
+		bHandled = TRUE; \
+		lResult = func((int)wParam, (LPNMHDR)lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+#endif // (_ATL_VER < 0x0700)
+
+
+///////////////////////////////////////////////////////////////////////////////
+// Dual argument helper classes (for ATL 3.0)
+
+#if (_ATL_VER < 0x0700)
+
+namespace ATL
+{
+
+class _U_RECT
+{
+public:
+	_U_RECT(LPRECT lpRect) : m_lpRect(lpRect)
+	{ }
+	_U_RECT(RECT& rc) : m_lpRect(&rc)
+	{ }
+	LPRECT m_lpRect;
+};
+
+class _U_MENUorID
+{
+public:
+	_U_MENUorID(HMENU hMenu) : m_hMenu(hMenu)
+	{ }
+	_U_MENUorID(UINT nID) : m_hMenu((HMENU)LongToHandle(nID))
+	{ }
+	HMENU m_hMenu;
+};
+
+class _U_STRINGorID
+{
+public:
+	_U_STRINGorID(LPCTSTR lpString) : m_lpstr(lpString)
+	{ }
+	_U_STRINGorID(UINT nID) : m_lpstr(MAKEINTRESOURCE(nID))
+	{ }
+	LPCTSTR m_lpstr;
+};
+
+}; // namespace ATL
+
+#endif // (_ATL_VER < 0x0700)
+
+
+namespace WTL
+{
+
+///////////////////////////////////////////////////////////////////////////////
+// Forward notifications support for message maps (for ATL 3.0)
+
+#if (_ATL_VER < 0x0700)
+
+// forward notifications support
+#define FORWARD_NOTIFICATIONS() \
+	{ \
+		bHandled = TRUE; \
+		lResult = WTL::Atl3ForwardNotifications(m_hWnd, uMsg, wParam, lParam, bHandled); \
+		if(bHandled) \
+			return TRUE; \
+	}
+
+static LRESULT Atl3ForwardNotifications(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
+{
+	LRESULT lResult = 0;
+	switch(uMsg)
+	{
+	case WM_COMMAND:
+	case WM_NOTIFY:
+#ifndef _WIN32_WCE
+	case WM_PARENTNOTIFY:
+#endif // !_WIN32_WCE
+	case WM_DRAWITEM:
+	case WM_MEASUREITEM:
+	case WM_COMPAREITEM:
+	case WM_DELETEITEM:
+	case WM_VKEYTOITEM:
+	case WM_CHARTOITEM:
+	case WM_HSCROLL:
+	case WM_VSCROLL:
+	case WM_CTLCOLORBTN:
+	case WM_CTLCOLORDLG:
+	case WM_CTLCOLOREDIT:
+	case WM_CTLCOLORLISTBOX:
+	case WM_CTLCOLORMSGBOX:
+	case WM_CTLCOLORSCROLLBAR:
+	case WM_CTLCOLORSTATIC:
+		lResult = ::SendMessage(::GetParent(hWnd), uMsg, wParam, lParam);
+		break;
+	default:
+		bHandled = FALSE;
+		break;
+	}
+	return lResult;
+}
+
+#endif // (_ATL_VER < 0x0700)
+
+#define DEFAULT_DPI 96.0
+
+typedef struct tagSIZEF
+{
+    FLOAT        cx;
+    FLOAT        cy;
+} SIZEF, *PSIZEF, *LPSIZEF;
+
+inline ATLAPI_(SIZE) Dpi()
+{
+    SIZE dpi;
+    int nPixelsPerInchX;    // Pixels per logical inch along width
+    int nPixelsPerInchY;    // Pixels per logical inch along height
+
+    HDC hDCScreen = GetDC(NULL); // Gets DC of virtual display
+    ATLASSUME(hDCScreen != NULL);
+    nPixelsPerInchX = GetDeviceCaps(hDCScreen, LOGPIXELSX);
+    nPixelsPerInchY = GetDeviceCaps(hDCScreen, LOGPIXELSY);
+    ReleaseDC(NULL, hDCScreen);
+
+    dpi.cx = nPixelsPerInchX;
+    dpi.cy = nPixelsPerInchY;
+
+    return dpi;
+}
+
+inline ATLAPI_(SIZEF) DpiScale()
+{
+    SIZE dpi = Dpi();
+    SIZEF dpiScale = { (FLOAT)dpi.cx, (FLOAT)dpi.cy };
+
+    dpiScale.cx /= DEFAULT_DPI;
+    dpiScale.cy /= DEFAULT_DPI;
+
+    return dpiScale;
+}
+
+inline ATLAPI_(SIZE) Dpi(
+    _In_ const HWND &hWnd)
+{
+    ATLENSURE_THROW(hWnd != NULL, E_POINTER);
+    SIZE dpi;
+    int nPixelsPerInchX;    // Pixels per logical inch along width
+    int nPixelsPerInchY;    // Pixels per logical inch along height
+
+    HDC hDCWindow = GetDC(hWnd);
+    ATLASSUME(hDCWindow != NULL);
+    nPixelsPerInchX = GetDeviceCaps(hDCWindow, LOGPIXELSX);
+    nPixelsPerInchY = GetDeviceCaps(hDCWindow, LOGPIXELSY);
+    ReleaseDC(hWnd, hDCWindow);
+
+    dpi.cx = nPixelsPerInchX;
+    dpi.cy = nPixelsPerInchY;
+
+    return dpi;
+}
+
+inline ATLAPI_(SIZEF) DpiScale(
+    _In_ const HWND &hWnd)
+{
+    ATLENSURE_THROW(hWnd != NULL, E_POINTER);
+    SIZE dpi = Dpi(hWnd);
+    SIZEF dpiScale = { (FLOAT)dpi.cx, (FLOAT)dpi.cy };
+
+    dpiScale.cx /= DEFAULT_DPI;
+    dpiScale.cy /= DEFAULT_DPI;
+
+    return dpiScale;
+}
+
+}; // namespace WTL
+
+#endif // __ATLWINX_H__
diff --git a/GLideN64/src/GLideNUI-wtl/config-debug.cpp b/GLideN64/src/GLideNUI-wtl/config-debug.cpp
new file mode 100644
index 00000000..c56343d4
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-debug.cpp
@@ -0,0 +1,40 @@
+#include "config-debug.h"
+#include "../Config.h"
+#include "../DebugDump.h"
+#include "Language.h"
+#include "resource.h"
+
+CDebugTab::CDebugTab() :
+	CConfigTab(IDD_TAB_DEBUG)
+{
+}
+
+BOOL CDebugTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/) {
+	return true;
+}
+
+void CDebugTab::ApplyLanguage(void) {
+	SetDlgItemTextW(IDC_CHK_DUMP_LOW, wGS(DEBUG_DUMP_LOWLEVEL_INFO).c_str());
+	SetDlgItemTextW(IDC_CHK_DUMP_NORMAL, wGS(DEBUG_DUMP_DISPLAY_LIST).c_str());
+	SetDlgItemTextW(IDC_CHK_DUMP_DETAIL, wGS(DEBUG_DUMP_DETAILED_INFO).c_str());
+}
+
+LRESULT CDebugTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/) {
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+void CDebugTab::LoadSettings(bool /*blockCustomSettings*/) {
+	CButton(GetDlgItem(IDC_CHK_DUMP_LOW)).SetCheck((config.debug.dumpMode & DEBUG_LOW) != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_DUMP_NORMAL)).SetCheck((config.debug.dumpMode & DEBUG_NORMAL) != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_DUMP_DETAIL)).SetCheck((config.debug.dumpMode & DEBUG_DETAIL) != 0 ? BST_CHECKED : BST_UNCHECKED);
+}
+
+void CDebugTab::SaveSettings() {
+	config.debug.dumpMode = 0;
+	if (CButton(GetDlgItem(IDC_CHK_DUMP_LOW)).GetCheck() == BST_CHECKED)
+		config.debug.dumpMode |= DEBUG_LOW;
+	if (CButton(GetDlgItem(IDC_CHK_DUMP_NORMAL)).GetCheck() == BST_CHECKED)
+		config.debug.dumpMode |= DEBUG_NORMAL;
+	if (CButton(GetDlgItem(IDC_CHK_DUMP_DETAIL)).GetCheck() == BST_CHECKED)
+		config.debug.dumpMode |= DEBUG_DETAIL;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/config-debug.h b/GLideN64/src/GLideNUI-wtl/config-debug.h
new file mode 100644
index 00000000..5e845875
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-debug.h
@@ -0,0 +1,21 @@
+#pragma once
+#include "config-tab.h"
+
+class CDebugTab :
+	public CConfigTab
+{
+public:
+	BEGIN_MSG_MAP(CEmulationTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+	END_MSG_MAP()
+
+	CDebugTab();
+
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+	void ApplyLanguage(void);
+	void LoadSettings(bool /*blockCustomSettings*/);
+	void SaveSettings();
+};
diff --git a/GLideN64/src/GLideNUI-wtl/config-emulation.cpp b/GLideN64/src/GLideNUI-wtl/config-emulation.cpp
new file mode 100644
index 00000000..68cc1e2e
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-emulation.cpp
@@ -0,0 +1,211 @@
+#include "config-emulation.h"
+#include "util.h"
+#include "../Config.h"
+#include "resource.h"
+#include "ConfigDlg.h"
+
+CEmulationTab::CEmulationTab(CConfigDlg & Dlg) :
+	CConfigTab(IDD_TAB_EMULATION),
+	m_Dlg(Dlg)
+{
+}
+
+BOOL CEmulationTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+{
+	TTInit();
+	TTSize(400);
+
+	CComboBox nativeRes2DComboBox(GetDlgItem(IDC_CMB_NATIVE_RES_2D));
+	nativeRes2DComboBox.ResetContent();
+	nativeRes2DComboBox.AddString(wGS(EMULATION_RENDER_DISABLE).c_str());
+	nativeRes2DComboBox.AddString(wGS(EMULATION_RENDER_ENABLE_OPTIMIZED).c_str());
+	nativeRes2DComboBox.AddString(wGS(EMULATION_RENDER_ENABLE_UNOPTIMIZED).c_str());
+
+	m_GamaTxt.Attach(GetDlgItem(IDC_GAMMA_VALUE));
+	m_GamaSpin.Attach(GetDlgItem(IDC_GAMMA_SPIN));
+	m_GamaSpin.SetBase(10);
+	m_GamaSpin.SetRange(10, 40);
+	m_GamaSpin.SetPos(20);
+	m_GamaSpin.SetBuddy(m_GamaTxt);
+
+	m_N64ResMultiplerTxt.Attach(GetDlgItem(IDC_N64_RES_MULTIPLER_TXT));
+	m_N64ResMultiplerSpin.Attach(GetDlgItem(IDC_N64_RES_MULTIPLER_SPIN));
+	m_N64ResMultiplerSpin.SetBase(10);
+	m_N64ResMultiplerSpin.SetRange(2, 16);
+	m_N64ResMultiplerSpin.SetPos(2);
+	m_N64ResMultiplerSpin.SetBuddy(m_N64ResMultiplerTxt);
+
+	SIZE iconSz = { ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON) };
+	m_GammaIcon.SubclassWindow(GetDlgItem(IDC_GAMMA_ICON));
+	m_GammaIcon.SetIcon(MAKEINTRESOURCE(IDI_ICON_INFO), iconSz.cx, iconSz.cy);
+	m_GammaIcon.SetWindowPos(HWND_TOP, 0, 0, iconSz.cx, iconSz.cy, SWP_NOMOVE | SWP_NOZORDER);
+	m_GammaIcon.SetBackroundBrush((HBRUSH)GetStockObject(WHITE_BRUSH));
+	return true;
+}
+
+LRESULT CEmulationTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+void CEmulationTab::OnGammaCorrection(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	CButton OverScan(GetDlgItem(IDC_CHK_GAMMA_CORRECTION));
+	if (OverScan.GetCheck() == BST_CHECKED) {
+		GetDlgItem(IDC_GAMMA_ICON).ShowWindow(SW_SHOW);
+		GetDlgItem(IDC_GAMMA_INFO).ShowWindow(SW_SHOW);
+	} else {
+		GetDlgItem(IDC_GAMMA_ICON).ShowWindow(SW_HIDE);
+		GetDlgItem(IDC_GAMMA_INFO).ShowWindow(SW_HIDE);
+	}
+}
+
+void CEmulationTab::OnPerGameSettings(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	m_Dlg.OnCustomSettingsToggled(CButton(GetDlgItem(IDC_CHK_USE_PER_GAME)).GetCheck() == BST_CHECKED);
+}
+
+void CEmulationTab::ApplyLanguage(void)
+{
+	SetDlgItemTextW(IDC_CHK_USE_PER_GAME, wGS(EMULATION_USE_PER_GAME).c_str());
+	SetDlgItemTextW(IDC_CHK_N64_STYLE_MIP_MAPPING, wGS(EMULATION_N64_STYLE_MIP_MAPPING).c_str());
+	SetDlgItemTextW(IDC_CHK_HWLIGHTING, wGS(EMULATION_HWLIGHTING).c_str());
+	SetDlgItemTextW(IDC_CHK_SHADERS_STORAGE, wGS(EMULATION_SHADERS_STORAGE).c_str());
+	SetDlgItemTextW(IDC_INTERNAL_RES_GROUP, wGS(EMULATION_INTERNAL_RES).c_str());
+	SetDlgItemTextW(IDC_FACTOR0X_RADIO, wGS(EMULATION_FACTOR0X).c_str());
+	SetDlgItemTextW(IDC_FACTOR1X_RADIO, wGS(EMULATION_FACTOR1X).c_str());
+	SetDlgItemTextW(IDC_FACTORXX_RADIO, wGS(EMULATION_FACTORXX).c_str());
+	SetDlgItemTextW(IDC_GAMMA_GROUP, wGS(EMULATION_GAMMA).c_str());
+	SetDlgItemTextW(IDC_CHK_GAMMA_CORRECTION, wGS(EMULATION_GAMMA_CORRECTION).c_str());
+	SetDlgItemTextW(IDC_GAMMA_INFO, wGS(EMULATION_GAMMA_INFO).c_str());
+	SetDlgItemTextW(IDC_2D_ELEMENTS_GROUP, wGS(EMULATION_2D_ELEMENTS).c_str());
+	SetDlgItemTextW(IDC_RENDER_2D_ELEMENTS, wGS(EMULATION_RENDER_2D_ELEMENTS).c_str());
+	SetDlgItemTextW(IDC_CHK_HALOS_REMOVAL, wGS(EMULATION_HALOS_REMOVAL).c_str());
+	SetDlgItemTextW(IDC_TXT_FIXBLACK_LINES, wGS(EMULATION_FIX_BLACK_LINES).c_str());
+	SetDlgItemTextW(IDC_FIXTEXRECT_SMART, wGS(EMULATION_ADJACENT_2D_ELEMENTS).c_str());
+	SetDlgItemTextW(IDC_FIXTEXRECT_FORCE, wGS(EMULATION_ALWAYS).c_str());
+	SetDlgItemTextW(IDC_FIXTEXRECT_NEVER, wGS(EMULATION_NEVER).c_str());
+	SetDlgItemTextW(IDC_TXT_BACKGROUND_RENDERING, wGS(EMULATION_BACKGROUND).c_str());
+	SetDlgItemTextW(IDC_BGMODE_ONEPIECE, wGS(EMULATION_ONE_PIECE).c_str());
+	SetDlgItemTextW(IDC_BGMODE_STRIPPED, wGS(EMULATION_STRIPPED).c_str());
+
+	std::wstring tooltip = wGS(EMULATION_USE_PER_GAME_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_USE_PER_GAME), tooltip.c_str());
+	tooltip = wGS(EMULATION_N64_STYLE_MIP_MAPPING_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_N64_STYLE_MIP_MAPPING), tooltip.c_str());
+	tooltip = wGS(EMULATION_HWLIGHTING_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_HWLIGHTING), tooltip.c_str());
+	tooltip = wGS(EMULATION_SHADERS_STORAGE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_SHADERS_STORAGE), tooltip.c_str());
+	tooltip = wGS(EMULATION_INTERNAL_RES_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_INTERNAL_RES_GROUP), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FACTOR0X_RADIO), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FACTOR1X_RADIO), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FACTORXX_RADIO), tooltip.c_str());
+	tooltip = wGS(EMULATION_GAMMA_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_GAMMA_GROUP), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CHK_GAMMA_CORRECTION), tooltip.c_str());
+	tooltip = wGS(EMULATION_RENDER_2D_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_RENDER_2D_ELEMENTS), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_NATIVE_RES_2D), tooltip.c_str());
+	tooltip = wGS(EMULATION_FIX_BLACK_LINES_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_FIXBLACK_LINES), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FIXTEXRECT_SMART), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FIXTEXRECT_FORCE), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FIXTEXRECT_NEVER), tooltip.c_str());
+	tooltip = wGS(EMULATION_BACKGROUND_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_BACKGROUND_RENDERING), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_BGMODE_ONEPIECE), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_BGMODE_STRIPPED), tooltip.c_str());
+
+	CComboBox nativeRes2DComboBox(GetDlgItem(IDC_CMB_NATIVE_RES_2D));
+	int selectedIndx = nativeRes2DComboBox.GetCurSel();
+	nativeRes2DComboBox.ResetContent();
+	nativeRes2DComboBox.AddString(wGS(EMULATION_RENDER_DISABLE).c_str());
+	nativeRes2DComboBox.AddString(wGS(EMULATION_RENDER_ENABLE_OPTIMIZED).c_str());
+	nativeRes2DComboBox.AddString(wGS(EMULATION_RENDER_ENABLE_UNOPTIMIZED).c_str());
+	if (selectedIndx >= 0)
+		nativeRes2DComboBox.SetCurSel(selectedIndx);
+}
+
+void CEmulationTab::LoadSettings(bool blockCustomSettings)
+{
+	if (!blockCustomSettings) {
+		CButton(GetDlgItem(IDC_CHK_USE_PER_GAME)).SetCheck(config.generalEmulation.enableCustomSettings != 0 ? BST_CHECKED : BST_UNCHECKED);
+		m_Dlg.OnCustomSettingsToggled(config.generalEmulation.enableCustomSettings != 0);
+	}
+	CButton(GetDlgItem(IDC_CHK_N64_STYLE_MIP_MAPPING)).SetCheck(config.generalEmulation.enableLOD != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_HWLIGHTING)).SetCheck(config.generalEmulation.enableHWLighting != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_SHADERS_STORAGE)).SetCheck(config.generalEmulation.enableShadersStorage != 0 ? BST_CHECKED : BST_UNCHECKED);
+	
+	CButton(GetDlgItem(IDC_CHK_HALOS_REMOVAL)).SetCheck(config.texture.enableHalosRemoval != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FIXTEXRECT_NEVER)).SetCheck(config.graphics2D.correctTexrectCoords == Config::tcDisable ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FIXTEXRECT_SMART)).SetCheck(config.graphics2D.correctTexrectCoords == Config::tcSmart ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FIXTEXRECT_FORCE)).SetCheck(config.graphics2D.correctTexrectCoords == Config::tcForce ? BST_CHECKED : BST_UNCHECKED);
+
+	CButton(GetDlgItem(IDC_BGMODE_ONEPIECE)).SetCheck(config.graphics2D.bgMode == Config::BGMode::bgOnePiece ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_BGMODE_STRIPPED)).SetCheck(config.graphics2D.bgMode == Config::BGMode::bgStripped ? BST_CHECKED : BST_UNCHECKED);
+
+	CComboBox nativeRes2DComboBox(GetDlgItem(IDC_CMB_NATIVE_RES_2D));
+	nativeRes2DComboBox.SetCurSel(config.graphics2D.enableNativeResTexrects);
+
+	CButton(GetDlgItem(IDC_CHK_GAMMA_CORRECTION)).SetCheck(config.gammaCorrection.force != 0 ? BST_CHECKED : BST_UNCHECKED);
+	int GammaPos = (int)(config.gammaCorrection.force != 0 ? config.gammaCorrection.level : 2.0) * 10;
+	m_GamaSpin.SetPos(GammaPos);
+	m_GamaTxt.SetWindowText(FormatStrW(L"%0.1f", (float)GammaPos / 10.0f).c_str());
+	GetDlgItem(IDC_GAMMA_ICON).ShowWindow(config.gammaCorrection.force != 0 ? SW_SHOW : SW_HIDE);
+	GetDlgItem(IDC_GAMMA_INFO).ShowWindow(config.gammaCorrection.force != 0 ? SW_SHOW : SW_HIDE);
+ 
+	CButton(GetDlgItem(IDC_FACTOR0X_RADIO)).SetCheck(config.frameBufferEmulation.nativeResFactor == 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FACTOR1X_RADIO)).SetCheck(config.frameBufferEmulation.nativeResFactor == 1 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FACTORXX_RADIO)).SetCheck(config.frameBufferEmulation.nativeResFactor > 1 ? BST_CHECKED : BST_UNCHECKED);
+	m_N64ResMultiplerSpin.SetPos(config.frameBufferEmulation.nativeResFactor > 1 ? config.frameBufferEmulation.nativeResFactor : 2);
+	m_N64ResMultiplerTxt.SetWindowText(FormatStrW(L"%dx", m_N64ResMultiplerSpin.GetPos()).c_str());
+}
+
+void CEmulationTab::SaveSettings()
+{
+	config.generalEmulation.enableCustomSettings = CButton(GetDlgItem(IDC_CHK_USE_PER_GAME)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.generalEmulation.enableLOD = CButton(GetDlgItem(IDC_CHK_N64_STYLE_MIP_MAPPING)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.generalEmulation.enableHWLighting = CButton(GetDlgItem(IDC_CHK_HWLIGHTING)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.generalEmulation.enableShadersStorage = CButton(GetDlgItem(IDC_CHK_SHADERS_STORAGE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	
+	if (CButton(GetDlgItem(IDC_FACTOR0X_RADIO)).GetCheck() == BST_CHECKED) {
+		config.frameBufferEmulation.nativeResFactor = 0;
+	} else if (CButton(GetDlgItem(IDC_FACTOR1X_RADIO)).GetCheck() == BST_CHECKED) {
+		config.frameBufferEmulation.nativeResFactor = 1;
+	} else if (CButton(GetDlgItem(IDC_FACTORXX_RADIO)).GetCheck() == BST_CHECKED) {
+		config.frameBufferEmulation.nativeResFactor = m_N64ResMultiplerSpin.GetPos();
+	}
+	config.gammaCorrection.force = CButton(GetDlgItem(IDC_CHK_GAMMA_CORRECTION)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.gammaCorrection.level = ((float)m_GamaSpin.GetPos()) / 10;
+	config.graphics2D.enableNativeResTexrects = CComboBox(GetDlgItem(IDC_CMB_NATIVE_RES_2D)).GetCurSel();
+	config.texture.enableHalosRemoval = CButton(GetDlgItem(IDC_CHK_HALOS_REMOVAL)).GetCheck() == BST_CHECKED ? 1 : 0;
+
+	if (CButton(GetDlgItem(IDC_FIXTEXRECT_NEVER)).GetCheck() == BST_CHECKED) {
+		config.graphics2D.correctTexrectCoords = Config::tcDisable;
+	} else if (CButton(GetDlgItem(IDC_FIXTEXRECT_SMART)).GetCheck() == BST_CHECKED) {
+		config.graphics2D.correctTexrectCoords = Config::tcSmart;
+	} else if (CButton(GetDlgItem(IDC_FIXTEXRECT_FORCE)).GetCheck() == BST_CHECKED) {
+		config.graphics2D.correctTexrectCoords = Config::tcForce;
+	}
+
+	if (CButton(GetDlgItem(IDC_BGMODE_ONEPIECE)).GetCheck() == BST_CHECKED) {
+		config.graphics2D.bgMode = Config::BGMode::bgOnePiece;
+	} else if (CButton(GetDlgItem(IDC_BGMODE_STRIPPED)).GetCheck() == BST_CHECKED) {
+		config.graphics2D.bgMode = Config::BGMode::bgStripped;
+	}
+}
+
+LRESULT CEmulationTab::OnScroll(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+{
+	LONG CtrlId = CWindow((HWND)lParam).GetWindowLong(GWL_ID);
+	if (CtrlId == IDC_GAMMA_SPIN) {
+		int Pos = m_GamaSpin.GetPos();
+		m_GamaTxt.SetWindowText(FormatStrW(L"%0.1f", (float)Pos / 10.0f).c_str());
+	} else if (CtrlId == IDC_N64_RES_MULTIPLER_SPIN) {
+		int Pos = m_N64ResMultiplerSpin.GetPos();
+		m_N64ResMultiplerTxt.SetWindowText(FormatStrW(L"%dx", Pos).c_str());
+	}
+	return 0;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/config-emulation.h b/GLideN64/src/GLideNUI-wtl/config-emulation.h
new file mode 100644
index 00000000..69f49d30
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-emulation.h
@@ -0,0 +1,41 @@
+#pragma once
+#include "config-tab.h"
+#include "wtl-BitmapPicture.h"
+#include "wtl-tooltip.h"
+#include "resource.h"
+
+class CConfigDlg;
+
+class CEmulationTab :
+	public CConfigTab,
+	public CToolTipDialog<CEmulationTab>
+{
+public:
+	BEGIN_MSG_MAP(CEmulationTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
+		COMMAND_HANDLER_EX(IDC_CHK_GAMMA_CORRECTION, BN_CLICKED, OnGammaCorrection)
+		COMMAND_HANDLER_EX(IDC_CHK_USE_PER_GAME, BN_CLICKED, OnPerGameSettings)
+		CHAIN_MSG_MAP(CToolTipDialog<CEmulationTab>)
+		REFLECT_NOTIFICATIONS()
+	END_MSG_MAP()
+
+	CEmulationTab(CConfigDlg & Dlg);
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+	void OnGammaCorrection(UINT /*Code*/, int id, HWND /*ctl*/);
+	void OnPerGameSettings(UINT /*Code*/, int id, HWND /*ctl*/);
+	void ApplyLanguage(void);
+	void LoadSettings(bool /*blockCustomSettings*/);
+	void SaveSettings();
+
+private:
+	LRESULT OnScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/);
+
+	CEdit m_GamaTxt, m_N64ResMultiplerTxt;
+	CUpDownCtrl m_GamaSpin, m_N64ResMultiplerSpin;
+	CBitmapPicture m_GammaIcon;
+	CConfigDlg & m_Dlg;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp b/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp
new file mode 100644
index 00000000..7c486d37
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp
@@ -0,0 +1,190 @@
+#include "config-framebuffer.h"
+#include "resource.h"
+#include "../Config.h"
+#include "Language.h"
+
+CFrameBufferTab::CFrameBufferTab() :
+	CConfigTab(IDD_TAB_FRAME_BUFFER)
+{
+}
+
+BOOL CFrameBufferTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+{
+	TTInit();
+	TTSize(400);
+
+	SIZE iconSz = { ::GetSystemMetrics(SM_CXICON), ::GetSystemMetrics(SM_CYICON) };
+	m_EmulateFBIcon.SubclassWindow(GetDlgItem(IDC_EMULATE_FB_ICON));
+	m_EmulateFBIcon.SetIcon(MAKEINTRESOURCE(IDI_ICON_WARNING), iconSz.cx, iconSz.cy);
+	m_EmulateFBIcon.SetWindowPos(HWND_TOP, 0, 0, iconSz.cx, iconSz.cy, SWP_NOMOVE | SWP_NOZORDER);
+	m_EmulateFBIcon.SetBackroundBrush((HBRUSH)GetStockObject(WHITE_BRUSH));
+
+	CComboBox frameBufferSwapComboBox(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP));
+	frameBufferSwapComboBox.AddString(wGS(FRAMEBUFFER_VERTICAL_INTERRUPT).c_str());
+	frameBufferSwapComboBox.AddString(wGS(FRAMEBUFFER_VI_ORIGIN_CHANGE).c_str());
+	frameBufferSwapComboBox.AddString(wGS(FRAMEBUFFER_COLOR_BUFFER_CHANGE).c_str());
+
+	CComboBox copyColorBufferComboBox(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER));
+	copyColorBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_NEVER).c_str());
+	copyColorBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_SYNCHRONOUS).c_str());
+	copyColorBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_ASYNCHRONOUS).c_str());
+
+	CComboBox copyDepthBufferComboBox(GetDlgItem(IDC_CMB_COPY_DEPTH_BUFFER));
+	copyDepthBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_DEPTH_NEVER).c_str());
+	copyDepthBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_DEPTH_VRAM).c_str());
+	copyDepthBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_DEPTH_SOFTWARE).c_str());
+
+	CComboBox n64DepthCompareComboBox(GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE));
+	n64DepthCompareComboBox.AddString(wGS(FRAMEBUFFER_N64_DEPTH_DISABLE).c_str());
+	n64DepthCompareComboBox.AddString(wGS(FRAMEBUFFER_N64_DEPTH_FAST).c_str());
+	n64DepthCompareComboBox.AddString(wGS(FRAMEBUFFER_N64_DEPTH_COMPATIBLE).c_str());
+	return true;
+}
+
+void CFrameBufferTab::ApplyLanguage(void)
+{
+	SetDlgItemTextW(IDC_CHK_ENABLE_FRAMEBUFFER, wGS(FRAMEBUFFER_ENABLE).c_str());
+	SetDlgItemTextW(IDC_FRAME_BUFFER_INFO, wGS(FRAMEBUFFER_ENABLE_INFO).c_str());
+	SetDlgItemTextW(IDC_CHK_COPY_AUX_BUFFERS, wGS(FRAMEBUFFER_COPY_AUX_BUFFERS).c_str());
+	SetDlgItemTextW(IDC_TXT_FRAMEBUFFER_SWAP, wGS(FRAMEBUFFER_SWAP).c_str());
+	SetDlgItemTextW(IDC_CHK_FB_INFO_ENABLE, wGS(FRAMEBUFFER_INFO_ENABLE).c_str());
+	SetDlgItemTextW(IDC_CHK_READ_COLOR_CHUNK, wGS(FRAMEBUFFER_READ_COLOR_CHUNK).c_str());
+	SetDlgItemTextW(IDC_CHK_READ_DEPTH_CHUNK, wGS(FRAMEBUFFER_READ_DEPTH_CHUNK).c_str());
+	SetDlgItemTextW(IDC_TXT_COPY_COLOR_BUFFER, wGS(FRAMEBUFFER_COPY_COLOR_BUFFER).c_str());
+	SetDlgItemTextW(IDC_TXT_COPY_DEPTH_BUFFER, wGS(FRAMEBUFFER_COPY_DEPTH_BUFFER).c_str());
+	SetDlgItemTextW(IDC_TXT_N64_DEPTH_COMPARE, wGS(FRAMEBUFFER_N64_DEPTH_COMPARE).c_str());
+	SetDlgItemTextW(IDC_CHK_FORCE_DEPTH_BUFFER_CLEAR, wGS(FRAMEBUFFER_FORCE_DEPTH_BUFFER_CLEAR).c_str());
+	SetDlgItemTextW(IDC_CHK_RENDER_FRAMEBUFFER, wGS(FRAMEBUFFER_RENDER_FRAMEBUFFER).c_str());
+	SetDlgItemTextW(IDC_CHK_COPY_DEPTH_TO_MAIN_DEPTH_BUFFER, wGS(FRAMEBUFFER_COPY_DEPTH_TO_MAIN).c_str());
+
+	std::wstring tooltip = wGS(FRAMEBUFFER_COPY_AUX_BUFFERS_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_COPY_AUX_BUFFERS), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_SWAP_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_FRAMEBUFFER_SWAP), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_INFO_ENABLE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_FB_INFO_ENABLE), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_READ_COLOR_CHUNK_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_READ_COLOR_CHUNK), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_READ_DEPTH_CHUNK_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_READ_DEPTH_CHUNK), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_COPY_COLOR_BUFFER_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_COPY_COLOR_BUFFER), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_COPY_DEPTH_BUFFER_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_COPY_COLOR_BUFFER), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_COPY_DEPTH_BUFFER), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_N64_DEPTH_COMPARE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_N64_DEPTH_COMPARE), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_FORCE_DEPTH_BUFFER_CLEAR_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_FORCE_DEPTH_BUFFER_CLEAR), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_RENDER_FRAMEBUFFER_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_RENDER_FRAMEBUFFER), tooltip.c_str());
+	tooltip = wGS(FRAMEBUFFER_COPY_DEPTH_TO_MAIN_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_COPY_DEPTH_TO_MAIN_DEPTH_BUFFER), tooltip.c_str());
+
+	CComboBox frameBufferSwapComboBox(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP));
+	int selectedIndx = frameBufferSwapComboBox.GetCurSel();
+	frameBufferSwapComboBox.ResetContent();
+	frameBufferSwapComboBox.AddString(wGS(FRAMEBUFFER_VERTICAL_INTERRUPT).c_str());
+	frameBufferSwapComboBox.AddString(wGS(FRAMEBUFFER_VI_ORIGIN_CHANGE).c_str());
+	frameBufferSwapComboBox.AddString(wGS(FRAMEBUFFER_COLOR_BUFFER_CHANGE).c_str());
+	if (selectedIndx >= 0)
+		frameBufferSwapComboBox.SetCurSel(selectedIndx);
+
+	CComboBox copyColorBufferComboBox(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER));
+	selectedIndx = copyColorBufferComboBox.GetCurSel();
+	copyColorBufferComboBox.ResetContent();
+	copyColorBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_NEVER).c_str());
+	copyColorBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_SYNCHRONOUS).c_str());
+	copyColorBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_ASYNCHRONOUS).c_str());
+	if (selectedIndx >= 0)
+		copyColorBufferComboBox.SetCurSel(selectedIndx);
+
+	CComboBox copyDepthBufferComboBox(GetDlgItem(IDC_CMB_COPY_DEPTH_BUFFER));
+	selectedIndx = copyDepthBufferComboBox.GetCurSel();
+	copyDepthBufferComboBox.ResetContent();
+	copyDepthBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_DEPTH_NEVER).c_str());
+	copyDepthBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_DEPTH_VRAM).c_str());
+	copyDepthBufferComboBox.AddString(wGS(FRAMEBUFFER_COPY_DEPTH_SOFTWARE).c_str());
+	if (selectedIndx >= 0)
+		copyDepthBufferComboBox.SetCurSel(selectedIndx);
+
+	CComboBox n64DepthCompareComboBox(GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE));
+	selectedIndx = n64DepthCompareComboBox.GetCurSel();
+	n64DepthCompareComboBox.ResetContent();
+	n64DepthCompareComboBox.AddString(wGS(FRAMEBUFFER_N64_DEPTH_DISABLE).c_str());
+	n64DepthCompareComboBox.AddString(wGS(FRAMEBUFFER_N64_DEPTH_FAST).c_str());
+	n64DepthCompareComboBox.AddString(wGS(FRAMEBUFFER_N64_DEPTH_COMPATIBLE).c_str());
+	if (selectedIndx >= 0)
+		n64DepthCompareComboBox.SetCurSel(selectedIndx);
+}
+
+LRESULT CFrameBufferTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+LRESULT CFrameBufferTab::OnEnableFramebuffer(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	bool fbEmulationEnabled = CButton(GetDlgItem(IDC_CHK_ENABLE_FRAMEBUFFER)).GetCheck() == BST_CHECKED;
+	bool fbInfoEnabled = CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).GetCheck() == BST_CHECKED;
+	CButton(GetDlgItem(IDC_CHK_COPY_AUX_BUFFERS)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CMB_COPY_DEPTH_BUFFER)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CHK_FORCE_DEPTH_BUFFER_CLEAR)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CHK_RENDER_FRAMEBUFFER)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CHK_COPY_DEPTH_TO_MAIN_DEPTH_BUFFER)).EnableWindow(fbEmulationEnabled);
+	CButton(GetDlgItem(IDC_CHK_READ_COLOR_CHUNK)).EnableWindow(fbEmulationEnabled && fbInfoEnabled);
+	CButton(GetDlgItem(IDC_CHK_READ_DEPTH_CHUNK)).EnableWindow(fbEmulationEnabled && fbInfoEnabled);
+	return 0;
+}
+
+
+LRESULT CFrameBufferTab::OnFbInfoEnable(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	bool fbInfoEnabled = CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).GetCheck() == BST_CHECKED;
+	CButton(GetDlgItem(IDC_CHK_READ_COLOR_CHUNK)).EnableWindow(fbInfoEnabled);
+	CButton(GetDlgItem(IDC_CHK_READ_DEPTH_CHUNK)).EnableWindow(fbInfoEnabled);
+	return 0;
+}
+
+void CFrameBufferTab::LoadSettings(bool /*blockCustomSettings*/)
+{
+	const bool fbEmulationEnabled = config.frameBufferEmulation.enable != 0;
+	CButton(GetDlgItem(IDC_CHK_ENABLE_FRAMEBUFFER)).SetCheck(fbEmulationEnabled != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_COPY_AUX_BUFFERS)).SetCheck(config.frameBufferEmulation.copyAuxToRDRAM != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CComboBox(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP)).SetCurSel(config.frameBufferEmulation.bufferSwapMode);
+	CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).SetCheck(config.frameBufferEmulation.fbInfoDisabled == 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_READ_COLOR_CHUNK)).SetCheck(config.frameBufferEmulation.fbInfoReadColorChunk != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_READ_DEPTH_CHUNK)).SetCheck(config.frameBufferEmulation.fbInfoReadDepthChunk != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CComboBox(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER)).SetCurSel(config.frameBufferEmulation.copyToRDRAM);
+	CComboBox(GetDlgItem(IDC_CMB_COPY_DEPTH_BUFFER)).SetCurSel(config.frameBufferEmulation.copyDepthToRDRAM);
+	CComboBox(GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE)).SetCurSel(config.frameBufferEmulation.N64DepthCompare);
+	CButton(GetDlgItem(IDC_CHK_FORCE_DEPTH_BUFFER_CLEAR)).SetCheck(config.frameBufferEmulation.forceDepthBufferClear != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_RENDER_FRAMEBUFFER)).SetCheck(config.frameBufferEmulation.copyFromRDRAM != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_COPY_DEPTH_TO_MAIN_DEPTH_BUFFER)).SetCheck(config.frameBufferEmulation.copyDepthToMainDepthBuffer != 0 ? BST_CHECKED : BST_UNCHECKED);
+
+	OnFbInfoEnable(0, 0, NULL);
+	OnEnableFramebuffer(0, 0, NULL);
+}
+
+void CFrameBufferTab::SaveSettings()
+{
+	config.frameBufferEmulation.enable = CButton(GetDlgItem(IDC_CHK_ENABLE_FRAMEBUFFER)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.copyAuxToRDRAM = CButton(GetDlgItem(IDC_CHK_COPY_AUX_BUFFERS)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.bufferSwapMode = CComboBox(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP)).GetCurSel();
+	config.frameBufferEmulation.fbInfoDisabled = CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.fbInfoReadColorChunk = CButton(GetDlgItem(IDC_CHK_READ_COLOR_CHUNK)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.fbInfoReadDepthChunk = CButton(GetDlgItem(IDC_CHK_READ_DEPTH_CHUNK)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.copyToRDRAM = CComboBox(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER)).GetCurSel();
+	config.frameBufferEmulation.copyDepthToRDRAM = CComboBox(GetDlgItem(IDC_CMB_COPY_DEPTH_BUFFER)).GetCurSel();
+	config.frameBufferEmulation.N64DepthCompare = CComboBox(GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE)).GetCurSel();
+	config.frameBufferEmulation.forceDepthBufferClear = CButton(GetDlgItem(IDC_CHK_FORCE_DEPTH_BUFFER_CLEAR)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.copyFromRDRAM = CButton(GetDlgItem(IDC_CHK_RENDER_FRAMEBUFFER)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.copyDepthToMainDepthBuffer = CButton(GetDlgItem(IDC_CHK_COPY_DEPTH_TO_MAIN_DEPTH_BUFFER)).GetCheck() == BST_CHECKED ? 1 : 0;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/config-framebuffer.h b/GLideN64/src/GLideNUI-wtl/config-framebuffer.h
new file mode 100644
index 00000000..937dbbfd
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-framebuffer.h
@@ -0,0 +1,33 @@
+#pragma once
+#include "config-tab.h"
+#include "wtl-BitmapPicture.h"
+#include "wtl-tooltip.h"
+#include "resource.h"
+
+class CFrameBufferTab :
+	public CConfigTab,
+	public CToolTipDialog<CFrameBufferTab>
+{
+public:
+	BEGIN_MSG_MAP(CFrameBufferTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		COMMAND_HANDLER_EX(IDC_CHK_ENABLE_FRAMEBUFFER, BN_CLICKED, OnEnableFramebuffer)
+		COMMAND_HANDLER_EX(IDC_CHK_FB_INFO_ENABLE, BN_CLICKED, OnFbInfoEnable)
+		CHAIN_MSG_MAP(CToolTipDialog<CFrameBufferTab>)
+	END_MSG_MAP()
+	
+	CFrameBufferTab();
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+	LRESULT OnEnableFramebuffer(UINT /*Code*/, int id, HWND /*ctl*/);
+	LRESULT OnFbInfoEnable(UINT /*Code*/, int id, HWND /*ctl*/);
+	void ApplyLanguage(void);
+	void LoadSettings(bool blockCustomSettings);
+	void SaveSettings();
+
+private:
+	CBitmapPicture m_EmulateFBIcon;
+};
+
diff --git a/GLideN64/src/GLideNUI-wtl/config-osd.cpp b/GLideN64/src/GLideNUI-wtl/config-osd.cpp
new file mode 100644
index 00000000..8c923089
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-osd.cpp
@@ -0,0 +1,301 @@
+#include "config-osd.h"
+#include "resource.h"
+#include "util.h"
+#include "../Config.h"
+#include "FontInfo.h"
+#include "Language.h"
+
+COsdTab::COsdTab() :
+	CConfigTab(IDD_TAB_OSD),
+	m_PosTopLeft(IDI_OSD_TOP_LEFT),
+	m_PosTop(IDI_OSD_TOP),
+	m_PosTopRight(IDI_OSD_TOP_RIGHT),
+	m_PosCenterLeft(IDI_OSD_LEFT),
+	m_PosCenter(0),
+	m_PosCenterRight(IDI_OSD_RIGHT),
+	m_PosBottomLeft(IDI_OSD_BOTTOM_LEFT),
+	m_PosBottom(IDI_OSD_BOTTOM),
+	m_PosBottomRight(IDI_OSD_BOTTOM_RIGHT)
+{
+	m_FontsLoaded = false;
+}
+
+BOOL COsdTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+{
+	m_PosTopLeft.SubclassWindow(GetDlgItem(IDC_OSD_TOP_LEFT));
+	m_PosTop.SubclassWindow(GetDlgItem(IDC_OSD_TOP));
+	m_PosTopRight.SubclassWindow(GetDlgItem(IDC_OSD_TOP_RIGHT));
+	m_PosCenterLeft.SubclassWindow(GetDlgItem(IDC_OSD_CENTER_LEFT));
+	m_PosCenter.SubclassWindow(GetDlgItem(IDC_OSD_CENTER));
+	m_PosCenterRight.SubclassWindow(GetDlgItem(IDC_OSD_CENTER_RIGHT));
+	m_PosBottomLeft.SubclassWindow(GetDlgItem(IDC_OSD_BOTTOM_LEFT));
+	m_PosBottom.SubclassWindow(GetDlgItem(IDC_OSD_BOTTOM));
+	m_PosBottomRight.SubclassWindow(GetDlgItem(IDC_OSD_BOTTOM_RIGHT));
+	m_Fonts.Attach(GetDlgItem(IDC_FONTS));
+	m_OsdColor.SubclassWindow(GetDlgItem(IDC_OSD_COLOR));
+	m_OsdPreview.SubclassWindow(GetDlgItem(IDC_OSD_PREVIEW));
+
+	m_FontSizeTxt.Attach(GetDlgItem(IDC_FONT_SIZE_TXT));
+	m_FontSizeSpin.Attach(GetDlgItem(IDC_FONT_SIZE_SPIN));
+	m_FontSizeSpin.SetBase(10);
+	m_FontSizeSpin.SetRange(6, 99);
+	m_FontSizeSpin.SetBuddy(m_FontSizeTxt);
+
+	m_PosCenterLeft.EnableWindow(false);
+	m_PosCenter.EnableWindow(false);
+	m_PosCenterRight.EnableWindow(false);
+
+	return true;
+}
+
+void COsdTab::LoadFonts(void)
+{
+	FontList fonts = GetFontFiles();
+	HTREEITEM hCurrentItem = TVI_ROOT;
+	for (FontList::const_iterator itr = fonts.begin(); itr != fonts.end(); itr++) {
+		std::wstring FontFile = ToUTF16(itr->first.c_str());
+		std::wstring FontName = ToUTF16(itr->second.c_str());
+
+		TVINSERTSTRUCT tv = { 0 };
+		wchar_t Item[500];
+		tv.item.mask = TVIF_TEXT;
+		tv.item.pszText = Item;
+		tv.item.cchTextMax = sizeof(Item) / sizeof(Item[0]);
+		tv.item.hItem = m_Fonts.GetChildItem(TVI_ROOT);
+		HTREEITEM hParent = TVI_ROOT;
+		while (tv.item.hItem) {
+			m_Fonts.GetItem(&tv.item);
+			if (wcscmp(FontName.c_str(), Item) == 0) {
+				hParent = tv.item.hItem;
+				break;
+			}
+			tv.item.hItem = m_Fonts.GetNextSiblingItem(tv.item.hItem);
+		}
+
+		if (hParent == TVI_ROOT) {
+			tv.item.mask = TVIF_TEXT;
+			tv.item.pszText = (LPWSTR)FontName.c_str();
+			tv.item.cchTextMax = FontName.length();
+			tv.hInsertAfter = TVI_SORT;
+			tv.hParent = TVI_ROOT;
+			hParent = m_Fonts.InsertItem(&tv);
+		}
+		tv.item.mask = TVIF_TEXT;
+		tv.item.pszText = (LPWSTR)FontFile.c_str();
+		tv.item.cchTextMax = FontFile.length();
+		tv.hInsertAfter = TVI_SORT;
+		tv.hParent = hParent;
+		m_Fonts.InsertItem(&tv);
+	}
+	if (hCurrentItem != TVI_ROOT) {
+		m_Fonts.SelectItem(hCurrentItem);
+		m_Fonts.SetItemState(hCurrentItem, TVIF_STATE | TVIS_SELECTED, TVIF_STATE | TVIS_SELECTED);
+		m_Fonts.SetFocus();
+	}
+	m_FontsLoaded = true;
+	SelCurrentFont();
+}
+
+void COsdTab::SelCurrentFont(void)
+{
+	std::wstring CurrentFile = ToUTF16(config.font.name.c_str());
+	TVINSERTSTRUCT tv = { 0 };
+	wchar_t Item[500];
+	tv.item.mask = TVIF_TEXT;
+	tv.item.pszText = Item;
+	tv.item.cchTextMax = sizeof(Item) / sizeof(Item[0]);
+	tv.item.hItem = m_Fonts.GetChildItem(TVI_ROOT);
+	HTREEITEM hCurrentItem = NULL;
+	while (tv.item.hItem) {
+		m_Fonts.GetItem(&tv.item);
+		m_Fonts.SetItemState(tv.item.hItem, 0, TVIF_STATE | TVIS_SELECTED);
+		HTREEITEM hChild = m_Fonts.GetChildItem(tv.item.hItem);
+		HTREEITEM NextItem = m_Fonts.GetNextSiblingItem(tv.item.hItem);
+		if (hChild != NULL) {
+			tv.item.hItem = hChild;
+			while (tv.item.hItem) {
+				m_Fonts.GetItem(&tv.item);
+				m_Fonts.SetItemState(tv.item.hItem, 0, TVIF_STATE | TVIS_SELECTED);
+				if (Item == CurrentFile)
+					hCurrentItem = tv.item.hItem;
+				tv.item.hItem = m_Fonts.GetNextSiblingItem(tv.item.hItem);
+			}
+		}
+		tv.item.hItem = NextItem;
+	}
+	if (hCurrentItem != TVI_ROOT) {
+		m_Fonts.SelectItem(hCurrentItem);
+		m_Fonts.SetItemState(hCurrentItem, TVIF_STATE | TVIS_SELECTED, TVIF_STATE | TVIS_SELECTED);
+		m_Fonts.SetFocus();
+	}
+}
+
+void COsdTab::ApplyLanguage(void)
+{
+	SetDlgItemTextW(IDC_POSITION, wGS(OSD_POSITION).c_str());
+	SetDlgItemTextW(IDC_CHK_FPS, wGS(OSD_DISPLAY_FPS).c_str());
+	SetDlgItemTextW(IDC_CHK_VIS, wGS(OSD_DISPLAY_VI).c_str());
+	SetDlgItemTextW(IDC_CHK_PERCENT, wGS(OSD_DISPLAY_PERCENTAGE).c_str());
+	SetDlgItemTextW(IDC_INTERNAL_RESOLUTION, wGS(OSD_DISPLAY_INTERNAL_RESOLUTION).c_str());
+	SetDlgItemTextW(IDC_RENDERING_RESOLUTION, wGS(OSD_DISPLAY_RENDERING_RESOLUTION).c_str());
+	SetDlgItemTextW(IDC_FONT, wGS(OSD_FONT).c_str());
+	SetDlgItemTextW(IDC_TXT_SIZE, wGS(OSD_SIZE).c_str());
+	SetDlgItemTextW(IDC_PX, wGS(OSD_PX).c_str());
+	SetDlgItemTextW(IDC_COLOR, wGS(OSD_COLOR).c_str());
+}
+
+LRESULT COsdTab::OnScroll(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+{
+	LONG CtrlId = CWindow((HWND)lParam).GetWindowLong(GWL_ID);
+	if (CtrlId == IDC_FONT_SIZE_SPIN)
+		m_OsdPreview.SetFontSize(m_FontSizeSpin.GetPos());
+	return 0;
+}
+
+void COsdTab::ClearOsdChecked()
+{
+	m_PosTopLeft.SetChecked(false);
+	m_PosTopLeft.Invalidate();
+	m_PosTop.SetChecked(false);
+	m_PosTop.Invalidate();
+	m_PosTopRight.SetChecked(false);
+	m_PosTopRight.Invalidate();
+	m_PosBottomLeft.SetChecked(false);
+	m_PosBottomLeft.Invalidate();
+	m_PosBottom.SetChecked(false);
+	m_PosBottom.Invalidate();
+	m_PosBottomRight.SetChecked(false);
+	m_PosBottomRight.Invalidate();
+}
+
+LRESULT COsdTab::OnOsdTopLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	ClearOsdChecked();
+	m_PosTopLeft.SetChecked(true);
+	return 0;
+}
+
+LRESULT COsdTab::OnOsdTop(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	ClearOsdChecked();
+	m_PosTop.SetChecked(true);
+	return 0;
+}
+
+LRESULT COsdTab::OnOsdTopRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	ClearOsdChecked();
+	m_PosTopRight.SetChecked(true);
+	return 0;
+}
+
+LRESULT COsdTab::OnOsdBottomLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	ClearOsdChecked();
+	m_PosBottomLeft.SetChecked(true);
+	return 0;
+}
+
+LRESULT COsdTab::OnOsdBottom(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	ClearOsdChecked();
+	m_PosBottom.SetChecked(true);
+	return 0;
+}
+
+LRESULT COsdTab::OnOsdBottomRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	ClearOsdChecked();
+	m_PosBottomRight.SetChecked(true);
+	return 0;
+}
+
+LRESULT COsdTab::OnFontItemChanged(NMHDR* /*phdr*/)
+{
+	m_OsdPreview.SetFont(GetSelectedFont());
+	return 0;
+}
+
+LRESULT COsdTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+LRESULT COsdTab::OnNotifyOsdColor(LPNMHDR /*pnmh*/)
+{
+	m_OsdPreview.SetColor(m_OsdColor.Red(), m_OsdColor.Green(), m_OsdColor.Blue());
+	m_OsdPreview.Invalidate();
+	return 0;
+}
+
+void COsdTab::LoadSettings(bool /*blockCustomSettings*/)
+{
+	m_FontSizeTxt.SetWindowText(FormatStrW(L"%d", config.font.size).c_str());
+	if (config.font.size > 0) {
+		m_FontSizeSpin.SetPos(config.font.size);
+		m_OsdPreview.SetFontSize(config.font.size);
+	}
+	if (!(config.font.color[0] == NULL && config.font.color[1] == NULL && config.font.color[2] == NULL)) {
+		m_OsdColor.SetColor(config.font.color[0], config.font.color[1], config.font.color[2]);
+		m_OsdPreview.SetColor(config.font.color[0], config.font.color[1], config.font.color[2]);
+	}
+	
+	m_PosTopLeft.SetChecked(config.onScreenDisplay.pos == Config::posTopLeft); 
+	m_PosTop.SetChecked(config.onScreenDisplay.pos == Config::posTopCenter); 
+	m_PosTopRight.SetChecked(config.onScreenDisplay.pos == Config::posTopRight);
+	m_PosBottomLeft.SetChecked(config.onScreenDisplay.pos == Config::posBottomLeft);
+	m_PosBottom.SetChecked(config.onScreenDisplay.pos == Config::posBottomCenter);
+	m_PosBottomRight.SetChecked(config.onScreenDisplay.pos == Config::posBottomRight); 
+
+	CButton(GetDlgItem(IDC_CHK_FPS)).SetCheck(config.onScreenDisplay.fps != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_VIS)).SetCheck(config.onScreenDisplay.vis != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_PERCENT)).SetCheck(config.onScreenDisplay.percent != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_INTERNAL_RESOLUTION)).SetCheck(config.onScreenDisplay.internalResolution != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_RENDERING_RESOLUTION)).SetCheck(config.onScreenDisplay.renderingResolution != 0 ? BST_CHECKED : BST_UNCHECKED);
+
+	if (m_FontsLoaded)
+		SelCurrentFont();
+}
+
+void COsdTab::SaveSettings()
+{
+	if (m_PosTopLeft.isChecked()) { config.onScreenDisplay.pos = Config::posTopLeft; }
+	else if (m_PosTop.isChecked()) { config.onScreenDisplay.pos = Config::posTopCenter; }
+	else if (m_PosTopRight.isChecked()) { config.onScreenDisplay.pos = Config::posTopRight; }
+	else if (m_PosBottomLeft.isChecked()) { config.onScreenDisplay.pos = Config::posBottomLeft; }
+	else if (m_PosBottom.isChecked()) { config.onScreenDisplay.pos = Config::posBottomCenter; }
+	else if (m_PosBottomRight.isChecked()) { config.onScreenDisplay.pos = Config::posBottomRight; }
+
+	config.onScreenDisplay.fps = CButton(GetDlgItem(IDC_CHK_FPS)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.onScreenDisplay.vis = CButton(GetDlgItem(IDC_CHK_VIS)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.onScreenDisplay.percent = CButton(GetDlgItem(IDC_CHK_PERCENT)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.onScreenDisplay.internalResolution = CButton(GetDlgItem(IDC_INTERNAL_RESOLUTION)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.onScreenDisplay.renderingResolution = CButton(GetDlgItem(IDC_RENDERING_RESOLUTION)).GetCheck() == BST_CHECKED ? 1 : 0;
+
+	config.font.name = FromUTF16(GetSelectedFont().c_str());
+	config.font.size = m_FontSizeSpin.GetPos();
+
+	config.font.color[0] = m_OsdColor.Red();
+	config.font.color[1] = m_OsdColor.Green();
+	config.font.color[2] = m_OsdColor.Blue();
+	config.font.color[3] = 0;
+	config.font.colorf[0] = (float)m_OsdColor.Red();
+	config.font.colorf[1] = (float)m_OsdColor.Green();
+	config.font.colorf[2] = (float)m_OsdColor.Blue();
+	config.font.colorf[3] = 0.0f;
+}
+
+std::wstring COsdTab::GetSelectedFont()
+{
+	HTREEITEM hItem = m_Fonts.GetSelectedItem();
+	if (hItem == NULL)
+		return L"";
+	HTREEITEM hChild = m_Fonts.GetChildItem(hItem);
+	if (hChild != NULL)
+		hItem = hChild;
+
+	wchar_t ItemText[MAX_PATH];
+	if (!m_Fonts.GetItemText(hItem, ItemText, sizeof(ItemText) / sizeof(ItemText[0])))
+		return L"";
+	return std::wstring(ItemText);
+}
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/config-osd.h b/GLideN64/src/GLideNUI-wtl/config-osd.h
new file mode 100644
index 00000000..c637e009
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-osd.h
@@ -0,0 +1,61 @@
+#pragma once
+#include "config-tab.h"
+#include "wtl-OsdButton.h"
+#include "wtl-ColorButton.h"
+#include "wtl-OsdPreview.h"
+#include "resource.h"
+#include <string>
+
+class COsdTab :
+	public CConfigTab
+{
+public:
+	BEGIN_MSG_MAP(COsdTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		NOTIFY_HANDLER_EX(IDC_FONTS, TVN_SELCHANGED, OnFontItemChanged)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
+		COMMAND_ID_HANDLER(IDC_OSD_TOP_LEFT, OnOsdTopLeft)
+		COMMAND_ID_HANDLER(IDC_OSD_TOP, OnOsdTop)
+		COMMAND_ID_HANDLER(IDC_OSD_TOP_RIGHT, OnOsdTopRight)
+		COMMAND_ID_HANDLER(IDC_OSD_BOTTOM_LEFT, OnOsdBottomLeft)
+		COMMAND_ID_HANDLER(IDC_OSD_BOTTOM, OnOsdBottom)
+		COMMAND_ID_HANDLER(IDC_OSD_BOTTOM_RIGHT, OnOsdBottomRight)
+		NOTIFY_HANDLER_EX(IDC_OSD_COLOR, CColorButton::CPN_SELCHANGE, OnNotifyOsdColor)
+		REFLECT_NOTIFICATIONS()
+	END_MSG_MAP()
+
+	COsdTab();
+
+	bool m_FontsLoaded;
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
+	LRESULT OnScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/);
+	void ClearOsdChecked();
+	LRESULT OnOsdTopLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+	LRESULT OnOsdTop(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+	LRESULT OnOsdTopRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+	LRESULT OnOsdBottomLeft(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+	LRESULT OnOsdBottom(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+	LRESULT OnOsdBottomRight(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+	LRESULT OnFontItemChanged(NMHDR* /*phdr*/);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+	LRESULT OnNotifyOsdColor(LPNMHDR pnmh);
+	void ApplyLanguage(void);
+	void LoadFonts(void);
+	void SelCurrentFont(void);
+	void LoadSettings(bool blockCustomSettings);
+	void SaveSettings();
+
+private:
+	std::wstring GetSelectedFont();
+
+	COSDButton m_PosTopLeft, m_PosTop, m_PosTopRight;
+	COSDButton m_PosCenterLeft, m_PosCenter, m_PosCenterRight;
+	COSDButton m_PosBottomLeft, m_PosBottom, m_PosBottomRight;
+	CTreeViewCtrl m_Fonts;
+	CEdit m_FontSizeTxt;
+	CUpDownCtrl m_FontSizeSpin;
+	CColorButton m_OsdColor;
+	COsdPreview m_OsdPreview;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/config-overscan.cpp b/GLideN64/src/GLideNUI-wtl/config-overscan.cpp
new file mode 100644
index 00000000..614ad714
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-overscan.cpp
@@ -0,0 +1,61 @@
+#include "config-overscan.h"
+#include "util.h"
+#include "resource.h"
+
+COverScanTab::COverScanTab()
+{
+	IDD = IDD_TAB_OVERSCAN;
+}
+
+BOOL COverScanTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+{
+	m_LeftTxt.Attach(GetDlgItem(IDC_OVERSCAN_LEFT_TXT));
+	m_LeftSpin.Attach(GetDlgItem(IDC_OVERSCAN_LEFT_SPIN));
+	m_LeftSpin.SetBase(10);
+	m_LeftSpin.SetRange(-99, 99);
+	m_LeftSpin.SetBuddy(m_LeftTxt);
+
+	m_RightTxt.Attach(GetDlgItem(IDC_OVERSCAN_RIGHT_TXT));
+	m_RightSpin.Attach(GetDlgItem(IDC_OVERSCAN_RIGHT_SPIN));
+	m_RightSpin.SetBase(10);
+	m_RightSpin.SetRange(-99, 99);
+	m_RightSpin.SetBuddy(m_RightTxt);
+
+	m_TopTxt.Attach(GetDlgItem(IDC_OVERSCAN_TOP_TXT));
+	m_TopSpin.Attach(GetDlgItem(IDC_OVERSCAN_TOP_SPIN));
+	m_TopSpin.SetBase(10);
+	m_TopSpin.SetRange(-99, 99);
+	m_TopSpin.SetBuddy(m_TopTxt);
+
+	m_BottomTxt.Attach(GetDlgItem(IDC_OVERSCAN_BOTTOM_TXT));
+	m_BottomSpin.Attach(GetDlgItem(IDC_OVERSCAN_BOTTOM_SPIN));
+	m_BottomSpin.SetBase(10);
+	m_BottomSpin.SetRange(-99, 99);
+	m_BottomSpin.SetBuddy(m_BottomTxt);
+	return true;
+}
+
+void COverScanTab::SetValue(int32_t Left, int32_t Right, int32_t Top, int32_t Bottom)
+{
+	m_LeftTxt.SetWindowText(FormatStrW(L"%d", Left).c_str());
+	m_LeftSpin.SetPos(Left);
+	m_RightTxt.SetWindowText(FormatStrW(L"%d", Right).c_str());
+	m_RightSpin.SetPos(Right);
+	m_TopTxt.SetWindowText(FormatStrW(L"%d", Top).c_str());
+	m_TopSpin.SetPos(Top);
+	m_BottomTxt.SetWindowText(FormatStrW(L"%d", Bottom).c_str());
+	m_BottomSpin.SetPos(Bottom);
+}
+
+void COverScanTab::GetValue(int32_t & Left, int32_t & Right, int32_t & Top, int32_t & Bottom)
+{
+	Left = m_LeftSpin.GetPos();
+	Right = m_RightSpin.GetPos();
+	Top = m_TopSpin.GetPos();
+	Bottom = m_BottomSpin.GetPos();
+}
+
+LRESULT COverScanTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
diff --git a/GLideN64/src/GLideNUI-wtl/config-overscan.h b/GLideN64/src/GLideNUI-wtl/config-overscan.h
new file mode 100644
index 00000000..ccc2d8b1
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-overscan.h
@@ -0,0 +1,27 @@
+#pragma once
+#include <stdint.h>
+#include "wtl.h"
+
+class COverScanTab :
+	public CDialogImpl<COverScanTab>
+{
+public:
+	uint32_t IDD;
+
+	BEGIN_MSG_MAP(CAboutCreditsTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+	END_MSG_MAP()
+
+	COverScanTab();
+	BOOL OnInitDialog(CWindow wndFocus, LPARAM lInitParam);
+	void SetValue(int32_t Left, int32_t Right, int32_t Top, int32_t Bottom);
+	void GetValue(int32_t & Left, int32_t & Right, int32_t & Top, int32_t & Bottom);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+
+private:
+	CEdit m_LeftTxt, m_RightTxt, m_TopTxt, m_BottomTxt;
+	CUpDownCtrl m_LeftSpin, m_RightSpin, m_TopSpin, m_BottomSpin;
+};
+
diff --git a/GLideN64/src/GLideNUI-wtl/config-tab.cpp b/GLideN64/src/GLideNUI-wtl/config-tab.cpp
new file mode 100644
index 00000000..55fb78e6
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-tab.cpp
@@ -0,0 +1,11 @@
+#include "config-tab.h"
+
+CConfigTab::CConfigTab(uint32_t _IDD) :
+	IDD(_IDD)
+{
+}
+
+CConfigTab::~CConfigTab()
+{
+}
+
diff --git a/GLideN64/src/GLideNUI-wtl/config-tab.h b/GLideN64/src/GLideNUI-wtl/config-tab.h
new file mode 100644
index 00000000..b97a887c
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-tab.h
@@ -0,0 +1,20 @@
+#pragma once
+#include <stdint.h>
+#include "wtl.h"
+
+class CConfigTab :
+	public CDialogImpl<CConfigTab>
+{
+public:
+	CConfigTab(uint32_t _IDD);
+	virtual ~CConfigTab();
+
+	BEGIN_MSG_MAP(CConfigTab)
+	END_MSG_MAP()
+
+	virtual void ApplyLanguage() = 0;
+	virtual void LoadSettings(bool blockCustomSettings) = 0;
+	virtual void SaveSettings() = 0;
+
+	uint32_t IDD;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/config-texture.cpp b/GLideN64/src/GLideNUI-wtl/config-texture.cpp
new file mode 100644
index 00000000..40ca72be
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-texture.cpp
@@ -0,0 +1,297 @@
+#include "config-texture.h"
+#include "resource.h"
+#include "util.h"
+#include "../Config.h"
+#include "Language.h"
+#include <Shlobj.h>
+
+CTextureEnhancementTab::CTextureEnhancementTab() :
+	CConfigTab(IDD_TAB_TEXTURE_ENHANCEMENT)
+{
+}
+
+BOOL CTextureEnhancementTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/)
+{
+	TTInit();
+	TTSize(400);
+
+	CComboBox filterComboBox(GetDlgItem(IDC_CMB_FILTER));
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_NONE).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH1).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH2).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH3).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH4).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SHARP1).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SHARP2).c_str());
+
+	CComboBox enhancementComboBox(GetDlgItem(IDC_CMB_ENHANCEMENT));
+	enhancementComboBox.AddString(wGS(TEXTURE_ENHANCEMENT_NONE).c_str());
+	enhancementComboBox.AddString(wGS(TEXTURE_ENHANCEMENT_STORE).c_str());
+	enhancementComboBox.AddString(L"X2");
+	enhancementComboBox.AddString(L"X2SAI");
+	enhancementComboBox.AddString(L"HQ2X");
+	enhancementComboBox.AddString(L"HQ2XS");
+	enhancementComboBox.AddString(L"LQ2X");
+	enhancementComboBox.AddString(L"LQ2XS");
+	enhancementComboBox.AddString(L"HQ4X");
+	enhancementComboBox.AddString(L"2xBRZ");
+	enhancementComboBox.AddString(L"3xBRZ");
+	enhancementComboBox.AddString(L"4xBRZ");
+	enhancementComboBox.AddString(L"5xBRZ");
+	enhancementComboBox.AddString(L"6xBRZ");
+
+	m_TextureFilterCacheTxt.Attach(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_EDIT));
+	m_TextureFilterCacheSpin.Attach(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_SPIN));
+	m_TextureFilterCacheSpin.SetBase(10);
+	m_TextureFilterCacheSpin.SetRange(0, 20);
+	m_TextureFilterCacheSpin.SetPos(0);
+	m_TextureFilterCacheSpin.SetBuddy(m_TextureFilterCacheTxt);
+	return true;
+}
+
+void CTextureEnhancementTab::ApplyLanguage(void)
+{
+	SetDlgItemTextW(IDC_TXT_N64_TEXTURE, wGS(TEXTURE_N64_TEXTURES_GROUP).c_str());
+	SetDlgItemTextW(IDC_TXT_TEXTURE_FILTER, wGS(TEXTURE_N64_FILTER).c_str());
+	SetDlgItemTextW(IDC_TXT_ENHANCEMENT, wGS(TEXTURE_ENHANCEMENT).c_str());
+	SetDlgItemTextW(IDC_CHK_DECREASE_COLOR, wGS(TEXTURE_DECREASE_COLOR).c_str());
+	SetDlgItemTextW(IDC_CHK_IGNORE_BACKGROUNDS, wGS(TEXTURE_IGNORE_BACKGROUNDS).c_str());
+	SetDlgItemTextW(IDC_CHK_ENHANCED_TEX_FILE_STORAGE, wGS(TEXTURE_USE_FILE_STORAGE).c_str());
+	SetDlgItemTextW(IDC_TEX_PACK_PATH_STATIC, wGS(TEXTURE_TEXTURE_PACK).c_str());
+	SetDlgItemTextW(IDC_TEX_CACHE_PATH_STATIC, wGS(TEXTURE_CACHE_PATH).c_str());
+	SetDlgItemTextW(IDC_TEX_DUMP_PATH_STATIC, wGS(TEXTURE_DUMP_PATH).c_str());
+	SetDlgItemTextW(IDC_CHK_ALPHA_CHANNEL, wGS(TEXTURE_USE_FULL_TRANSPARENCIES).c_str());
+	SetDlgItemTextW(IDC_CHK_ALTERNATIVE_CRC, wGS(TEXTURE_ALTERNATIVE_CRC).c_str());
+	SetDlgItemTextW(IDC_CHK_HIRES_TEX_FILESTORAGE, wGS(TEXTURE_FILE_STORAGE).c_str());
+	SetDlgItemTextW(IDC_CHK_TEXTURE_DUMP, wGS(TEXTURE_DUMP_EDIT).c_str());
+	SetDlgItemTextW(IDC_TEXTURE_FILTER_CACHE_STATIC, wGS(TEXTURE_SIZE_OF_MEMORY_CACHE).c_str());
+	SetDlgItemTextW(IDC_CHK_SAVE_TEXTURE_CACHE, wGS(TEXTURE_SAVE_ENHANCED).c_str());
+	SetDlgItemTextW(IDC_CHK_COMPRESS_CACHE, wGS(TEXTURE_COMPRESS_CACHE).c_str());
+	SetDlgItemTextW(IDC_CHK_FORCE_16BPP, wGS(TEXTURE_CONVERT_16BPP).c_str());
+
+	std::wstring tooltip = wGS(TEXTURE_N64_FILTER_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_TEXTURE_FILTER), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_FILTER), tooltip.c_str());
+	tooltip = wGS(TEXTURE_ENHANCEMENT_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_ENHANCEMENT), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_ENHANCEMENT), tooltip.c_str());
+	tooltip = wGS(TEXTURE_DECREASE_COLOR_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_DECREASE_COLOR), tooltip.c_str());
+	tooltip = wGS(TEXTURE_IGNORE_BACKGROUNDS_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_IGNORE_BACKGROUNDS), tooltip.c_str());
+	tooltip = wGS(TEXTURE_TEXTURE_PACK_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TEX_PACK_PATH_STATIC), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_TEX_PACK_PATH_EDIT), tooltip.c_str());
+	tooltip = wGS(TEXTURE_USE_FULL_TRANSPARENCIES_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_ALPHA_CHANNEL), tooltip.c_str());
+	tooltip = wGS(TEXTURE_ALTERNATIVE_CRC_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_ALTERNATIVE_CRC), tooltip.c_str());
+	tooltip = wGS(TEXTURE_DUMP_EDIT_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_TEXTURE_DUMP), tooltip.c_str());
+	tooltip = wGS(TEXTURE_SIZE_OF_MEMORY_CACHE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_STATIC), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_EDIT), tooltip.c_str());
+	tooltip = wGS(TEXTURE_SAVE_ENHANCED_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_SAVE_TEXTURE_CACHE), tooltip.c_str());
+	tooltip = wGS(TEXTURE_COMPRESS_CACHE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_COMPRESS_CACHE), tooltip.c_str());
+	tooltip = wGS(TEXTURE_CONVERT_16BPP_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_FORCE_16BPP), tooltip.c_str());
+
+	CComboBox filterComboBox(GetDlgItem(IDC_CMB_FILTER));
+	int selectedIndx = filterComboBox.GetCurSel();
+	filterComboBox.ResetContent();
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_NONE).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH1).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH2).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH3).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SMOOTH4).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SHARP1).c_str());
+	filterComboBox.AddString(wGS(TEXTURE_N64_FILTER_SHARP2).c_str());
+	if (selectedIndx >= 0)
+		filterComboBox.SetCurSel(selectedIndx);
+
+	CComboBox enhancementComboBox(GetDlgItem(IDC_CMB_ENHANCEMENT));
+	selectedIndx = enhancementComboBox.GetCurSel();
+	enhancementComboBox.ResetContent();
+	enhancementComboBox.AddString(wGS(TEXTURE_ENHANCEMENT_NONE).c_str());
+	enhancementComboBox.AddString(wGS(TEXTURE_ENHANCEMENT_STORE).c_str());
+	enhancementComboBox.AddString(L"X2");
+	enhancementComboBox.AddString(L"X2SAI");
+	enhancementComboBox.AddString(L"HQ2X");
+	enhancementComboBox.AddString(L"HQ2XS");
+	enhancementComboBox.AddString(L"LQ2X");
+	enhancementComboBox.AddString(L"LQ2XS");
+	enhancementComboBox.AddString(L"HQ4X");
+	enhancementComboBox.AddString(L"2xBRZ");
+	enhancementComboBox.AddString(L"3xBRZ");
+	enhancementComboBox.AddString(L"4xBRZ");
+	enhancementComboBox.AddString(L"5xBRZ");
+	enhancementComboBox.AddString(L"6xBRZ");
+	if (selectedIndx >= 0)
+		enhancementComboBox.SetCurSel(selectedIndx);
+}
+
+LRESULT CTextureEnhancementTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
+{
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+void CTextureEnhancementTab::OnFileStorage(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	bool UseFileStorage = !CButton(GetDlgItem(IDC_CHK_ENHANCED_TEX_FILE_STORAGE)).GetCheck() == BST_CHECKED;
+	CButton(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_STATIC)).EnableWindow(UseFileStorage);
+	CButton(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_EDIT)).EnableWindow(UseFileStorage);
+	CButton(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_SPIN)).EnableWindow(UseFileStorage);
+}
+
+void CTextureEnhancementTab::OnTexturePack(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	bool UseTextPack = CButton(GetDlgItem(IDC_CHK_TEXTURE_PACK)).GetCheck() == BST_CHECKED;
+	CButton(GetDlgItem(IDC_TEX_PACK_PATH_STATIC)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_PACK_PATH_EDIT)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_PACK_PATH_BTN)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_CACHE_PATH_STATIC)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_CACHE_PATH_EDIT)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_CACHE_PATH_BTN)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_DUMP_PATH_STATIC)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_DUMP_PATH_EDIT)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_TEX_DUMP_PATH_BTN)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_CHK_ALPHA_CHANNEL)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_CHK_ALTERNATIVE_CRC)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_CHK_HIRES_TEX_FILESTORAGE)).EnableWindow(UseTextPack);
+	CButton(GetDlgItem(IDC_CHK_TEXTURE_DUMP)).EnableWindow(UseTextPack);
+}
+
+LRESULT CTextureEnhancementTab::OnScroll(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/)
+{
+	LONG CtrlId = CWindow((HWND)lParam).GetWindowLong(GWL_ID);
+	if (CtrlId == IDC_TEXTURE_FILTER_CACHE_SPIN) {
+		int Pos = m_TextureFilterCacheSpin.GetPos();
+		m_TextureFilterCacheTxt.SetWindowText(FormatStrW(L"%d MB", Pos == 20 ? 999 : Pos * 50).c_str());
+	}
+	return 0;
+}
+
+void CTextureEnhancementTab::LoadSettings(bool /*blockCustomSettings*/)
+{
+	CComboBox(GetDlgItem(IDC_CMB_FILTER)).SetCurSel(config.textureFilter.txFilterMode);
+	CComboBox(GetDlgItem(IDC_CMB_ENHANCEMENT)).SetCurSel(config.textureFilter.txEnhancementMode);
+	CButton(GetDlgItem(IDC_CHK_DEPOSTERIZE)).SetCheck(config.textureFilter.txDeposterize != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_IGNORE_BACKGROUNDS)).SetCheck(config.textureFilter.txFilterIgnoreBG != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_ENHANCED_TEX_FILE_STORAGE)).SetCheck(config.textureFilter.txEnhancedTextureFileStorage != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_TEXTURE_PACK)).SetCheck(config.textureFilter.txHiresEnable != 0 ? BST_CHECKED : BST_UNCHECKED);
+		
+	GetDlgItem(IDC_TEX_PACK_PATH_EDIT).SetWindowText(config.textureFilter.txPath);
+	GetDlgItem(IDC_TEX_CACHE_PATH_EDIT).SetWindowText(config.textureFilter.txCachePath);
+	GetDlgItem(IDC_TEX_DUMP_PATH_EDIT).SetWindowText(config.textureFilter.txDumpPath);
+
+	CButton(GetDlgItem(IDC_CHK_ALPHA_CHANNEL)).SetCheck(config.textureFilter.txHiresFullAlphaChannel != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_ALTERNATIVE_CRC)).SetCheck(config.textureFilter.txHresAltCRC != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_HIRES_TEX_FILESTORAGE)).SetCheck(config.textureFilter.txHiresTextureFileStorage != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_TEXTURE_DUMP)).SetCheck(config.textureFilter.txDump != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_SAVE_TEXTURE_CACHE)).SetCheck(config.textureFilter.txSaveCache != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_COMPRESS_CACHE)).SetCheck(config.textureFilter.txCacheCompression != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_FORCE_16BPP)).SetCheck(config.textureFilter.txForce16bpp != 0 ? BST_CHECKED : BST_UNCHECKED);
+   
+	m_TextureFilterCacheSpin.SetPos((config.textureFilter.txCacheSize / gc_uMegabyte) /  50);
+
+	OnFileStorage(0, 0, NULL);
+	OnTexturePack(0, 0, NULL);
+	BOOL bHandled;
+	OnScroll(0, 0, (LPARAM)(GetDlgItem(IDC_TEXTURE_FILTER_CACHE_SPIN).Detach()), bHandled);
+}
+
+void CTextureEnhancementTab::SaveDirectory(int EditCtrl, wchar_t * txPath)
+{
+	CWindow EditWnd = GetDlgItem(EditCtrl);
+	int TxtLen = EditWnd.GetWindowTextLength();
+	std::wstring Path;
+	Path.resize(TxtLen + 1);
+	EditWnd.GetWindowText((wchar_t *)Path.data(), Path.size());
+
+	WIN32_FIND_DATA	FindData;
+	HANDLE hFindFile = FindFirstFile(Path.c_str(), &FindData);
+	bool exists = (hFindFile != INVALID_HANDLE_VALUE);
+
+	if (hFindFile != NULL)
+		FindClose(hFindFile);
+
+	if (exists)
+		wcscpy(txPath, Path.c_str());
+}
+
+void CTextureEnhancementTab::SaveSettings()
+{
+	config.textureFilter.txFilterMode = CComboBox(GetDlgItem(IDC_CMB_FILTER)).GetCurSel();
+	config.textureFilter.txEnhancementMode = CComboBox(GetDlgItem(IDC_CMB_ENHANCEMENT)).GetCurSel();
+	config.textureFilter.txDeposterize = CButton(GetDlgItem(IDC_CHK_DEPOSTERIZE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txFilterIgnoreBG = CButton(GetDlgItem(IDC_CHK_IGNORE_BACKGROUNDS)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txEnhancedTextureFileStorage = CButton(GetDlgItem(IDC_CHK_ENHANCED_TEX_FILE_STORAGE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txHiresEnable = CButton(GetDlgItem(IDC_CHK_TEXTURE_PACK)).GetCheck() == BST_CHECKED ? 1 : 0;
+
+	SaveDirectory(IDC_TEX_PACK_PATH_EDIT, config.textureFilter.txPath);
+	SaveDirectory(IDC_TEX_CACHE_PATH_EDIT, config.textureFilter.txCachePath);
+	SaveDirectory(IDC_TEX_DUMP_PATH_EDIT, config.textureFilter.txDumpPath);
+
+	config.textureFilter.txHiresFullAlphaChannel = CButton(GetDlgItem(IDC_CHK_ALPHA_CHANNEL)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txHresAltCRC = CButton(GetDlgItem(IDC_CHK_ALTERNATIVE_CRC)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txHiresTextureFileStorage = CButton(GetDlgItem(IDC_CHK_HIRES_TEX_FILESTORAGE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txDump = CButton(GetDlgItem(IDC_CHK_TEXTURE_DUMP)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txCacheSize = m_TextureFilterCacheSpin.GetPos() * gc_uMegabyte * 50;
+	config.textureFilter.txSaveCache = CButton(GetDlgItem(IDC_CHK_SAVE_TEXTURE_CACHE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txCacheCompression = CButton(GetDlgItem(IDC_CHK_COMPRESS_CACHE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.textureFilter.txForce16bpp = CButton(GetDlgItem(IDC_CHK_FORCE_16BPP)).GetCheck() == BST_CHECKED ? 1 : 0;
+}
+
+void CTextureEnhancementTab::OnSelectTexPackPath(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	SelectDir(L"Select directory for texture pack path", IDC_TEX_PACK_PATH_EDIT);
+}
+
+void CTextureEnhancementTab::OnSelectTexCachePath(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	SelectDir(L"Select directory for texture cache path", IDC_TEX_CACHE_PATH_EDIT);
+}
+
+void CTextureEnhancementTab::OnSelectTexDumpPath(UINT /*Code*/, int /*id*/, HWND /*ctl*/)
+{
+	SelectDir(L"Select directory for texture dump path", IDC_TEX_DUMP_PATH_EDIT);
+}
+
+void CTextureEnhancementTab::SelectDir(wchar_t * Title, int EditCtrl)
+{
+	wchar_t Buffer[MAX_PATH], Directory[MAX_PATH];
+	LPITEMIDLIST pidl;
+	BROWSEINFOW bi;
+
+	CWindow EditWnd = GetDlgItem(EditCtrl);
+	int TxtLen = EditWnd.GetWindowTextLength();
+	std::wstring EditText;
+	EditText.resize(TxtLen + 1);
+	EditWnd.GetWindowText((wchar_t *)EditText.data(), EditText.size());
+
+	bi.hwndOwner = m_hWnd;
+	bi.pidlRoot = NULL;
+	bi.pszDisplayName = Buffer;
+	bi.lpszTitle = Title;
+	bi.ulFlags = BIF_RETURNFSANCESTORS | BIF_RETURNONLYFSDIRS;
+	bi.lpfn = (BFFCALLBACK)SelectDirCallBack;
+	bi.lParam = (DWORD)EditText.c_str();
+	if ((pidl = SHBrowseForFolderW(&bi)) != NULL && SHGetPathFromIDListW(pidl, Directory))
+		EditWnd.SetWindowText(Directory);
+}
+
+int CALLBACK CTextureEnhancementTab::SelectDirCallBack(HWND hwnd, uint32_t uMsg, uint32_t /*lp*/, uint32_t lpData)
+{
+	switch (uMsg)
+	{
+	case BFFM_INITIALIZED:
+		// WParam is TRUE since you are passing a path.
+		// It would be FALSE if you were passing a pidl.
+		if (lpData)
+			SendMessage(hwnd, BFFM_SETSELECTION, TRUE, lpData);
+		break;
+	}
+	return 0;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/config-texture.h b/GLideN64/src/GLideNUI-wtl/config-texture.h
new file mode 100644
index 00000000..e7c52b14
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-texture.h
@@ -0,0 +1,46 @@
+#pragma once
+#include "config-tab.h"
+#include "wtl-tooltip.h"
+#include "resource.h"
+
+class CTextureEnhancementTab :
+	public CConfigTab,
+	public CToolTipDialog<CTextureEnhancementTab>
+{
+public:
+	BEGIN_MSG_MAP(CTextureEnhancementTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		COMMAND_HANDLER_EX(IDC_CHK_ENHANCED_TEX_FILE_STORAGE, BN_CLICKED, OnFileStorage)
+		COMMAND_HANDLER_EX(IDC_CHK_TEXTURE_PACK, BN_CLICKED, OnTexturePack)
+		COMMAND_ID_HANDLER_EX(IDC_TEX_PACK_PATH_BTN, OnSelectTexPackPath)
+		COMMAND_ID_HANDLER_EX(IDC_TEX_CACHE_PATH_BTN, OnSelectTexCachePath)
+		COMMAND_ID_HANDLER_EX(IDC_TEX_DUMP_PATH_BTN, OnSelectTexDumpPath)
+		MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
+		CHAIN_MSG_MAP(CToolTipDialog<CTextureEnhancementTab>)
+	END_MSG_MAP()
+
+	CTextureEnhancementTab();
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+	LRESULT OnScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/);
+	void OnFileStorage(UINT /*Code*/, int id, HWND /*ctl*/);
+	void OnTexturePack(UINT /*Code*/, int id, HWND /*ctl*/);
+	void ApplyLanguage(void);
+	void LoadSettings(bool blockCustomSettings);
+	void SaveSettings();
+
+private:
+	static int CALLBACK SelectDirCallBack(HWND hwnd, uint32_t uMsg, uint32_t lp, uint32_t lpData);
+
+	void SaveDirectory(int EditCtrl, wchar_t * txPath);
+	void SelectDir(wchar_t * Title, int EditCtrl);
+	void OnSelectTexPackPath(UINT Code, int id, HWND ctl);
+	void OnSelectTexCachePath(UINT Code, int id, HWND ctl);
+	void OnSelectTexDumpPath(UINT Code, int id, HWND ctl);
+
+	CEdit m_TextureFilterCacheTxt;
+	CUpDownCtrl m_TextureFilterCacheSpin;
+};
+
diff --git a/GLideN64/src/GLideNUI-wtl/config-video.cpp b/GLideN64/src/GLideNUI-wtl/config-video.cpp
new file mode 100644
index 00000000..fde578b4
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-video.cpp
@@ -0,0 +1,467 @@
+#include "config-video.h"
+#include "FullscreenResolutions.h"
+#include "util.h"
+#include "Language.h"
+#include "ConfigDlg.h"
+#include "../Config.h"
+#include "wtl-tooltip.h"
+
+static struct {
+	unsigned short width, height;
+	LPCTSTR description;
+}
+WindowedModes[] = {
+	{ 320, 240, _T("320 x 240") },
+	{ 400, 300, _T("400 x 300") },
+	{ 480, 360, _T("480 x 360") },
+	{ 640, 480, _T("640 x 480") },
+	{ 800, 600, _T("800 x 600") },
+	{ 960, 720, _T("960 x 720") },
+	{ 1024, 768, _T("1024 x 768") },
+	{ 1152, 864, _T("1152 x 864") },
+	{ 1280, 960, _T("1280 x 960") },
+	{ 1280, 1024, _T("1280 x 1024") },
+	{ 1440, 1080, _T("1440 x 1080") },
+	{ 1600, 1024, _T("1600 x 1024") },
+	{ 1600, 1200, _T("1600 x 1200") }
+};
+static const unsigned int numWindowedModes = sizeof(WindowedModes) / sizeof(WindowedModes[0]);
+static const LPCTSTR englishLang = _T("English");
+
+static u32 pow2(u32 dim)
+{
+	if (dim == 0) return 0;
+
+	return (1 << dim);
+}
+
+static u32 powof(u32 dim)
+{
+	if (dim == 0) return 0;
+
+	u32 num = 2; u32 i = 1;
+	while (num < dim) {
+		num <<= 1;
+		i++;
+	}
+	return i;
+}
+
+CVideoTab::CVideoTab(CConfigDlg & Dlg, CFrameBufferTab & FrameBufferTab, const char * strIniPath) :
+	CConfigTab(IDD_TAB_VIDEO),
+	m_strIniPath(strIniPath),
+	m_LangList(GetLanguageList(strIniPath)),
+	m_Dlg(Dlg),
+	m_FrameBufferTab(FrameBufferTab)
+{
+}
+
+CVideoTab::~CVideoTab() {
+	for (size_t i = 0; i < m_OverscanTabs.size(); i++)
+		delete m_OverscanTabs[i];
+	m_OverscanTabs.clear();
+}
+
+BOOL CVideoTab::OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/) {
+	TTInit();
+	TTSize(400);
+
+	m_OverScanTab.Attach(GetDlgItem(IDC_TAB_OVERSCAN));
+	AddOverScanTab(VIDEO_NTSC);
+	AddOverScanTab(VIDEO_PAL);
+
+	m_AliasingSlider.Attach(GetDlgItem(IDC_ALIASING_SLIDER));
+	m_AliasingSlider.SetTicFreq(1);
+	m_AliasingSlider.SetRangeMin(0);
+	m_AliasingSlider.SetRangeMax(3);
+
+	m_AnisotropicSlider.Attach(GetDlgItem(IDC_ANISOTROPIC_SLIDER));
+	m_AnisotropicSlider.SetTicFreq(2);
+	m_AnisotropicSlider.SetRangeMin(0);
+	m_AnisotropicSlider.SetRangeMax(16);
+
+	CComboBox aspectComboBox(GetDlgItem(IDC_CMB_ASPECT_RATIO));
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_4_3).c_str());
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_16_19).c_str());
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_STRETCH).c_str());
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_ADJUST).c_str());
+
+	CComboBox ditheringModeComboBox(GetDlgItem(IDC_CMB_PATTERN));
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_DISABLE).c_str());
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_BAYER).c_str());
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_MAGIC_SQUARE).c_str());
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_BLUE_NOISE).c_str());
+
+	SIZE iconSz = { ::GetSystemMetrics(SM_CXSMICON), ::GetSystemMetrics(SM_CYSMICON) };
+	m_AAInfoIcon.SubclassWindow(GetDlgItem(IDC_AA_INFO_ICON));
+	m_AAInfoIcon.SetIcon(MAKEINTRESOURCE(IDI_ICON_INFO), iconSz.cx, iconSz.cy);
+	m_AAInfoIcon.SetWindowPos(HWND_TOP, 0, 0, iconSz.cx, iconSz.cy, SWP_NOMOVE | SWP_NOZORDER);
+	m_AAInfoIcon.SetBackroundBrush((HBRUSH)GetStockObject(WHITE_BRUSH));
+
+	CComboBox translationsComboBox(GetDlgItem(IDC_CMB_LANGUAGE));
+	for (LanguageList::const_iterator itr = m_LangList.begin(); itr != m_LangList.end(); itr++) {
+		int indx = translationsComboBox.AddString(ToUTF16(itr->LanguageName.c_str()).c_str());
+		translationsComboBox.SetItemData(indx, (DWORD_PTR)itr->Filename.c_str());
+	}
+	if (translationsComboBox.FindString(-1, englishLang) == CB_ERR) {
+		int indx = translationsComboBox.AddString(englishLang);
+		translationsComboBox.SetItemData(indx, (DWORD_PTR)"");
+	}
+	return true;
+}
+
+void CVideoTab::ApplyLanguage(void) {
+	SetDlgItemTextW(IDC_VIDEO_GROUP, wGS(VIDEO_GROUP).c_str());
+	SetDlgItemTextW(IDC_TXT_FULL_SCREEN_RES, wGS(VIDEO_FULL_SCREEN_RES).c_str());
+	SetDlgItemTextW(IDC_TXT_REFRESH_RATE, wGS(VIDEO_REFRESH_RATE).c_str());
+	SetDlgItemTextW(IDC_TXT_WINDOWED_RESOLUTION, wGS(VIDEO_WINDOWED_RESOLUTION).c_str());
+	SetDlgItemTextW(IDC_TXT_ASPECT_RATIO, wGS(VIDEO_ASPECT_RATIO).c_str());
+	SetDlgItemTextW(IDC_CHK_VERTICAL_SYNC, wGS(VIDEO_VSYNC).c_str());
+	SetDlgItemTextW(IDC_CHK_THREADED_VIDEO, wGS(VIDEO_THREADED_VIDEO).c_str());
+	SetDlgItemTextW(IDC_CHK_OVERSCAN, wGS(VIDEO_OVERSCAN).c_str());
+	SetDlgItemTextW(IDC_AA_GROUP, wGS(VIDEO_ANTI_ALIASING).c_str());
+	SetDlgItemTextW(IDC_NOAA_RADIO, wGS(VIDEO_NO_ANTI_ALIASING).c_str());
+	SetDlgItemTextW(IDC_FXAA_RADIO, wGS(VIDEO_FAST_ANTI_ALIASING).c_str());
+	SetDlgItemTextW(IDC_MSAA_RADIO, wGS(VIDEO_MULTISAMPLE_ANTI_ALIASING).c_str());
+	SetDlgItemTextW(IDC_AA_OFF, wGS(VIDEO_AA_OFF).c_str());
+	SetDlgItemTextW(IDC_AA_HIGH, wGS(VIDEO_AA_HIGH).c_str());
+	SetDlgItemTextW(IDC_AA_INFO, wGS(VIDEO_AA_INFO).c_str());
+	SetDlgItemTextW(IDC_FILTERING_GROUP, wGS(VIDEO_FILTERING_GROUP).c_str());
+	SetDlgItemTextW(IDC_ANISOTROPIC, wGS(VIDEO_ANISOTROPIC).c_str());
+	SetDlgItemTextW(IDC_ANISOTROPIC_OFF, wGS(VIDEO_ANISOTROPIC_OFF).c_str());
+	SetDlgItemTextW(IDC_ANISOTROPIC_HIGH, wGS(VIDEO_ANISOTROPIC_HIGH).c_str());
+	SetDlgItemTextW(IDC_BILINEAR, wGS(VIDEO_BILINEAR).c_str());
+	SetDlgItemTextW(IDC_BILINEAR_STANDARD, wGS(VIDEO_BILINEAR_STANDARD).c_str());
+	SetDlgItemTextW(IDC_BILINEAR_3POINT, wGS(VIDEO_BILINEAR_3POINT).c_str());
+	
+	SetDlgItemTextW(IDC_DITHERING_GROUP, wGS(VIDEO_DITHERING_GROUP).c_str());
+	SetDlgItemTextW(IDC_PATTERN, wGS(VIDEO_PATTERN).c_str());
+	SetDlgItemTextW(IDC_CHK_APPLY_TO_OUTPUT, wGS(VIDEO_DITHERING_APPLY_TO_OUTPUT).c_str());
+	SetDlgItemTextW(IDC_CHK_5BIT_QUANTIZATION, wGS(VIDEO_DITHERING_5BIT_QUANTIZATION).c_str());
+	SetDlgItemTextW(IDC_CHK_HIRES_NOISE, wGS(VIDEO_DITHERING_HIRES_NOISE).c_str());
+	SetDlgItemTextW(IDC_LANGUAGE, wGS(VIDEO_LANGUAGE).c_str());
+
+	std::wstring tooltip = wGS(VIDEO_FULL_SCREEN_RES_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_FULL_SCREEN_RES), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_FULL_SCREEN_RES), tooltip.c_str());
+	tooltip = wGS(VIDEO_REFRESH_RATE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_REFRESH_RATE), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_REFRESH_RATE), tooltip.c_str());
+	tooltip = wGS(VIDEO_WINDOWED_RESOLUTION_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_WINDOWED_RESOLUTION), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_WINDOWED_RESOLUTION), tooltip.c_str());
+	tooltip = wGS(VIDEO_ASPECT_RATIO_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_TXT_ASPECT_RATIO), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_CMB_ASPECT_RATIO), tooltip.c_str());
+	tooltip = wGS(VIDEO_VSYNC_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_VERTICAL_SYNC), tooltip.c_str());
+	tooltip = wGS(VIDEO_THREADED_VIDEO_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_THREADED_VIDEO), tooltip.c_str());
+	tooltip = wGS(VIDEO_OVERSCAN_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_OVERSCAN), tooltip.c_str());
+	tooltip = wGS(VIDEO_AA_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_AA_GROUP), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_NOAA_RADIO), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_FXAA_RADIO), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_MSAA_RADIO), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_ALIASING_SLIDER), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_AA_OFF), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_AA_HIGH), tooltip.c_str());
+	tooltip = wGS(VIDEO_BILINEAR_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_BILINEAR), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_BILINEAR_STANDARD), tooltip.c_str());
+	TTSetTxt(GetDlgItem(IDC_BILINEAR_3POINT), tooltip.c_str());
+	tooltip = wGS(VIDEO_DITHERING_APPLY_TO_OUTPUT_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_APPLY_TO_OUTPUT), tooltip.c_str());
+	tooltip = wGS(VIDEO_DITHERING_5BIT_QUANTIZATION_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_5BIT_QUANTIZATION), tooltip.c_str());
+	tooltip = wGS(VIDEO_DITHERING_HIRES_NOISE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CHK_HIRES_NOISE), tooltip.c_str());
+	tooltip = wGS(VIDEO_DITHERING_MODE_TOOLTIP);
+	TTSetTxt(GetDlgItem(IDC_CMB_PATTERN), tooltip.c_str());
+
+	CComboBox aspectComboBox(GetDlgItem(IDC_CMB_ASPECT_RATIO));
+	int selectedIndx = aspectComboBox.GetCurSel();
+	aspectComboBox.ResetContent();
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_4_3).c_str());
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_16_19).c_str());
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_STRETCH).c_str());
+	aspectComboBox.AddString(wGS(VIDEO_ASPECT_ADJUST).c_str());
+	if (selectedIndx >= 0)
+		aspectComboBox.SetCurSel(selectedIndx);
+
+	CComboBox ditheringModeComboBox(GetDlgItem(IDC_CMB_PATTERN));
+	selectedIndx = ditheringModeComboBox.GetCurSel();
+	ditheringModeComboBox.ResetContent();
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_DISABLE).c_str());
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_BAYER).c_str());
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_MAGIC_SQUARE).c_str());
+	ditheringModeComboBox.AddString(wGS(VIDEO_DITHERING_BLUE_NOISE).c_str());
+	if (selectedIndx >= 0)
+		ditheringModeComboBox.SetCurSel(selectedIndx);
+
+	for (int i = 0, n = m_OverScanTab.GetItemCount(); i < n; i++) {
+		TCITEM tci = { 0 };
+		tci.mask = TCIF_PARAM;
+		m_OverScanTab.GetItem(i, &tci);
+		if (tci.lParam != 0) {
+			tci.mask = TCIF_TEXT;
+			std::wstring caption = wGS((languageStringID)tci.lParam);
+			tci.pszText = (LPWSTR)caption.c_str();
+			m_OverScanTab.SetItem(i, &tci);
+		}
+	}
+
+}
+
+LRESULT CVideoTab::OnScroll(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& /*bHandled*/) {
+	LONG SliderId = CWindow((HWND)lParam).GetWindowLong(GWL_ID);
+	if (SliderId == IDC_ALIASING_SLIDER) {
+		int32_t multisampling = m_AliasingSlider.GetPos();
+		std::wstring AliasingText = FormatStrW(L"%dx", pow2(multisampling));
+		CWindow(GetDlgItem(IDC_ALIASING_LABEL)).SetWindowTextW(AliasingText.c_str());
+		CButton(GetDlgItem(multisampling != 0 ? IDC_MSAA_RADIO : IDC_NOAA_RADIO)).SetCheck(BST_CHECKED);
+		CButton(GetDlgItem(multisampling != 0 ? IDC_NOAA_RADIO : IDC_MSAA_RADIO)).SetCheck(BST_UNCHECKED);
+		CButton(GetDlgItem(IDC_FXAA_RADIO)).SetCheck(BST_UNCHECKED);
+	} else if (SliderId == IDC_ANISOTROPIC_SLIDER) {
+		CWindow(GetDlgItem(IDC_ANISOTROPIC_LABEL)).SetWindowTextW(FormatStrW(L"%dx", m_AnisotropicSlider.GetPos()).c_str());
+	}
+	return 0;
+}
+
+void CVideoTab::OnOverscan(UINT /*Code*/, int /*id*/, HWND /*ctl*/) {
+	CButton OverScan(GetDlgItem(IDC_CHK_OVERSCAN));
+	if (OverScan.GetCheck() == BST_CHECKED) {
+		GetDlgItem(IDC_TAB_OVERSCAN).ShowWindow(SW_SHOW);
+		ShowOverScanTab(m_OverScanTab.GetCurSel());
+	} else {
+		GetDlgItem(IDC_TAB_OVERSCAN).ShowWindow(SW_HIDE);
+		m_OverscanTabs[m_OverScanTab.GetCurSel()]->ShowWindow(SW_HIDE);
+	}
+}
+
+LRESULT CVideoTab::OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/) {
+	return (LRESULT)GetStockObject(WHITE_BRUSH);
+}
+
+LRESULT CVideoTab::OnOverscanTabChange(NMHDR* /*pNMHDR*/) {
+	ShowOverScanTab(m_OverScanTab.GetCurSel());
+	return FALSE;
+}
+
+void CVideoTab::OnFullScreenChanged(UINT /*Code*/, int /*id*/, HWND /*ctl*/) {
+	CComboBox fullScreenResolutionComboBox(GetDlgItem(IDC_CMB_FULL_SCREEN_RES));
+	int32_t index = fullScreenResolutionComboBox.GetCurSel();
+	StringList fullscreenRatesList;
+	int fullscreenRate;
+	fillFullscreenRefreshRateList(index, fullscreenRatesList, fullscreenRate);
+
+	CComboBox RefreshRateComboBox(GetDlgItem(IDC_CMB_REFRESH_RATE));
+	RefreshRateComboBox.ResetContent();
+	for (size_t i = 0, n = fullscreenRatesList.size(); i < n; i++) {
+		std::wstring fullscreenRateStr(fullscreenRatesList[i].begin(), fullscreenRatesList[i].end());
+		int index = RefreshRateComboBox.AddString(fullscreenRateStr.c_str());
+		if (fullscreenRate == i)
+			RefreshRateComboBox.SetCurSel(index);
+	}
+}
+
+LRESULT CVideoTab::OnLanguageChanged(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hwnd*/, BOOL& /*bHandled*/) {
+	CComboBox translationsComboBox(GetDlgItem(IDC_CMB_LANGUAGE));
+	std::string currentLang = (const char *)translationsComboBox.GetItemDataPtr(translationsComboBox.GetCurSel());
+	m_Dlg.SetLanguage(currentLang);
+	return 0;
+}
+
+void CVideoTab::AddOverScanTab(languageStringID caption) {
+	m_OverScanTab.AddItem(TCIF_TEXT | TCIF_PARAM, wGS(caption).c_str(), 0, caption);
+
+	COverScanTab * tab = new COverScanTab;
+	tab->Create(m_hWnd, 0);
+	tab->SetWindowPos(m_hWnd, 0, 0, 0, 0, SWP_HIDEWINDOW);
+	m_OverscanTabs.push_back(tab);
+
+	if (m_OverscanTabs.size() == 1)
+		ShowOverScanTab(0);
+}
+
+void CVideoTab::ShowOverScanTab(int nTab) {
+	for (size_t i = 0; i < m_OverscanTabs.size(); i++)
+		m_OverscanTabs[i]->ShowWindow(SW_HIDE);
+
+	CRect TabRect;
+	m_OverScanTab.GetWindowRect(&TabRect);
+	ScreenToClient(&TabRect);
+	m_OverScanTab.AdjustRect(FALSE, &TabRect);
+
+	m_OverscanTabs[nTab]->SetWindowPos(HWND_TOP, TabRect.left, TabRect.top, TabRect.Width(), TabRect.Height(), SWP_SHOWWINDOW);
+
+	CRect WinRect, ClientRect;
+	m_OverscanTabs[nTab]->GetWindowRect(WinRect);
+	m_OverscanTabs[nTab]->GetClientRect(ClientRect);
+
+	m_OverScanTab.RedrawWindow();
+}
+
+void CVideoTab::LoadSettings(bool /*blockCustomSettings*/) {
+	CComboBox WindowedResolutionComboBox(GetDlgItem(IDC_CMB_WINDOWED_RESOLUTION));
+	if (WindowedResolutionComboBox.GetCount() == 0) {
+		for (unsigned int i = 0; i < numWindowedModes; ++i) {
+			int index = WindowedResolutionComboBox.AddString(WindowedModes[i].description);
+			WindowedResolutionComboBox.SetItemData(index, i);
+			if (WindowedModes[i].width == config.video.windowedWidth && WindowedModes[i].height == config.video.windowedHeight)
+				WindowedResolutionComboBox.SetCurSel(index);
+		}
+		if (WindowedResolutionComboBox.GetCount() > 0 && WindowedResolutionComboBox.GetCurSel() < 0) {
+			WindowedResolutionComboBox.AddString(FormatStrW(L"%d x %d", config.video.windowedWidth, config.video.windowedHeight).c_str());
+			WindowedResolutionComboBox.SetCurSel(numWindowedModes);
+		}
+	}
+
+	CButton overscanCheckBox(GetDlgItem(IDC_CHK_OVERSCAN));
+	overscanCheckBox.SetCheck(config.frameBufferEmulation.enableOverscan != 0 ? BST_CHECKED : BST_UNCHECKED);
+	OnOverscan(0, 0, NULL);
+
+	m_OverscanTabs[0]->SetValue(
+		config.frameBufferEmulation.overscanNTSC.left,
+		config.frameBufferEmulation.overscanNTSC.right,
+		config.frameBufferEmulation.overscanNTSC.top,
+		config.frameBufferEmulation.overscanNTSC.bottom
+	);
+
+	m_OverscanTabs[1]->SetValue(
+		config.frameBufferEmulation.overscanPAL.left,
+		config.frameBufferEmulation.overscanPAL.right,
+		config.frameBufferEmulation.overscanPAL.top,
+		config.frameBufferEmulation.overscanPAL.bottom
+	);
+
+	StringList fullscreenModesList, fullscreenRatesList;
+	int fullscreenMode, fullscreenRate;
+	fillFullscreenResolutionsList(fullscreenModesList, fullscreenMode, fullscreenRatesList, fullscreenRate);
+
+	CComboBox fullScreenResolutionComboBox(GetDlgItem(IDC_CMB_FULL_SCREEN_RES));
+	fullScreenResolutionComboBox.ResetContent();
+	for (size_t i = 0, n = fullscreenModesList.size(); i < n; i++) {
+		std::wstring fullscreenModeStr(fullscreenModesList[i].begin(), fullscreenModesList[i].end());
+		int index = fullScreenResolutionComboBox.AddString(fullscreenModeStr.c_str());
+		if (fullscreenMode == i)
+			fullScreenResolutionComboBox.SetCurSel(index);
+	}
+	OnFullScreenChanged(0, 0, NULL);
+	const unsigned int multisampling = config.video.fxaa == 0 && config.video.multisampling > 0
+		? config.video.multisampling
+		: 8;
+	m_AliasingSlider.SetPos(powof(multisampling));
+	std::wstring AliasingText = FormatStrW(L"%dx", multisampling);
+	CWindow(GetDlgItem(IDC_ALIASING_LABEL)).SetWindowTextW(AliasingText.c_str());
+
+	CButton(GetDlgItem(IDC_NOAA_RADIO)).SetCheck(config.video.multisampling == 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FXAA_RADIO)).SetCheck(config.video.fxaa != 0 && config.video.multisampling != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_MSAA_RADIO)).SetCheck(config.video.fxaa == 0 && config.video.multisampling != 0 ? BST_CHECKED : BST_UNCHECKED);
+	m_AnisotropicSlider.SetPos(config.texture.maxAnisotropy);
+	CWindow(GetDlgItem(IDC_ANISOTROPIC_LABEL)).SetWindowTextW(FormatStrW(L"%dx", m_AnisotropicSlider.GetPos()).c_str());
+
+	CButton(GetDlgItem(IDC_CHK_VERTICAL_SYNC)).SetCheck(config.video.verticalSync != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_THREADED_VIDEO)).SetCheck(config.video.threadedVideo != 0 ? BST_CHECKED : BST_UNCHECKED);
+
+	CButton(GetDlgItem(IDC_BILINEAR_3POINT)).SetCheck(config.texture.bilinearMode == BILINEAR_3POINT ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_BILINEAR_STANDARD)).SetCheck(config.texture.bilinearMode == BILINEAR_STANDARD ? BST_CHECKED : BST_UNCHECKED);
+
+	CComboBox aspectComboBox(GetDlgItem(IDC_CMB_ASPECT_RATIO));
+	switch (config.frameBufferEmulation.aspect) {
+	case Config::aStretch: aspectComboBox.SetCurSel(2); break;
+	case Config::a43: aspectComboBox.SetCurSel(0); break;
+	case Config::a169: aspectComboBox.SetCurSel(1); break;
+	case Config::aAdjust: aspectComboBox.SetCurSel(3); break;
+	}
+
+	CComboBox(GetDlgItem(IDC_CMB_PATTERN)).SetCurSel(config.generalEmulation.rdramImageDitheringMode);
+	CButton(GetDlgItem(IDC_CHK_APPLY_TO_OUTPUT)).SetCheck(config.generalEmulation.enableDitheringPattern != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_5BIT_QUANTIZATION)).SetCheck(config.generalEmulation.enableDitheringQuantization != 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_CHK_HIRES_NOISE)).SetCheck(config.generalEmulation.enableHiresNoiseDithering != 0 ? BST_CHECKED : BST_UNCHECKED);
+
+	CComboBox translationsComboBox(GetDlgItem(IDC_CMB_LANGUAGE));
+	translationsComboBox.SetCurSel(-1);
+	int englishIndx = -1;
+	for (int i = 0, n = translationsComboBox.GetCount(); i < n; i++) {
+		const char * translations = (const char *)translationsComboBox.GetItemDataPtr(i);
+		if (_stricmp(translations, "gliden64_en.Lang") == 0)
+			englishIndx = i;
+
+		if (config.translationFile == translations) {
+			translationsComboBox.SetCurSel(i);
+			break;
+		}
+	} // default: attempt to use gliden64_en.Lang
+	if (englishIndx >= 0 && translationsComboBox.GetCurSel() < 0) 
+		translationsComboBox.SetCurSel(englishIndx);
+	else if (translationsComboBox.GetCurSel() < 0) // gliden64_en.Lang not found; select hardcoded english
+		translationsComboBox.SetCurSel(translationsComboBox.FindString(-1, englishLang));
+}
+
+void CVideoTab::SaveSettings()
+{
+	getFullscreenResolutions(CComboBox(GetDlgItem(IDC_CMB_FULL_SCREEN_RES)).GetCurSel(), config.video.fullscreenWidth, config.video.fullscreenHeight);
+	getFullscreenRefreshRate(CComboBox(GetDlgItem(IDC_CMB_REFRESH_RATE)).GetCurSel(), config.video.fullscreenRefresh);
+
+	CComboBox WindowResCB(GetDlgItem(IDC_CMB_WINDOWED_RESOLUTION));
+	CString WindowResStr;
+	WindowResCB.GetWindowText(WindowResStr);
+	std::string resolution(CW2A(WindowResStr.GetString()));
+	std::regex parseRes("(\\d+) ?x ?(\\d+)");
+	std::smatch tokens;
+	if (std::regex_search(resolution, tokens, parseRes) && tokens.size() > 1) {
+		// matches w x h where w is 300-7999 and h is 200-3999
+		if (range<300, 8000>::contains(std::stoi(tokens[1])) && range<200, 4000>::contains(std::stoi(tokens[2]))) {
+			config.video.windowedWidth = std::stoi(tokens[1]);
+			config.video.windowedHeight = std::stoi(tokens[2]);
+		}
+	}
+
+	int AspectIndx = CComboBox(GetDlgItem(IDC_CMB_ASPECT_RATIO)).GetCurSel();
+	if (AspectIndx == 2) { config.frameBufferEmulation.aspect = Config::aStretch; }
+	else if (AspectIndx == 0) { config.frameBufferEmulation.aspect = Config::a43; }
+	else if (AspectIndx == 1) { config.frameBufferEmulation.aspect = Config::a169; }
+	else if (AspectIndx == 3) { config.frameBufferEmulation.aspect = Config::aAdjust; }
+
+	config.video.verticalSync = CButton(GetDlgItem(IDC_CHK_VERTICAL_SYNC)).GetCheck() == BST_CHECKED;
+	config.video.threadedVideo = CButton(GetDlgItem(IDC_CHK_THREADED_VIDEO)).GetCheck() == BST_CHECKED;
+	config.frameBufferEmulation.enableOverscan = CButton(GetDlgItem(IDC_CHK_OVERSCAN)).GetCheck() == BST_CHECKED;
+
+	m_OverscanTabs[0]->GetValue(
+		config.frameBufferEmulation.overscanNTSC.left,
+		config.frameBufferEmulation.overscanNTSC.right,
+		config.frameBufferEmulation.overscanNTSC.top,
+		config.frameBufferEmulation.overscanNTSC.bottom
+	);
+
+	m_OverscanTabs[1]->GetValue(
+		config.frameBufferEmulation.overscanPAL.left,
+		config.frameBufferEmulation.overscanPAL.right,
+		config.frameBufferEmulation.overscanPAL.top,
+		config.frameBufferEmulation.overscanPAL.bottom
+	);
+
+	config.video.fxaa = CButton(GetDlgItem(IDC_FXAA_RADIO)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.video.multisampling =
+		(CButton(GetDlgItem(IDC_FXAA_RADIO)).GetCheck() == BST_CHECKED
+			|| CComboBox(m_FrameBufferTab.GetDlgItem(IDC_CMB_N64_DEPTH_COMPARE)).GetCurSel() != 0
+			|| CButton(GetDlgItem(IDC_NOAA_RADIO)).GetCheck() == BST_CHECKED
+			) ? 0
+		: pow2(m_AliasingSlider.GetPos());
+	config.texture.maxAnisotropy = m_AnisotropicSlider.GetPos();
+
+	if (CButton(GetDlgItem(IDC_BILINEAR_3POINT)).GetCheck() == BST_CHECKED)
+		config.texture.bilinearMode = BILINEAR_3POINT;
+	if (CButton(GetDlgItem(IDC_BILINEAR_STANDARD)).GetCheck() == BST_CHECKED)
+		config.texture.bilinearMode = BILINEAR_STANDARD;
+
+	config.generalEmulation.rdramImageDitheringMode = CComboBox(GetDlgItem(IDC_CMB_PATTERN)).GetCurSel();
+	config.generalEmulation.enableDitheringPattern = CButton(GetDlgItem(IDC_CHK_APPLY_TO_OUTPUT)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.generalEmulation.enableDitheringQuantization = CButton(GetDlgItem(IDC_CHK_5BIT_QUANTIZATION)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.generalEmulation.enableHiresNoiseDithering = CButton(GetDlgItem(IDC_CHK_HIRES_NOISE)).GetCheck() == BST_CHECKED ? 1 : 0;
+
+	CComboBox translationsComboBox(GetDlgItem(IDC_CMB_LANGUAGE));
+	config.translationFile = (const char *)translationsComboBox.GetItemDataPtr(translationsComboBox.GetCurSel());
+}
diff --git a/GLideN64/src/GLideNUI-wtl/config-video.h b/GLideN64/src/GLideNUI-wtl/config-video.h
new file mode 100644
index 00000000..cc87b2b1
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/config-video.h
@@ -0,0 +1,63 @@
+#define _WTL_NO_CSTRING
+
+#pragma once
+#include "config-tab.h"
+#include "config-overscan.h"
+#include "config-framebuffer.h"
+#include "wtl-BitmapPicture.h"
+#include "wtl-tooltip.h"
+#include "resource.h"
+#include "Language.h"
+#include <atlstr.h>
+#include <vector>
+#include <regex>
+
+class CConfigDlg;
+class CFrameBufferTab;
+
+class CVideoTab :
+	public CConfigTab,
+	public CToolTipDialog<CVideoTab>
+{
+public:
+	BEGIN_MSG_MAP(CVideoTab)
+		MSG_WM_INITDIALOG(OnInitDialog)
+		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnColorStatic)
+		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnColorStatic)
+		MESSAGE_HANDLER(WM_PRINTCLIENT, OnColorStatic)
+		NOTIFY_HANDLER_EX(IDC_TAB_OVERSCAN, TCN_SELCHANGE, OnOverscanTabChange)
+		COMMAND_HANDLER_EX(IDC_CMB_FULL_SCREEN_RES, CBN_SELCHANGE, OnFullScreenChanged)
+		COMMAND_HANDLER_EX(IDC_CHK_OVERSCAN, BN_CLICKED, OnOverscan)
+		COMMAND_HANDLER(IDC_CMB_LANGUAGE, CBN_SELCHANGE, OnLanguageChanged)
+		MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
+		MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
+		CHAIN_MSG_MAP(CToolTipDialog<CVideoTab>)
+		REFLECT_NOTIFICATIONS()
+	END_MSG_MAP()
+
+	CVideoTab(CConfigDlg & Dlg, CFrameBufferTab & FrameBufferTab, const char * strIniPath);
+	~CVideoTab();
+
+	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
+	LRESULT OnScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/);
+	void OnOverscan(UINT /*Code*/, int id, HWND /*ctl*/);
+	LRESULT OnColorStatic(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/);
+	LRESULT OnOverscanTabChange(NMHDR* /*pNMHDR*/);
+	void OnFullScreenChanged(UINT /*Code*/, int id, HWND /*ctl*/);
+	LRESULT OnLanguageChanged(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& bHandled);
+	void AddOverScanTab(languageStringID caption);
+	void ShowOverScanTab(int nTab);
+	void ApplyLanguage(void);
+	void LoadSettings(bool blockCustomSettings);
+	void SaveSettings();
+
+	CTabCtrl m_OverScanTab;
+	std::vector<COverScanTab *> m_OverscanTabs;
+	CTrackBarCtrl m_AliasingSlider;
+	CTrackBarCtrl m_AnisotropicSlider;
+	CBitmapPicture m_AAInfoIcon;
+	std::string m_strIniPath;
+	LanguageList m_LangList;
+	CConfigDlg & m_Dlg;
+	CFrameBufferTab & m_FrameBufferTab;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/fullscreenresolutions_windows.cpp b/GLideN64/src/GLideNUI-wtl/fullscreenresolutions_windows.cpp
new file mode 100644
index 00000000..bef0d4f4
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/fullscreenresolutions_windows.cpp
@@ -0,0 +1,180 @@
+#include <windows.h>
+#include <stdio.h>
+#include "FullscreenResolutions.h"
+#include "../Config.h"
+
+#if defined(_MSC_VER) && _MSC_VER < 1900
+
+#define snprintf c99_snprintf
+#define vsnprintf c99_vsnprintf
+
+__inline int c99_vsnprintf(char *outBuf, size_t size, const char *format, va_list ap)
+{
+	int count = -1;
+
+	if (size != 0)
+		count = _vsnprintf_s(outBuf, size, _TRUNCATE, format, ap);
+	if (count == -1)
+		count = _vscprintf(format, ap);
+
+	return count;
+}
+
+__inline int c99_snprintf(char *outBuf, size_t size, const char *format, ...)
+{
+	int count;
+	va_list ap;
+
+	va_start(ap, format);
+	count = c99_vsnprintf(outBuf, size, format, ap);
+	va_end(ap);
+
+	return count;
+}
+
+#endif
+
+static
+struct
+{
+	struct
+	{
+		DWORD width, height, refreshRate;
+	} selected;
+
+	struct
+	{
+		DWORD	width, height;
+	} resolution[32];
+
+	DWORD refreshRate[32];
+
+	DWORD	numResolutions;
+	DWORD	numRefreshRates;
+} fullscreen;
+
+static
+void _fillFullscreenRefreshRateList(StringList & _listRefreshRates, int & _rateIdx)
+{
+	memset(&fullscreen.refreshRate, 0, sizeof(fullscreen.refreshRate));
+	fullscreen.numRefreshRates = 0;
+	_rateIdx = 0;
+
+	int i = 0;
+	DEVMODE deviceMode;
+	char text[128];
+
+	while (EnumDisplaySettings(NULL, i++, &deviceMode) != 0)
+	{
+		if (deviceMode.dmBitsPerPel != 32)
+			continue;
+
+		DWORD j = 0;
+		for (; j < fullscreen.numRefreshRates; ++j)	{
+			if ((deviceMode.dmDisplayFrequency == fullscreen.refreshRate[j]))
+				break;
+		}
+		if ((deviceMode.dmDisplayFrequency != fullscreen.refreshRate[j]) &&
+			(deviceMode.dmPelsWidth == fullscreen.selected.width) &&
+			(deviceMode.dmPelsHeight == fullscreen.selected.height)) {
+
+			fullscreen.refreshRate[j] = deviceMode.dmDisplayFrequency;
+			//: Abbreviation for Hertz; include a leading space if appropriate
+			snprintf(text, sizeof(text), "%d Hz", deviceMode.dmDisplayFrequency);
+			_listRefreshRates.push_back(text);
+
+			if (fullscreen.selected.refreshRate == deviceMode.dmDisplayFrequency)
+				_rateIdx = fullscreen.numRefreshRates;
+
+			++fullscreen.numRefreshRates;
+		}
+	}
+}
+
+void fillFullscreenResolutionsList(StringList & _listResolutions, int & _resolutionIdx, StringList & _listRefreshRates, int & _rateIdx)
+{
+	fullscreen.selected.width = config.video.fullscreenWidth;
+	fullscreen.selected.height = config.video.fullscreenHeight;
+	fullscreen.selected.refreshRate = config.video.fullscreenRefresh;
+
+	memset(&fullscreen.resolution, 0, sizeof(fullscreen.resolution));
+	memset(&fullscreen.refreshRate, 0, sizeof(fullscreen.refreshRate));
+	fullscreen.numResolutions = 0;
+	fullscreen.numRefreshRates = 0;
+	_resolutionIdx = 0;
+
+	static
+	struct
+	{
+		unsigned short x, y;
+		const char *description;
+	} ratios[] = {
+		{ 3,  2, "3:2" },
+		{ 4,  3, "4:3" },
+		{ 5,  4, "5:4" },
+		{ 16, 9, "16:9" },
+		{ 8,  5, "16:10" },
+		{ 21, 9, "21:9" }
+	};
+	const int numRatios = sizeof(ratios);
+
+	int i = 0;
+	char text[128];
+	DEVMODE deviceMode;
+	while (EnumDisplaySettings(NULL, i++, &deviceMode) != 0)
+	{
+		if (deviceMode.dmBitsPerPel != 32)
+			continue;
+
+		DWORD j = 0;
+		for (; j < fullscreen.numResolutions; ++j) {
+			if ((deviceMode.dmPelsWidth == fullscreen.resolution[j].width) &&
+				(deviceMode.dmPelsHeight == fullscreen.resolution[j].height)) {
+				break;
+			}
+		}
+		if ((deviceMode.dmPelsWidth != fullscreen.resolution[j].width) ||
+			(deviceMode.dmPelsHeight != fullscreen.resolution[j].height)) {
+
+			fullscreen.resolution[fullscreen.numResolutions].width = deviceMode.dmPelsWidth;
+			fullscreen.resolution[fullscreen.numResolutions].height = deviceMode.dmPelsHeight;
+			snprintf(text, 128, "%i x %i", deviceMode.dmPelsWidth, deviceMode.dmPelsHeight);
+
+			for (int j = 0; j < numRatios; ++j)
+				if (fabs((float)deviceMode.dmPelsWidth / (float)deviceMode.dmPelsHeight
+					- (float)ratios[j].x / (float)ratios[j].y) < 0.005f) {
+					snprintf(text, 128, "%s (%s)", text, ratios[j].description);
+					break;
+				}
+
+			_listResolutions.push_back(text);
+
+			if ((fullscreen.selected.width == deviceMode.dmPelsWidth) &&
+				(fullscreen.selected.height == deviceMode.dmPelsHeight))
+				_resolutionIdx = fullscreen.numResolutions;
+
+			++fullscreen.numResolutions;
+		}
+	}
+
+	_fillFullscreenRefreshRateList(_listRefreshRates, _rateIdx);
+}
+
+void fillFullscreenRefreshRateList(int _resolutionIdx, StringList & _listRefreshRates, int & _rateIdx)
+{
+	fullscreen.selected.width = fullscreen.resolution[_resolutionIdx].width;
+	fullscreen.selected.height = fullscreen.resolution[_resolutionIdx].height;
+	_fillFullscreenRefreshRateList(_listRefreshRates, _rateIdx);
+	_rateIdx = fullscreen.numRefreshRates - 1;
+}
+
+void getFullscreenResolutions(int _idx, unsigned int & _width, unsigned int & _height)
+{
+	_width = fullscreen.resolution[_idx].width;
+	_height = fullscreen.resolution[_idx].height;
+}
+
+void getFullscreenRefreshRate(int _idx, unsigned int & _rate)
+{
+	_rate = fullscreen.refreshRate[_idx];
+}
diff --git a/GLideN64/src/GLideNUI-wtl/resource.h b/GLideN64/src/GLideNUI-wtl/resource.h
new file mode 100644
index 0000000000000000000000000000000000000000..c4af4f6c6738368e9631205ebb98e74b5e579e9c
GIT binary patch
literal 20272
zcmbuHTW=h>5k~ttK>mY(JO)@>H(ws5(G|9&i7vjq2wATkI9RNKwVh-U<gX{G)1ND3
zPm@Kq0>SQ{*64Iiu|Bd`WY2&8{b+bJ{L_9ehpXX!I2w+Jwf(ys&n}16aBi<|hJV@5
z?}y*ndmjy3!^QAvct89)d>+2ozmLOLyY|YieHp$De;$6eSF7QV_OmtoW%w}sV*h@%
z>tF5olU@5{SKiyZzS*k}_WGk;`Pt5X$nJ1wEWP{3;WvBF>G0Ct#rrRZJG1ErBfkIN
z`?2f~<8NVczb$*uk$s+<;lM0Aw%1F4c1L<lU71x^c8`AkUO>GbJ$-9L&eRqsX8)bt
z<<{;}{{;J0Dn2+E4vl$dj5?w8o9*H8uw5mekL0yQ%el4om9<NWQN9Lwr%J}=+tKRf
zwnMJBTuweQk0{EoL*M!*fLw3AoV*&_@5uZTw^~k)ThP5BKi?Yv+}e~DC06Q@fz3}s
zKZ|%`ywe5kw`Fnhcz7C;-R4)urdPS@<U@YeMZOx9&F5cPw6x<7^7Ah8vGs7M?!Y{J
z-Vxi|qd#iBP#zm6)?NojN8hyIiTxbgHIIeOBjmaUbMmcm-k802MuSctem44LW#`=S
z(texxaQie!4|kOPWnz@iAoppIxWEg&u?M-XL3$+bi#WS9-}Xn{_E6X0l>FMfdTn&>
z(6$_#>l%bC|I+7OS#Nr8ad&K%=WSK@b6taTa+y-Pip_Nm&dK-Y4|<TZrqz(^8qCSP
zUU2(~=Eqfa=j2{nb8=mSIhk?xc5KIsu6D%cx&~`xw<|hAu4}MH?rBHJbq&%Zp^LSt
z`qs`F1rNq7sYfY0LDa2`mNFUC!uU#*M1Iik==q~u2DZkl`dC`Ki`ey6guQg!_Irt4
zZ%5cm^Oz~S-jZ`RJ=3|31wB0z{;v0@u*qCrjIrVt^&RDtdXEbGt<mY5-&v2;N7cK;
zuJ@_1&&=j)<KK*D{dBSGy(;W?#y+*5w~MS+HWuYJuveA?9NLk1d1*h)jg+a98K8XT
zdGpVM-TbR%H#r*y84jegkx2$sSE$(azBOmR9%JRmJpbB=^fS88m3<can$0{-?3OO&
zlLNDtS?|g?a6Rvvdn3h3l;g<mGmG#0?>Q>=k)_J-Z_VSYg0G>=?pT*A^DgXLJK}|d
zF~i0uakedXtV?G<B)g6>9em<*f`_qVT~fa|uphM_<4#}hC!fT+Jh9CB;p}?8gHJ9j
z_8!WPG9K8(8{_Yd{ZD_0=D9-NU7vF(26rqHBhAm*%$E+0{IU|+Njp*2BfDuw&)`#5
zU(=&sr!AwrM{F|p8;cI+(PZ2xv+WtNV_h-}EwNjk5j)o9p^<63%Te#wqs8cn8V2)`
z+6+zXc)Xmmcg-(X<K3dsUhG(xn_5rv8~OugtloOlBkbMAxD&DI(ec)ls#jvi@jYj!
zc|&Bm*zvd%v+I_N9p{5{w$CdgZ%gyLL1vFe>g>ABcwBbJ@jYixXHzxn#g5~<#jaT|
zb{yY6Ufx-sLfwTt0(G96Dyh1Z;xG9m9(SC5X%&RM?}~qGy#V*Qu;`{*aAEgR6*g5P
zWOqF7IQz`<Df$)7-Zf6tY<9c%8e@aA$pV#|P^F`fRmJka?pE>)cJBo<Vq%brIC&cL
zhsV}`^p5vp$J)u++l$%p*pRc|EM~{r@%T_iOiXCafCwR4h{uwC<daxCJ?xTx#O~9M
zv_d3nu6%74D;wX;>J^z{$J)u6uZ+wrp%inQu`YJ3ot$0z?3+w~4ST;arsZs}X8PYp
zN3r8EZOZPikBS|SX+FQaG+#5@Vb#s&X!oY+C_mW`YE@|7`xAN-t+<JNF^))FD|<$E
zw{&?vW+7D1J?iMGh{kLCBxSP3wEaengLM@$oGF{C^tFAadNj)JSeIos*&&{<XZK>q
zx;(W08Q(HbVAO|7HiahZR=ZDPT~67I2;^0aV9e@k-gb7ZOOF#O8q7sBQl>SR+KLN4
zdD75jz9xiMPR43VTcKjdx^%m#6RxfL!_4h&93ygz=hYdp`*d0M0+G&o#(L&?vE%X5
z?RH<NN734o`@htpV#m64w%0c_GN67&Gk(kZ?Td=t@pw6B6X|P<MXFXUcC1V92UA;e
z=62`pIrWTu66<o#&h2ioV_iDi$NQYjC%7>G&?9c@Uv~HDGWC4E(?lN6Eyw@pmU~I{
zPaDe2Thmwc(WkGp=Jed>SpKv#lTEFe`-Lo288~@!{WJOJ=v68+eMXIXFFyYqEv2f`
z*;*COxtz;KeM*&QsEo_@bE{`>MoZ2YyHBaGRjsC)MgN;rl{5W(37feO)k9*NRe9zY
zFYFrCA?*>F_Pk=ZdI42vr~cM@J=p;9Nh@>5%~_H7t)9Ruz|&QKG>Y}^hs~qdaZjLp
zg_*2aI+IedRr%e#el2#~6GUvrf7bLiZRR!XXN`U!Vjmi}Tnln`JVHC08b19E?S_9^
zUXk6g?qhb{D`LmGkJ)vvh#l+R*+-@lMu$F+xW8lFN9?*soE>X3V%I(5>^@yGCs~ix
z59JfoY009anaZ=q>bH+`u=xz^LCNP@^pA5@y4|rZovqbP*6*koOna)$e#&+EyrD~H
zi<fpNdEAurp4dIQOicBv@(!L)YMu66#P{<?rD@aNI(r(CV)y8>&+fdAEq1I+_qXqT
z^_EO`OMc0HFLta;XM0A-n0YfsOPT3>v1462JI@kXQ9Lvy&F3dhR(wAXb|b2C%^o&9
zv2>3WaT1T0)BRh?uGX1+66<oxrt0C9+L+EhEB0VSD|pUkPS4&z)d|T-;@xLr$GR-B
zV~h1$vE%Ww#P0Eo*s(61Jzaa~^+~MD61(3gu`WyOexLN}a&1cQu{dwbzVVWM3(MKD
zF1<g|ii}5j+kVAKtV`y5QVe4-yE@bp)^?-#U16ilNSBa&9;@}3KDyYkF6mpbe2K5I
zUF=ww&SplVxnFtJ!F}OJv1479*gchZvHNrx&nVs6bQHT!m+LV;i1K5rw<SjHOzb{g
zdLG5fI=iE4OusI6pDq(yGi0jbwHy|{*nPT8Y-ab&E140ymGh(6u`a0%T#u`Z%l6R0
zZtbQ)+pKHQhJBS8eFm{(U0z$&x91s#O|OU@>ykPKBiMG}+f6R7#g28URYg_4Sa%=-
z)!&wg=~@rl?cRBi-LdA~ZuTn?dCHNQBgAbhyJNQ7z55`$<Nn0$KD9YFySPyfy)6~2
z$a2{ov-926?RAaKwv78Ktvsq~f`7dFl_=#i*&X*)X`X}n*?+H5({~)y>s4qz?yJ(S
zjwM#RcG`W_)LKS~<Qr86=hows*3PIYsqEX*Rk2%r6>DMIQ$x)sx4FdhYhuTJRV_~L
zExx1uG-AiP)GkY6gKWaBY9GaJX@@?<YsS%Rb$UOsW9{U12hRt4?j&}sowQ$gne}4F
z+9~gboPPe&E3sqkZ0=YraZ1-<?=|x8vfZqM^R!-xs%v7$+NrUryRieSMi)EQj^evz
z<@^p}$K$-%Eh}s6SeL5$Q&Xq9p?%7|@x9mBf#Gw&eXAm|ws1fE$wp3Efl=a}opGE$
zy)2)^x^%Yo-@P2y?X@DPr>*r2RLv)`E}fm%W68joCC6)O#CNPqU+LBQh0kK=c5Ysg
zPhwp<n;p-zB)%^1^_$XRw{}J?wb$<;cC1U{uGU`8DILX*b-8@R(VfJOb?N!w@~3+6
zcdSciQ;%5oR1fTUyma>Rr+Q$=x^(vPr+Q$=x?CF99y4moSeL|!t1+)BwMJ&KV_oJu
z|9bk?-0s%SDE9WT=Z86_KW9$v-MSBUKe2yNEzH}J9O#Yp;rO5RZ9R*~oTpsL5<Avq
zUT4z|#rdajKjcTT`*c~_O`vMtw8H0nvHNsc-r*AM=)&K9x=j0BQdKPa#sb;hr_03F
zj*<BuAoqrjV#m7lI9a}X37^EeOn#nvAU&Zpwbx(C?pT+bcBB9FEe=kaA7QulMLB!Q
z^qnW_Y35|jU0eI2oITy&;_5F^bxn51y5z|tY8vItti_IX>2>5frTiP&-KR^hewRt}
zt76BxTw7Gk|FV5W>{ypc;cZ_24zYW6N!^<<fr!Z|<#VxPU3v_%SC&469bDznV0sU+
z`*fMJvHqo5&$BpFVtNI;y-x{+-&YxlHa!!&Z@iq_%}BXZwf_HO>xt4cn_EpS)+@1N
z&6nDe=iwt?Ll;|`Cy&tglU>?3fc<0qRx-XZ?4y16*f;xzv9I?2zu7t8Jodr9UyN@a
z`)uDMwl#iZ*x&8=dH8YotNrf1z4yzQmx!kf<&(W%ye-Q@SPNxGg`PClSn$eX@P$SA
z(f6E&zxXBi8!`}{k7E9*`QwevBH5`)#r~$48L>B<ds7k9Sdmr-`R*UqIe8A846^jZ
zOTBhjBGWfq*blQgJzrkqZjE)7`uA+q=;XXq5LrX5TkS1f?tx2ed6Kq>xr(Cn?I3(#
P-B0!{av#5YfBO2r*UVoC

literal 0
HcmV?d00001

diff --git a/GLideN64/src/GLideNUI-wtl/util.cpp b/GLideN64/src/GLideNUI-wtl/util.cpp
new file mode 100644
index 00000000..f8574f14
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/util.cpp
@@ -0,0 +1,57 @@
+#include "util.h"
+#include <windows.h>
+#include <memory>
+
+std::string FromUTF16(const wchar_t * UTF16Source)
+{
+	std::string Result;
+
+	uint32_t utf8size = WideCharToMultiByte(CP_UTF8, 0, UTF16Source, -1, NULL, 0, NULL, NULL);
+	if (utf8size > 0)
+	{
+		std::unique_ptr<char> pUTF8(new char[utf8size]);
+		WideCharToMultiByte(CP_UTF8, 0, UTF16Source, -1, pUTF8.get(), utf8size, NULL, NULL);
+		Result = pUTF8.get();
+	}
+	return Result;
+}
+
+std::wstring ToUTF16(const char * Source)
+{
+	std::wstring res;
+
+	DWORD nNeeded = MultiByteToWideChar(CP_UTF8, 0, Source, -1, NULL, 0);
+	if (nNeeded > 0)
+	{
+		std::unique_ptr<wchar_t> pUTF8(new wchar_t[nNeeded]);
+		if (pUTF8.get() != NULL)
+		{
+			nNeeded = MultiByteToWideChar(CP_UTF8, 0, Source, -1, pUTF8.get(), nNeeded);
+			if (nNeeded)
+			{
+				res = pUTF8.get();
+			}
+		}
+	}
+	return res;
+}
+
+std::wstring FormatStrW(const wchar_t * strFormat, ...)
+{
+	va_list args;
+	va_start(args, strFormat);
+
+	size_t nlen = _vscwprintf(strFormat, args) + 1;
+	wchar_t * buffer = (wchar_t *)alloca(nlen * sizeof(wchar_t));
+	buffer[nlen - 1] = 0;
+
+	std::wstring res;
+	if (buffer != NULL)
+	{
+		_vsnwprintf(buffer, nlen - 1, strFormat, args);
+		res = buffer;
+	}
+	va_end(args);
+	return res;
+
+}
diff --git a/GLideN64/src/GLideNUI-wtl/util.h b/GLideN64/src/GLideNUI-wtl/util.h
new file mode 100644
index 00000000..51a05825
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/util.h
@@ -0,0 +1,11 @@
+#pragma once
+#include <string>
+
+std::string FromUTF16(const wchar_t * UTF16Source);
+std::wstring ToUTF16(const char * Source);
+std::wstring FormatStrW(const wchar_t * Source, ...);
+
+template <int min, int max> class range {
+public:
+	static bool contains(int i) { return min <= i && i < max; }
+};
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.cpp b/GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.cpp
new file mode 100644
index 00000000..f7331462
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.cpp
@@ -0,0 +1,68 @@
+#include "wtl-BitmapPicture.h"
+
+CBitmapPicture::CBitmapPicture() :
+	m_hBitmap(NULL),
+	m_nResourceID(-1),
+	m_ResourceIcon(false)
+{
+	memset(&m_bmInfo, 0, sizeof(m_bmInfo));
+	m_BackgroundBrush.CreateSolidBrush(::GetSysColor(COLOR_3DFACE));
+}
+
+LRESULT CBitmapPicture::OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL &/*bHandled*/)
+{
+	CPaintDC dc(m_hWnd);
+	CRect rect;
+	GetClientRect(&rect);
+
+	CBrush PaintBrush;
+	HBRUSH OldBrush = dc.SelectBrush(m_BackgroundBrush);
+	dc.PatBlt(rect.left, rect.top, rect.Width(), rect.Height(), PATCOPY);
+	if (m_ResourceIcon)
+	{
+		CIcon hIcon = (HICON)::LoadImage(ModuleHelper::GetResourceInstance(), m_nResourceID > 0 ? MAKEINTRESOURCE(m_nResourceID) : m_strResourceName.c_str(), IMAGE_ICON, m_IconWidth, m_IconHeight, LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
+		if (!hIcon.IsNull())
+		{
+			dc.DrawIconEx(0, 0, hIcon, rect.Width(), rect.Height(), 0, NULL, DI_NORMAL);
+		}
+	}
+	dc.SelectBrush(OldBrush);
+	return 0;
+}
+
+bool CBitmapPicture::SetIcon(LPCWSTR lpszResourceName, uint32_t nWidth, uint32_t nHeight)
+{
+	CIcon hIcon = (HICON)::LoadImage(ModuleHelper::GetResourceInstance(), lpszResourceName > 0 ? MAKEINTRESOURCE(lpszResourceName) : lpszResourceName, IMAGE_ICON, nWidth, nHeight, LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
+	if (hIcon.IsNull())
+	{
+		return false;
+	}
+	ICONINFO IconInfo;
+	if (!hIcon.GetIconInfo(&IconInfo))
+	{
+		return false;
+	}
+	if (IS_INTRESOURCE(lpszResourceName))
+	{
+		m_nResourceID = (int)lpszResourceName;
+	}
+	else
+	{
+		m_strResourceName = lpszResourceName;
+	}
+	m_ResourceIcon = true;
+	m_IconWidth = nWidth;
+	m_IconHeight = nHeight;
+	return true;
+}
+
+bool CBitmapPicture::SetBitmap(HBITMAP hBitmap)
+{
+	m_hBitmap.Attach(hBitmap);
+	return ::GetObject(m_hBitmap, sizeof(BITMAP), &m_bmInfo) != 0;
+}
+
+void CBitmapPicture::SetBackroundBrush(HBRUSH brush)
+{
+	m_BackgroundBrush.Attach(brush);
+}
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.h b/GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.h
new file mode 100644
index 00000000..a2351433
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-BitmapPicture.h
@@ -0,0 +1,33 @@
+#pragma once
+#include "wtl.h"
+#include <string>
+
+class CBitmapPicture :
+	public CWindowImpl <CBitmapPicture>
+{
+public:
+	BEGIN_MSG_MAP(CBitmapPicture)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint);
+	END_MSG_MAP()
+
+	CBitmapPicture();
+
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL &/*bHandled*/);
+
+	bool SetIcon(LPCWSTR lpszResourceName, uint32_t nWidth, uint32_t nHeight);
+	void SetBackroundBrush(HBRUSH brush);
+
+private:
+	CBitmapPicture(const CBitmapPicture&);
+	CBitmapPicture& operator=(const CBitmapPicture&);
+
+	bool CBitmapPicture::SetBitmap(HBITMAP hBitmap);
+
+	int m_nResourceID;
+	std::wstring m_strResourceName;
+	uint32_t m_IconWidth, m_IconHeight;
+	bool m_ResourceIcon;
+	BITMAP m_bmInfo;
+	CBitmap m_hBitmap;
+	CBrush m_BackgroundBrush;
+};
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-ColorButton.cpp b/GLideN64/src/GLideNUI-wtl/wtl-ColorButton.cpp
new file mode 100644
index 00000000..caf17a9d
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-ColorButton.cpp
@@ -0,0 +1,67 @@
+#include "wtl-ColorButton.h"
+
+CColorButton::CColorButton() :
+	m_Red(0),
+	m_Green(0),
+	m_Blue(0)
+{
+	memset(m_CustClr, 0, sizeof(m_CustClr));
+}
+
+LRESULT CColorButton::OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL &/*bHandled*/)
+{
+	CPaintDC dc(m_hWnd);
+
+	CRect rect;
+	GetClientRect(&rect);
+
+	CPen pen;
+	pen.CreatePen(PS_SOLID, 0, ::GetSysColor(COLOR_GRAYTEXT));
+	HPEN hpenOld = dc.SelectPen(pen);
+	CBrush PaintBrush;
+	PaintBrush.CreateSolidBrush(RGB(m_Red, m_Green, m_Blue));
+	dc.SelectBrush(PaintBrush);
+	dc.Rectangle(rect.left, rect.top, rect.Width(), rect.Height());
+	dc.SelectPen(hpenOld);
+
+	return 0;
+}
+
+void CColorButton::SetColor(uint8_t Red, uint8_t Green, uint8_t Blue)
+{
+	m_Red = Red;
+	m_Green = Green;
+	m_Blue = Blue;
+	SendNotification(CPN_SELCHANGE);
+	Invalidate();
+}
+
+LRESULT CColorButton::OnClicked(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/)
+{
+	CHOOSECOLOR cc = { 0 };
+	static DWORD rgbCurrent;		// initial color selection
+	ZeroMemory(&cc, sizeof(cc));
+	cc.lStructSize = sizeof(cc);
+	cc.hwndOwner = GetParent();
+	cc.lpCustColors = (LPDWORD)m_CustClr;
+	cc.rgbResult = RGB(m_Red, m_Green, m_Blue);
+	cc.Flags = CC_FULLOPEN | CC_RGBINIT | CC_PREVENTFULLOPEN;
+	if (ChooseColor(&cc) == TRUE)
+	{
+		m_Red = GetRValue(cc.rgbResult);
+		m_Green = GetGValue(cc.rgbResult);
+		m_Blue = GetBValue(cc.rgbResult);
+		SendNotification(CPN_SELCHANGE);
+	}
+	return TRUE;
+}
+
+void CColorButton::SendNotification(UINT nCode)
+{
+	NMCOLORBUTTON nmclr;
+	nmclr.hdr.code = nCode;
+	nmclr.hdr.hwndFrom = m_hWnd;
+	nmclr.hdr.idFrom = GetDlgCtrlID();
+	nmclr.clr = RGB(m_Red, m_Green, m_Blue);
+	::SendMessage(GetParent(), WM_NOTIFY, (WPARAM)GetDlgCtrlID(), (LPARAM)&nmclr);
+}
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-ColorButton.h b/GLideN64/src/GLideNUI-wtl/wtl-ColorButton.h
new file mode 100644
index 00000000..6adc36f2
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-ColorButton.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "wtl.h"
+#include <stdint.h>
+
+class CColorButton :
+	public CWindowImpl <CColorButton>
+{
+public:
+	struct NMCOLORBUTTON
+	{
+		NMHDR hdr;
+		COLORREF clr;
+	};
+
+	enum
+	{
+		CPN_SELCHANGE = 0x8000,	/* Colour Picker Selection change */
+	};
+
+	BEGIN_MSG_MAP(CColorButton)
+		REFLECTED_COMMAND_CODE_HANDLER(BN_CLICKED, OnClicked)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint);
+	END_MSG_MAP()
+
+	CColorButton();
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL &/*bHandled*/);
+	void SetColor(uint8_t Red, uint8_t Green, uint8_t Blue);
+	LRESULT OnClicked(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*hWndCtl*/, BOOL& /*bHandled*/);
+
+	inline uint8_t Red() const { return m_Red; }
+	inline uint8_t Green() const { return m_Green; }
+	inline uint8_t Blue() const { return m_Blue; }
+
+private:
+	void SendNotification(UINT nCode);
+
+	COLORREF m_CustClr[16];
+	uint8_t m_Red, m_Green, m_Blue;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-OsdButton.cpp b/GLideN64/src/GLideNUI-wtl/wtl-OsdButton.cpp
new file mode 100644
index 00000000..1a549838
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-OsdButton.cpp
@@ -0,0 +1,60 @@
+#include "wtl-OsdButton.h"
+
+COSDButton::COSDButton(uint32_t IconId, DWORD dwExtendedStyle, HIMAGELIST hImageList) :
+	CBitmapButtonImpl<COSDButton>(dwExtendedStyle, hImageList),
+	m_Checked(false)
+{
+	if (IconId != 0)
+	{
+		m_Icon.LoadIcon(IconId);
+	}
+}
+
+void COSDButton::DoPaint(CDCHandle dc)
+{
+	CRect rect = { 0 };
+	GetClientRect(&rect);
+
+	COLORREF BackgroundColor = RGB(225, 225, 225);
+	COLORREF BorderColor = RGB(173, 173, 173);
+	if (!IsWindowEnabled())
+	{
+		BackgroundColor = RGB(204, 204, 204);
+		BorderColor = RGB(191, 191, 191);
+	}
+	else if (m_fMouseOver)
+	{
+		BackgroundColor = RGB(229, 241, 251);
+		BorderColor = RGB(0, 120, 215);
+	}
+	if (m_Checked)
+	{
+		BackgroundColor = RGB(204, 228, 247);
+		BorderColor = RGB(0, 84, 153);
+	}
+
+	CBrush Background;
+	Background.CreateSolidBrush(BackgroundColor);
+
+	CPen pen;
+	pen.CreatePen(PS_SOLID, 1, BorderColor);
+	dc.SelectPen(pen);
+	dc.SelectBrush(Background);
+	dc.Rectangle(rect.left, rect.top, rect.right, rect.bottom);
+
+	if (!m_Icon.IsNull())
+	{
+		uint32_t IconBorder = (uint32_t)(rect.Width() * 0.3);
+		uint32_t IconSize = rect.Width() - (IconBorder * 2);
+		dc.DrawIconEx(IconBorder, IconBorder, m_Icon, IconSize, IconSize);
+	}
+}
+
+void COSDButton::SetChecked(bool checked)
+{
+	if (m_Checked != checked)
+	{
+		m_Checked = checked;
+		Invalidate();
+	}
+}
\ No newline at end of file
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-OsdButton.h b/GLideN64/src/GLideNUI-wtl/wtl-OsdButton.h
new file mode 100644
index 00000000..bb3d0de1
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-OsdButton.h
@@ -0,0 +1,19 @@
+#include "wtl.h"
+#include <stdint.h>
+
+class COSDButton : 
+	public CBitmapButtonImpl<COSDButton>
+{
+public:
+	DECLARE_WND_SUPERCLASS(_T("WTL_BitmapButton"), GetWndClassName())
+
+	COSDButton(uint32_t IconId, DWORD dwExtendedStyle = BMPBTN_AUTOSIZE | BMPBTN_HOVER, HIMAGELIST hImageList = NULL);
+	void DoPaint(CDCHandle dc);
+	void SetChecked(bool checked);
+
+	inline bool isChecked(void) const { return m_Checked; }
+
+private:
+	CIcon m_Icon;
+	bool m_Checked;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.cpp b/GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.cpp
new file mode 100644
index 00000000..f39f8060
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.cpp
@@ -0,0 +1,120 @@
+#include "wtl-OsdPreview.h"
+#include "FontInfo.h"
+#include "util.h"
+#include "Language.h"
+#include <DWrite.h>
+
+#pragma comment(lib, "Dwrite.lib")
+
+COsdPreview::COsdPreview() :
+	m_FontFile(L"arial.ttf"),
+	m_FontSize(16),
+	m_Red(0),
+	m_Green(0),
+	m_Blue(0)
+{
+}
+
+void COsdPreview::SetFont(const std::wstring & FontFile)
+{
+	m_FontFile = FontFile;
+	Invalidate();
+}
+
+void COsdPreview::SetFontSize(uint32_t FontSize)
+{
+	m_FontSize = FontSize;
+	Invalidate();
+}
+
+void COsdPreview::SetColor(uint8_t Red, uint8_t Green, uint8_t Blue)
+{
+	m_Red = Red;
+	m_Green = Green;
+	m_Blue = Blue;
+	Invalidate();
+}
+
+
+LRESULT COsdPreview::OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL & /*bHandled*/)
+{
+	CRect rect;
+	GetClientRect(&rect);
+
+	CPaintDC dc(m_hWnd);
+	CBrush PaintBrush;
+	PaintBrush.CreateSolidBrush(RGB(0, 0, 0));
+	dc.SelectBrush(PaintBrush);
+	dc.Rectangle(rect.left, rect.top, rect.Width(), rect.Height());
+	dc.SetTextColor(RGB(m_Red, m_Green, m_Blue));
+	dc.SetBkColor(RGB(0, 0, 0));
+
+	std::wstring fontFileName = ToUTF16(GetFontFolder().c_str());
+	fontFileName += L"\\" + m_FontFile;
+
+	AddFontResourceEx(fontFileName.c_str(), FR_PRIVATE, 0);
+	LOGFONT logFont;
+	if (SUCCEEDED(GetLogFontFromFileName(fontFileName.c_str(), &logFont)))
+	{
+		int desiredPpem = (int)m_FontSize;
+		logFont.lfHeight = -long(desiredPpem);
+		HFONT hf = CreateFontIndirect(&logFont);
+		HFONT hOldFont = (HFONT)dc.SelectFont(hf);
+		if (hOldFont)
+		{
+			dc.DrawText(wGS(OSD_PREVIEW).c_str(), -1, rect, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
+			dc.SelectFont(hOldFont);
+		}
+	}
+	return 0;
+}
+
+HRESULT COsdPreview::GetLogFontFromFileName(const wchar_t * fontFileName, LOGFONT* logFont)
+{
+	CComPtr<IDWriteFactory> dwriteFactory;
+	if (FAILED(DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED, __uuidof(IDWriteFactory), reinterpret_cast<IUnknown**>(&dwriteFactory))))
+	{
+		return S_FALSE;
+	}
+
+	CComPtr<IDWriteGdiInterop> gdiInterop;
+	if (FAILED(dwriteFactory->GetGdiInterop(&gdiInterop)))
+	{
+		return S_FALSE;
+	}
+
+	CComPtr<IDWriteFontFile> fontFile;
+	if (FAILED(dwriteFactory->CreateFontFileReference(fontFileName, nullptr, &fontFile)))
+	{
+		return S_FALSE;
+	}
+
+	BOOL isSupportedFontType = false;
+	DWRITE_FONT_FILE_TYPE fontFileType;
+	DWRITE_FONT_FACE_TYPE fontFaceType;
+	UINT32 numberOfFaces = 0;
+	if (FAILED(fontFile->Analyze(&isSupportedFontType, &fontFileType, &fontFaceType, &numberOfFaces)))
+	{
+		return S_FALSE;
+	}
+	if (!isSupportedFontType)
+	{
+		return DWRITE_E_FILEFORMAT;
+	}
+
+	CComPtr<IDWriteFontFace> fontFace;
+	IDWriteFontFile * const fontFiles[] =
+	{
+		fontFile.p
+	};
+	if (FAILED(dwriteFactory->CreateFontFace(fontFaceType, ARRAYSIZE(fontFiles), &fontFiles[0], 0, DWRITE_FONT_SIMULATIONS_NONE, &fontFace)))
+	{
+		return S_FALSE;
+	}
+
+	if (FAILED(gdiInterop->ConvertFontFaceToLOGFONT(fontFace, OUT logFont)))
+	{
+		return S_FALSE;
+	}
+	return S_OK;
+}
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.h b/GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.h
new file mode 100644
index 00000000..0bf73c9e
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-OsdPreview.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "wtl.h"
+#include <string>
+
+class COsdPreview :
+	public CWindowImpl <COsdPreview>
+{
+public:
+	BEGIN_MSG_MAP(CColorButton)
+		MESSAGE_HANDLER(WM_PAINT, OnPaint);
+	END_MSG_MAP()
+
+	COsdPreview();
+	void SetFont(const std::wstring & FontFile);
+	void SetFontSize(uint32_t FontSize);
+	void SetColor(uint8_t Red, uint8_t Green, uint8_t Blue);
+	LRESULT OnPaint(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL & /*bHandled*/);
+
+private:
+	static HRESULT GetLogFontFromFileName(const wchar_t * fontFileName, LOGFONT* logFont);
+
+	std::wstring m_FontFile;
+	uint8_t m_Red, m_Green, m_Blue;
+	uint32_t m_FontSize;
+};
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-WindowFont.h b/GLideN64/src/GLideNUI-wtl/wtl-WindowFont.h
new file mode 100644
index 00000000..0c1bc248
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-WindowFont.h
@@ -0,0 +1,97 @@
+#pragma once
+#include "wtl.h"
+
+// Wrapper for the Win32 LOGFONT structure
+class CLogFont : public LOGFONT
+{
+public:
+	CLogFont()
+	{
+		memset(static_cast<LOGFONT*>(this), 0, sizeof(LOGFONT));
+	}
+};
+
+// Class used to create a font based on the font used by a specific window
+class CWindowFont : public CFont  
+{
+public:
+	// Font styles
+	typedef enum tagEType
+	{
+		typeNormal		= 0x00,
+		typeBold		= 0x01,
+		typeItalic		= 0x02,
+		typeUnderline	= 0x04,
+		typeSubheading	= 0x08,
+		typeHeading		= 0x10,
+	} EType;
+public:
+	CWindowFont() : CFont()
+	{
+	}
+	
+	/// hWnd	- The window to use for the base font
+	/// nType	- Font style flags
+	CWindowFont(HWND hWnd, int nType)
+	{
+		// We need a HWND
+		ATLASSERT(hWnd != NULL);
+		// Create the font
+		Create(hWnd, nType);
+	}
+	
+	virtual ~CWindowFont()
+	{
+	}
+public:
+	// Create the font
+	// hWnd		- The window to use for the base font
+	// nType	- Font style flags
+	// return true on success
+	bool Create(HWND hWnd, int nType)
+	{
+		// Be defensive
+		ATLASSERT(hWnd != NULL);
+		ATLASSERT(::IsWindow(hWnd) != FALSE);
+		// Get the font the window is currently using
+		HFONT hFont = (HFONT)::SendMessage(hWnd, WM_GETFONT, 0, 0);
+		// Do we have a font?
+		if (hFont == NULL)
+			return false;
+		
+		::CLogFont lf;
+		// Fill the LOGFONT
+		if (::GetObject(hFont, sizeof(lf), &lf) == 0)
+			return false;
+		// Amend the LOGFONT members
+		if (nType & typeBold)
+			lf.lfWeight = FW_BOLD;
+		if (nType & typeItalic)
+			lf.lfItalic = TRUE;
+		if (nType & typeUnderline)
+			lf.lfUnderline = TRUE;
+		if (nType & typeSubheading)
+			lf.lfHeight = static_cast<LONG>(lf.lfHeight * 1.25);
+		if (nType & typeHeading)
+			lf.lfHeight = static_cast<LONG>(lf.lfHeight * 2.5);
+		
+		// Create the new font
+		return CreateFontIndirect(&lf) ? true : false;
+	}
+	
+	// Create the font and apply to a nominate dialog control
+	bool Apply(HWND hWnd, int nType, UINT nControlID)
+	{
+		// First create the font
+		if (IsNull() && !Create(hWnd, nType))
+		{
+			return false;
+		}
+		// Apply to the nominated control
+		CWindow wndControl = ::GetDlgItem(hWnd, nControlID);
+		ATLASSERT(wndControl != NULL);
+		// Apply
+		wndControl.SetFont(m_hFont);
+		return true;
+	}
+};
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h b/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h
new file mode 100644
index 00000000..6ae4e19a
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h
@@ -0,0 +1,113 @@
+#pragma once
+
+template < class T, class TT = CToolTipCtrl >
+class CToolTipDialog
+{
+	// Data declarations and members
+public:
+	TT& GetTT() { return m_TT; }
+protected:
+	TT m_TT;
+	UINT m_uTTStyle;
+	UINT m_uToolFlags;
+	// Construction
+	CToolTipDialog(UINT uTTSTyle = TTS_NOPREFIX | TTS_BALLOON, UINT uToolFlags = TTF_IDISHWND | TTF_SUBCLASS)
+		: m_TT(NULL), m_uTTStyle(uTTSTyle),
+		m_uToolFlags(uToolFlags | TTF_SUBCLASS)
+	{}
+
+	void TTInit()
+	{
+		T* pT = (T*)this;
+		ATLASSERT(::IsWindow(*pT));
+		m_TT.Create(*pT, NULL, NULL, m_uTTStyle);
+		CToolInfo ToolInfo(pT->m_uToolFlags, *pT, 0, 0, MAKEINTRESOURCE(pT->IDD));
+		m_TT.AddTool(&ToolInfo);
+		::EnumChildWindows(*pT, SetTool, (LPARAM)pT);
+		TTDelay();
+		TTSize(0);
+		TTActivate(TRUE);
+	}
+	// Operations
+public:
+	void TTActivate(BOOL bActivate)
+	{
+		m_TT.Activate(bActivate);
+	}
+	void TTSize(int nPixel)
+	{
+		m_TT.SetMaxTipWidth(nPixel);
+	}
+	void TTDelay()
+	{
+		m_TT.SetDelayTime(TTDT_INITIAL, 1250);
+		m_TT.SetDelayTime(TTDT_RESHOW, 600);
+		m_TT.SetDelayTime(TTDT_AUTOPOP, 32767);
+	}
+
+	void TTSetTxt(HWND hTool, _U_STRINGorID text)
+	{
+		m_TT.UpdateTipText(text, hTool);
+	}
+	void TTSetTxt(UINT idTool, _U_STRINGorID text)
+	{
+		TTSetTxt(GetHWND(idTool), text);
+	}
+
+	BOOL TTAdd(HWND hTool)
+	{
+		return SetTool(hTool, (LPARAM)(T*)this);
+	}
+	BOOL TTAdd(UINT idTool)
+	{
+		return TTAdd(GetHWND(idTool));
+	}
+
+	void TTRemove(HWND hTool)
+	{
+		m_TT.DelTool(hTool);
+	}
+	void TTRemove(UINT idTool)
+	{
+		TTRemove(GetHWND(idTool));
+	}
+	// Message map and handlers
+	BEGIN_MSG_MAP(CToolTipDialog)
+		MESSAGE_RANGE_HANDLER(WM_MOUSEFIRST, WM_MOUSELAST, OnMouse)
+		MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
+	END_MSG_MAP()
+
+	LRESULT OnInitDialog(UINT, WPARAM, LPARAM, BOOL& bHandled)
+	{
+		TTInit();
+		bHandled = FALSE;
+		return TRUE;
+	}
+
+	LRESULT OnMouse(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
+	{
+		T* pT = (T*)this;
+		bHandled = FALSE;
+		if (m_TT.IsWindow())
+			m_TT.RelayEvent((LPMSG)pT->GetCurrentMessage());
+		return 0;
+	}
+	// Implementation
+private:
+	HWND GetHWND(UINT idTool)
+	{
+		return ::GetDlgItem(*(T*)this, idTool);
+	}
+
+	static BOOL CALLBACK SetTool(HWND hTool, LPARAM pDlg)
+	{
+		T* pT = (T*)pDlg;
+		int idTool = ::GetWindowLong(hTool, GWL_ID);
+		if (idTool != IDC_STATIC)
+		{
+			CToolInfo ToolInfo(pT->m_uToolFlags, hTool, 0, 0, (LPTSTR)idTool);
+			pT->m_TT.AddTool(&ToolInfo);
+		}
+		return TRUE;
+	}
+};
diff --git a/GLideN64/src/GLideNUI-wtl/wtl.h b/GLideN64/src/GLideNUI-wtl/wtl.h
new file mode 100644
index 00000000..5c70e27c
--- /dev/null
+++ b/GLideN64/src/GLideNUI-wtl/wtl.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#undef OS_WINDOWS
+#pragma warning(push)
+#pragma warning(disable : 4091) // warning C4091: 'typedef ': ignored on left of 'tagGPFIDL_FLAGS' when no variable is declared
+#pragma warning(disable : 4201) // warning C4201: nonstandard extension used: nameless struct/union
+#pragma warning(disable : 4302) // warning C4302: 'type cast': truncation from 'LPCTSTR' to 'WORD'
+#pragma warning(disable : 4458) // warning C4458: declaration of 'dwCommonButtons' hides class member
+#pragma warning(disable : 4838) // warning C4838: conversion from 'int' to 'UINT' requires a narrowing conversion
+#pragma warning(disable : 4996) // warning C4996: 'GetVersionExA': was declared deprecated
+#define _ATL_DISABLE_NOTHROW_NEW
+#include <atlbase.h>
+#include "wtl\atlapp.h"
+#include "wtl\atlcrack.h"
+#include "wtl\atlctrls.h"
+#include "WTL\atlctrlx.h"
+#include "WTL\atlgdi.h"
+#include "WTL\atlmisc.h"
+#include "WTL\atlwinx.h"
+#include <atlwin.h>
+#pragma warning(pop)
diff --git a/GLideN64/src/GLideNUI/ConfigDialog.cpp b/GLideN64/src/GLideNUI/ConfigDialog.cpp
index 1d2dd6d1..cd4a9b22 100644
--- a/GLideN64/src/GLideNUI/ConfigDialog.cpp
+++ b/GLideN64/src/GLideNUI/ConfigDialog.cpp
@@ -142,6 +142,11 @@ void ConfigDialog::_init(bool reInit, bool blockCustomSettings)
 		break;
 	}
 
+	ui->ditheringModeComboBox->setCurrentIndex(config.generalEmulation.rdramImageDitheringMode);
+	ui->ditheringQuantizationCheckBox->setChecked(config.generalEmulation.enableDitheringQuantization);
+	ui->hiresNoiseDitheringCheckBox->setChecked(config.generalEmulation.enableHiresNoiseDithering);
+	ui->ditheringPatternCheckBox->setChecked(config.generalEmulation.enableDitheringPattern);
+
 	switch (config.texture.screenShotFormat) {
 	case 0:
 		ui->pngRadioButton->setChecked(true);
@@ -153,7 +158,6 @@ void ConfigDialog::_init(bool reInit, bool blockCustomSettings)
 
 	// Emulation settings
 	ui->emulateLodCheckBox->setChecked(config.generalEmulation.enableLOD != 0);
-	ui->emulateNoiseCheckBox->setChecked(config.generalEmulation.enableNoise != 0);
 	ui->enableHWLightingCheckBox->setChecked(config.generalEmulation.enableHWLighting != 0);
 	ui->enableShadersStorageCheckBox->setChecked(config.generalEmulation.enableShadersStorage != 0);
 	if (!blockCustomSettings)
@@ -443,6 +447,11 @@ void ConfigDialog::accept(bool justSave) {
 	else if (ui->blnr3PointRadioButton->isChecked())
 		config.texture.bilinearMode = BILINEAR_3POINT;
 
+	config.generalEmulation.rdramImageDitheringMode = ui->ditheringModeComboBox->currentIndex();
+	config.generalEmulation.enableDitheringQuantization = ui->ditheringQuantizationCheckBox->isChecked() ? 1 : 0;
+	config.generalEmulation.enableHiresNoiseDithering = ui->hiresNoiseDitheringCheckBox->isChecked() ? 1 : 0;
+	config.generalEmulation.enableDitheringPattern = ui->ditheringPatternCheckBox->isChecked() ? 1 : 0;
+
 	if (ui->pngRadioButton->isChecked())
 		config.texture.screenShotFormat = 0;
 	else if (ui->jpegRadioButton->isChecked())
@@ -462,7 +471,6 @@ void ConfigDialog::accept(bool justSave) {
 
 	// Emulation settings
 	config.generalEmulation.enableLOD = ui->emulateLodCheckBox->isChecked() ? 1 : 0;
-	config.generalEmulation.enableNoise = ui->emulateNoiseCheckBox->isChecked() ? 1 : 0;
 	config.generalEmulation.enableHWLighting = ui->enableHWLightingCheckBox->isChecked() ? 1 : 0;
 	config.generalEmulation.enableShadersStorage = ui->enableShadersStorageCheckBox->isChecked() ? 1 : 0;
 	config.generalEmulation.enableCustomSettings = ui->customSettingsCheckBox->isChecked() ? 1 : 0;
diff --git a/GLideN64/src/GLideNUI/BottomLeft.ico b/GLideN64/src/GLideNUI/Resources/BottomLeft.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/BottomLeft.ico
rename to GLideN64/src/GLideNUI/Resources/BottomLeft.ico
diff --git a/GLideN64/src/GLideNUI/BottomRight.ico b/GLideN64/src/GLideNUI/Resources/BottomRight.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/BottomRight.ico
rename to GLideN64/src/GLideNUI/Resources/BottomRight.ico
diff --git a/GLideN64/src/GLideNUI/Down.ico b/GLideN64/src/GLideNUI/Resources/Down.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Down.ico
rename to GLideN64/src/GLideNUI/Resources/Down.ico
diff --git a/GLideN64/src/GLideNUI/Icon-Original.ico b/GLideN64/src/GLideNUI/Resources/Icon-Original.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Icon-Original.ico
rename to GLideN64/src/GLideNUI/Resources/Icon-Original.ico
diff --git a/GLideN64/src/GLideNUI/Icon.ico b/GLideN64/src/GLideNUI/Resources/Icon.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Icon.ico
rename to GLideN64/src/GLideNUI/Resources/Icon.ico
diff --git a/GLideN64/src/GLideNUI/Info.ico b/GLideN64/src/GLideNUI/Resources/Info.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Info.ico
rename to GLideN64/src/GLideNUI/Resources/Info.ico
diff --git a/GLideN64/src/GLideNUI/Left.ico b/GLideN64/src/GLideNUI/Resources/Left.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Left.ico
rename to GLideN64/src/GLideNUI/Resources/Left.ico
diff --git a/GLideN64/src/GLideNUI/Right.ico b/GLideN64/src/GLideNUI/Resources/Right.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Right.ico
rename to GLideN64/src/GLideNUI/Resources/Right.ico
diff --git a/GLideN64/src/GLideNUI/TopLeft.ico b/GLideN64/src/GLideNUI/Resources/TopLeft.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/TopLeft.ico
rename to GLideN64/src/GLideNUI/Resources/TopLeft.ico
diff --git a/GLideN64/src/GLideNUI/TopRight.ico b/GLideN64/src/GLideNUI/Resources/TopRight.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/TopRight.ico
rename to GLideN64/src/GLideNUI/Resources/TopRight.ico
diff --git a/GLideN64/src/GLideNUI/Up.ico b/GLideN64/src/GLideNUI/Resources/Up.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Up.ico
rename to GLideN64/src/GLideNUI/Resources/Up.ico
diff --git a/GLideN64/src/GLideNUI/Warning.ico b/GLideN64/src/GLideNUI/Resources/Warning.ico
similarity index 100%
rename from GLideN64/src/GLideNUI/Warning.ico
rename to GLideN64/src/GLideNUI/Resources/Warning.ico
diff --git a/GLideN64/src/GLideNUI/Settings.cpp b/GLideN64/src/GLideNUI/Settings.cpp
index adaac331..68dd7a9b 100644
--- a/GLideN64/src/GLideNUI/Settings.cpp
+++ b/GLideN64/src/GLideNUI/Settings.cpp
@@ -40,7 +40,10 @@ void _loadSettings(QSettings & settings)
 	settings.endGroup();
 
 	settings.beginGroup("generalEmulation");
-	config.generalEmulation.enableNoise = settings.value("enableNoise", config.generalEmulation.enableNoise).toInt();
+	config.generalEmulation.enableDitheringPattern = settings.value("enableDitheringPattern", config.generalEmulation.enableDitheringPattern).toInt();
+	config.generalEmulation.enableDitheringQuantization = settings.value("enableDitheringQuantization", config.generalEmulation.enableDitheringQuantization).toInt();
+	config.generalEmulation.enableHiresNoiseDithering = settings.value("enableHiresNoiseDithering", config.generalEmulation.enableHiresNoiseDithering).toInt();
+	config.generalEmulation.rdramImageDitheringMode = settings.value("rdramImageDitheringMode", config.generalEmulation.rdramImageDitheringMode).toInt();
 	config.generalEmulation.enableLOD = settings.value("enableLOD", config.generalEmulation.enableLOD).toInt();
 	config.generalEmulation.enableHWLighting = settings.value("enableHWLighting", config.generalEmulation.enableHWLighting).toInt();
 	config.generalEmulation.enableShadersStorage = settings.value("enableShadersStorage", config.generalEmulation.enableShadersStorage).toInt();
@@ -212,7 +215,10 @@ void writeSettings(const QString & _strIniFolder)
 	settings.endGroup();
 
 	settings.beginGroup("generalEmulation");
-	settings.setValue("enableNoise", config.generalEmulation.enableNoise);
+	settings.setValue("enableDitheringPattern", config.generalEmulation.enableDitheringPattern);
+	settings.setValue("enableDitheringQuantization", config.generalEmulation.enableDitheringQuantization);
+	settings.setValue("enableHiresNoiseDithering", config.generalEmulation.enableHiresNoiseDithering);
+	settings.setValue("rdramImageDitheringMode", config.generalEmulation.rdramImageDitheringMode);
 	settings.setValue("enableLOD", config.generalEmulation.enableLOD);
 	settings.setValue("enableHWLighting", config.generalEmulation.enableHWLighting);
 	settings.setValue("enableShadersStorage", config.generalEmulation.enableShadersStorage);
@@ -402,7 +408,10 @@ void saveCustomRomSettings(const QString & _strIniFolder, const char * _strRomNa
 	settings.endGroup();
 
 	settings.beginGroup("generalEmulation");
-	WriteCustomSetting(generalEmulation, enableNoise);
+	WriteCustomSetting(generalEmulation, enableDitheringPattern);
+	WriteCustomSetting(generalEmulation, enableDitheringQuantization);
+	WriteCustomSetting(generalEmulation, enableHiresNoiseDithering);
+	WriteCustomSetting(generalEmulation, rdramImageDitheringMode);
 	WriteCustomSetting(generalEmulation, enableLOD);
 	WriteCustomSetting(generalEmulation, enableHWLighting);
 	WriteCustomSetting(generalEmulation, enableShadersStorage);
diff --git a/GLideN64/src/GLideNUI/configDialog.ui b/GLideN64/src/GLideNUI/configDialog.ui
index b7b67d27..aa877866 100644
--- a/GLideN64/src/GLideNUI/configDialog.ui
+++ b/GLideN64/src/GLideNUI/configDialog.ui
@@ -10,7 +10,7 @@
     <x>0</x>
     <y>0</y>
     <width>559</width>
-    <height>595</height>
+    <height>613</height>
    </rect>
   </property>
   <property name="windowTitle">
@@ -1130,19 +1130,6 @@
               </property>
              </widget>
             </item>
-            <item>
-             <widget class="QCheckBox" name="emulateNoiseCheckBox">
-              <property name="toolTip">
-               <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;This option emulates effects that use random color input. Checking this option may cause rare performance problems.&lt;/p&gt;&lt;p&gt;[Recommended: &lt;span style=&quot; font-style:italic;&quot;&gt;Checked&lt;/span&gt;]&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
-              </property>
-              <property name="text">
-               <string>Enable noise</string>
-              </property>
-              <property name="checked">
-               <bool>true</bool>
-              </property>
-             </widget>
-            </item>
             <item>
              <widget class="QCheckBox" name="enableHWLightingCheckBox">
               <property name="toolTip">
@@ -1393,6 +1380,86 @@
            </item>
           </layout>
          </item>
+         <item>
+          <widget class="QGroupBox" name="ditheringGroupBox">
+           <property name="title">
+            <string>Dithering</string>
+           </property>
+           <layout class="QGridLayout" name="gridLayout_6">
+            <item row="0" column="1">
+             <widget class="QCheckBox" name="ditheringQuantizationCheckBox">
+              <property name="toolTip">
+               <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Like real hardware this setting reduces the number of colors if dithering is used. Removes undesired dithering fragments. Default = enabled.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+              </property>
+              <property name="text">
+               <string>Enable 5bit quantization</string>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="0">
+             <widget class="QCheckBox" name="hiresNoiseDitheringCheckBox">
+              <property name="toolTip">
+               <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;This setting doubles noise resolution to get a finer noise effect at higher resolutions. Default = disabled.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+              </property>
+              <property name="text">
+               <string>High resolution noise dithering</string>
+              </property>
+             </widget>
+            </item>
+            <item row="0" column="0">
+             <widget class="QCheckBox" name="ditheringPatternCheckBox">
+              <property name="toolTip">
+               <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;This setting enables game controlled ordered grid dithering. Enable it for accurate representation. Default = disabled.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+              </property>
+              <property name="text">
+               <string>Dithering pattern on output image</string>
+              </property>
+             </widget>
+            </item>
+            <item row="1" column="1">
+             <layout class="QHBoxLayout" name="horizontalLayout_24">
+              <item>
+               <widget class="QLabel" name="ditheringLabel">
+                <property name="toolTip">
+                 <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;RDRAM dithering prevents color banding in games with framebuffer effects.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                </property>
+                <property name="text">
+                 <string>RDRAM image dithering:</string>
+                </property>
+               </widget>
+              </item>
+              <item>
+               <widget class="QComboBox" name="ditheringModeComboBox">
+                <property name="toolTip">
+                 <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Settings: Disabled, Bayer ordered grid dithering, Magic Square ordered grid dithering or blue noise dithering. Blue noise dithering produces unobtrusive results. Default = blue noise dithering.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
+                </property>
+                <item>
+                 <property name="text">
+                  <string>disable</string>
+                 </property>
+                </item>
+                <item>
+                 <property name="text">
+                  <string>Bayer</string>
+                 </property>
+                </item>
+                <item>
+                 <property name="text">
+                  <string>Magic square</string>
+                 </property>
+                </item>
+                <item>
+                 <property name="text">
+                  <string>Blue noise</string>
+                 </property>
+                </item>
+               </widget>
+              </item>
+             </layout>
+            </item>
+           </layout>
+          </widget>
+         </item>
          <item>
           <widget class="QGroupBox" name="nativeRes2DGroupBox">
            <property name="title">
@@ -3996,9 +4063,9 @@
   </connection>
  </connections>
  <buttongroups>
-  <buttongroup name="screenshotButtonGroup"/>
   <buttongroup name="factorButtonGroup"/>
-  <buttongroup name="fixTexrectCoordsButtonGroup"/>
   <buttongroup name="osdButtonGroup"/>
+  <buttongroup name="fixTexrectCoordsButtonGroup"/>
+  <buttongroup name="screenshotButtonGroup"/>
  </buttongroups>
 </ui>
diff --git a/GLideN64/src/GLideNUI/icon.qrc b/GLideN64/src/GLideNUI/icon.qrc
index 0f602f33..9929470a 100644
--- a/GLideN64/src/GLideNUI/icon.qrc
+++ b/GLideN64/src/GLideNUI/icon.qrc
@@ -1,15 +1,15 @@
 <RCC>
     <qresource prefix="/">
-        <file>Icon.ico</file>
-        <file>Warning.ico</file>
-        <file>Info.ico</file>
-        <file>Up.ico</file>
-        <file>Right.ico</file>
-        <file>Down.ico</file>
-        <file>Left.ico</file>
-        <file>TopLeft.ico</file>
-        <file>TopRight.ico</file>
-        <file>BottomRight.ico</file>
-        <file>BottomLeft.ico</file>
+        <file alias="BottomLeft.ico">Resources/BottomLeft.ico</file>
+        <file alias="BottomRight.ico">Resources/BottomRight.ico</file>
+        <file alias="Down.ico">Resources/Down.ico</file>
+        <file alias="Icon.ico">Resources/Icon.ico</file>
+        <file alias="Info.ico">Resources/Info.ico</file>
+        <file alias="Left.ico">Resources/Left.ico</file>
+        <file alias="Right.ico">Resources/Right.ico</file>
+        <file alias="TopLeft.ico">Resources/TopLeft.ico</file>
+        <file alias="TopRight.ico">Resources/TopRight.ico</file>
+        <file alias="Up.ico">Resources/Up.ico</file>
+        <file alias="Warning.ico">Resources/Warning.ico</file>
     </qresource>
 </RCC>
diff --git a/GLideN64/src/Graphics/CombinerProgram.cpp b/GLideN64/src/Graphics/CombinerProgram.cpp
index 1cfae434..37521bd6 100644
--- a/GLideN64/src/Graphics/CombinerProgram.cpp
+++ b/GLideN64/src/Graphics/CombinerProgram.cpp
@@ -12,7 +12,9 @@ namespace graphics {
 		vecOptions.push_back(config.texture.bilinearMode);
 		vecOptions.push_back(config.texture.enableHalosRemoval);
 		vecOptions.push_back(config.generalEmulation.enableHWLighting);
-		vecOptions.push_back(config.generalEmulation.enableNoise);
+		vecOptions.push_back(config.generalEmulation.enableHiresNoiseDithering);
+		vecOptions.push_back(config.generalEmulation.enableDitheringPattern);
+		vecOptions.push_back(config.generalEmulation.enableDitheringQuantization);
 		vecOptions.push_back(config.generalEmulation.enableLOD);
 		vecOptions.push_back(config.frameBufferEmulation.N64DepthCompare == Config::dcFast ? 1 : 0);
 		vecOptions.push_back(config.frameBufferEmulation.N64DepthCompare == Config::dcCompatible ? 1 : 0);
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
index 393b3236..d4cd0ec4 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
@@ -263,6 +263,7 @@ class VertexShaderHeader : public ShaderPart
 			ss << "# define IN in" << std::endl << "# define OUT out" << std::endl;
 			m_part = ss.str();
 		}
+		m_part += "uniform lowp float uClipRatio; \n";
 	}
 };
 
@@ -291,12 +292,16 @@ class VertexShaderTexturedTriangle : public ShaderPart
 			"uniform mediump vec2 uCacheOffset[2];				\n"
 			"uniform mediump vec2 uCacheShiftScale[2];			\n"
 			"uniform lowp ivec2 uCacheFrameBuffer;				\n"
-			"OUT lowp vec4 vShadeColor;							\n"
 			"OUT highp vec2 vTexCoord0;							\n"
 			"OUT highp vec2 vTexCoord1;							\n"
 			"OUT mediump vec2 vLodTexCoord;						\n"
 			"OUT lowp float vNumLights;							\n"
-
+			;
+		if (!_glinfo.isGLESX || _glinfo.noPerspective)
+			m_part += "noperspective OUT lowp vec4 vShadeColor;	\n";
+		else
+			m_part += "OUT lowp vec4 vShadeColor;				\n";
+		m_part +=
 			"mediump vec2 calcTexCoord(in vec2 texCoord, in int idx)		\n"
 			"{																\n"
 			"    vec2 texCoordOut = texCoord*uCacheShiftScale[idx];			\n"
@@ -351,17 +356,22 @@ class VertexShaderTriangle : public ShaderPart
 	VertexShaderTriangle(const opengl::GLInfo & _glinfo)
 	{
 		m_part =
-			"IN highp vec4 aPosition;			\n"
-			"IN lowp vec4 aColor;				\n"
-			"IN lowp float aNumLights;			\n"
-			"IN highp vec4 aModify;				\n"
-			"									\n"
-			"uniform lowp int uFogUsage;		\n"
-			"uniform mediump vec2 uFogScale;	\n"
-			"uniform mediump vec2 uScreenCoordsScale;\n"
-			"									\n"
-			"OUT lowp vec4 vShadeColor;			\n"
-			"OUT lowp float vNumLights;			\n"
+			"IN highp vec4 aPosition;										\n"
+			"IN lowp vec4 aColor;											\n"
+			"IN lowp float aNumLights;										\n"
+			"IN highp vec4 aModify;											\n"
+			"																\n"
+			"uniform lowp int uFogUsage;									\n"
+			"uniform mediump vec2 uFogScale;								\n"
+			"uniform mediump vec2 uScreenCoordsScale;						\n"
+			"																\n"
+			"OUT lowp float vNumLights;										\n"
+			;
+		if (!_glinfo.isGLESX || _glinfo.noPerspective)
+			m_part += "noperspective OUT lowp vec4 vShadeColor;				\n";
+		else
+			m_part += "OUT lowp vec4 vShadeColor;							\n";
+		m_part +=
 			"																\n"
 			"void main()													\n"
 			"{																\n"
@@ -405,9 +415,14 @@ class VertexShaderTexturedRect : public ShaderPart
 			"IN highp vec2 aTexCoord0;							\n"
 			"IN highp vec2 aTexCoord1;							\n"
 			"													\n"
-			"OUT lowp vec4 vShadeColor;							\n"
-			"OUT highp vec2 vTexCoord0;						\n"
-			"OUT highp vec2 vTexCoord1;						\n"
+			"OUT highp vec2 vTexCoord0;							\n"
+			"OUT highp vec2 vTexCoord1;							\n"
+			;
+		if (!_glinfo.isGLESX || _glinfo.noPerspective)
+			m_part += "noperspective OUT lowp vec4 vShadeColor;	\n";
+		else
+			m_part += "OUT lowp vec4 vShadeColor;				\n";
+		m_part +=
 			"uniform lowp vec4 uRectColor;						\n"
 			"void main()										\n"
 			"{													\n"
@@ -427,7 +442,12 @@ class VertexShaderRect : public ShaderPart
 		m_part =
 			"IN highp vec4 aRectPosition;						\n"
 			"													\n"
-			"OUT lowp vec4 vShadeColor;							\n"
+			;
+		if (!_glinfo.isGLESX || _glinfo.noPerspective)
+			m_part += "noperspective OUT lowp vec4 vShadeColor;	\n";
+		else
+			m_part += "OUT lowp vec4 vShadeColor;				\n";
+		m_part +=
 			"uniform lowp vec4 uRectColor;						\n"
 			"void main()										\n"
 			"{													\n"
@@ -454,6 +474,7 @@ class VertexShaderEnd : public ShaderPart
 					;
 		}
 		m_part +=
+			" gl_Position.zw *= vec2(uClipRatio);	 \n"
 			"} \n"
 			;
 	}
@@ -521,6 +542,10 @@ class FragmentShaderHeader : public ShaderPart
 				<< "# define texture2D texture" << std::endl;
 			m_part = ss.str();
 		}
+		m_part +=
+			// Return the vector of the standard basis of R^4 with a 1 at position <pos> and 0 otherwise.
+			"  #define STVEC(pos) step(float(pos) - 0.5, vec4(0.0,1.0,2.0,3.0)) - step(float(pos) + 0.5, vec4(0.0,1.0,2.0,3.0)) \n";
+
 	}
 };
 
@@ -531,7 +556,6 @@ class ShaderBlender1 : public ShaderPart
 	{
 #if 1
 			m_part =
-				"  #define STVEC(pos) step(float(pos) - 0.5, vec4(0.0,1.0,2.0,3.0)) - step(float(pos) + 0.5, vec4(0.0,1.0,2.0,3.0)) \n" // Return the vector of the standard basis of R^4 with a 1 at position <pos> and 0 otherwise.
 				"  #define MUXA(pos) dot(muxA, STVEC(pos))				\n"
 				"  #define MUXB(pos) dot(muxB, STVEC(pos))				\n"
 				"  #define MUXPM(pos) muxPM*(STVEC(pos))				\n"
@@ -713,17 +737,87 @@ class ShaderAlphaTest : public ShaderPart
 	}
 };
 
-class ShaderCallDither : public ShaderPart
+class ShaderDithering : public ShaderPart
 {
 public:
-	ShaderCallDither(const opengl::GLInfo & _glinfo)
+	ShaderDithering(const opengl::GLInfo & _glinfo)
 	{
-		if (!_glinfo.isGLES2 && config.generalEmulation.enableNoise != 0) {
+		if (_glinfo.isGLES2)
+			return;
+
+		if (config.generalEmulation.enableDitheringPattern == 0) {
 			m_part =
-				"  if (uColorDitherMode == 2) colorNoiseDither(snoise(), clampedColor.rgb);	\n"
-				"  if (uAlphaDitherMode == 2) alphaNoiseDither(snoise(), clampedColor.a);	\n"
+				"  if (uColorDitherMode == 2) {											\n"
+				"    colorDither(snoiseRGB(), clampedColor.rgb);						\n"
+				"  }																	\n"
+				"  if (uAlphaDitherMode == 2) {											\n"
+				"    alphaDither(snoiseA(), clampedColor.a);							\n"
+				"  }																	\n"
 				;
+			return;
 		}
+
+		m_part +=
+			"  lowp mat4 bayer = mat4( 0.0, 0.75, 0.1875, 0.9375,						\n"
+			"                          0.5, 0.25, 0.6875, 0.4375,						\n"
+			"                          0.125, 0.875, 0.0625, 0.8125,					\n"
+			"                          0.625, 0.375, 0.5625, 0.3125);					\n"
+			"  lowp mat4 mSquare = mat4( 0.0, 0.6875, 0.75, 0.4375,						\n"
+			"                            0.875, 0.3125, 0.125, 0.5625, 					\n"
+			"                            0.1875, 0.5, 0.9375, 0.25,						\n"
+			"                            0.8125, 0.375, 0.0625, 0.625);					\n"
+			// Try to keep dithering visible even at higher resolutions
+			"  lowp float divider = 1.0 + step(3.0, uScreenScale.x);					\n"
+			"  mediump ivec2 position = ivec2(mod((gl_FragCoord.xy - 0.5) / divider,4.0));\n"
+			"  lowp vec4 posX = STVEC(position.x);										\n"
+			"  lowp vec4 posY = STVEC(position.y);										\n"
+			"  lowp float bayerThreshold = dot(bayer*posY, posX);						\n"
+			"  lowp float mSquareThreshold = dot(mSquare*posY, posX);					\n"
+			"  switch (uColorDitherMode) {												\n"
+			"     case 0:																\n"
+			"       colorDither(vec3(mSquareThreshold), clampedColor.rgb);				\n"
+			"     break;																\n"
+			"     case 1:																\n"
+			"       colorDither(vec3(bayerThreshold), clampedColor.rgb);				\n"
+			"       break;																\n"
+			"     case 2:																\n"
+			"       colorDither(snoiseRGB(), clampedColor.rgb);							\n"
+			"       break;																\n"
+			"     case 3:																\n"
+			"       break;																\n"
+			"  }																		\n"
+			"  switch (uAlphaDitherMode) {												\n"
+			"     case 0:																\n"
+			"       switch (uColorDitherMode) {											\n"
+			"         case 0:															\n"
+			"         case 2:															\n"
+			"           alphaDither(mSquareThreshold, clampedColor.a);					\n"
+			"           break;															\n"
+			"         case 1:															\n"
+			"         case 3:															\n"
+			"           alphaDither(bayerThreshold, clampedColor.a);					\n"
+			"           break;															\n"
+			"       }																	\n"
+			"       break;																\n"
+			"     case 1:																\n"
+			"       switch (uColorDitherMode) {											\n"
+			"         case 0:															\n"
+			"         case 2:															\n"
+			"           alphaDither(bayerThreshold, clampedColor.a);					\n"
+			"           break;															\n"
+			"         case 1:															\n"
+			"         case 3:															\n"
+			"           alphaDither(mSquareThreshold, clampedColor.a);					\n"
+			"           break;															\n"
+			"       }																	\n"
+			"       break;																\n"
+			"     case 2:																\n"
+			"       alphaDither(snoiseA(), clampedColor.a);								\n"
+			"       break;																\n"
+			"     case 3:																\n"
+			"       break;																\n"
+			"  }																		\n"
+			;
 	}
 };
 
@@ -801,8 +895,12 @@ class ShaderFragmentGlobalVariablesTex : public ShaderPart
 			;
 		}
 
+		if (!_glinfo.isGLESX || _glinfo.noPerspective)
+			m_part += "noperspective IN lowp vec4 vShadeColor;	\n";
+		else
+			m_part += "IN lowp vec4 vShadeColor;	\n";
+
 		m_part +=
-			"IN lowp vec4 vShadeColor;	\n"
 			"IN highp vec2 vTexCoord0;\n"
 			"IN highp vec2 vTexCoord1;\n"
 			"IN mediump vec2 vLodTexCoord;\n"
@@ -880,10 +978,12 @@ class ShaderFragmentGlobalVariablesNotex : public ShaderPart
 				;
 		}
 
-		m_part +=
-			"IN lowp vec4 vShadeColor;	\n"
-			"IN lowp float vNumLights;	\n"
-			;
+		if (!_glinfo.isGLESX || _glinfo.noPerspective)
+			m_part += "noperspective IN lowp vec4 vShadeColor;	\n";
+		else
+			m_part += "IN lowp vec4 vShadeColor;	\n";
+
+		m_part += "IN lowp float vNumLights;	\n";
 
 		if (config.frameBufferEmulation.N64DepthCompare == Config::dcFast && _glinfo.ext_fetch) {
 			m_part +=
@@ -905,7 +1005,7 @@ class ShaderFragmentHeaderNoise : public ShaderPart
 	ShaderFragmentHeaderNoise(const opengl::GLInfo & _glinfo)
 	{
 		m_part =
-			"lowp float snoise();\n";
+			"lowp float snoise();\n"
 		;
 	}
 };
@@ -993,12 +1093,15 @@ class ShaderFragmentHeaderDither : public ShaderPart
 public:
 	ShaderFragmentHeaderDither(const opengl::GLInfo & _glinfo)
 	{
-		if (!_glinfo.isGLES2 && config.generalEmulation.enableNoise != 0) {
-			m_part =
-				"void colorNoiseDither(in lowp float _noise, inout lowp vec3 _color);\n"
-				"void alphaNoiseDither(in lowp float _noise, inout lowp float _alpha);\n";
+		if (_glinfo.isGLES2)
+			return;
+
+		m_part =
+			"void colorDither(in lowp vec3 _threshold, inout lowp vec3 _color);\n"
+			"void alphaDither(in lowp float _threshold, inout lowp float _alpha);\n"
+			"lowp vec3 snoiseRGB();\n"
+			"lowp float snoiseA();\n"
 			;
-		}
 	}
 };
 
@@ -1569,35 +1672,25 @@ class ShaderNoise : public ShaderPart
 public:
 	ShaderNoise(const opengl::GLInfo & _glinfo)
 	{
-		if (config.generalEmulation.enableNoise == 0) {
-			// Dummy noise
+		if (_glinfo.isGLES2) {
 			m_part =
-				"lowp float snoise()	\n"
-				"{						\n"
-				"  return 0.5;			\n"
-				"}						\n"
+				"uniform sampler2D uTexNoise;							\n"
+				"lowp float snoise()									\n"
+				"{														\n"
+				"  mediump vec2 texSize = vec2(640.0, 580.0);			\n"
+				"  mediump vec2 coord = gl_FragCoord.xy/uScreenScale/texSize;	\n"
+				"  return texture2D(uTexNoise, coord).r;				\n"
+				"}														\n"
 				;
 		} else {
-			if (_glinfo.isGLES2) {
-				m_part =
-					"uniform sampler2D uTexNoise;							\n"
-					"lowp float snoise()									\n"
-					"{														\n"
-					"  mediump vec2 texSize = vec2(640.0, 580.0);			\n"
-					"  mediump vec2 coord = gl_FragCoord.xy/uScreenScale/texSize;	\n"
-					"  return texture2D(uTexNoise, coord).r;				\n"
-					"}														\n"
+			m_part =
+				"uniform sampler2D uTexNoise;							\n"
+				"lowp float snoise()									\n"
+				"{														\n"
+				"  ivec2 coord = ivec2(gl_FragCoord.xy/uScreenScale);	\n"
+				"  return texelFetch(uTexNoise, coord, 0).r;			\n"
+				"}														\n"
 				;
-			} else {
-				m_part =
-					"uniform sampler2D uTexNoise;		\n"
-					"lowp float snoise()									\n"
-					"{														\n"
-					"  ivec2 coord = ivec2(gl_FragCoord.xy/uScreenScale);	\n"
-					"  return texelFetch(uTexNoise, coord, 0).r;			\n"
-					"}														\n"
-					;
-			}
 		}
 	}
 };
@@ -1607,26 +1700,81 @@ class ShaderDither : public ShaderPart
 public:
 	ShaderDither(const opengl::GLInfo & _glinfo)
 	{
-		if (!_glinfo.isGLES2 && config.generalEmulation.enableNoise != 0) {
+		if (_glinfo.isGLES2)
+			return;
+
+		if (config.generalEmulation.enableDitheringQuantization != 0) {
 			m_part =
-				"void colorNoiseDither(in lowp float _noise, inout lowp vec3 _color)	\n"
-				"{															\n"
-				"    mediump vec3 tmpColor = _color*255.0;					\n"
-				"    mediump ivec3 iColor = ivec3(tmpColor);				\n"
-				//"    iColor &= 248;										\n" // does not work with HW lighting enabled (why?!)
-				"    iColor |= ivec3(tmpColor*_noise)&7;					\n"
-				"    _color = vec3(iColor)/255.0;							\n"
-				"}															\n"
-				"void alphaNoiseDither(in lowp float _noise, inout lowp float _alpha)	\n"
-				"{															\n"
-				"    mediump float tmpAlpha = _alpha*255.0;					\n"
-				"    mediump int iAlpha = int(tmpAlpha);					\n"
-				//"    iAlpha &= 248;											\n" // causes issue #518. need further investigation
-				"    iAlpha |= int(tmpAlpha*_noise)&7;						\n"
-				"    _alpha = float(iAlpha)/255.0;							\n"
-				"}															\n"
-			;
+				"void quantizeRGB(inout lowp vec3 _color)				\n"
+				"{														\n"
+				"     _color.rgb = round(_color.rgb * 32.0)/32.0;		\n"
+				"}														\n"
+				"void quantizeA(inout lowp float _alpha)				\n"
+				"{														\n"
+				"     _alpha = round(_alpha * 32.0)/32.0;				\n"
+				"}														\n"
+				;
+		} else {
+			m_part =
+				"void quantizeRGB(inout lowp vec3 _color){}\n"
+				"void quantizeA(inout lowp float _alpha){}\n"
+				;
 		}
+
+		m_part +=
+			"void colorDither(in lowp vec3 _noise, inout lowp vec3 _color)\n"
+			"{															\n"
+			"  mediump vec3 threshold = 7.0 / 255.0 * (_noise - 0.5);	\n"
+			"  _color = clamp(_color + threshold,0.0,1.0);				\n"
+			"  quantizeRGB(_color);										\n"
+			"}															\n"
+			"void alphaDither(in lowp float _noise, inout lowp float _alpha)\n"
+			"{															\n"
+			"  mediump float threshold = 7.0 / 255.0 * (_noise - 0.5);	\n"
+			"  _alpha = clamp(_alpha + threshold,0.0,1.0);				\n"
+			"  quantizeA(_alpha);										\n"
+			"}															\n"
+			"lowp vec3 snoiseRGB()									\n"
+			"{														\n"
+			"  mediump vec2 texSize = vec2(640.0, 580.0);			\n"
+			;
+		if (config.generalEmulation.enableHiresNoiseDithering != 0)
+			// multiplier for higher res noise effect
+			m_part +=
+			"  lowp float mult = 1.0 + step(2.0, uScreenScale.x);	\n";
+		else
+			m_part +=
+			"  lowp float mult = 1.0;								\n";
+		m_part +=
+			"	mediump vec2 coordR = mult * ((gl_FragCoord.xy)/uScreenScale/texSize);\n"
+			"	mediump vec2 coordG = mult * ((gl_FragCoord.xy + vec2( 0.0, texSize.y / 2.0 ))/uScreenScale/texSize);\n"
+			"	mediump vec2 coordB = mult * ((gl_FragCoord.xy + vec2( texSize.x / 2.0,  0.0))/uScreenScale/texSize);\n"
+			// Only red channel of noise texture contains noise.
+			"  lowp float r = texture(uTexNoise,coordR).r;			\n"
+			"  lowp float g = texture(uTexNoise,coordG).r;			\n"
+			"  lowp float b = texture(uTexNoise,coordB).r;			\n"
+			"														\n"
+			"  return vec3(r,g,b);									\n"
+			"}														\n"
+			"lowp float snoiseA()									\n"
+			"{														\n"
+			"  mediump vec2 texSize = vec2(640.0, 580.0);			\n"
+			;
+		if (config.generalEmulation.enableHiresNoiseDithering != 0)
+			// multiplier for higher res noise effect
+			m_part +=
+			"  lowp float mult = 1.0 + step(2.0, uScreenScale.x);	\n";
+		else
+			m_part +=
+			"  lowp float mult = 1.0;								\n";
+		m_part +=
+			"														\n"
+			"	mediump vec2 coord = mult * ((gl_FragCoord.xy)/uScreenScale/texSize);\n"
+			"														\n"
+			// Only red channel of noise texture contains noise.
+			"  return texture(uTexNoise,coord).r;					\n"
+			"}														\n"
+			;
 	}
 };
 
@@ -1649,17 +1797,19 @@ class ShaderWriteDepth : public ShaderPart
 				if ((config.generalEmulation.hacks & hack_RE2) != 0) {
 					m_part =
 						"uniform lowp usampler2D uZlutImage;\n"
-						"highp float writeDepth()						        													\n"
-						"{																									\n"
+						"highp float writeDepth()																		\n"
+						"{																								\n"
 						;
 					if (_glinfo.isGLESX && _glinfo.noPerspective) {
 						m_part +=
 							"  if (uClampMode == 1 && (vZCoord > 1.0)) discard;	\n"
-							"  highp float FragDepth = clamp((vZCoord - uPolygonOffset) * uDepthScale.s + uDepthScale.t, 0.0, 1.0);	\n"
+							"  highp float FragDepth = (uDepthSource != 0) ? uPrimDepth :								\n"
+							"           clamp((vZCoord - uPolygonOffset) * uDepthScale.s + uDepthScale.t, 0.0, 1.0);	\n"
 							;
 					} else {
 						m_part +=
-							"  highp float FragDepth = clamp((gl_FragCoord.z * 2.0 - 1.0) * uDepthScale.s + uDepthScale.t, 0.0, 1.0);	\n"
+							"  highp float FragDepth = (uDepthSource != 0) ? uPrimDepth :								\n"
+							"            clamp((gl_FragCoord.z * 2.0 - 1.0) * uDepthScale.s + uDepthScale.t, 0.0, 1.0);	\n"
 						;
 					}
 					m_part +=
@@ -1726,9 +1876,9 @@ class ShaderMipmap : public ShaderPart
 					"  readtex1 = texture2DLodEXT(uTex1, texCoord1, 0.0);		\n"
 					"														\n"
 					"  mediump float fMaxTile = float(uMaxTile);			\n"
-					"  mediump vec2 dx = abs(dFdx(vLodTexCoord));			\n"
-					"  dx *= uScreenScale;									\n"
-					"  mediump float lod = max(dx.x, dx.y);					\n"
+					"  mediump vec2 dx = abs(dFdx(vLodTexCoord)) * uScreenScale;	\n"
+					"  mediump vec2 dy = abs(dFdy(vLodTexCoord)) * uScreenScale;	\n"
+					"  mediump float lod = max(dx.x + dx.y, dy.x + dy.y);	\n" /*LINEAR*/
 					"  bool magnify = lod < 1.0;							\n"
 					"  mediump float lod_tile = magnify ? 0.0 : floor(log2(floor(lod))); \n"
 					"  bool distant = lod > 128.0 || lod_tile >= fMaxTile;	\n"
@@ -2600,7 +2750,7 @@ CombinerProgramBuilder::CombinerProgramBuilder(const opengl::GLInfo & _glinfo, o
 , m_signExtendColorABD(new ShaderSignExtendColorABD)
 , m_signExtendAlphaABD(new ShaderSignExtendAlphaABD)
 , m_alphaTest(new ShaderAlphaTest)
-, m_callDither(new ShaderCallDither(_glinfo))
+, m_callDither(new ShaderDithering(_glinfo))
 , m_vertexHeader(new VertexShaderHeader(_glinfo))
 , m_vertexEnd(new VertexShaderEnd(_glinfo))
 , m_vertexRect(new VertexShaderRect(_glinfo))
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
index 460ace9d..bfaa1328 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
@@ -708,6 +708,22 @@ class UClampMode : public UniformGroup
 	iUniform uClampMode;
 };
 
+class UClipRatio : public UniformGroup
+{
+public:
+	UClipRatio(GLuint _program) {
+		LocateUniform(uClipRatio);
+	}
+
+	void update(bool _force) override
+	{
+		uClipRatio.set(float(gSP.clipRatio), _force);
+	}
+
+private:
+	fUniform uClipRatio;
+};
+
 class UPolygonOffset : public UniformGroup
 {
 public:
@@ -1042,8 +1058,7 @@ void CombinerProgramUniformFactory::buildUniforms(GLuint _program,
 												  const CombinerKey & _key,
 												  UniformGroups & _uniforms)
 {
-	if (config.generalEmulation.enableNoise != 0)
-		_uniforms.emplace_back(new UNoiseTex(_program));
+	_uniforms.emplace_back(new UNoiseTex(_program));
 
 	if (!m_glInfo.isGLES2) {
 		_uniforms.emplace_back(new UDepthTex(_program));
@@ -1113,6 +1128,8 @@ void CombinerProgramUniformFactory::buildUniforms(GLuint _program,
 		_uniforms.emplace_back(new UPolygonOffset(_program));
 	}
 
+	_uniforms.emplace_back(new UClipRatio(_program));
+
 	_uniforms.emplace_back(new UScreenCoordsScale(_program));
 
 	_uniforms.emplace_back(new UColors(_program));
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h
index 660569e7..10ef119e 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h
@@ -20,7 +20,7 @@ namespace glsl {
 		bool _saveCombinerKeys(const graphics::Combiners & _combiners) const;
 		bool _loadFromCombinerKeys(graphics::Combiners & _combiners);
 
-		const u32 m_formatVersion = 0x2AU;
+		const u32 m_formatVersion = 0x2CU;
 		const u32 m_keysFormatVersion = 0x04;
 		const opengl::GLInfo & m_glinfo;
 		opengl::CachedUseProgram * m_useProgram;
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp
index 38a1faab..63e0a83c 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp
@@ -674,7 +674,7 @@ namespace glsl {
 
 		void activate() override {
 			FXAAShaderBase::activate();
-			FrameBuffer * pBuffer = frameBufferList().findBuffer(*REG.VI_ORIGIN);
+			FrameBuffer * pBuffer = frameBufferList().findBuffer(*REG.VI_ORIGIN & 0xffffff);
 			if (pBuffer != nullptr && pBuffer->m_pTexture != nullptr &&
 				(m_width != pBuffer->m_pTexture->width || m_height != pBuffer->m_pTexture->height)) {
 				m_width = pBuffer->m_pTexture->width;
diff --git a/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.cpp b/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.cpp
index f1c7a97a..e55b1717 100644
--- a/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.cpp
@@ -109,7 +109,7 @@ void BufferedDrawer::_updateRectBuffer(const graphics::Context::DrawRectParamete
 		return;
 	}
 
-	const u32 crc = CRC_Calculate(0xFFFFFFFF, _params.vertices, dataSize);
+	const u64 crc = CRC_Calculate(UINT64_MAX, _params.vertices, dataSize);
 	auto iter = m_rectBufferOffsets.find(crc);
 	if (iter != m_rectBufferOffsets.end()) {
 		buffer.pos = iter->second;
diff --git a/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.h b/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.h
index 073c32be..40576b5c 100644
--- a/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.h
+++ b/GLideN64/src/Graphics/OpenGLContext/opengl_BufferedDrawer.h
@@ -74,7 +74,7 @@ namespace opengl {
 
 		std::vector<Vertex> m_vertices;
 
-		typedef std::unordered_map<u32, u32> BufferOffsets;
+		typedef std::unordered_map<u64, u32> BufferOffsets;
 		BufferOffsets m_rectBufferOffsets;
 
 		static const u32 m_bufMaxSize;
diff --git a/GLideN64/src/GraphicsDrawer.cpp b/GLideN64/src/GraphicsDrawer.cpp
index 3922dafc..47f9e238 100644
--- a/GLideN64/src/GraphicsDrawer.cpp
+++ b/GLideN64/src/GraphicsDrawer.cpp
@@ -236,6 +236,16 @@ float _adjustViewportX(f32 _X0)
 	return (_X0 + halfVP - halfX) * dwnd().getAdjustScale() + halfX - halfVP;
 }
 
+inline
+void _adjustViewportToClipRatio(s32 & x, s32 & y, s32 & width, s32 & height)
+{
+	x -= (gSP.clipRatio - 1) * width / 2;
+	y -= (gSP.clipRatio - 1) * height / 2;
+	width *= gSP.clipRatio;
+	height *= gSP.clipRatio;
+}
+
+
 void GraphicsDrawer::_updateViewport() const
 {
 	DisplayWindow & wnd = DisplayWindow::get();
@@ -246,10 +256,12 @@ void GraphicsDrawer::_updateViewport() const
 		float Xf = gSP.viewport.vscale[0] < 0 ? (gSP.viewport.x + gSP.viewport.vscale[0] * 2.0f) : gSP.viewport.x;
 		if (_needAdjustCoordinate(wnd))
 			Xf = _adjustViewportX(Xf);
-		const s32 X = (s32)(Xf * scaleX);
-		const s32 Y = (s32)(gSP.viewport.y * scaleY);
-		gfxContext.setViewport(X, Y,
-			std::max((s32)(gSP.viewport.width * scaleX), 0), std::max((s32)(gSP.viewport.height * scaleY), 0));
+		s32 X = (s32)(Xf * scaleX);
+		s32 Y = (s32)(gSP.viewport.y * scaleY);
+		s32 WIDTH = std::max((s32)(gSP.viewport.width * scaleX), 0);
+		s32 HEIGHT = std::max((s32)(gSP.viewport.height * scaleY), 0);
+		_adjustViewportToClipRatio(X, Y, WIDTH, HEIGHT);
+		gfxContext.setViewport(X, Y, WIDTH, HEIGHT);
 	} else {
 		const f32 scaleX = pCurrentBuffer->m_scale;
 		const f32 scaleY = pCurrentBuffer->m_scale;
@@ -257,12 +269,14 @@ void GraphicsDrawer::_updateViewport() const
 		Xf += f32(pCurrentBuffer->m_originX);
 		if (_needAdjustCoordinate(wnd))
 			Xf = _adjustViewportX(Xf);
-		const s32 X = roundup(Xf, scaleX);
+		s32 X = roundup(Xf, scaleX);
 		float Yf = gSP.viewport.vscale[1] < 0 ? (gSP.viewport.y + gSP.viewport.vscale[1] * 2.0f) : gSP.viewport.y;
 		Yf += f32(pCurrentBuffer->m_originY);
-		const s32 Y = roundup(Yf, scaleY);
-		gfxContext.setViewport(X, Y,
-			std::max(roundup(gSP.viewport.width, scaleX), 0), std::max(roundup(gSP.viewport.height, scaleY), 0));
+		s32 Y = roundup(Yf, scaleY);
+		s32 WIDTH = std::max(roundup(gSP.viewport.width, scaleX), 0);
+		s32 HEIGHT = std::max(roundup(gSP.viewport.height, scaleY), 0);
+		_adjustViewportToClipRatio(X, Y, WIDTH, HEIGHT);
+		gfxContext.setViewport(X, Y, WIDTH, HEIGHT);
 	}
 	gSP.changed &= ~CHANGED_VIEWPORT;
 }
@@ -286,9 +300,15 @@ void GraphicsDrawer::_updateScreenCoordsViewport(const FrameBuffer * _pBuffer) c
 		viewportScaleX = viewportScaleY = pCurrentBuffer->m_scale;
 		X = roundup(f32(pCurrentBuffer->m_originX), viewportScaleX);
 		Y = roundup(f32(pCurrentBuffer->m_originY), viewportScaleY);
+		if (RSP.LLE) {
+			gSP.viewport.width = f32(bufferWidth);
+			gSP.viewport.height = f32(bufferHeight);
+		}
 	}
-
-	gfxContext.setViewport(X, Y, roundup(f32(bufferWidth), viewportScaleX), roundup(f32(bufferHeight), viewportScaleY));
+	s32 WIDTH = roundup(f32(bufferWidth), viewportScaleX);
+	s32 HEIGHT = roundup(f32(bufferHeight), viewportScaleY);
+	_adjustViewportToClipRatio(X, Y, WIDTH, HEIGHT);
+	gfxContext.setViewport(X, Y, WIDTH, HEIGHT);
 	gSP.changed |= CHANGED_VIEWPORT;
 }
 
@@ -776,17 +796,24 @@ void GraphicsDrawer::drawScreenSpaceTriangle(u32 _numVtx, graphics::DrawModePara
 	if (_numVtx == 0 || !_canDraw())
 		return;
 
+	ValueKeeper<u32> otherMode(gSP.clipRatio, 1U);
+
 	f32 maxY = 0;
 	for (u32 i = 0; i < _numVtx; ++i) {
 		SPVertex & vtx = m_dmaVertices[i];
 		vtx.modify = MODIFY_ALL;
 		maxY = std::max(maxY, vtx.y);
+
+		vtx.clip = 0;
+		if (vtx.x > gSP.viewport.width) vtx.clip |= CLIP_POSX;
+		if (vtx.x < 0) vtx.clip |= CLIP_NEGX;
+		if (vtx.y > gSP.viewport.height) vtx.clip |= CLIP_POSY;
+		if (vtx.y < 0) vtx.clip |= CLIP_NEGY;
 	}
 	m_modifyVertices = MODIFY_ALL;
 
 	gSP.changed &= ~CHANGED_GEOMETRYMODE; // Don't update cull mode
 	_prepareDrawTriangle();
-	gfxContext.enable(enable::CULL_FACE, false);
 
 	Context::DrawTriangleParameters triParams;
 	triParams.mode = _mode;
@@ -798,7 +825,18 @@ void GraphicsDrawer::drawScreenSpaceTriangle(u32 _numVtx, graphics::DrawModePara
 	g_debugger.addTriangles(triParams);
 	m_dmaVerticesNum = 0;
 
-	frameBufferList().setBufferChanged(maxY);
+#ifndef OLD_LLE
+	if (config.frameBufferEmulation.enable != 0) {
+		const f32 maxY = renderTriangles(m_dmaVertices.data(), nullptr, _numVtx);
+		frameBufferList().setBufferChanged(maxY);
+		if (config.frameBufferEmulation.copyDepthToRDRAM == Config::cdSoftwareRender &&
+			gDP.otherMode.depthUpdate != 0) {
+			FrameBuffer * pCurrentDepthBuffer = frameBufferList().findBuffer(gDP.depthImageAddress);
+			if (pCurrentDepthBuffer != nullptr)
+				pCurrentDepthBuffer->setDirty();
+		}
+	}
+#endif
 	gSP.changed |= CHANGED_GEOMETRYMODE;
 }
 
@@ -942,6 +980,7 @@ void GraphicsDrawer::drawLine(int _v0, int _v1, float _width)
 
 void GraphicsDrawer::drawRect(int _ulx, int _uly, int _lrx, int _lry)
 {
+	ValueKeeper<u32> otherMode(gSP.clipRatio, 1U);
 	m_texrectDrawer.draw();
 
 	if (!_canDraw())
@@ -1145,6 +1184,7 @@ void GraphicsDrawer::drawTexturedRect(const TexturedRectParams & _params)
 {
 	gSP.changed &= ~CHANGED_GEOMETRYMODE; // Don't update cull mode
 	m_drawingState = DrawingState::TexRect;
+	ValueKeeper<u32> otherMode(gSP.clipRatio, 1U);
 
 	if (m_texrectDrawer.canContinue()) {
 		CombinerInfo & cmbInfo = CombinerInfo::get();
@@ -1472,6 +1512,8 @@ bool GraphicsDrawer::isRejected(s32 _v0, s32 _v1, s32 _v2) const
 	const f32 ySign = GBI.isNegativeY() ? -1.0f : 1.0f;
 	for (u32 i = 0; i < 3; ++i) {
 		const SPVertex & v = triangles.vertices[verts[i]];
+		if ((v.modify & MODIFY_XY) != 0)
+			continue;
 		const f32 sx = gSP.viewport.vtrans[0] + (v.x / v.w) * gSP.viewport.vscale[0];
 		if (sx < rejectBox.ulx)
 			return true;
diff --git a/GLideN64/src/Neon/CRC_OPT_NEON.cpp b/GLideN64/src/Neon/CRC_OPT_NEON.cpp
index 044100ac..72e6cb6e 100644
--- a/GLideN64/src/Neon/CRC_OPT_NEON.cpp
+++ b/GLideN64/src/Neon/CRC_OPT_NEON.cpp
@@ -1,5 +1,5 @@
 #include "CRC.h"
-#include "xxHash/xxhash.h"
+#include "xxHash/xxh3.h"
 #include <arm_neon.h>
 
 #define CRC32_POLYNOMIAL	 0x04C11DB7
@@ -49,16 +49,10 @@ u32 CRC_Calculate_Strict(u32 crc, const void *buffer, u32 count) {
 #define PRIME32_4	668265263U
 #define PRIME32_5	374761393U
 
-#if defined(_MSC_VER)
-#  define XXH_rotl32(x,r) _rotl(x,r)
-#else
-#  define XXH_rotl32(x, r) ((x << r) | (x >> (32 - r)))
-#endif
-
-u32 ReliableHash32NEON(const void *input, size_t len, u32 seed) {
+u64 ReliableHash32NEON(const void *input, size_t len, u64 seed) {
 	if (((uintptr_t) input & 3) != 0) {
 		// Cannot handle misaligned data. Fall back to XXH32.
-		return XXH32(input, len, seed);
+		return XXH3_64bits_withSeed(input, len, seed);
 	}
 
 	const u8 *p = (const u8 *) input;
@@ -119,11 +113,11 @@ u32 ReliableHash32NEON(const void *input, size_t len, u32 seed) {
 	return h32;
 }
 
-u32 CRC_Calculate(u32 crc, const void *buffer, u32 count) {
+u64 CRC_Calculate(u64 crc, const void *buffer, u32 count) {
 	return ReliableHash32NEON(buffer, count, crc);
 }
 
-u32 CRC_CalculatePalette(u32 crc, const void *buffer, u32 count) {
+u64 CRC_CalculatePalette(u64 crc, const void *buffer, u32 count) {
 	u8 *p = (u8 *) buffer;
 	while (count--) {
 		crc = ReliableHash32NEON(p, 2, crc);
diff --git a/GLideN64/src/NoiseTexture.cpp b/GLideN64/src/NoiseTexture.cpp
index abcade20..ce1b5185 100644
--- a/GLideN64/src/NoiseTexture.cpp
+++ b/GLideN64/src/NoiseTexture.cpp
@@ -74,9 +74,6 @@ void NoiseTexture::_fillTextureData()
 
 void NoiseTexture::init()
 {
-	if (config.generalEmulation.enableNoise == 0)
-		return;
-
 	if (m_texData[0].empty())
 		_fillTextureData();
 
@@ -129,7 +126,7 @@ void NoiseTexture::destroy()
 
 void NoiseTexture::update()
 {
-	if (m_DList == dwnd().getBuffersSwapCount() || config.generalEmulation.enableNoise == 0)
+	if (m_texData[0].empty() || m_DList == dwnd().getBuffersSwapCount())
 		return;
 
 	u32 rand_value(0U);
diff --git a/GLideN64/src/PaletteTexture.cpp b/GLideN64/src/PaletteTexture.cpp
index a61c5b61..372f5659 100644
--- a/GLideN64/src/PaletteTexture.cpp
+++ b/GLideN64/src/PaletteTexture.cpp
@@ -72,6 +72,7 @@ void PaletteTexture::destroy()
 	textureCache().removeFrameBufferTexture(m_pTexture);
 	m_pTexture = nullptr;
 	free(m_pbuf);
+	m_pbuf = nullptr;
 }
 
 void PaletteTexture::update()
diff --git a/GLideN64/src/PaletteTexture.h b/GLideN64/src/PaletteTexture.h
index 5266167f..e8d183c8 100644
--- a/GLideN64/src/PaletteTexture.h
+++ b/GLideN64/src/PaletteTexture.h
@@ -21,7 +21,7 @@ class PaletteTexture
 private:
 	CachedTexture * m_pTexture;
 	u8* m_pbuf;
-	u32 m_paletteCRC256;
+	u64 m_paletteCRC256;
 };
 
 extern PaletteTexture g_paletteTexture;
diff --git a/GLideN64/src/RDP.cpp b/GLideN64/src/RDP.cpp
index 2cc994f2..1e896007 100644
--- a/GLideN64/src/RDP.cpp
+++ b/GLideN64/src/RDP.cpp
@@ -546,6 +546,7 @@ void RDP_Half_1( u32 _c )
 		w0 = RDP.cmd_data[RDP.cmd_cur+0];
 		w1 = RDP.cmd_data[RDP.cmd_cur+1];
 		LLEcmd[RSP.cmd](w0, w1);
+		LLETriangle::get().flush(cmd);
 	} else {
 		DebugMsg(DEBUG_NORMAL | DEBUG_IGNORED, "gDPHalf_1()\n");
 	}
@@ -564,7 +565,7 @@ inline u32 READ_RDP_DATA(u32 address)
 	if (dp_status & 0x1)          // XBUS_DMEM_DMA enabled
 		return rsp_dmem[(address & 0xfff)>>2];
 	else
-		return rdram[address>>2];
+		return rdram[(address & 0xffffff)>>2];
 }
 
 void RDP_ProcessRDPList()
@@ -605,6 +606,7 @@ void RDP_ProcessRDPList()
 		RDP.w2 = RDP.cmd_data[RDP.cmd_cur + 2];
 		RDP.w3 = RDP.cmd_data[RDP.cmd_cur + 3];
 		RSP.cmd = cmd;
+		LLETriangle::get().flush(cmd);
 		LLEcmd[cmd](RDP.w0, RDP.w1);
 
 		RDP.cmd_cur = (RDP.cmd_cur + CmdLength[cmd] / 4) & maxCMDMask;
@@ -615,7 +617,6 @@ void RDP_ProcessRDPList()
 		RDP.cmd_cur = 0;
 	}
 
-	RSP.LLE = false;
 	gDP.changed |= CHANGED_COLORBUFFER;
 	gDP.changed &= ~CHANGED_CPU_FB_WRITE;
 
diff --git a/GLideN64/src/RSP.cpp b/GLideN64/src/RSP.cpp
index 0ffca3fd..2c53c76a 100644
--- a/GLideN64/src/RSP.cpp
+++ b/GLideN64/src/RSP.cpp
@@ -109,6 +109,8 @@ void RSP_CheckDLCounter()
 
 void RSP_ProcessDList()
 {
+	RSP.LLE = false;
+
 	if (ConfigOpen || dwnd().isResizeWindow()) {
 		*REG.MI_INTR |= MI_INTR_DP;
 		CheckInterrupts();
@@ -223,7 +225,7 @@ void RSP_SetDefaultState()
 	gSP.matrix.modelView[0][2][2] = 1.0f;
 	gSP.matrix.modelView[0][3][3] = 1.0f;
 
-	gSP.clipRatio = 2U;
+	gSP.clipRatio = 1U;
 
 	gDP.otherMode._u64 = 0U;
 	gDP.otherMode.bi_lerp0 = gDP.otherMode.bi_lerp1 = 1;
diff --git a/GLideN64/src/SoftwareRender.cpp b/GLideN64/src/SoftwareRender.cpp
index 1b63ccfe..67177760 100644
--- a/GLideN64/src/SoftwareRender.cpp
+++ b/GLideN64/src/SoftwareRender.cpp
@@ -3,6 +3,7 @@
 #include "DepthBufferRender/ClipPolygon.h"
 #include "DepthBufferRender/DepthBufferRender.h"
 #include "gSP.h"
+#include "RSP.h"
 #include "SoftwareRender.h"
 #include "DepthBuffer.h"
 #include "Config.h"
@@ -54,6 +55,8 @@ bool calcScreenCoordinates(SPVertex * _vsrc, vertexclip * _vclip, u32 _numVertex
 	const float y2 = _vclip[2].y - _vclip[1].y;
 
 	_clockwise = (x1*y2 - y1*x2) >= 0.0f;
+	if (RSP.LLE)
+		return true;
 
 	const u32 cullMode = (gSP.geometryMode & G_CULL_BOTH);
 
diff --git a/GLideN64/src/Textures.cpp b/GLideN64/src/Textures.cpp
index b9033cea..70401982 100644
--- a/GLideN64/src/Textures.cpp
+++ b/GLideN64/src/Textures.cpp
@@ -527,15 +527,15 @@ void TextureCache::_checkCacheSize()
 	}
 }
 
-CachedTexture * TextureCache::_addTexture(u32 _crc32)
+CachedTexture * TextureCache::_addTexture(u64 _crc64)
 {
 	if (m_curUnpackAlignment == 0)
 		m_curUnpackAlignment = gfxContext.getTextureUnpackAlignment();
 	_checkCacheSize();
 	m_textures.emplace_front(gfxContext.createTexture(textureTarget::TEXTURE_2D));
 	Textures::iterator new_iter = m_textures.begin();
-	new_iter->crc = _crc32;
-	m_lruTextureLocations.insert(std::pair<u32, Textures::iterator>(_crc32, new_iter));
+	new_iter->crc = _crc64;
+	m_lruTextureLocations.insert(std::pair<u64, Textures::iterator>(_crc64, new_iter));
 	return &(*new_iter);
 }
 
@@ -1243,7 +1243,7 @@ struct TextureParams
 };
 
 static
-u32 _calculateCRC(u32 _t, const TextureParams & _params, u32 _bytes)
+u64 _calculateCRC(u32 _t, const TextureParams & _params, u32 _bytes)
 {
 	const bool rgba32 = gSP.textureTile[_t]->size == G_IM_SIZ_32b;
 	if (_bytes == 0) {
@@ -1254,7 +1254,7 @@ u32 _calculateCRC(u32 _t, const TextureParams & _params, u32 _bytes)
 		_bytes >>= 1;
 	const u32 tMemMask = (gDP.otherMode.textureLUT == G_TT_NONE && !rgba32) ? 0x1FF : 0xFF;
 	const u64 *src = (u64*)&TMEM[gSP.textureTile[_t]->tmem & tMemMask];
-	u32 crc = 0xFFFFFFFF;
+	u64 crc = UINT64_MAX;
 	crc = CRC_Calculate(crc, src, _bytes);
 
 	if (rgba32) {
@@ -1264,9 +1264,9 @@ u32 _calculateCRC(u32 _t, const TextureParams & _params, u32 _bytes)
 
 	if (gDP.otherMode.textureLUT != G_TT_NONE || gSP.textureTile[_t]->format == G_IM_FMT_CI) {
 		if (gSP.textureTile[_t]->size == G_IM_SIZ_4b)
-			crc = CRC_Calculate( crc, &gDP.paletteCRC16[gSP.textureTile[_t]->palette], 4 );
+			crc = CRC_Calculate( crc, &gDP.paletteCRC16[gSP.textureTile[_t]->palette], sizeof(u64) );
 		else if (gSP.textureTile[_t]->size == G_IM_SIZ_8b)
-			crc = CRC_Calculate( crc, &gDP.paletteCRC256, 4 );
+			crc = CRC_Calculate( crc, &gDP.paletteCRC256, sizeof(u64) );
 	}
 
 	if (config.generalEmulation.enableLOD != 0 && gSP.texture.level > 1 && _t > 0)
@@ -1352,15 +1352,15 @@ void TextureCache::activateMSDummy(u32 _t)
 void TextureCache::_updateBackground()
 {
 	u32 numBytes = gSP.bgImage.width * gSP.bgImage.height << gSP.bgImage.size >> 1;
-	u32 crc;
+	u64 crc;
 
-	crc = CRC_Calculate( 0xFFFFFFFF, &RDRAM[gSP.bgImage.address], numBytes );
+	crc = CRC_Calculate( UINT64_MAX, &RDRAM[gSP.bgImage.address], numBytes );
 
 	if (gDP.otherMode.textureLUT != G_TT_NONE || gSP.bgImage.format == G_IM_FMT_CI) {
 		if (gSP.bgImage.size == G_IM_SIZ_4b)
-			crc = CRC_Calculate( crc, &gDP.paletteCRC16[gSP.bgImage.palette], 4 );
+			crc = CRC_Calculate( crc, &gDP.paletteCRC16[gSP.bgImage.palette], sizeof(u64) );
 		else if (gSP.bgImage.size == G_IM_SIZ_8b)
-			crc = CRC_Calculate( crc, &gDP.paletteCRC256, 4 );
+			crc = CRC_Calculate( crc, &gDP.paletteCRC256, sizeof(u64) );
 	}
 
 	u32 params[4] = {gSP.bgImage.width, gSP.bgImage.height, gSP.bgImage.format, gSP.bgImage.size};
@@ -1502,7 +1502,7 @@ void TextureCache::update(u32 _t)
 	params.width = sizes.width;
 	params.height = sizes.height;
 
-	const u32 crc = _calculateCRC(_t, params, sizes.bytes);
+	const u64 crc = _calculateCRC(_t, params, sizes.bytes);
 
 	if (current[_t] != nullptr && current[_t]->crc == crc) {
 		activateTexture(_t, current[_t]);
diff --git a/GLideN64/src/Textures.h b/GLideN64/src/Textures.h
index c85f5dfe..db866158 100644
--- a/GLideN64/src/Textures.h
+++ b/GLideN64/src/Textures.h
@@ -18,7 +18,7 @@ struct CachedTexture
 	CachedTexture(graphics::ObjectHandle _name) : name(_name), max_level(0), frameBufferTexture(fbNone), bHDTexture(false) {}
 
 	graphics::ObjectHandle name;
-	u32		crc = 0;
+	u64		crc = 0;
 //	float	fulS, fulT;
 //	WORD	ulS, ulT, lrS, lrT;
 	float	offsetS, offsetT;
@@ -78,7 +78,7 @@ struct TextureCache
 	TextureCache(const TextureCache &) = delete;
 
 	void _checkCacheSize();
-	CachedTexture * _addTexture(u32 _crc32);
+	CachedTexture * _addTexture(u64 _crc64);
 	void _load(u32 _tile, CachedTexture *_pTexture);
 	bool _loadHiresTexture(u32 _tile, CachedTexture *_pTexture, u64 & _ricecrc);
 	void _loadBackground(CachedTexture *pTexture);
@@ -90,7 +90,7 @@ struct TextureCache
 	void _getTextureDestData(CachedTexture& tmptex, u32* pDest, graphics::Parameter glInternalFormat, GetTexelFunc GetTexel, u16* pLine);
 
 	typedef std::list<CachedTexture> Textures;
-	typedef std::unordered_map<u32, Textures::iterator> Texture_Locations;
+	typedef std::unordered_map<u64, Textures::iterator> Texture_Locations;
 	typedef std::unordered_map<u32, CachedTexture> FBTextures;
 	Textures m_textures;
 	Texture_Locations m_lruTextureLocations;
diff --git a/GLideN64/src/VI.cpp b/GLideN64/src/VI.cpp
index b92514b1..92ebaadd 100644
--- a/GLideN64/src/VI.cpp
+++ b/GLideN64/src/VI.cpp
@@ -82,7 +82,7 @@ void VI_UpdateSize()
 //	const int fsaa = ((*REG.VI_STATUS) >> 8) & 3;
 //	const int divot = ((*REG.VI_STATUS) >> 4) & 1;
 	FrameBufferList & fbList = frameBufferList();
-	FrameBuffer * pBuffer = fbList.findBuffer(VI.lastOrigin);
+	FrameBuffer * pBuffer = fbList.findBuffer(VI.lastOrigin & 0xffffff);
 	DepthBuffer * pDepthBuffer = pBuffer != nullptr ? pBuffer->m_pDepthBuffer : nullptr;
 	if (config.frameBufferEmulation.enable &&
 		((interlacedPrev != VI.interlaced) ||
@@ -131,7 +131,7 @@ void VI_UpdateScreen()
 
 	if (config.frameBufferEmulation.enable) {
 
-		FrameBuffer * pBuffer = frameBufferList().findBuffer(*REG.VI_ORIGIN);
+		FrameBuffer * pBuffer = frameBufferList().findBuffer(*REG.VI_ORIGIN & 0xffffff);
 		if (pBuffer == nullptr) {
 			gDP.changed |= CHANGED_CPU_FB_WRITE;
 		} else if (!FBInfo::fbInfo.isSupported() &&
@@ -166,7 +166,7 @@ void VI_UpdateScreen()
 					}
 					const u32 size = *REG.VI_STATUS & 3;
 					if (VI.height > 0 && size > G_IM_SIZ_8b  && VI.width > 0)
-						frameBufferList().saveBuffer(*REG.VI_ORIGIN, G_IM_FMT_RGBA, size, VI.width, true);
+						frameBufferList().saveBuffer(*REG.VI_ORIGIN & 0xffffff, G_IM_FMT_RGBA, size, VI.width, true);
 				}
 			}
 //			if ((((*REG.VI_STATUS) & 3) > 0) && (gDP.colorImage.changed || bCFB)) { // Does not work in release build!!!
@@ -175,12 +175,12 @@ void VI_UpdateScreen()
 					VI_UpdateSize();
 					bVIUpdated = true;
 				}
-				FrameBuffer_CopyFromRDRAM(*REG.VI_ORIGIN, bCFB);
+				FrameBuffer_CopyFromRDRAM(*REG.VI_ORIGIN & 0xffffff, bCFB);
 			}
 			frameBufferList().renderBuffer();
 			frameBufferList().clearBuffersChanged();
 			VI.lastOrigin = *REG.VI_ORIGIN;
-		} 
+		}
 	} else {
 		if (gDP.changed & CHANGED_COLORBUFFER) {
 			frameBufferList().renderBuffer();
diff --git a/GLideN64/src/gDP.cpp b/GLideN64/src/gDP.cpp
index 866a7acb..fb85bc72 100644
--- a/GLideN64/src/gDP.cpp
+++ b/GLideN64/src/gDP.cpp
@@ -27,6 +27,9 @@ using namespace std;
 
 gDPInfo gDP;
 
+// angrylion's macro
+#define SIGN(x, numb)	(((x) & ((1 << numb) - 1)) | -((x) & (1 << (numb - 1))))
+
 bool isCurrentColorImageDepthImage()
 {
 	return (gDP.colorImage.address == gDP.depthImageAddress) ||
@@ -708,11 +711,11 @@ void gDPLoadTLUT( u32 tile, u32 uls, u32 ult, u32 lrs, u32 lrt )
 			destIdx += 4;
 		}
 
-		gDP.paletteCRC16[pal] = CRC_CalculatePalette(0xFFFFFFFF, &TMEM[256 + (pal << 4)], 16);
+		gDP.paletteCRC16[pal] = CRC_CalculatePalette(UINT64_MAX, &TMEM[256 + (pal << 4)], 16);
 		pal = (pal + 1) & 0x0F;
 	}
 
-	gDP.paletteCRC256 = CRC_Calculate(0xFFFFFFFF, gDP.paletteCRC16, 64);
+	gDP.paletteCRC256 = CRC_Calculate(UINT64_MAX, gDP.paletteCRC16, sizeof(u64) * 16);
 
 	if (TFH.isInited()) {
 		const u16 start = gDP.tiles[tile].tmem - 256; // starting location in the palettes
@@ -811,9 +814,6 @@ void gDPFillRectangle( s32 ulx, s32 uly, s32 lrx, s32 lry )
 
 void gDPSetConvert( s32 k0, s32 k1, s32 k2, s32 k3, s32 k4, s32 k5 )
 {
-// angrylion's macro
-#define SIGN(x, numb)	(((x) & ((1 << numb) - 1)) | -((x) & (1 << (numb - 1))))
-
 	gDP.convert.k0 = (SIGN(k0, 9) << 1) + 1;
 	gDP.convert.k1 = (SIGN(k1, 9) << 1) + 1;
 	gDP.convert.k2 = (SIGN(k2, 9) << 1) + 1;
@@ -949,6 +949,8 @@ void gDPNoOp()
  *    based on sources of ziggy's z64      *
  *******************************************/
 
+#ifdef OLD_LLE
+
 void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u32 * _pRdpCmd)
 {
 	gSP.texture.level = _SHIFTR(_w1, 19, 3);
@@ -992,7 +994,7 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 
 	yl = (_w1 & 0x3fff);
 	ym = ((_w2 >> 16) & 0x3fff);
-	yh = ((_w2 >>  0) & 0x3fff);
+	yh = ((_w2 >> 0) & 0x3fff);
 	xl = (s32)(w3);
 	xh = (s32)(w5);
 	xm = (s32)(w7);
@@ -1000,42 +1002,42 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 	dxhdy = (s32)(w6);
 	dxmdy = (s32)(w8);
 
-	if (yl & (0x800<<2)) yl |= 0xfffff000<<2;
-	if (ym & (0x800<<2)) ym |= 0xfffff000<<2;
-	if (yh & (0x800<<2)) yh |= 0xfffff000<<2;
+	if (yl & (0x800 << 2)) yl |= 0xfffff000 << 2;
+	if (ym & (0x800 << 2)) ym |= 0xfffff000 << 2;
+	if (yh & (0x800 << 2)) yh |= 0xfffff000 << 2;
 
 	yh &= ~3;
 
 	r = 0xff; g = 0xff; b = 0xff; a = 0xff; z = 0xffff0000; s = 0;  t = 0;  w = 0x30000;
 
 	if (_shade != 0) {
-		r    = (shade_base[0] & 0xffff0000) | ((shade_base[+4 ] >> 16) & 0x0000ffff);
-		g    = ((shade_base[0 ] << 16) & 0xffff0000) | (shade_base[4 ] & 0x0000ffff);
-		b    = (shade_base[1 ] & 0xffff0000) | ((shade_base[5 ] >> 16) & 0x0000ffff);
-		a    = ((shade_base[1 ] << 16) & 0xffff0000) | (shade_base[5 ] & 0x0000ffff);
-		drdx = (shade_base[2 ] & 0xffff0000) | ((shade_base[6 ] >> 16) & 0x0000ffff);
-		dgdx = ((shade_base[2 ] << 16) & 0xffff0000) | (shade_base[6 ] & 0x0000ffff);
-		dbdx = (shade_base[3 ] & 0xffff0000) | ((shade_base[7 ] >> 16) & 0x0000ffff);
-		dadx = ((shade_base[3 ] << 16) & 0xffff0000) | (shade_base[7 ] & 0x0000ffff);
-		drde = (shade_base[8 ] & 0xffff0000) | ((shade_base[12] >> 16) & 0x0000ffff);
-		dgde = ((shade_base[8 ] << 16) & 0xffff0000) | (shade_base[12] & 0x0000ffff);
-		dbde = (shade_base[9 ] & 0xffff0000) | ((shade_base[13] >> 16) & 0x0000ffff);
-		dade = ((shade_base[9 ] << 16) & 0xffff0000) | (shade_base[13] & 0x0000ffff);
+		r = (shade_base[0] & 0xffff0000) | ((shade_base[+4] >> 16) & 0x0000ffff);
+		g = ((shade_base[0] << 16) & 0xffff0000) | (shade_base[4] & 0x0000ffff);
+		b = (shade_base[1] & 0xffff0000) | ((shade_base[5] >> 16) & 0x0000ffff);
+		a = ((shade_base[1] << 16) & 0xffff0000) | (shade_base[5] & 0x0000ffff);
+		drdx = (shade_base[2] & 0xffff0000) | ((shade_base[6] >> 16) & 0x0000ffff);
+		dgdx = ((shade_base[2] << 16) & 0xffff0000) | (shade_base[6] & 0x0000ffff);
+		dbdx = (shade_base[3] & 0xffff0000) | ((shade_base[7] >> 16) & 0x0000ffff);
+		dadx = ((shade_base[3] << 16) & 0xffff0000) | (shade_base[7] & 0x0000ffff);
+		drde = (shade_base[8] & 0xffff0000) | ((shade_base[12] >> 16) & 0x0000ffff);
+		dgde = ((shade_base[8] << 16) & 0xffff0000) | (shade_base[12] & 0x0000ffff);
+		dbde = (shade_base[9] & 0xffff0000) | ((shade_base[13] >> 16) & 0x0000ffff);
+		dade = ((shade_base[9] << 16) & 0xffff0000) | (shade_base[13] & 0x0000ffff);
 	}
 	if (_texture != 0) {
-		s    = (texture_base[0 ] & 0xffff0000) | ((texture_base[4 ] >> 16) & 0x0000ffff);
-		t    = ((texture_base[0 ] << 16) & 0xffff0000)      | (texture_base[4 ] & 0x0000ffff);
-		w    = (texture_base[1 ] & 0xffff0000) | ((texture_base[5 ] >> 16) & 0x0000ffff);
+		s = (texture_base[0] & 0xffff0000) | ((texture_base[4] >> 16) & 0x0000ffff);
+		t = ((texture_base[0] << 16) & 0xffff0000) | (texture_base[4] & 0x0000ffff);
+		w = (texture_base[1] & 0xffff0000) | ((texture_base[5] >> 16) & 0x0000ffff);
 		//    w = abs(w);
-		dsdx = (texture_base[2 ] & 0xffff0000) | ((texture_base[6 ] >> 16) & 0x0000ffff);
-		dtdx = ((texture_base[2 ] << 16) & 0xffff0000)      | (texture_base[6 ] & 0x0000ffff);
-		dwdx = (texture_base[3 ] & 0xffff0000) | ((texture_base[7 ] >> 16) & 0x0000ffff);
-		dsde = (texture_base[8 ] & 0xffff0000) | ((texture_base[12] >> 16) & 0x0000ffff);
-		dtde = ((texture_base[8 ] << 16) & 0xffff0000)      | (texture_base[12] & 0x0000ffff);
-		dwde = (texture_base[9 ] & 0xffff0000) | ((texture_base[13] >> 16) & 0x0000ffff);
+		dsdx = (texture_base[2] & 0xffff0000) | ((texture_base[6] >> 16) & 0x0000ffff);
+		dtdx = ((texture_base[2] << 16) & 0xffff0000) | (texture_base[6] & 0x0000ffff);
+		dwdx = (texture_base[3] & 0xffff0000) | ((texture_base[7] >> 16) & 0x0000ffff);
+		dsde = (texture_base[8] & 0xffff0000) | ((texture_base[12] >> 16) & 0x0000ffff);
+		dtde = ((texture_base[8] << 16) & 0xffff0000) | (texture_base[12] & 0x0000ffff);
+		dwde = (texture_base[9] & 0xffff0000) | ((texture_base[13] >> 16) & 0x0000ffff);
 	}
 	if (_zbuffer != 0) {
-		z    = zbuffer_base[0];
+		z = zbuffer_base[0];
 		dzdx = zbuffer_base[1];
 		dzde = zbuffer_base[2];
 	}
@@ -1068,8 +1070,8 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 	xright_inc = dxhdy;
 
 	while (yh<ym &&
-		!((!flip && xleft < xright+0x10000) ||
-		 (flip && xleft > xright-0x10000))) {
+		!((!flip && xleft < xright + 0x10000) ||
+		(flip && xleft > xright - 0x10000))) {
 		xleft += xleft_inc;
 		xright += xright_inc;
 		s += dsde;    t += dtde;    w += dwde;
@@ -1078,25 +1080,25 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 		yh++;
 	}
 
-	j = ym-yh;
+	j = ym - yh;
 	if (j > 0) {
-		int dx = (xleft-xright)>>16;
+		int dx = (xleft - xright) >> 16;
 		if ((!flip && xleft < xright) || (flip/* && xleft > xright*/))
 		{
 			if (_shade != 0) {
-				vtx->r = CSCALE(r+drdx*dx);
-				vtx->g = CSCALE(g+dgdx*dx);
-				vtx->b = CSCALE(b+dbdx*dx);
-				vtx->a = CSCALE(a+dadx*dx);
+				vtx->r = CSCALE(r + drdx*dx);
+				vtx->g = CSCALE(g + dgdx*dx);
+				vtx->b = CSCALE(b + dbdx*dx);
+				vtx->a = CSCALE(a + dadx*dx);
 			}
 			if (_texture != 0) {
-				vtx->s = SSCALE(s+dsdx*dx, w+dwdx*dx);
-				vtx->t = TSCALE(t+dtdx*dx, w+dwdx*dx);
+				vtx->s = SSCALE(s + dsdx*dx, w + dwdx*dx);
+				vtx->t = TSCALE(t + dtdx*dx, w + dwdx*dx);
 			}
 			vtx->x = XSCALE(xleft);
 			vtx->y = YSCALE(yh);
-			vtx->z = ZSCALE(z+dzdx*dx);
-			vtx->w = WSCALE(w+dwdx*dx);
+			vtx->z = ZSCALE(z + dzdx*dx);
+			vtx->w = WSCALE(w + dwdx*dx);
 			++vtx;
 		}
 		if ((!flip/* && xleft < xright*/) || (/*flip &&*/ xleft > xright))
@@ -1120,7 +1122,7 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 		xleft += xleft_inc*j;  xright += xright_inc*j;
 		s += dsde*j;  t += dtde*j;
 		if (w + dwde*j != 0) w += dwde*j;
-		else w += dwde*(j-1);
+		else w += dwde*(j - 1);
 		r += drde*j;  g += dgde*j;  b += dbde*j;  a += dade*j;
 		z += dzde*j;
 		// render ...
@@ -1131,28 +1133,28 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 
 	//if (yl-ym > 0)
 	{
-		int dx = (xleft-xright)>>16;
+		int dx = (xleft - xright) >> 16;
 		if ((!flip && xleft <= xright) ||
-				(flip/* && xleft >= xright*/))
+			(flip/* && xleft >= xright*/))
 		{
 			if (_shade != 0) {
-				vtx->r = CSCALE(r+drdx*dx);
-				vtx->g = CSCALE(g+dgdx*dx);
-				vtx->b = CSCALE(b+dbdx*dx);
-				vtx->a = CSCALE(a+dadx*dx);
+				vtx->r = CSCALE(r + drdx*dx);
+				vtx->g = CSCALE(g + dgdx*dx);
+				vtx->b = CSCALE(b + dbdx*dx);
+				vtx->a = CSCALE(a + dadx*dx);
 			}
 			if (_texture != 0) {
-				vtx->s = SSCALE(s+dsdx*dx, w+dwdx*dx);
-				vtx->t = TSCALE(t+dtdx*dx, w+dwdx*dx);
+				vtx->s = SSCALE(s + dsdx*dx, w + dwdx*dx);
+				vtx->t = TSCALE(t + dtdx*dx, w + dwdx*dx);
 			}
 			vtx->x = XSCALE(xleft);
 			vtx->y = YSCALE(ym);
-			vtx->z = ZSCALE(z+dzdx*dx);
-			vtx->w = WSCALE(w+dwdx*dx);
+			vtx->z = ZSCALE(z + dzdx*dx);
+			vtx->w = WSCALE(w + dwdx*dx);
 			++vtx;
 		}
 		if ((!flip/* && xleft <= xright*/) ||
-				(/*flip && */xleft >= xright))
+			(/*flip && */xleft >= xright))
 		{
 			if (_shade != 0) {
 				vtx->r = CSCALE(r);
@@ -1174,7 +1176,7 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 	xleft_inc = dxldy;
 	xright_inc = dxhdy;
 
-	j = yl-ym;
+	j = yl - ym;
 	//j--; // ?
 	xleft += xleft_inc*j;  xright += xright_inc*j;
 	s += dsde*j;  t += dtde*j;  w += dwde*j;
@@ -1182,8 +1184,8 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 	z += dzde*j;
 
 	while (yl>ym &&
-		   !((!flip && xleft < xright+0x10000) ||
-			 (flip && xleft > xright-0x10000))) {
+		!((!flip && xleft < xright + 0x10000) ||
+		(flip && xleft > xright - 0x10000))) {
 		xleft -= xleft_inc;    xright -= xright_inc;
 		s -= dsde;    t -= dtde;    w -= dwde;
 		r -= drde;    g -= dgde;    b -= dbde;    a -= dade;
@@ -1194,28 +1196,28 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 
 	// render ...
 	if (j >= 0) {
-		int dx = (xleft-xright)>>16;
+		int dx = (xleft - xright) >> 16;
 		if ((!flip && xleft <= xright) ||
-				(flip/* && xleft >= xright*/))
+			(flip/* && xleft >= xright*/))
 		{
 			if (_shade != 0) {
-				vtx->r = CSCALE(r+drdx*dx);
-				vtx->g = CSCALE(g+dgdx*dx);
-				vtx->b = CSCALE(b+dbdx*dx);
-				vtx->a = CSCALE(a+dadx*dx);
+				vtx->r = CSCALE(r + drdx*dx);
+				vtx->g = CSCALE(g + dgdx*dx);
+				vtx->b = CSCALE(b + dbdx*dx);
+				vtx->a = CSCALE(a + dadx*dx);
 			}
 			if (_texture != 0) {
-				vtx->s = SSCALE(s+dsdx*dx, w+dwdx*dx);
-				vtx->t = TSCALE(t+dtdx*dx, w+dwdx*dx);
+				vtx->s = SSCALE(s + dsdx*dx, w + dwdx*dx);
+				vtx->t = TSCALE(t + dtdx*dx, w + dwdx*dx);
 			}
 			vtx->x = XSCALE(xleft);
 			vtx->y = YSCALE(yl);
-			vtx->z = ZSCALE(z+dzdx*dx);
-			vtx->w = WSCALE(w+dwdx*dx);
+			vtx->z = ZSCALE(z + dzdx*dx);
+			vtx->w = WSCALE(w + dwdx*dx);
 			++vtx;
 		}
 		if ((!flip/* && xleft <= xright*/) ||
-				(/*flip &&*/ xleft >= xright))
+			(/*flip &&*/ xleft >= xright))
 		{
 			if (_shade != 0) {
 				vtx->r = CSCALE(r);
@@ -1244,59 +1246,537 @@ void gDPLLETriangle(u32 _w1, u32 _w2, int _shade, int _texture, int _zbuffer, u3
 	gSP.textureTile[0] = textureTileOrg[0];
 	gSP.textureTile[1] = textureTileOrg[1];
 
-	DebugMsg( DEBUG_NORMAL, "gDPLLETriangle(%08x, %08x) shade: %d, texture: %d, zbuffer: %d\n",
-			  _w1, _w2, _shade, _texture, _zbuffer);
+	DebugMsg(DEBUG_NORMAL, "gDPLLETriangle(%08x, %08x) shade: %d, texture: %d, zbuffer: %d\n",
+		_w1, _w2, _shade, _texture, _zbuffer);
+}
+
+#endif // OLD_LLE
+
+LLETriangle::LLETriangle()
+{
+	m_textureTileOrg[0] = gSP.textureTile[0];
+	m_textureTileOrg[1] = gSP.textureTile[1];
+	m_textureScaleOrg[0] = m_textureScaleOrg[1] = 1.0f;
+}
+
+LLETriangle& LLETriangle::get()
+{
+	static LLETriangle lleTriangle;
+	return lleTriangle;
+}
+
+void LLETriangle::start(u32 _tile)
+{
+	if (!m_flushed)
+		return;
+	m_textureTileOrg[0] = gSP.textureTile[0];
+	m_textureTileOrg[1] = gSP.textureTile[1];
+	m_textureScaleOrg[0] = gSP.texture.scales;
+	m_textureScaleOrg[1] = gSP.texture.scalet;
+	gSP.texture.tile = _tile;
+	gSP.textureTile[0] = &gDP.tiles[_tile];
+	gSP.textureTile[1] = needReplaceTex1ByTex0() ? &gDP.tiles[_tile] : &gDP.tiles[(_tile + 1) & 7];
+	gSP.texture.scales = 1.0f;
+	gSP.texture.scalet = 1.0f;
+	m_flushed = false;
+}
+
+void LLETriangle::flush(u32 _cmd)
+{
+#ifndef OLD_LLE
+	if (_cmd >= 0x08 && _cmd <= 0x0f)
+		return;
+	
+	GraphicsDrawer & drawer = dwnd().getDrawer();
+	if (drawer.getDMAVerticesCount() > 0) {
+		drawer.drawScreenSpaceTriangle(drawer.getDMAVerticesCount(), graphics::drawmode::TRIANGLES);
+	}
+	gSP.textureTile[0] = m_textureTileOrg[0];
+	gSP.textureTile[1] = m_textureTileOrg[1];
+	gSP.texture.scales = m_textureScaleOrg[0];
+	gSP.texture.scalet = m_textureScaleOrg[1];
+	m_flushed = true;
+#endif
 }
 
+void LLETriangle::draw(bool _shade, bool _texture, bool _zbuffer, s32 * _pData) 
+{
+	DebugMsg(DEBUG_NORMAL, "gDPLLETriangle shade: %d, texture: %d, zbuffer: %d\n",
+		int(_shade), int(_texture), int(_zbuffer));
+
+	gSP.texture.level = _SHIFTR(_pData[0], 19, 3);
+	const u32 tile = _SHIFTR(_pData[0], 16, 3);
+	if (tile != m_tile)
+		flush(0);
+	m_tile = tile;
+	const int flip = (_pData[0] & 0x800000) >> 23;
+	start(tile);
+
+	int yl = SIGN(_pData[0], 14);
+	int ym = _pData[1] >> 16;
+	ym = SIGN(ym, 14);
+	int yh = SIGN(_pData[1], 14);
+
+	int xl = SIGN(_pData[2], 28);
+	int xh = SIGN(_pData[4], 28);
+	int xm = SIGN(_pData[6], 28);
+
+	const int dxldy = SIGN(_pData[3], 30);
+	const int dxhdy = SIGN(_pData[5], 30);
+	const int dxmdy = SIGN(_pData[7], 30);
+
+	yh &= ~3;
+
+	int r = 0xff, g = 0xff, b = 0xff, a = 0xff;
+	int drdx = 0, dgdx = 0, dbdx = 0, dadx = 0;
+	int drde = 0, dgde = 0, dbde = 0, dade = 0;
+
+	if (_shade) {
+		r = (_pData[8] & 0xffff0000) | ((_pData[12] >> 16) & 0x0000ffff);
+		g = ((_pData[8] << 16) & 0xffff0000) | (_pData[12] & 0x0000ffff);
+		b = (_pData[9] & 0xffff0000) | ((_pData[13] >> 16) & 0x0000ffff);
+		a = ((_pData[9] << 16) & 0xffff0000) | (_pData[13] & 0x0000ffff);
+		drdx = (_pData[10] & 0xffff0000) | ((_pData[14] >> 16) & 0x0000ffff);
+		dgdx = ((_pData[10] << 16) & 0xffff0000) | (_pData[14] & 0x0000ffff);
+		dbdx = (_pData[11] & 0xffff0000) | ((_pData[15] >> 16) & 0x0000ffff);
+		dadx = ((_pData[11] << 16) & 0xffff0000) | (_pData[15] & 0x0000ffff);
+		drde = (_pData[16] & 0xffff0000) | ((_pData[20] >> 16) & 0x0000ffff);
+		dgde = ((_pData[16] << 16) & 0xffff0000) | (_pData[20] & 0x0000ffff);
+		dbde = (_pData[17] & 0xffff0000) | ((_pData[21] >> 16) & 0x0000ffff);
+		dade = ((_pData[17] << 16) & 0xffff0000) | (_pData[21] & 0x0000ffff);
+	}
+
+	int s = 0, t = 0, w = 0x30000;
+	int dsdx = 0, dtdx = 0, dwdx = 0;
+	int dsde = 0, dtde = 0, dwde = 0;
+	if (_texture) {
+		s = (_pData[24] & 0xffff0000) | ((_pData[28] >> 16) & 0x0000ffff);
+		t = ((_pData[24] << 16) & 0xffff0000) | (_pData[28] & 0x0000ffff);
+		w = (_pData[25] & 0xffff0000) | ((_pData[29] >> 16) & 0x0000ffff);
+		dsdx = (_pData[26] & 0xffff0000) | ((_pData[30] >> 16) & 0x0000ffff);
+		dtdx = ((_pData[26] << 16) & 0xffff0000) | (_pData[30] & 0x0000ffff);
+		dwdx = (_pData[27] & 0xffff0000) | ((_pData[31] >> 16) & 0x0000ffff);
+		dsde = (_pData[32] & 0xffff0000) | ((_pData[36] >> 16) & 0x0000ffff);
+		dtde = ((_pData[32] << 16) & 0xffff0000) | (_pData[36] & 0x0000ffff);
+		dwde = (_pData[33] & 0xffff0000) | ((_pData[37] >> 16) & 0x0000ffff);
+	}
+
+	int z = 0xffff0000;
+	int dzdx = 0, dzde = 0;
+	if (_zbuffer) {
+		z = _pData[40];
+		dzdx = _pData[41];
+		dzde = _pData[42];
+	}
+
+	std::array<SPVertex, 8> vertices;
+
+	auto cscale = [](int c) {
+		return _FIXED2FLOATCOLOR((((c) > 0x3ff0000 ? 0x3ff0000 : ((c) < 0 ? 0 : (c))) >> 18), 8);
+	};
+
+	f32 rf = cscale(r << 2);
+	f32 gf = cscale(g << 2);
+	f32 bf = cscale(b << 2);
+	f32 af = cscale(a << 2);
+	f32 wf = f32(w) / f32(0xffff0000);
+	f32 zf = f32(z) / f32(0xffff0000);
+	f32 sf = f32(s) / f32(1 << 18);
+	f32 tf = f32(t) / f32(1 << 18);
+
+	f32 drdef = _FIXED2FLOAT(((drde >> 2) & ~1), 16) / 255.0f;
+	f32 dgdef = _FIXED2FLOAT(((dgde >> 2) & ~1), 16) / 255.0f;
+	f32 dbdef = _FIXED2FLOAT(((dbde >> 2) & ~1), 16) / 255.0f;
+	f32 dadef = _FIXED2FLOAT(((dade >> 2) & ~1), 16) / 255.0f;
+	f32 dwdef = f32(dwde >> 2) / f32(0xffff0000);
+	f32 dzdef = f32(dzde >> 2) / f32(0xffff0000);
+
+	f32 dsdef = f32(dsde >> 2) / f32(1 << 18);
+	f32 dtdef = f32(dtde >> 2) / f32(1 << 18);
+
+	f32 drdxf = _FIXED2FLOAT(drdx, 16) / 255.0f;
+	f32 dgdxf = _FIXED2FLOAT(dgdx, 16) / 255.0f;
+	f32 dbdxf = _FIXED2FLOAT(dbdx, 16) / 255.0f;
+	f32 dadxf = _FIXED2FLOAT(dadx, 16) / 255.0f;
+
+	f32 dwdxf = f32(dwdx >> 2) / f32(0xffff0000);
+	f32 dzdxf = f32(dzdx >> 2) / f32(0xffff0000);
+
+	f32 dsdxf = _FIXED2FLOAT(((dsdx >> 2) & ~1), 16);
+	f32 dtdxf = _FIXED2FLOAT(((dtdx >> 2) & ~1), 16);
+
+	f32 xhf = _FIXED2FLOAT((xh & ~0x1), 16);
+	f32 xmf = _FIXED2FLOAT((xm & ~0x1), 16);
+
+	f32 yhf = f32(yh);
+	f32 ymf = f32(ym);
+	f32 ylf = f32(yl);
+	f32 hk = _FIXED2FLOAT(((dxhdy >> 2) & ~0x1), 16);
+	f32 mk = _FIXED2FLOAT(((dxmdy >> 2) & ~0x1), 16);
+	f32 hc = xhf - hk * yhf;
+	f32 mc = xmf - mk * yhf;
+
+	auto updateVtx = [&](SPVertex * vtx, f32 diffY, f32 diffx)
+	{
+		if (_shade) {
+			auto colorClamp = [](f32 c) -> f32
+			{
+				f32 res;
+				if (c < 0.0f)
+					res = 0.0f;
+				else if (c > 1.0f)
+					res = 1.0f;
+				else
+					res = static_cast<f32>(c);
+				return res;
+			};
+
+			vtx->r = colorClamp(rf + drdef * diffY + drdxf * diffx);
+			vtx->g = colorClamp(gf + dgdef * diffY + dgdxf * diffx);
+			vtx->b = colorClamp(bf + dbdef * diffY + dbdxf * diffx);
+			vtx->a = colorClamp(af + dadef * diffY + dadxf * diffx);
+		}
+
+		if (_zbuffer) {
+			//((gDP.otherMode.depthSource == G_ZS_PRIM) ? gDP.primDepth.z : f32(u32(z)) / 0xffff0000)
+			vtx->z = (gDP.otherMode.depthSource == G_ZS_PRIM) ?
+				gDP.primDepth.z :
+				static_cast<f32>((zf + dzdef * diffY + dzdxf * diffx * 4.0f)*2.0f);
+			//if (vtx->z < 0.0f)
+			//	vtx->z = 1.0f + vtx->z - ceil(vtx->z);
+		} else
+			vtx->z = 0.0f;
+
+		if (_texture) {
+			if (gDP.otherMode.texturePersp != 0) {
+				f32 vw = wf + dwdef * diffY + dwdxf * diffx * 4.0f;
+				if (vw == 0)
+					int t = 0;
+				vtx->w = static_cast<f32>(1.0f / (vw > 0.0f ? vw : (1.0f + vw - ceil(vw))));
+				//vtx->w = static_cast<f32>(1.0f / vw);
+				if (vw <= 0.0f) {
+					// TODO fix with proper coords
+					vtx->s = static_cast<f32>(1 << gSP.textureTile[0]->masks);
+					vtx->t = static_cast<f32>(1 << gSP.textureTile[0]->maskt);
+				} else {
+					vtx->s = static_cast<f32>((sf + dsdef * diffY + dsdxf*diffx) / vw * 0.0625f);
+					vtx->t = static_cast<f32>((tf + dtdef * diffY + dtdxf*diffx) / vw * 0.0625f);
+				}
+			} else {
+				vtx->w = 1.0f;
+				vtx->s = static_cast<f32>((sf + dsdef * diffY + dsdxf*diffx) * 0.125f);
+				vtx->t = static_cast<f32>((tf + dtdef * diffY + dtdxf*diffx) * 0.125f);
+			}
+		} else
+			vtx->w = 1.0f;
+		//assert(!isnan(vtx->x));
+	};
+
+	u32 vtxCount = 0;
+	if (fabs(hk - mk) < 0.00000001f) {
+		SPVertex * vtx = &vertices[vtxCount++];
+		vtx->x = static_cast<f32>(hk * yhf + hc);
+		vtx->y = static_cast<f32>(yhf * 0.25f);
+		updateVtx(vtx, 0.0f, 0.0f);
+
+		if (mc != hc) {
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(mk * yhf + mc);
+			vtx->y = static_cast<f32>(yhf * 0.25f);
+			updateVtx(vtx, 0.0f, (mc - hc));
+		}
+
+		f32 diffym = (ymf - yhf);
+		f32 xhym = (hk * ymf + hc);
+		f32 xmym = (mk * ymf + mc);
+		f32 diffxm = (xmym - xhym);
+
+#if 1
+		f32 vw = wf + dwdef * diffym + dwdxf * diffxm * 4.0f;
+		if (vw <= 0.0f) {
+			f32 xhyf, xmyf, diffyf, diffxf;
+			f32 yf = ymf;
+			do {
+				yf -= 1.0f;
+				diffyf = (yf - yhf);
+				xhyf = hk * yf + hc;
+				xmyf = mk * yf + mc;
+				diffxf = xmyf - xhyf;
+				vw = wf + dwdef * diffyf + dwdxf * diffxf * 4.0f;
+			} while (vw <= 0.0f && yf > yhf);
+
+			SPVertex * vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(xhyf);
+			vtx->y = static_cast<f32>(yf * 0.25);
+			updateVtx(vtx, diffyf, 0.0f);
+
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(xmyf);
+			vtx->y = static_cast<f32>(yf * 0.25);
+			updateVtx(vtx, diffyf, diffxf);
+		}
+#endif
+
+		vtx = &vertices[vtxCount++];
+		vtx->x = static_cast<f32>(xhym);
+		vtx->y = static_cast<f32>(ymf * 0.25);
+		updateVtx(vtx, diffym, 0.0f);
+
+		vtx = &vertices[vtxCount++];
+		vtx->x = static_cast<f32>(xmym);
+		vtx->y = static_cast<f32>(ymf * 0.25);
+		updateVtx(vtx, diffym, diffxm);
+
+		if (dxldy != dxmdy && ym < yl) {
+			f32 xlf = _FIXED2FLOAT((xl & ~1), 16);
+			f32 lk = _FIXED2FLOAT(((dxldy >> 2) & ~1), 16);
+			f32 lc = xlf - lk * ym;
+			f32 y4f = (lc - hc) / (hk - lk);
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(hk * y4f + hc);
+			vtx->y = static_cast<f32>(y4f * 0.25);
+			updateVtx(vtx, (y4f - yhf), 0.0f);
+		}
+	} else {
+		f32 y0f = (mc - hc) / (hk - mk);
+
+		SPVertex * vtx = &vertices[vtxCount++];
+		vtx->x = static_cast<f32>(hk * y0f + hc);
+		vtx->y = static_cast<f32>(y0f * 0.25f);
+		updateVtx(vtx, (y0f - yhf), 0.0f);
+
+		f32 y1f = ymf;
+		f32 xlf = _FIXED2FLOAT((xl & ~1), 16);
+		f32 lk = _FIXED2FLOAT(((dxldy >> 2) & ~1), 16);
+		f32 lc = xlf - lk * y1f;
+
+		//f32 lc = xt - lk * yf;
+		//if ((dxldy >> 2) == (dxmdy >> 2))
+		//	y1f = (lc - hc) / (hk - lk);
+		//else
+		//	y1f = (lc - mc) / (mk - lk);
+
+		//if (y1f < ymf)
+		//	y1f = ymf;
+
+		vtx = &vertices[vtxCount++];
+		vtx->x = static_cast<f32>(xlf);
+		vtx->y = static_cast<f32>(y1f * 0.25);
+
+		f32 x1f = hk * y1f + hc;
+		f32 diffx1 = xlf - x1f;
+
+#if 0
+		if ((dxldy >> 2) == (dxmdy >> 2))
+			y1f = (lc - hc) / (hk - lk);
+		else
+			y1f = (lc - mc) / (mk - lk);
+#endif
+
+		f32 diffy1 = (y1f - yhf);
+		updateVtx(vtx, diffy1, diffx1);
+
+#if 1
+		f32 vw1 = wf + dwdef * diffy1 + dwdxf * diffx1 * 4.0f;
+		if (vw1 <= 0.0f) {
+			f32 y1_1f = y1f;
+			f32 vw1_1 = vw1;
+			f32 x1_1f = x1f;
+			f32 x1_2f = xlf;
+			f32 diffy1_1 = diffy1;
+			f32 diffx1_1 = diffx1;
+			do {
+				y1_1f += 1.0f;
+				diffy1_1 = (y1_1f - yhf);
+				x1_1f = hk * y1_1f + hc;
+				x1_2f = lk * y1_1f + lc;
+				diffx1_1 = x1_2f - x1_1f;
+				vw1_1 = wf + dwdef * diffy1_1 + dwdxf * diffx1_1 * 4.0f;
+			} while (vw1_1 <= 0.0f && y1_1f < ylf);
+
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(x1_1f);
+			vtx->y = static_cast<f32>(y1_1f * 0.25f);
+			updateVtx(vtx, diffy1_1, 0.0f);
+
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(x1_2f);
+			vtx->y = static_cast<f32>(y1_1f * 0.25f);
+			updateVtx(vtx, diffy1_1, diffx1_1);
+
+		}
+#endif
+
+		if (hk == lk) {
+			f32 lrx = lk * ylf + lc;
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(lrx);
+			vtx->y = static_cast<f32>(ylf * 0.25f - (vertices[1].y - vertices[0].y));
+			f32 ydiff = (vtx->y*4.0f - yhf);
+			updateVtx(vtx, ydiff, diffx1);
+
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(lrx);
+			vtx->y = static_cast<f32>(ylf*0.25f);
+			ydiff = (ylf - yhf);
+
+			f32 x2f = hk * ylf + hc;
+			f32 diffx2 = vtx->x - x2f;
+			updateVtx(vtx, ydiff, diffx2);
+		}
+		else if (mk == lk) {
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(hk * ylf + hc);
+			vtx->y = static_cast<f32>(ylf * 0.25f);
+			updateVtx(vtx, (ylf - yhf), 0.0f);
+		}
+		else {
+			f32 y2f = ylf;
+
+			if (yl == ym) {
+				y2f = (lc - mc) / (mk - lk);
+			}
+			else {
+				y2f = (lc - hc) / (hk - lk);
+			}
+
+			vtx = &vertices[vtxCount++];
+			vtx->x = static_cast<f32>(hk * y2f + hc);
+			vtx->y = static_cast<f32>(y2f * 0.25f);
+			updateVtx(vtx, (y2f - yhf), 0.0f);
+		}
+	}
+
+	if (_texture)
+		gDP.changed |= CHANGED_TILE;
+	if (_zbuffer)
+		gSP.geometryMode |= G_ZBUFFER;
+
+	if (vtxCount < 3)
+		return;
+
+	GraphicsDrawer & drawer = dwnd().getDrawer();
+
+	for (u32 i = 0; i < vtxCount - 2; ++i) {
+		for (u32 j = 0; j < 3; ++j) {
+			SPVertex & v = drawer.getCurrentDMAVertex();
+			v = vertices[i + j];
+		}
+	}
+}
+
+#ifdef OLD_LLE
 static void gDPTriangle(u32 _w1, u32 _w2, int shade, int texture, int zbuffer)
 {
 	gDPLLETriangle(_w1, _w2, shade, texture, zbuffer, RDP.cmd_data + RDP.cmd_cur);
 }
+#endif
 
 void gDPTriFill(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 8 * sizeof(s32));
+	memset(&ewdata[8], 0, 36 * sizeof(s32));
+	LLETriangle::get().draw(0, 0, 0, ewdata);
+#else
 	gDPTriangle(w0, w1, 0, 0, 0);
+#endif
 	DebugMsg( DEBUG_NORMAL, "trifill\n");
 }
 
 void gDPTriShade(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 24 * sizeof(s32));
+	memset(&ewdata[24], 0, 20 * sizeof(s32));
+	LLETriangle::get().draw(1, 0, 0, ewdata);
+#else
 	gDPTriangle(w0, w1, 1, 0, 0);
+#endif
 	DebugMsg( DEBUG_NORMAL, "trishade\n");
 }
 
 void gDPTriTxtr(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 8 * sizeof(s32));
+	memset(&ewdata[8], 0, 16 * sizeof(s32));
+	memcpy(&ewdata[24], RDP.cmd_data + RDP.cmd_cur + 8, 16 * sizeof(s32));
+	memset(&ewdata[40], 0, 4 * sizeof(s32));
+	LLETriangle::get().draw(0, 1, 0, ewdata);
+#else
 	gDPTriangle(w0, w1, 0, 1, 0);
-	DebugMsg( DEBUG_NORMAL, "tritxtr\n");
+#endif
+	DebugMsg(DEBUG_NORMAL, "tritxtr\n");
 }
 
 void gDPTriShadeTxtr(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 40 * sizeof(s32));
+	memset(&ewdata[40], 0, 4 * sizeof(s32));
+	LLETriangle::get().draw(1, 1, 0, ewdata);
+#else
 	gDPTriangle(w0, w1, 1, 1, 0);
+#endif
 	DebugMsg( DEBUG_NORMAL, "trishadetxtr\n");
 }
 
 void gDPTriFillZ(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 8 * sizeof(s32));
+	memset(&ewdata[8], 0, 32 * sizeof(s32));
+	memcpy(&ewdata[40], RDP.cmd_data + RDP.cmd_cur + 8, 4 * sizeof(s32));
+	LLETriangle::get().draw(0, 0, 1, ewdata);
+#else
 	gDPTriangle(w0, w1, 0, 0, 1);
+#endif
 	DebugMsg( DEBUG_NORMAL, "trifillz\n");
 }
 
 void gDPTriShadeZ(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 24 * sizeof(s32));
+	memset(&ewdata[24], 0, 16 * sizeof(s32));
+	memcpy(&ewdata[40], RDP.cmd_data + RDP.cmd_cur + 24, 4 * sizeof(s32));
+	LLETriangle::get().draw(1, 0, 1, ewdata);
+#else
 	gDPTriangle(w0, w1, 1, 0, 1);
+#endif
 	DebugMsg( DEBUG_NORMAL, "trishadez\n");
 }
 
 void gDPTriTxtrZ(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 8 * sizeof(s32));
+	memset(&ewdata[8], 0, 16 * sizeof(s32));
+	memcpy(&ewdata[24], RDP.cmd_data + RDP.cmd_cur + 8, 16 * sizeof(s32));
+	memcpy(&ewdata[40], RDP.cmd_data + RDP.cmd_cur + 24, 4 * sizeof(s32));
+	LLETriangle::get().draw(0, 1, 1, ewdata);
+#else
 	gDPTriangle(w0, w1, 0, 1, 1);
+#endif
 	DebugMsg( DEBUG_NORMAL, "tritxtrz\n");
 }
 
 void gDPTriShadeTxtrZ(u32 w0, u32 w1)
 {
+#ifndef OLD_LLE
+	s32 ewdata[44];
+	memcpy(&ewdata[0], RDP.cmd_data + RDP.cmd_cur, 44 * sizeof(s32));
+	LLETriangle::get().draw(1, 1, 1, ewdata);
+#else
 	gDPTriangle(w0, w1, 1, 1, 1);
+#endif
 	DebugMsg( DEBUG_NORMAL, "trishadetxtrz\n");
 }
diff --git a/GLideN64/src/gDP.h b/GLideN64/src/gDP.h
index 6bea3489..48b62014 100644
--- a/GLideN64/src/gDP.h
+++ b/GLideN64/src/gDP.h
@@ -251,8 +251,8 @@ struct gDPInfo
 	u32 changed;
 
 	u16 TexFilterPalette[512];
-	u32 paletteCRC16[16];
-	u32 paletteCRC256;
+	u64 paletteCRC16[16];
+	u64 paletteCRC256;
 	u32 half_1, half_2;
 
 	 gDPLoadTileInfo loadInfo[512];
@@ -260,6 +260,26 @@ struct gDPInfo
 
 extern gDPInfo gDP;
 
+//#define OLD_LLE
+
+class LLETriangle
+{
+public:
+	void draw(bool _shade, bool _texture, bool _zbuffer, s32 * _pData);
+	void flush(u32 _cmd);
+	static LLETriangle& get();
+
+private:
+	LLETriangle();
+	LLETriangle(LLETriangle&) = delete;
+	void start(u32 _tile);
+
+	gDPTile *m_textureTileOrg[2];
+	f32 m_textureScaleOrg[2];
+	bool m_flushed{ true };
+	u32 m_tile{ 0 };
+};
+
 void gDPSetOtherMode( u32 mode0, u32 mode1 );
 void gDPSetPrimDepth( u16 z, u16 dz );
 void gDPSetTexturePersp( u32 enable );
diff --git a/GLideN64/src/gSP.cpp b/GLideN64/src/gSP.cpp
index 586003b1..150e73d6 100644
--- a/GLideN64/src/gSP.cpp
+++ b/GLideN64/src/gSP.cpp
@@ -1594,6 +1594,7 @@ void gSPSegment( s32 seg, s32 base )
 void gSPClipRatio(u32 ratio)
 {
 	gSP.clipRatio = std::abs(static_cast<s16>(ratio & 0xFFFF));
+	gSP.changed |= CHANGED_VIEWPORT;
 	DebugMsg(DEBUG_NORMAL, "gSPClipRatio(%u);\n", gSP.clipRatio);
 }
 
@@ -1677,7 +1678,7 @@ void gSPModifyVertex( u32 _vtx, u32 _where, u32 _val )
 				vtx0.y *= vtx0.w;
 			} else {
 				vtx0.modify |= MODIFY_XY;
-				if (vtx0.w == 0.0f) {
+				if (vtx0.w == 0.0f || gDP.otherMode.depthSource == G_ZS_PRIM) {
 					vtx0.w = 1.0f;
 					vtx0.clip &= ~(CLIP_W);
 				}
diff --git a/GLideN64/src/mupenplus/Config_mupenplus.cpp b/GLideN64/src/mupenplus/Config_mupenplus.cpp
index 70f3eff7..39bffa17 100644
--- a/GLideN64/src/mupenplus/Config_mupenplus.cpp
+++ b/GLideN64/src/mupenplus/Config_mupenplus.cpp
@@ -67,7 +67,13 @@ bool Config_SetDefault()
 	res = ConfigSetDefaultInt(g_configVideoGliden64, "MaxAnisotropy", config.texture.maxAnisotropy, "Max level of Anisotropic Filtering, 0 for off");
 	assert(res == M64ERR_SUCCESS);
 	//#Emulation Settings
-	res = ConfigSetDefaultBool(g_configVideoGliden64, "EnableNoise", config.generalEmulation.enableNoise, "Enable color noise emulation.");
+	res = ConfigSetDefaultBool(g_configVideoGliden64, "EnableDitheringPattern", config.generalEmulation.enableDitheringPattern, "Enable dithering pattern on output image.");
+	assert(res == M64ERR_SUCCESS);
+	res = ConfigSetDefaultBool(g_configVideoGliden64, "EnableHiresNoiseDithering", config.generalEmulation.enableHiresNoiseDithering, "Enable hi-res noise dithering.");
+	assert(res == M64ERR_SUCCESS);
+	res = ConfigSetDefaultBool(g_configVideoGliden64, "DitheringQuantization", config.generalEmulation.enableDitheringQuantization, "Dither with color quantization.");
+	assert(res == M64ERR_SUCCESS);
+	res = ConfigSetDefaultInt(g_configVideoGliden64, "RDRAMImageDitheringMode", config.generalEmulation.rdramImageDitheringMode, "Dithering mode for image in RDRAM. (0=disable, 1=bayer, 2=magic square, 3=blue noise)");
 	assert(res == M64ERR_SUCCESS);
 	res = ConfigSetDefaultBool(g_configVideoGliden64, "EnableLOD", config.generalEmulation.enableLOD, "Enable LOD emulation.");
 	assert(res == M64ERR_SUCCESS);
@@ -270,8 +276,14 @@ void Config_LoadCustomConfig()
 	result = ConfigExternalGetParameter(fileHandle, sectionName, "texture\\screenShotFormat", value, sizeof(value));
 	if (result == M64ERR_SUCCESS) config.texture.screenShotFormat = atoi(value);
 
-	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\enableNoise", value, sizeof(value));
-	if (result == M64ERR_SUCCESS) config.generalEmulation.enableNoise = atoi(value);
+	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\enableDitheringPattern", value, sizeof(value));
+	if (result == M64ERR_SUCCESS) config.generalEmulation.enableDitheringPattern = atoi(value);
+	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\enableHiresNoiseDithering", value, sizeof(value));
+	if (result == M64ERR_SUCCESS) config.generalEmulation.enableHiresNoiseDithering = atoi(value);
+	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\enableDitheringQuantization", value, sizeof(value));
+	if (result == M64ERR_SUCCESS) config.generalEmulation.enableDitheringQuantization = atoi(value);
+	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\rdramImageDitheringMode", value, sizeof(value));
+	if (result == M64ERR_SUCCESS) config.generalEmulation.rdramImageDitheringMode = atoi(value);
 	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\enableLOD", value, sizeof(value));
 	if (result == M64ERR_SUCCESS) config.generalEmulation.enableLOD = atoi(value);
 	result = ConfigExternalGetParameter(fileHandle, sectionName, "generalEmulation\\enableHWLighting", value, sizeof(value));
@@ -394,7 +406,11 @@ void Config_LoadConfig()
 	config.texture.maxAnisotropy = ConfigGetParamInt(g_configVideoGliden64, "MaxAnisotropy");
 	config.texture.enableHalosRemoval = ConfigGetParamBool(g_configVideoGliden64, "enableHalosRemoval");
 	//#Emulation Settings
-	config.generalEmulation.enableNoise = ConfigGetParamBool(g_configVideoGliden64, "EnableNoise");
+	config.generalEmulation.enableDitheringPattern = ConfigGetParamBool(g_configVideoGliden64, "EnableDitheringPattern");
+	config.generalEmulation.enableHiresNoiseDithering = ConfigGetParamBool(g_configVideoGliden64, "EnableHiresNoiseDithering");
+	config.generalEmulation.enableDitheringQuantization = ConfigGetParamBool(g_configVideoGliden64, "DitheringQuantization");
+	config.generalEmulation.rdramImageDitheringMode = ConfigGetParamInt(g_configVideoGliden64, "RDRAMImageDitheringMode");
+
 	config.generalEmulation.enableLOD = ConfigGetParamBool(g_configVideoGliden64, "EnableLOD");
 	config.generalEmulation.enableHWLighting = ConfigGetParamBool(g_configVideoGliden64, "EnableHWLighting");
 	config.generalEmulation.enableShadersStorage = ConfigGetParamBool(g_configVideoGliden64, "EnableShadersStorage");
diff --git a/GLideN64/src/resource.h b/GLideN64/src/resource.h
new file mode 100644
index 0000000000000000000000000000000000000000..11bee0a1ac9c2be6281dd77299bd2aa422e0339c
GIT binary patch
literal 814
zcmb7?PfNo<5XIkF@H;Gc6l{v(J*Gv9Z7Pi^^%QKINTsyUH2y*S>gsPc7OIC(88$mR
zee>Sz+kSnv)Y3Z<Yp6^eb#=>%eHJTHk5i%#;#fyuTXGs`p_w*Xt7H}0QX5k%Rp~)X
zPLWOtr$^;lu{PAV>~m@hDl<?Or<`*^Wl46nr;x%`qo;ZUbFDro!^gVR1=tN7yNPVy
z<qkxyS3i^C3zRGPZN_ImT}8F@x@%aRpYMfzt*M^)Z3ed7<1^+H)C;d)fDG{{(VbFU
z>UrOKsE)~QaI52c>yA}J&j@S?dPr|y_qd<%9q5WmpS;$s?_i#pSJ{ttMo(80X2@hb
z2|X!UM4mB82t!Kl{zO}W&JSjeU>y)4YMn-2$D0H`+W%sYxxvWaw`po8n>*lps3*0P
X_7=^&=8tjjnC;&>_itS*{XTyK&>(a4

literal 0
HcmV?d00001

diff --git a/GLideN64/src/uCodes/S2DEX.cpp b/GLideN64/src/uCodes/S2DEX.cpp
index a9525c8c..88acd5dd 100644
--- a/GLideN64/src/uCodes/S2DEX.cpp
+++ b/GLideN64/src/uCodes/S2DEX.cpp
@@ -730,8 +730,8 @@ static
 void gSPObjSprite(u32 _sp)
 {
 	const u32 address = RSP_SegmentToPhysical(_sp);
-	uObjSprite *objSprite = (uObjSprite*)&RDRAM[address];
-	gSPSetSpriteTile(objSprite);
+	uObjSprite *pObjSprite = (uObjSprite*)&RDRAM[address];
+	gSPSetSpriteTile(pObjSprite);
 
 	/* Fixed point coordinates calculation. Decoded by olivieryuyu */
 	//	X1 = AND (X + B3) by B0 + ((objX + A3) * A) >> 16 + ((objY + A3) * B) >> 16
@@ -745,10 +745,12 @@ void gSPObjSprite(u32 _sp)
 	const s16 y0 = (gs_s2dexversion == eVer1_3) ?
 					((objMtx.Y + CC.B5) & CC.B0) + CC.B7 :
 					((objMtx.Y + CC.B3) & CC.B0);
-	const s16 ulx = objSprite->objX + CC.A3;
-	const s16 uly = objSprite->objY + CC.A3;
-	const s16 lrx = ((((u64(objSprite->imageW) - CC.A1) << 8) * (0x80007FFFU / u32(objSprite->scaleW))) >> 32) + ulx;
-	const s16 lry = ((((u64(objSprite->imageH) - CC.A1) << 8) * (0x80007FFFU / u32(objSprite->scaleH))) >> 32) + uly;
+	const s16 ulx = pObjSprite->objX + CC.A3;
+	const s16 uly = pObjSprite->objY + CC.A3;
+	const u32 objSpriteScaleW = std::max(u32(pObjSprite->scaleW), 1U);
+	const u32 objSpriteScaleH = std::max(u32(pObjSprite->scaleH), 1U);
+	const s16 lrx = ((((u64(pObjSprite->imageW) - CC.A1) << 8) * (0x80007FFFU / objSpriteScaleW)) >> 32) + ulx;
+	const s16 lry = ((((u64(pObjSprite->imageH) - CC.A1) << 8) * (0x80007FFFU / objSpriteScaleH)) >> 32) + uly;
 
 	auto calcX = [&](s16 _x, s16 _y) -> f32
 	{
@@ -763,14 +765,14 @@ void gSPObjSprite(u32 _sp)
 	};
 
 	f32 uls = 0.0f;
-	f32 lrs = _FIXED2FLOAT(objSprite->imageW, 5) - 1.0f;
+	f32 lrs = _FIXED2FLOAT(pObjSprite->imageW, 5) - 1.0f;
 	f32 ult = 0.0f;
-	f32 lrt = _FIXED2FLOAT(objSprite->imageH, 5) - 1.0f;
+	f32 lrt = _FIXED2FLOAT(pObjSprite->imageH, 5) - 1.0f;
 
-	if (objSprite->imageFlags & G_BG_FLAG_FLIPS)
+	if (pObjSprite->imageFlags & G_BG_FLAG_FLIPS)
 		std::swap(uls, lrs);
 
-	if (objSprite->imageFlags & G_BG_FLAG_FLIPT)
+	if (pObjSprite->imageFlags & G_BG_FLAG_FLIPT)
 		std::swap(ult, lrt);
 
 	const float z = (gDP.otherMode.depthSource == G_ZS_PRIM) ? gDP.primDepth.z : gSP.viewport.nearz;
diff --git a/GLideN64/src/windows/GLideN64_windows.cpp b/GLideN64/src/windows/GLideN64_windows.cpp
index c2246ec4..1da12745 100644
--- a/GLideN64/src/windows/GLideN64_windows.cpp
+++ b/GLideN64/src/windows/GLideN64_windows.cpp
@@ -5,9 +5,25 @@ HWND		hStatusBar;
 HWND		hToolBar;
 HINSTANCE	hInstance;
 
+#ifdef WTL_UI
+void ConfigInit(void * hinst);
+void ConfigCleanup(void);
+#endif
+
 BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID /*lpvReserved*/)
 {
-	hInstance = hinstDLL;
-
+#ifdef WTL_UI
+    if (dwReason == DLL_PROCESS_ATTACH)
+    {
+        hInstance = hinstDLL;
+        ConfigInit(hinstDLL);
+    }
+    else if (dwReason == DLL_PROCESS_DETACH)
+    {
+        ConfigCleanup();
+    }
+#else
+    hInstance = hinstDLL;
+#endif
 	return TRUE;
 }
diff --git a/GLideN64/src/xxHash/xxh3.h b/GLideN64/src/xxHash/xxh3.h
index b3a82958..9e3e88ad 100644
--- a/GLideN64/src/xxHash/xxh3.h
+++ b/GLideN64/src/xxHash/xxh3.h
@@ -1,50 +1,54 @@
 /*
-   xxHash - Extremely Fast Hash algorithm
-   Development source file for `xxh3`
-   Copyright (C) 2019-present, Yann Collet.
-
-   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are
-   met:
-
-       * Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
-       * Redistributions in binary form must reproduce the above
-   copyright notice, this list of conditions and the following disclaimer
-   in the documentation and/or other materials provided with the
-   distribution.
-
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-   You can contact the author at :
-   - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
-
-/* Note :
-   This file is separated for development purposes.
-   It will be integrated into `xxhash.c` when development phase is complete.
-*/
-
-#ifndef XXH3_H
-#define XXH3_H
+ * xxHash - Extremely Fast Hash algorithm
+ * Development source file for `xxh3`
+ * Copyright (C) 2019-present, Yann Collet
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
 
+/*
+ * Note: This file is separated for development purposes.
+ * It will be integrated into `xxhash.h` when development stage is completed.
+ *
+ * Credit: most of the work on vectorial and asm variants comes from @easyaspi314
+ */
 
-/* ===   Dependencies   === */
+#ifndef XXH3_H_1397135465
+#define XXH3_H_1397135465
 
-#undef XXH_INLINE_ALL   /* in case it's already defined */
-#define XXH_INLINE_ALL
+/* ===   Dependencies   === */
+#ifndef XXHASH_H_5627135585666179
+/* special: when including `xxh3.h` directly, turn on XXH_INLINE_ALL */
+#  undef XXH_INLINE_ALL   /* avoid redefinition */
+#  define XXH_INLINE_ALL
+#endif
 #include "xxhash.h"
 
 
@@ -53,10 +57,20 @@
 #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* >= C99 */
 #  define XXH_RESTRICT   restrict
 #else
-/* note : it might be useful to define __restrict or __restrict__ for some C++ compilers */
+/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */
 #  define XXH_RESTRICT   /* disable */
 #endif
 
+#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
+  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
+  || defined(__clang__)
+#    define XXH_likely(x) __builtin_expect(x, 1)
+#    define XXH_unlikely(x) __builtin_expect(x, 0)
+#else
+#    define XXH_likely(x) (x)
+#    define XXH_unlikely(x) (x)
+#endif
+
 #if defined(__GNUC__)
 #  if defined(__AVX2__)
 #    include <immintrin.h>
@@ -72,17 +86,50 @@
 #endif
 
 /*
- * Sanity check.
+ * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
+ * remaining a true 64-bit/128-bit hash function.
+ *
+ * This is done by prioritizing a subset of 64-bit operations that can be
+ * emulated without too many steps on the average 32-bit machine.
+ *
+ * For example, these two lines seem similar, and run equally fast on 64-bit:
  *
- * XXH3 only requires these features to be efficient:
+ *   xxh_u64 x;
+ *   x ^= (x >> 47); // good
+ *   x ^= (x >> 13); // bad
+ *
+ * However, to a 32-bit machine, there is a major difference.
+ *
+ * x ^= (x >> 47) looks like this:
+ *
+ *   x.lo ^= (x.hi >> (47 - 32));
+ *
+ * while x ^= (x >> 13) looks like this:
+ *
+ *   // note: funnel shifts are not usually cheap.
+ *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
+ *   x.hi ^= (x.hi >> 13);
+ *
+ * The first one is significantly faster than the second, simply because the
+ * shift is larger than 32. This means:
+ *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
+ *    32 bits in the shift.
+ *  - The shift result will always fit in the lower 32 bits, and therefore,
+ *    we can ignore the upper 32 bits in the xor.
+ *
+ * Thanks to this optimization, XXH3 only requires these features to be efficient:
  *
  *  - Usable unaligned access
  *  - A 32-bit or 64-bit ALU
  *      - If 32-bit, a decent ADC instruction
  *  - A 32 or 64-bit multiply with a 64-bit result
+ *  - For the 128-bit variant, a decent byteswap helps short inputs.
+ *
+ * The first two are already required by XXH32, and almost all 32-bit and 64-bit
+ * platforms which can run XXH32 can run XXH3 efficiently.
  *
- * Almost all 32-bit and 64-bit targets meet this, except for Thumb-1, the
- * classic 16-bit only subset of ARM's instruction set.
+ * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
+ * notable exception.
  *
  * First of all, Thumb-1 lacks support for the UMULL instruction which
  * performs the important long multiply. This means numerous __aeabi_lmul
@@ -93,14 +140,16 @@
  * Lo registers, and this shuffling results in thousands more MOVs than A32.
  *
  * A32 and T32 don't have this limitation. They can access all 14 registers,
- * do a 32->64 multiply with UMULL, and the flexible operand is helpful too.
+ * do a 32->64 multiply with UMULL, and the flexible operand allowing free
+ * shifts is helpful, too.
  *
- * If compiling Thumb-1 for a target which supports ARM instructions, we
- * will give a warning.
+ * Therefore, we do a quick sanity check.
  *
- * Usually, if this happens, it is because of an accident and you probably
- * need to specify -march, as you probably meant to compileh for a newer
- * architecture.
+ * If compiling Thumb-1 for a target which supports ARM instructions, we will
+ * emit a warning, as it is not a "sane" platform to compile for.
+ *
+ * Usually, if this happens, it is because of an accident and you probably need
+ * to specify -march, as you likely meant to compile for a newer architecture.
  */
 #if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
 #   warning "XXH3 is highly inefficient without ARM or Thumb-2."
@@ -109,11 +158,11 @@
 /* ==========================================
  * Vectorization detection
  * ========================================== */
-#define XXH_SCALAR 0
-#define XXH_SSE2   1
-#define XXH_AVX2   2
-#define XXH_NEON   3
-#define XXH_VSX    4
+#define XXH_SCALAR 0 /* Portable scalar version */
+#define XXH_SSE2   1 /* SSE2 for Pentium 4 and all x86_64 */
+#define XXH_AVX2   2 /* AVX2 for Haswell and Bulldozer */
+#define XXH_NEON   3 /* NEON for most ARMv7-A and all AArch64 */
+#define XXH_VSX    4 /* VSX and ZVector for POWER8/z13 */
 
 #ifndef XXH_VECTOR    /* can be defined on command line */
 #  if defined(__AVX2__)
@@ -125,47 +174,186 @@
   && (defined(__LITTLE_ENDIAN__) /* We only support little endian NEON */ \
     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
 #    define XXH_VECTOR XXH_NEON
-#  elif defined(__PPC64__) && defined(__POWER8_VECTOR__) && defined(__GNUC__)
+#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
+     || (defined(__s390x__) && defined(__VEC__)) \
+     && defined(__GNUC__) /* TODO: IBM XL */
 #    define XXH_VECTOR XXH_VSX
 #  else
 #    define XXH_VECTOR XXH_SCALAR
 #  endif
 #endif
 
-/* control alignment of accumulator,
- * for compatibility with fast vector loads */
+/*
+ * Controls the alignment of the accumulator.
+ * This is for compatibility with aligned vector loads, which are usually faster.
+ */
 #ifndef XXH_ACC_ALIGN
-#  if XXH_VECTOR == 0   /* scalar */
+#  if XXH_VECTOR == XXH_SCALAR  /* scalar */
 #     define XXH_ACC_ALIGN 8
-#  elif XXH_VECTOR == 1  /* sse2 */
+#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
 #     define XXH_ACC_ALIGN 16
-#  elif XXH_VECTOR == 2  /* avx2 */
+#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
 #     define XXH_ACC_ALIGN 32
-#  elif XXH_VECTOR == 3  /* neon */
+#  elif XXH_VECTOR == XXH_NEON  /* neon */
 #     define XXH_ACC_ALIGN 16
-#  elif XXH_VECTOR == 4  /* vsx */
+#  elif XXH_VECTOR == XXH_VSX   /* vsx */
 #     define XXH_ACC_ALIGN 16
 #  endif
 #endif
 
-/* xxh_u64 XXH_mult32to64(xxh_u32 a, xxh_u64 b) { return (xxh_u64)a * (xxh_u64)b; } */
-#if defined(_MSC_VER) && defined(_M_IX86)
-#    include <intrin.h>
-#    define XXH_mult32to64(x, y) __emulu(x, y)
-#else
-#    define XXH_mult32to64(x, y) ((xxh_u64)((x) & 0xFFFFFFFF) * (xxh_u64)((y) & 0xFFFFFFFF))
+/*
+ * UGLY HACK:
+ * GCC usually generates the best code with -O3 for xxHash.
+ *
+ * However, when targeting AVX2, it is overzealous in its unrolling resulting
+ * in code roughly 3/4 the speed of Clang.
+ *
+ * There are other issues, such as GCC splitting _mm256_loadu_si256 into
+ * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
+ * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
+ *
+ * That is why when compiling the AVX2 version, it is recommended to use either
+ *   -O2 -mavx2 -march=haswell
+ * or
+ *   -O2 -mavx2 -mno-avx256-split-unaligned-load
+ * for decent performance, or to use Clang instead.
+ *
+ * Fortunately, we can control the first one with a pragma that forces GCC into
+ * -O2, but the other one we can't control without "failed to inline always
+ * inline function due to target mismatch" warnings.
+ */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC push_options
+#  pragma GCC optimize("-O2")
 #endif
 
-/* VSX stuff. It's a lot because VSX support is mediocre across compilers and
- * there is a lot of mischief with endianness. */
+
+#if XXH_VECTOR == XXH_NEON
+/*
+ * NEON's setup for vmlal_u32 is a little more complicated than it is on
+ * SSE2, AVX2, and VSX.
+ *
+ * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.
+ *
+ * To do the same operation, the 128-bit 'Q' register needs to be split into
+ * two 64-bit 'D' registers, performing this operation::
+ *
+ *   [                a                 |                 b                ]
+ *            |              '---------. .--------'                |
+ *            |                         x                          |
+ *            |              .---------' '--------.                |
+ *   [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[    a >> 32     |     b >> 32    ]
+ *
+ * Due to significant changes in aarch64, the fastest method for aarch64 is
+ * completely different than the fastest method for ARMv7-A.
+ *
+ * ARMv7-A treats D registers as unions overlaying Q registers, so modifying
+ * D11 will modify the high half of Q5. This is similar to how modifying AH
+ * will only affect bits 8-15 of AX on x86.
+ *
+ * VZIP takes two registers, and puts even lanes in one register and odd lanes
+ * in the other.
+ *
+ * On ARMv7-A, this strangely modifies both parameters in place instead of
+ * taking the usual 3-operand form.
+ *
+ * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the
+ * lower and upper halves of the Q register to end up with the high and low
+ * halves where we want - all in one instruction.
+ *
+ *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }
+ *
+ * Unfortunately we need inline assembly for this: Instructions modifying two
+ * registers at once is not possible in GCC or Clang's IR, and they have to
+ * create a copy.
+ *
+ * aarch64 requires a different approach.
+ *
+ * In order to make it easier to write a decent compiler for aarch64, many
+ * quirks were removed, such as conditional execution.
+ *
+ * NEON was also affected by this.
+ *
+ * aarch64 cannot access the high bits of a Q-form register, and writes to a
+ * D-form register zero the high bits, similar to how writes to W-form scalar
+ * registers (or DWORD registers on x86_64) work.
+ *
+ * The formerly free vget_high intrinsics now require a vext (with a few
+ * exceptions)
+ *
+ * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent
+ * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one
+ * operand.
+ *
+ * The equivalent of the VZIP.32 on the lower and upper halves would be this
+ * mess:
+ *
+ *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }
+ *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }
+ *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }
+ *
+ * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):
+ *
+ *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 >> 32);
+ *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 & 0xFFFFFFFF);
+ *
+ * This is available on ARMv7-A, but is less efficient than a single VZIP.32.
+ */
+
+/*
+ * Function-like macro:
+ * void XXH_SPLIT_IN_PLACE(uint64x2_t &in, uint32x2_t &outLo, uint32x2_t &outHi)
+ * {
+ *     outLo = (uint32x2_t)(in & 0xFFFFFFFF);
+ *     outHi = (uint32x2_t)(in >> 32);
+ *     in = UNDEFINED;
+ * }
+ */
+# if !defined(XXH_NO_VZIP_HACK) /* define to disable */ \
+   && defined(__GNUC__) \
+   && !defined(__aarch64__) && !defined(__arm64__)
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
+    do {                                                                                    \
+      /* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */ \
+      /* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */     \
+      /* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */ \
+      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
+      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
+      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
+   } while (0)
+# else
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
+    do {                                                                                  \
+      (outLo) = vmovn_u64    (in);                                                        \
+      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
+    } while (0)
+# endif
+#endif  /* XXH_VECTOR == XXH_NEON */
+
+/*
+ * VSX and Z Vector helpers.
+ *
+ * This is very messy, and any pull requests to clean this up are welcome.
+ *
+ * There are a lot of problems with supporting VSX and s390x, due to
+ * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
+ */
 #if XXH_VECTOR == XXH_VSX
-#  include <altivec.h>
-#  undef vector
-typedef __vector unsigned long long U64x2;
-typedef __vector unsigned char U8x16;
-typedef __vector unsigned U32x4;
+#  if defined(__s390x__)
+#    include <s390intrin.h>
+#  else
+#    include <altivec.h>
+#  endif
+
+#  undef vector /* Undo the pollution */
 
-#ifndef XXH_VSX_BE
+typedef __vector unsigned long long xxh_u64x2;
+typedef __vector unsigned char xxh_u8x16;
+typedef __vector unsigned xxh_u32x4;
+
+# ifndef XXH_VSX_BE
 #  if defined(__BIG_ENDIAN__) \
   || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
 #    define XXH_VSX_BE 1
@@ -175,67 +363,82 @@ typedef __vector unsigned U32x4;
 #  else
 #    define XXH_VSX_BE 0
 #  endif
-#endif
+# endif /* !defined(XXH_VSX_BE) */
 
-/* We need some helpers for big endian mode. */
-#if XXH_VSX_BE
+# if XXH_VSX_BE
 /* A wrapper for POWER9's vec_revb. */
-#  ifdef __POWER9_VECTOR__
+#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
 #    define XXH_vec_revb vec_revb
 #  else
-XXH_FORCE_INLINE U64x2 XXH_vec_revb(U64x2 val)
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
 {
-    U8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
-                              0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
+    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
+                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
     return vec_perm(val, val, vByteSwap);
 }
 #  endif
+# endif /* XXH_VSX_BE */
 
-/* Power8 Crypto gives us vpermxor which is very handy for
- * PPC64EB.
- *
- * U8x16 vpermxor(U8x16 a, U8x16 b, U8x16 mask)
- * {
- *     U8x16 ret;
- *     for (int i = 0; i < 16; i++) {
- *         ret[i] = a[mask[i] & 0xF] ^ b[mask[i] >> 4];
- *     }
- *     return ret;
- * }
- *
- * Because both of the main loops load the key, swap, and xor it with input,
- * we can combine the key swap into this instruction.
+/*
+ * Performs an unaligned load and byte swaps it on big endian.
  */
-#  ifdef vec_permxor
-#    define XXH_vec_permxor vec_permxor
-#  else
-#    define XXH_vec_permxor __builtin_crypto_vpermxor
-#  endif
-#endif
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
+{
+    xxh_u64x2 ret;
+    memcpy(&ret, ptr, sizeof(xxh_u64x2));
+# if XXH_VSX_BE
+    ret = XXH_vec_revb(ret);
+# endif
+    return ret;
+}
+
 /*
- * Because we reinterpret the multiply, there are endian memes: vec_mulo actually becomes
- * vec_mule.
+ * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
  *
- * Additionally, the intrinsic wasn't added until GCC 8, despite existing for a while.
- * Clang has an easy way to control this, we can just use the builtin which doesn't swap.
- * GCC needs inline assembly. */
-#if __has_builtin(__builtin_altivec_vmuleuw)
+ * These intrinsics weren't added until GCC 8, despite existing for a while,
+ * and they are endian dependent. Also, their meaning swap depending on version.
+ * */
+# if defined(__s390x__)
+ /* s390x is always big endian, no issue on this platform */
+#  define XXH_vec_mulo vec_mulo
+#  define XXH_vec_mule vec_mule
+# elif defined(__clang__) && __has_builtin(__builtin_altivec_vmuleuw)
+/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
 #  define XXH_vec_mulo __builtin_altivec_vmulouw
 #  define XXH_vec_mule __builtin_altivec_vmuleuw
-#else
+# else
+/* gcc needs inline assembly */
 /* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
-XXH_FORCE_INLINE U64x2 XXH_vec_mulo(U32x4 a, U32x4 b) {
-    U64x2 result;
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
     __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
     return result;
 }
-XXH_FORCE_INLINE U64x2 XXH_vec_mule(U32x4 a, U32x4 b) {
-    U64x2 result;
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
     __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
     return result;
 }
-#endif
-#endif
+# endif /* XXH_vec_mulo, XXH_vec_mule */
+#endif /* XXH_VECTOR == XXH_VSX */
+
+
+/* prefetch
+ * can be disabled, by declaring XXH_NO_PREFETCH build macro */
+#if defined(XXH_NO_PREFETCH)
+#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
+#else
+#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  /* _mm_prefetch() is not defined outside of x86/x64 */
+#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
+#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
+#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
+#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
+#  else
+#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
+#  endif
+#endif  /* XXH_NO_PREFETCH */
 
 
 /* ==========================================
@@ -248,6 +451,7 @@ XXH_FORCE_INLINE U64x2 XXH_vec_mule(U32x4 a, U32x4 b) {
 #  error "default keyset is not large enough"
 #endif
 
+/* Pseudorandom secret taken directly from FARSH */
 XXH_ALIGN(64) static const xxh_u8 kSecret[XXH_SECRET_DEFAULT_SIZE] = {
     0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
     0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
@@ -265,16 +469,40 @@ XXH_ALIGN(64) static const xxh_u8 kSecret[XXH_SECRET_DEFAULT_SIZE] = {
 };
 
 /*
- * GCC for x86 has a tendency to use SSE in this loop. While it
- * successfully avoids swapping (as MUL overwrites EAX and EDX), it
- * slows it down because instead of free register swap shifts, it
- * must use pshufd and punpckl/hd.
+ * Does a 32-bit to 64-bit long multiply.
+ *
+ * Wraps __emulu on MSVC x86 because it tends to call __allmul when it doesn't
+ * need to (but it shouldn't need to anyways, it is about 7 instructions to do
+ * a 64x64 multiply...). Since we know that this will _always_ emit MULL, we
+ * use that instead of the normal method.
  *
- * To prevent this, we use this attribute to shut off SSE.
+ * If you are compiling for platforms like Thumb-1 and don't have a better option,
+ * you may also want to write your own long multiply routine here.
+ *
+ * XXH_FORCE_INLINE xxh_u64 XXH_mult32to64(xxh_u64 x, xxh_u64 y)
+ * {
+ *    return (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF);
+ * }
+ */
+#if defined(_MSC_VER) && defined(_M_IX86)
+#    include <intrin.h>
+#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
+#else
+/*
+ * Downcast + upcast is usually better than masking on older compilers like
+ * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
+ *
+ * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
+ * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
  */
-#if defined(__GNUC__) && !defined(__clang__) && defined(__i386__)
-__attribute__((__target__("no-sse")))
+#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
 #endif
+
+/*
+ * Calculates a 64->128-bit long multiply.
+ *
+ * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.
+ */
 static XXH128_hash_t
 XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
 {
@@ -287,9 +515,9 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
      *
      * Usually.
      *
-     * Despite being a 32-bit platform, Clang (and emscripten) define this
-     * type despite not having the arithmetic for it. This results in a
-     * laggy compiler builtin call which calculates a full 128-bit multiply.
+     * Despite being a 32-bit platform, Clang (and emscripten) define this type
+     * despite not having the arithmetic for it. This results in a laggy
+     * compiler builtin call which calculates a full 128-bit multiply.
      * In that case it is best to use the portable one.
      * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
      */
@@ -322,29 +550,30 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
     /*
      * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
      *
-     * This is a fast and simple grade school multiply, which is shown
-     * below with base 10 arithmetic instead of base 0x100000000.
+     * This is a fast and simple grade school multiply, which is shown below
+     * with base 10 arithmetic instead of base 0x100000000.
      *
      *           9 3 // D2 lhs = 93
      *         x 7 5 // D2 rhs = 75
      *     ----------
-     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10)
-     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10)
-     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10)
-     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10)
+     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
+     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
+     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
+     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
      *     ---------
-     *         2 7 | // D2 cross  = (15 / 10) + (45 % 10) + 21
-     *     + 6 7 | | // D2 upper  = (27 / 10) + (45 / 10) + 63
+     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
+     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
      *     ---------
-     *       6 9 7 5
+     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
      *
      * The reasons for adding the products like this are:
      *  1. It avoids manual carry tracking. Just like how
-     *     (9 * 9) + 9 + 9 = 99, the same applies with this for
-     *     UINT64_MAX. This avoids a lot of complexity.
+     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
+     *     This avoids a lot of complexity.
      *
      *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
-     *     instruction available in ARMv6+ A32/T32, which is shown below:
+     *     instruction available in ARM's Digital Signal Processing extension
+     *     in 32-bit ARMv6 and later, which is shown below:
      *
      *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
      *         {
@@ -353,12 +582,12 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
      *             *RdHi = (xxh_u32)(product >> 32);
      *         }
      *
-     *     This instruction was designed for efficient long multiplication,
-     *     and allows this to be calculated in only 4 instructions which
-     *     is comparable to some 64-bit ALUs.
+     *     This instruction was designed for efficient long multiplication, and
+     *     allows this to be calculated in only 4 instructions at speeds
+     *     comparable to some 64-bit ALUs.
      *
-     *  3. It isn't terrible on other platforms. Usually this will be
-     *     a couple of 32-bit ADD/ADCs.
+     *  3. It isn't terrible on other platforms. Usually this will be a couple
+     *     of 32-bit ADD/ADCs.
      */
 
     /* First calculate all of the cross products. */
@@ -378,17 +607,11 @@ XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
 }
 
 /*
- * We want to keep the attribute here because a target switch
- * disables inlining.
- *
  * Does a 64-bit to 128-bit multiply, then XOR folds it.
- * The reason for the separate function is to prevent passing
- * too many structs around by value. This will hopefully inline
- * the multiply, but we don't force it.
+ *
+ * The reason for the separate function is to prevent passing too many structs
+ * around by value. This will hopefully inline the multiply, but we don't force it.
  */
-#if defined(__GNUC__) && !defined(__clang__) && defined(__i386__)
-__attribute__((__target__("no-sse")))
-#endif
 static xxh_u64
 XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
 {
@@ -396,32 +619,78 @@ XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
     return product.low64 ^ product.high64;
 }
 
+/* Seems to produce slightly better code on GCC for some reason. */
+XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
+{
+    XXH_ASSERT(0 <= shift && shift < 64);
+    return v64 ^ (v64 >> shift);
+}
 
+/*
+ * We don't need to (or want to) mix as much as XXH64.
+ *
+ * Short hashes are more evenly distributed, so it isn't necessary.
+ */
 static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
 {
-    h64 ^= h64 >> 37;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
+    h64 = XXH_xorshift64(h64, 37);
+    h64 *= 0x165667919E3779F9ULL;
+    h64 = XXH_xorshift64(h64, 32);
     return h64;
 }
 
 
 /* ==========================================
  * Short keys
- * ========================================== */
+ * ==========================================
+ * One of the shortcomings of XXH32 and XXH64 was that their performance was
+ * sub-optimal on short lengths. It used an iterative algorithm which strongly
+ * favored lengths that were a multiple of 4 or 8.
+ *
+ * Instead of iterating over individual inputs, we use a set of single shot
+ * functions which piece together a range of lengths and operate in constant time.
+ *
+ * Additionally, the number of multiplies has been significantly reduced. This
+ * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
+ *
+ * Depending on the platform, this may or may not be faster than XXH32, but it
+ * is almost guaranteed to be faster than XXH64.
+ */
 
+/*
+ * At very short lengths, there isn't enough input to fully hide secrets, or use
+ * the entire secret.
+ *
+ * There is also only a limited amount of mixing we can do before significantly
+ * impacting performance.
+ *
+ * Therefore, we use different sections of the secret and always mix two secret
+ * samples with an XOR. This should have no effect on performance on the
+ * seedless or withSeed variants because everything _should_ be constant folded
+ * by modern compilers.
+ *
+ * The XOR mixing hides individual parts of the secret and increases entropy.
+ *
+ * This adds an extra layer of strength for custom secrets.
+ */
 XXH_FORCE_INLINE XXH64_hash_t
 XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(1 <= len && len <= 3);
     XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
+     */
     {   xxh_u8 const c1 = input[0];
         xxh_u8 const c2 = input[len >> 1];
         xxh_u8 const c3 = input[len - 1];
-        xxh_u32  const combined = ((xxh_u32)c1) | (((xxh_u32)c2) << 8) | (((xxh_u32)c3) << 16) | (((xxh_u32)len) << 24);
-        xxh_u64  const keyed = (xxh_u64)combined ^ (XXH_readLE32(secret) + seed);
-        xxh_u64  const mixed = keyed * PRIME64_1;
+        xxh_u32 const combined = ((xxh_u32)c1<<16) | (((xxh_u32)c2) << 24) | (((xxh_u32)c3) << 0) | (((xxh_u32)len) << 8);
+        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
+        xxh_u64 const mixed = keyed * PRIME64_1;
         return XXH3_avalanche(mixed);
     }
 }
@@ -431,13 +700,19 @@ XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_h
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
-    XXH_ASSERT(4 <= len && len <= 8);
-    {   xxh_u32 const input_lo = XXH_readLE32(input);
-        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
-        xxh_u64 const input_64 = input_lo | ((xxh_u64)input_hi << 32);
-        xxh_u64 const keyed = input_64 ^ (XXH_readLE64(secret) + seed);
-        xxh_u64 const mix64 = len + ((keyed ^ (keyed >> 51)) * PRIME32_1);
-        return XXH3_avalanche((mix64 ^ (mix64 >> 47)) * PRIME64_2);
+    XXH_ASSERT(4 <= len && len < 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input1 = XXH_readLE32(input);
+        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
+        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
+        xxh_u64 x = input64 ^ bitflip;
+        /* this mix is inspired by Pelle Evensen's rrmxmx */
+        x ^= XXH_rotl64(x, 49) ^ XXH_rotl64(x, 24);
+        x *= 0x9FB21C651E98DF25ULL;
+        x ^= (x >> 35) + len ;
+        x *= 0x9FB21C651E98DF25ULL;
+        return XXH_xorshift64(x, 28);
     }
 }
 
@@ -446,10 +721,14 @@ XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
-    XXH_ASSERT(9 <= len && len <= 16);
-    {   xxh_u64 const input_lo = XXH_readLE64(input)           ^ (XXH_readLE64(secret)     + seed);
-        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ (XXH_readLE64(secret + 8) - seed);
-        xxh_u64 const acc = len + (input_lo + input_hi) + XXH3_mul128_fold64(input_lo, input_hi);
+    XXH_ASSERT(8 <= len && len <= 16);
+    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
+        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
+        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
+        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
+        xxh_u64 const acc = len
+                          + XXH_swap64(input_lo) + input_hi
+                          + XXH3_mul128_fold64(input_lo, input_hi);
         return XXH3_avalanche(acc);
     }
 }
@@ -458,10 +737,152 @@ XXH_FORCE_INLINE XXH64_hash_t
 XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
 {
     XXH_ASSERT(len <= 16);
-    {   if (len > 8) return XXH3_len_9to16_64b(input, len, secret, seed);
-        if (len >= 4) return XXH3_len_4to8_64b(input, len, secret, seed);
+    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
+        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
         if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
-        return 0;
+        return XXH3_avalanche((PRIME64_1 + seed) ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
+    }
+}
+
+/*
+ * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
+ * multiplication by zero, affecting hashes of lengths 17 to 240.
+ *
+ * However, they are very unlikely.
+ *
+ * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
+ * unseeded non-cryptographic hashes, it does not attempt to defend itself
+ * against specially crafted inputs, only random inputs.
+ *
+ * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
+ * cancelling out the secret is taken an arbitrary number of times (addressed
+ * in XXH3_accumulate_512), this collision is very unlikely with random inputs
+ * and/or proper seeding:
+ *
+ * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
+ * function that is only called up to 16 times per hash with up to 240 bytes of
+ * input.
+ *
+ * This is not too bad for a non-cryptographic hash function, especially with
+ * only 64 bit outputs.
+ *
+ * The 128-bit variant (which trades some speed for strength) is NOT affected
+ * by this, although it is always a good idea to use a proper seed if you care
+ * about strength.
+ */
+XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
+                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
+{
+#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
+  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
+    /*
+     * UGLY HACK:
+     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
+     * slower code.
+     *
+     * By forcing seed64 into a register, we disrupt the cost model and
+     * cause it to scalarize. See `XXH32_round()`
+     *
+     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
+     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
+     * GCC 9.2, despite both emitting scalar code.
+     *
+     * GCC generates much better scalar code than Clang for the rest of XXH3,
+     * which is why finding a more optimal codepath is an interest.
+     */
+    __asm__ ("" : "+r" (seed64));
+#endif
+    {   xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64 const input_hi = XXH_readLE64(input+8);
+        return XXH3_mul128_fold64(
+            input_lo ^ (XXH_readLE64(secret)   + seed64),
+            input_hi ^ (XXH_readLE64(secret+8) - seed64)
+        );
+    }
+}
+
+/* For mid range keys, XXH3 uses a Mum-hash variant. */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                     XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   xxh_u64 acc = len * PRIME64_1;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc += XXH3_mix16B(input+48, secret+96, seed);
+                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
+                }
+                acc += XXH3_mix16B(input+32, secret+64, seed);
+                acc += XXH3_mix16B(input+len-48, secret+80, seed);
+            }
+            acc += XXH3_mix16B(input+16, secret+32, seed);
+            acc += XXH3_mix16B(input+len-32, secret+48, seed);
+        }
+        acc += XXH3_mix16B(input+0, secret+0, seed);
+        acc += XXH3_mix16B(input+len-16, secret+16, seed);
+
+        return XXH3_avalanche(acc);
+    }
+}
+
+#define XXH3_MIDSIZE_MAX 240
+
+XXH_NO_INLINE XXH64_hash_t
+XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    #define XXH3_MIDSIZE_STARTOFFSET 3
+    #define XXH3_MIDSIZE_LASTOFFSET  17
+
+    {   xxh_u64 acc = len * PRIME64_1;
+        int const nbRounds = (int)len / 16;
+        int i;
+        for (i=0; i<8; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
+        }
+        acc = XXH3_avalanche(acc);
+        XXH_ASSERT(nbRounds >= 8);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */ \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
+         * In everywhere else, it uses scalar code.
+         *
+         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
+         * would still be slower than UMAAL (see XXH_mult64to128).
+         *
+         * Unfortunately, Clang doesn't handle the long multiplies properly and
+         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
+         * scalarized into an ugly mess of VMOV.32 instructions.
+         *
+         * This mess is difficult to avoid without turning autovectorization
+         * off completely, but they are usually relatively minor and/or not
+         * worth it to fix.
+         *
+         * This loop is the easiest to fix, as unlike XXH32, this pragma
+         * _actually works_ because it is a loop vectorization instead of an
+         * SLP vectorization.
+         */
+        #pragma clang loop vectorize(disable)
+#endif
+        for (i=8 ; i < nbRounds; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
+        }
+        /* last bytes */
+        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
+        return XXH3_avalanche(acc);
     }
 }
 
@@ -474,6 +895,28 @@ XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_
 
 typedef enum { XXH3_acc_64bits, XXH3_acc_128bits } XXH3_accWidth_e;
 
+/*
+ * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
+ *
+ * It is a hardened version of UMAC, based off of FARSH's implementation.
+ *
+ * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
+ * implementations, and it is ridiculously fast.
+ *
+ * We harden it by mixing the original input to the accumulators as well as the product.
+ *
+ * This means that in the (relatively likely) case of a multiply by zero, the
+ * original input is preserved.
+ *
+ * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
+ * cross-pollination, as otherwise the upper and lower halves would be
+ * essentially independent.
+ *
+ * This doesn't matter on 64-bit hashes since they all get merged together in
+ * the end, so we skip the extra step.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
 XXH_FORCE_INLINE void
 XXH3_accumulate_512(      void* XXH_RESTRICT acc,
                     const void* XXH_RESTRICT input,
@@ -483,46 +926,75 @@ XXH3_accumulate_512(      void* XXH_RESTRICT acc,
 #if (XXH_VECTOR == XXH_AVX2)
 
     XXH_ASSERT((((size_t)acc) & 31) == 0);
-    {   XXH_ALIGN(32) __m256i* const xacc  =       (__m256i *) acc;
-        const         __m256i* const xinput = (const __m256i *) input;  /* not really aligned, just for ptr arithmetic, and because _mm256_loadu_si256() requires this type */
-        const         __m256i* const xsecret = (const __m256i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm256_loadu_si256() requires this type */
+    {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
+        const         __m256i* const xinput  = (const __m256i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
 
         size_t i;
         for (i=0; i < STRIPE_LEN/sizeof(__m256i); i++) {
-            __m256i const data_vec = _mm256_loadu_si256 (xinput+i);
-            __m256i const key_vec = _mm256_loadu_si256 (xsecret+i);
-            __m256i const data_key = _mm256_xor_si256 (data_vec, key_vec);                                  /* uint32 dk[8]  = {d0+k0, d1+k1, d2+k2, d3+k3, ...} */
-            __m256i const product = _mm256_mul_epu32 (data_key, _mm256_shuffle_epi32 (data_key, 0x31));  /* uint64 mul[4] = {dk0*dk1, dk2*dk3, ...} */
+            /* data_vec    = xinput[i]; */
+            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
             if (accWidth == XXH3_acc_128bits) {
-                __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
-                __m256i const sum = _mm256_add_epi64(xacc[i], data_swap);
-                xacc[i]  = _mm256_add_epi64(product, sum);
+                /* xacc[i] += swap(data_vec); */
+                __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
+                __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
+                /* xacc[i] += product; */
+                xacc[i] = _mm256_add_epi64(product, sum);
             } else {  /* XXH3_acc_64bits */
+                /* xacc[i] += data_vec; */
                 __m256i const sum = _mm256_add_epi64(xacc[i], data_vec);
-                xacc[i]  = _mm256_add_epi64(product, sum);
+                /* xacc[i] += product; */
+                xacc[i] = _mm256_add_epi64(product, sum);
             }
     }   }
 
 #elif (XXH_VECTOR == XXH_SSE2)
 
+    /* SSE2 is just a half-scale version of the AVX2 version. */
     XXH_ASSERT((((size_t)acc) & 15) == 0);
-    {   XXH_ALIGN(16) __m128i* const xacc  =       (__m128i *) acc;
-        const         __m128i* const xinput = (const __m128i *) input;  /* not really aligned, just for ptr arithmetic, and because _mm_loadu_si128() requires this type */
-        const         __m128i* const xsecret = (const __m128i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm_loadu_si128() requires this type */
+    {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xinput  = (const __m128i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
 
         size_t i;
         for (i=0; i < STRIPE_LEN/sizeof(__m128i); i++) {
-            __m128i const data_vec = _mm_loadu_si128 (xinput+i);
-            __m128i const key_vec = _mm_loadu_si128 (xsecret+i);
-            __m128i const data_key = _mm_xor_si128 (data_vec, key_vec);                                  /* uint32 dk[8]  = {d0+k0, d1+k1, d2+k2, d3+k3, ...} */
-            __m128i const product = _mm_mul_epu32 (data_key, _mm_shuffle_epi32 (data_key, 0x31));  /* uint64 mul[4] = {dk0*dk1, dk2*dk3, ...} */
+            /* data_vec    = xinput[i]; */
+            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
             if (accWidth == XXH3_acc_128bits) {
+                /* xacc[i] += swap(data_vec); */
                 __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
-                __m128i const sum = _mm_add_epi64(xacc[i], data_swap);
-                xacc[i]  = _mm_add_epi64(product, sum);
+                __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
+                /* xacc[i] += product; */
+                xacc[i] = _mm_add_epi64(product, sum);
             } else {  /* XXH3_acc_64bits */
+                /* xacc[i] += data_vec; */
                 __m128i const sum = _mm_add_epi64(xacc[i], data_vec);
-                xacc[i]  = _mm_add_epi64(product, sum);
+                /* xacc[i] += product; */
+                xacc[i] = _mm_add_epi64(product, sum);
             }
     }   }
 
@@ -537,117 +1009,66 @@ XXH3_accumulate_512(      void* XXH_RESTRICT acc,
 
         size_t i;
         for (i=0; i < STRIPE_LEN / sizeof(uint64x2_t); i++) {
-#if !defined(__aarch64__) && !defined(__arm64__) && defined(__GNUC__) /* ARM32-specific hack */
-            /* vzip on ARMv7 Clang generates a lot of vmovs (technically vorrs) without this.
-             * vzip on 32-bit ARM NEON will overwrite the original register, and I think that Clang
-             * assumes I don't want to destroy it and tries to make a copy. This slows down the code
-             * a lot.
-             * aarch64 not only uses an entirely different syntax, but it requires three
-             * instructions...
-             *    ext    v1.16B, v0.16B, #8    // select high bits because aarch64 can't address them directly
-             *    zip1   v3.2s, v0.2s, v1.2s   // first zip
-             *    zip2   v2.2s, v0.2s, v1.2s   // second zip
-             * ...to do what ARM does in one:
-             *    vzip.32 d0, d1               // Interleave high and low bits and overwrite. */
-
-            /* data_vec = xsecret[i]; */
-            uint8x16_t const data_vec    = vld1q_u8(xinput + (i * 16));
-            /* key_vec  = xsecret[i];  */
-            uint8x16_t const key_vec     = vld1q_u8(xsecret  + (i * 16));
-            /* data_key = data_vec ^ key_vec; */
-            uint32x4_t       data_key;
-
-            if (accWidth == XXH3_acc_64bits) {
-                /* Add first to prevent register swaps */
-                /* xacc[i] += data_vec; */
-                xacc[i] = vaddq_u64 (xacc[i], vreinterpretq_u64_u8(data_vec));
-            } else {  /* XXH3_acc_128bits */
-                /* xacc[i] += swap(data_vec); */
-                /* can probably be optimized better */
-                uint64x2_t const data64 = vreinterpretq_u64_u8(data_vec);
-                uint64x2_t const swapped= vextq_u64(data64, data64, 1);
-                xacc[i] = vaddq_u64 (xacc[i], swapped);
-            }
-
-            data_key = vreinterpretq_u32_u8(veorq_u8(data_vec, key_vec));
-
-            /* Here's the magic. We use the quirkiness of vzip to shuffle data_key in place.
-             * shuffle: data_key[0, 1, 2, 3] = data_key[0, 2, 1, 3] */
-            __asm__("vzip.32 %e0, %f0" : "+w" (data_key));
-            /* xacc[i] += (uint64x2_t) data_key[0, 1] * (uint64x2_t) data_key[2, 3]; */
-            xacc[i] = vmlal_u32(xacc[i], vget_low_u32(data_key), vget_high_u32(data_key));
-
-#else
-            /* On aarch64, vshrn/vmovn seems to be equivalent to, if not faster than, the vzip method. */
-
-            /* data_vec = xsecret[i]; */
-            uint8x16_t const data_vec    = vld1q_u8(xinput + (i * 16));
+            /* data_vec = xinput[i]; */
+            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
             /* key_vec  = xsecret[i];  */
-            uint8x16_t const key_vec     = vld1q_u8(xsecret  + (i * 16));
+            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
             /* data_key = data_vec ^ key_vec; */
-            uint64x2_t const data_key    = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
-            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF); */
-            uint32x2_t const data_key_lo = vmovn_u64  (data_key);
-            /* data_key_hi = (uint32x2_t) (data_key >> 32); */
-            uint32x2_t const data_key_hi = vshrn_n_u64 (data_key, 32);
+            uint64x2_t data_key    = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
+            uint32x2_t data_key_lo, data_key_hi;
             if (accWidth == XXH3_acc_64bits) {
                 /* xacc[i] += data_vec; */
                 xacc[i] = vaddq_u64 (xacc[i], vreinterpretq_u64_u8(data_vec));
             } else {  /* XXH3_acc_128bits */
                 /* xacc[i] += swap(data_vec); */
-                uint64x2_t const data64 = vreinterpretq_u64_u8(data_vec);
-                uint64x2_t const swapped= vextq_u64(data64, data64, 1);
+                uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
+                uint64x2_t const swapped = vextq_u64(data64, data64, 1);
                 xacc[i] = vaddq_u64 (xacc[i], swapped);
             }
+            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (data_key >> 32);
+             * data_key = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
             /* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */
             xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);
 
-#endif
         }
     }
 
 #elif (XXH_VECTOR == XXH_VSX)
-          U64x2* const xacc =        (U64x2*) acc;    /* presumed aligned */
-    U64x2 const* const xinput = (U64x2 const*) input;   /* no alignment restriction */
-    U64x2 const* const xsecret  = (U64x2 const*) secret;    /* no alignment restriction */
-    U64x2 const v32 = { 32,  32 };
-#if XXH_VSX_BE
-    U8x16 const vXorSwap  = { 0x07, 0x16, 0x25, 0x34, 0x43, 0x52, 0x61, 0x70,
-                              0x8F, 0x9E, 0xAD, 0xBC, 0xCB, 0xDA, 0xE9, 0xF8 };
-#endif
+          xxh_u64x2* const xacc     =       (xxh_u64x2*) acc;    /* presumed aligned */
+    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   /* no alignment restriction */
+    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    /* no alignment restriction */
+    xxh_u64x2 const v32 = { 32, 32 };
     size_t i;
-    for (i = 0; i < STRIPE_LEN / sizeof(U64x2); i++) {
+    for (i = 0; i < STRIPE_LEN / sizeof(xxh_u64x2); i++) {
         /* data_vec = xinput[i]; */
+        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
         /* key_vec = xsecret[i]; */
-#if XXH_VSX_BE
-        /* byteswap */
-        U64x2 const data_vec = XXH_vec_revb(vec_vsx_ld(0, xinput + i));
-        U64x2 const key_raw = vec_vsx_ld(0, xsecret + i);
-        /* See comment above. data_key = data_vec ^ swap(xsecret[i]); */
-        U64x2 const data_key = (U64x2)XXH_vec_permxor((U8x16)data_vec, (U8x16)key_raw, vXorSwap);
-#else
-        U64x2 const data_vec = vec_vsx_ld(0, xinput + i);
-        U64x2 const key_vec = vec_vsx_ld(0, xsecret + i);
-        U64x2 const data_key = data_vec ^ key_vec;
-#endif
+        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+        xxh_u64x2 const data_key = data_vec ^ key_vec;
         /* shuffled = (data_key << 32) | (data_key >> 32); */
-        U32x4 const shuffled = (U32x4)vec_rl(data_key, v32);
-        /* product = ((U64x2)data_key & 0xFFFFFFFF) * ((U64x2)shuffled & 0xFFFFFFFF); */
-        U64x2 const product = XXH_vec_mulo((U32x4)data_key, shuffled);
+        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
+        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
+        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
         xacc[i] += product;
 
         if (accWidth == XXH3_acc_64bits) {
             xacc[i] += data_vec;
         } else {  /* XXH3_acc_128bits */
             /* swap high and low halves */
-            U64x2 const data_swapped = vec_xxpermdi(data_vec, data_vec, 2);
+#ifdef __s390x__
+            xxh_u64x2 const data_swapped = vec_permi(data_vec, data_vec, 2);
+#else
+            xxh_u64x2 const data_swapped = vec_xxpermdi(data_vec, data_vec, 2);
+#endif
             xacc[i] += data_swapped;
         }
     }
 
 #else   /* scalar variant of Accumulator - universal */
 
-    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;    /* presumed aligned on 32-bytes boundaries, little hint for the auto-vectorizer */
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; /* presumed aligned */
     const xxh_u8* const xinput = (const xxh_u8*) input;  /* no alignment restriction */
     const xxh_u8* const xsecret  = (const xxh_u8*) secret;   /* no alignment restriction */
     size_t i;
@@ -666,6 +1087,26 @@ XXH3_accumulate_512(      void* XXH_RESTRICT acc,
 #endif
 }
 
+/*
+ * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
+ *
+ * Multiplication isn't perfect, as explained by Google in HighwayHash:
+ *
+ *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
+ *  // varying degrees. In descending order of goodness, bytes
+ *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
+ *  // As expected, the upper and lower bytes are much worse.
+ *
+ * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
+ *
+ * Since our algorithm uses a pseudorandom secret to add some variance into the
+ * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
+ *
+ * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
+ * extraction.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
 XXH_FORCE_INLINE void
 XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 {
@@ -673,7 +1114,9 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 
     XXH_ASSERT((((size_t)acc) & 31) == 0);
     {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
-        const         __m256i* const xsecret = (const __m256i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm256_loadu_si256() requires this argument type */
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
         const __m256i prime32 = _mm256_set1_epi32((int)PRIME32_1);
 
         size_t i;
@@ -687,7 +1130,7 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
             __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
 
             /* xacc[i] *= PRIME32_1; */
-            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, 0x31);
+            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
             __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
             __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
             xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
@@ -698,7 +1141,9 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 
     XXH_ASSERT((((size_t)acc) & 15) == 0);
     {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
-        const         __m128i* const xsecret = (const __m128i *) secret;   /* not really aligned, just for ptr arithmetic, and because _mm_loadu_si128() requires this argument type */
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
         const __m128i prime32 = _mm_set1_epi32((int)PRIME32_1);
 
         size_t i;
@@ -707,12 +1152,12 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
             __m128i const acc_vec     = xacc[i];
             __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
             __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
-            /* xacc[i] ^= xsecret; */
+            /* xacc[i] ^= xsecret[i]; */
             __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
             __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
 
             /* xacc[i] *= PRIME32_1; */
-            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, 0x31);
+            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
             __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
             __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
             xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
@@ -723,80 +1168,91 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 
     XXH_ASSERT((((size_t)acc) & 15) == 0);
 
-    {   uint64x2_t* const xacc =     (uint64x2_t*) acc;
-        uint8_t const* const xsecret = (uint8_t const*) secret;
-        uint32x2_t const prime     = vdup_n_u32 (PRIME32_1);
+    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
+        uint8_t const* xsecret = (uint8_t const*) secret;
+        uint32x2_t prime       = vdup_n_u32 (PRIME32_1);
 
         size_t i;
         for (i=0; i < STRIPE_LEN/sizeof(uint64x2_t); i++) {
-            /* data_vec = xacc[i] ^ (xacc[i] >> 47); */
-            uint64x2_t const   acc_vec  = xacc[i];
-            uint64x2_t const   shifted  = vshrq_n_u64 (acc_vec, 47);
-            uint64x2_t const   data_vec = veorq_u64   (acc_vec, shifted);
-
-            /* key_vec  = xsecret[i]; */
-            uint32x4_t const   key_vec  = vreinterpretq_u32_u8(vld1q_u8(xsecret + (i * 16)));
-            /* data_key = data_vec ^ key_vec; */
-            uint32x4_t const   data_key = veorq_u32   (vreinterpretq_u32_u64(data_vec), key_vec);
-            /* shuffled = { data_key[0, 2], data_key[1, 3] }; */
-            uint32x2x2_t const shuffled = vzip_u32    (vget_low_u32(data_key), vget_high_u32(data_key));
-
-            /* data_key *= PRIME32_1 */
-
-            /* prod_hi = (data_key >> 32) * PRIME32_1; */
-            uint64x2_t const   prod_hi = vmull_u32    (shuffled.val[1], prime);
-            /* xacc[i] = prod_hi << 32; */
-            xacc[i] = vshlq_n_u64(prod_hi, 32);
-            /* xacc[i] += (prod_hi & 0xFFFFFFFF) * PRIME32_1; */
-            xacc[i] = vmlal_u32(xacc[i], shuffled.val[0], prime);
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            uint64x2_t acc_vec  = xacc[i];
+            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
+            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);
+
+            /* xacc[i] ^= xsecret[i]; */
+            uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
+            uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));
+
+            /* xacc[i] *= PRIME32_1 */
+            uint32x2_t data_key_lo, data_key_hi;
+            /* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
+             * xacc[i] = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
+            {   /*
+                 * prod_hi = (data_key >> 32) * PRIME32_1;
+                 *
+                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
+                 * incorrectly "optimize" this:
+                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
+                 *   shifted = vshll_n_u32(tmp, 32);
+                 * to this:
+                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
+                 *   shifted = vshlq_n_u64(tmp, 32);
+                 *
+                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
+                 * for NEON, and it scalarizes two 64-bit multiplies instead.
+                 *
+                 * vmull_u32 has the same timing as vmul_u32, and it avoids
+                 * this bug completely.
+                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
+                 */
+                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
+                /* xacc[i] = prod_hi << 32; */
+                xacc[i] = vshlq_n_u64(prod_hi, 32);
+                /* xacc[i] += (prod_hi & 0xFFFFFFFF) * PRIME32_1; */
+                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
+            }
     }   }
 
 #elif (XXH_VECTOR == XXH_VSX)
 
-          U64x2* const xacc =       (U64x2*) acc;
-    const U64x2* const xsecret = (const U64x2*) secret;
-    /* constants */
-    U64x2 const v32  = { 32, 32 };
-    U64x2 const v47 = { 47, 47 };
-    U32x4 const prime = { PRIME32_1, PRIME32_1, PRIME32_1, PRIME32_1 };
-    size_t i;
-#if XXH_VSX_BE
-    /* endian swap */
-    U8x16 const vXorSwap  = { 0x07, 0x16, 0x25, 0x34, 0x43, 0x52, 0x61, 0x70,
-                              0x8F, 0x9E, 0xAD, 0xBC, 0xCB, 0xDA, 0xE9, 0xF8 };
-#endif
-    for (i = 0; i < STRIPE_LEN / sizeof(U64x2); i++) {
-        U64x2 const acc_vec  = xacc[i];
-        U64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
-        /* key_vec = xsecret[i]; */
-#if XXH_VSX_BE
-        /* swap bytes words */
-        U64x2 const key_raw  = vec_vsx_ld(0, xsecret + i);
-        U64x2 const data_key = (U64x2)XXH_vec_permxor((U8x16)data_vec, (U8x16)key_raw, vXorSwap);
-#else
-        U64x2 const key_vec  = vec_vsx_ld(0, xsecret + i);
-        U64x2 const data_key = data_vec ^ key_vec;
-#endif
-
-        /* data_key *= PRIME32_1 */
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
 
-        /* prod_lo = ((U64x2)data_key & 0xFFFFFFFF) * ((U64x2)prime & 0xFFFFFFFF);  */
-        U64x2 const prod_even  = XXH_vec_mule((U32x4)data_key, prime);
-        /* prod_hi = ((U64x2)data_key >> 32) * ((U64x2)prime >> 32);  */
-        U64x2 const prod_odd  = XXH_vec_mulo((U32x4)data_key, prime);
-        xacc[i] = prod_odd + (prod_even << v32);
-    }
+    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
+        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
+        /* constants */
+        xxh_u64x2 const v32  = { 32, 32 };
+        xxh_u64x2 const v47 = { 47, 47 };
+        xxh_u32x4 const prime = { PRIME32_1, PRIME32_1, PRIME32_1, PRIME32_1 };
+        size_t i;
+        for (i = 0; i < STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            xxh_u64x2 const acc_vec  = xacc[i];
+            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
+
+            /* xacc[i] ^= xsecret[i]; */
+            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+            xxh_u64x2 const data_key = data_vec ^ key_vec;
+
+            /* xacc[i] *= PRIME32_1 */
+            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
+            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
+            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
+            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
+            xacc[i] = prod_odd + (prod_even << v32);
+    }   }
 
 #else   /* scalar variant of Scrambler - universal */
 
-    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned on 32-bytes boundaries, little hint for the auto-vectorizer */
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
     const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
     size_t i;
     XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
     for (i=0; i < ACC_NB; i++) {
         xxh_u64 const key64 = XXH_readLE64(xsecret + 8*i);
         xxh_u64 acc64 = xacc[i];
-        acc64 ^= acc64 >> 47;
+        acc64 = XXH_xorshift64(acc64, 47);
         acc64 ^= key64;
         acc64 *= PRIME32_1;
         xacc[i] = acc64;
@@ -805,9 +1261,15 @@ XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
 #endif
 }
 
-/* assumption : nbStripes will not overflow secret size */
+#define XXH_PREFETCH_DIST 384
+
+/*
+ * XXH3_accumulate()
+ * Loops over XXH3_accumulate_512().
+ * Assumption: nbStripes will not overflow the secret size
+ */
 XXH_FORCE_INLINE void
-XXH3_accumulate(       xxh_u64* XXH_RESTRICT acc,
+XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
                 const xxh_u8* XXH_RESTRICT input,
                 const xxh_u8* XXH_RESTRICT secret,
                       size_t nbStripes,
@@ -815,24 +1277,16 @@ XXH3_accumulate(       xxh_u64* XXH_RESTRICT acc,
 {
     size_t n;
     for (n = 0; n < nbStripes; n++ ) {
+        const xxh_u8* const in = input + n*STRIPE_LEN;
+        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
         XXH3_accumulate_512(acc,
-                            input  + n*STRIPE_LEN,
+                            in,
                             secret + n*XXH_SECRET_CONSUME_RATE,
                             accWidth);
     }
 }
 
-/* note : clang auto-vectorizes well in SS2 mode _if_ this function is `static`,
- *        and doesn't auto-vectorize it at all if it is `FORCE_INLINE`.
- *        However, it auto-vectorizes better AVX2 if it is `FORCE_INLINE`
- *        Pretty much every other modes and compilers prefer `FORCE_INLINE`.
- */
-
-#if defined(__clang__) && (XXH_VECTOR==0) && !defined(__AVX2__) && !defined(__arm__) && !defined(__thumb__)
-static void
-#else
 XXH_FORCE_INLINE void
-#endif
 XXH3_hashLong_internal_loop( xxh_u64* XXH_RESTRICT acc,
                       const xxh_u8* XXH_RESTRICT input, size_t len,
                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
@@ -860,7 +1314,8 @@ XXH3_hashLong_internal_loop( xxh_u64* XXH_RESTRICT acc,
         /* last stripe */
         if (len & (STRIPE_LEN - 1)) {
             const xxh_u8* const p = input + len - STRIPE_LEN;
-#define XXH_SECRET_LASTACC_START 7  /* do not align on 8, so that secret is different from scrambler */
+            /* Do not align on 8, so that the secret is different from the scrambler */
+#define XXH_SECRET_LASTACC_START 7
             XXH3_accumulate_512(acc, p, secret + secretSize - STRIPE_LEN - XXH_SECRET_LASTACC_START, accWidth);
     }   }
 }
@@ -899,19 +1354,27 @@ XXH3_hashLong_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
 
     /* converge into final hash */
     XXH_STATIC_ASSERT(sizeof(acc) == 64);
-#define XXH_SECRET_MERGEACCS_START 11  /* do not align on 8, so that secret is different from accumulator */
+    /* do not align on 8, so that the secret is different from the accumulator */
+#define XXH_SECRET_MERGEACCS_START 11
     XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
     return XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
 }
 
-
-XXH_NO_INLINE XXH64_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
 XXH3_hashLong_64b_defaultSecret(const xxh_u8* XXH_RESTRICT input, size_t len)
 {
     return XXH3_hashLong_internal(input, len, kSecret, sizeof(kSecret));
 }
 
-XXH_NO_INLINE XXH64_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
 XXH3_hashLong_64b_withSecret(const xxh_u8* XXH_RESTRICT input, size_t len,
                              const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
 {
@@ -942,14 +1405,18 @@ XXH_FORCE_INLINE void XXH3_initCustomSecret(xxh_u8* customSecret, xxh_u64 seed64
 }
 
 
-/* XXH3_hashLong_64b_withSeed() :
- * Generate a custom key,
- * based on alteration of default kSecret with the seed,
+/*
+ * XXH3_hashLong_64b_withSeed():
+ * Generate a custom key based on alteration of default kSecret with the seed,
  * and then use this key for long mode hashing.
+ *
  * This operation is decently fast but nonetheless costs a little bit of time.
  * Try to avoid it whenever possible (typically when seed==0).
+ *
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
  */
-XXH_NO_INLINE XXH64_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
+XXH_NO_INLINE XXH64_hash_t
 XXH3_hashLong_64b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
 {
     XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
@@ -958,76 +1425,6 @@ XXH3_hashLong_64b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
     return XXH3_hashLong_internal(input, len, secret, sizeof(secret));
 }
 
-
-XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
-                                 const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
-{
-    xxh_u64 const input_lo = XXH_readLE64(input);
-    xxh_u64 const input_hi = XXH_readLE64(input+8);
-    return XXH3_mul128_fold64(
-               input_lo ^ (XXH_readLE64(secret)   + seed64),
-               input_hi ^ (XXH_readLE64(secret+8) - seed64) );
-}
-
-
-XXH_FORCE_INLINE XXH64_hash_t
-XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
-                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
-                     XXH64_hash_t seed)
-{
-    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
-    XXH_ASSERT(16 < len && len <= 128);
-
-    {   xxh_u64 acc = len * PRIME64_1;
-        if (len > 32) {
-            if (len > 64) {
-                if (len > 96) {
-                    acc += XXH3_mix16B(input+48, secret+96, seed);
-                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
-                }
-                acc += XXH3_mix16B(input+32, secret+64, seed);
-                acc += XXH3_mix16B(input+len-48, secret+80, seed);
-            }
-            acc += XXH3_mix16B(input+16, secret+32, seed);
-            acc += XXH3_mix16B(input+len-32, secret+48, seed);
-        }
-        acc += XXH3_mix16B(input+0, secret+0, seed);
-        acc += XXH3_mix16B(input+len-16, secret+16, seed);
-
-        return XXH3_avalanche(acc);
-    }
-}
-
-#define XXH3_MIDSIZE_MAX 240
-
-XXH_NO_INLINE XXH64_hash_t
-XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
-                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
-                      XXH64_hash_t seed)
-{
-    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
-    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
-
-    #define XXH3_MIDSIZE_STARTOFFSET 3
-    #define XXH3_MIDSIZE_LASTOFFSET  17
-
-    {   xxh_u64 acc = len * PRIME64_1;
-        int const nbRounds = (int)len / 16;
-        int i;
-        for (i=0; i<8; i++) {
-            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
-        }
-        acc = XXH3_avalanche(acc);
-        XXH_ASSERT(nbRounds >= 8);
-        for (i=8 ; i < nbRounds; i++) {
-            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
-        }
-        /* last bytes */
-        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
-        return XXH3_avalanche(acc);
-    }
-}
-
 /* ===   Public entry point   === */
 
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* input, size_t len)
@@ -1042,14 +1439,16 @@ XXH_PUBLIC_API XXH64_hash_t
 XXH3_64bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
 {
     XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
-    /* if an action must be taken should `secret` conditions not be respected,
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
      * it should be done here.
      * For now, it's a contract pre-condition.
-     * Adding a check and a branch here would cost performance at every hash */
-     if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
-     if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
-     if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
-     return XXH3_hashLong_64b_withSecret((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize);
+     * Adding a check and a branch here would cost performance at every hash.
+     */
+    if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
+    if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+    return XXH3_hashLong_64b_withSecret((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize);
 }
 
 XXH_PUBLIC_API XXH64_hash_t
@@ -1152,6 +1551,9 @@ XXH3_consumeStripes( xxh_u64* acc,
     }
 }
 
+/*
+ * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
+ */
 XXH_FORCE_INLINE XXH_errorcode
 XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_e accWidth)
 {
@@ -1171,12 +1573,16 @@ XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_
             state->bufferedSize += (XXH32_hash_t)len;
             return XXH_OK;
         }
-        /* input now > XXH3_INTERNALBUFFER_SIZE */
+        /* input is now > XXH3_INTERNALBUFFER_SIZE */
 
         #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / STRIPE_LEN)
         XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % STRIPE_LEN == 0);   /* clean multiple */
 
-        if (state->bufferedSize) {   /* some input within internal buffer: fill then consume it */
+        /*
+         * There is some input left inside the internal buffer.
+         * Fill it, then consume it.
+         */
+        if (state->bufferedSize) {
             size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
             XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
             input += loadSize;
@@ -1188,7 +1594,7 @@ XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_
             state->bufferedSize = 0;
         }
 
-        /* consume input by full buffer quantities */
+        /* Consume input by full buffer quantities */
         if (input+XXH3_INTERNALBUFFER_SIZE <= bEnd) {
             const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
             do {
@@ -1201,7 +1607,7 @@ XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_
             } while (input<=limit);
         }
 
-        if (input < bEnd) { /* some remaining input input : buffer it */
+        if (input < bEnd) { /* Some remaining input: buffer it */
             XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
             state->bufferedSize = (XXH32_hash_t)(bEnd-input);
         }
@@ -1220,7 +1626,11 @@ XXH3_64bits_update(XXH3_state_t* state, const void* input, size_t len)
 XXH_FORCE_INLINE void
 XXH3_digest_long (XXH64_hash_t* acc, const XXH3_state_t* state, XXH3_accWidth_e accWidth)
 {
-    memcpy(acc, state->acc, sizeof(state->acc));  /* digest locally, state remains unaltered, and can continue ingesting more input afterwards */
+    /*
+     * Digest on a local copy. This way, the state remains unaltered, and it can
+     * continue ingesting more input afterwards.
+     */
+    memcpy(acc, state->acc, sizeof(state->acc));
     if (state->bufferedSize >= STRIPE_LEN) {
         size_t const totalNbStripes = state->bufferedSize / STRIPE_LEN;
         XXH32_hash_t nbStripesSoFar = state->nbStripesSoFar;
@@ -1271,40 +1681,52 @@ XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(1 <= len && len <= 3);
     XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
+     */
     {   xxh_u8 const c1 = input[0];
         xxh_u8 const c2 = input[len >> 1];
         xxh_u8 const c3 = input[len - 1];
-        xxh_u32  const combinedl = ((xxh_u32)c1) + (((xxh_u32)c2) << 8) + (((xxh_u32)c3) << 16) + (((xxh_u32)len) << 24);
-        xxh_u32  const combinedh = XXH_swap32(combinedl);
-        xxh_u64  const keyed_lo = (xxh_u64)combinedl ^ (XXH_readLE32(secret)   + seed);
-        xxh_u64  const keyed_hi = (xxh_u64)combinedh ^ (XXH_readLE32(secret+4) - seed);
-        xxh_u64  const mixedl = keyed_lo * PRIME64_1;
-        xxh_u64  const mixedh = keyed_hi * PRIME64_5;
+        xxh_u32 const combinedl = ((xxh_u32)c1<<16) | (((xxh_u32)c2) << 24) | (((xxh_u32)c3) << 0) | (((xxh_u32)len) << 8);
+        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
+        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
+        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
+        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
+        xxh_u64 const mixedl = keyed_lo * PRIME64_1;
+        xxh_u64 const mixedh = keyed_hi * PRIME64_5;
         XXH128_hash_t const h128 = { XXH3_avalanche(mixedl) /*low64*/, XXH3_avalanche(mixedh) /*high64*/ };
         return h128;
     }
 }
 
-
 XXH_FORCE_INLINE XXH128_hash_t
 XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
 {
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
     XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
     {   xxh_u32 const input_lo = XXH_readLE32(input);
         xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
-        xxh_u64 const input_64_lo = input_lo + ((xxh_u64)input_hi << 32);
-        xxh_u64 const input_64_hi = XXH_swap64(input_64_lo);
-        xxh_u64 const keyed_lo = input_64_lo ^ (XXH_readLE64(secret) + seed);
-        xxh_u64 const keyed_hi = input_64_hi ^ (XXH_readLE64(secret + 8) - seed);
-        xxh_u64 const mix64l1 = len + ((keyed_lo ^ (keyed_lo >> 51)) * PRIME32_1);
-        xxh_u64 const mix64l2 = (mix64l1 ^ (mix64l1 >> 47)) * PRIME64_2;
-        xxh_u64 const mix64h1 = ((keyed_hi ^ (keyed_hi >> 47)) * PRIME64_1) - len;
-        xxh_u64 const mix64h2 = (mix64h1 ^ (mix64h1 >> 43)) * PRIME64_4;
-        {   XXH128_hash_t const h128 = { XXH3_avalanche(mix64l2) /*low64*/, XXH3_avalanche(mix64h2) /*high64*/ };
-            return h128;
-    }   }
+        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
+        xxh_u64 const keyed = input_64 ^ bitflip;
+
+        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
+        XXH128_hash_t m128 = XXH_mult64to128(keyed, PRIME64_1 + (len << 2));
+
+        m128.high64 += (m128.low64 << 1);
+        m128.low64  ^= (m128.high64 >> 3);
+
+        m128.low64   = XXH_xorshift64(m128.low64, 35);
+        m128.low64  *= 0x9FB21C651E98DF25ULL;
+        m128.low64   = XXH_xorshift64(m128.low64, 28);
+        m128.high64  = XXH3_avalanche(m128.high64);
+        return m128;
+    }
 }
 
 XXH_FORCE_INLINE XXH128_hash_t
@@ -1313,15 +1735,66 @@ XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64
     XXH_ASSERT(input != NULL);
     XXH_ASSERT(secret != NULL);
     XXH_ASSERT(9 <= len && len <= 16);
-    {   xxh_u64 const input_lo = XXH_readLE64(input) ^ (XXH_readLE64(secret) + seed);
-        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ (XXH_readLE64(secret+8) - seed);
-        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi, PRIME64_1);
-        xxh_u64 const lenContrib = XXH_mult32to64(len, PRIME32_5);
-        m128.low64 += lenContrib;
-        m128.high64 += input_hi * PRIME64_1;
-        m128.low64  ^= (m128.high64 >> 32);
-        {   XXH128_hash_t h128 = XXH_mult64to128(m128.low64, PRIME64_2);
+    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
+        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
+        xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
+        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, PRIME64_1);
+        /*
+         * Put len in the middle of m128 to ensure that the length gets mixed to
+         * both the low and high bits in the 128x64 multiply below.
+         */
+        m128.low64  += (xxh_u64)(len - 1) << 54;
+        input_hi ^= bitfliph;
+        /*
+         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
+         * add the long product of the low 32 bits of input_hi and PRIME32_2 to
+         * the high 64 bits of m128.
+         *
+         * The best approach to this operation is different on 32-bit and 64-bit.
+         */
+        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
+            /*
+             * 32-bit optimized version, which is more readable.
+             *
+             * On 32-bit, it removes an ADC and delays a dependency between the two
+             * halves of m128.high64, but it generates an extra mask on 64-bit.
+             */
+            m128.high64 += (input_hi & 0xFFFFFFFF00000000) + XXH_mult32to64((xxh_u32)input_hi, PRIME32_2);
+        } else {
+            /*
+             * 64-bit optimized (albeit more confusing) version.
+             *
+             * Uses some properties of addition and multiplication to remove the mask:
+             *
+             * Let:
+             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
+             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
+             *    c = PRIME32_2
+             *
+             *    a + (b * c)
+             * Inverse Property: x + y - x == y
+             *    a + (b * (1 + c - 1))
+             * Distributive Property: x * (y + z) == (x * y) + (x * z)
+             *    a + (b * 1) + (b * (c - 1))
+             * Identity Property: x * 1 == x
+             *    a + b + (b * (c - 1))
+             *
+             * Substitute a, b, and c:
+             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (PRIME32_2 - 1))
+             *
+             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
+             *    input_hi + ((xxh_u64)input_hi.lo * (PRIME32_2 - 1))
+             */
+            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, PRIME32_2 - 1);
+        }
+        /* m128 ^= XXH_swap64(m128 >> 64); */
+        m128.low64  ^= XXH_swap64(m128.high64);
+
+        {   /* 128x64 multiply: h128 = m128 * PRIME64_2; */
+            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, PRIME64_2);
             h128.high64 += m128.high64 * PRIME64_2;
+
             h128.low64   = XXH3_avalanche(h128.low64);
             h128.high64  = XXH3_avalanche(h128.high64);
             return h128;
@@ -1337,52 +1810,18 @@ XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64
     {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
         if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
         if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
-        {   XXH128_hash_t const h128 = { 0, 0 };
+        {   XXH128_hash_t h128;
+            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
+            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
+            h128.low64 = XXH3_avalanche((PRIME64_1 + seed) ^ bitflipl);
+            h128.high64 = XXH3_avalanche((PRIME64_2 - seed) ^ bitfliph);
             return h128;
     }   }
 }
 
-XXH_FORCE_INLINE XXH128_hash_t
-XXH3_hashLong_128b_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
-                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
-{
-    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[ACC_NB] = XXH3_INIT_ACC;
-
-    XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_128bits);
-
-    /* converge into final hash */
-    XXH_STATIC_ASSERT(sizeof(acc) == 64);
-    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
-    {   xxh_u64 const low64 = XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
-        xxh_u64 const high64 = XXH3_mergeAccs(acc, secret + secretSize - sizeof(acc) - XXH_SECRET_MERGEACCS_START, ~((xxh_u64)len * PRIME64_2));
-        XXH128_hash_t const h128 = { low64, high64 };
-        return h128;
-    }
-}
-
-XXH_NO_INLINE XXH128_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
-XXH3_hashLong_128b_defaultSecret(const xxh_u8* input, size_t len)
-{
-    return XXH3_hashLong_128b_internal(input, len, kSecret, sizeof(kSecret));
-}
-
-XXH_NO_INLINE XXH128_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
-XXH3_hashLong_128b_withSecret(const xxh_u8* input, size_t len,
-                              const xxh_u8* secret, size_t secretSize)
-{
-    return XXH3_hashLong_128b_internal(input, len, secret, secretSize);
-}
-
-XXH_NO_INLINE XXH128_hash_t    /* It's important for performance that XXH3_hashLong is not inlined. Not sure why (uop cache maybe ?), but difference is large and easily measurable */
-XXH3_hashLong_128b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
-{
-    XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
-    if (seed == 0) return XXH3_hashLong_128b_defaultSecret(input, len);
-    XXH3_initCustomSecret(secret, seed);
-    return XXH3_hashLong_128b_internal(input, len, secret, sizeof(secret));
-}
-
-
+/*
+ * A bit slower than XXH3_mix16B, but handles multiply by zero better.
+ */
 XXH_FORCE_INLINE XXH128_hash_t
 XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2, const xxh_u8* secret, XXH64_hash_t seed)
 {
@@ -1393,6 +1832,36 @@ XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2, c
     return acc;
 }
 
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   XXH128_hash_t acc;
+        acc.low64 = len * PRIME64_1;
+        acc.high64 = 0;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
+                }
+                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
+            }
+            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
+        }
+        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
+        {   xxh_u64 const low64 = acc.low64 + acc.high64;
+            xxh_u64 const high64 = (acc.low64 * PRIME64_1) + (acc.high64 * PRIME64_4) + ((len - seed) * PRIME64_2);
+            XXH128_hash_t const h128 = { XXH3_avalanche(low64), (XXH64_hash_t)0 - XXH3_avalanche(high64) };
+            return h128;
+        }
+    }
+}
+
 XXH_NO_INLINE XXH128_hash_t
 XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
                        const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
@@ -1426,36 +1895,59 @@ XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
     }
 }
 
-
 XXH_FORCE_INLINE XXH128_hash_t
-XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
-                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
-                      XXH64_hash_t seed)
+XXH3_hashLong_128b_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
+                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
 {
-    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
-    XXH_ASSERT(16 < len && len <= 128);
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[ACC_NB] = XXH3_INIT_ACC;
 
-    {   XXH128_hash_t acc;
-        acc.low64 = len * PRIME64_1;
-        acc.high64 = 0;
-        if (len > 32) {
-            if (len > 64) {
-                if (len > 96) {
-                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
-                }
-                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
-            }
-            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
-        }
-        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
-        {   xxh_u64 const low64 = acc.low64 + acc.high64;
-            xxh_u64 const high64 = (acc.low64 * PRIME64_1) + (acc.high64 * PRIME64_4) + ((len - seed) * PRIME64_2);
-            XXH128_hash_t const h128 = { XXH3_avalanche(low64), (XXH64_hash_t)0 - XXH3_avalanche(high64) };
-            return h128;
-        }
+    XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_128bits);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    {   xxh_u64 const low64 = XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
+        xxh_u64 const high64 = XXH3_mergeAccs(acc, secret + secretSize - sizeof(acc) - XXH_SECRET_MERGEACCS_START, ~((xxh_u64)len * PRIME64_2));
+        XXH128_hash_t const h128 = { low64, high64 };
+        return h128;
     }
 }
 
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_defaultSecret(const xxh_u8* input, size_t len)
+{
+    return XXH3_hashLong_128b_internal(input, len, kSecret, sizeof(kSecret));
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSecret(const xxh_u8* input, size_t len,
+                              const xxh_u8* secret, size_t secretSize)
+{
+    return XXH3_hashLong_128b_internal(input, len, secret, secretSize);
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
+{
+    XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+    if (seed == 0) return XXH3_hashLong_128b_defaultSecret(input, len);
+    XXH3_initCustomSecret(secret, seed);
+    return XXH3_hashLong_128b_internal(input, len, secret, sizeof(secret));
+}
+
+
 XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* input, size_t len)
 {
     if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, kSecret, 0);
@@ -1468,10 +1960,12 @@ XXH_PUBLIC_API XXH128_hash_t
 XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
 {
     XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
-    /* if an action must be taken should `secret` conditions not be respected,
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
      * it should be done here.
      * For now, it's a contract pre-condition.
-     * Adding a check and a branch here would cost performance at every hash */
+     * Adding a check and a branch here would cost performance at every hash.
+     */
      if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
      if (len <= 128) return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
      if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
@@ -1562,7 +2056,7 @@ XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
 
 /* 128-bit utility functions */
 
-#include <string.h>   /* memcmp */
+#include <string.h>   /* memcmp, memcpy */
 
 /* return : 1 is equal, 0 if different */
 XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
@@ -1608,6 +2102,11 @@ XXH128_hashFromCanonical(const XXH128_canonical_t* src)
     return h;
 }
 
+/* Pop our optimization override from above */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC pop_options
+#endif
 
-
-#endif  /* XXH3_H */
+#endif  /* XXH3_H_1397135465 */
diff --git a/GLideN64/src/xxHash/xxhash.c b/GLideN64/src/xxHash/xxhash.c
deleted file mode 100644
index 3f49b7d1..00000000
--- a/GLideN64/src/xxHash/xxhash.c
+++ /dev/null
@@ -1,1110 +0,0 @@
-/*
-*  xxHash - Fast Hash algorithm
-*  Copyright (C) 2012-2016, Yann Collet
-*
-*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions are
-*  met:
-*
-*  * Redistributions of source code must retain the above copyright
-*  notice, this list of conditions and the following disclaimer.
-*  * Redistributions in binary form must reproduce the above
-*  copyright notice, this list of conditions and the following disclaimer
-*  in the documentation and/or other materials provided with the
-*  distribution.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*  You can contact the author at :
-*  - xxHash homepage: http://www.xxhash.com
-*  - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
-
-
-/* since xxhash.c can be included (via XXH_INLINE_ALL),
- * it's good practice to protect it with guard
- * in case of multiples inclusions */
-#ifndef XXHASH_C_01393879
-#define XXHASH_C_01393879
-
-/* *************************************
-*  Tuning parameters
-***************************************/
-/*!XXH_FORCE_MEMORY_ACCESS :
- * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
- * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
- * The below switch allow to select different access method for improved performance.
- * Method 0 (default) : use `memcpy()`. Safe and portable.
- * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
- *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
- * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
- *            It can generate buggy code on targets which do not support unaligned memory accesses.
- *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
- * See http://stackoverflow.com/a/32095106/646947 for details.
- * Prefer these methods in priority order (0 > 1 > 2)
- */
-#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
-#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
-#    define XXH_FORCE_MEMORY_ACCESS 2
-#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
-  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
-#    define XXH_FORCE_MEMORY_ACCESS 1
-#  endif
-#endif
-
-/*!XXH_ACCEPT_NULL_INPUT_POINTER :
- * If input pointer is NULL, xxHash default behavior is to dereference it, triggering a segfault.
- * When this macro is enabled, xxHash actively checks input for null pointer.
- * It it is, result for null input pointers is the same as a null-length input.
- */
-#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
-#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
-#endif
-
-/*!XXH_FORCE_ALIGN_CHECK :
- * This is a minor performance trick, only useful with lots of very small keys.
- * It means : check for aligned/unaligned input.
- * The check costs one initial branch per hash;
- * set it to 0 when the input is guaranteed to be aligned,
- * or when alignment doesn't matter for performance.
- */
-#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
-#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
-#    define XXH_FORCE_ALIGN_CHECK 0
-#  else
-#    define XXH_FORCE_ALIGN_CHECK 1
-#  endif
-#endif
-
-/*!XXH_REROLL:
- * Whether to reroll XXH32_finalize, and XXH64_finalize,
- * instead of using an unrolled jump table/if statement loop.
- *
- * This is automatically defined on -Os/-Oz on GCC and Clang. */
-#ifndef XXH_REROLL
-#  if defined(__OPTIMIZE_SIZE__)
-#    define XXH_REROLL 1
-#  else
-#    define XXH_REROLL 0
-#  endif
-#endif
-
-/* *************************************
-*  Includes & Memory related functions
-***************************************/
-/*! Modify the local functions below should you wish to use some other memory routines
-*   for malloc(), free() */
-#include <stdlib.h>
-static void* XXH_malloc(size_t s) { return malloc(s); }
-static void  XXH_free  (void* p)  { free(p); }
-/*! and for memcpy() */
-#include <string.h>
-static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
-
-#include <limits.h>   /* ULLONG_MAX */
-
-#define XXH_STATIC_LINKING_ONLY
-#include "xxhash.h"
-
-
-/* *************************************
-*  Compiler Specific Options
-***************************************/
-#ifdef _MSC_VER    /* Visual Studio */
-#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
-#  define XXH_FORCE_INLINE static __forceinline
-#  define XXH_NO_INLINE static __declspec(noinline)
-#else
-#  if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
-#    ifdef __GNUC__
-#      define XXH_FORCE_INLINE static inline __attribute__((always_inline))
-#      define XXH_NO_INLINE static __attribute__((noinline))
-#    else
-#      define XXH_FORCE_INLINE static inline
-#      define XXH_NO_INLINE static
-#    endif
-#  else
-#    define XXH_FORCE_INLINE static
-#    define XXH_NO_INLINE static
-#  endif /* __STDC_VERSION__ */
-#endif
-
-
-
-/* *************************************
-*  Debug
-***************************************/
-/* DEBUGLEVEL is expected to be defined externally,
- * typically through compiler command line.
- * Value must be a number. */
-#ifndef DEBUGLEVEL
-#  define DEBUGLEVEL 0
-#endif
-
-#if (DEBUGLEVEL>=1)
-#  include <assert.h>   /* note : can still be disabled with NDEBUG */
-#  define XXH_ASSERT(c)   assert(c)
-#else
-#  define XXH_ASSERT(c)   ((void)0)
-#endif
-
-/* note : use after variable declarations */
-#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }
-
-
-/* *************************************
-*  Basic Types
-***************************************/
-#if !defined (__VMS) \
- && (defined (__cplusplus) \
- || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
-# include <stdint.h>
-  typedef uint8_t  xxh_u8;
-#else
-  typedef unsigned char      xxh_u8;
-#endif
-typedef XXH32_hash_t xxh_u32;
-
-
-/* ===   Memory access   === */
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
-static xxh_u32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-static xxh_u32 XXH_read32(const void* memPtr)
-{
-    xxh_u32 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-
-/* ===   Endianess   === */
-typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
-
-/* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line */
-#ifndef XXH_CPU_LITTLE_ENDIAN
-#  if defined(_WIN32) /* Windows is always little endian */ \
-     || defined(__LITTLE_ENDIAN__) \
-     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
-#    define XXH_CPU_LITTLE_ENDIAN 1
-#  elif defined(__BIG_ENDIAN__) \
-     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
-#    define XXH_CPU_LITTLE_ENDIAN 0
-#  else
-static int XXH_isLittleEndian(void)
-{
-    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };   /* don't use static : performance detrimental  */
-    return one.c[0];
-}
-#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
-#  endif
-#endif
-
-
-
-
-/* ****************************************
-*  Compiler-specific Functions and Macros
-******************************************/
-#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-
-#ifndef __has_builtin
-#  define __has_builtin(x) 0
-#endif
-
-#if !defined(NO_CLANG_BUILTIN) && __has_builtin(__builtin_rotateleft32) && __has_builtin(__builtin_rotateleft64)
-#  define XXH_rotl32 __builtin_rotateleft32
-#  define XXH_rotl64 __builtin_rotateleft64
-/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
-#elif defined(_MSC_VER)
-#  define XXH_rotl32(x,r) _rotl(x,r)
-#  define XXH_rotl64(x,r) _rotl64(x,r)
-#else
-#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
-#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
-#endif
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap32 _byteswap_ulong
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap32 __builtin_bswap32
-#else
-static xxh_u32 XXH_swap32 (xxh_u32 x)
-{
-    return  ((x << 24) & 0xff000000 ) |
-            ((x <<  8) & 0x00ff0000 ) |
-            ((x >>  8) & 0x0000ff00 ) |
-            ((x >> 24) & 0x000000ff );
-}
-#endif
-
-
-/* ***************************
-*  Memory reads
-*****************************/
-typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
-
-XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
-}
-
-static xxh_u32 XXH_readBE32(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
-}
-
-XXH_FORCE_INLINE xxh_u32
-XXH_readLE32_align(const void* ptr, XXH_alignment align)
-{
-    if (align==XXH_unaligned) {
-        return XXH_readLE32(ptr);
-    } else {
-        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
-    }
-}
-
-
-/* *************************************
-*  Misc
-***************************************/
-XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
-
-
-/* *******************************************************************
-*  32-bit hash functions
-*********************************************************************/
-static const xxh_u32 PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
-static const xxh_u32 PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
-static const xxh_u32 PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */
-static const xxh_u32 PRIME32_4 = 0x27D4EB2FU;   /* 0b00100111110101001110101100101111 */
-static const xxh_u32 PRIME32_5 = 0x165667B1U;   /* 0b00010110010101100110011110110001 */
-
-static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
-{
-    acc += input * PRIME32_2;
-    acc  = XXH_rotl32(acc, 13);
-    acc *= PRIME32_1;
-#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
-    /* UGLY HACK:
-     * This inline assembly hack forces acc into a normal register. This is the
-     * only thing that prevents GCC and Clang from autovectorizing the XXH32 loop
-     * (pragmas and attributes don't work for some resason) without globally
-     * disabling SSE4.1.
-     *
-     * The reason we want to avoid vectorization is because despite working on
-     * 4 integers at a time, there are multiple factors slowing XXH32 down on
-     * SSE4:
-     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on newer chips!)
-     *   making it slightly slower to multiply four integers at once compared to four
-     *   integers independently. Even when pmulld was fastest, Sandy/Ivy Bridge, it is
-     *   still not worth it to go into SSE just to multiply unless doing a long operation.
-     *
-     * - Four instructions are required to rotate,
-     *      movqda tmp,  v // not required with VEX encoding
-     *      pslld  tmp, 13 // tmp <<= 13
-     *      psrld  v,   19 // x >>= 19
-     *      por    v,  tmp // x |= tmp
-     *   compared to one for scalar:
-     *      roll   v, 13    // reliably fast across the board
-     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
-     *
-     * - Instruction level parallelism is actually more beneficial here because the
-     *   SIMD actually serializes this operation: While v1 is rotating, v2 can load data,
-     *   while v3 can multiply. SSE forces them to operate together.
-     *
-     * How this hack works:
-     * __asm__(""       // Declare an assembly block but don't declare any instructions
-     *          :       // However, as an Input/Output Operand,
-     *          "+r"    // constrain a read/write operand (+) as a general purpose register (r).
-     *          (acc)   // and set acc as the operand
-     * );
-     *
-     * Because of the 'r', the compiler has promised that seed will be in a
-     * general purpose register and the '+' says that it will be 'read/write',
-     * so it has to assume it has changed. It is like volatile without all the
-     * loads and stores.
-     *
-     * Since the argument has to be in a normal register (not an SSE register),
-     * each time XXH32_round is called, it is impossible to vectorize. */
-    __asm__("" : "+r" (acc));
-#endif
-    return acc;
-}
-
-/* mix all bits */
-static xxh_u32 XXH32_avalanche(xxh_u32 h32)
-{
-    h32 ^= h32 >> 15;
-    h32 *= PRIME32_2;
-    h32 ^= h32 >> 13;
-    h32 *= PRIME32_3;
-    h32 ^= h32 >> 16;
-    return(h32);
-}
-
-#define XXH_get32bits(p) XXH_readLE32_align(p, align)
-
-static xxh_u32
-XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
-{
-#define PROCESS1               \
-    h32 += (*ptr++) * PRIME32_5; \
-    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
-
-#define PROCESS4                         \
-    h32 += XXH_get32bits(ptr) * PRIME32_3; \
-    ptr+=4;                                \
-    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
-
-    /* Compact rerolled version */
-    if (XXH_REROLL) {
-        len &= 15;
-        while (len >= 4) {
-            PROCESS4;
-            len -= 4;
-        }
-        while (len > 0) {
-            PROCESS1;
-            --len;
-        }
-        return XXH32_avalanche(h32);
-    } else {
-         switch(len&15) /* or switch(bEnd - p) */ {
-           case 12:      PROCESS4;
-                         /* fallthrough */
-           case 8:       PROCESS4;
-                         /* fallthrough */
-           case 4:       PROCESS4;
-                         return XXH32_avalanche(h32);
-
-           case 13:      PROCESS4;
-                         /* fallthrough */
-           case 9:       PROCESS4;
-                         /* fallthrough */
-           case 5:       PROCESS4;
-                         PROCESS1;
-                         return XXH32_avalanche(h32);
-
-           case 14:      PROCESS4;
-                         /* fallthrough */
-           case 10:      PROCESS4;
-                         /* fallthrough */
-           case 6:       PROCESS4;
-                         PROCESS1;
-                         PROCESS1;
-                         return XXH32_avalanche(h32);
-
-           case 15:      PROCESS4;
-                         /* fallthrough */
-           case 11:      PROCESS4;
-                         /* fallthrough */
-           case 7:       PROCESS4;
-                         /* fallthrough */
-           case 3:       PROCESS1;
-                         /* fallthrough */
-           case 2:       PROCESS1;
-                         /* fallthrough */
-           case 1:       PROCESS1;
-                         /* fallthrough */
-           case 0:       return XXH32_avalanche(h32);
-        }
-        XXH_ASSERT(0);
-        return h32;   /* reaching this point is deemed impossible */
-    }
-}
-
-XXH_FORCE_INLINE xxh_u32
-XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
-{
-    const xxh_u8* bEnd = input + len;
-    xxh_u32 h32;
-
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-    if (input==NULL) {
-        len=0;
-        bEnd=input=(const xxh_u8*)(size_t)16;
-    }
-#endif
-
-    if (len>=16) {
-        const xxh_u8* const limit = bEnd - 15;
-        xxh_u32 v1 = seed + PRIME32_1 + PRIME32_2;
-        xxh_u32 v2 = seed + PRIME32_2;
-        xxh_u32 v3 = seed + 0;
-        xxh_u32 v4 = seed - PRIME32_1;
-
-        do {
-            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
-            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
-            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
-            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
-        } while (input < limit);
-
-        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
-            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
-    } else {
-        h32  = seed + PRIME32_5;
-    }
-
-    h32 += (xxh_u32)len;
-
-    return XXH32_finalize(h32, input, len&15, align);
-}
-
-
-XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH32_state_t state;
-    XXH32_reset(&state, seed);
-    XXH32_update(&state, (const xxh_u8*)input, len);
-    return XXH32_digest(&state);
-
-#else
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
-            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
-    }   }
-
-    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
-#endif
-}
-
-
-
-/*======   Hash streaming   ======*/
-
-XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
-{
-    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
-{
-    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state));
-    state.v1 = seed + PRIME32_1 + PRIME32_2;
-    state.v2 = seed + PRIME32_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME32_1;
-    /* do not write into reserved, planned to be removed in a future version */
-    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH_errorcode
-XXH32_update(XXH32_state_t* state, const void* input, size_t len)
-{
-    if (input==NULL)
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-        return XXH_OK;
-#else
-        return XXH_ERROR;
-#endif
-
-    {   const xxh_u8* p = (const xxh_u8*)input;
-        const xxh_u8* const bEnd = p + len;
-
-        state->total_len_32 += (XXH32_hash_t)len;
-        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
-
-        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
-            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
-            state->memsize += (XXH32_hash_t)len;
-            return XXH_OK;
-        }
-
-        if (state->memsize) {   /* some data left from previous update */
-            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
-            {   const xxh_u32* p32 = state->mem32;
-                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
-                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
-                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
-                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
-            }
-            p += 16-state->memsize;
-            state->memsize = 0;
-        }
-
-        if (p <= bEnd-16) {
-            const xxh_u8* const limit = bEnd - 16;
-            xxh_u32 v1 = state->v1;
-            xxh_u32 v2 = state->v2;
-            xxh_u32 v3 = state->v3;
-            xxh_u32 v4 = state->v4;
-
-            do {
-                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
-                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
-                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
-                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
-            } while (p<=limit);
-
-            state->v1 = v1;
-            state->v2 = v2;
-            state->v3 = v3;
-            state->v4 = v4;
-        }
-
-        if (p < bEnd) {
-            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
-            state->memsize = (unsigned)(bEnd-p);
-        }
-    }
-
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
-{
-    xxh_u32 h32;
-
-    if (state->large_len) {
-        h32 = XXH_rotl32(state->v1, 1)
-            + XXH_rotl32(state->v2, 7)
-            + XXH_rotl32(state->v3, 12)
-            + XXH_rotl32(state->v4, 18);
-    } else {
-        h32 = state->v3 /* == seed */ + PRIME32_5;
-    }
-
-    h32 += state->total_len_32;
-
-    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
-}
-
-
-/*======   Canonical representation   ======*/
-
-/*! Default XXH result types are basic unsigned 32 and 64 bits.
-*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
-*   These functions allow transformation of hash result into and from its canonical format.
-*   This way, hash values can be written into a file or buffer, remaining comparable across different systems.
-*/
-
-XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
-{
-    return XXH_readBE32(src);
-}
-
-
-#ifndef XXH_NO_LONG_LONG
-
-/* *******************************************************************
-*  64-bit hash functions
-*********************************************************************/
-
-/*======   Memory access   ======*/
-
-typedef XXH64_hash_t xxh_u64;
-
-
-/*! XXH_REROLL_XXH64:
- * Whether to reroll the XXH64_finalize() loop.
- *
- * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a performance gain
- * on 64-bit hosts, as only one jump is required.
- *
- * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit registers,
- * and 64-bit arithmetic needs to be simulated, it isn't beneficial to unroll. The code becomes
- * ridiculously large (the largest function in the binary on i386!), and rerolling it saves
- * anywhere from 3kB to 20kB. It is also slightly faster because it fits into cache better
- * and is more likely to be inlined by the compiler.
- *
- * If XXH_REROLL is defined, this is ignored and the loop is always rerolled. */
-#ifndef XXH_REROLL_XXH64
-#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
-   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
-     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
-     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
-     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
-   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
-#    define XXH_REROLL_XXH64 1
-#  else
-#    define XXH_REROLL_XXH64 0
-#  endif
-#endif /* !defined(XXH_REROLL_XXH64) */
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
-static xxh_u64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-
-static xxh_u64 XXH_read64(const void* memPtr)
-{
-    xxh_u64 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap64 _byteswap_uint64
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap64 __builtin_bswap64
-#else
-static xxh_u64 XXH_swap64 (xxh_u64 x)
-{
-    return  ((x << 56) & 0xff00000000000000ULL) |
-            ((x << 40) & 0x00ff000000000000ULL) |
-            ((x << 24) & 0x0000ff0000000000ULL) |
-            ((x << 8)  & 0x000000ff00000000ULL) |
-            ((x >> 8)  & 0x00000000ff000000ULL) |
-            ((x >> 24) & 0x0000000000ff0000ULL) |
-            ((x >> 40) & 0x000000000000ff00ULL) |
-            ((x >> 56) & 0x00000000000000ffULL);
-}
-#endif
-
-XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
-}
-
-static xxh_u64 XXH_readBE64(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
-}
-
-XXH_FORCE_INLINE xxh_u64
-XXH_readLE64_align(const void* ptr, XXH_alignment align)
-{
-    if (align==XXH_unaligned)
-        return XXH_readLE64(ptr);
-    else
-        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
-}
-
-
-/*======   xxh64   ======*/
-
-static const xxh_u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
-static const xxh_u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
-static const xxh_u64 PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
-static const xxh_u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
-static const xxh_u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */
-
-static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
-{
-    acc += input * PRIME64_2;
-    acc  = XXH_rotl64(acc, 31);
-    acc *= PRIME64_1;
-    return acc;
-}
-
-static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
-{
-    val  = XXH64_round(0, val);
-    acc ^= val;
-    acc  = acc * PRIME64_1 + PRIME64_4;
-    return acc;
-}
-
-static xxh_u64 XXH64_avalanche(xxh_u64 h64)
-{
-    h64 ^= h64 >> 33;
-    h64 *= PRIME64_2;
-    h64 ^= h64 >> 29;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
-    return h64;
-}
-
-
-#define XXH_get64bits(p) XXH_readLE64_align(p, align)
-
-static xxh_u64
-XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
-{
-#define PROCESS1_64            \
-    h64 ^= (*ptr++) * PRIME64_5; \
-    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
-
-#define PROCESS4_64          \
-    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * PRIME64_1; \
-    ptr+=4;                    \
-    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
-
-#define PROCESS8_64 {        \
-    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
-    ptr+=8;                    \
-    h64 ^= k1;               \
-    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
-}
-
-    /* Rerolled version for 32-bit targets is faster and much smaller. */
-    if (XXH_REROLL || XXH_REROLL_XXH64) {
-        len &= 31;
-        while (len >= 8) {
-            PROCESS8_64;
-            len -= 8;
-        }
-        if (len >= 4) {
-            PROCESS4_64;
-            len -= 4;
-        }
-        while (len > 0) {
-            PROCESS1_64;
-            --len;
-        }
-         return  XXH64_avalanche(h64);
-    } else {
-        switch(len & 31) {
-           case 24: PROCESS8_64;
-                         /* fallthrough */
-           case 16: PROCESS8_64;
-                         /* fallthrough */
-           case  8: PROCESS8_64;
-                    return XXH64_avalanche(h64);
-
-           case 28: PROCESS8_64;
-                         /* fallthrough */
-           case 20: PROCESS8_64;
-                         /* fallthrough */
-           case 12: PROCESS8_64;
-                         /* fallthrough */
-           case  4: PROCESS4_64;
-                    return XXH64_avalanche(h64);
-
-           case 25: PROCESS8_64;
-                         /* fallthrough */
-           case 17: PROCESS8_64;
-                         /* fallthrough */
-           case  9: PROCESS8_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 29: PROCESS8_64;
-                         /* fallthrough */
-           case 21: PROCESS8_64;
-                         /* fallthrough */
-           case 13: PROCESS8_64;
-                         /* fallthrough */
-           case  5: PROCESS4_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 26: PROCESS8_64;
-                         /* fallthrough */
-           case 18: PROCESS8_64;
-                         /* fallthrough */
-           case 10: PROCESS8_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 30: PROCESS8_64;
-                         /* fallthrough */
-           case 22: PROCESS8_64;
-                         /* fallthrough */
-           case 14: PROCESS8_64;
-                         /* fallthrough */
-           case  6: PROCESS4_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 27: PROCESS8_64;
-                         /* fallthrough */
-           case 19: PROCESS8_64;
-                         /* fallthrough */
-           case 11: PROCESS8_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    PROCESS1_64;
-                    return XXH64_avalanche(h64);
-
-           case 31: PROCESS8_64;
-                         /* fallthrough */
-           case 23: PROCESS8_64;
-                         /* fallthrough */
-           case 15: PROCESS8_64;
-                         /* fallthrough */
-           case  7: PROCESS4_64;
-                         /* fallthrough */
-           case  3: PROCESS1_64;
-                         /* fallthrough */
-           case  2: PROCESS1_64;
-                         /* fallthrough */
-           case  1: PROCESS1_64;
-                         /* fallthrough */
-           case  0: return XXH64_avalanche(h64);
-        }
-    }
-    /* impossible to reach */
-    XXH_ASSERT(0);
-    return 0;  /* unreachable, but some compilers complain without it */
-}
-
-XXH_FORCE_INLINE xxh_u64
-XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
-{
-    const xxh_u8* bEnd = input + len;
-    xxh_u64 h64;
-
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-    if (input==NULL) {
-        len=0;
-        bEnd=input=(const xxh_u8*)(size_t)32;
-    }
-#endif
-
-    if (len>=32) {
-        const xxh_u8* const limit = bEnd - 32;
-        xxh_u64 v1 = seed + PRIME64_1 + PRIME64_2;
-        xxh_u64 v2 = seed + PRIME64_2;
-        xxh_u64 v3 = seed + 0;
-        xxh_u64 v4 = seed - PRIME64_1;
-
-        do {
-            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
-            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
-            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
-            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
-        } while (input<=limit);
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-
-    } else {
-        h64  = seed + PRIME64_5;
-    }
-
-    h64 += (xxh_u64) len;
-
-    return XXH64_finalize(h64, input, len, align);
-}
-
-
-XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH64_state_t state;
-    XXH64_reset(&state, seed);
-    XXH64_update(&state, (const xxh_u8*)input, len);
-    return XXH64_digest(&state);
-
-#else
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
-            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
-    }   }
-
-    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
-
-#endif
-}
-
-/*======   Hash Streaming   ======*/
-
-XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
-{
-    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
-{
-    XXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state));
-    state.v1 = seed + PRIME64_1 + PRIME64_2;
-    state.v2 = seed + PRIME64_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME64_1;
-     /* do not write into reserved64, might be removed in a future version */
-    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API XXH_errorcode
-XXH64_update (XXH64_state_t* state, const void* input, size_t len)
-{
-    if (input==NULL)
-#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
-        return XXH_OK;
-#else
-        return XXH_ERROR;
-#endif
-
-    {   const xxh_u8* p = (const xxh_u8*)input;
-        const xxh_u8* const bEnd = p + len;
-
-        state->total_len += len;
-
-        if (state->memsize + len < 32) {  /* fill in tmp buffer */
-            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
-            state->memsize += (xxh_u32)len;
-            return XXH_OK;
-        }
-
-        if (state->memsize) {   /* tmp buffer is full */
-            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
-            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
-            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
-            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
-            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
-            p += 32-state->memsize;
-            state->memsize = 0;
-        }
-
-        if (p+32 <= bEnd) {
-            const xxh_u8* const limit = bEnd - 32;
-            xxh_u64 v1 = state->v1;
-            xxh_u64 v2 = state->v2;
-            xxh_u64 v3 = state->v3;
-            xxh_u64 v4 = state->v4;
-
-            do {
-                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
-                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
-                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
-                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
-            } while (p<=limit);
-
-            state->v1 = v1;
-            state->v2 = v2;
-            state->v3 = v3;
-            state->v4 = v4;
-        }
-
-        if (p < bEnd) {
-            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
-            state->memsize = (unsigned)(bEnd-p);
-        }
-    }
-
-    return XXH_OK;
-}
-
-
-XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
-{
-    xxh_u64 h64;
-
-    if (state->total_len >= 32) {
-        xxh_u64 const v1 = state->v1;
-        xxh_u64 const v2 = state->v2;
-        xxh_u64 const v3 = state->v3;
-        xxh_u64 const v4 = state->v4;
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-    } else {
-        h64  = state->v3 /*seed*/ + PRIME64_5;
-    }
-
-    h64 += (xxh_u64) state->total_len;
-
-    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
-}
-
-
-/*====== Canonical representation   ======*/
-
-XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
-{
-    return XXH_readBE64(src);
-}
-
-
-
-/* *********************************************************************
-*  XXH3
-*  New generation hash designed for speed on small keys and vectorization
-************************************************************************ */
-
-#include "xxh3.h"
-
-
-#endif  /* XXH_NO_LONG_LONG */
-
-#endif  /* XXHASH_C_01393879 */
diff --git a/GLideN64/src/xxHash/xxhash.h b/GLideN64/src/xxHash/xxhash.h
index 60435bed..f711b34e 100644
--- a/GLideN64/src/xxHash/xxhash.h
+++ b/GLideN64/src/xxHash/xxhash.h
@@ -1,40 +1,42 @@
 /*
-   xxHash - Extremely Fast Hash algorithm
-   Header File
-   Copyright (C) 2012-2016, Yann Collet.
-
-   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are
-   met:
-
-       * Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
-       * Redistributions in binary form must reproduce the above
-   copyright notice, this list of conditions and the following disclaimer
-   in the documentation and/or other materials provided with the
-   distribution.
-
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-   You can contact the author at :
-   - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
+ * xxHash - Extremely Fast Hash algorithm
+ * Header File
+ * Copyright (C) 2012-present, Yann Collet.
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
 
-/* Notice extracted from xxHash homepage :
+/* TODO: update */
+/* Notice extracted from xxHash homepage:
 
-xxHash is an extremely fast Hash algorithm, running at RAM speed limits.
+xxHash is an extremely fast hash algorithm, running at RAM speed limits.
 It also successfully passes all tests from the SMHasher suite.
 
 Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)
@@ -49,17 +51,19 @@ Lookup3         1.2 GB/s      9       Bob Jenkins
 SuperFastHash   1.2 GB/s      1       Paul Hsieh
 CityHash64      1.05 GB/s    10       Pike & Alakuijala
 FNV             0.55 GB/s     5       Fowler, Noll, Vo
-CRC32           0.43 GB/s    9
+CRC32           0.43 GB/s     9
 MD5-32          0.33 GB/s    10       Ronald L. Rivest
 SHA1-32         0.28 GB/s    10
 
-Note : other CRC32 implementations can be over 40x faster than SMHasher's:
-http://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735
-
 Q.Score is a measure of quality of the hash function.
 It depends on successfully passing SMHasher test set.
 10 is a perfect score.
 
+Note: SMHasher's CRC32 implementation is not the fastest one.
+Other speed-oriented implementations can be faster,
+especially in combination with PCLMUL instruction:
+https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735
+
 A 64-bit version, named XXH64, is available since r35.
 It offers much better speed, but for 64-bit applications only.
 Name     Speed on 64 bits    Speed on 32 bits
@@ -67,40 +71,38 @@ XXH64       13.8 GB/s            1.9 GB/s
 XXH32        6.8 GB/s            6.0 GB/s
 */
 
-#ifndef XXHASH_H_5627135585666179
-#define XXHASH_H_5627135585666179 1
-
 #if defined (__cplusplus)
 extern "C" {
 #endif
 
-
 /* ****************************
-*  Definitions
-******************************/
-#include <stddef.h>   /* size_t */
-typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
-
-
-/* ****************************
- *  API modifier
+ *  INLINE mode
  ******************************/
-/** XXH_INLINE_ALL (and XXH_PRIVATE_API)
- *  This build macro includes xxhash functions in `static` mode
- *  in order to inline them, and remove their symbol from the public list.
- *  Inlining offers great performance improvement on small keys,
- *  and dramatic ones when length is expressed as a compile-time constant.
- *  See https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html .
- *  Methodology :
+/*!
+ * XXH_INLINE_ALL (and XXH_PRIVATE_API)
+ * Use these build macros to inline xxhash into the target unit.
+ * Inlining improves performance on small inputs, especially when the length is
+ * expressed as a compile-time constant:
+ *
+ *      https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
+ *
+ * It also keeps xxHash symbols private to the unit, so they are not exported.
+ *
+ * Usage:
  *     #define XXH_INLINE_ALL
  *     #include "xxhash.h"
- * `xxhash.c` is automatically included.
- *  It's not useful to compile and link it as a separate object.
+ *
+ * Do not compile and link xxhash.o as a separate object, as it is not useful.
  */
-#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
-#  ifndef XXH_STATIC_LINKING_ONLY
-#    define XXH_STATIC_LINKING_ONLY
-#  endif
+#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
+    && !defined(XXH_INLINE_ALL_31684351384)
+   /* this section should be traversed only once */
+#  define XXH_INLINE_ALL_31684351384
+   /* give access to the advanced API, required to compile implementations */
+#  undef XXH_STATIC_LINKING_ONLY   /* avoid macro redef */
+#  define XXH_STATIC_LINKING_ONLY
+   /* make all functions private */
+#  undef XXH_PUBLIC_API
 #  if defined(__GNUC__)
 #    define XXH_PUBLIC_API static __inline __attribute__((unused))
 #  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
@@ -108,10 +110,63 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 #  elif defined(_MSC_VER)
 #    define XXH_PUBLIC_API static __inline
 #  else
-     /* this version may generate warnings for unused static functions */
+     /* note: this version may generate warnings for unused static functions */
 #    define XXH_PUBLIC_API static
 #  endif
-#else
+
+   /*
+    * This part deals with the special case where a unit wants to inline xxHash,
+    * but "xxhash.h" has previously been included without XXH_INLINE_ALL, such
+    * as part of some previously included *.h header file.
+    * Without further action, the new include would just be ignored,
+    * and functions would effectively _not_ be inlined (silent failure).
+    * The following macros solve this situation by prefixing all inlined names,
+    * avoiding naming collision with previous inclusions.
+    */
+#  ifdef XXH_NAMESPACE
+#    error "XXH_INLINE_ALL with XXH_NAMESPACE is not supported"
+     /*
+      * Note: Alternative: #undef all symbols (it's a pretty large list).
+      * Without #error: it compiles, but functions are actually not inlined.
+      */
+#  endif
+#  define XXH_NAMESPACE XXH_INLINE_
+   /*
+    * Some identifiers (enums, type names) are not symbols, but they must
+    * still be renamed to avoid redeclaration.
+    * Alternative solution: do not redeclare them.
+    * However, this requires some #ifdefs, and is a more dispersed action.
+    * Meanwhile, renaming can be achieved in a single block
+    */
+#  define XXH_IPREF(Id)   XXH_INLINE_ ## Id
+#  define XXH_OK XXH_IPREF(XXH_OK)
+#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
+#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
+#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
+#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
+#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
+#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
+#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
+#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
+#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
+#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
+#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
+#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
+   /* Ensure the header is parsed again, even if it was previously included */
+#  undef XXHASH_H_5627135585666179
+#  undef XXHASH_H_STATIC_13879238742
+#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
+
+
+
+/* ****************************************************************
+ *  Stable API
+ *****************************************************************/
+#ifndef XXHASH_H_5627135585666179
+#define XXHASH_H_5627135585666179 1
+
+/* specific declaration modes for Windows */
+#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
 #  if defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
 #    ifdef XXH_EXPORT
 #      define XXH_PUBLIC_API __declspec(dllexport)
@@ -121,18 +176,20 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 #  else
 #    define XXH_PUBLIC_API   /* do nothing */
 #  endif
-#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
+#endif
 
-/*! XXH_NAMESPACE, aka Namespace Emulation :
+/*!
+ * XXH_NAMESPACE, aka Namespace Emulation:
  *
- * If you want to include _and expose_ xxHash functions from within your own library,
- * but also want to avoid symbol collisions with other libraries which may also include xxHash,
+ * If you want to include _and expose_ xxHash functions from within your own
+ * library, but also want to avoid symbol collisions with other libraries which
+ * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix
+ * any public symbol from xxhash library with the value of XXH_NAMESPACE
+ * (therefore, avoid empty or numeric values).
  *
- * you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library
- * with the value of XXH_NAMESPACE (therefore, avoid NULL and numeric values).
- *
- * Note that no change is required within the calling program as long as it includes `xxhash.h` :
- * regular symbol name will be automatically translated by this header.
+ * Note that no change is required within the calling program as long as it
+ * includes `xxhash.h`: Regular symbol names will be automatically translated
+ * by this header.
  */
 #ifdef XXH_NAMESPACE
 #  define XXH_CAT(A,B) A##B
@@ -164,11 +221,18 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 ***************************************/
 #define XXH_VERSION_MAJOR    0
 #define XXH_VERSION_MINOR    7
-#define XXH_VERSION_RELEASE  2
+#define XXH_VERSION_RELEASE  3
 #define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
 XXH_PUBLIC_API unsigned XXH_versionNumber (void);
 
 
+/* ****************************
+*  Definitions
+******************************/
+#include <stddef.h>   /* size_t */
+typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
+
+
 /*-**********************************************************************
 *  32-bit hash
 ************************************************************************/
@@ -185,39 +249,43 @@ XXH_PUBLIC_API unsigned XXH_versionNumber (void);
 #     if ULONG_MAX == 0xFFFFFFFFUL
         typedef unsigned long XXH32_hash_t;
 #     else
-#       error "unsupported platform : need a 32-bit type"
+#       error "unsupported platform: need a 32-bit type"
 #     endif
 #   endif
 #endif
 
-/*! XXH32() :
-    Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
-    The memory between input & input+length must be valid (allocated and read-accessible).
-    "seed" can be used to alter the result predictably.
-    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s */
+/*!
+ * XXH32():
+ *  Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
+ *  The memory between input & input+length must be valid (allocated and read-accessible).
+ *  "seed" can be used to alter the result predictably.
+ *  Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s
+ */
 XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);
 
-/*======   Streaming   ======*/
+/*******   Streaming   *******/
 
 /*
  * Streaming functions generate the xxHash value from an incrememtal input.
  * This method is slower than single-call functions, due to state management.
  * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
  *
- * XXH state must first be allocated, using XXH*_createState() .
+ * An XXH state must first be allocated using `XXH*_createState()`.
  *
- * Start a new hash by initializing state with a seed, using XXH*_reset().
+ * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
  *
- * Then, feed the hash state by calling XXH*_update() as many times as necessary.
- * The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.
+ * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
  *
- * Finally, a hash value can be produced anytime, by using XXH*_digest().
+ * The function returns an error code, with 0 meaning OK, and any other value
+ * meaning there is an error.
+ *
+ * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
  * This function returns the nn-bits hash as an int or long long.
  *
- * It's still possible to continue inserting input into the hash state after a digest,
- * and generate some new hash values later on, by invoking again XXH*_digest().
+ * It's still possible to continue inserting input into the hash state after a
+ * digest, and generate new hash values later on by invoking `XXH*_digest()`.
  *
- * When done, release the state, using XXH*_freeState().
+ * When done, release the state using `XXH*_freeState()`.
  */
 
 typedef struct XXH32_state_s XXH32_state_t;   /* incomplete type */
@@ -229,21 +297,25 @@ XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t
 XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
 XXH_PUBLIC_API XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 
-/* Default return values from XXH functions are basic unsigned 32 and 64 bits.
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
  * This the simplest and fastest format for further post-processing.
- * However, this leaves open the question of what is the order of bytes,
- * since little and big endian conventions will write the same number differently.
  *
- * The canonical representation settles this issue,
- * by mandating big-endian convention,
- * aka, the same convention as human-readable numbers (large digits first).
- * When writing hash values to storage, sending them over a network, or printing them,
- * it's highly recommended to use the canonical representation,
- * to ensure portability across a wider range of systems, present and future.
+ * However, this leaves open the question of what is the order on the byte level,
+ * since little and big endian conventions will store the same number differently.
+ *
+ * The canonical representation settles this issue by mandating big-endian
+ * convention, the same convention as human-readable numbers (large digits first).
  *
- * The following functions allow transformation of hash values into and from canonical format.
+ * When writing hash values to storage, sending them over a network, or printing
+ * them, it's highly recommended to use the canonical representation to ensure
+ * portability across a wider range of systems, present and future.
+ *
+ * The following functions allow transformation of hash values to and from
+ * canonical format.
  */
 
 typedef struct { unsigned char digest[4]; } XXH32_canonical_t;
@@ -265,14 +337,17 @@ XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src
     typedef unsigned long long XXH64_hash_t;
 #endif
 
-/*! XXH64() :
-    Calculate the 64-bit hash of sequence of length "len" stored at memory address "input".
-    "seed" can be used to alter the result predictably.
-    This function runs faster on 64-bit systems, but slower on 32-bit systems (see benchmark).
-*/
+/*!
+ * XXH64():
+ * Returns the 64-bit hash of sequence of length @length stored at memory
+ * address @input.
+ * @seed can be used to alter the result predictably.
+ * This function usually runs faster on 64-bit systems, but slower on 32-bit
+ * systems (see benchmark).
+ */
 XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t length, XXH64_hash_t seed);
 
-/*======   Streaming   ======*/
+/*******   Streaming   *******/
 typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
 XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void);
 XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
@@ -282,7 +357,7 @@ XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t
 XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
 XXH_PUBLIC_API XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 typedef struct { unsigned char digest[8]; } XXH64_canonical_t;
 XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);
 XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);
@@ -290,20 +365,25 @@ XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src
 
 #endif  /* XXH_NO_LONG_LONG */
 
+#endif /* XXHASH_H_5627135585666179 */
 
 
-#ifdef XXH_STATIC_LINKING_ONLY
 
-/* ================================================================================================
-   This section contains declarations which are not guaranteed to remain stable.
-   They may change in future versions, becoming incompatible with a different version of the library.
-   These declarations should only be used with static linking.
-   Never use them in association with dynamic linking !
-=================================================================================================== */
+#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
+#define XXHASH_H_STATIC_13879238742
+/* ****************************************************************************
+ * This section contains declarations which are not guaranteed to remain stable.
+ * They may change in future versions, becoming incompatible with a different
+ * version of the library.
+ * These declarations should only be used with static linking.
+ * Never use them in association with dynamic linking!
+ ***************************************************************************** */
 
-/* These definitions are only present to allow
- * static allocation of XXH state, on stack or in a struct for example.
- * Never **ever** use members directly. */
+/*
+ * These definitions are only present to allow static allocation of an XXH
+ * state, for example, on the stack or in a struct.
+ * Never **ever** access members directly.
+ */
 
 struct XXH32_state_s {
    XXH32_hash_t total_len_32;
@@ -317,7 +397,9 @@ struct XXH32_state_s {
    XXH32_hash_t reserved;   /* never read nor write, might be removed in a future version */
 };   /* typedef'd to XXH32_state_t */
 
-#ifndef XXH_NO_LONG_LONG  /* remove 64-bit support */
+
+#ifndef XXH_NO_LONG_LONG  /* defined when there is no 64-bit support */
+
 struct XXH64_state_s {
    XXH64_hash_t total_len;
    XXH64_hash_t v1;
@@ -329,81 +411,58 @@ struct XXH64_state_s {
    XXH32_hash_t reserved32;  /* required for padding anyway */
    XXH64_hash_t reserved64;  /* never read nor write, might be removed in a future version */
 };   /* typedef'd to XXH64_state_t */
-#endif   /* XXH_NO_LONG_LONG */
 
 
 /*-**********************************************************************
 *  XXH3
 *  New experimental hash
 ************************************************************************/
-#ifndef XXH_NO_LONG_LONG
-
 
-/* ============================================
- * XXH3 is a new hash algorithm,
- * featuring improved speed performance for both small and large inputs.
- * See full speed analysis at : http://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
- * In general, expect XXH3 to run about ~2x faster on large inputs,
- * and >3x faster on small ones, though exact differences depend on platform.
+/* ************************************************************************
+ * XXH3 is a new hash algorithm featuring:
+ *  - Improved speed for both small and large inputs
+ *  - True 64-bit and 128-bit outputs
+ *  - SIMD acceleration
+ *  - Improved 32-bit viability
+ *
+ * Speed analysis methodology is explained here:
+ *
+ *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
+ *
+ * In general, expect XXH3 to run about ~2x faster on large inputs and >3x
+ * faster on small ones compared to XXH64, though exact differences depend on
+ * the platform.
  *
- * The algorithm is portable, will generate the same hash on all platforms.
- * It benefits greatly from vectorization units, but does not require it.
+ * The algorithm is portable: Like XXH32 and XXH64, it generates the same hash
+ * on all platforms.
+ *
+ * It benefits greatly from SIMD and 64-bit arithmetic, but does not require it.
+ *
+ * Almost all 32-bit and 64-bit targets that can run XXH32 smoothly can run
+ * XXH3 at usable speeds, even if XXH64 runs slowly. Further details are
+ * explained in the implementation.
+ *
+ * Optimized implementations are provided for AVX2, SSE2, NEON, POWER8, ZVector,
+ * and scalar targets. This can be controlled with the XXH_VECTOR macro.
  *
  * XXH3 offers 2 variants, _64bits and _128bits.
- * When only 64 bits are needed, prefer calling the _64bits variant :
- * it reduces the amount of mixing, resulting in faster speed on small inputs.
+ * When only 64 bits are needed, prefer calling the _64bits variant, as it
+ * reduces the amount of mixing, resulting in faster speed on small inputs.
+ *
  * It's also generally simpler to manipulate a scalar return type than a struct.
  *
- * The XXH3 algorithm is still considered experimental.
- * Produced results can still change between versions.
- * Results produced by v0.7.x are not comparable with results from v0.7.y .
- * It's nonetheless possible to use XXH3 for ephemeral data (local sessions),
- * but avoid storing values in long-term storage for later reads.
+ * The 128-bit version adds additional strength, but it is slightly slower.
  *
- * The API supports one-shot hashing, streaming mode, and custom secrets.
+ * The XXH3 algorithm is still in development.
+ * The results it produces may still change in future versions.
+ *
+ * Results produced by v0.7.x are not comparable with results from v0.7.y.
+ * However, the API is completely stable, and it can safely be used for
+ * ephemeral data (local sessions).
  *
- * There are still a number of opened questions that community can influence during the experimental period.
- * I'm trying to list a few of them below, though don't consider this list as complete.
- *
- * - 128-bits output type : currently defined as a structure of two 64-bits fields.
- *                          That's because 128-bit values do not exist in C standard.
- *                          Note that it means that, at byte level, result is not identical depending on endianess.
- *                          However, at field level, they are identical on all platforms.
- *                          The canonical representation solves the issue of identical byte-level representation across platforms,
- *                          which is necessary for serialization.
- *                          Q1 : Would there be a better representation for a 128-bit hash result ?
- *                          Q2 : Are the names of the inner 64-bit fields important ? Should they be changed ?
- *
- * - Prototype XXH128() :   XXH128() uses the same arguments as XXH64(), for consistency.
- *                          It means it maps to XXH3_128bits_withSeed().
- *                          This variant is slightly slower than XXH3_128bits(),
- *                          because the seed is now part of the algorithm, and can't be simplified.
- *                          Is that a good idea ?
- *
- * - Seed type for XXH128() : currently, it's a single 64-bit value, like the 64-bit variant.
- *                          It could be argued that it's more logical to offer a 128-bit seed input parameter for a 128-bit hash.
- *                          But 128-bit seed is more difficult to use, since it requires to pass a structure instead of a scalar value.
- *                          Such a variant could either replace current one, or become an additional one.
- *                          Farmhash, for example, offers both variants (the 128-bits seed variant is called `doubleSeed`).
- *                          Follow up question : if both 64-bit and 128-bit seeds are allowed, which variant should be called XXH128 ?
- *
- * - Result for len==0 :    Currently, the result of hashing a zero-length input is always `0`.
- *                          It seems okay as a return value when using "default" secret and seed.
- *                          But is it still fine to return `0` when secret or seed are non-default ?
- *                          Are there use cases which could depend on generating a different hash result for zero-length input when the secret is different ?
- *
- * - Consistency (1) :      Streaming XXH128 uses an XXH3 state, which is the same state as XXH3_64bits().
- *                          It means a 128bit streaming loop must invoke the following symbols :
- *                          XXH3_createState(), XXH3_128bits_reset(), XXH3_128bits_update() (loop), XXH3_128bits_digest(), XXH3_freeState().
- *                          Is that consistent enough ?
- *
- * - Consistency (2) :      The canonical representation of `XXH3_64bits` is provided by existing functions
- *                          XXH64_canonicalFromHash(), and reverse operation XXH64_hashFromCanonical().
- *                          As a mirror, canonical functions for XXH128_hash_t results generated by `XXH3_128bits`
- *                          are XXH128_canonicalFromHash() and XXH128_hashFromCanonical().
- *                          Which means, `XXH3` doesn't appear in the names, because canonical functions operate on a type,
- *                          independently of which algorithm was used to generate that type.
- *                          Is that consistent enough ?
+ * Avoid storing values in long-term storage until the algorithm is finalized.
+ *
+ * The API supports one-shot hashing, streaming mode, and custom secrets.
  */
 
 #ifdef XXH_NAMESPACE
@@ -422,28 +481,32 @@ struct XXH64_state_s {
 #  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
 #endif
 
-/* XXH3_64bits() :
+/* XXH3_64bits():
  * default 64-bit variant, using default secret and default seed of 0.
  * It's the fastest variant. */
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* data, size_t len);
 
-/* XXH3_64bits_withSecret() :
+/*
+ * XXH3_64bits_withSecret():
  * It's possible to provide any blob of bytes as a "secret" to generate the hash.
- * This makes it more difficult for an external actor to prepare an intentional collision.
+ * This makes it more difficult for an external actor to prepare an intentional
+ * collision.
  * The secret *must* be large enough (>= XXH3_SECRET_SIZE_MIN).
  * It should consist of random bytes.
- * Avoid repeating same character, or sequences of bytes,
- * and especially avoid swathes of \0.
+ * Avoid trivial sequences, such as repeating sequences and especially '\0',
+ * as this can cancel out itself.
  * Failure to respect these conditions will result in a poor quality hash.
  */
 #define XXH3_SECRET_SIZE_MIN 136
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
 
-/* XXH3_64bits_withSeed() :
- * This variant generates on the fly a custom secret,
- * based on the default secret, altered using the `seed` value.
+/*
+ * XXH3_64bits_withSeed():
+ * This variant generates a custom secret on the fly based on the default
+ * secret, altered using the `seed` value.
  * While this operation is decently fast, note that it's not completely free.
- * note : seed==0 produces same results as XXH3_64bits() */
+ * Note: seed==0 produces the same results as XXH3_64bits().
+ */
 XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
 
 
@@ -460,14 +523,24 @@ XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, X
 #  define XXH_ALIGN(n)   /* disabled */
 #endif
 
+/* Old GCC versions only accept the attribute after the type in structures. */
+#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
+    && defined(__GNUC__)
+#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
+#else
+#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
+#endif
+
 typedef struct XXH3_state_s XXH3_state_t;
 
 #define XXH3_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */
 #define XXH3_INTERNALBUFFER_SIZE 256
 struct XXH3_state_s {
-   XXH_ALIGN(64) XXH64_hash_t acc[8];
-   XXH_ALIGN(64) unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE];  /* used to store a custom secret generated from the seed. Makes state larger. Design might change */
-   XXH_ALIGN(64) unsigned char buffer[XXH3_INTERNALBUFFER_SIZE];
+   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
+  /* used to store a custom secret generated from the seed. Makes state larger.
+   * Design might change */
+   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
+   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
    XXH32_hash_t bufferedSize;
    XXH32_hash_t nbStripesPerBlock;
    XXH32_hash_t nbStripesSoFar;
@@ -477,30 +550,40 @@ struct XXH3_state_s {
    XXH64_hash_t totalLen;
    XXH64_hash_t seed;
    XXH64_hash_t reserved64;
-   const unsigned char* secret;    /* note : there is some padding after, due to alignment on 64 bytes */
+   /* note: there is some padding after due to alignment on 64 bytes */
+   const unsigned char* secret;
 };   /* typedef'd to XXH3_state_t */
 
-/* Streaming requires state maintenance.
- * This operation costs memory and cpu.
- * As a consequence, streaming is slower than one-shot hashing.
- * For better performance, prefer using one-shot functions whenever possible. */
+#undef XXH_ALIGN_MEMBER
 
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever possible.
+ */
 XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void);
 XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
 XXH_PUBLIC_API void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);
 
 
-/* XXH3_64bits_reset() :
- * initialize with default parameters.
- * result will be equivalent to `XXH3_64bits()`. */
+/*
+ * XXH3_64bits_reset():
+ * Initialize with the default parameters.
+ * The result will be equivalent to `XXH3_64bits()`.
+ */
 XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);
-/* XXH3_64bits_reset_withSeed() :
- * generate a custom secret from `seed`, and store it into state.
- * digest will be equivalent to `XXH3_64bits_withSeed()`. */
+/*
+ * XXH3_64bits_reset_withSeed():
+ * Generate a custom secret from `seed`, and store it into `statePtr`.
+ * digest will be equivalent to `XXH3_64bits_withSeed()`.
+ */
 XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
-/* XXH3_64bits_reset_withSecret() :
- * `secret` is referenced, and must outlive the hash streaming session.
- * secretSize must be >= XXH3_SECRET_SIZE_MIN.
+/*
+ * XXH3_64bits_reset_withSecret():
+ * `secret` is referenced, and must outlive the hash streaming session, so
+ * be careful when using stack arrays.
+ * `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`.
  */
 XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
 
@@ -546,20 +629,27 @@ XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const
 XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);
 
 
-/* Note : for better performance, following functions can be inlined,
- * using XXH_INLINE_ALL */
+/* Note: For better performance, these functions can be inlined using XXH_INLINE_ALL */
 
-/* return : 1 is equal, 0 if different */
+/*!
+ * XXH128_isEqual():
+ * Return: 1 if `h1` and `h2` are equal, 0 if they are not.
+ */
 XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);
 
-/* This comparator is compatible with stdlib's qsort().
- * return : >0 if *h128_1  > *h128_2
- *          <0 if *h128_1  < *h128_2
- *          =0 if *h128_1 == *h128_2  */
+/*!
+ * XXH128_cmp():
+ *
+ * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
+ *
+ * return: >0 if *h128_1  > *h128_2
+ *         <0 if *h128_1  < *h128_2
+ *         =0 if *h128_1 == *h128_2
+ */
 XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2);
 
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 typedef struct { unsigned char digest[16]; } XXH128_canonical_t;
 XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);
 XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);
@@ -567,21 +657,1285 @@ XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t*
 
 #endif  /* XXH_NO_LONG_LONG */
 
+#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
+#  define XXH_IMPLEMENTATION
+#endif
+
+#endif  /* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) */
+
+
+/* ======================================================================== */
+/* ======================================================================== */
+/* ======================================================================== */
+
 
 /*-**********************************************************************
-*  XXH_INLINE_ALL
-************************************************************************/
-#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
-#  include "xxhash.c"   /* include xxhash function bodies as `static`, for inlining */
+ * xxHash implementation
+ *-**********************************************************************
+ * xxHash's implementation used to be found in xxhash.c.
+ *
+ * However, code inlining requires the implementation to be visible to the
+ * compiler, usually within the header.
+ *
+ * As a workaround, xxhash.c used to be included within xxhash.h. This caused
+ * some issues with some build systems, especially ones which treat .c files
+ * as source files.
+ *
+ * Therefore, the implementation is now directly integrated within xxhash.h.
+ * Another small advantage is that xxhash.c is no longer needed in /include.
+ ************************************************************************/
+
+#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
+   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
+#  define XXH_IMPLEM_13a8737387
+
+/* *************************************
+*  Tuning parameters
+***************************************/
+/*!
+ * XXH_FORCE_MEMORY_ACCESS:
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is
+ * safe and portable.
+ *
+ * Unfortunately, on some target/compiler combinations, the generated assembly
+ * is sub-optimal.
+ *
+ * The below switch allow to select a different access method for improved
+ * performance.
+ * Method 0 (default):
+ *     Use `memcpy()`. Safe and portable.
+ * Method 1:
+ *     `__attribute__((packed))` statement. It depends on compiler extensions
+ *     and is therefore not portable.
+ *     This method is safe if your compiler supports it, and *generally* as
+ *     fast or faster than `memcpy`.
+ * Method 2:
+ *     Direct access via cast. This method doesn't depend on the compiler but
+ *     violates the C standard.
+ *     It can generate buggy code on targets which do not support unaligned
+ *     memory accesses.
+ *     But in some circumstances, it's the only known way to get the most
+ *     performance (ie GCC + ARMv6)
+ * Method 3:
+ *     Byteshift. This can generate the best code on old compilers which don't
+ *     inline small `memcpy()` calls, and it might also be faster on big-endian
+ *     systems which lack a native byteswap instruction.
+ * See https://stackoverflow.com/a/32095106/646947 for details.
+ * Prefer these methods in priority order (0 > 1 > 2 > 3)
+ */
+#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
+#    define XXH_FORCE_MEMORY_ACCESS 2
+#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
+  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
+#    define XXH_FORCE_MEMORY_ACCESS 1
+#  endif
 #endif
 
+/*!
+ *XXH_ACCEPT_NULL_INPUT_POINTER:
+ * If the input pointer is NULL, xxHash's default behavior is to dereference it,
+ * triggering a segfault.
+ * When this macro is enabled, xxHash actively checks the input for a null pointer.
+ * If it is, the result for null input pointers is the same as a zero-length input.
+ */
+#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
+#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
+#endif
 
+/*!
+ * XXH_FORCE_ALIGN_CHECK:
+ * This is a minor performance trick, only useful with lots of very small keys.
+ * It means: check for aligned/unaligned input.
+ * The check costs one initial branch per hash;
+ * Set it to 0 when the input is guaranteed to be aligned or when alignment
+ * doesn't matter for performance.
+ *
+ * This option does not affect XXH3.
+ */
+#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
+#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
+#    define XXH_FORCE_ALIGN_CHECK 0
+#  else
+#    define XXH_FORCE_ALIGN_CHECK 1
+#  endif
+#endif
+
+/*!
+ * XXH_NO_INLINE_HINTS:
+ *
+ * By default, xxHash tries to force the compiler to inline almost all internal
+ * functions.
+ *
+ * This can usually improve performance due to reduced jumping and improved
+ * constant folding, but significantly increases the size of the binary which
+ * might not be favorable.
+ *
+ * Additionally, sometimes the forced inlining can be detrimental to performance,
+ * depending on the architecture.
+ *
+ * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
+ * compiler full control on whether to inline or not.
+ *
+ * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using
+ * -fno-inline with GCC or Clang, this will automatically be defined.
+ */
+#ifndef XXH_NO_INLINE_HINTS
+#  if defined(__OPTIMIZE_SIZE__) /* -Os, -Oz */ \
+   || defined(__NO_INLINE__)     /* -O0, -fno-inline */
+#    define XXH_NO_INLINE_HINTS 1
+#  else
+#    define XXH_NO_INLINE_HINTS 0
+#  endif
+#endif
 
-#endif /* XXH_STATIC_LINKING_ONLY */
+/*!
+ * XXH_REROLL:
+ * Whether to reroll XXH32_finalize, and XXH64_finalize,
+ * instead of using an unrolled jump table/if statement loop.
+ *
+ * This is automatically defined on -Os/-Oz on GCC and Clang.
+ */
+#ifndef XXH_REROLL
+#  if defined(__OPTIMIZE_SIZE__)
+#    define XXH_REROLL 1
+#  else
+#    define XXH_REROLL 0
+#  endif
+#endif
 
 
-#if defined (__cplusplus)
+/* *************************************
+*  Includes & Memory related functions
+***************************************/
+/*!
+ * Modify the local functions below should you wish to use some other memory
+ * routines for malloc() and free()
+ */
+#include <stdlib.h>
+static void* XXH_malloc(size_t s) { return malloc(s); }
+static void  XXH_free  (void* p)  { free(p); }
+/*! and for memcpy() */
+#include <string.h>
+static void* XXH_memcpy(void* dest, const void* src, size_t size)
+{
+    return memcpy(dest,src,size);
 }
+
+#include <limits.h>   /* ULLONG_MAX */
+
+
+/* *************************************
+*  Compiler Specific Options
+***************************************/
+#ifdef _MSC_VER /* Visual Studio warning fix */
+#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
 #endif
 
-#endif /* XXHASH_H_5627135585666179 */
+#if XXH_NO_INLINE_HINTS /* disable inlining hints */
+#  define XXH_FORCE_INLINE static
+#  define XXH_NO_INLINE static
+#elif defined(_MSC_VER)    /* Visual Studio */
+#  define XXH_FORCE_INLINE static __forceinline
+#  define XXH_NO_INLINE static __declspec(noinline)
+#else
+#  if defined (__cplusplus) \
+    || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
+#    ifdef __GNUC__
+#      define XXH_FORCE_INLINE static inline __attribute__((always_inline))
+#      define XXH_NO_INLINE static __attribute__((noinline))
+#    else
+#      define XXH_FORCE_INLINE static inline
+#      define XXH_NO_INLINE static
+#    endif
+#  else
+#    define XXH_FORCE_INLINE static
+#    define XXH_NO_INLINE static
+#  endif /* __STDC_VERSION__ */
+#endif
+
+
+
+/* *************************************
+*  Debug
+***************************************/
+/*
+ * DEBUGLEVEL is expected to be defined externally, typically via the compiler's
+ * command line options. The value must be a number.
+ */
+#ifndef DEBUGLEVEL
+#  define DEBUGLEVEL 0
+#endif
+
+#if (DEBUGLEVEL>=1)
+#  include <assert.h>   /* note: can still be disabled with NDEBUG */
+#  define XXH_ASSERT(c)   assert(c)
+#else
+#  define XXH_ASSERT(c)   ((void)0)
+#endif
+
+/* note: use after variable declarations */
+#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }
+
+
+/* *************************************
+*  Basic Types
+***************************************/
+#if !defined (__VMS) \
+ && (defined (__cplusplus) \
+ || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+# include <stdint.h>
+  typedef uint8_t  xxh_u8;
+#else
+  typedef unsigned char      xxh_u8;
+#endif
+typedef XXH32_hash_t xxh_u32;
+
+
+/* ***   Memory access   *** */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE32 and XXH_readBE32.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/*
+ * Force direct memory access. Only works on CPU which support unaligned memory
+ * access in hardware.
+ */
+static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
+static xxh_u32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://stackoverflow.com/a/32095106/646947
+ */
+static xxh_u32 XXH_read32(const void* memPtr)
+{
+    xxh_u32 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+
+/* ***   Endianess   *** */
+typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
+
+/*!
+ * XXH_CPU_LITTLE_ENDIAN:
+ * Defined to 1 if the target is little endian, or 0 if it is big endian.
+ * It can be defined externally, for example on the compiler command line.
+ *
+ * If it is not defined, a runtime check (which is usually constant folded)
+ * is used instead.
+ */
+#ifndef XXH_CPU_LITTLE_ENDIAN
+/*
+ * Try to detect endianness automatically, to avoid the nonstandard behavior
+ * in `XXH_isLittleEndian()`
+ */
+#  if defined(_WIN32) /* Windows is always little endian */ \
+     || defined(__LITTLE_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 1
+#  elif defined(__BIG_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 0
+#  else
+static int XXH_isLittleEndian(void)
+{
+    /*
+     * Nonstandard, but well-defined behavior in practice.
+     * Don't use static: it is detrimental to performance.
+     */
+    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
+    return one.c[0];
+}
+#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
+#  endif
+#endif
+
+
+
+
+/* ****************************************
+*  Compiler-specific Functions and Macros
+******************************************/
+#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+#ifndef __has_builtin
+#  define __has_builtin(x) 0
+#endif
+
+#if !defined(NO_CLANG_BUILTIN) && __has_builtin(__builtin_rotateleft32) \
+                               && __has_builtin(__builtin_rotateleft64)
+#  define XXH_rotl32 __builtin_rotateleft32
+#  define XXH_rotl64 __builtin_rotateleft64
+/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
+#elif defined(_MSC_VER)
+#  define XXH_rotl32(x,r) _rotl(x,r)
+#  define XXH_rotl64(x,r) _rotl64(x,r)
+#else
+#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
+#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
+#endif
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap32 _byteswap_ulong
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap32 __builtin_bswap32
+#else
+static xxh_u32 XXH_swap32 (xxh_u32 x)
+{
+    return  ((x << 24) & 0xff000000 ) |
+            ((x <<  8) & 0x00ff0000 ) |
+            ((x >>  8) & 0x0000ff00 ) |
+            ((x >> 24) & 0x000000ff );
+}
+#endif
+
+
+/* ***************************
+*  Memory reads
+*****************************/
+typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
+
+/*
+ * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
+ *
+ * This is ideal for older compilers which don't inline memcpy.
+ */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u32)bytePtr[1] << 8)
+         | ((xxh_u32)bytePtr[2] << 16)
+         | ((xxh_u32)bytePtr[3] << 24);
+}
+
+XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[3]
+         | ((xxh_u32)bytePtr[2] << 8)
+         | ((xxh_u32)bytePtr[1] << 16)
+         | ((xxh_u32)bytePtr[0] << 24);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
+}
+
+static xxh_u32 XXH_readBE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u32
+XXH_readLE32_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned) {
+        return XXH_readLE32(ptr);
+    } else {
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
+    }
+}
+
+
+/* *************************************
+*  Misc
+***************************************/
+XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
+
+
+/* *******************************************************************
+*  32-bit hash functions
+*********************************************************************/
+static const xxh_u32 PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
+static const xxh_u32 PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
+static const xxh_u32 PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */
+static const xxh_u32 PRIME32_4 = 0x27D4EB2FU;   /* 0b00100111110101001110101100101111 */
+static const xxh_u32 PRIME32_5 = 0x165667B1U;   /* 0b00010110010101100110011110110001 */
+
+static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
+{
+    acc += input * PRIME32_2;
+    acc  = XXH_rotl32(acc, 13);
+    acc *= PRIME32_1;
+#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
+    /*
+     * UGLY HACK:
+     * This inline assembly hack forces acc into a normal register. This is the
+     * only thing that prevents GCC and Clang from autovectorizing the XXH32
+     * loop (pragmas and attributes don't work for some resason) without globally
+     * disabling SSE4.1.
+     *
+     * The reason we want to avoid vectorization is because despite working on
+     * 4 integers at a time, there are multiple factors slowing XXH32 down on
+     * SSE4:
+     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
+     *   newer chips!) making it slightly slower to multiply four integers at
+     *   once compared to four integers independently. Even when pmulld was
+     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
+     *   just to multiply unless doing a long operation.
+     *
+     * - Four instructions are required to rotate,
+     *      movqda tmp,  v // not required with VEX encoding
+     *      pslld  tmp, 13 // tmp <<= 13
+     *      psrld  v,   19 // x >>= 19
+     *      por    v,  tmp // x |= tmp
+     *   compared to one for scalar:
+     *      roll   v, 13    // reliably fast across the board
+     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
+     *
+     * - Instruction level parallelism is actually more beneficial here because
+     *   the SIMD actually serializes this operation: While v1 is rotating, v2
+     *   can load data, while v3 can multiply. SSE forces them to operate
+     *   together.
+     *
+     * How this hack works:
+     * __asm__(""       // Declare an assembly block but don't declare any instructions
+     *          :       // However, as an Input/Output Operand,
+     *          "+r"    // constrain a read/write operand (+) as a general purpose register (r).
+     *          (acc)   // and set acc as the operand
+     * );
+     *
+     * Because of the 'r', the compiler has promised that seed will be in a
+     * general purpose register and the '+' says that it will be 'read/write',
+     * so it has to assume it has changed. It is like volatile without all the
+     * loads and stores.
+     *
+     * Since the argument has to be in a normal register (not an SSE register),
+     * each time XXH32_round is called, it is impossible to vectorize.
+     */
+    __asm__("" : "+r" (acc));
+#endif
+    return acc;
+}
+
+/* mix all bits */
+static xxh_u32 XXH32_avalanche(xxh_u32 h32)
+{
+    h32 ^= h32 >> 15;
+    h32 *= PRIME32_2;
+    h32 ^= h32 >> 13;
+    h32 *= PRIME32_3;
+    h32 ^= h32 >> 16;
+    return(h32);
+}
+
+#define XXH_get32bits(p) XXH_readLE32_align(p, align)
+
+static xxh_u32
+XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define PROCESS1               \
+    h32 += (*ptr++) * PRIME32_5; \
+    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
+
+#define PROCESS4                         \
+    h32 += XXH_get32bits(ptr) * PRIME32_3; \
+    ptr+=4;                                \
+    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
+
+    /* Compact rerolled version */
+    if (XXH_REROLL) {
+        len &= 15;
+        while (len >= 4) {
+            PROCESS4;
+            len -= 4;
+        }
+        while (len > 0) {
+            PROCESS1;
+            --len;
+        }
+        return XXH32_avalanche(h32);
+    } else {
+         switch(len&15) /* or switch(bEnd - p) */ {
+           case 12:      PROCESS4;
+                         /* fallthrough */
+           case 8:       PROCESS4;
+                         /* fallthrough */
+           case 4:       PROCESS4;
+                         return XXH32_avalanche(h32);
+
+           case 13:      PROCESS4;
+                         /* fallthrough */
+           case 9:       PROCESS4;
+                         /* fallthrough */
+           case 5:       PROCESS4;
+                         PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 14:      PROCESS4;
+                         /* fallthrough */
+           case 10:      PROCESS4;
+                         /* fallthrough */
+           case 6:       PROCESS4;
+                         PROCESS1;
+                         PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 15:      PROCESS4;
+                         /* fallthrough */
+           case 11:      PROCESS4;
+                         /* fallthrough */
+           case 7:       PROCESS4;
+                         /* fallthrough */
+           case 3:       PROCESS1;
+                         /* fallthrough */
+           case 2:       PROCESS1;
+                         /* fallthrough */
+           case 1:       PROCESS1;
+                         /* fallthrough */
+           case 0:       return XXH32_avalanche(h32);
+        }
+        XXH_ASSERT(0);
+        return h32;   /* reaching this point is deemed impossible */
+    }
+}
+
+XXH_FORCE_INLINE xxh_u32
+XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
+{
+    const xxh_u8* bEnd = input + len;
+    xxh_u32 h32;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (input==NULL) {
+        len=0;
+        bEnd=input=(const xxh_u8*)(size_t)16;
+    }
+#endif
+
+    if (len>=16) {
+        const xxh_u8* const limit = bEnd - 15;
+        xxh_u32 v1 = seed + PRIME32_1 + PRIME32_2;
+        xxh_u32 v2 = seed + PRIME32_2;
+        xxh_u32 v3 = seed + 0;
+        xxh_u32 v4 = seed - PRIME32_1;
+
+        do {
+            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
+            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
+            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
+            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
+        } while (input < limit);
+
+        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
+            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
+    } else {
+        h32  = seed + PRIME32_5;
+    }
+
+    h32 += (xxh_u32)len;
+
+    return XXH32_finalize(h32, input, len&15, align);
+}
+
+
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH32_state_t state;
+    XXH32_reset(&state, seed);
+    XXH32_update(&state, (const xxh_u8*)input, len);
+    return XXH32_digest(&state);
+
+#else
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
+            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+#endif
+}
+
+
+
+/*******   Hash streaming   *******/
+
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
+{
+    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
+{
+    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME32_1 + PRIME32_2;
+    state.v2 = seed + PRIME32_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME32_1;
+    /* do not write into reserved, planned to be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH_errorcode
+XXH32_update(XXH32_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len_32 += (XXH32_hash_t)len;
+        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
+
+        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
+            state->memsize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* some data left from previous update */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
+            {   const xxh_u32* p32 = state->mem32;
+                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
+                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
+                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
+                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
+            }
+            p += 16-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p <= bEnd-16) {
+            const xxh_u8* const limit = bEnd - 16;
+            xxh_u32 v1 = state->v1;
+            xxh_u32 v2 = state->v2;
+            xxh_u32 v3 = state->v3;
+            xxh_u32 v4 = state->v4;
+
+            do {
+                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
+                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
+                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
+                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
+            } while (p<=limit);
+
+            state->v1 = v1;
+            state->v2 = v2;
+            state->v3 = v3;
+            state->v4 = v4;
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
+{
+    xxh_u32 h32;
+
+    if (state->large_len) {
+        h32 = XXH_rotl32(state->v1, 1)
+            + XXH_rotl32(state->v2, 7)
+            + XXH_rotl32(state->v3, 12)
+            + XXH_rotl32(state->v4, 18);
+    } else {
+        h32 = state->v3 /* == seed */ + PRIME32_5;
+    }
+
+    h32 += state->total_len_32;
+
+    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
+}
+
+
+/*******   Canonical representation   *******/
+
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
+ *
+ * The canonical representation uses big endian convention, the same convention
+ * as human-readable numbers (large digits first).
+ *
+ * This way, hash values can be written into a file or buffer, remaining
+ * comparable across different systems.
+ *
+ * The following functions allow transformation of hash values to and from their
+ * canonical format.
+ */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
+{
+    return XXH_readBE32(src);
+}
+
+
+#ifndef XXH_NO_LONG_LONG
+
+/* *******************************************************************
+*  64-bit hash functions
+*********************************************************************/
+
+/*******   Memory access   *******/
+
+typedef XXH64_hash_t xxh_u64;
+
+
+/*!
+ * XXH_REROLL_XXH64:
+ * Whether to reroll the XXH64_finalize() loop.
+ *
+ * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a
+ * performance gain on 64-bit hosts, as only one jump is required.
+ *
+ * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit
+ * registers, and 64-bit arithmetic needs to be simulated, it isn't beneficial
+ * to unroll. The code becomes ridiculously large (the largest function in the
+ * binary on i386!), and rerolling it saves anywhere from 3kB to 20kB. It is
+ * also slightly faster because it fits into cache better and is more likely
+ * to be inlined by the compiler.
+ *
+ * If XXH_REROLL is defined, this is ignored and the loop is always rerolled.
+ */
+#ifndef XXH_REROLL_XXH64
+#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
+   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
+     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
+     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
+     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
+   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
+#    define XXH_REROLL_XXH64 1
+#  else
+#    define XXH_REROLL_XXH64 0
+#  endif
+#endif /* !defined(XXH_REROLL_XXH64) */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE64 and XXH_readBE64.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer, but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
+static xxh_u64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://stackoverflow.com/a/32095106/646947
+ */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    xxh_u64 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap64 _byteswap_uint64
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap64 __builtin_bswap64
+#else
+static xxh_u64 XXH_swap64 (xxh_u64 x)
+{
+    return  ((x << 56) & 0xff00000000000000ULL) |
+            ((x << 40) & 0x00ff000000000000ULL) |
+            ((x << 24) & 0x0000ff0000000000ULL) |
+            ((x << 8)  & 0x000000ff00000000ULL) |
+            ((x >> 8)  & 0x00000000ff000000ULL) |
+            ((x >> 24) & 0x0000000000ff0000ULL) |
+            ((x >> 40) & 0x000000000000ff00ULL) |
+            ((x >> 56) & 0x00000000000000ffULL);
+}
+#endif
+
+
+/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u64)bytePtr[1] << 8)
+         | ((xxh_u64)bytePtr[2] << 16)
+         | ((xxh_u64)bytePtr[3] << 24)
+         | ((xxh_u64)bytePtr[4] << 32)
+         | ((xxh_u64)bytePtr[5] << 40)
+         | ((xxh_u64)bytePtr[6] << 48)
+         | ((xxh_u64)bytePtr[7] << 56);
+}
+
+XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[7]
+         | ((xxh_u64)bytePtr[6] << 8)
+         | ((xxh_u64)bytePtr[5] << 16)
+         | ((xxh_u64)bytePtr[4] << 24)
+         | ((xxh_u64)bytePtr[3] << 32)
+         | ((xxh_u64)bytePtr[2] << 40)
+         | ((xxh_u64)bytePtr[1] << 48)
+         | ((xxh_u64)bytePtr[0] << 56);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
+}
+
+static xxh_u64 XXH_readBE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u64
+XXH_readLE64_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return XXH_readLE64(ptr);
+    else
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
+}
+
+
+/*******   xxh64   *******/
+
+static const xxh_u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
+static const xxh_u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
+static const xxh_u64 PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
+static const xxh_u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
+static const xxh_u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */
+
+static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
+{
+    acc += input * PRIME64_2;
+    acc  = XXH_rotl64(acc, 31);
+    acc *= PRIME64_1;
+    return acc;
+}
+
+static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
+{
+    val  = XXH64_round(0, val);
+    acc ^= val;
+    acc  = acc * PRIME64_1 + PRIME64_4;
+    return acc;
+}
+
+static xxh_u64 XXH64_avalanche(xxh_u64 h64)
+{
+    h64 ^= h64 >> 33;
+    h64 *= PRIME64_2;
+    h64 ^= h64 >> 29;
+    h64 *= PRIME64_3;
+    h64 ^= h64 >> 32;
+    return h64;
+}
+
+
+#define XXH_get64bits(p) XXH_readLE64_align(p, align)
+
+static xxh_u64
+XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define PROCESS1_64            \
+    h64 ^= (*ptr++) * PRIME64_5; \
+    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
+
+#define PROCESS4_64          \
+    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * PRIME64_1; \
+    ptr+=4;                    \
+    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
+
+#define PROCESS8_64 {        \
+    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
+    ptr+=8;                    \
+    h64 ^= k1;               \
+    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
+}
+
+    /* Rerolled version for 32-bit targets is faster and much smaller. */
+    if (XXH_REROLL || XXH_REROLL_XXH64) {
+        len &= 31;
+        while (len >= 8) {
+            PROCESS8_64;
+            len -= 8;
+        }
+        if (len >= 4) {
+            PROCESS4_64;
+            len -= 4;
+        }
+        while (len > 0) {
+            PROCESS1_64;
+            --len;
+        }
+         return  XXH64_avalanche(h64);
+    } else {
+        switch(len & 31) {
+           case 24: PROCESS8_64;
+                         /* fallthrough */
+           case 16: PROCESS8_64;
+                         /* fallthrough */
+           case  8: PROCESS8_64;
+                    return XXH64_avalanche(h64);
+
+           case 28: PROCESS8_64;
+                         /* fallthrough */
+           case 20: PROCESS8_64;
+                         /* fallthrough */
+           case 12: PROCESS8_64;
+                         /* fallthrough */
+           case  4: PROCESS4_64;
+                    return XXH64_avalanche(h64);
+
+           case 25: PROCESS8_64;
+                         /* fallthrough */
+           case 17: PROCESS8_64;
+                         /* fallthrough */
+           case  9: PROCESS8_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 29: PROCESS8_64;
+                         /* fallthrough */
+           case 21: PROCESS8_64;
+                         /* fallthrough */
+           case 13: PROCESS8_64;
+                         /* fallthrough */
+           case  5: PROCESS4_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 26: PROCESS8_64;
+                         /* fallthrough */
+           case 18: PROCESS8_64;
+                         /* fallthrough */
+           case 10: PROCESS8_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 30: PROCESS8_64;
+                         /* fallthrough */
+           case 22: PROCESS8_64;
+                         /* fallthrough */
+           case 14: PROCESS8_64;
+                         /* fallthrough */
+           case  6: PROCESS4_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 27: PROCESS8_64;
+                         /* fallthrough */
+           case 19: PROCESS8_64;
+                         /* fallthrough */
+           case 11: PROCESS8_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 31: PROCESS8_64;
+                         /* fallthrough */
+           case 23: PROCESS8_64;
+                         /* fallthrough */
+           case 15: PROCESS8_64;
+                         /* fallthrough */
+           case  7: PROCESS4_64;
+                         /* fallthrough */
+           case  3: PROCESS1_64;
+                         /* fallthrough */
+           case  2: PROCESS1_64;
+                         /* fallthrough */
+           case  1: PROCESS1_64;
+                         /* fallthrough */
+           case  0: return XXH64_avalanche(h64);
+        }
+    }
+    /* impossible to reach */
+    XXH_ASSERT(0);
+    return 0;  /* unreachable, but some compilers complain without it */
+}
+
+XXH_FORCE_INLINE xxh_u64
+XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
+{
+    const xxh_u8* bEnd = input + len;
+    xxh_u64 h64;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (input==NULL) {
+        len=0;
+        bEnd=input=(const xxh_u8*)(size_t)32;
+    }
+#endif
+
+    if (len>=32) {
+        const xxh_u8* const limit = bEnd - 32;
+        xxh_u64 v1 = seed + PRIME64_1 + PRIME64_2;
+        xxh_u64 v2 = seed + PRIME64_2;
+        xxh_u64 v3 = seed + 0;
+        xxh_u64 v4 = seed - PRIME64_1;
+
+        do {
+            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
+            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
+            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
+            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
+        } while (input<=limit);
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+
+    } else {
+        h64  = seed + PRIME64_5;
+    }
+
+    h64 += (xxh_u64) len;
+
+    return XXH64_finalize(h64, input, len, align);
+}
+
+
+XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH64_state_t state;
+    XXH64_reset(&state, seed);
+    XXH64_update(&state, (const xxh_u8*)input, len);
+    return XXH64_digest(&state);
+
+#else
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
+            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+
+#endif
+}
+
+/*******   Hash Streaming   *******/
+
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
+{
+    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
+{
+    XXH64_state_t state;   /* use a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME64_1 + PRIME64_2;
+    state.v2 = seed + PRIME64_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME64_1;
+     /* do not write into reserved64, might be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH64_update (XXH64_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len += len;
+
+        if (state->memsize + len < 32) {  /* fill in tmp buffer */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
+            state->memsize += (xxh_u32)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* tmp buffer is full */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
+            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
+            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
+            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
+            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
+            p += 32-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p+32 <= bEnd) {
+            const xxh_u8* const limit = bEnd - 32;
+            xxh_u64 v1 = state->v1;
+            xxh_u64 v2 = state->v2;
+            xxh_u64 v3 = state->v3;
+            xxh_u64 v4 = state->v4;
+
+            do {
+                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
+                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
+                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
+                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
+            } while (p<=limit);
+
+            state->v1 = v1;
+            state->v2 = v2;
+            state->v3 = v3;
+            state->v4 = v4;
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
+{
+    xxh_u64 h64;
+
+    if (state->total_len >= 32) {
+        xxh_u64 const v1 = state->v1;
+        xxh_u64 const v2 = state->v2;
+        xxh_u64 const v3 = state->v3;
+        xxh_u64 const v4 = state->v4;
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+    } else {
+        h64  = state->v3 /*seed*/ + PRIME64_5;
+    }
+
+    h64 += (xxh_u64) state->total_len;
+
+    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
+}
+
+
+/******* Canonical representation   *******/
+
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
+{
+    return XXH_readBE64(src);
+}
+
+
+
+/* *********************************************************************
+*  XXH3
+*  New generation hash designed for speed on small keys and vectorization
+************************************************************************ */
+
+#include "xxh3.h"
+
+
+#endif  /* XXH_NO_LONG_LONG */
+
+
+#endif  /* XXH_IMPLEMENTATION */
+
+
+#if defined (__cplusplus)
+}
+#endif
diff --git a/GLideN64/translations/wtl/gliden64_de.Lang b/GLideN64/translations/wtl/gliden64_de.Lang
new file mode 100644
index 00000000..2ca1d3f9
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_de.Lang
@@ -0,0 +1,217 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Deutsch"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# "Video"
+#1001# "Emulation"
+#1002# "Frame-Buffer"
+#1003# "Textur-Verbesserungen"
+#1004# "OSD"
+#1005# "Debuggen"
+#1010# "Einstellungen speichern fr:"
+#1011# "Einstellungen Profil:"
+#1012# "Entfernen"
+#1013# "Standardeinstellungen wiederherstellen"
+#1014# "Speichern und schlieen"
+#1015# "Speichern"
+#1016# "Schlieen"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# "Video"
+#2001# "Vollbild-Auflsung:"
+#2002# "Alle von der Grafikkarte/Monitor untersttzten Auflsungen sollten angezeigt werden.\n[Empfehlung: Die maximale Auflsung des Monitors, auer es gibt Geschwindigkeitprobleme]"
+#2003# "Aktualisierungsrate:"
+#2005# "Fenster-Auflsung:"
+#2006# "Diese Option whlt die Auflsung fr den Fenstermodus aus. Du kannst auch eine benutzerdefinierte Fenstergre eingeben.\n[Empfehlung: 640 x 480, 800 x 600, 1024 x 768, 1280 x 960]"
+#2007# "Seitenverhltnis:"
+#2008# "Diese Einstellung legt das Seitenverhltnis der Ausgabe fest. Alle N64 Spiele untersttzen 4:3. Einige Spiele untersttzen 16:9 innerhalb der Spieleinstellungen. Verwende Strecken um den kompletten Bildschirm ohne schwarze Rnder anzuzeigen.\nVersuche das Spiel passend einzustellen versucht den Betrachtungsraum ohne Strecken anzupassen. Viele Spiele funktionieren gut. Einige nicht."
+#2009# "4:3 (empfohlen)"
+#2010# "16:9"
+#2011# "Strecken"
+#2012# "Versuche das Spiel passend einzustellen"
+#2013# "Aktiviere VSync"
+#2014# "Vertikale Synchronisation, oder VSync, kann die Bildqualitt durch die Synchronisation der Aktualisierungsrate des Spiels mit der Bildwiederholrate des Monitors verbessern. Dies verhindert Bildversatz/Tearing, kann zu Leistungseinbrchen fhren.\n[Empfehlung: Gewhnlich aus, auer es gibt Tearing]"
+#2015# "Threaded Video aktivieren"
+#2016# "Threaded Video kann die Leistung mit schlechten OpenGL-Treibern auf Kosten einer sehr marginalen Eingangsverzgerung, normalerweise weniger als ein halbes Frame, verbessern.\n[Empfehlung: Gewhnlich aus, es sei denn, es gibt Leistungsprobleme]"
+#2017# "Overscan"
+#2018# "Wenn aktiviert, wird das Bild um die in N64 Pixel angegebenen Werte beschnitten. Ntzlich, um schwarze Rnder in einigen Spielen zu entfernen."
+#2019# "NTSC"
+#2020# "PAL"
+#2021# "Antialiasing"
+#2022# "Kein Antialiasing"
+#2023# "Fast Approximate Antialiasing (FXAA)"
+#2024# "Multisample-Antialiasing (MSAA):"
+#2025# "Aus"
+#2026# "Hoch"
+#2027# "GLideN64 bietet zwei Methoden zur Kantenglttung an:\nFast Approximate Antialiasing (FXAA): FXAA ist ein Nachbearbeitungsfilter, der ein anstndiges Ergebnis liefern kann, aber so gut wie MSAA ist. Der Hauptgrund fr die Verwendung von FXAA ist die Verwendung mit N64-Style-Tiefenvergleich. FXAA fgt dem Ausgabebild etwas Unschrfe hinzu, wodurch einige Texturen wie Text mglicherweise schlechter aussehen.\nMultisample-Antialiasing (MSAA): MSAA ist eine Standard-Antialiasing-Technik, die in der Computergrafik zur Verbesserung der Bildqualitt eingesetzt wird. Die meisten modernen GPUs untersttzen 2, 4, 8 und 16 Samples. Mehr Samples bedeuten bessere Qualitt, sind aber langsamer. Es gibt zwei Nachteile: Es ist inkompatibel mit N64-Style-Tiefenvergleich und kann bei einigen Spielen zu kleineren Strungen fhren.\nEmpfehlung: [Normalerweise 16x MSAA, oder FXAA mit N64-Style-Tiefenvergleich]"
+#2028# "Multisample-Antialiasing ist nicht kompatibel mit N64-Style-Tiefenvergleich."
+#2029# "Filtern"
+#2030# "Anisotrope Filterung:"
+#2031# "Aus"
+#2032# "Hoch"
+#2033# "Bilineare Filterung:"
+#2034# "Standard"
+#2035# "N64-Style 3 Punkt"
+#2036# "Bilineare Filterung: Texturen verwenden standard PC-Style bilineare Filtering.\nN64-Style 3 point: Texturen werden hnlich dem N64 gefiltert. Das Resultat sieht nicht so weich aus, entspricht aber ehr dem N64."
+#2046# "Deaktivieren"
+#2050# "Sprache:"
+
+/*********************************************************************************
+* Emulation Tab                                                                  *
+*********************************************************************************/
+#3000# "Spieleinstellungen verwenden"
+#3001# "Wenn aktiviert, werden alle nicht standardmigen Einstellungen fr jedes Spiel einzeln gespeichert.\nWenn ein Spiel luft, werden die Einstellungen fr das aktuell laufende Spiel angezeigt und gespeichert.\nHinweis: GLideN64 enthlt bereits Einstellungen fr die optimale Leistung der meisten Spiele. Sei vorsichtig wenn du Optionen auf den Registerkarten 'Emulation' und 'Frame-Buffer' nderst.\n[Empfehlung: Ausgewhlt]"
+#3002# "Aktiviere N64-Style Mip-Mapping"
+#3003# "Das N64 verwendet eine einzigartige Art des Mip-Mappings, welche nur schwer auf einem PC nachzustellen ist. Wenn diese Einstellung ausgewhlt ist wird N64 Mip-Mapping emuliert. Wenn diese Einstellung nicht ausgewhlt ist sehen bei einigen Spielen Texturen in der Ferne schrfer aus.\n[Empfehlung: Ausgewhlt]"
+#3004# "Aktiviere Per-Pixel Lighting (Bessere Qualitt, nur HLE)"
+#3005# "Das N64 berechnet die Beleuchtung per Vertex. Diese Einstellung aktiviert Phong Shading, welches glatterer und realistischer Beleuchtung erzeugt.\n\n[Empfehlung: Eigene Vorliebe]"
+#3006# "Speichere kompilierte Shader fr Geschwindigkeit (Empfehlung)"
+#3007# "Verwende einen dauerhaften Speicher fr kompilierte Shader Programme.\nJedes Spiel verwendet einen Satz an Combinern. Ein Combiner ist eine Gleichung, welche beschreibt wie aus verschiedenen Farbeingngen eine Ausgangsfarbe erzeugt wird. GLideN64 bersetzt und kompiliert Shader whrend der Laufzeit. Shader sind gro und komplex.Wenn ein Spiel mehrere neue Combiner verwendet dauert das kompilieren neuer Shader einige Zeit, was zu Stottern fhren kann. Wenn diese einstellung ausgewhlt ist werden diese Shader gesichert, damit sie beim nchsten Mal nicht neu kompiliert werden mssen.\n[Empfehlung: Ausgewhlt]"
+#3008# "Interne Auflsung:"
+#3009# "Diese Einstellung legt die Render-Buffer-Gre der Ausgabe fest. Standardmig ist die Render-Buffer-Gre Wie die Auflsung der Ausgabe, oder alternativ auch die Original N64 Auflsung oder ein Vielfaches der N64 Auflsung."
+#3010# "Wie Ausgabeauflsung"
+#3011# "Originale N64 Auflsung (hchste Genauigkeit)"
+#3012# "Mehrfaches der N64 Auflsung:"
+#3013# "Gamma"
+#3014# "Gammakorrektur.\nEinige N64 Spiele verwenden Gammakorrektur. Gammakorrektur macht das Bild heller. Das N64 wendet Gammakorrektur in seinem Video Interface an. \nGLideN64 emuliert Gammakorrektur mit einem Nachbearbeitungseffekt. Das bedeutet, es funktioniert nur, wenn die Frame-Buffer-Emulation aktiviert ist. Gammakorrektur wird automatisch bei Spielen aktiviert, welche dieses Feature auf einem echten N64 verwenden. Du kannst Gammakorrektur fr alle Spiele erzwingen. Der Standardwert fr Gammakorrektur ist 2, wie auf einem N64.\n[Empfehlung: benutze Standardeinstellung]"
+#3015# "Benutzerdefinierte Gammakorrekturstufe:"
+#3016# "Die Auswahl dieser Option setzt die vom Spiel vorgegebene Gammakorrektur auer Kraft."
+#3017# "2D-Elemente"
+#3018# "Rendern von 2D-Elementen in N64-Auflsung (beste Qualitt, kann langsam sein):"
+#3019# "Wenn diese Option ausgewhlt ist, werden 2D Elemente in der originalen N64 Auflsung gezeichnet, bevor sie zur Ausgabe gegeben werden. Normalerweise werden durch diese Einstellung Anzeigeprobleme von 2D Elementen beseitigt. Die Ausfhrungsgeschwindigkeit kann aber beeintrchtigt werden. Diese Einstellung verwendet Heuristik um benachbarte 2D Elemente zu erkennen, welche nicht in jedem Spiel funktionieren.\n[Empfehlung: Ausgewhlt, auer es bestehen Geschwindigkeitsprobleme]"
+#3020# "Deaktivieren"
+#3021# "Aktiviere optimiert"
+#3022# "Aktiviere nicht optimiert"
+#3023# "Versuche farbige Halos um transparente Objekte zu entfernen"
+#3024# "Beseitige schwarze Linien zwischen 2D Elementen:"
+#3025# "In einigen Spielen sind die Koordinaten von 2D Elemente nicht richtig ausgerichtet. Zwischen zwei benachbarten Elementen besteht eine Lcke von einem halben Pixel. Bei der originalen N64 Auflsung tritt dieses Problem nicht aus. Bei hheren Auflsungen ist aber eine schwarze Linie zwischen den Elementen sichtbar. Diese Einstellung verhindert schwarze Linien zwischen benachbarten 2D Elementen.\nFr benachbarte 2D Elemente: Wendet die Korrektur bei Polygonen an, welche sie bentigen. Bei auswhlen, welche Probleme mit schwarzen Linien haben.\nImmer: Wende Korrektur bei allen 2D Elementen an. Whle diese Einstellung aus, falls Fr benachbarte 2D Elemente nicht hilft.\nNiemals: Keine Korrektur von schwarzen Linien zwischen 2D Elementen.\n[Empfehlung: Spielabhngig, in der Regel Niemals]"
+#3026# "Nur benachbarte 2D Elemente"
+#3027# "Immer"
+#3028# "Niemals"
+#3029# "Hintergrund-Renderingmodus (nur HLE):"
+#3030# "Hintergrund-Rendering ist ein komplexer Makrobefehl zum Rendern groer (normalerweise bildschirmfllender) Bilder. Da Hintergrundbilder normalerweise nicht in den Texturspeicher passen, werden sie vom Mikrocode auf schmale Streifen aufgeteilt und einzeln gerendert. HLE-Code hat zwei Modi zur Emulation von Hintergrundbefehlen:\nAn einem Stck: Das gesamte Hintergrundbild wird als ein texturiertes Rechteck dargestellt. Diese Methode ist normalerweise viel schneller, aber das Ergebnis ist nicht immer korrekt.\nIn Streifen: Diese Methode emuliert Hintergrundbefehle so nah wie mglich zur tatschlichen Mikrocode-Implementierung. Ist langsamer, aber prziser. Ein weiteres Problem: Bei einigen Spielen knnen Lcken zwischen den gerenderten Streifen in hoher Auflsung auftreten. Verwende die \"Rendern von 2D-Elementen in N64-Auflsung\" -Option zum Entfernen der Lcken.\n[Empfehlung: Spielabhngig, meistens in Streifen]"
+#3031# "An einem Stck"
+#3032# "In Streifen"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "Framebuffer emulieren"
+#4001# "Wenn diese Einstellung nicht ausgewhlt ist, sind viele Effekte deaktiviert wie z.B. Kantenglttung, Beschneiden, Seitenverhltnis, N64 Auflsungsfaktor, N64-Style Tiefenvergleich und mehr. Diese Einstellung sollte nur deaktiviert werden, falls es Geschwindigkeitsprobleme gibt."
+#4002# "Kopiere den Hilfs-Farb-Buffer in den N64 Speicher (manchmal langsam, wenige Spielprobleme)"
+#4003# "Wenn diese Einstellung ausgewhlt ist wird der Hilfs-Farb-Buffer, direkt nachdem er aktualisiert wurde, in den N64 Speicher geschrieben. Diese Einstellung hilft Frame-Buffer-Effekte in einigen Spielen richtig zu emulieren. Sie kann aber deutlich die Leistung reduzieren.\n[Empfehlung: Nicht ausgewhlt]"
+#4004# "Frame-Bufferwechsel an:"
+#4005# "Die Einstellung legt fest, wie oft GLideN64 den Haupt-Frame-Buffer aktualisiert.\nVertikaler Interrupt: Aktualisiert den Buffer so schnell wie mglich, d.h. bei jedem vertikalen Interrupt in der Sekunde (50Hz fr PAL und 60Hz fr NTSC Spiele). Diese Einstellung hat die hchste Kompatibilitt. Verwende diese Einstellung solange es keine Leistungseinbuen gibt.\nVI-Ursprungsnderung: Die VI-Ursprungsnderung korrespondiert mit den eigentlichen FPS eines Spiels. N64 Spiele laufen in der Regel mit 20 bis 30 FPS. Der Buffer wird nicht so oft wie beim ersten Modus aktualisiert. Dieser Modus funktioniert nicht bei Spielen, welche einen einzigen Buffer verwenden, was selten vorkommt.\nFarb-Buffer-nderung: Diese Einstellung berprft, ob sich der Frame-Buffer gendert hat. Bei einigen Spielen funktioniert diese Einstellung nicht."
+#4006# "Vertikaler Interrupt (empfohlen, wenigste Spielprobleme)"
+#4007# "VI Ursprung hat sich gendert (schneller, wenige Spielprobleme)"
+#4008# "Farbbuffer nderung (am schnellsten, einige Spielprobleme)"
+#4009# "Benutze die Hilfe des Emulators zum Lesen/Schreiben des Frame-Buffers"
+#4010# "Einige Emulatoren erkennen nur schlecht, ob der Frame-Buffer gelesen oder geschrieben wurden. Die Erkennung des Emulators kann deaktiviert werden, damit GLideN64 selbst Frame-Buffer lesen und schreiben kann.\n[Empfehlung: Gewhnlich nicht ausgewhlt, aber manche Spiele laufen mit dieser Einstellung schneller]"
+#4011# "Lese Farb-Buffer in 4kB Stcken"
+#4012# "Wenn diese Einstellung ausgewhlt ist, wird der Farb-Buffer in Stcken gelesen. Andernfalls wird der Buffer in einem Rutsch gelesen. Wenn ein Spiel den kompletten Buffer lesen muss, kann diese Einstellung zu Verzgerungen fhren.\n[Empfehlung: Gewhnlich nicht ausgewhlt, weil der Farb-Buffer in der Regel komplett gelesen wird]"
+#4013# "Lese Depth-Buffer in 4kB Stcken"
+#4014# "Wenn diese Einstellung ausgewhlt ist, wird der Depth-Buffer in Stcken gelesen. Andernfalls wird der Buffer in einem Rutsch gelesen. Wenn ein Spiel den kompletten Buffer lesen muss, kann diese Einstellung zu Verzgerungen fhren.\n[Empfehlung: Ausgewhlt, weil der Depth-Buffer in der Regel nicht komplett gelesen wird]"
+#4015# "Kopiere den Frame-Buffer der Grafikkarte in den N64 Speicher:"
+#4016# "Bei einigen Spielen kann GLideN64 nicht feststellen, ob der Frame-Buffer verwendet wird. Mit diesen Einstellungen kann festgelegt werde, ob GLideN64 jeden Frame des Grafikkarten-Frame-Buffers in den N64 Speicher kopiert.\nNiemals: Deaktivert das Kopieren des Grafikkarten-Buffers.\nSynchron: Effekte aller Spiele werden erkannt. Die Leistung kann beeintrchtigt werden. Verwende diese Einstellung fr alle Spiele, welche mit Asynchron nicht funktionieren.\nAsynchron: Die Effekte der meisten Spiele werden erkannt.\n[Empfehlung: Asynchron]"
+#4017# "Niemals (am schnellsten, viele Spielprobleme)"
+#4018# "Synchron (am langsamsten, die wenigsten Spielprobleme)"
+#4019# "Asynchron (schnell, wenige Spielprobleme)"
+#4020# "Kopiere den Depth-Buffer der Grafikkarte in den N64 Speicher:"
+#4022# "Niemals (am schnellsten, die meisten Spielprobleme)"
+#4023# "Vom VRAM (langsam, einige Spielprobleme)"
+#4024# "In Software (schnell, am wenigsten Spielprobleme)"
+#4027# "Deaktivieren"
+#4030# "Tiefenpuffer lschen erzwingen"
+#4032# "bergebe den N64 Frame-Buffer an die Ausgabe"
+#4033# "Wenn diese Einstellung ausgewhlt ist, wird der Frame-Buffer direkt ausgegeben. Dies verhindert einige Grafikprobleme, kann aber zu Verzgerungen und visuellen Problemem fhren.\n[Empfehlung: In der Regel nicht ausgewhlt]"
+#4034# "Tiefe in Haupttiefenpuffer kopieren"
+#4035# "Diese Option ist fr einige von der Reshade-Tiefe abhngige Effekte, wie SSAO und Tiefenschrfe, erforderlich.\n[Empfehlung: nur wenn du Reshade verwendest und tiefenabhngige Effekte bentigst]"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5000# "N64 Texturen"
+#5001# "Filter:"
+#5002# "Diese Filter gltten oder schrfen Texturen. Es gibt vier Filter zum Gltten und zwei Filter zum Schrfen. Um so hher die Nummer, umso strker der Effekt. Die Geschwindigkeit kann je nach Spiel und/oder PC beeintrchtigt werden.\n[Empfehlung: Eigene Vorliebe]"
+#5003# "Kein"
+#5004# "Glatte Filterung 1"
+#5005# "Glatte Filterung 2"
+#5006# "Glatte Filterung 3"
+#5007# "Glatte Filterung 4"
+#5008# "Scharfe Filterung 1"
+#5009# "Scharfe Filterung 2"
+#5010# "Verbesserungen:"
+#5011# "Es knnen 12 verschiedene Filter ausgewhlt werden. Abhngig vom Filter kann die Ausfhrungsgeschwindigkeit beeintrchtigt werden.\nWenn Abspeichern ausgewhlt ist werden Texturen im Cache gespeichert. Dies steigert die Ausfhrungsgeschwindigkeit. Deaktiviere Ausgeschaltet fr Hintergrnde fr die beste Ausfhrungsgeschwindikeit.\n[Empfehlung: Eigene Vorliebe]"
+#5012# "Kein"
+#5013# "Abspeichern"
+#5014# "Verringere Color-Banding (empfohlen fr xBRZ Verbesserung)"
+#5015# "Diese Einstellung aktiviert eine Vorverarbeitungsstufe, welche Farbtontrennungsprobleme bei hochauflsenden Texturen reduziert.\n[Empfehlung: Ausgewhlt fr xBRZ]"
+#5016# "Fr Hintergnde deaktiviert"
+#5017# "Diese Einstellung verwirft Texturverbesserungen fr lange, schmale Texturen, welche gewhnlich fr Hintergrnde verwendet werden. Dies spart Texturspeicher und kann die Ausfhrungsgeschwindigkeit steigern.\n[Empfehlung: Ausgewhlt]"
+#5018# "Dateispeicher anstelle des Cache-Speichers verwenden"
+#5019# "Verwende Texturpaket"
+#5020# "Pfad fr Texturpakete:"
+#5021# "Pfad fr Textur-Packs auswhlen.\nStandard: Plugin/hires_texture"
+#5022# "Textur-Cache-Pfad:"
+#5023# "Textur-Dump-Pfad:"
+#5024# "Benutze volle Transparenz (empfohlen fr neuere Texturepacks)"
+#5025# "Falls diese Einstellung nicht ausgewhlt ist, werden Texturen wie beim Rice-Video-Plugin geladen: Transparenzen sind entweder an oder aus. Wenn diese Einstellung ausgewhlt ist untersucht GlideN64 wie der Alpha Channel der Texturen aufgebaut ist und whlt das beste Format aus. Dies gibt dem Ersteller von Textur-Packs die Mglichkeit halbtransparente Texturen zu verwenden.\nDiese Einstellung sollte bei alten oder schlecht entworfenen Texture-Packs nicht ausgewhlt werden.\n[Empfehlung: Textur-Pack abhngig]"
+#5026# "Alternative CRC-Berechnung (fr ltere Rice-Video-Packs)"
+#5027# "Diese Einstellung emuliert einen CRC Berechnungsfehler des Rice-Video-Plugins. Wenn Fehler beim Laden von Texturen auftauchen aktiviere oder deaktiviere diese Einstellung.\n[Empfehlung: Nicht ausgewhlt, ausgewhlt fr ltere Textur-Packs]"
+#5028# "Dateispeicher anstelle des Cache-Speichers verwenden"
+#5029# "Speichere/editiere Texturen"
+#5030# "Diese Einstellung speichert aktuell angezeigte Texturen in einem Texture-Pack Verzeichnis. Es knnen auch Texturen neu geladen werden whrend ein Spiel luft um direkt zu sehen wie sie aussehen.\nHotkeys:\nBenutze R um Texturen aus Texture-Packs neu zu laden\nBenutze D um Texturen speichern an- und abzuschalten"
+#5031# "Gre des Speichercaches fr erweiterte Texturen:"
+#5032# "Verbesserte und gefilterte Texturen knnen zwischengespeichert werden, um die Leistung zu erhhen. Diese Einstellung legt fest wieviel Speicher fr den Texture-Cache reserviert wird. Dies kann bei vielen Anfragen die Leistung erhhen, was normalerweise der Fall ist. Eigentlich sollten 128MB mehr als genug sein. Der beste Wert ist aber spielabhngig. Super Mario 64 reichen z.B. 32 MB. Conker's Bad Fur Day kann aber noch von 256 MB+ providieren. Beim Wert 0 ist der Cache deaktiviert.\n[Empfehlung: abhngig von PC und Spiel]"
+#5033# "Speichere den Cache fr verbesserte Texturen auf der Festplatte"
+#5034# "Diese Einstellung speichert alle vorher geladenen oder verbesserten Texturen auf dem PC. Wenn das Spiel noch einmal gestartet wird mssen die Texturen nicht neu erstellt werden.\nWenn Texture-Packs verwendet werden dauert das Laden eines Packs nur wenige Sekunden gegenber dem normalen Ladevorgang von 5-60 Sekunden. Wird jedoch das Texture Pack verndert, muss der Texture Cache manuell gelscht werden um die nderung zu bernehmen. Cache Dateien werden im Plugin Verzeichnis im Verzeichnis Cache gespeichert.\n[Empfehlung: Ausgewhlt]"
+#5035# "Textur-Cache komprimieren"
+#5036# "Texturen werden komprimiert, damit mehr Texturen im Cache gehalten werden knnen. Die Kompressionsrate variiert je nach Textur, aber ist normalerweise 1/5 der Originalgre.\n[Empfehlung: Ausgewhlt]"
+#5037# "Konvertiere Texturen zu 16Bit"
+#5038# "Diese Einstellung halbiert den Speicherbedarf von Texturen im Texture-Cache und VRAM um die Leistung zu steigern. Wenn die Farbtiefe reduziert wird versucht GLideN64 die originale Qualitt so gut wie mglich zu erhalten. Bei den meisten Texturen ist es kaum wahrnehmbar, aber einige Texturen, wie z.B. fr den Himmel, knnen schlechter aussehen.\n[Empfehlung: Nicht ausgewhlt]"
+
+/*********************************************************************************
+* On-screen display                                                              *
+*********************************************************************************/
+#6000# "Position"
+#6001# "FPS anzeigen"
+#6002# "VI/s anzeigen"
+#6003# "Anzeige in Prozent"
+#6004# "Interne Auflsung anzeigen"
+#6005# "Rendering-Auflsung anzeigen"
+#6006# "Schriftart"
+#6007# "Gre:"
+#6008# "px"
+#6009# "Farbe:"
+#6010# "Vorschau"
+
+/*********************************************************************************
+* Debug                                                                          *
+*********************************************************************************/
+#7000# "Low-Level-Info ausgeben"
+#7001# "Display-Listen-Befehle ausgeben"
+#7002# "Detaillierte Informationen ausgeben (Matrizen, Eckpunkte, etc.)"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "ber GLideN64"
+#9001# "ber"
+#9002# "Beitrger"
+#9003# "Finanzierer"
+#9004# "Danksagung"
+#9005# "Das N64 Open-Source Grafik-Plugin der nchsten Generation."
+#9006# "Autoren"
+#9007# "Entwickler"
+#9008# "Betatester"
+#9009# "Oberflchendesigner"
+#9011# "Autor des originalen glN64 Grafikplugins"
+#9012# "Autor des glesn64 Grafikplugins, einem GLES 2.0 Port von glN64"
+#9013# "Autor der GlideHQ Texturbibliothek"
+#9014# "Autor von z64, einem OpenGL LLE Grafikplugin"
diff --git a/GLideN64/translations/wtl/gliden64_en.Lang b/GLideN64/translations/wtl/gliden64_en.Lang
new file mode 100644
index 00000000..2c97443b
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_en.Lang
@@ -0,0 +1,236 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "English"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# "Video"
+#1001# "Emulation"
+#1002# "Frame buffer"
+#1003# "Texture enhancement"
+#1004# "OSD"
+#1005# "Debug"
+#1010# "Save settings for:"
+#1011# "Settings profile:"
+#1012# "Remove"
+#1013# "Restore Defaults"
+#1014# "Save and Close"
+#1015# "Save"
+#1016# "Close"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# "Video"
+#2001# "Full screen resolution:"
+#2002# "All the resolutions that your video card/monitor supports should be displayed.\n[Recommended: Maximum resolution for your monitor unless performance becomes an issue]"
+#2003# "Refresh rate:"
+#2005# "Windowed resolution:"
+#2006# "This option selects the resolution for windowed mode. You can also type in a custom window size.\n[Recommended: 640 x 480, 800 x 600, 1024 x 768, 1280 x 960]"
+#2007# "Aspect ratio:"
+#2008# "This setting adjusts the aspect ratio of the video output. All N64 games support 4:3. Some games support 16:9 within game settings. Use Stretch to fill the screen without pillar or letterboxing.\nTry to adjust game to fit tries to adjust the viewing space to fit without stretching. Many games work well adjusted, but some don't."
+#2009# "4:3 (recommended)"
+#2010# "16:9"
+#2011# "Stretch"
+#2012# "Try to adjust game to fit"
+#2013# "Enable VSync"
+#2014# "Vertical sync, or VSync, can improve the image by syncing the game's frame rate to your monitor's refresh rate. This prevents image tearing, but may cause performance problems.\n[Recommended: Usually off, on if you have image tearing problems]"
+#2015# "Enable threaded video"
+#2016# "Threaded video can improve performance with poor OpenGL drivers at the cost of very marginal input lag, usually less than half a frame.\n[Recommended: Usually off, unless there are performance issues]"
+#2017# "Overscan"
+#2018# "When enabled, the image is cropped by values specified in N64 pixels. Useful to remove black borders in some games."
+#2019# "NTSC"
+#2020# "PAL"
+#2021# "Anti-aliasing"
+#2022# "No anti-aliasing"
+#2023# "Fast approximate anti-aliasing (FXAA)"
+#2024# "Multisample anti-aliasing (MSAA):"
+#2025# "Off"
+#2026# "High"
+#2027# "GLideN64 offers two methods to smooth jagged polygons:\nFast approximate anti-aliasing (FXAA): FXAA is a post-processing filter that can provide a decent result, but as good as MSAA. The main reason to use FXAA is to use with N64-style depth compare. FXAA adds some blurriness to the output image, causing some textures like text to possibly look worse.\nMultisample anti-aliasing (MSAA): MSAA is a standard anti-aliasing technique used in computer graphics to improve image quality. Most modern GPUs support 2, 4, 8, and 16 samples. More samples mean better quality, but are slower. There are two downsides: it's incompatible with N64-style depth compare and may cause minor glitches in some games.\nRecommendation: [Usually 16x MSAA, or FXAA with N64-style depth compare]"
+#2028# "Multisample anti-aliasing is not compatible with N64-style depth compare."
+#2029# "Filtering"
+#2030# "Anisotropic filtering:"
+#2031# "Off"
+#2032# "High"
+#2033# "Bilinear filtering:"
+#2034# "Standard"
+#2035# "N64-style 3 point"
+#2036# "Bilinear filtering: Textures will use standard PC-style bilinear filtering.\nN64-style 3 point: Textures will be filtered more like the N64. The result is less smooth but more accurate."
+#2037# "Dithering"
+#2038# "Pattern (RDRAM):"
+#2039# "Apply to final output"
+#2040# "This setting enables game controlled ordered grid dithering. Enable it for accurate representation. Default = disabled."
+#2041# "Enable 5-bit quantization"
+#2042# "Like real hardware this setting reduces the number of colors if dithering is used. Removes undesired dithering fragments. Default = enabled."
+#2043# "High resolution noise"
+#2044# "This setting doubles noise resolution to get a finer noise effect at higher resolutions. Default = disabled."
+#2045# "RDRAM dithering prevents color banding in games with framebuffer effects.\nSettings: Disabled, Bayer ordered grid dithering, Magic Square ordered grid dithering or blue noise dithering. Blue noise dithering produces unobtrusive results. Default = blue noise dithering."
+#2046# "Disable"
+#2047# "Bayer"
+#2048# "Magic square"
+#2049# "Blue noise"
+#2050# "Language:"
+
+/*********************************************************************************
+* Emulation Tab                                                                  *
+*********************************************************************************/
+#3000# "Use per-game settings"
+#3001# "When enabled, all non-default values of settings are stored individually for each game.\nWhen a game is running, settings are displayed and saved for the currently running game.\nNote: GLideN64 already contains settings for the optimal performance of most games. Be careful when altering options on 'Emulation' and 'Frame buffer' tab.\n[Recommended: Checked]"
+#3002# "Enable N64-style mip-mapping"
+#3003# "The N64 uses a unique method of mip-mapping that's difficult to reproduce correctly on PCs. When checked, this option emulates N64-accurate mip-mapping. When unchecked, some games have sharper distant textures.\n[Recommended: Checked]"
+#3004# "Enable per-pixel lighting (better quality, HLE only)"
+#3005# "In N64 games lighting is calculated per vertex. This option enables Phong shading, which provides smoother and more realistic lighting.\n\n[Recommended: Your preference]"
+#3006# "Store compiled shaders for performance (recommended)"
+#3007# "Use persistent storage for compiled shader programs.\nEach game uses a set of combiners. A combiner is an equation that defines how to build output color from various color inputs. GLideN64 translates shaders, and compiles shader programs on the fly. Shaders are large and complex. If the game uses several new combiners, compiling new shaders will take time and result in stuttering. When this option is checked, these shaders are saved so they're not recompiled the next time you run the game.\n[Recommended: Checked]"
+#3008# "Internal resolution:"
+#3009# "This option sets the output render buffer size. By default, the render buffer is set to the Same as output resolution, but you can set it to the Original N64 resolution or a Multiple of N64 resolution."
+#3010# "Same as output resolution"
+#3011# "Original N64 resolution (most accurate)"
+#3012# "Multiple of N64 resolution:"
+#3013# "Gamma"
+#3014# "Gamma correction.\nSome N64 games use gamma correction. Gamma correction makes image brighter. N64 applies gamma correction in its Video Interface. \nGLideN64 emulates gamma correction as post-processing effect. That is, it works only when frame buffer emulation enabled. Gamma correction enabled automatically for games, which use it on real N64. You may force gamma correction for all games. Default level of gamma correction is 2, as on N64.\n[Recommended: use defaults]"
+#3015# "Custom gamma correction level:"
+#3016# "Selecting this option overrides gamma correction specified by the game."
+#3017# "2D elements"
+#3018# "Render 2D elements in N64 resolution (best quality, can be slow):"
+#3019# "When checked, 2D elements are rendered at the N64s resolution before copying them to output. This usually eliminates display issues with 2D elements, but it can be slow. This option uses heuristics to detect adjacent 2D elements that doesn't work for every game.\n[Recommended: Checked, unless you have performance problems]"
+#3020# "Disable"
+#3021# "Enable optimized"
+#3022# "Enable unoptimized"
+#3023# "Try to remove colored halos around transparent objects"
+#3024# "Fix black lines between 2D elements:"
+#3025# "In some games the coordinates for parts of 2D elements are not aligned: there is a half-pixel split between adjacent elements. When rendering at the N64's original resolution it isn't visible, but when the image is scaled up it results in black lines. This option attempts to connect these 2D elements.\nFor adjacent 2D elements: Apply the correction only for polygons that need it. Select this option for games that have issues with black lines.\nAlways: Apply the correction for every 2D element. Select this option when For adjacent 2D elements doesn't help.\nNever: Don't attempt to correct black lines between 2D elements.\n[Recommended: Game dependent, mostly Never]"
+#3026# "For adjacent 2D elements"
+#3027# "Always"
+#3028# "Never"
+#3029# "Background rendering mode (HLE only):"
+#3030# "Background is a complex macro command used to render large (normally full screen) images. Since background images usually don't fit texture memory, the microcode splits them on narrow strips and renders them one by one. HLE code has two modes to emulate background commands:\nOne piece: The whole background image rendred as one textured rectangle. This method is normally much faster, but the result is not always correct.\nStripped: This method emulates background commands as close as possible to actual microcode implementation. It's slower but more precise. Another problem: some games may have gaps between rendered strips in high resolution. Use \"Render 2D elements in N64 resolution\" option to remove the gaps.\n[Recommended: Game dependent, mostly Stripped]"
+#3031# "One piece"
+#3032# "Stripped"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "Emulate frame buffer"
+#4001# "Unchecking this option disables many effects including cropping, aspect ratio, N64 resolution factor, N64-style depth compare and more. Don't uncheck this option unless you have performance issues."
+#4002# "Copy auxiliary color buffers to N64 memory (sometimes slow, fewer game issues)"
+#4003# "When checked, the auxiliary color buffer is copied to N64 memory right after rendering to it is finished. This option helps to correctly emulate frame buffer effects in some games. This option may noticeably reduce performance.\n[Recommended: Usually unchecked]"
+#4004# "Frame buffer swap on:"
+#4005# "This option controls how often GLideN64 updates the main frame buffer.\nVertical interrupt: Update the buffer as quickly as possible, every vertical interrupt per second (50 for PAL and 60 for NTSC games). This option is the most compatible. Use this mode unless you have performance problems.\nVI origin change: The VI origin changes corresponding to the game's actual FPS. N64 games typically run between 20 to 30 FPS so the buffers swap less often than the first mode. This mode does not work for games that use single buffering, which is rare.\nColor buffer change: This option checks to see if the frame buffer has been changed. There are some games where this doesn't work."
+#4006# "Vertical interrupt (recommended, fewest game issues)"
+#4007# "VI origin change (faster, few game issues)"
+#4008# "Color buffer change (fastest, some game issues)"
+#4009# "Use emulator help to read/write frame buffers"
+#4010# "Some emulators do a poor job of detecting when to read/write frame buffers. You can disable emulator help to let GLideN64 read/write frame buffers itself.\n[Recommended: Usually unchecked, but for some games/emulators it may be faster checked]"
+#4011# "Read color buffer in 4 KB chunks"
+#4012# "When checked, the color buffer will be read in chunks. Otherwise, the buffer will be read in its entirety. If a game needs to read the entire buffer, selecting this option may be slow.\n[Recommended: Usually unchecked, because the color buffer is usually read entirely]"
+#4013# "Read depth buffer in 4 KB chunks"
+#4014# "When checked, the depth buffer will be read in chunks. Otherwise the buffer will be read in its entirety. If a game needs to read the entire buffer, selecting this option may be slow.\n[Recommended: Checked, because the depth buffer is not often read entirely]"
+#4015# "Copy video card frame buffer to N64 memory:"
+#4016# "In some games GLideN64 can't detect when the game uses the frame buffer. With these options, you can have GLideN64 copy each frame of your video card's frame buffer to N64 memory.\nNever: Disable copying buffers from video card.\nSynchronous: Effects are detected for all games, but it can be slow. Use for games where Asynchronous doesn't work.\nAsynchronous: Effects are detected for most games.\n[Recommended: Usually Asynchronous]"
+#4017# "Never (fastest, many game issues)"
+#4018# "Synchronous (slowest, fewest game issues)"
+#4019# "Asynchronous (fast, few game issues)"
+#4020# "Copy video card depth buffer to N64 memory:"
+#4021# "The depth buffer is used to emulate some effects (e.g. coronas):\nNever: Depth buffer is disabled.\nFrom VRAM: Your video card's depth buffer is copied to N64 memory each frame, which can be slow on some games.\nIn software: Generally faster than copying from VRAM, but the result can be imperfect.\n[Recommended: In software]"
+#4022# "Never (fastest, most game issues)"
+#4023# "From VRAM (slow, some game issues)"
+#4024# "In software (fast, fewest game issues)"
+#4025# "N64-style depth compare (experimental, disables MSAA)"
+#4026# "The N64 uses a unique method of calculating depth to the camera. When enabled, GlideN64 uses shaders to try to emulate these calculations correctly. Not compatible with anti-aliasing. Experimental!\nFast mode requires OpenGL 4.2 and fragment shader interlock extensions.\nCompatible mode requires only core OpenGL 4.2 Can be slow!\n[Recommended: Sometimes checked, for several games]"
+#4027# "Disable"
+#4028# "Fast"
+#4029# "Compatible"
+#4030# "Force depth buffer clear"
+#4031# "Enable force depth buffer clear. A hack. Necessary for Eikou no Saint Andrews.\n[Recommended: except for Eikou no Saint Andrews]"
+#4032# "Render N64 frame buffer to output"
+#4033# "When this option is checked, the frame buffer is rendered directly to the screen. This prevents some graphic problems but may cause slowdowns or visual quality problems.\n[Recommended: Usually unchecked]"
+#4034# "Copy depth to main depth buffer"
+#4035# "This option is required for some Reshade depth dependant effects, such as SSAO and depth of field.\n[Recommended: only if you use Reshade and need depth dependant effects]"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5000# "N64 textures"
+#5001# "Filter:"
+#5002# "This filter smooths or sharpens textures. There are four smoothing filters and two sharpening filters. The higher the number, the stronger the effect. Performance may be affected depending on the game and/or your PC.\n[Recommended: Your preference]"
+#5003# "None"
+#5004# "Smooth filtering 1"
+#5005# "Smooth filtering 2"
+#5006# "Smooth filtering 3"
+#5007# "Smooth filtering 4"
+#5008# "Sharp filtering 1"
+#5009# "Sharp filtering 2"
+#5010# "Enhancement:"
+#5011# "There are 12 distinct filters to select. Depending on which filter, they may cause performance problems.\nWhen Store is selected, textures are saved to the cache as-is. This improves performance in games that load many textures. Uncheck Disable for backgrounds for the best performance.\n[Recommended: Your preference]"
+#5012# "None"
+#5013# "Store"
+#5014# "Decrease color banding (recommended for xBRZ enhancement)"
+#5015# "This option enables a pre-processing step that reduces posterization issues on enhanced textures.\n[Recommended: Checked for xBRZ]"
+#5016# "Disable for backgrounds"
+#5017# "This option skips texture enhancements for long, narrow textures that are usually used for backgrounds. This may save texture memory and improve performance.\n[Recommended: Checked, unless Enhancement is set to Store]"
+#5018# "Use file storage instead of memory cache"
+#5019# "Use texture pack"
+#5020# "Texture pack path:"
+#5021# "Select path to the folder with texture packs.\nDefault: Plugin/hires_texture"
+#5022# "Texture cache path:"
+#5023# "Texture dump path:"
+#5024# "Use full transparencies (recommended for newer texture packs)"
+#5025# "When this option is cleared, textures will be loaded as they are when using Rice Video: transparencies either on or off. When this option is selected, GlideN64 will check how the texture's alpha channel was designed and will select the most appropriate format. This gives texture pack designers freedom to use semi-transparent textures.\nClear this option for older or poorly designed texture packs.\n[Recommended: Texture pack dependent]"
+#5026# "Alternative CRC calculation (for old Rice Video packs)"
+#5027# "This option emulates a palette CRC calculation bug in Rice Video. If you have problems loading textures, try checking or unchecking this option.\n[Recommended: Mostly unchecked, checked for old texture packs]"
+#5028# "Use file storage instead of memory cache"
+#5029# "Dump/edit textures"
+#5030# "This option dumps textures on screen to a texture pack folder. You can also reload textures while the game is running to see how they look instantlybig time saver!\nHotkeys:\nUse R to reload textures from the texture pack\nUse D to toggle texture dumping on or off"
+#5031# "Size of memory cache for enhanced textures:"
+#5032# "Enhanced and filtered textures can be cached to improve performance. This option adjusts how much memory is dedicated to the texture cache. This can improve performance if there are many requests for the same texture, which is usually the case. Normally 128 MB should be more than enough, but the best option is different for each game. Super Mario 64 may not need more than 32 MB, but Conker's Bad Fur Day can take advantage of 256 MB+. Adjust accordingly if you are having performance problems. Setting this option to 0 disables the cache.\n[Recommended: PC and game dependent]"
+#5033# "Save enhanced texture cache to hard disk"
+#5034# "This option saves all previously loaded and enhanced textures to your PC. When the game is next launched, textures don't have to be recreated, causing smoother performance.\nWhen using texture packs, loading packs will take only a few seconds when the game is launched as opposed to the 560 seconds that loading usually takes. However, if you change the texture pack you'll have to manually delete the texture cache. Saved cache files are saved to a folder called Cache within the plugins folder.\n[Recommended: Checked]"
+#5035# "Compress texture cache"
+#5036# "Textures will be compressed so more textures can be held in the cache. The compression ratio varies per texture, but the compression is typically 1/5 of the original size.\n[Recommended: Checked]"
+#5037# "Convert textures to 16 bpp"
+#5038# "This option halves the space used by textures in the texture cache and video card memory to improve performance. When reducing the color, GLideN64 tries to perserve the original quality as much as possible. On most textures it's hardly noticeable, but some textures, like skies, can look noticeably worse.\n[Recommended: Unchecked]"
+
+/*********************************************************************************
+* On-screen display                                                              *
+*********************************************************************************/
+#6000# "Position"
+#6001# "Display FPS"
+#6002# "Display VI/s"
+#6003# "Display percentage"
+#6004# "Display internal resolution"
+#6005# "Display rendering resolution"
+#6006# "Font"
+#6007# "Size:"
+#6008# "px"
+#6009# "Color:"
+#6010# "Preview"
+
+/*********************************************************************************
+* Debug                                                                          *
+*********************************************************************************/
+#7000# "Dump low-level info"
+#7001# "Dump display list commands"
+#7002# "Dump detailed info (matrices, vertices, etc.)"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "About GLideN64"
+#9001# "About"
+#9002# "Contributors"
+#9003# "Funders"
+#9004# "Credits"
+#9005# "A new generation, open-source graphics plugin for N64 emulators."
+#9006# "Authors"
+#9007# "Developer"
+#9008# "Beta tester"
+#9009# "GUI designer"
+#9010# "... and more"
+#9011# "Author of the original glN64 graphics plugin"
+#9012# "Author of gles2n64, a port of glN64 to GL ES 2.0"
+#9013# "Author of the GlideHQ texture library"
+#9014# "Author of z64, an OpenGL LLE plugin"
\ No newline at end of file
diff --git a/GLideN64/translations/wtl/gliden64_es.Lang b/GLideN64/translations/wtl/gliden64_es.Lang
new file mode 100644
index 00000000..8bd472c3
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_es.Lang
@@ -0,0 +1,160 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Espaol"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# "Vdeo"
+#1001# "Emulacin"
+#1002# "Frame buffer"
+#1003# "Mejora de texturas"
+#1004# "OSD"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# "Vdeo"
+#2001# "Resolucin de pantalla completa:"
+#2002# "Aqu deberan aparecer todas las resoluciones que admite tu tarjeta grfica o monitor.\n[Recomendacin: La resolucin mxima que permita tu monitor salvo que haya problemas de rendimiento]"
+#2003# "Frecuencia de actualizacin:"
+#2005# "Resolucin de ventana:"
+#2007# "Proporcin de aspecto:"
+#2008# "Ajusta la proporcin de aspecto de la salida de vdeo. Todos los juegos de N64 admiten la proporcin 4:3. Algunos son compatibles con 16:9 dentro de las opciones de cada juego. Utiliza la opcin estirar para llenar toda la pantalla sin provocar bordes en cualquier punto de la pantalla.\nIntentar ajustar el tamao del juego intentar ajustar el espacio de la pantalla sin estirar la imagen. Muchos juegos funcionan correctamente bajo este ajuste, pero algunos no funcionarn bien."
+#2009# "4:3 (recomendado)"
+#2010# "16:9"
+#2011# "Estirar"
+#2012# "Intentar ajustar el tamao del juego"
+#2013# "Sincrona vertical"
+#2014# "La sincrona vertical (Tambin llamada VSync) puede mejorar la calidad de imagen sincronizando la velocidad de fotogramas del juego con la frecuencia de actualizacin de tu monitor. Esto evita que la imagen aparezca cortada, pero podra provocar problemas de rendimiento.\n[Recomendacin: Por norma general desactivado, activar si las imgenes salen cortadas]"
+#2025# "Desactivado"
+#2026# "Alto"
+#2030# "Filtro anisotrpico:"
+#2031# "Desactivado"
+#2032# "Alto"
+#2033# "Filtrado bilineal:"
+#2034# "Estndar"
+#2035# "Tripunto N64"
+#2036# "Filtrado bilineal: Las texturas utilizarn el filtro bilineal estndar de PC.\nTripunto N64: Las texturas se filtrarn de una forma ms parecida a la que hace la N64. El resultado ser menos suave, pero ms preciso."
+#2046# "Desactivado"
+#2050# "Idioma:"
+
+/*********************************************************************************
+* Emulation Tab                                                                  *
+*********************************************************************************/
+#3002# "Mip-mapping de N64"
+#3003# "La N64 utiliza un sistema de mip-mapping que es difcil de reproducir correctamente en PCs. Al activar esta opcin se emular el mip-mapping de N64. Si se desactiva, algunos juegos tendrn texturas ms definidas a lo lejos.\n[Recomendacin: Activado]"
+#3004# "Iluminacin por pxel (mejor calidad, slo en HLE)"
+#3005# "La iluminacin de los juegos de N64 se calcula segn cada vrtice. Esta opcin activa el sombreado Phong, que da una iluminacin ms suave y realista.\n\n[Recomendacin: Lo que prefieras]"
+#3006# "Guardar shaders compilados para mejorar el rendimiento (recomendado)"
+#3007# "Guarda de forma persistente los programas de shaders compilados.\nCada juego utiliza un conjunto de combinadores. Un combinador es una ecuacin que define el color que se muestra a partir de varios colores de la imagen original. GLideN64 traduce los shaders y compila los programas de shaders al vuelo. Los shaders ocupan mucho espacio y son complejos. Si una escena nueva utiliza varios combinadores nuevos, se tardar ms en compilar un shader nuevo y eso puede provocar trompicones. Al activar esta opcin se guardarn los shaders para no tener que recompilarlos la prxima vez que ejecutes el juego.\n[Recomendacin: Activado]"
+#3008# "Resolucin interna:"
+#3009# "Esta opcin asigna el tamao del bfer de renderizado de salida. La configuracin prdeterminada del bfer de renderizado es Idntica a la resolucin de salida, pero puedes utilizar la Resolucin original de N64 o un Mltiplo de la resolucin de N64."
+#3010# "Idntica a la resolucin de salida"
+#3011# "Resolucin original de N64 (ms precisa)"
+#3012# "Mltiplo de la resolucin de N64:"
+#3014# "Correccin gamma.\nAlgunos juegos de N64 utilizan la correccin gamma, que hace que la imagen sea ms brillante. La N64 aplica la correccin gamma a su interfaz de vdeo. \nGLideN64 emula la correccin gamma como un efecto de posprocesado. Es decir, slo funciona si se utiliza la emulacin del frame buffer. La correccin gamma se activa automticamente en los juegos que la utilizan en una N64 real. Puedes forzar la correccin gamma en todos los juegos. El nivel predeterminado de correccin es 2, como en una N64 real.\n[Recomendacin: Utilizar el valor predeterminado]"
+#3016# "Al seleccionar esta opcin se anular la correccin de gamma que especifique el juego."
+#3019# "Si se activa esta opcin, el plugin renderizar los elementos 2D en la resolucin nativa de N64 y despus copiar el resultado al bfer principal. Esto debera eliminar los problemas grficos en los elementos 2D, pero puede provocar ralentizaciones. Esta opcin utiliza heurstica para detectar los elementos 2D adyacentes, pero no funcionar en todos los juegos.\n[Recomendacin: Activado salvo que tengas problemas de rendimiento]"
+#3020# "Desactivado"
+#3024# "Corregir lneas negras entre elementos en 2D:"
+#3025# "En algunos juegos no se alinean las coordenadas de los elementos en 2D: Hay una separacin de medio pxel entre cada elemento adyacente. No es algo visible cuando se renderizan en la resolucin nativa de N64, pero provoca lneas negras cuando se escala la imagen. Esta opcin intenta unir estos elementos en 2D.\nPara elementos en 2D adyacentes: Aplica la correccin slo en los polgonos que la necesiten. Selecciona esta opcin para los juegos que tengan problemas de lneas negras.\nSiempre: Aplica la correccin en todos los elementos en 2D. Selecciona esta opcin cuando Para elementos adyacentes no funcione.\nNunca: No corregir las lneas negras entre los elementos en 2D.\n[Recomendacin: En funcin de cada juego, por lo general Nunca]"
+#3026# "Para elementos en 2D adyacentes"
+#3027# "Siempre"
+#3028# "Nunca"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "Emular frame buffer"
+#4001# "Al desactivar esta opcin desactivars muchos efectos, como el recorte de imagen, la proporcin de aspecto, el factor de resolucin de N64 y la comparacin de profundidad al estilo de N64, entre otros. No desactives esta opcin salvo que tengas problemas de rendimiento."
+#4002# "Copiar bfers auxiliares de color a la memoria de N64 (A veces va lento, puede dar problemas)"
+#4003# "Al activar esta opcin,se copiar el bfer auxiliar de color a la memoria de N64 nada ms sea renderizado. Permite emular correctamente los efectos basados en frame buffer de algunos juegos. Esta opcin podra reducir visiblemente el rendimiento.\n[Recomendacin: Por norma general desactivado]"
+#4004# "Actualizacin del frame buffer:"
+#4005# "Esta opcin controla la frecuencia con la que GlideN64 actualizar el frame buffer principal.\nInterrupcin vertical: Actualiza el bfer lo ms rpido posible, en cada interrupcin vertical por segundo (50 en juegos PAL y 60 en juegos NTSC). Es la opcin ms compatible. Utilzala salvo que tengas problemas de rendimiento.\nCambio en el origen de la VI: El origen del VI cambia en funcin de los FPS que tenga el juego. Los juegos de N64 suelen funcionar a una velocidad de entre 20 y 30 FPS, as que los bfers se actualizan menos que en el primer modo. Este modo no funciona en los juegos monobfer, lo que es poco habitual.\nCambio en el bfer de color: Esta opcin verifica que se haya cambiado el frame buffer. No funciona en algunos juegos."
+#4006# "Interrupcin vertical (Recomendado, problemas mnimos)"
+#4007# "Cambio en el origen de la VI (Ms rpido, da pocos problemas)"
+#4008# "Cambio en el bfer de color (Ms rpido, da algunos problemas)"
+#4009# "Utilizar las ayudas del emulador para leer/escribir los frame buffers"
+#4010# "Algunos emuladores no son muy buenos a la hora de detectar el momento de leer o escribir en los frame buffers. Puedes desactivar la ayuda del emulador para que GlideN64 se encargue de leer y escribir los frame buffers por su cuenta.\n[Recomendacin: Por norma general desactivado, aunque algunos juegos o emuladores pueden ir ms rpidos si se deja activado]"
+#4011# "Leer el bfer de color por fragmentos de 4 KB"
+#4012# "Al activar esta opcin, el bfer de color se leer por fragmentos. En caso contrario, el bfer se leer en su totalidad. Si algn juego necesita leer el bfer entero, esta opcin podra ralentizarlo.\n[Recomendacin: Por norma general desactivado, ya que suele leerse el bfer de color en su totalidad]"
+#4013# "Leer el bfer de profundidad por fragmentos de 4 KB"
+#4014# "Al activar esta opcin, el bfer de profundidad se leer por fragmentos. En caso contrario, el bfer se leer en su totalidad. Si algn juego necesita leer el bfer entero, esta opcin podra ralentizarlo.\n[Recomendacin: Activado, ya que el bfer de profundidad no suele leerse en su totalidad]"
+#4015# "Copiar el frame buffer de la tarjeta grfica a la memoria de N64:"
+#4016# "GlideN64 no podr detectar el uso del frame buffer en algunos juegos. Con estas opciones podrs hacer que GlideN64 copie cada fotograma del frame buffer de tu tarjeta grfica a la memoria de N64.\nNunca: No copiar los bfers de la tarjeta grfica.\nSncrono: Detecta los efectos de todos los juegos, pero puede ser lento. Utilzalo en los juegos en los que no funcione la opcin Asncrono.\nAsncrono: Detecta los efectos en casi todos los juegos.\n[Recomendacin: Por norma general asncrono]"
+#4017# "Nunca (Lo ms rpido, da ms problemas)"
+#4018# "Sncrono (Lo ms lento, problemas mnimos)"
+#4019# "Asncrono (Rpido, da pocos problemas)"
+#4020# "Copiar bfer de profundidad de la tarjeta grfica a la memoria de N64:"
+#4022# "Nunca (Lo ms rpido, lo ms problemtico)"
+#4023# "Copiar de la VRAM (Lento, da algunos problemas)"
+#4024# "Por software (Rpido, problemas mnimos)"
+#4027# "Desactivado"
+#4032# "Renderizar el frame buffer de N64 a la imagen"
+#4033# "Al activar esta opcin se renderizar el frame buffer directamente en pantalla. Esto evita algunos problemas grficos pero puede provocar ralentizaciones o problemas de calidad visual.\n[Recomendacin: Por norma general desactivado]"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5000# "Texturas de N64"
+#5001# "Filtro:"
+#5002# "Este filtro suaviza o perfila las texturas. Hay cuatro filtros de suavizado y dos de perfilado. Cuanto ms alto sea el nmero, ms fuerte ser el efecto. Podra afectar al rendimiento segn el juego o tu equipo.\n[Recomendacin: Lo que prefieras]"
+#5003# "Desactivar"
+#5004# "Filtro suave 1"
+#5005# "Filtro suave 2"
+#5006# "Filtro suave 3"
+#5007# "Filtro suave 4"
+#5008# "Filtro ntido 1"
+#5009# "Filtro ntido 2"
+#5010# "Mejora:"
+#5011# "Tienes 12 filtros distintos a elegir. Algunos filtros podran provocar problemas de rendimiento.\nCuando se selecciona la opcin Almacenar, las texturas se guardarn en la cach tal cual estn. Esto mejorar el rendimiento en los juegos que utilizan muchas texturas. Desactiva la opcin Desactivar en fondos para obtener el mejor rendimiento posible.\n[Recomendacin: Lo que prefieras]"
+#5012# "Desactivar"
+#5013# "Almacenar"
+#5014# "Reducir las bandas de color (Recomendado para el filtro xBRZ)"
+#5015# "Esta opcin activa un paso de preprocesado que reduce los efectos de posterizacin en las texturas modificadas.\n[Recomendacin: Activado para el efecto xBRZ]"
+#5016# "Desactivar en fondos"
+#5017# "Esta opcin evita aplicar las mejoras de texturas en aquellas que sean largas y estrechas, ya que suelen utilizarse para los fondos. Podra reducir el consumo de texturas y mejorar el rendimiento.\n[Recomendacin: Activado salvo que las mejoras de texturas estn configuradas en Almacenar]"
+#5019# "Usar paquete de texturas"
+#5020# "Ruta de paquetes de texturas:"
+#5021# "Selecciona la carpeta donde se encuentren los paquetes de texturas.\nCarpeta predeterminada: Plugin/hires_texture"
+#5024# "Utilizar transparencias totales (Recomendado para paquetes nuevos)"
+#5025# "Si se desactiva esta opcin, las texturas se cargarn igual que con Rice Video: Las transparencias son absolutas o nulas. Al activar esta opcin GlideN64 comprobar la forma en la que se ha diseado el canal alfa de la textura y seleccionar el formato ms adecuado. Esto da a los diseadores de paquetes libertad para utilizar texturas semitransparentes.\nDesactiva esta opcin si utilizas paquetes antiguos o pobremente diseados.\n[Recomendacin: Segn cada paquete de texturas]"
+#5026# "Clculo alternativo de CRC (Para paquetes antiguos para Rice Video)"
+#5027# "Esta opcin emula un fallo en el clculo del CRC de las paletas de RiceVideo. Si no se cargan algunas texturas, prueba a activar o desactivar esta opcin.\n[Recomendacin: Por norma general desactivado, activar para paquetes muy antiguos]"
+#5029# "Volcar/Editar texturas"
+#5030# "Esta opcin vuelca las texturas que aparezcan en pantalla a una carpeta con un paquete de texturas. Tambin puedes recargar las texturas mientras se ejecuta el juego para ver cmo quedan al momento, ahorrndote mucho tiempo!\nAtajos de teclado:\nPulsa R para recargar las texturas del paquete de texturas.\nPulsaD para activar o desactivar el volcado de texturas."
+#5032# "Las texturas mejoradas y filtradas pueden guardarse en una cach para mejorar el rendimiento. Esta opcin ajusta la cantidad de memoria que se dedicar a la cach de texturas. Puede mejorar el rendimiento si hay peticiones repetidas de la misma textura, que suele ocurrir. Normalmente deberan bastar 128 MB, pero cada juego tiene su valor ideal. Puede que Super Mario 64 no necesite ms de 32 MB, pero Conker's Bad Fur Day puede aprovechar ms de 256 MB. Cambia este parmetro si tienes problemas de velocidad. Si la opcin est a 0 desactivar la cach.\n[Recomendacin: En funcin del juego y de tu equipo]"
+#5033# "Guardar una cach de texturas mejoradas al disco duro"
+#5034# "Esta opcin guarda todas las texturas cargadas y mejoradas a tu PC. Cuando vuelvas a ejecutar el juego, no har falta recrear las texturas y mejorar el rendimiento.\nCuando utilices paquetes de texturas, su carga slo tardar unos segundos en vez de la media de 5 a 60 segundos que suele tardar. Sin embargo, si cambias el paquete de texturas, tendrs que borrar la cach de texturas de forma manual. Los archivos de cach se guardan en una carpeta llamada Cache, dentro de la carpeta plugins.\n[Recomendacin: Activado]"
+#5035# "Comprimir cach de texturas"
+#5036# "Se comprimirn las texturas para que entren ms texturas en la cach. La proporcin de compresin cambia segn la textura, pero suele ser de 1/5 del tamao original.\n[Recomendacin: Activado]"
+#5037# "Convertir texturas a 16 BPP"
+#5038# "Esta opcin reduce a la mitad el tamao que utilizan las texturas de la cach de texturas y de la memoria de la tarjeta grfica para mejorar el rendimiento. A la hora de reducir el color, GlideN64 intentar preservar la calidad original en la medida de lo posible. Es apenas imperceptible en la mayora de las texturas, pero algunas como los cielos quedarn peor.\n[Recomendacin: Desactivado]"
+
+/*********************************************************************************
+* On-screen display                                                              *
+*********************************************************************************/
+#6000# "Posicin"
+#6003# "Mostrar porcentaje"
+#6009# "Color:"
+#6010# "Demostracin"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "Acerca de GLideN64"
+#9001# "Acerca de"
+#9002# "Contribuyentes"
+#9003# "Financiadores"
+#9004# "Crditos"
+#9005# "La nueva generacin de los plugins grficos de cdigo abierto para emuladores de N64."
+#9006# "Autores"
+#9007# "Desarrollo"
+#9008# "Testeo de las betas"
+#9009# "Diseador de la interfaz"
+#9011# "Autor del plugin grfico original glN64"
+#9012# "Autor de gles2n64, una conversin de glN64 a GL ES 2.0"
+#9013# "Autor de la librera de texturas GlideHQ"
+#9014# "Autor de z64, un plugin LLE para OpenGL"
\ No newline at end of file
diff --git a/GLideN64/translations/wtl/gliden64_fr.Lang b/GLideN64/translations/wtl/gliden64_fr.Lang
new file mode 100644
index 00000000..550db094
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_fr.Lang
@@ -0,0 +1,160 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Franais"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# "Vido"
+#1001# "mulation"
+#1002# "Tampon image"
+#1003# "Amliorations des Textures"
+#1004# "OSD"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# "Vido"
+#2001# "Rsolution Plein Ecran :"
+#2002# "Toutes les rsolutions supportes par votre carte graphique / moniteur devraient tre affiches.\n[Recommand : Rsolution native (maximum) de votre moniteur - sauf si les performances sont dgrades]"
+#2003# "Taux de rafrachissement :"
+#2005# "Rsolution en Mode Fentr :"
+#2007# "Format d'cran :"
+#2008# "Cette option ajuste le format d'cran de la sortie vido. Tous les jeux N64 supportent 4:3. Quelques jeux supportent 16:9 dans leurs paramtrages. Utilisez tir pour remplir l'cran sans bords noirs.\nAjust  l'cran sans tirer tente d'ajuster l'espace de vue afin de remplir sans tirer. De nombreux jeux fonctionnent correctement en mode ajust, mais d'autres non."
+#2009# "4:3 (recommand)"
+#2010# "16:9"
+#2011# "tir"
+#2012# "Ajust  l'cran sans tirer"
+#2013# "Activer la synchro verticale"
+#2014# "La synchronisation verticale, ou VSync, peut amliorer l'image en synchronisant le taux d'chantillonage du jeu  celui du taux de rafrachissement de votre cran. Cela vite la dchirure de l'image, mais peut engendrer des problmes de performance.\n[Recommand : Gnralement dsactiv, sauf si vous avez des problmes de dchirure d'image]"
+#2025# "Off"
+#2026# "Max"
+#2030# "Filtrage Anisotropique :"
+#2031# "Off"
+#2032# "Max"
+#2033# "Filtrage bilinaire :"
+#2034# "Standard"
+#2035# "Style N64 3 points"
+#2036# "Filtrage bilinaire: les textures vont utiliser le filtrage bilinaire standard d'un PC.\nStyle N64 3 points: Les textures seront filtrs comme sur la N64. Le rsultat est moins lisse mais plus authentique."
+#2046# "Dsactiv"
+#2050# "Langue :"
+
+/*********************************************************************************
+* Emulation Tab                                                                  *
+*********************************************************************************/
+#3002# "Activer le mip-mapping N64"
+#3003# "La N64 utilise une mthode unique de mip-mapping qu'il est difficile de reproduire correctement sur les PCs. Quand elle est coche, cette option mule un mip-mapping N64 prcis. Quand elle est dcoche, certains jeux ont des textures distantes plus nettes.\n[Recommand : Activ]"
+#3004# "Activer l'clairage matriel (meilleure qualit, HLE seulement)"
+#3005# "Dans les jeux N64, l'clairage est calcul par vertex. Cette option active un Shader Phong, qui apporte un clairage plus doux et plus raliste.\n\n[Recommand : Selon votre prfrence]"
+#3006# "Stocker les Shaders compils pour plus de performance (recommand)"
+#3007# "Utiliser un stockage persistent pour compiler les Shaders.\nChaque jeu utilise un ensemble de combinateurs. Un combinateur est une quation qui dfinie couleur depuis des entres de couleurs diverses. GLideN64 traduit les Shaders, et les compile  la vole. Les Shaders sont larges et complexes. Si le jeu utilise de nombreux mlangeurs, la compilation des Shaders prendra du temps et engendrera des saccades. Quand cette option est coche, ces Shaders sont sauvegards et ne seront donc pas recompils la prochaine fois que vous lancerez le jeu.\n[Recommand : Activ]"
+#3008# "Rsolution interne :"
+#3009# "Cette option dfinie la taille de rendu du tampon de sortie. Par dfaut, le rendu est dfini sur Identique  la rsolution de sortie, mais vous pouvez la dfinir comme identique  la Rsolution N64 d'origine ou  un Multiple de la rsolution N64."
+#3010# "Identique  la rsolution de sortie"
+#3011# "Rsolution N64 d'origine (le plus prcis)"
+#3012# "Multiple de la rsolution N64 :"
+#3014# "Correction gamma.\nCertains jeux N64 utilise la correction gamma. La correction gamma rend l'image plus lumineuse. La N64 applique la correction gamma dans son Interface Vido. \nGLideN64 mule la correction gamma tel un effet de post-traitement. C'est pourquoi cela fonctionne uniquement si l'mulation du Tampon Image est active. La correction gamma est automatiquement active pour les jeux qui l'utilise nativement sur la N64. Vous pouvez forcer la correction gamma pour tous les jeux. La niveau de correction gamma par dfaut est 2, comme sur la N64.\n[Recommand : valeur par dfaut]"
+#3016# "Slectionner cette option outrepasse les corrections gamma dfinies par le jeu."
+#3019# "Quand cette option est active, les lments 2D sont restitus  la mme rsolution que la N64 avant de les copier vers la sortie. Gnralement, cela elimine les erreurs d'affichage avec les lments 2D, mais cela peut tre lent. Cette option utilise des heuristiques pour dtecter les lments 2D adjacents, cela ne fonctionne pas pour tous les jeux.\n[Recommand : Coch, sauf si vous avez des problmes de performance]"
+#3020# "Dsactiv"
+#3024# "Fixer les lignes noires entre les lments 2D :"
+#3025# "Dans certains jeux les coordones des sections d'lments 2D ne sont pas aligns : il y a un demi-pixel d'cart entre les lments adjacents. Quand le rendu est dfini  la rsolution N64 d'origine cela n'est pas visible, mais quand l'image est mise  l'chelle suprieure cela rsulte en l'affichage de lignes noires. Cette option tente de connecter les lments 2D.\nPour les lments 2D adjacents : Applique la correction seulement pour les polygones qui la ncessite. Slectionnez cette option pour les jeux qui affiche des lignes noires.\nToujours : Applique la correction pour tous les lments 2D. Slectionnez cette option quand Pour les lments 2D adjacents ne fonctionne pas.\nJamais : N'essaye pas de corriger les lignes noires entre les lments 2D.\n[Recommand : En fonction du jeu, gnralement Jamais]"
+#3026# "Pour les lments 2D adjacents"
+#3027# "Toujours"
+#3028# "Jamais"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "muler le Tampon Image"
+#4001# "Dcocher cette option dsactive de nombreux effets tels que le recadrage, le format d'cran, le facteur de rsolution N64, la comparaison de profondeur de la N64 et autres. Veuillez ne pas dcocher cette option sauf si vous avez des problmes de performance."
+#4002# "Copier les tampons couleur auxiliaires vers la mmoire de la N64 (parfois lent, moins de problmes en jeu)"
+#4003# "Quand l'option est coche, le tampon couleur auxiliaire est copi vers la mmoire de la N64 juste aprs la restitution. Cette option aide  corriger des effets du tampon image dans quelques jeux. Cela peut rduire significativement les performances.\n[Recommand : Gnralement dsactiv]"
+#4004# "Changer le tampon image :"
+#4005# "Cette option contrle la frquence de mise  jour du tampon image principal.\n l'interruption verticale : Met  jour le tampon aussi rapidement que possible :  chaque interruption verticale par seconde (50 pour les jeux PAL et 60 pour les jeux NTSC). C'est l'option qui offre la meilleure compatibilit. Utilisez ce mode sauf si vous avez des problmes de performance.\nAu changement d'origine VI : Le changement d'origine VI correspond au FPS actuel du jeu. Les jeux N64 tournent gnralement entre 20 et 30 FPS donc le tampon change moins souvent que le premier mode. Il ne fonctionne pas pour les jeux qui utilisent une mise en tampon unique, ce qui est rare.\nAu changement du Tampon Couleur : Cette option vrifie si le tampon image a chang. Il y a quelques jeux o cela ne fonctionne pas."
+#4006# " l'interruption verticale (recommand, le moins de problmes en jeu)"
+#4007# "Au changement d'origine VI (plus rapide, peu de problmes en jeu)"
+#4008# "Au changement du Tampon Couleur (le plus rapide, quelques problmes en jeu)"
+#4009# "Utiliser l'aide de l'mulateur pour lire/crire dans le tampon image"
+#4010# "Certains mulateurs ne dtectent pas ou mal quand lire/crire dans le tampon image. Vous pouvez dsactiver l'aide de l'mulateur pour laisser GLideN64 lire/crire dans le tampon image.\n[Recommand : Gnralement dsactiv, mais avec certains jeux/mulateurs les performances sont meilleures quand l'option est active]"
+#4011# "Lire les tampons couleur par blocs de 4 Ko"
+#4012# "Quand l'option est active, le tampon couleur sera lu par blocs. Sinon il sera lu dans son intgralit. Si un jeu a besoin de lire entirement le tampon, slectionner cette option peut rduire les performances.\n[Recommand : Gnralement dsactiv, car le tampon de couleur est souvent lu dans son intgralit]"
+#4013# "Lire les tampons de profondeur par blocs de 4 Ko"
+#4014# "Quand l'option est active, le tampon de profondeur sera lu par blocs. Sinon il sera lu dans son intgralit. Si un jeu a besoin de lire entirement le tampon, slectionner cette option peut rduire les performances.\n[Recommand : Activ, car le tampon de profondeur n'est pas souvent lu dans son intgralit]"
+#4015# "Copier le tampon image de votre carte graphique vers la mmoire N64 :"
+#4016# "Dans certains jeux GLideN64 ne peut pas dtecter l'utilisation du tampon image. Avec ces options, GLideN64 copie chaque image du tamon image de votre carte graphique vers la mmoire N64.\nJamais : Dsactive la copie du tampon de votre carte graphique.\nSynchrone : Les effets sont dtects pour tous les jeux, mais cela peut tre lent. Utilisez cette option pour les jeux o Asynchrone ne fonctionne pas.\nAsynchrone : Les effets sont dtects pour de nombreux jeux.\n[Recommand : Gnralement Asynchrone]"
+#4017# "Jamais (le plus rapide, nombreux problmes en jeu)"
+#4018# "Synchrone (le plus lent, le moins de problmes en jeu)"
+#4019# "Asynchrone (rapide, peu de problmes en jeu)"
+#4020# "Copier le tampon de profondeur de votre carte graphique vers la mmoire N64 :"
+#4022# "Jamais (le plus rapide, le plus de problmes en jeu)"
+#4023# "Depuis la VRAM (lent, quelques problmes en jeu)"
+#4024# "Dans le logiciel (rapide, le moins de problmes en jeu)"
+#4027# "Dsactiv"
+#4032# "Restituer le tampon image N64 vers la sortie"
+#4033# "Quand cette option est active, le tampon image est restitu directement vers l'cran. Cela permet de corriger certains problmes graphiques mais peut causer des ralentissements et rduire la qualit visuelle.\n[Recommand : Gnralement dsactiv]"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5000# "Textures N64"
+#5001# "Filtre :"
+#5002# "Ce filtre lisse ou affine les textures. Il y a 4 filtres de lissage et 2 filtres d'affinement. Plus le nombre est lev, plus l'effet est important. Veuillez noter que les performances peuvent tre impactes suivant le jeu et/ou le PC.\n[Recommand : selon votre prfrence]"
+#5003# "Aucun"
+#5004# "Filtrage lisse 1"
+#5005# "Filtrage lisse 2"
+#5006# "Filtrage lisse 3"
+#5007# "Filtrage lisse 4"
+#5008# "Filtrage affin 1"
+#5009# "Filtrage affin 2"
+#5010# "Amliorations :"
+#5011# "12 filtres diffrents sont slectionnables. Selon le filtre, il peut y avoir un impact sur les performances.\nQuand le mode Stocker est slectionn, les textures sont sauvegardes dans le cache 'tel quel'. Cela augmente les performances dans les jeux chargeant de nombreuses textures. Dcoch Dsactiver pour les arrire-plans pour un meilleur rsultat.\n[Recommand : selon votre prfrence]"
+#5012# "Aucun"
+#5013# "Stocker"
+#5014# "Rduire les bandes de couleur (recommand pour l'amlioration xBRZ)"
+#5015# "Cette option active une tape de pr-processing qui rduit les problmes de postrisation sur les textures amliores.\n[Recommand : Activ pour le filtre xBRZ]"
+#5016# "Dsactiver pour les arrire-plans"
+#5017# "Cette option ignore l'amlioration pour les textures lointaines et troites gnralement utilises pour les arrire-plans. Cela peut rduire la mmoire utilise pour la sauvegarde des textures et augmenter les performances.\n[Recommand : Activ, sauf si l'option Amliorations est dfinie sur 'Store']"
+#5019# "Utiliser un Pack de Textures"
+#5020# "Chemin des Packs de Textures :"
+#5021# "Slectionne le rpertoire contenant les packs de textures.\nPar dfaut : Plugin/hires_texture"
+#5024# "Utiliser les transparences compltes (recommand pour les packs de textures rcents)"
+#5025# "Quand cette option est dsactive, les textures seront charges tel qu'elles le seraient avec Rice Video : la transparence est soit active, soit inactive. Quand cette option est slectionne, GlideN64 vrifie comment le canal alpha de la texture a t conu et utilise le format le plus appropri. Cela donne aux dveloppeurs de pack de textures la libert d'utiliser des textures semi-transparentes.\nDsactivez cette option pour les vieux pack de textures ou ceux mal conus.\n[Recommand : en fonction du pack de textures]"
+#5026# "Calcul alternatif du CRC (pour les vieux packs Rice Video)"
+#5027# "Cette option mule un bug dans le plugin RiceVideo sur le calcul CRC de la palette. Si certaines textures ne sont pas charges, positionnez cette option  'activ' ou 'dsactiv'.\n[Recommand : principalement dsactiv, activ pour les vieux packs de textures]"
+#5029# "Dumper/diter les textures"
+#5030# "Cette option permet de dumper les textures affiches  l'cran vers le rpertoire des packs de textures. Vous pouvez galement recharger les textures quand le jeu est dmarr pour voir le rsultat instantanment - quel gain de temps !\nTouches de raccourcis : \nUtilisez R pour recharger les textures du pack de textures.\nUtilisez D pour le basculer le mode de dumpimg sur activ/dsactiv."
+#5032# "Les textures amliores et filtres peuvent tre mises en cache. Ce paramtre ajustera la quantit de mmoire alloue pour le cache des textures. Cela amliore les performances si un nombre consquent de requtes appelle les mmes textures, ce qui est gnralement le cas. Par dfaut, 128 Mo devraient tre suffisant mais cela peut varier selon les jeux. Super Mario 64 peut ncessiter moins de 32 Mo, mais Conker's Bad Fur Day peut ncessiter plus de 256 Mo. Ajustez la valeur si vous rencontrez des problmes de performances. La valeur '0' dsactive le cache.\n[Recommand : en fonction du jeu et du PC]"
+#5033# "Sauvegarder le cache d'amlioration des textures sur le disque"
+#5034# "Cette option sauvegardera toutes les textures prcdemment charges et celles amliores sur le disque. Au prochain dmarrage du jeu, les textures n'auront pas  tre recres, ce qui amliore les performances.\nQuand vous utilisez des packs de textures, leur chargement ne prendra que quelques secondes au lancement du jeu, au lieu de 5  60 secondes habituellement. Par contre, si le pack de texture est modifi vous devrez supprimer manuellement le cache. Les fichiers de cache sont sauvegards dans le sous-dossier 'Cache' du dossier contenant le plugin.\n[Recommand : Activ]"
+#5035# "Compresser le Cache de Texture"
+#5036# "Les textures seront compresses, ainsi plus de textures pourront tre mises en cache. Le ratio de compression varie suivant les textures, mais il est en moyenne de 1/5 par rapport  la taille originale.\n[Recommand : Activ]"
+#5037# "Convertir les textures en 16 bits"
+#5038# "Cette option rduit de moiti l'espace occup par les textures dans le cache ainsi que celui de la mmoire de votre carte graphique, cela afin d'amliorer les performances. Quand la taille du codage de la couleur est rduite, GLideN64 essaye de prserver la qualit originale autant que possible. Sur certaines textures c'est difficilement visible, mais sur d'autres, tel le ciel, le rendu peut tre mauvais.\n[Recommand : Dsactiv]"
+
+/*********************************************************************************
+* On-screen display                                                              *
+*********************************************************************************/
+#6000# "Position"
+#6003# "Afficher le pourcentage"
+#6009# "Couleur :"
+#6010# "Prvisualisation"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "A Propos De GLideN64"
+#9001# "A Propos De"
+#9002# "Contributeurs"
+#9003# "Donateurs"
+#9004# "Crdits"
+#9005# "La nouvelle gnration de plugin graphique open source pour les mulateurs N64."
+#9006# "Auteurs"
+#9007# "Dveloppeur"
+#9008# "Bta testeur"
+#9009# "Concepteur de l'interface graphique"
+#9011# "Auteur du plugin graphique original glN64"
+#9012# "Auteur de gles2n64, un portage de glN64 vers GL ES 2.0"
+#9013# "Auteur de la librairie de texture GlideHQ"
+#9014# "Auteur de z64, un plugin OpenGL LLE"
\ No newline at end of file
diff --git a/GLideN64/translations/wtl/gliden64_it.Lang b/GLideN64/translations/wtl/gliden64_it.Lang
new file mode 100644
index 00000000..32e84289
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_it.Lang
@@ -0,0 +1,42 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Italiano"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1001# "Emulazione"
+#1003# "Miglioramenti texture"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2001# "Risoluzione a schermo intero:"
+#2003# "Frequenza di aggiornamento:"
+#2005# "Risoluzione finestra:"
+#2011# "Adatta"
+#2030# "Filtro Anisotropico:"
+#2050# "Lingua:"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "Emula il frame buffer"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5001# "Filtro:"
+#5010# "Miglioramento:"
+#5019# "Utilizza un pacchetto texture modificate"
+#5020# "Percorso cartella pacchetti texture:"
+#5035# "Comprimi cache texture"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "Riguardo a GlideN64"
+#9003# "Finanziatori"
+#9004# "Crediti"
+#9006# "Autori"
diff --git a/GLideN64/translations/wtl/gliden64_ja.Lang b/GLideN64/translations/wtl/gliden64_ja.Lang
new file mode 100644
index 00000000..5213b3b3
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_ja.Lang
@@ -0,0 +1,45 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Japanese"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# ""
+#1001# ""
+#1003# ""
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# ""
+#2001# ":"
+#2003# ":"
+#2005# ":"
+#2010# "16:9"
+#2011# ""
+#2030# ":"
+#2050# ":"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# ""
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5001# " :"
+#5010# ":"
+#5019# ""
+#5020# ":"
+#5035# ""
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "GLideN64"
+#9003# ""
+#9004# ""
+#9006# ""
diff --git a/GLideN64/translations/wtl/gliden64_pl.Lang b/GLideN64/translations/wtl/gliden64_pl.Lang
new file mode 100644
index 00000000..bbf81d05
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_pl.Lang
@@ -0,0 +1,45 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Polski"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# "Obraz"
+#1001# "Emulacja"
+#1003# "Uwydatnienie tekstur"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# "Obraz"
+#2001# "Rozdzielczo penoekranowa:"
+#2003# "Czstotliwo odwieania:"
+#2005# "Rozdzielczo w oknie:"
+#2010# "16:9"
+#2011# "Rozcignij"
+#2030# "Filtrowanie anizotropowe:"
+#2050# "Jzyk:"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "Emuluj bufor ramki"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5001# "Filtr:"
+#5010# "Uwydatnienie:"
+#5019# "Uyj paczki tekstur"
+#5020# "cieka paczek tekstur:"
+#5035# "Kompresuj pami podrczn tekstur"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "O GLideN64"
+#9003# "Darczycy"
+#9004# "Inni twrcy"
+#9006# "Autorzy"
\ No newline at end of file
diff --git a/GLideN64/translations/wtl/gliden64_pt_BR.Lang b/GLideN64/translations/wtl/gliden64_pt_BR.Lang
new file mode 100644
index 00000000..b75295c5
--- /dev/null
+++ b/GLideN64/translations/wtl/gliden64_pt_BR.Lang
@@ -0,0 +1,45 @@
+/*********************************************************************************
+* Meta Information                                                               *
+*********************************************************************************/
+#0001# "Portugus Brasileiro"
+
+/*********************************************************************************
+* Config Dialog                                                                  *
+*********************************************************************************/
+#1000# "Vdeo"
+#1001# "Emulao"
+#1003# "Melhoramento de Textura"
+
+/*********************************************************************************
+* Video Tab                                                                      *
+*********************************************************************************/
+#2000# "Vdeo"
+#2001# "Resoluo Tela Cheia:"
+#2003# "Freqncia do Refresh:"
+#2005# "Resoluo de Janela:"
+#2010# "16:9"
+#2011# "Estendido"
+#2030# "Filtragem Anisotrpica:"
+#2050# "Lngua:"
+
+/*********************************************************************************
+* Frame Buffer Tab                                                               *
+*********************************************************************************/
+#4000# "Emula frame buffer"
+
+/*********************************************************************************
+* Texture enhancement                                                            *
+*********************************************************************************/
+#5001# "Filtro:"
+#5010# "Melhoramento:"
+#5019# "Usa pacote de textura"
+#5020# "Local dos pacotes de textura:"
+#5035# "Compacta cache de textura"
+
+/*********************************************************************************
+* About                                                                          *
+*********************************************************************************/
+#9000# "Sobre GLideN64"
+#9003# "Financiadores"
+#9004# "Crditos"
+#9006# "Autores"
\ No newline at end of file

From 08ff370c2ee6b88b4afed8421acd0387050bfc46 Mon Sep 17 00:00:00 2001
From: David Lawson <dmrlawson@gmail.com>
Date: Thu, 30 Apr 2020 13:31:29 +0100
Subject: [PATCH 03/28] Always return -1 from HleForwardTask

We don't have LLE yet so this means we don't try to forward things to an LLE implementation. Fixes F-Zero X Expansion
---
 mupen64plus-rsp-hle/src/plugin.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/mupen64plus-rsp-hle/src/plugin.c b/mupen64plus-rsp-hle/src/plugin.c
index 19ccbcea..53a61bf4 100644
--- a/mupen64plus-rsp-hle/src/plugin.c
+++ b/mupen64plus-rsp-hle/src/plugin.c
@@ -144,7 +144,7 @@ void HleShowCFB(void* UNUSED(user_defined))
 
 int HleForwardTask(void* user_defined)
 {
-    return 0;
+    return -1;
 }
 
 /* DLL-exported functions */

From 8c08c98e0c36e0997d2d860c0e0200715620cc57 Mon Sep 17 00:00:00 2001
From: David Lawson <davidlawson@gambitresearch.com>
Date: Tue, 5 May 2020 10:50:34 +0100
Subject: [PATCH 04/28] Add script to generate header files from
 mupen64plus-core and GLideN64 ini files

---
 generate-ini-headers.sh | 30 ++++++++++++++++++++++++++++++
 1 file changed, 30 insertions(+)
 create mode 100755 generate-ini-headers.sh

diff --git a/generate-ini-headers.sh b/generate-ini-headers.sh
new file mode 100755
index 00000000..9a3996f3
--- /dev/null
+++ b/generate-ini-headers.sh
@@ -0,0 +1,30 @@
+#!/bin/bash
+
+# Make sure we're in the script's directory
+cd "$(dirname "$0")"
+
+# Generate mupen64plus.ini.h
+MUPEN_CORE_HEADER="#ifndef __INIFILE_H__
+#define __INIFILE_H__
+
+char inifile[] =
+"
+MUPEN_CORE_CONTENTS=$(while read -r f; do sed -nr 's/\\/\\\\/g; s/$/\\n/g; s/(^.*$)/"\1"/gp' <<< $f ; done < ./mupen64plus-core/data/mupen64plus.ini)
+MUPEN_CORE_FOOTER=";
+
+#endif
+"
+cat <<< ${MUPEN_CORE_HEADER}${MUPEN_CORE_CONTENTS}${MUPEN_CORE_FOOTER} > custom/mupen64plus-core/main/mupen64plus.ini.h
+
+# Generate GLideN64.custom.ini.h 
+GLIDEN64_HEADER="#ifndef __CUSTOM_INI__
+#define __CUSTOM_INI__
+
+char customini[] =
+"
+GLIDEN64_CONTENTS=$(while read -r f; do sed -nr 's/\\/\\\\/g; s/$/\\n/g; s/(^.*$)/"\1"/gp' <<< $f; done < ./GLideN64/ini/GLideN64.custom.ini)
+GLIDEN64_FOOTER=";
+
+#endif
+"
+cat <<< ${GLIDEN64_HEADER}${GLIDEN64_CONTENTS}${GLIDEN64_FOOTER} > custom/GLideN64/GLideN64.custom.ini.h

From 7f6856b6bcc8f5abf6d72ee9a245ba154b9e9b82 Mon Sep 17 00:00:00 2001
From: David Lawson <dmrlawson@gmail.com>
Date: Tue, 5 May 2020 22:39:43 +0100
Subject: [PATCH 05/28] [Squash later] Make rebase branch build (#185)

- Remove noise emulation config
 - Fix CRC function specs
---
 Makefile.common                                |  3 +--
 custom/GLideN64/CRC.cpp                        |  5 +++--
 custom/GLideN64/GLideN64_libretro.h            |  1 -
 custom/GLideN64/mupenplus/Config_mupenplus.cpp |  1 -
 libretro/libretro.c                            | 11 -----------
 5 files changed, 4 insertions(+), 17 deletions(-)

diff --git a/Makefile.common b/Makefile.common
index 2cb542cb..3d81e642 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -150,8 +150,6 @@ SOURCES_C += \
 COREFLAGS += -I$(CORE_DIR)/subprojects/minizip
 
 # xxHash
-SOURCES_C += \
-	$(CORE_DIR)/subprojects/xxhash/xxhash.c
 COREFLAGS += -I$(CORE_DIR)/subprojects/xxhash
 
 ifneq (,$(findstring win,$(platform)))
@@ -268,6 +266,7 @@ SOURCES_CXX   += \
     $(VIDEODIR_GLIDEN64)/src/NoiseTexture.cpp                                                     \
     $(VIDEODIR_GLIDEN64)/src/DepthBufferRender/ClipPolygon.cpp                                    \
     $(VIDEODIR_GLIDEN64)/src/DepthBufferRender/DepthBufferRender.cpp                              \
+    $(VIDEODIR_GLIDEN64)/src/BufferCopy/BlueNoiseTexture.cpp                                    \
     $(VIDEODIR_GLIDEN64)/src/BufferCopy/ColorBufferToRDRAM.cpp                                    \
     $(VIDEODIR_GLIDEN64)/src/BufferCopy/DepthBufferToRDRAM.cpp                                    \
     $(VIDEODIR_GLIDEN64)/src/BufferCopy/RDRAMtoColorBuffer.cpp                                    \
diff --git a/custom/GLideN64/CRC.cpp b/custom/GLideN64/CRC.cpp
index 8df260d6..75d7585d 100644
--- a/custom/GLideN64/CRC.cpp
+++ b/custom/GLideN64/CRC.cpp
@@ -1,4 +1,5 @@
 #include "CRC.h"
+#define XXH_INLINE_ALL
 #include "xxhash.h"
 
 #define CRC32_POLYNOMIAL     0x04C11DB7
@@ -45,7 +46,7 @@ u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
 	return crc ^ orig;
 }
 
-u32 CRC_Calculate( u32 crc, const void * buffer, u32 count )
+u64 CRC_Calculate( u64 crc, const void * buffer, u32 count )
 {
 #ifdef __x86_64__
 	return XXH64(buffer, count, crc);
@@ -54,7 +55,7 @@ u32 CRC_Calculate( u32 crc, const void * buffer, u32 count )
 #endif
 }
 
-u32 CRC_CalculatePalette(u32 crc, const void * buffer, u32 count )
+u64 CRC_CalculatePalette(u64 crc, const void * buffer, u32 count )
 {
 	u8 *p;
 	u32 orig = crc;
diff --git a/custom/GLideN64/GLideN64_libretro.h b/custom/GLideN64/GLideN64_libretro.h
index a5e277b4..bc7b4c5e 100644
--- a/custom/GLideN64/GLideN64_libretro.h
+++ b/custom/GLideN64/GLideN64_libretro.h
@@ -59,7 +59,6 @@ extern uint32_t EnableShadersStorage;
 extern uint32_t EnableTextureCache;
 extern uint32_t EnableFBEmulation;
 extern uint32_t EnableFrameDuping;
-extern uint32_t EnableNoiseEmulation;
 extern uint32_t EnableLODEmulation;
 extern uint32_t EnableFullspeed;
 extern uint32_t CountPerOp;
diff --git a/custom/GLideN64/mupenplus/Config_mupenplus.cpp b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
index 992b8ede..ceecaf10 100644
--- a/custom/GLideN64/mupenplus/Config_mupenplus.cpp
+++ b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
@@ -122,7 +122,6 @@ extern "C" void Config_LoadConfig()
 	config.texture.bilinearMode = bilinearMode;
 	config.generalEmulation.enableHWLighting = EnableHWLighting;
 	config.generalEmulation.enableLegacyBlending = enableLegacyBlending;
-	config.generalEmulation.enableNoise = EnableNoiseEmulation;
 	config.generalEmulation.enableLOD = EnableLODEmulation;
 	
 	config.frameBufferEmulation.copyDepthToRDRAM = EnableCopyDepthToRDRAM;
diff --git a/libretro/libretro.c b/libretro/libretro.c
index 9d00e413..32e2e3c9 100644
--- a/libretro/libretro.c
+++ b/libretro/libretro.c
@@ -184,7 +184,6 @@ uint32_t EnableShadersStorage = 0;
 uint32_t EnableTextureCache = 0;
 uint32_t EnableFBEmulation = 0;
 uint32_t EnableFrameDuping = 0;
-uint32_t EnableNoiseEmulation = 0;
 uint32_t EnableLODEmulation = 0;
 uint32_t EnableFullspeed = 0;
 uint32_t CountPerOp = 0;
@@ -259,9 +258,6 @@ static void setup_variables(void)
         { CORE_NAME "-FXAA",
             "(GLN64) FXAA; 0|1" },
 
-        { CORE_NAME "-NoiseEmulation",
-            "(GLN64) Noise Emulation; True|False" },
-
         { CORE_NAME "-EnableFBEmulation",
 #ifdef VC
             "(GLN64) Framebuffer Emulation; False|True" },
@@ -826,13 +822,6 @@ static void update_variables(bool startup)
           CountPerScanlineOverride = !strcmp(var.value, "Auto") ? 0 : atoi(var.value);
        }
 
-       var.key = CORE_NAME "-NoiseEmulation";
-       var.value = NULL;
-       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
-       {
-          EnableNoiseEmulation = !strcmp(var.value, "False") ? 0 : 1;
-       }
-
        var.key = CORE_NAME "-EnableLODEmulation";
        var.value = NULL;
        if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)

From 647c13011d11f9f13f207d1e5273b61a1440bdb2 Mon Sep 17 00:00:00 2001
From: David Lawson <dmrlawson@gmail.com>
Date: Wed, 6 May 2020 10:45:43 +0100
Subject: [PATCH 06/28] [Squash] Don't include xxhash from mupen64plus-core
 (#190)

---
 Makefile.common |    3 -
 xxHash/xxh3.h   | 2112 +++++++++++++++++++++++++++++++++++++++++++++++
 xxHash/xxhash.c |  888 --------------------
 xxHash/xxhash.h | 1964 +++++++++++++++++++++++++++++++++++++++----
 4 files changed, 3918 insertions(+), 1049 deletions(-)
 create mode 100644 xxHash/xxh3.h
 delete mode 100644 xxHash/xxhash.c

diff --git a/Makefile.common b/Makefile.common
index 3d81e642..c7caf096 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -149,9 +149,6 @@ SOURCES_C += \
 	$(CORE_DIR)/subprojects/minizip/ioapi.c
 COREFLAGS += -I$(CORE_DIR)/subprojects/minizip
 
-# xxHash
-COREFLAGS += -I$(CORE_DIR)/subprojects/xxhash
-
 ifneq (,$(findstring win,$(platform)))
 	SOURCES_C += $(VIDEODIR_GLIDEN64)/src/osal/osal_files_win32.c
 else
diff --git a/xxHash/xxh3.h b/xxHash/xxh3.h
new file mode 100644
index 00000000..9e3e88ad
--- /dev/null
+++ b/xxHash/xxh3.h
@@ -0,0 +1,2112 @@
+/*
+ * xxHash - Extremely Fast Hash algorithm
+ * Development source file for `xxh3`
+ * Copyright (C) 2019-present, Yann Collet
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
+
+/*
+ * Note: This file is separated for development purposes.
+ * It will be integrated into `xxhash.h` when development stage is completed.
+ *
+ * Credit: most of the work on vectorial and asm variants comes from @easyaspi314
+ */
+
+#ifndef XXH3_H_1397135465
+#define XXH3_H_1397135465
+
+/* ===   Dependencies   === */
+#ifndef XXHASH_H_5627135585666179
+/* special: when including `xxh3.h` directly, turn on XXH_INLINE_ALL */
+#  undef XXH_INLINE_ALL   /* avoid redefinition */
+#  define XXH_INLINE_ALL
+#endif
+#include "xxhash.h"
+
+
+/* ===   Compiler specifics   === */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* >= C99 */
+#  define XXH_RESTRICT   restrict
+#else
+/* Note: it might be useful to define __restrict or __restrict__ for some C++ compilers */
+#  define XXH_RESTRICT   /* disable */
+#endif
+
+#if (defined(__GNUC__) && (__GNUC__ >= 3))  \
+  || (defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 800)) \
+  || defined(__clang__)
+#    define XXH_likely(x) __builtin_expect(x, 1)
+#    define XXH_unlikely(x) __builtin_expect(x, 0)
+#else
+#    define XXH_likely(x) (x)
+#    define XXH_unlikely(x) (x)
+#endif
+
+#if defined(__GNUC__)
+#  if defined(__AVX2__)
+#    include <immintrin.h>
+#  elif defined(__SSE2__)
+#    include <emmintrin.h>
+#  elif defined(__ARM_NEON__) || defined(__ARM_NEON)
+#    define inline __inline__  /* clang bug */
+#    include <arm_neon.h>
+#    undef inline
+#  endif
+#elif defined(_MSC_VER)
+#  include <intrin.h>
+#endif
+
+/*
+ * One goal of XXH3 is to make it fast on both 32-bit and 64-bit, while
+ * remaining a true 64-bit/128-bit hash function.
+ *
+ * This is done by prioritizing a subset of 64-bit operations that can be
+ * emulated without too many steps on the average 32-bit machine.
+ *
+ * For example, these two lines seem similar, and run equally fast on 64-bit:
+ *
+ *   xxh_u64 x;
+ *   x ^= (x >> 47); // good
+ *   x ^= (x >> 13); // bad
+ *
+ * However, to a 32-bit machine, there is a major difference.
+ *
+ * x ^= (x >> 47) looks like this:
+ *
+ *   x.lo ^= (x.hi >> (47 - 32));
+ *
+ * while x ^= (x >> 13) looks like this:
+ *
+ *   // note: funnel shifts are not usually cheap.
+ *   x.lo ^= (x.lo >> 13) | (x.hi << (32 - 13));
+ *   x.hi ^= (x.hi >> 13);
+ *
+ * The first one is significantly faster than the second, simply because the
+ * shift is larger than 32. This means:
+ *  - All the bits we need are in the upper 32 bits, so we can ignore the lower
+ *    32 bits in the shift.
+ *  - The shift result will always fit in the lower 32 bits, and therefore,
+ *    we can ignore the upper 32 bits in the xor.
+ *
+ * Thanks to this optimization, XXH3 only requires these features to be efficient:
+ *
+ *  - Usable unaligned access
+ *  - A 32-bit or 64-bit ALU
+ *      - If 32-bit, a decent ADC instruction
+ *  - A 32 or 64-bit multiply with a 64-bit result
+ *  - For the 128-bit variant, a decent byteswap helps short inputs.
+ *
+ * The first two are already required by XXH32, and almost all 32-bit and 64-bit
+ * platforms which can run XXH32 can run XXH3 efficiently.
+ *
+ * Thumb-1, the classic 16-bit only subset of ARM's instruction set, is one
+ * notable exception.
+ *
+ * First of all, Thumb-1 lacks support for the UMULL instruction which
+ * performs the important long multiply. This means numerous __aeabi_lmul
+ * calls.
+ *
+ * Second of all, the 8 functional registers are just not enough.
+ * Setup for __aeabi_lmul, byteshift loads, pointers, and all arithmetic need
+ * Lo registers, and this shuffling results in thousands more MOVs than A32.
+ *
+ * A32 and T32 don't have this limitation. They can access all 14 registers,
+ * do a 32->64 multiply with UMULL, and the flexible operand allowing free
+ * shifts is helpful, too.
+ *
+ * Therefore, we do a quick sanity check.
+ *
+ * If compiling Thumb-1 for a target which supports ARM instructions, we will
+ * emit a warning, as it is not a "sane" platform to compile for.
+ *
+ * Usually, if this happens, it is because of an accident and you probably need
+ * to specify -march, as you likely meant to compile for a newer architecture.
+ */
+#if defined(__thumb__) && !defined(__thumb2__) && defined(__ARM_ARCH_ISA_ARM)
+#   warning "XXH3 is highly inefficient without ARM or Thumb-2."
+#endif
+
+/* ==========================================
+ * Vectorization detection
+ * ========================================== */
+#define XXH_SCALAR 0 /* Portable scalar version */
+#define XXH_SSE2   1 /* SSE2 for Pentium 4 and all x86_64 */
+#define XXH_AVX2   2 /* AVX2 for Haswell and Bulldozer */
+#define XXH_NEON   3 /* NEON for most ARMv7-A and all AArch64 */
+#define XXH_VSX    4 /* VSX and ZVector for POWER8/z13 */
+
+#ifndef XXH_VECTOR    /* can be defined on command line */
+#  if defined(__AVX2__)
+#    define XXH_VECTOR XXH_AVX2
+#  elif defined(__SSE2__) || defined(_M_AMD64) || defined(_M_X64) || (defined(_M_IX86_FP) && (_M_IX86_FP == 2))
+#    define XXH_VECTOR XXH_SSE2
+#  elif defined(__GNUC__) /* msvc support maybe later */ \
+  && (defined(__ARM_NEON__) || defined(__ARM_NEON)) \
+  && (defined(__LITTLE_ENDIAN__) /* We only support little endian NEON */ \
+    || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__))
+#    define XXH_VECTOR XXH_NEON
+#  elif (defined(__PPC64__) && defined(__POWER8_VECTOR__)) \
+     || (defined(__s390x__) && defined(__VEC__)) \
+     && defined(__GNUC__) /* TODO: IBM XL */
+#    define XXH_VECTOR XXH_VSX
+#  else
+#    define XXH_VECTOR XXH_SCALAR
+#  endif
+#endif
+
+/*
+ * Controls the alignment of the accumulator.
+ * This is for compatibility with aligned vector loads, which are usually faster.
+ */
+#ifndef XXH_ACC_ALIGN
+#  if XXH_VECTOR == XXH_SCALAR  /* scalar */
+#     define XXH_ACC_ALIGN 8
+#  elif XXH_VECTOR == XXH_SSE2  /* sse2 */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_AVX2  /* avx2 */
+#     define XXH_ACC_ALIGN 32
+#  elif XXH_VECTOR == XXH_NEON  /* neon */
+#     define XXH_ACC_ALIGN 16
+#  elif XXH_VECTOR == XXH_VSX   /* vsx */
+#     define XXH_ACC_ALIGN 16
+#  endif
+#endif
+
+/*
+ * UGLY HACK:
+ * GCC usually generates the best code with -O3 for xxHash.
+ *
+ * However, when targeting AVX2, it is overzealous in its unrolling resulting
+ * in code roughly 3/4 the speed of Clang.
+ *
+ * There are other issues, such as GCC splitting _mm256_loadu_si256 into
+ * _mm_loadu_si128 + _mm256_inserti128_si256. This is an optimization which
+ * only applies to Sandy and Ivy Bridge... which don't even support AVX2.
+ *
+ * That is why when compiling the AVX2 version, it is recommended to use either
+ *   -O2 -mavx2 -march=haswell
+ * or
+ *   -O2 -mavx2 -mno-avx256-split-unaligned-load
+ * for decent performance, or to use Clang instead.
+ *
+ * Fortunately, we can control the first one with a pragma that forces GCC into
+ * -O2, but the other one we can't control without "failed to inline always
+ * inline function due to target mismatch" warnings.
+ */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC push_options
+#  pragma GCC optimize("-O2")
+#endif
+
+
+#if XXH_VECTOR == XXH_NEON
+/*
+ * NEON's setup for vmlal_u32 is a little more complicated than it is on
+ * SSE2, AVX2, and VSX.
+ *
+ * While PMULUDQ and VMULEUW both perform a mask, VMLAL.U32 performs an upcast.
+ *
+ * To do the same operation, the 128-bit 'Q' register needs to be split into
+ * two 64-bit 'D' registers, performing this operation::
+ *
+ *   [                a                 |                 b                ]
+ *            |              '---------. .--------'                |
+ *            |                         x                          |
+ *            |              .---------' '--------.                |
+ *   [ a & 0xFFFFFFFF | b & 0xFFFFFFFF ],[    a >> 32     |     b >> 32    ]
+ *
+ * Due to significant changes in aarch64, the fastest method for aarch64 is
+ * completely different than the fastest method for ARMv7-A.
+ *
+ * ARMv7-A treats D registers as unions overlaying Q registers, so modifying
+ * D11 will modify the high half of Q5. This is similar to how modifying AH
+ * will only affect bits 8-15 of AX on x86.
+ *
+ * VZIP takes two registers, and puts even lanes in one register and odd lanes
+ * in the other.
+ *
+ * On ARMv7-A, this strangely modifies both parameters in place instead of
+ * taking the usual 3-operand form.
+ *
+ * Therefore, if we want to do this, we can simply use a D-form VZIP.32 on the
+ * lower and upper halves of the Q register to end up with the high and low
+ * halves where we want - all in one instruction.
+ *
+ *   vzip.32   d10, d11       @ d10 = { d10[0], d11[0] }; d11 = { d10[1], d11[1] }
+ *
+ * Unfortunately we need inline assembly for this: Instructions modifying two
+ * registers at once is not possible in GCC or Clang's IR, and they have to
+ * create a copy.
+ *
+ * aarch64 requires a different approach.
+ *
+ * In order to make it easier to write a decent compiler for aarch64, many
+ * quirks were removed, such as conditional execution.
+ *
+ * NEON was also affected by this.
+ *
+ * aarch64 cannot access the high bits of a Q-form register, and writes to a
+ * D-form register zero the high bits, similar to how writes to W-form scalar
+ * registers (or DWORD registers on x86_64) work.
+ *
+ * The formerly free vget_high intrinsics now require a vext (with a few
+ * exceptions)
+ *
+ * Additionally, VZIP was replaced by ZIP1 and ZIP2, which are the equivalent
+ * of PUNPCKL* and PUNPCKH* in SSE, respectively, in order to only modify one
+ * operand.
+ *
+ * The equivalent of the VZIP.32 on the lower and upper halves would be this
+ * mess:
+ *
+ *   ext     v2.4s, v0.4s, v0.4s, #2 // v2 = { v0[2], v0[3], v0[0], v0[1] }
+ *   zip1    v1.2s, v0.2s, v2.2s     // v1 = { v0[0], v2[0] }
+ *   zip2    v0.2s, v0.2s, v1.2s     // v0 = { v0[1], v2[1] }
+ *
+ * Instead, we use a literal downcast, vmovn_u64 (XTN), and vshrn_n_u64 (SHRN):
+ *
+ *   shrn    v1.2s, v0.2d, #32  // v1 = (uint32x2_t)(v0 >> 32);
+ *   xtn     v0.2s, v0.2d       // v0 = (uint32x2_t)(v0 & 0xFFFFFFFF);
+ *
+ * This is available on ARMv7-A, but is less efficient than a single VZIP.32.
+ */
+
+/*
+ * Function-like macro:
+ * void XXH_SPLIT_IN_PLACE(uint64x2_t &in, uint32x2_t &outLo, uint32x2_t &outHi)
+ * {
+ *     outLo = (uint32x2_t)(in & 0xFFFFFFFF);
+ *     outHi = (uint32x2_t)(in >> 32);
+ *     in = UNDEFINED;
+ * }
+ */
+# if !defined(XXH_NO_VZIP_HACK) /* define to disable */ \
+   && defined(__GNUC__) \
+   && !defined(__aarch64__) && !defined(__arm64__)
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                              \
+    do {                                                                                    \
+      /* Undocumented GCC/Clang operand modifier: %e0 = lower D half, %f0 = upper D half */ \
+      /* https://github.com/gcc-mirror/gcc/blob/38cf91e5/gcc/config/arm/arm.c#L22486 */     \
+      /* https://github.com/llvm-mirror/llvm/blob/2c4ca683/lib/Target/ARM/ARMAsmPrinter.cpp#L399 */ \
+      __asm__("vzip.32  %e0, %f0" : "+w" (in));                                             \
+      (outLo) = vget_low_u32 (vreinterpretq_u32_u64(in));                                   \
+      (outHi) = vget_high_u32(vreinterpretq_u32_u64(in));                                   \
+   } while (0)
+# else
+#  define XXH_SPLIT_IN_PLACE(in, outLo, outHi)                                            \
+    do {                                                                                  \
+      (outLo) = vmovn_u64    (in);                                                        \
+      (outHi) = vshrn_n_u64  ((in), 32);                                                  \
+    } while (0)
+# endif
+#endif  /* XXH_VECTOR == XXH_NEON */
+
+/*
+ * VSX and Z Vector helpers.
+ *
+ * This is very messy, and any pull requests to clean this up are welcome.
+ *
+ * There are a lot of problems with supporting VSX and s390x, due to
+ * inconsistent intrinsics, spotty coverage, and multiple endiannesses.
+ */
+#if XXH_VECTOR == XXH_VSX
+#  if defined(__s390x__)
+#    include <s390intrin.h>
+#  else
+#    include <altivec.h>
+#  endif
+
+#  undef vector /* Undo the pollution */
+
+typedef __vector unsigned long long xxh_u64x2;
+typedef __vector unsigned char xxh_u8x16;
+typedef __vector unsigned xxh_u32x4;
+
+# ifndef XXH_VSX_BE
+#  if defined(__BIG_ENDIAN__) \
+  || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_VSX_BE 1
+#  elif defined(__VEC_ELEMENT_REG_ORDER__) && __VEC_ELEMENT_REG_ORDER__ == __ORDER_BIG_ENDIAN__
+#    warning "-maltivec=be is not recommended. Please use native endianness."
+#    define XXH_VSX_BE 1
+#  else
+#    define XXH_VSX_BE 0
+#  endif
+# endif /* !defined(XXH_VSX_BE) */
+
+# if XXH_VSX_BE
+/* A wrapper for POWER9's vec_revb. */
+#  if defined(__POWER9_VECTOR__) || (defined(__clang__) && defined(__s390x__))
+#    define XXH_vec_revb vec_revb
+#  else
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_revb(xxh_u64x2 val)
+{
+    xxh_u8x16 const vByteSwap = { 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00,
+                                  0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0x08 };
+    return vec_perm(val, val, vByteSwap);
+}
+#  endif
+# endif /* XXH_VSX_BE */
+
+/*
+ * Performs an unaligned load and byte swaps it on big endian.
+ */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_loadu(const void *ptr)
+{
+    xxh_u64x2 ret;
+    memcpy(&ret, ptr, sizeof(xxh_u64x2));
+# if XXH_VSX_BE
+    ret = XXH_vec_revb(ret);
+# endif
+    return ret;
+}
+
+/*
+ * vec_mulo and vec_mule are very problematic intrinsics on PowerPC
+ *
+ * These intrinsics weren't added until GCC 8, despite existing for a while,
+ * and they are endian dependent. Also, their meaning swap depending on version.
+ * */
+# if defined(__s390x__)
+ /* s390x is always big endian, no issue on this platform */
+#  define XXH_vec_mulo vec_mulo
+#  define XXH_vec_mule vec_mule
+# elif defined(__clang__) && __has_builtin(__builtin_altivec_vmuleuw)
+/* Clang has a better way to control this, we can just use the builtin which doesn't swap. */
+#  define XXH_vec_mulo __builtin_altivec_vmulouw
+#  define XXH_vec_mule __builtin_altivec_vmuleuw
+# else
+/* gcc needs inline assembly */
+/* Adapted from https://github.com/google/highwayhash/blob/master/highwayhash/hh_vsx.h. */
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mulo(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
+    __asm__("vmulouw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
+    return result;
+}
+XXH_FORCE_INLINE xxh_u64x2 XXH_vec_mule(xxh_u32x4 a, xxh_u32x4 b)
+{
+    xxh_u64x2 result;
+    __asm__("vmuleuw %0, %1, %2" : "=v" (result) : "v" (a), "v" (b));
+    return result;
+}
+# endif /* XXH_vec_mulo, XXH_vec_mule */
+#endif /* XXH_VECTOR == XXH_VSX */
+
+
+/* prefetch
+ * can be disabled, by declaring XXH_NO_PREFETCH build macro */
+#if defined(XXH_NO_PREFETCH)
+#  define XXH_PREFETCH(ptr)  (void)(ptr)  /* disabled */
+#else
+#  if defined(_MSC_VER) && (defined(_M_X64) || defined(_M_I86))  /* _mm_prefetch() is not defined outside of x86/x64 */
+#    include <mmintrin.h>   /* https://msdn.microsoft.com/fr-fr/library/84szxsww(v=vs.90).aspx */
+#    define XXH_PREFETCH(ptr)  _mm_prefetch((const char*)(ptr), _MM_HINT_T0)
+#  elif defined(__GNUC__) && ( (__GNUC__ >= 4) || ( (__GNUC__ == 3) && (__GNUC_MINOR__ >= 1) ) )
+#    define XXH_PREFETCH(ptr)  __builtin_prefetch((ptr), 0 /* rw==read */, 3 /* locality */)
+#  else
+#    define XXH_PREFETCH(ptr) (void)(ptr)  /* disabled */
+#  endif
+#endif  /* XXH_NO_PREFETCH */
+
+
+/* ==========================================
+ * XXH3 default settings
+ * ========================================== */
+
+#define XXH_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */
+
+#if (XXH_SECRET_DEFAULT_SIZE < XXH3_SECRET_SIZE_MIN)
+#  error "default keyset is not large enough"
+#endif
+
+/* Pseudorandom secret taken directly from FARSH */
+XXH_ALIGN(64) static const xxh_u8 kSecret[XXH_SECRET_DEFAULT_SIZE] = {
+    0xb8, 0xfe, 0x6c, 0x39, 0x23, 0xa4, 0x4b, 0xbe, 0x7c, 0x01, 0x81, 0x2c, 0xf7, 0x21, 0xad, 0x1c,
+    0xde, 0xd4, 0x6d, 0xe9, 0x83, 0x90, 0x97, 0xdb, 0x72, 0x40, 0xa4, 0xa4, 0xb7, 0xb3, 0x67, 0x1f,
+    0xcb, 0x79, 0xe6, 0x4e, 0xcc, 0xc0, 0xe5, 0x78, 0x82, 0x5a, 0xd0, 0x7d, 0xcc, 0xff, 0x72, 0x21,
+    0xb8, 0x08, 0x46, 0x74, 0xf7, 0x43, 0x24, 0x8e, 0xe0, 0x35, 0x90, 0xe6, 0x81, 0x3a, 0x26, 0x4c,
+    0x3c, 0x28, 0x52, 0xbb, 0x91, 0xc3, 0x00, 0xcb, 0x88, 0xd0, 0x65, 0x8b, 0x1b, 0x53, 0x2e, 0xa3,
+    0x71, 0x64, 0x48, 0x97, 0xa2, 0x0d, 0xf9, 0x4e, 0x38, 0x19, 0xef, 0x46, 0xa9, 0xde, 0xac, 0xd8,
+    0xa8, 0xfa, 0x76, 0x3f, 0xe3, 0x9c, 0x34, 0x3f, 0xf9, 0xdc, 0xbb, 0xc7, 0xc7, 0x0b, 0x4f, 0x1d,
+    0x8a, 0x51, 0xe0, 0x4b, 0xcd, 0xb4, 0x59, 0x31, 0xc8, 0x9f, 0x7e, 0xc9, 0xd9, 0x78, 0x73, 0x64,
+
+    0xea, 0xc5, 0xac, 0x83, 0x34, 0xd3, 0xeb, 0xc3, 0xc5, 0x81, 0xa0, 0xff, 0xfa, 0x13, 0x63, 0xeb,
+    0x17, 0x0d, 0xdd, 0x51, 0xb7, 0xf0, 0xda, 0x49, 0xd3, 0x16, 0x55, 0x26, 0x29, 0xd4, 0x68, 0x9e,
+    0x2b, 0x16, 0xbe, 0x58, 0x7d, 0x47, 0xa1, 0xfc, 0x8f, 0xf8, 0xb8, 0xd1, 0x7a, 0xd0, 0x31, 0xce,
+    0x45, 0xcb, 0x3a, 0x8f, 0x95, 0x16, 0x04, 0x28, 0xaf, 0xd7, 0xfb, 0xca, 0xbb, 0x4b, 0x40, 0x7e,
+};
+
+/*
+ * Does a 32-bit to 64-bit long multiply.
+ *
+ * Wraps __emulu on MSVC x86 because it tends to call __allmul when it doesn't
+ * need to (but it shouldn't need to anyways, it is about 7 instructions to do
+ * a 64x64 multiply...). Since we know that this will _always_ emit MULL, we
+ * use that instead of the normal method.
+ *
+ * If you are compiling for platforms like Thumb-1 and don't have a better option,
+ * you may also want to write your own long multiply routine here.
+ *
+ * XXH_FORCE_INLINE xxh_u64 XXH_mult32to64(xxh_u64 x, xxh_u64 y)
+ * {
+ *    return (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF);
+ * }
+ */
+#if defined(_MSC_VER) && defined(_M_IX86)
+#    include <intrin.h>
+#    define XXH_mult32to64(x, y) __emulu((unsigned)(x), (unsigned)(y))
+#else
+/*
+ * Downcast + upcast is usually better than masking on older compilers like
+ * GCC 4.2 (especially 32-bit ones), all without affecting newer compilers.
+ *
+ * The other method, (x & 0xFFFFFFFF) * (y & 0xFFFFFFFF), will AND both operands
+ * and perform a full 64x64 multiply -- entirely redundant on 32-bit.
+ */
+#    define XXH_mult32to64(x, y) ((xxh_u64)(xxh_u32)(x) * (xxh_u64)(xxh_u32)(y))
+#endif
+
+/*
+ * Calculates a 64->128-bit long multiply.
+ *
+ * Uses __uint128_t and _umul128 if available, otherwise uses a scalar version.
+ */
+static XXH128_hash_t
+XXH_mult64to128(xxh_u64 lhs, xxh_u64 rhs)
+{
+    /*
+     * GCC/Clang __uint128_t method.
+     *
+     * On most 64-bit targets, GCC and Clang define a __uint128_t type.
+     * This is usually the best way as it usually uses a native long 64-bit
+     * multiply, such as MULQ on x86_64 or MUL + UMULH on aarch64.
+     *
+     * Usually.
+     *
+     * Despite being a 32-bit platform, Clang (and emscripten) define this type
+     * despite not having the arithmetic for it. This results in a laggy
+     * compiler builtin call which calculates a full 128-bit multiply.
+     * In that case it is best to use the portable one.
+     * https://github.com/Cyan4973/xxHash/issues/211#issuecomment-515575677
+     */
+#if defined(__GNUC__) && !defined(__wasm__) \
+    && defined(__SIZEOF_INT128__) \
+    || (defined(_INTEGRAL_MAX_BITS) && _INTEGRAL_MAX_BITS >= 128)
+
+    __uint128_t product = (__uint128_t)lhs * (__uint128_t)rhs;
+    XXH128_hash_t const r128 = { (xxh_u64)(product), (xxh_u64)(product >> 64) };
+    return r128;
+
+    /*
+     * MSVC for x64's _umul128 method.
+     *
+     * xxh_u64 _umul128(xxh_u64 Multiplier, xxh_u64 Multiplicand, xxh_u64 *HighProduct);
+     *
+     * This compiles to single operand MUL on x64.
+     */
+#elif defined(_M_X64) || defined(_M_IA64)
+
+#ifndef _MSC_VER
+#   pragma intrinsic(_umul128)
+#endif
+    xxh_u64 product_high;
+    xxh_u64 const product_low = _umul128(lhs, rhs, &product_high);
+    XXH128_hash_t const r128 = { product_low, product_high };
+    return r128;
+
+#else
+    /*
+     * Portable scalar method. Optimized for 32-bit and 64-bit ALUs.
+     *
+     * This is a fast and simple grade school multiply, which is shown below
+     * with base 10 arithmetic instead of base 0x100000000.
+     *
+     *           9 3 // D2 lhs = 93
+     *         x 7 5 // D2 rhs = 75
+     *     ----------
+     *           1 5 // D2 lo_lo = (93 % 10) * (75 % 10) = 15
+     *         4 5 | // D2 hi_lo = (93 / 10) * (75 % 10) = 45
+     *         2 1 | // D2 lo_hi = (93 % 10) * (75 / 10) = 21
+     *     + 6 3 | | // D2 hi_hi = (93 / 10) * (75 / 10) = 63
+     *     ---------
+     *         2 7 | // D2 cross = (15 / 10) + (45 % 10) + 21 = 27
+     *     + 6 7 | | // D2 upper = (27 / 10) + (45 / 10) + 63 = 67
+     *     ---------
+     *       6 9 7 5 // D4 res = (27 * 10) + (15 % 10) + (67 * 100) = 6975
+     *
+     * The reasons for adding the products like this are:
+     *  1. It avoids manual carry tracking. Just like how
+     *     (9 * 9) + 9 + 9 = 99, the same applies with this for UINT64_MAX.
+     *     This avoids a lot of complexity.
+     *
+     *  2. It hints for, and on Clang, compiles to, the powerful UMAAL
+     *     instruction available in ARM's Digital Signal Processing extension
+     *     in 32-bit ARMv6 and later, which is shown below:
+     *
+     *         void UMAAL(xxh_u32 *RdLo, xxh_u32 *RdHi, xxh_u32 Rn, xxh_u32 Rm)
+     *         {
+     *             xxh_u64 product = (xxh_u64)*RdLo * (xxh_u64)*RdHi + Rn + Rm;
+     *             *RdLo = (xxh_u32)(product & 0xFFFFFFFF);
+     *             *RdHi = (xxh_u32)(product >> 32);
+     *         }
+     *
+     *     This instruction was designed for efficient long multiplication, and
+     *     allows this to be calculated in only 4 instructions at speeds
+     *     comparable to some 64-bit ALUs.
+     *
+     *  3. It isn't terrible on other platforms. Usually this will be a couple
+     *     of 32-bit ADD/ADCs.
+     */
+
+    /* First calculate all of the cross products. */
+    xxh_u64 const lo_lo = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs & 0xFFFFFFFF);
+    xxh_u64 const hi_lo = XXH_mult32to64(lhs >> 32,        rhs & 0xFFFFFFFF);
+    xxh_u64 const lo_hi = XXH_mult32to64(lhs & 0xFFFFFFFF, rhs >> 32);
+    xxh_u64 const hi_hi = XXH_mult32to64(lhs >> 32,        rhs >> 32);
+
+    /* Now add the products together. These will never overflow. */
+    xxh_u64 const cross = (lo_lo >> 32) + (hi_lo & 0xFFFFFFFF) + lo_hi;
+    xxh_u64 const upper = (hi_lo >> 32) + (cross >> 32)        + hi_hi;
+    xxh_u64 const lower = (cross << 32) | (lo_lo & 0xFFFFFFFF);
+
+    XXH128_hash_t r128 = { lower, upper };
+    return r128;
+#endif
+}
+
+/*
+ * Does a 64-bit to 128-bit multiply, then XOR folds it.
+ *
+ * The reason for the separate function is to prevent passing too many structs
+ * around by value. This will hopefully inline the multiply, but we don't force it.
+ */
+static xxh_u64
+XXH3_mul128_fold64(xxh_u64 lhs, xxh_u64 rhs)
+{
+    XXH128_hash_t product = XXH_mult64to128(lhs, rhs);
+    return product.low64 ^ product.high64;
+}
+
+/* Seems to produce slightly better code on GCC for some reason. */
+XXH_FORCE_INLINE xxh_u64 XXH_xorshift64(xxh_u64 v64, int shift)
+{
+    XXH_ASSERT(0 <= shift && shift < 64);
+    return v64 ^ (v64 >> shift);
+}
+
+/*
+ * We don't need to (or want to) mix as much as XXH64.
+ *
+ * Short hashes are more evenly distributed, so it isn't necessary.
+ */
+static XXH64_hash_t XXH3_avalanche(xxh_u64 h64)
+{
+    h64 = XXH_xorshift64(h64, 37);
+    h64 *= 0x165667919E3779F9ULL;
+    h64 = XXH_xorshift64(h64, 32);
+    return h64;
+}
+
+
+/* ==========================================
+ * Short keys
+ * ==========================================
+ * One of the shortcomings of XXH32 and XXH64 was that their performance was
+ * sub-optimal on short lengths. It used an iterative algorithm which strongly
+ * favored lengths that were a multiple of 4 or 8.
+ *
+ * Instead of iterating over individual inputs, we use a set of single shot
+ * functions which piece together a range of lengths and operate in constant time.
+ *
+ * Additionally, the number of multiplies has been significantly reduced. This
+ * reduces latency, especially when emulating 64-bit multiplies on 32-bit.
+ *
+ * Depending on the platform, this may or may not be faster than XXH32, but it
+ * is almost guaranteed to be faster than XXH64.
+ */
+
+/*
+ * At very short lengths, there isn't enough input to fully hide secrets, or use
+ * the entire secret.
+ *
+ * There is also only a limited amount of mixing we can do before significantly
+ * impacting performance.
+ *
+ * Therefore, we use different sections of the secret and always mix two secret
+ * samples with an XOR. This should have no effect on performance on the
+ * seedless or withSeed variants because everything _should_ be constant folded
+ * by modern compilers.
+ *
+ * The XOR mixing hides individual parts of the secret and increases entropy.
+ *
+ * This adds an extra layer of strength for custom secrets.
+ */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_1to3_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(1 <= len && len <= 3);
+    XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combined = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combined = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combined = { input[2], 0x03, input[0], input[1] }
+     */
+    {   xxh_u8 const c1 = input[0];
+        xxh_u8 const c2 = input[len >> 1];
+        xxh_u8 const c3 = input[len - 1];
+        xxh_u32 const combined = ((xxh_u32)c1<<16) | (((xxh_u32)c2) << 24) | (((xxh_u32)c3) << 0) | (((xxh_u32)len) << 8);
+        xxh_u64 const bitflip = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const keyed = (xxh_u64)combined ^ bitflip;
+        xxh_u64 const mixed = keyed * PRIME64_1;
+        return XXH3_avalanche(mixed);
+    }
+}
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_4to8_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(4 <= len && len < 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input1 = XXH_readLE32(input);
+        xxh_u32 const input2 = XXH_readLE32(input + len - 4);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+8) ^ XXH_readLE64(secret+16)) - seed;
+        xxh_u64 const input64 = input2 + (((xxh_u64)input1) << 32);
+        xxh_u64 x = input64 ^ bitflip;
+        /* this mix is inspired by Pelle Evensen's rrmxmx */
+        x ^= XXH_rotl64(x, 49) ^ XXH_rotl64(x, 24);
+        x *= 0x9FB21C651E98DF25ULL;
+        x ^= (x >> 35) + len ;
+        x *= 0x9FB21C651E98DF25ULL;
+        return XXH_xorshift64(x, 28);
+    }
+}
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_9to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(8 <= len && len <= 16);
+    {   xxh_u64 const bitflip1 = (XXH_readLE64(secret+24) ^ XXH_readLE64(secret+32)) + seed;
+        xxh_u64 const bitflip2 = (XXH_readLE64(secret+40) ^ XXH_readLE64(secret+48)) - seed;
+        xxh_u64 const input_lo = XXH_readLE64(input)           ^ bitflip1;
+        xxh_u64 const input_hi = XXH_readLE64(input + len - 8) ^ bitflip2;
+        xxh_u64 const acc = len
+                          + XXH_swap64(input_lo) + input_hi
+                          + XXH3_mul128_fold64(input_lo, input_hi);
+        return XXH3_avalanche(acc);
+    }
+}
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_0to16_64b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(len <= 16);
+    {   if (XXH_likely(len >  8)) return XXH3_len_9to16_64b(input, len, secret, seed);
+        if (XXH_likely(len >= 4)) return XXH3_len_4to8_64b(input, len, secret, seed);
+        if (len) return XXH3_len_1to3_64b(input, len, secret, seed);
+        return XXH3_avalanche((PRIME64_1 + seed) ^ (XXH_readLE64(secret+56) ^ XXH_readLE64(secret+64)));
+    }
+}
+
+/*
+ * DISCLAIMER: There are known *seed-dependent* multicollisions here due to
+ * multiplication by zero, affecting hashes of lengths 17 to 240.
+ *
+ * However, they are very unlikely.
+ *
+ * Keep this in mind when using the unseeded XXH3_64bits() variant: As with all
+ * unseeded non-cryptographic hashes, it does not attempt to defend itself
+ * against specially crafted inputs, only random inputs.
+ *
+ * Compared to classic UMAC where a 1 in 2^31 chance of 4 consecutive bytes
+ * cancelling out the secret is taken an arbitrary number of times (addressed
+ * in XXH3_accumulate_512), this collision is very unlikely with random inputs
+ * and/or proper seeding:
+ *
+ * This only has a 1 in 2^63 chance of 8 consecutive bytes cancelling out, in a
+ * function that is only called up to 16 times per hash with up to 240 bytes of
+ * input.
+ *
+ * This is not too bad for a non-cryptographic hash function, especially with
+ * only 64 bit outputs.
+ *
+ * The 128-bit variant (which trades some speed for strength) is NOT affected
+ * by this, although it is always a good idea to use a proper seed if you care
+ * about strength.
+ */
+XXH_FORCE_INLINE xxh_u64 XXH3_mix16B(const xxh_u8* XXH_RESTRICT input,
+                                     const xxh_u8* XXH_RESTRICT secret, xxh_u64 seed64)
+{
+#if defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__i386__) && defined(__SSE2__)  /* x86 + SSE2 */ \
+  && !defined(XXH_ENABLE_AUTOVECTORIZE)      /* Define to disable like XXH32 hack */
+    /*
+     * UGLY HACK:
+     * GCC for x86 tends to autovectorize the 128-bit multiply, resulting in
+     * slower code.
+     *
+     * By forcing seed64 into a register, we disrupt the cost model and
+     * cause it to scalarize. See `XXH32_round()`
+     *
+     * FIXME: Clang's output is still _much_ faster -- On an AMD Ryzen 3600,
+     * XXH3_64bits @ len=240 runs at 4.6 GB/s with Clang 9, but 3.3 GB/s on
+     * GCC 9.2, despite both emitting scalar code.
+     *
+     * GCC generates much better scalar code than Clang for the rest of XXH3,
+     * which is why finding a more optimal codepath is an interest.
+     */
+    __asm__ ("" : "+r" (seed64));
+#endif
+    {   xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64 const input_hi = XXH_readLE64(input+8);
+        return XXH3_mul128_fold64(
+            input_lo ^ (XXH_readLE64(secret)   + seed64),
+            input_hi ^ (XXH_readLE64(secret+8) - seed64)
+        );
+    }
+}
+
+/* For mid range keys, XXH3 uses a Mum-hash variant. */
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_len_17to128_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                     const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                     XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   xxh_u64 acc = len * PRIME64_1;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc += XXH3_mix16B(input+48, secret+96, seed);
+                    acc += XXH3_mix16B(input+len-64, secret+112, seed);
+                }
+                acc += XXH3_mix16B(input+32, secret+64, seed);
+                acc += XXH3_mix16B(input+len-48, secret+80, seed);
+            }
+            acc += XXH3_mix16B(input+16, secret+32, seed);
+            acc += XXH3_mix16B(input+len-32, secret+48, seed);
+        }
+        acc += XXH3_mix16B(input+0, secret+0, seed);
+        acc += XXH3_mix16B(input+len-16, secret+16, seed);
+
+        return XXH3_avalanche(acc);
+    }
+}
+
+#define XXH3_MIDSIZE_MAX 240
+
+XXH_NO_INLINE XXH64_hash_t
+XXH3_len_129to240_64b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    #define XXH3_MIDSIZE_STARTOFFSET 3
+    #define XXH3_MIDSIZE_LASTOFFSET  17
+
+    {   xxh_u64 acc = len * PRIME64_1;
+        int const nbRounds = (int)len / 16;
+        int i;
+        for (i=0; i<8; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*i), seed);
+        }
+        acc = XXH3_avalanche(acc);
+        XXH_ASSERT(nbRounds >= 8);
+#if defined(__clang__)                                /* Clang */ \
+    && (defined(__ARM_NEON) || defined(__ARM_NEON__)) /* NEON */ \
+    && !defined(XXH_ENABLE_AUTOVECTORIZE)             /* Define to disable */
+        /*
+         * UGLY HACK:
+         * Clang for ARMv7-A tries to vectorize this loop, similar to GCC x86.
+         * In everywhere else, it uses scalar code.
+         *
+         * For 64->128-bit multiplies, even if the NEON was 100% optimal, it
+         * would still be slower than UMAAL (see XXH_mult64to128).
+         *
+         * Unfortunately, Clang doesn't handle the long multiplies properly and
+         * converts them to the nonexistent "vmulq_u64" intrinsic, which is then
+         * scalarized into an ugly mess of VMOV.32 instructions.
+         *
+         * This mess is difficult to avoid without turning autovectorization
+         * off completely, but they are usually relatively minor and/or not
+         * worth it to fix.
+         *
+         * This loop is the easiest to fix, as unlike XXH32, this pragma
+         * _actually works_ because it is a loop vectorization instead of an
+         * SLP vectorization.
+         */
+        #pragma clang loop vectorize(disable)
+#endif
+        for (i=8 ; i < nbRounds; i++) {
+            acc += XXH3_mix16B(input+(16*i), secret+(16*(i-8)) + XXH3_MIDSIZE_STARTOFFSET, seed);
+        }
+        /* last bytes */
+        acc += XXH3_mix16B(input + len - 16, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET, seed);
+        return XXH3_avalanche(acc);
+    }
+}
+
+
+/* ===    Long Keys    === */
+
+#define STRIPE_LEN 64
+#define XXH_SECRET_CONSUME_RATE 8   /* nb of secret bytes consumed at each accumulation */
+#define ACC_NB (STRIPE_LEN / sizeof(xxh_u64))
+
+typedef enum { XXH3_acc_64bits, XXH3_acc_128bits } XXH3_accWidth_e;
+
+/*
+ * XXH3_accumulate_512 is the tightest loop for long inputs, and it is the most optimized.
+ *
+ * It is a hardened version of UMAC, based off of FARSH's implementation.
+ *
+ * This was chosen because it adapts quite well to 32-bit, 64-bit, and SIMD
+ * implementations, and it is ridiculously fast.
+ *
+ * We harden it by mixing the original input to the accumulators as well as the product.
+ *
+ * This means that in the (relatively likely) case of a multiply by zero, the
+ * original input is preserved.
+ *
+ * On 128-bit inputs, we swap 64-bit pairs when we add the input to improve
+ * cross-pollination, as otherwise the upper and lower halves would be
+ * essentially independent.
+ *
+ * This doesn't matter on 64-bit hashes since they all get merged together in
+ * the end, so we skip the extra step.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
+XXH_FORCE_INLINE void
+XXH3_accumulate_512(      void* XXH_RESTRICT acc,
+                    const void* XXH_RESTRICT input,
+                    const void* XXH_RESTRICT secret,
+                    XXH3_accWidth_e accWidth)
+{
+#if (XXH_VECTOR == XXH_AVX2)
+
+    XXH_ASSERT((((size_t)acc) & 31) == 0);
+    {   XXH_ALIGN(32) __m256i* const xacc    =       (__m256i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires  a const __m256i * pointer for some reason. */
+        const         __m256i* const xinput  = (const __m256i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
+
+        size_t i;
+        for (i=0; i < STRIPE_LEN/sizeof(__m256i); i++) {
+            /* data_vec    = xinput[i]; */
+            __m256i const data_vec    = _mm256_loadu_si256    (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m256i const data_key_lo = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m256i const product     = _mm256_mul_epu32     (data_key, data_key_lo);
+            if (accWidth == XXH3_acc_128bits) {
+                /* xacc[i] += swap(data_vec); */
+                __m256i const data_swap = _mm256_shuffle_epi32(data_vec, _MM_SHUFFLE(1, 0, 3, 2));
+                __m256i const sum       = _mm256_add_epi64(xacc[i], data_swap);
+                /* xacc[i] += product; */
+                xacc[i] = _mm256_add_epi64(product, sum);
+            } else {  /* XXH3_acc_64bits */
+                /* xacc[i] += data_vec; */
+                __m256i const sum = _mm256_add_epi64(xacc[i], data_vec);
+                /* xacc[i] += product; */
+                xacc[i] = _mm256_add_epi64(product, sum);
+            }
+    }   }
+
+#elif (XXH_VECTOR == XXH_SSE2)
+
+    /* SSE2 is just a half-scale version of the AVX2 version. */
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {   XXH_ALIGN(16) __m128i* const xacc    =       (__m128i *) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xinput  = (const __m128i *) input;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
+
+        size_t i;
+        for (i=0; i < STRIPE_LEN/sizeof(__m128i); i++) {
+            /* data_vec    = xinput[i]; */
+            __m128i const data_vec    = _mm_loadu_si128   (xinput+i);
+            /* key_vec     = xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            /* data_key    = data_vec ^ key_vec; */
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+            /* data_key_lo = data_key >> 32; */
+            __m128i const data_key_lo = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            /* product     = (data_key & 0xffffffff) * (data_key_lo & 0xffffffff); */
+            __m128i const product     = _mm_mul_epu32     (data_key, data_key_lo);
+            if (accWidth == XXH3_acc_128bits) {
+                /* xacc[i] += swap(data_vec); */
+                __m128i const data_swap = _mm_shuffle_epi32(data_vec, _MM_SHUFFLE(1,0,3,2));
+                __m128i const sum       = _mm_add_epi64(xacc[i], data_swap);
+                /* xacc[i] += product; */
+                xacc[i] = _mm_add_epi64(product, sum);
+            } else {  /* XXH3_acc_64bits */
+                /* xacc[i] += data_vec; */
+                __m128i const sum = _mm_add_epi64(xacc[i], data_vec);
+                /* xacc[i] += product; */
+                xacc[i] = _mm_add_epi64(product, sum);
+            }
+    }   }
+
+#elif (XXH_VECTOR == XXH_NEON)
+
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {
+        XXH_ALIGN(16) uint64x2_t* const xacc = (uint64x2_t *) acc;
+        /* We don't use a uint32x4_t pointer because it causes bus errors on ARMv7. */
+        uint8_t const* const xinput = (const uint8_t *) input;
+        uint8_t const* const xsecret  = (const uint8_t *) secret;
+
+        size_t i;
+        for (i=0; i < STRIPE_LEN / sizeof(uint64x2_t); i++) {
+            /* data_vec = xinput[i]; */
+            uint8x16_t data_vec    = vld1q_u8(xinput  + (i * 16));
+            /* key_vec  = xsecret[i];  */
+            uint8x16_t key_vec     = vld1q_u8(xsecret + (i * 16));
+            /* data_key = data_vec ^ key_vec; */
+            uint64x2_t data_key    = vreinterpretq_u64_u8(veorq_u8(data_vec, key_vec));
+            uint32x2_t data_key_lo, data_key_hi;
+            if (accWidth == XXH3_acc_64bits) {
+                /* xacc[i] += data_vec; */
+                xacc[i] = vaddq_u64 (xacc[i], vreinterpretq_u64_u8(data_vec));
+            } else {  /* XXH3_acc_128bits */
+                /* xacc[i] += swap(data_vec); */
+                uint64x2_t const data64  = vreinterpretq_u64_u8(data_vec);
+                uint64x2_t const swapped = vextq_u64(data64, data64, 1);
+                xacc[i] = vaddq_u64 (xacc[i], swapped);
+            }
+            /* data_key_lo = (uint32x2_t) (data_key & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (data_key >> 32);
+             * data_key = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
+            /* xacc[i] += (uint64x2_t) data_key_lo * (uint64x2_t) data_key_hi; */
+            xacc[i] = vmlal_u32 (xacc[i], data_key_lo, data_key_hi);
+
+        }
+    }
+
+#elif (XXH_VECTOR == XXH_VSX)
+          xxh_u64x2* const xacc     =       (xxh_u64x2*) acc;    /* presumed aligned */
+    xxh_u64x2 const* const xinput   = (xxh_u64x2 const*) input;   /* no alignment restriction */
+    xxh_u64x2 const* const xsecret  = (xxh_u64x2 const*) secret;    /* no alignment restriction */
+    xxh_u64x2 const v32 = { 32, 32 };
+    size_t i;
+    for (i = 0; i < STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+        /* data_vec = xinput[i]; */
+        xxh_u64x2 const data_vec = XXH_vec_loadu(xinput + i);
+        /* key_vec = xsecret[i]; */
+        xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+        xxh_u64x2 const data_key = data_vec ^ key_vec;
+        /* shuffled = (data_key << 32) | (data_key >> 32); */
+        xxh_u32x4 const shuffled = (xxh_u32x4)vec_rl(data_key, v32);
+        /* product = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)shuffled & 0xFFFFFFFF); */
+        xxh_u64x2 const product  = XXH_vec_mulo((xxh_u32x4)data_key, shuffled);
+        xacc[i] += product;
+
+        if (accWidth == XXH3_acc_64bits) {
+            xacc[i] += data_vec;
+        } else {  /* XXH3_acc_128bits */
+            /* swap high and low halves */
+#ifdef __s390x__
+            xxh_u64x2 const data_swapped = vec_permi(data_vec, data_vec, 2);
+#else
+            xxh_u64x2 const data_swapped = vec_xxpermdi(data_vec, data_vec, 2);
+#endif
+            xacc[i] += data_swapped;
+        }
+    }
+
+#else   /* scalar variant of Accumulator - universal */
+
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc; /* presumed aligned */
+    const xxh_u8* const xinput = (const xxh_u8*) input;  /* no alignment restriction */
+    const xxh_u8* const xsecret  = (const xxh_u8*) secret;   /* no alignment restriction */
+    size_t i;
+    XXH_ASSERT(((size_t)acc & (XXH_ACC_ALIGN-1)) == 0);
+    for (i=0; i < ACC_NB; i++) {
+        xxh_u64 const data_val = XXH_readLE64(xinput + 8*i);
+        xxh_u64 const data_key = data_val ^ XXH_readLE64(xsecret + i*8);
+
+        if (accWidth == XXH3_acc_64bits) {
+            xacc[i] += data_val;
+        } else {
+            xacc[i ^ 1] += data_val; /* swap adjacent lanes */
+        }
+        xacc[i] += XXH_mult32to64(data_key & 0xFFFFFFFF, data_key >> 32);
+    }
+#endif
+}
+
+/*
+ * XXH3_scrambleAcc: Scrambles the accumulators to improve mixing.
+ *
+ * Multiplication isn't perfect, as explained by Google in HighwayHash:
+ *
+ *  // Multiplication mixes/scrambles bytes 0-7 of the 64-bit result to
+ *  // varying degrees. In descending order of goodness, bytes
+ *  // 3 4 2 5 1 6 0 7 have quality 228 224 164 160 100 96 36 32.
+ *  // As expected, the upper and lower bytes are much worse.
+ *
+ * Source: https://github.com/google/highwayhash/blob/0aaf66b/highwayhash/hh_avx2.h#L291
+ *
+ * Since our algorithm uses a pseudorandom secret to add some variance into the
+ * mix, we don't need to (or want to) mix as often or as much as HighwayHash does.
+ *
+ * This isn't as tight as XXH3_accumulate, but still written in SIMD to avoid
+ * extraction.
+ *
+ * Both XXH3_64bits and XXH3_128bits use this subroutine.
+ */
+XXH_FORCE_INLINE void
+XXH3_scrambleAcc(void* XXH_RESTRICT acc, const void* XXH_RESTRICT secret)
+{
+#if (XXH_VECTOR == XXH_AVX2)
+
+    XXH_ASSERT((((size_t)acc) & 31) == 0);
+    {   XXH_ALIGN(32) __m256i* const xacc = (__m256i*) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm256_loadu_si256 requires a const __m256i * pointer for some reason. */
+        const         __m256i* const xsecret = (const __m256i *) secret;
+        const __m256i prime32 = _mm256_set1_epi32((int)PRIME32_1);
+
+        size_t i;
+        for (i=0; i < STRIPE_LEN/sizeof(__m256i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m256i const acc_vec     = xacc[i];
+            __m256i const shifted     = _mm256_srli_epi64    (acc_vec, 47);
+            __m256i const data_vec    = _mm256_xor_si256     (acc_vec, shifted);
+            /* xacc[i] ^= xsecret; */
+            __m256i const key_vec     = _mm256_loadu_si256   (xsecret+i);
+            __m256i const data_key    = _mm256_xor_si256     (data_vec, key_vec);
+
+            /* xacc[i] *= PRIME32_1; */
+            __m256i const data_key_hi = _mm256_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            __m256i const prod_lo     = _mm256_mul_epu32     (data_key, prime32);
+            __m256i const prod_hi     = _mm256_mul_epu32     (data_key_hi, prime32);
+            xacc[i] = _mm256_add_epi64(prod_lo, _mm256_slli_epi64(prod_hi, 32));
+        }
+    }
+
+#elif (XXH_VECTOR == XXH_SSE2)
+
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+    {   XXH_ALIGN(16) __m128i* const xacc = (__m128i*) acc;
+        /* Unaligned. This is mainly for pointer arithmetic, and because
+         * _mm_loadu_si128 requires a const __m128i * pointer for some reason. */
+        const         __m128i* const xsecret = (const __m128i *) secret;
+        const __m128i prime32 = _mm_set1_epi32((int)PRIME32_1);
+
+        size_t i;
+        for (i=0; i < STRIPE_LEN/sizeof(__m128i); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47) */
+            __m128i const acc_vec     = xacc[i];
+            __m128i const shifted     = _mm_srli_epi64    (acc_vec, 47);
+            __m128i const data_vec    = _mm_xor_si128     (acc_vec, shifted);
+            /* xacc[i] ^= xsecret[i]; */
+            __m128i const key_vec     = _mm_loadu_si128   (xsecret+i);
+            __m128i const data_key    = _mm_xor_si128     (data_vec, key_vec);
+
+            /* xacc[i] *= PRIME32_1; */
+            __m128i const data_key_hi = _mm_shuffle_epi32 (data_key, _MM_SHUFFLE(0, 3, 0, 1));
+            __m128i const prod_lo     = _mm_mul_epu32     (data_key, prime32);
+            __m128i const prod_hi     = _mm_mul_epu32     (data_key_hi, prime32);
+            xacc[i] = _mm_add_epi64(prod_lo, _mm_slli_epi64(prod_hi, 32));
+        }
+    }
+
+#elif (XXH_VECTOR == XXH_NEON)
+
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+
+    {   uint64x2_t* xacc       = (uint64x2_t*) acc;
+        uint8_t const* xsecret = (uint8_t const*) secret;
+        uint32x2_t prime       = vdup_n_u32 (PRIME32_1);
+
+        size_t i;
+        for (i=0; i < STRIPE_LEN/sizeof(uint64x2_t); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            uint64x2_t acc_vec  = xacc[i];
+            uint64x2_t shifted  = vshrq_n_u64 (acc_vec, 47);
+            uint64x2_t data_vec = veorq_u64   (acc_vec, shifted);
+
+            /* xacc[i] ^= xsecret[i]; */
+            uint8x16_t key_vec  = vld1q_u8(xsecret + (i * 16));
+            uint64x2_t data_key = veorq_u64(data_vec, vreinterpretq_u64_u8(key_vec));
+
+            /* xacc[i] *= PRIME32_1 */
+            uint32x2_t data_key_lo, data_key_hi;
+            /* data_key_lo = (uint32x2_t) (xacc[i] & 0xFFFFFFFF);
+             * data_key_hi = (uint32x2_t) (xacc[i] >> 32);
+             * xacc[i] = UNDEFINED; */
+            XXH_SPLIT_IN_PLACE(data_key, data_key_lo, data_key_hi);
+            {   /*
+                 * prod_hi = (data_key >> 32) * PRIME32_1;
+                 *
+                 * Avoid vmul_u32 + vshll_n_u32 since Clang 6 and 7 will
+                 * incorrectly "optimize" this:
+                 *   tmp     = vmul_u32(vmovn_u64(a), vmovn_u64(b));
+                 *   shifted = vshll_n_u32(tmp, 32);
+                 * to this:
+                 *   tmp     = "vmulq_u64"(a, b); // no such thing!
+                 *   shifted = vshlq_n_u64(tmp, 32);
+                 *
+                 * However, unlike SSE, Clang lacks a 64-bit multiply routine
+                 * for NEON, and it scalarizes two 64-bit multiplies instead.
+                 *
+                 * vmull_u32 has the same timing as vmul_u32, and it avoids
+                 * this bug completely.
+                 * See https://bugs.llvm.org/show_bug.cgi?id=39967
+                 */
+                uint64x2_t prod_hi = vmull_u32 (data_key_hi, prime);
+                /* xacc[i] = prod_hi << 32; */
+                xacc[i] = vshlq_n_u64(prod_hi, 32);
+                /* xacc[i] += (prod_hi & 0xFFFFFFFF) * PRIME32_1; */
+                xacc[i] = vmlal_u32(xacc[i], data_key_lo, prime);
+            }
+    }   }
+
+#elif (XXH_VECTOR == XXH_VSX)
+
+    XXH_ASSERT((((size_t)acc) & 15) == 0);
+
+    {         xxh_u64x2* const xacc    =       (xxh_u64x2*) acc;
+        const xxh_u64x2* const xsecret = (const xxh_u64x2*) secret;
+        /* constants */
+        xxh_u64x2 const v32  = { 32, 32 };
+        xxh_u64x2 const v47 = { 47, 47 };
+        xxh_u32x4 const prime = { PRIME32_1, PRIME32_1, PRIME32_1, PRIME32_1 };
+        size_t i;
+        for (i = 0; i < STRIPE_LEN / sizeof(xxh_u64x2); i++) {
+            /* xacc[i] ^= (xacc[i] >> 47); */
+            xxh_u64x2 const acc_vec  = xacc[i];
+            xxh_u64x2 const data_vec = acc_vec ^ (acc_vec >> v47);
+
+            /* xacc[i] ^= xsecret[i]; */
+            xxh_u64x2 const key_vec  = XXH_vec_loadu(xsecret + i);
+            xxh_u64x2 const data_key = data_vec ^ key_vec;
+
+            /* xacc[i] *= PRIME32_1 */
+            /* prod_lo = ((xxh_u64x2)data_key & 0xFFFFFFFF) * ((xxh_u64x2)prime & 0xFFFFFFFF);  */
+            xxh_u64x2 const prod_even  = XXH_vec_mule((xxh_u32x4)data_key, prime);
+            /* prod_hi = ((xxh_u64x2)data_key >> 32) * ((xxh_u64x2)prime >> 32);  */
+            xxh_u64x2 const prod_odd  = XXH_vec_mulo((xxh_u32x4)data_key, prime);
+            xacc[i] = prod_odd + (prod_even << v32);
+    }   }
+
+#else   /* scalar variant of Scrambler - universal */
+
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64* const xacc = (xxh_u64*) acc;   /* presumed aligned */
+    const xxh_u8* const xsecret = (const xxh_u8*) secret;   /* no alignment restriction */
+    size_t i;
+    XXH_ASSERT((((size_t)acc) & (XXH_ACC_ALIGN-1)) == 0);
+    for (i=0; i < ACC_NB; i++) {
+        xxh_u64 const key64 = XXH_readLE64(xsecret + 8*i);
+        xxh_u64 acc64 = xacc[i];
+        acc64 = XXH_xorshift64(acc64, 47);
+        acc64 ^= key64;
+        acc64 *= PRIME32_1;
+        xacc[i] = acc64;
+    }
+
+#endif
+}
+
+#define XXH_PREFETCH_DIST 384
+
+/*
+ * XXH3_accumulate()
+ * Loops over XXH3_accumulate_512().
+ * Assumption: nbStripes will not overflow the secret size
+ */
+XXH_FORCE_INLINE void
+XXH3_accumulate(     xxh_u64* XXH_RESTRICT acc,
+                const xxh_u8* XXH_RESTRICT input,
+                const xxh_u8* XXH_RESTRICT secret,
+                      size_t nbStripes,
+                      XXH3_accWidth_e accWidth)
+{
+    size_t n;
+    for (n = 0; n < nbStripes; n++ ) {
+        const xxh_u8* const in = input + n*STRIPE_LEN;
+        XXH_PREFETCH(in + XXH_PREFETCH_DIST);
+        XXH3_accumulate_512(acc,
+                            in,
+                            secret + n*XXH_SECRET_CONSUME_RATE,
+                            accWidth);
+    }
+}
+
+XXH_FORCE_INLINE void
+XXH3_hashLong_internal_loop( xxh_u64* XXH_RESTRICT acc,
+                      const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                            XXH3_accWidth_e accWidth)
+{
+    size_t const nb_rounds = (secretSize - STRIPE_LEN) / XXH_SECRET_CONSUME_RATE;
+    size_t const block_len = STRIPE_LEN * nb_rounds;
+    size_t const nb_blocks = len / block_len;
+
+    size_t n;
+
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+
+    for (n = 0; n < nb_blocks; n++) {
+        XXH3_accumulate(acc, input + n*block_len, secret, nb_rounds, accWidth);
+        XXH3_scrambleAcc(acc, secret + secretSize - STRIPE_LEN);
+    }
+
+    /* last partial block */
+    XXH_ASSERT(len > STRIPE_LEN);
+    {   size_t const nbStripes = (len - (block_len * nb_blocks)) / STRIPE_LEN;
+        XXH_ASSERT(nbStripes <= (secretSize / XXH_SECRET_CONSUME_RATE));
+        XXH3_accumulate(acc, input + nb_blocks*block_len, secret, nbStripes, accWidth);
+
+        /* last stripe */
+        if (len & (STRIPE_LEN - 1)) {
+            const xxh_u8* const p = input + len - STRIPE_LEN;
+            /* Do not align on 8, so that the secret is different from the scrambler */
+#define XXH_SECRET_LASTACC_START 7
+            XXH3_accumulate_512(acc, p, secret + secretSize - STRIPE_LEN - XXH_SECRET_LASTACC_START, accWidth);
+    }   }
+}
+
+XXH_FORCE_INLINE xxh_u64
+XXH3_mix2Accs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret)
+{
+    return XXH3_mul128_fold64(
+               acc[0] ^ XXH_readLE64(secret),
+               acc[1] ^ XXH_readLE64(secret+8) );
+}
+
+static XXH64_hash_t
+XXH3_mergeAccs(const xxh_u64* XXH_RESTRICT acc, const xxh_u8* XXH_RESTRICT secret, xxh_u64 start)
+{
+    xxh_u64 result64 = start;
+
+    result64 += XXH3_mix2Accs(acc+0, secret +  0);
+    result64 += XXH3_mix2Accs(acc+2, secret + 16);
+    result64 += XXH3_mix2Accs(acc+4, secret + 32);
+    result64 += XXH3_mix2Accs(acc+6, secret + 48);
+
+    return XXH3_avalanche(result64);
+}
+
+#define XXH3_INIT_ACC { PRIME32_3, PRIME64_1, PRIME64_2, PRIME64_3, \
+                        PRIME64_4, PRIME32_2, PRIME64_5, PRIME32_1 };
+
+XXH_FORCE_INLINE XXH64_hash_t
+XXH3_hashLong_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
+                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
+{
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[ACC_NB] = XXH3_INIT_ACC;
+
+    XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_64bits);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    /* do not align on 8, so that the secret is different from the accumulator */
+#define XXH_SECRET_MERGEACCS_START 11
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    return XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
+XXH3_hashLong_64b_defaultSecret(const xxh_u8* XXH_RESTRICT input, size_t len)
+{
+    return XXH3_hashLong_internal(input, len, kSecret, sizeof(kSecret));
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSecret(const xxh_u8* XXH_RESTRICT input, size_t len,
+                             const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
+{
+    return XXH3_hashLong_internal(input, len, secret, secretSize);
+}
+
+
+XXH_FORCE_INLINE void XXH_writeLE64(void* dst, xxh_u64 v64)
+{
+    if (!XXH_CPU_LITTLE_ENDIAN) v64 = XXH_swap64(v64);
+    memcpy(dst, &v64, sizeof(v64));
+}
+
+/* XXH3_initCustomSecret() :
+ * destination `customSecret` is presumed allocated and same size as `kSecret`.
+ */
+XXH_FORCE_INLINE void XXH3_initCustomSecret(xxh_u8* customSecret, xxh_u64 seed64)
+{
+    int const nbRounds = XXH_SECRET_DEFAULT_SIZE / 16;
+    int i;
+
+    XXH_STATIC_ASSERT((XXH_SECRET_DEFAULT_SIZE & 15) == 0);
+
+    for (i=0; i < nbRounds; i++) {
+        XXH_writeLE64(customSecret + 16*i,     XXH_readLE64(kSecret + 16*i)     + seed64);
+        XXH_writeLE64(customSecret + 16*i + 8, XXH_readLE64(kSecret + 16*i + 8) - seed64);
+    }
+}
+
+
+/*
+ * XXH3_hashLong_64b_withSeed():
+ * Generate a custom key based on alteration of default kSecret with the seed,
+ * and then use this key for long mode hashing.
+ *
+ * This operation is decently fast but nonetheless costs a little bit of time.
+ * Try to avoid it whenever possible (typically when seed==0).
+ *
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH64_hash_t
+XXH3_hashLong_64b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
+{
+    XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+    if (seed==0) return XXH3_hashLong_64b_defaultSecret(input, len);
+    XXH3_initCustomSecret(secret, seed);
+    return XXH3_hashLong_internal(input, len, secret, sizeof(secret));
+}
+
+/* ===   Public entry point   === */
+
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* input, size_t len)
+{
+    if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, kSecret, 0);
+    if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), 0);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), 0);
+    return XXH3_hashLong_64b_defaultSecret((const xxh_u8*)input, len);
+}
+
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
+     * it should be done here.
+     * For now, it's a contract pre-condition.
+     * Adding a check and a branch here would cost performance at every hash.
+     */
+    if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
+    if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+    return XXH3_hashLong_64b_withSecret((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize);
+}
+
+XXH_PUBLIC_API XXH64_hash_t
+XXH3_64bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
+{
+    if (len <= 16) return XXH3_len_0to16_64b((const xxh_u8*)input, len, kSecret, seed);
+    if (len <= 128) return XXH3_len_17to128_64b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), seed);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_64b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), seed);
+    return XXH3_hashLong_64b_withSeed((const xxh_u8*)input, len, seed);
+}
+
+/* ===   XXH3 streaming   === */
+
+XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void)
+{
+    return (XXH3_state_t*)XXH_malloc(sizeof(XXH3_state_t));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void
+XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state)
+{
+    memcpy(dst_state, src_state, sizeof(*dst_state));
+}
+
+static void
+XXH3_64bits_reset_internal(XXH3_state_t* statePtr,
+                           XXH64_hash_t seed,
+                           const xxh_u8* secret, size_t secretSize)
+{
+    XXH_ASSERT(statePtr != NULL);
+    memset(statePtr, 0, sizeof(*statePtr));
+    statePtr->acc[0] = PRIME32_3;
+    statePtr->acc[1] = PRIME64_1;
+    statePtr->acc[2] = PRIME64_2;
+    statePtr->acc[3] = PRIME64_3;
+    statePtr->acc[4] = PRIME64_4;
+    statePtr->acc[5] = PRIME32_2;
+    statePtr->acc[6] = PRIME64_5;
+    statePtr->acc[7] = PRIME32_1;
+    statePtr->seed = seed;
+    XXH_ASSERT(secret != NULL);
+    statePtr->secret = secret;
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+    statePtr->secretLimit = (XXH32_hash_t)(secretSize - STRIPE_LEN);
+    statePtr->nbStripesPerBlock = statePtr->secretLimit / XXH_SECRET_CONSUME_RATE;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset(XXH3_state_t* statePtr)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_64bits_reset_internal(statePtr, 0, kSecret, XXH_SECRET_DEFAULT_SIZE);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_64bits_reset_internal(statePtr, 0, (const xxh_u8*)secret, secretSize);
+    if (secret == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_64bits_reset_internal(statePtr, seed, kSecret, XXH_SECRET_DEFAULT_SIZE);
+    XXH3_initCustomSecret(statePtr->customSecret, seed);
+    statePtr->secret = statePtr->customSecret;
+    return XXH_OK;
+}
+
+XXH_FORCE_INLINE void
+XXH3_consumeStripes( xxh_u64* acc,
+                    XXH32_hash_t* nbStripesSoFarPtr, XXH32_hash_t nbStripesPerBlock,
+                    const xxh_u8* input, size_t totalStripes,
+                    const xxh_u8* secret, size_t secretLimit,
+                    XXH3_accWidth_e accWidth)
+{
+    XXH_ASSERT(*nbStripesSoFarPtr < nbStripesPerBlock);
+    if (nbStripesPerBlock - *nbStripesSoFarPtr <= totalStripes) {
+        /* need a scrambling operation */
+        size_t const nbStripes = nbStripesPerBlock - *nbStripesSoFarPtr;
+        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, nbStripes, accWidth);
+        XXH3_scrambleAcc(acc, secret + secretLimit);
+        XXH3_accumulate(acc, input + nbStripes * STRIPE_LEN, secret, totalStripes - nbStripes, accWidth);
+        *nbStripesSoFarPtr = (XXH32_hash_t)(totalStripes - nbStripes);
+    } else {
+        XXH3_accumulate(acc, input, secret + nbStripesSoFarPtr[0] * XXH_SECRET_CONSUME_RATE, totalStripes, accWidth);
+        *nbStripesSoFarPtr += (XXH32_hash_t)totalStripes;
+    }
+}
+
+/*
+ * Both XXH3_64bits_update and XXH3_128bits_update use this routine.
+ */
+XXH_FORCE_INLINE XXH_errorcode
+XXH3_update(XXH3_state_t* state, const xxh_u8* input, size_t len, XXH3_accWidth_e accWidth)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* const bEnd = input + len;
+
+        state->totalLen += len;
+
+        if (state->bufferedSize + len <= XXH3_INTERNALBUFFER_SIZE) {  /* fill in tmp buffer */
+            XXH_memcpy(state->buffer + state->bufferedSize, input, len);
+            state->bufferedSize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+        /* input is now > XXH3_INTERNALBUFFER_SIZE */
+
+        #define XXH3_INTERNALBUFFER_STRIPES (XXH3_INTERNALBUFFER_SIZE / STRIPE_LEN)
+        XXH_STATIC_ASSERT(XXH3_INTERNALBUFFER_SIZE % STRIPE_LEN == 0);   /* clean multiple */
+
+        /*
+         * There is some input left inside the internal buffer.
+         * Fill it, then consume it.
+         */
+        if (state->bufferedSize) {
+            size_t const loadSize = XXH3_INTERNALBUFFER_SIZE - state->bufferedSize;
+            XXH_memcpy(state->buffer + state->bufferedSize, input, loadSize);
+            input += loadSize;
+            XXH3_consumeStripes(state->acc,
+                               &state->nbStripesSoFar, state->nbStripesPerBlock,
+                                state->buffer, XXH3_INTERNALBUFFER_STRIPES,
+                                state->secret, state->secretLimit,
+                                accWidth);
+            state->bufferedSize = 0;
+        }
+
+        /* Consume input by full buffer quantities */
+        if (input+XXH3_INTERNALBUFFER_SIZE <= bEnd) {
+            const xxh_u8* const limit = bEnd - XXH3_INTERNALBUFFER_SIZE;
+            do {
+                XXH3_consumeStripes(state->acc,
+                                   &state->nbStripesSoFar, state->nbStripesPerBlock,
+                                    input, XXH3_INTERNALBUFFER_STRIPES,
+                                    state->secret, state->secretLimit,
+                                    accWidth);
+                input += XXH3_INTERNALBUFFER_SIZE;
+            } while (input<=limit);
+        }
+
+        if (input < bEnd) { /* Some remaining input: buffer it */
+            XXH_memcpy(state->buffer, input, (size_t)(bEnd-input));
+            state->bufferedSize = (XXH32_hash_t)(bEnd-input);
+        }
+    }
+
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_64bits_update(XXH3_state_t* state, const void* input, size_t len)
+{
+    return XXH3_update(state, (const xxh_u8*)input, len, XXH3_acc_64bits);
+}
+
+
+XXH_FORCE_INLINE void
+XXH3_digest_long (XXH64_hash_t* acc, const XXH3_state_t* state, XXH3_accWidth_e accWidth)
+{
+    /*
+     * Digest on a local copy. This way, the state remains unaltered, and it can
+     * continue ingesting more input afterwards.
+     */
+    memcpy(acc, state->acc, sizeof(state->acc));
+    if (state->bufferedSize >= STRIPE_LEN) {
+        size_t const totalNbStripes = state->bufferedSize / STRIPE_LEN;
+        XXH32_hash_t nbStripesSoFar = state->nbStripesSoFar;
+        XXH3_consumeStripes(acc,
+                           &nbStripesSoFar, state->nbStripesPerBlock,
+                            state->buffer, totalNbStripes,
+                            state->secret, state->secretLimit,
+                            accWidth);
+        if (state->bufferedSize % STRIPE_LEN) {  /* one last partial stripe */
+            XXH3_accumulate_512(acc,
+                                state->buffer + state->bufferedSize - STRIPE_LEN,
+                                state->secret + state->secretLimit - XXH_SECRET_LASTACC_START,
+                                accWidth);
+        }
+    } else {  /* bufferedSize < STRIPE_LEN */
+        if (state->bufferedSize) { /* one last stripe */
+            xxh_u8 lastStripe[STRIPE_LEN];
+            size_t const catchupSize = STRIPE_LEN - state->bufferedSize;
+            memcpy(lastStripe, state->buffer + sizeof(state->buffer) - catchupSize, catchupSize);
+            memcpy(lastStripe + catchupSize, state->buffer, state->bufferedSize);
+            XXH3_accumulate_512(acc,
+                                lastStripe,
+                                state->secret + state->secretLimit - XXH_SECRET_LASTACC_START,
+                                accWidth);
+    }   }
+}
+
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_digest (const XXH3_state_t* state)
+{
+    if (state->totalLen > XXH3_MIDSIZE_MAX) {
+        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[ACC_NB];
+        XXH3_digest_long(acc, state, XXH3_acc_64bits);
+        return XXH3_mergeAccs(acc, state->secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)state->totalLen * PRIME64_1);
+    }
+    /* len <= XXH3_MIDSIZE_MAX : short code */
+    if (state->seed)
+        return XXH3_64bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
+    return XXH3_64bits_withSecret(state->buffer, (size_t)(state->totalLen), state->secret, state->secretLimit + STRIPE_LEN);
+}
+
+/* ==========================================
+ * XXH3 128 bits (=> XXH128)
+ * ========================================== */
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_1to3_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(1 <= len && len <= 3);
+    XXH_ASSERT(secret != NULL);
+    /*
+     * len = 1: combinedl = { input[0], 0x01, input[0], input[0] }
+     * len = 2: combinedl = { input[1], 0x02, input[0], input[1] }
+     * len = 3: combinedl = { input[2], 0x03, input[0], input[1] }
+     */
+    {   xxh_u8 const c1 = input[0];
+        xxh_u8 const c2 = input[len >> 1];
+        xxh_u8 const c3 = input[len - 1];
+        xxh_u32 const combinedl = ((xxh_u32)c1<<16) | (((xxh_u32)c2) << 24) | (((xxh_u32)c3) << 0) | (((xxh_u32)len) << 8);
+        xxh_u32 const combinedh = XXH_rotl32(XXH_swap32(combinedl), 13);
+        xxh_u64 const bitflipl = (XXH_readLE32(secret) ^ XXH_readLE32(secret+4)) + seed;
+        xxh_u64 const bitfliph = (XXH_readLE32(secret+8) ^ XXH_readLE32(secret+12)) - seed;
+        xxh_u64 const keyed_lo = (xxh_u64)combinedl ^ bitflipl;
+        xxh_u64 const keyed_hi = (xxh_u64)combinedh ^ bitfliph;
+        xxh_u64 const mixedl = keyed_lo * PRIME64_1;
+        xxh_u64 const mixedh = keyed_hi * PRIME64_5;
+        XXH128_hash_t const h128 = { XXH3_avalanche(mixedl) /*low64*/, XXH3_avalanche(mixedh) /*high64*/ };
+        return h128;
+    }
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_4to8_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(4 <= len && len <= 8);
+    seed ^= (xxh_u64)XXH_swap32((xxh_u32)seed) << 32;
+    {   xxh_u32 const input_lo = XXH_readLE32(input);
+        xxh_u32 const input_hi = XXH_readLE32(input + len - 4);
+        xxh_u64 const input_64 = input_lo + ((xxh_u64)input_hi << 32);
+        xxh_u64 const bitflip = (XXH_readLE64(secret+16) ^ XXH_readLE64(secret+24)) + seed;
+        xxh_u64 const keyed = input_64 ^ bitflip;
+
+        /* Shift len to the left to ensure it is even, this avoids even multiplies. */
+        XXH128_hash_t m128 = XXH_mult64to128(keyed, PRIME64_1 + (len << 2));
+
+        m128.high64 += (m128.low64 << 1);
+        m128.low64  ^= (m128.high64 >> 3);
+
+        m128.low64   = XXH_xorshift64(m128.low64, 35);
+        m128.low64  *= 0x9FB21C651E98DF25ULL;
+        m128.low64   = XXH_xorshift64(m128.low64, 28);
+        m128.high64  = XXH3_avalanche(m128.high64);
+        return m128;
+    }
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_9to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(input != NULL);
+    XXH_ASSERT(secret != NULL);
+    XXH_ASSERT(9 <= len && len <= 16);
+    {   xxh_u64 const bitflipl = (XXH_readLE64(secret+32) ^ XXH_readLE64(secret+40)) - seed;
+        xxh_u64 const bitfliph = (XXH_readLE64(secret+48) ^ XXH_readLE64(secret+56)) + seed;
+        xxh_u64 const input_lo = XXH_readLE64(input);
+        xxh_u64       input_hi = XXH_readLE64(input + len - 8);
+        XXH128_hash_t m128 = XXH_mult64to128(input_lo ^ input_hi ^ bitflipl, PRIME64_1);
+        /*
+         * Put len in the middle of m128 to ensure that the length gets mixed to
+         * both the low and high bits in the 128x64 multiply below.
+         */
+        m128.low64  += (xxh_u64)(len - 1) << 54;
+        input_hi ^= bitfliph;
+        /*
+         * Add the high 32 bits of input_hi to the high 32 bits of m128, then
+         * add the long product of the low 32 bits of input_hi and PRIME32_2 to
+         * the high 64 bits of m128.
+         *
+         * The best approach to this operation is different on 32-bit and 64-bit.
+         */
+        if (sizeof(void *) < sizeof(xxh_u64)) { /* 32-bit */
+            /*
+             * 32-bit optimized version, which is more readable.
+             *
+             * On 32-bit, it removes an ADC and delays a dependency between the two
+             * halves of m128.high64, but it generates an extra mask on 64-bit.
+             */
+            m128.high64 += (input_hi & 0xFFFFFFFF00000000) + XXH_mult32to64((xxh_u32)input_hi, PRIME32_2);
+        } else {
+            /*
+             * 64-bit optimized (albeit more confusing) version.
+             *
+             * Uses some properties of addition and multiplication to remove the mask:
+             *
+             * Let:
+             *    a = input_hi.lo = (input_hi & 0x00000000FFFFFFFF)
+             *    b = input_hi.hi = (input_hi & 0xFFFFFFFF00000000)
+             *    c = PRIME32_2
+             *
+             *    a + (b * c)
+             * Inverse Property: x + y - x == y
+             *    a + (b * (1 + c - 1))
+             * Distributive Property: x * (y + z) == (x * y) + (x * z)
+             *    a + (b * 1) + (b * (c - 1))
+             * Identity Property: x * 1 == x
+             *    a + b + (b * (c - 1))
+             *
+             * Substitute a, b, and c:
+             *    input_hi.hi + input_hi.lo + ((xxh_u64)input_hi.lo * (PRIME32_2 - 1))
+             *
+             * Since input_hi.hi + input_hi.lo == input_hi, we get this:
+             *    input_hi + ((xxh_u64)input_hi.lo * (PRIME32_2 - 1))
+             */
+            m128.high64 += input_hi + XXH_mult32to64((xxh_u32)input_hi, PRIME32_2 - 1);
+        }
+        /* m128 ^= XXH_swap64(m128 >> 64); */
+        m128.low64  ^= XXH_swap64(m128.high64);
+
+        {   /* 128x64 multiply: h128 = m128 * PRIME64_2; */
+            XXH128_hash_t h128 = XXH_mult64to128(m128.low64, PRIME64_2);
+            h128.high64 += m128.high64 * PRIME64_2;
+
+            h128.low64   = XXH3_avalanche(h128.low64);
+            h128.high64  = XXH3_avalanche(h128.high64);
+            return h128;
+    }   }
+}
+
+/* Assumption : `secret` size is >= 16
+ * Note : it should be >= XXH3_SECRET_SIZE_MIN anyway */
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_0to16_128b(const xxh_u8* input, size_t len, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    XXH_ASSERT(len <= 16);
+    {   if (len > 8) return XXH3_len_9to16_128b(input, len, secret, seed);
+        if (len >= 4) return XXH3_len_4to8_128b(input, len, secret, seed);
+        if (len) return XXH3_len_1to3_128b(input, len, secret, seed);
+        {   XXH128_hash_t h128;
+            xxh_u64 const bitflipl = XXH_readLE64(secret+64) ^ XXH_readLE64(secret+72);
+            xxh_u64 const bitfliph = XXH_readLE64(secret+80) ^ XXH_readLE64(secret+88);
+            h128.low64 = XXH3_avalanche((PRIME64_1 + seed) ^ bitflipl);
+            h128.high64 = XXH3_avalanche((PRIME64_2 - seed) ^ bitfliph);
+            return h128;
+    }   }
+}
+
+/*
+ * A bit slower than XXH3_mix16B, but handles multiply by zero better.
+ */
+XXH_FORCE_INLINE XXH128_hash_t
+XXH128_mix32B(XXH128_hash_t acc, const xxh_u8* input_1, const xxh_u8* input_2, const xxh_u8* secret, XXH64_hash_t seed)
+{
+    acc.low64  += XXH3_mix16B (input_1, secret+0, seed);
+    acc.low64  ^= XXH_readLE64(input_2) + XXH_readLE64(input_2 + 8);
+    acc.high64 += XXH3_mix16B (input_2, secret+16, seed);
+    acc.high64 ^= XXH_readLE64(input_1) + XXH_readLE64(input_1 + 8);
+    return acc;
+}
+
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_len_17to128_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                      const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                      XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(16 < len && len <= 128);
+
+    {   XXH128_hash_t acc;
+        acc.low64 = len * PRIME64_1;
+        acc.high64 = 0;
+        if (len > 32) {
+            if (len > 64) {
+                if (len > 96) {
+                    acc = XXH128_mix32B(acc, input+48, input+len-64, secret+96, seed);
+                }
+                acc = XXH128_mix32B(acc, input+32, input+len-48, secret+64, seed);
+            }
+            acc = XXH128_mix32B(acc, input+16, input+len-32, secret+32, seed);
+        }
+        acc = XXH128_mix32B(acc, input, input+len-16, secret, seed);
+        {   xxh_u64 const low64 = acc.low64 + acc.high64;
+            xxh_u64 const high64 = (acc.low64 * PRIME64_1) + (acc.high64 * PRIME64_4) + ((len - seed) * PRIME64_2);
+            XXH128_hash_t const h128 = { XXH3_avalanche(low64), (XXH64_hash_t)0 - XXH3_avalanche(high64) };
+            return h128;
+        }
+    }
+}
+
+XXH_NO_INLINE XXH128_hash_t
+XXH3_len_129to240_128b(const xxh_u8* XXH_RESTRICT input, size_t len,
+                       const xxh_u8* XXH_RESTRICT secret, size_t secretSize,
+                       XXH64_hash_t seed)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN); (void)secretSize;
+    XXH_ASSERT(128 < len && len <= XXH3_MIDSIZE_MAX);
+
+    {   XXH128_hash_t acc;
+        int const nbRounds = (int)len / 32;
+        int i;
+        acc.low64 = len * PRIME64_1;
+        acc.high64 = 0;
+        for (i=0; i<4; i++) {
+            acc = XXH128_mix32B(acc, input+(32*i), input+(32*i)+16, secret+(32*i), seed);
+        }
+        acc.low64 = XXH3_avalanche(acc.low64);
+        acc.high64 = XXH3_avalanche(acc.high64);
+        XXH_ASSERT(nbRounds >= 4);
+        for (i=4 ; i < nbRounds; i++) {
+            acc = XXH128_mix32B(acc, input+(32*i), input+(32*i)+16, secret+XXH3_MIDSIZE_STARTOFFSET+(32*(i-4)), seed);
+        }
+        /* last bytes */
+        acc = XXH128_mix32B(acc, input + len - 16, input + len - 32, secret + XXH3_SECRET_SIZE_MIN - XXH3_MIDSIZE_LASTOFFSET - 16, 0ULL - seed);
+
+        {   xxh_u64 const low64 = acc.low64 + acc.high64;
+            xxh_u64 const high64 = (acc.low64 * PRIME64_1) + (acc.high64 * PRIME64_4) + ((len - seed) * PRIME64_2);
+            XXH128_hash_t const h128 = { XXH3_avalanche(low64), (XXH64_hash_t)0 - XXH3_avalanche(high64) };
+            return h128;
+        }
+    }
+}
+
+XXH_FORCE_INLINE XXH128_hash_t
+XXH3_hashLong_128b_internal(const xxh_u8* XXH_RESTRICT input, size_t len,
+                            const xxh_u8* XXH_RESTRICT secret, size_t secretSize)
+{
+    XXH_ALIGN(XXH_ACC_ALIGN) xxh_u64 acc[ACC_NB] = XXH3_INIT_ACC;
+
+    XXH3_hashLong_internal_loop(acc, input, len, secret, secretSize, XXH3_acc_128bits);
+
+    /* converge into final hash */
+    XXH_STATIC_ASSERT(sizeof(acc) == 64);
+    XXH_ASSERT(secretSize >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+    {   xxh_u64 const low64 = XXH3_mergeAccs(acc, secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)len * PRIME64_1);
+        xxh_u64 const high64 = XXH3_mergeAccs(acc, secret + secretSize - sizeof(acc) - XXH_SECRET_MERGEACCS_START, ~((xxh_u64)len * PRIME64_2));
+        XXH128_hash_t const h128 = { low64, high64 };
+        return h128;
+    }
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_defaultSecret(const xxh_u8* input, size_t len)
+{
+    return XXH3_hashLong_128b_internal(input, len, kSecret, sizeof(kSecret));
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSecret(const xxh_u8* input, size_t len,
+                              const xxh_u8* secret, size_t secretSize)
+{
+    return XXH3_hashLong_128b_internal(input, len, secret, secretSize);
+}
+
+/*
+ * It's important for performance that XXH3_hashLong is not inlined. Not sure
+ * why (uop cache maybe?), but the difference is large and easily measurable.
+ */
+XXH_NO_INLINE XXH128_hash_t
+XXH3_hashLong_128b_withSeed(const xxh_u8* input, size_t len, XXH64_hash_t seed)
+{
+    XXH_ALIGN(8) xxh_u8 secret[XXH_SECRET_DEFAULT_SIZE];
+    if (seed == 0) return XXH3_hashLong_128b_defaultSecret(input, len);
+    XXH3_initCustomSecret(secret, seed);
+    return XXH3_hashLong_128b_internal(input, len, secret, sizeof(secret));
+}
+
+
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* input, size_t len)
+{
+    if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, kSecret, 0);
+    if (len <= 128) return XXH3_len_17to128_128b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), 0);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_128b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), 0);
+    return XXH3_hashLong_128b_defaultSecret((const xxh_u8*)input, len);
+}
+
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSecret(const void* input, size_t len, const void* secret, size_t secretSize)
+{
+    XXH_ASSERT(secretSize >= XXH3_SECRET_SIZE_MIN);
+    /*
+     * If an action is to be taken if `secret` conditions are not respected,
+     * it should be done here.
+     * For now, it's a contract pre-condition.
+     * Adding a check and a branch here would cost performance at every hash.
+     */
+     if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, 0);
+     if (len <= 128) return XXH3_len_17to128_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+     if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_128b((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize, 0);
+     return XXH3_hashLong_128b_withSecret((const xxh_u8*)input, len, (const xxh_u8*)secret, secretSize);
+}
+
+XXH_PUBLIC_API XXH128_hash_t
+XXH3_128bits_withSeed(const void* input, size_t len, XXH64_hash_t seed)
+{
+    if (len <= 16) return XXH3_len_0to16_128b((const xxh_u8*)input, len, kSecret, seed);
+    if (len <= 128) return XXH3_len_17to128_128b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), seed);
+    if (len <= XXH3_MIDSIZE_MAX) return XXH3_len_129to240_128b((const xxh_u8*)input, len, kSecret, sizeof(kSecret), seed);
+    return XXH3_hashLong_128b_withSeed((const xxh_u8*)input, len, seed);
+}
+
+XXH_PUBLIC_API XXH128_hash_t
+XXH128(const void* input, size_t len, XXH64_hash_t seed)
+{
+    return XXH3_128bits_withSeed(input, len, seed);
+}
+
+
+/* ===   XXH3 128-bit streaming   === */
+
+/* all the functions are actually the same as for 64-bit streaming variant,
+   just the reset one is different (different initial acc values for 0,5,6,7),
+   and near the end of the digest function */
+
+static void
+XXH3_128bits_reset_internal(XXH3_state_t* statePtr,
+                           XXH64_hash_t seed,
+                           const xxh_u8* secret, size_t secretSize)
+{
+    XXH3_64bits_reset_internal(statePtr, seed, secret, secretSize);
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset(XXH3_state_t* statePtr)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_128bits_reset_internal(statePtr, 0, kSecret, XXH_SECRET_DEFAULT_SIZE);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_128bits_reset_internal(statePtr, 0, (const xxh_u8*)secret, secretSize);
+    if (secret == NULL) return XXH_ERROR;
+    if (secretSize < XXH3_SECRET_SIZE_MIN) return XXH_ERROR;
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed)
+{
+    if (statePtr == NULL) return XXH_ERROR;
+    XXH3_128bits_reset_internal(statePtr, seed, kSecret, XXH_SECRET_DEFAULT_SIZE);
+    XXH3_initCustomSecret(statePtr->customSecret, seed);
+    statePtr->secret = statePtr->customSecret;
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH3_128bits_update(XXH3_state_t* state, const void* input, size_t len)
+{
+    return XXH3_update(state, (const xxh_u8*)input, len, XXH3_acc_128bits);
+}
+
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* state)
+{
+    if (state->totalLen > XXH3_MIDSIZE_MAX) {
+        XXH_ALIGN(XXH_ACC_ALIGN) XXH64_hash_t acc[ACC_NB];
+        XXH3_digest_long(acc, state, XXH3_acc_128bits);
+        XXH_ASSERT(state->secretLimit + STRIPE_LEN >= sizeof(acc) + XXH_SECRET_MERGEACCS_START);
+        {   xxh_u64 const low64 = XXH3_mergeAccs(acc, state->secret + XXH_SECRET_MERGEACCS_START, (xxh_u64)state->totalLen * PRIME64_1);
+            xxh_u64 const high64 = XXH3_mergeAccs(acc, state->secret + state->secretLimit + STRIPE_LEN - sizeof(acc) - XXH_SECRET_MERGEACCS_START, ~((xxh_u64)state->totalLen * PRIME64_2));
+            XXH128_hash_t const h128 = { low64, high64 };
+            return h128;
+        }
+    }
+    /* len <= XXH3_MIDSIZE_MAX : short code */
+    if (state->seed)
+        return XXH3_128bits_withSeed(state->buffer, (size_t)state->totalLen, state->seed);
+    return XXH3_128bits_withSecret(state->buffer, (size_t)(state->totalLen), state->secret, state->secretLimit + STRIPE_LEN);
+}
+
+/* 128-bit utility functions */
+
+#include <string.h>   /* memcmp, memcpy */
+
+/* return : 1 is equal, 0 if different */
+XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2)
+{
+    /* note : XXH128_hash_t is compact, it has no padding byte */
+    return !(memcmp(&h1, &h2, sizeof(h1)));
+}
+
+/* This prototype is compatible with stdlib's qsort().
+ * return : >0 if *h128_1  > *h128_2
+ *          <0 if *h128_1  < *h128_2
+ *          =0 if *h128_1 == *h128_2  */
+XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2)
+{
+    XXH128_hash_t const h1 = *(const XXH128_hash_t*)h128_1;
+    XXH128_hash_t const h2 = *(const XXH128_hash_t*)h128_2;
+    int const hcmp = (h1.high64 > h2.high64) - (h2.high64 > h1.high64);
+    /* note : bets that, in most cases, hash values are different */
+    if (hcmp) return hcmp;
+    return (h1.low64 > h2.low64) - (h2.low64 > h1.low64);
+}
+
+
+/*======   Canonical representation   ======*/
+XXH_PUBLIC_API void
+XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH128_canonical_t) == sizeof(XXH128_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) {
+        hash.high64 = XXH_swap64(hash.high64);
+        hash.low64  = XXH_swap64(hash.low64);
+    }
+    memcpy(dst, &hash.high64, sizeof(hash.high64));
+    memcpy((char*)dst + sizeof(hash.high64), &hash.low64, sizeof(hash.low64));
+}
+
+XXH_PUBLIC_API XXH128_hash_t
+XXH128_hashFromCanonical(const XXH128_canonical_t* src)
+{
+    XXH128_hash_t h;
+    h.high64 = XXH_readBE64(src);
+    h.low64  = XXH_readBE64(src->digest + 8);
+    return h;
+}
+
+/* Pop our optimization override from above */
+#if XXH_VECTOR == XXH_AVX2 /* AVX2 */ \
+  && defined(__GNUC__) && !defined(__clang__) /* GCC, not Clang */ \
+  && defined(__OPTIMIZE__) && !defined(__OPTIMIZE_SIZE__) /* respect -O0 and -Os */
+#  pragma GCC pop_options
+#endif
+
+#endif  /* XXH3_H_1397135465 */
diff --git a/xxHash/xxhash.c b/xxHash/xxhash.c
deleted file mode 100644
index 833b99f3..00000000
--- a/xxHash/xxhash.c
+++ /dev/null
@@ -1,888 +0,0 @@
-/*
-*  xxHash - Fast Hash algorithm
-*  Copyright (C) 2012-2016, Yann Collet
-*
-*  BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-*
-*  Redistribution and use in source and binary forms, with or without
-*  modification, are permitted provided that the following conditions are
-*  met:
-*
-*  * Redistributions of source code must retain the above copyright
-*  notice, this list of conditions and the following disclaimer.
-*  * Redistributions in binary form must reproduce the above
-*  copyright notice, this list of conditions and the following disclaimer
-*  in the documentation and/or other materials provided with the
-*  distribution.
-*
-*  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-*  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-*  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-*  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-*  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-*  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-*  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-*  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-*  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-*  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-*  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*
-*  You can contact the author at :
-*  - xxHash homepage: http://www.xxhash.com
-*  - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
-
-
-/* *************************************
-*  Tuning parameters
-***************************************/
-/*!XXH_FORCE_MEMORY_ACCESS :
- * By default, access to unaligned memory is controlled by `memcpy()`, which is safe and portable.
- * Unfortunately, on some target/compiler combinations, the generated assembly is sub-optimal.
- * The below switch allow to select different access method for improved performance.
- * Method 0 (default) : use `memcpy()`. Safe and portable.
- * Method 1 : `__packed` statement. It depends on compiler extension (ie, not portable).
- *            This method is safe if your compiler supports it, and *generally* as fast or faster than `memcpy`.
- * Method 2 : direct access. This method doesn't depend on compiler but violate C standard.
- *            It can generate buggy code on targets which do not support unaligned memory accesses.
- *            But in some circumstances, it's the only known way to get the most performance (ie GCC + ARMv6)
- * See http://stackoverflow.com/a/32095106/646947 for details.
- * Prefer these methods in priority order (0 > 1 > 2)
- */
-#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
-#  if defined(__GNUC__) && ( defined(__ARM_ARCH_6__) || defined(__ARM_ARCH_6J__) || defined(__ARM_ARCH_6K__) || defined(__ARM_ARCH_6Z__) || defined(__ARM_ARCH_6ZK__) || defined(__ARM_ARCH_6T2__) )
-#    define XXH_FORCE_MEMORY_ACCESS 2
-#  elif defined(__INTEL_COMPILER) || \
-  (defined(__GNUC__) && ( defined(__ARM_ARCH_7__) || defined(__ARM_ARCH_7A__) || defined(__ARM_ARCH_7R__) || defined(__ARM_ARCH_7M__) || defined(__ARM_ARCH_7S__) ))
-#    define XXH_FORCE_MEMORY_ACCESS 1
-#  endif
-#endif
-
-/*!XXH_ACCEPT_NULL_INPUT_POINTER :
- * If the input pointer is a null pointer, xxHash default behavior is to trigger a memory access error, since it is a bad pointer.
- * When this option is enabled, xxHash output for null input pointers will be the same as a null-length input.
- * By default, this option is disabled. To enable it, uncomment below define :
- */
-/* #define XXH_ACCEPT_NULL_INPUT_POINTER 1 */
-
-/*!XXH_FORCE_NATIVE_FORMAT :
- * By default, xxHash library provides endian-independent Hash values, based on little-endian convention.
- * Results are therefore identical for little-endian and big-endian CPU.
- * This comes at a performance cost for big-endian CPU, since some swapping is required to emulate little-endian format.
- * Should endian-independence be of no importance for your application, you may set the #define below to 1,
- * to improve speed for Big-endian CPU.
- * This option has no impact on Little_Endian CPU.
- */
-#ifndef XXH_FORCE_NATIVE_FORMAT   /* can be defined externally */
-#  define XXH_FORCE_NATIVE_FORMAT 0
-#endif
-
-/*!XXH_FORCE_ALIGN_CHECK :
- * This is a minor performance trick, only useful with lots of very small keys.
- * It means : check for aligned/unaligned input.
- * The check costs one initial branch per hash;
- * set it to 0 when the input is guaranteed to be aligned,
- * or when alignment doesn't matter for performance.
- */
-#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
-#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
-#    define XXH_FORCE_ALIGN_CHECK 0
-#  else
-#    define XXH_FORCE_ALIGN_CHECK 1
-#  endif
-#endif
-
-
-/* *************************************
-*  Includes & Memory related functions
-***************************************/
-/*! Modify the local functions below should you wish to use some other memory routines
-*   for malloc(), free() */
-#include <stdlib.h>
-static void* XXH_malloc(size_t s) { return malloc(s); }
-static void  XXH_free  (void* p)  { free(p); }
-/*! and for memcpy() */
-#include <string.h>
-static void* XXH_memcpy(void* dest, const void* src, size_t size) { return memcpy(dest,src,size); }
-
-#define XXH_STATIC_LINKING_ONLY
-#include "xxhash.h"
-
-
-/* *************************************
-*  Compiler Specific Options
-***************************************/
-#ifdef _MSC_VER    /* Visual Studio */
-#  pragma warning(disable : 4127)      /* disable: C4127: conditional expression is constant */
-#  define FORCE_INLINE static __forceinline
-#else
-#  if defined (__cplusplus) || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
-#    ifdef __GNUC__
-#      define FORCE_INLINE static inline __attribute__((always_inline))
-#    else
-#      define FORCE_INLINE static inline
-#    endif
-#  else
-#    define FORCE_INLINE static
-#  endif /* __STDC_VERSION__ */
-#endif
-
-
-/* *************************************
-*  Basic Types
-***************************************/
-#ifndef MEM_MODULE
-# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
-#   include <stdint.h>
-    typedef uint8_t  BYTE;
-    typedef uint16_t U16;
-    typedef uint32_t U32;
-# else
-    typedef unsigned char      BYTE;
-    typedef unsigned short     U16;
-    typedef unsigned int       U32;
-# endif
-#endif
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static U32 XXH_read32(const void* memPtr) { return *(const U32*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { U32 u32; } __attribute__((packed)) unalign;
-static U32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-static U32 XXH_read32(const void* memPtr)
-{
-    U32 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-
-/* ****************************************
-*  Compiler-specific Functions and Macros
-******************************************/
-#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
-
-/* Note : although _rotl exists for minGW (GCC under windows), performance seems poor */
-#if defined(_MSC_VER)
-#  define XXH_rotl32(x,r) _rotl(x,r)
-#  define XXH_rotl64(x,r) _rotl64(x,r)
-#else
-#  define XXH_rotl32(x,r) ((x << r) | (x >> (32 - r)))
-#  define XXH_rotl64(x,r) ((x << r) | (x >> (64 - r)))
-#endif
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap32 _byteswap_ulong
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap32 __builtin_bswap32
-#else
-static U32 XXH_swap32 (U32 x)
-{
-    return  ((x << 24) & 0xff000000 ) |
-            ((x <<  8) & 0x00ff0000 ) |
-            ((x >>  8) & 0x0000ff00 ) |
-            ((x >> 24) & 0x000000ff );
-}
-#endif
-
-
-/* *************************************
-*  Architecture Macros
-***************************************/
-typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
-
-/* XXH_CPU_LITTLE_ENDIAN can be defined externally, for example on the compiler command line */
-#ifndef XXH_CPU_LITTLE_ENDIAN
-    static const int g_one = 1;
-#   define XXH_CPU_LITTLE_ENDIAN   (*(const char*)(&g_one))
-#endif
-
-
-/* ***************************
-*  Memory reads
-*****************************/
-typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
-
-FORCE_INLINE U32 XXH_readLE32_align(const void* ptr, XXH_endianess endian, XXH_alignment align)
-{
-    if (align==XXH_unaligned)
-        return endian==XXH_littleEndian ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
-    else
-        return endian==XXH_littleEndian ? *(const U32*)ptr : XXH_swap32(*(const U32*)ptr);
-}
-
-FORCE_INLINE U32 XXH_readLE32(const void* ptr, XXH_endianess endian)
-{
-    return XXH_readLE32_align(ptr, endian, XXH_unaligned);
-}
-
-static U32 XXH_readBE32(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
-}
-
-
-/* *************************************
-*  Macros
-***************************************/
-#define XXH_STATIC_ASSERT(c)   { enum { XXH_static_assert = 1/(int)(!!(c)) }; }    /* use only *after* variable declarations */
-XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
-
-
-/* *******************************************************************
-*  32-bits hash functions
-*********************************************************************/
-static const U32 PRIME32_1 = 2654435761U;
-static const U32 PRIME32_2 = 2246822519U;
-static const U32 PRIME32_3 = 3266489917U;
-static const U32 PRIME32_4 =  668265263U;
-static const U32 PRIME32_5 =  374761393U;
-
-static U32 XXH32_round(U32 seed, U32 input)
-{
-    seed += input * PRIME32_2;
-    seed  = XXH_rotl32(seed, 13);
-    seed *= PRIME32_1;
-    return seed;
-}
-
-FORCE_INLINE U32 XXH32_endian_align(const void* input, size_t len, U32 seed, XXH_endianess endian, XXH_alignment align)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* bEnd = p + len;
-    U32 h32;
-#define XXH_get32bits(p) XXH_readLE32_align(p, endian, align)
-
-#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
-    if (p==NULL) {
-        len=0;
-        bEnd=p=(const BYTE*)(size_t)16;
-    }
-#endif
-
-    if (len>=16) {
-        const BYTE* const limit = bEnd - 16;
-        U32 v1 = seed + PRIME32_1 + PRIME32_2;
-        U32 v2 = seed + PRIME32_2;
-        U32 v3 = seed + 0;
-        U32 v4 = seed - PRIME32_1;
-
-        do {
-            v1 = XXH32_round(v1, XXH_get32bits(p)); p+=4;
-            v2 = XXH32_round(v2, XXH_get32bits(p)); p+=4;
-            v3 = XXH32_round(v3, XXH_get32bits(p)); p+=4;
-            v4 = XXH32_round(v4, XXH_get32bits(p)); p+=4;
-        } while (p<=limit);
-
-        h32 = XXH_rotl32(v1, 1) + XXH_rotl32(v2, 7) + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
-    } else {
-        h32  = seed + PRIME32_5;
-    }
-
-    h32 += (U32) len;
-
-    while (p+4<=bEnd) {
-        h32 += XXH_get32bits(p) * PRIME32_3;
-        h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
-        p+=4;
-    }
-
-    while (p<bEnd) {
-        h32 += (*p) * PRIME32_5;
-        h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
-        p++;
-    }
-
-    h32 ^= h32 >> 15;
-    h32 *= PRIME32_2;
-    h32 ^= h32 >> 13;
-    h32 *= PRIME32_3;
-    h32 ^= h32 >> 16;
-
-    return h32;
-}
-
-
-XXH_PUBLIC_API unsigned int XXH32 (const void* input, size_t len, unsigned int seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH32_state_t state;
-    XXH32_reset(&state, seed);
-    XXH32_update(&state, input, len);
-    return XXH32_digest(&state);
-#else
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
-            if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-                return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
-            else
-                return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
-    }   }
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH32_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
-    else
-        return XXH32_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
-#endif
-}
-
-
-
-/*======   Hash streaming   ======*/
-
-XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
-{
-    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, unsigned int seed)
-{
-    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state)-4);   /* do not write into reserved, for future removal */
-    state.v1 = seed + PRIME32_1 + PRIME32_2;
-    state.v2 = seed + PRIME32_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME32_1;
-    memcpy(statePtr, &state, sizeof(state));
-    return XXH_OK;
-}
-
-
-FORCE_INLINE XXH_errorcode XXH32_update_endian (XXH32_state_t* state, const void* input, size_t len, XXH_endianess endian)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* const bEnd = p + len;
-
-#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
-    if (input==NULL) return XXH_ERROR;
-#endif
-
-    state->total_len_32 += (unsigned)len;
-    state->large_len |= (len>=16) | (state->total_len_32>=16);
-
-    if (state->memsize + len < 16)  {   /* fill in tmp buffer */
-        XXH_memcpy((BYTE*)(state->mem32) + state->memsize, input, len);
-        state->memsize += (unsigned)len;
-        return XXH_OK;
-    }
-
-    if (state->memsize) {   /* some data left from previous update */
-        XXH_memcpy((BYTE*)(state->mem32) + state->memsize, input, 16-state->memsize);
-        {   const U32* p32 = state->mem32;
-            state->v1 = XXH32_round(state->v1, XXH_readLE32(p32, endian)); p32++;
-            state->v2 = XXH32_round(state->v2, XXH_readLE32(p32, endian)); p32++;
-            state->v3 = XXH32_round(state->v3, XXH_readLE32(p32, endian)); p32++;
-            state->v4 = XXH32_round(state->v4, XXH_readLE32(p32, endian));
-        }
-        p += 16-state->memsize;
-        state->memsize = 0;
-    }
-
-    if (p <= bEnd-16) {
-        const BYTE* const limit = bEnd - 16;
-        U32 v1 = state->v1;
-        U32 v2 = state->v2;
-        U32 v3 = state->v3;
-        U32 v4 = state->v4;
-
-        do {
-            v1 = XXH32_round(v1, XXH_readLE32(p, endian)); p+=4;
-            v2 = XXH32_round(v2, XXH_readLE32(p, endian)); p+=4;
-            v3 = XXH32_round(v3, XXH_readLE32(p, endian)); p+=4;
-            v4 = XXH32_round(v4, XXH_readLE32(p, endian)); p+=4;
-        } while (p<=limit);
-
-        state->v1 = v1;
-        state->v2 = v2;
-        state->v3 = v3;
-        state->v4 = v4;
-    }
-
-    if (p < bEnd) {
-        XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
-        state->memsize = (unsigned)(bEnd-p);
-    }
-
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* state_in, const void* input, size_t len)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH32_update_endian(state_in, input, len, XXH_littleEndian);
-    else
-        return XXH32_update_endian(state_in, input, len, XXH_bigEndian);
-}
-
-
-
-FORCE_INLINE U32 XXH32_digest_endian (const XXH32_state_t* state, XXH_endianess endian)
-{
-    const BYTE * p = (const BYTE*)state->mem32;
-    const BYTE* const bEnd = (const BYTE*)(state->mem32) + state->memsize;
-    U32 h32;
-
-    if (state->large_len) {
-        h32 = XXH_rotl32(state->v1, 1) + XXH_rotl32(state->v2, 7) + XXH_rotl32(state->v3, 12) + XXH_rotl32(state->v4, 18);
-    } else {
-        h32 = state->v3 /* == seed */ + PRIME32_5;
-    }
-
-    h32 += state->total_len_32;
-
-    while (p+4<=bEnd) {
-        h32 += XXH_readLE32(p, endian) * PRIME32_3;
-        h32  = XXH_rotl32(h32, 17) * PRIME32_4;
-        p+=4;
-    }
-
-    while (p<bEnd) {
-        h32 += (*p) * PRIME32_5;
-        h32  = XXH_rotl32(h32, 11) * PRIME32_1;
-        p++;
-    }
-
-    h32 ^= h32 >> 15;
-    h32 *= PRIME32_2;
-    h32 ^= h32 >> 13;
-    h32 *= PRIME32_3;
-    h32 ^= h32 >> 16;
-
-    return h32;
-}
-
-
-XXH_PUBLIC_API unsigned int XXH32_digest (const XXH32_state_t* state_in)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH32_digest_endian(state_in, XXH_littleEndian);
-    else
-        return XXH32_digest_endian(state_in, XXH_bigEndian);
-}
-
-
-/*======   Canonical representation   ======*/
-
-/*! Default XXH result types are basic unsigned 32 and 64 bits.
-*   The canonical representation follows human-readable write convention, aka big-endian (large digits first).
-*   These functions allow transformation of hash result into and from its canonical format.
-*   This way, hash values can be written into a file or buffer, and remain comparable across different systems and programs.
-*/
-
-XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
-{
-    return XXH_readBE32(src);
-}
-
-
-#ifndef XXH_NO_LONG_LONG
-
-/* *******************************************************************
-*  64-bits hash functions
-*********************************************************************/
-
-/*======   Memory access   ======*/
-
-#ifndef MEM_MODULE
-# define MEM_MODULE
-# if !defined (__VMS) && (defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
-#   include <stdint.h>
-    typedef uint64_t U64;
-# else
-    typedef unsigned long long U64;   /* if your compiler doesn't support unsigned long long, replace by another 64-bit type here. Note that xxhash.h will also need to be updated. */
-# endif
-#endif
-
-
-#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
-
-/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
-static U64 XXH_read64(const void* memPtr) { return *(const U64*) memPtr; }
-
-#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
-
-/* __pack instructions are safer, but compiler specific, hence potentially problematic for some compilers */
-/* currently only defined for gcc and icc */
-typedef union { U32 u32; U64 u64; } __attribute__((packed)) unalign64;
-static U64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
-
-#else
-
-/* portable and safe solution. Generally efficient.
- * see : http://stackoverflow.com/a/32095106/646947
- */
-
-static U64 XXH_read64(const void* memPtr)
-{
-    U64 val;
-    memcpy(&val, memPtr, sizeof(val));
-    return val;
-}
-
-#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
-
-#if defined(_MSC_VER)     /* Visual Studio */
-#  define XXH_swap64 _byteswap_uint64
-#elif XXH_GCC_VERSION >= 403
-#  define XXH_swap64 __builtin_bswap64
-#else
-static U64 XXH_swap64 (U64 x)
-{
-    return  ((x << 56) & 0xff00000000000000ULL) |
-            ((x << 40) & 0x00ff000000000000ULL) |
-            ((x << 24) & 0x0000ff0000000000ULL) |
-            ((x << 8)  & 0x000000ff00000000ULL) |
-            ((x >> 8)  & 0x00000000ff000000ULL) |
-            ((x >> 24) & 0x0000000000ff0000ULL) |
-            ((x >> 40) & 0x000000000000ff00ULL) |
-            ((x >> 56) & 0x00000000000000ffULL);
-}
-#endif
-
-FORCE_INLINE U64 XXH_readLE64_align(const void* ptr, XXH_endianess endian, XXH_alignment align)
-{
-    if (align==XXH_unaligned)
-        return endian==XXH_littleEndian ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
-    else
-        return endian==XXH_littleEndian ? *(const U64*)ptr : XXH_swap64(*(const U64*)ptr);
-}
-
-FORCE_INLINE U64 XXH_readLE64(const void* ptr, XXH_endianess endian)
-{
-    return XXH_readLE64_align(ptr, endian, XXH_unaligned);
-}
-
-static U64 XXH_readBE64(const void* ptr)
-{
-    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
-}
-
-
-/*======   xxh64   ======*/
-
-static const U64 PRIME64_1 = 11400714785074694791ULL;
-static const U64 PRIME64_2 = 14029467366897019727ULL;
-static const U64 PRIME64_3 =  1609587929392839161ULL;
-static const U64 PRIME64_4 =  9650029242287828579ULL;
-static const U64 PRIME64_5 =  2870177450012600261ULL;
-
-static U64 XXH64_round(U64 acc, U64 input)
-{
-    acc += input * PRIME64_2;
-    acc  = XXH_rotl64(acc, 31);
-    acc *= PRIME64_1;
-    return acc;
-}
-
-static U64 XXH64_mergeRound(U64 acc, U64 val)
-{
-    val  = XXH64_round(0, val);
-    acc ^= val;
-    acc  = acc * PRIME64_1 + PRIME64_4;
-    return acc;
-}
-
-FORCE_INLINE U64 XXH64_endian_align(const void* input, size_t len, U64 seed, XXH_endianess endian, XXH_alignment align)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* bEnd = p + len;
-    U64 h64;
-#define XXH_get64bits(p) XXH_readLE64_align(p, endian, align)
-
-#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
-    if (p==NULL) {
-        len=0;
-        bEnd=p=(const BYTE*)(size_t)32;
-    }
-#endif
-
-    if (len>=32) {
-        const BYTE* const limit = bEnd - 32;
-        U64 v1 = seed + PRIME64_1 + PRIME64_2;
-        U64 v2 = seed + PRIME64_2;
-        U64 v3 = seed + 0;
-        U64 v4 = seed - PRIME64_1;
-
-        do {
-            v1 = XXH64_round(v1, XXH_get64bits(p)); p+=8;
-            v2 = XXH64_round(v2, XXH_get64bits(p)); p+=8;
-            v3 = XXH64_round(v3, XXH_get64bits(p)); p+=8;
-            v4 = XXH64_round(v4, XXH_get64bits(p)); p+=8;
-        } while (p<=limit);
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-
-    } else {
-        h64  = seed + PRIME64_5;
-    }
-
-    h64 += (U64) len;
-
-    while (p+8<=bEnd) {
-        U64 const k1 = XXH64_round(0, XXH_get64bits(p));
-        h64 ^= k1;
-        h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;
-        p+=8;
-    }
-
-    if (p+4<=bEnd) {
-        h64 ^= (U64)(XXH_get32bits(p)) * PRIME64_1;
-        h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
-        p+=4;
-    }
-
-    while (p<bEnd) {
-        h64 ^= (*p) * PRIME64_5;
-        h64 = XXH_rotl64(h64, 11) * PRIME64_1;
-        p++;
-    }
-
-    h64 ^= h64 >> 33;
-    h64 *= PRIME64_2;
-    h64 ^= h64 >> 29;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
-
-    return h64;
-}
-
-
-XXH_PUBLIC_API unsigned long long XXH64 (const void* input, size_t len, unsigned long long seed)
-{
-#if 0
-    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
-    XXH64_state_t state;
-    XXH64_reset(&state, seed);
-    XXH64_update(&state, input, len);
-    return XXH64_digest(&state);
-#else
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if (XXH_FORCE_ALIGN_CHECK) {
-        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
-            if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-                return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_aligned);
-            else
-                return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_aligned);
-    }   }
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH64_endian_align(input, len, seed, XXH_littleEndian, XXH_unaligned);
-    else
-        return XXH64_endian_align(input, len, seed, XXH_bigEndian, XXH_unaligned);
-#endif
-}
-
-/*======   Hash Streaming   ======*/
-
-XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
-{
-    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
-}
-XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
-{
-    XXH_free(statePtr);
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
-{
-    memcpy(dstState, srcState, sizeof(*dstState));
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, unsigned long long seed)
-{
-    XXH64_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
-    memset(&state, 0, sizeof(state)-8);   /* do not write into reserved, for future removal */
-    state.v1 = seed + PRIME64_1 + PRIME64_2;
-    state.v2 = seed + PRIME64_2;
-    state.v3 = seed + 0;
-    state.v4 = seed - PRIME64_1;
-    memcpy(statePtr, &state, sizeof(state));
-    return XXH_OK;
-}
-
-FORCE_INLINE XXH_errorcode XXH64_update_endian (XXH64_state_t* state, const void* input, size_t len, XXH_endianess endian)
-{
-    const BYTE* p = (const BYTE*)input;
-    const BYTE* const bEnd = p + len;
-
-#ifdef XXH_ACCEPT_NULL_INPUT_POINTER
-    if (input==NULL) return XXH_ERROR;
-#endif
-
-    state->total_len += len;
-
-    if (state->memsize + len < 32) {  /* fill in tmp buffer */
-        XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, len);
-        state->memsize += (U32)len;
-        return XXH_OK;
-    }
-
-    if (state->memsize) {   /* tmp buffer is full */
-        XXH_memcpy(((BYTE*)state->mem64) + state->memsize, input, 32-state->memsize);
-        state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0, endian));
-        state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1, endian));
-        state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2, endian));
-        state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3, endian));
-        p += 32-state->memsize;
-        state->memsize = 0;
-    }
-
-    if (p+32 <= bEnd) {
-        const BYTE* const limit = bEnd - 32;
-        U64 v1 = state->v1;
-        U64 v2 = state->v2;
-        U64 v3 = state->v3;
-        U64 v4 = state->v4;
-
-        do {
-            v1 = XXH64_round(v1, XXH_readLE64(p, endian)); p+=8;
-            v2 = XXH64_round(v2, XXH_readLE64(p, endian)); p+=8;
-            v3 = XXH64_round(v3, XXH_readLE64(p, endian)); p+=8;
-            v4 = XXH64_round(v4, XXH_readLE64(p, endian)); p+=8;
-        } while (p<=limit);
-
-        state->v1 = v1;
-        state->v2 = v2;
-        state->v3 = v3;
-        state->v4 = v4;
-    }
-
-    if (p < bEnd) {
-        XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
-        state->memsize = (unsigned)(bEnd-p);
-    }
-
-    return XXH_OK;
-}
-
-XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* state_in, const void* input, size_t len)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH64_update_endian(state_in, input, len, XXH_littleEndian);
-    else
-        return XXH64_update_endian(state_in, input, len, XXH_bigEndian);
-}
-
-FORCE_INLINE U64 XXH64_digest_endian (const XXH64_state_t* state, XXH_endianess endian)
-{
-    const BYTE * p = (const BYTE*)state->mem64;
-    const BYTE* const bEnd = (const BYTE*)state->mem64 + state->memsize;
-    U64 h64;
-
-    if (state->total_len >= 32) {
-        U64 const v1 = state->v1;
-        U64 const v2 = state->v2;
-        U64 const v3 = state->v3;
-        U64 const v4 = state->v4;
-
-        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
-        h64 = XXH64_mergeRound(h64, v1);
-        h64 = XXH64_mergeRound(h64, v2);
-        h64 = XXH64_mergeRound(h64, v3);
-        h64 = XXH64_mergeRound(h64, v4);
-    } else {
-        h64  = state->v3 + PRIME64_5;
-    }
-
-    h64 += (U64) state->total_len;
-
-    while (p+8<=bEnd) {
-        U64 const k1 = XXH64_round(0, XXH_readLE64(p, endian));
-        h64 ^= k1;
-        h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4;
-        p+=8;
-    }
-
-    if (p+4<=bEnd) {
-        h64 ^= (U64)(XXH_readLE32(p, endian)) * PRIME64_1;
-        h64  = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
-        p+=4;
-    }
-
-    while (p<bEnd) {
-        h64 ^= (*p) * PRIME64_5;
-        h64  = XXH_rotl64(h64, 11) * PRIME64_1;
-        p++;
-    }
-
-    h64 ^= h64 >> 33;
-    h64 *= PRIME64_2;
-    h64 ^= h64 >> 29;
-    h64 *= PRIME64_3;
-    h64 ^= h64 >> 32;
-
-    return h64;
-}
-
-XXH_PUBLIC_API unsigned long long XXH64_digest (const XXH64_state_t* state_in)
-{
-    XXH_endianess endian_detected = (XXH_endianess)XXH_CPU_LITTLE_ENDIAN;
-
-    if ((endian_detected==XXH_littleEndian) || XXH_FORCE_NATIVE_FORMAT)
-        return XXH64_digest_endian(state_in, XXH_littleEndian);
-    else
-        return XXH64_digest_endian(state_in, XXH_bigEndian);
-}
-
-
-/*====== Canonical representation   ======*/
-
-XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
-{
-    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
-    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
-    memcpy(dst, &hash, sizeof(*dst));
-}
-
-XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
-{
-    return XXH_readBE64(src);
-}
-
-#endif  /* XXH_NO_LONG_LONG */
diff --git a/xxHash/xxhash.h b/xxHash/xxhash.h
index 9d831e03..f711b34e 100644
--- a/xxHash/xxhash.h
+++ b/xxHash/xxhash.h
@@ -1,40 +1,42 @@
 /*
-   xxHash - Extremely Fast Hash algorithm
-   Header File
-   Copyright (C) 2012-2016, Yann Collet.
-
-   BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)
-
-   Redistribution and use in source and binary forms, with or without
-   modification, are permitted provided that the following conditions are
-   met:
-
-       * Redistributions of source code must retain the above copyright
-   notice, this list of conditions and the following disclaimer.
-       * Redistributions in binary form must reproduce the above
-   copyright notice, this list of conditions and the following disclaimer
-   in the documentation and/or other materials provided with the
-   distribution.
-
-   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-   You can contact the author at :
-   - xxHash source repository : https://github.com/Cyan4973/xxHash
-*/
+ * xxHash - Extremely Fast Hash algorithm
+ * Header File
+ * Copyright (C) 2012-present, Yann Collet.
+ *
+ * BSD 2-Clause License (https://www.opensource.org/licenses/bsd-license.php)
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *
+ *    * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *    * Redistributions in binary form must reproduce the above
+ *      copyright notice, this list of conditions and the following disclaimer
+ *      in the documentation and/or other materials provided with the
+ *      distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * You can contact the author at:
+ *   - xxHash homepage: https://www.xxhash.com
+ *   - xxHash source repository: https://github.com/Cyan4973/xxHash
+ */
 
-/* Notice extracted from xxHash homepage :
+/* TODO: update */
+/* Notice extracted from xxHash homepage:
 
-xxHash is an extremely fast Hash algorithm, running at RAM speed limits.
+xxHash is an extremely fast hash algorithm, running at RAM speed limits.
 It also successfully passes all tests from the SMHasher suite.
 
 Comparison (single thread, Windows Seven 32 bits, using SMHasher on a Core 2 Duo @3GHz)
@@ -57,44 +59,50 @@ Q.Score is a measure of quality of the hash function.
 It depends on successfully passing SMHasher test set.
 10 is a perfect score.
 
-A 64-bits version, named XXH64, is available since r35.
-It offers much better speed, but for 64-bits applications only.
+Note: SMHasher's CRC32 implementation is not the fastest one.
+Other speed-oriented implementations can be faster,
+especially in combination with PCLMUL instruction:
+https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html?showComment=1552696407071#c3490092340461170735
+
+A 64-bit version, named XXH64, is available since r35.
+It offers much better speed, but for 64-bit applications only.
 Name     Speed on 64 bits    Speed on 32 bits
 XXH64       13.8 GB/s            1.9 GB/s
 XXH32        6.8 GB/s            6.0 GB/s
 */
 
-#ifndef XXHASH_H_5627135585666179
-#define XXHASH_H_5627135585666179 1
-
 #if defined (__cplusplus)
 extern "C" {
 #endif
 
-
-/* ****************************
-*  Definitions
-******************************/
-#include <stddef.h>   /* size_t */
-typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
-
-
 /* ****************************
-*  API modifier
-******************************/
-/** XXH_PRIVATE_API
-*   This is useful to include xxhash functions in `static` mode
-*   in order to inline them, and remove their symbol from the public list.
-*   Methodology :
-*     #define XXH_PRIVATE_API
-*     #include "xxhash.h"
-*   `xxhash.c` is automatically included.
-*   It's not useful to compile and link it as a separate module.
-*/
-#ifdef XXH_PRIVATE_API
-#  ifndef XXH_STATIC_LINKING_ONLY
-#    define XXH_STATIC_LINKING_ONLY
-#  endif
+ *  INLINE mode
+ ******************************/
+/*!
+ * XXH_INLINE_ALL (and XXH_PRIVATE_API)
+ * Use these build macros to inline xxhash into the target unit.
+ * Inlining improves performance on small inputs, especially when the length is
+ * expressed as a compile-time constant:
+ *
+ *      https://fastcompression.blogspot.com/2018/03/xxhash-for-small-keys-impressive-power.html
+ *
+ * It also keeps xxHash symbols private to the unit, so they are not exported.
+ *
+ * Usage:
+ *     #define XXH_INLINE_ALL
+ *     #include "xxhash.h"
+ *
+ * Do not compile and link xxhash.o as a separate object, as it is not useful.
+ */
+#if (defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)) \
+    && !defined(XXH_INLINE_ALL_31684351384)
+   /* this section should be traversed only once */
+#  define XXH_INLINE_ALL_31684351384
+   /* give access to the advanced API, required to compile implementations */
+#  undef XXH_STATIC_LINKING_ONLY   /* avoid macro redef */
+#  define XXH_STATIC_LINKING_ONLY
+   /* make all functions private */
+#  undef XXH_PUBLIC_API
 #  if defined(__GNUC__)
 #    define XXH_PUBLIC_API static __inline __attribute__((unused))
 #  elif defined (__cplusplus) || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */)
@@ -102,23 +110,87 @@ typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
 #  elif defined(_MSC_VER)
 #    define XXH_PUBLIC_API static __inline
 #  else
-#    define XXH_PUBLIC_API static   /* this version may generate warnings for unused static functions; disable the relevant warning */
+     /* note: this version may generate warnings for unused static functions */
+#    define XXH_PUBLIC_API static
 #  endif
-#else
-#  define XXH_PUBLIC_API   /* do nothing */
-#endif /* XXH_PRIVATE_API */
 
-/*!XXH_NAMESPACE, aka Namespace Emulation :
+   /*
+    * This part deals with the special case where a unit wants to inline xxHash,
+    * but "xxhash.h" has previously been included without XXH_INLINE_ALL, such
+    * as part of some previously included *.h header file.
+    * Without further action, the new include would just be ignored,
+    * and functions would effectively _not_ be inlined (silent failure).
+    * The following macros solve this situation by prefixing all inlined names,
+    * avoiding naming collision with previous inclusions.
+    */
+#  ifdef XXH_NAMESPACE
+#    error "XXH_INLINE_ALL with XXH_NAMESPACE is not supported"
+     /*
+      * Note: Alternative: #undef all symbols (it's a pretty large list).
+      * Without #error: it compiles, but functions are actually not inlined.
+      */
+#  endif
+#  define XXH_NAMESPACE XXH_INLINE_
+   /*
+    * Some identifiers (enums, type names) are not symbols, but they must
+    * still be renamed to avoid redeclaration.
+    * Alternative solution: do not redeclare them.
+    * However, this requires some #ifdefs, and is a more dispersed action.
+    * Meanwhile, renaming can be achieved in a single block
+    */
+#  define XXH_IPREF(Id)   XXH_INLINE_ ## Id
+#  define XXH_OK XXH_IPREF(XXH_OK)
+#  define XXH_ERROR XXH_IPREF(XXH_ERROR)
+#  define XXH_errorcode XXH_IPREF(XXH_errorcode)
+#  define XXH32_canonical_t  XXH_IPREF(XXH32_canonical_t)
+#  define XXH64_canonical_t  XXH_IPREF(XXH64_canonical_t)
+#  define XXH128_canonical_t XXH_IPREF(XXH128_canonical_t)
+#  define XXH32_state_s XXH_IPREF(XXH32_state_s)
+#  define XXH32_state_t XXH_IPREF(XXH32_state_t)
+#  define XXH64_state_s XXH_IPREF(XXH64_state_s)
+#  define XXH64_state_t XXH_IPREF(XXH64_state_t)
+#  define XXH3_state_s  XXH_IPREF(XXH3_state_s)
+#  define XXH3_state_t  XXH_IPREF(XXH3_state_t)
+#  define XXH128_hash_t XXH_IPREF(XXH128_hash_t)
+   /* Ensure the header is parsed again, even if it was previously included */
+#  undef XXHASH_H_5627135585666179
+#  undef XXHASH_H_STATIC_13879238742
+#endif /* XXH_INLINE_ALL || XXH_PRIVATE_API */
 
-If you want to include _and expose_ xxHash functions from within your own library,
-but also want to avoid symbol collisions with other libraries which may also include xxHash,
 
-you can use XXH_NAMESPACE, to automatically prefix any public symbol from xxhash library
-with the value of XXH_NAMESPACE (therefore, avoid NULL and numeric values).
 
-Note that no change is required within the calling program as long as it includes `xxhash.h` :
-regular symbol name will be automatically translated by this header.
-*/
+/* ****************************************************************
+ *  Stable API
+ *****************************************************************/
+#ifndef XXHASH_H_5627135585666179
+#define XXHASH_H_5627135585666179 1
+
+/* specific declaration modes for Windows */
+#if !defined(XXH_INLINE_ALL) && !defined(XXH_PRIVATE_API)
+#  if defined(WIN32) && defined(_MSC_VER) && (defined(XXH_IMPORT) || defined(XXH_EXPORT))
+#    ifdef XXH_EXPORT
+#      define XXH_PUBLIC_API __declspec(dllexport)
+#    elif XXH_IMPORT
+#      define XXH_PUBLIC_API __declspec(dllimport)
+#    endif
+#  else
+#    define XXH_PUBLIC_API   /* do nothing */
+#  endif
+#endif
+
+/*!
+ * XXH_NAMESPACE, aka Namespace Emulation:
+ *
+ * If you want to include _and expose_ xxHash functions from within your own
+ * library, but also want to avoid symbol collisions with other libraries which
+ * may also include xxHash, you can use XXH_NAMESPACE to automatically prefix
+ * any public symbol from xxhash library with the value of XXH_NAMESPACE
+ * (therefore, avoid empty or numeric values).
+ *
+ * Note that no change is required within the calling program as long as it
+ * includes `xxhash.h`: Regular symbol names will be automatically translated
+ * by this header.
+ */
 #ifdef XXH_NAMESPACE
 #  define XXH_CAT(A,B) A##B
 #  define XXH_NAME2(A,B) XXH_CAT(A,B)
@@ -148,146 +220,1722 @@ regular symbol name will be automatically translated by this header.
 *  Version
 ***************************************/
 #define XXH_VERSION_MAJOR    0
-#define XXH_VERSION_MINOR    6
-#define XXH_VERSION_RELEASE  2
+#define XXH_VERSION_MINOR    7
+#define XXH_VERSION_RELEASE  3
 #define XXH_VERSION_NUMBER  (XXH_VERSION_MAJOR *100*100 + XXH_VERSION_MINOR *100 + XXH_VERSION_RELEASE)
 XXH_PUBLIC_API unsigned XXH_versionNumber (void);
 
 
+/* ****************************
+*  Definitions
+******************************/
+#include <stddef.h>   /* size_t */
+typedef enum { XXH_OK=0, XXH_ERROR } XXH_errorcode;
+
+
 /*-**********************************************************************
-*  32-bits hash
+*  32-bit hash
 ************************************************************************/
-typedef unsigned int XXH32_hash_t;
+#if !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   include <stdint.h>
+    typedef uint32_t XXH32_hash_t;
+#else
+#   include <limits.h>
+#   if UINT_MAX == 0xFFFFFFFFUL
+      typedef unsigned int XXH32_hash_t;
+#   else
+#     if ULONG_MAX == 0xFFFFFFFFUL
+        typedef unsigned long XXH32_hash_t;
+#     else
+#       error "unsupported platform: need a 32-bit type"
+#     endif
+#   endif
+#endif
+
+/*!
+ * XXH32():
+ *  Calculate the 32-bit hash of sequence "length" bytes stored at memory address "input".
+ *  The memory between input & input+length must be valid (allocated and read-accessible).
+ *  "seed" can be used to alter the result predictably.
+ *  Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark): 5.4 GB/s
+ */
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, XXH32_hash_t seed);
+
+/*******   Streaming   *******/
 
-/*! XXH32() :
-    Calculate the 32-bits hash of sequence "length" bytes stored at memory address "input".
-    The memory between input & input+length must be valid (allocated and read-accessible).
-    "seed" can be used to alter the result predictably.
-    Speed on Core 2 Duo @ 3 GHz (single thread, SMHasher benchmark) : 5.4 GB/s */
-XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t length, unsigned int seed);
+/*
+ * Streaming functions generate the xxHash value from an incrememtal input.
+ * This method is slower than single-call functions, due to state management.
+ * For small inputs, prefer `XXH32()` and `XXH64()`, which are better optimized.
+ *
+ * An XXH state must first be allocated using `XXH*_createState()`.
+ *
+ * Start a new hash by initializing the state with a seed using `XXH*_reset()`.
+ *
+ * Then, feed the hash state by calling `XXH*_update()` as many times as necessary.
+ *
+ * The function returns an error code, with 0 meaning OK, and any other value
+ * meaning there is an error.
+ *
+ * Finally, a hash value can be produced anytime, by using `XXH*_digest()`.
+ * This function returns the nn-bits hash as an int or long long.
+ *
+ * It's still possible to continue inserting input into the hash state after a
+ * digest, and generate new hash values later on by invoking `XXH*_digest()`.
+ *
+ * When done, release the state using `XXH*_freeState()`.
+ */
 
-/*======   Streaming   ======*/
 typedef struct XXH32_state_s XXH32_state_t;   /* incomplete type */
 XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void);
 XXH_PUBLIC_API XXH_errorcode  XXH32_freeState(XXH32_state_t* statePtr);
 XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dst_state, const XXH32_state_t* src_state);
 
-XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, unsigned int seed);
+XXH_PUBLIC_API XXH_errorcode XXH32_reset  (XXH32_state_t* statePtr, XXH32_hash_t seed);
 XXH_PUBLIC_API XXH_errorcode XXH32_update (XXH32_state_t* statePtr, const void* input, size_t length);
 XXH_PUBLIC_API XXH32_hash_t  XXH32_digest (const XXH32_state_t* statePtr);
 
-/*
-These functions generate the xxHash of an input provided in multiple segments.
-Note that, for small input, they are slower than single-call functions, due to state management.
-For small input, prefer `XXH32()` and `XXH64()` .
-
-XXH state must first be allocated, using XXH*_createState() .
+/*******   Canonical representation   *******/
 
-Start a new hash by initializing state with a seed, using XXH*_reset().
-
-Then, feed the hash state by calling XXH*_update() as many times as necessary.
-Obviously, input must be allocated and read accessible.
-The function returns an error code, with 0 meaning OK, and any other value meaning there is an error.
-
-Finally, a hash value can be produced anytime, by using XXH*_digest().
-This function returns the nn-bits hash as an int or long long.
-
-It's still possible to continue inserting input into the hash state after a digest,
-and generate some new hashes later on, by calling again XXH*_digest().
-
-When done, free XXH state space if it was allocated dynamically.
-*/
-
-/*======   Canonical representation   ======*/
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
+ * This the simplest and fastest format for further post-processing.
+ *
+ * However, this leaves open the question of what is the order on the byte level,
+ * since little and big endian conventions will store the same number differently.
+ *
+ * The canonical representation settles this issue by mandating big-endian
+ * convention, the same convention as human-readable numbers (large digits first).
+ *
+ * When writing hash values to storage, sending them over a network, or printing
+ * them, it's highly recommended to use the canonical representation to ensure
+ * portability across a wider range of systems, present and future.
+ *
+ * The following functions allow transformation of hash values to and from
+ * canonical format.
+ */
 
 typedef struct { unsigned char digest[4]; } XXH32_canonical_t;
 XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash);
 XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src);
 
-/* Default result type for XXH functions are primitive unsigned 32 and 64 bits.
-*  The canonical representation uses human-readable write convention, aka big-endian (large digits first).
-*  These functions allow transformation of hash result into and from its canonical format.
-*  This way, hash values can be written into a file / memory, and remain comparable on different systems and programs.
-*/
-
 
 #ifndef XXH_NO_LONG_LONG
 /*-**********************************************************************
-*  64-bits hash
+*  64-bit hash
 ************************************************************************/
-typedef unsigned long long XXH64_hash_t;
+#if !defined (__VMS) \
+  && (defined (__cplusplus) \
+  || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+#   include <stdint.h>
+    typedef uint64_t XXH64_hash_t;
+#else
+    /* the following type must have a width of 64-bit */
+    typedef unsigned long long XXH64_hash_t;
+#endif
 
-/*! XXH64() :
-    Calculate the 64-bits hash of sequence of length "len" stored at memory address "input".
-    "seed" can be used to alter the result predictably.
-    This function runs faster on 64-bits systems, but slower on 32-bits systems (see benchmark).
-*/
-XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t length, unsigned long long seed);
+/*!
+ * XXH64():
+ * Returns the 64-bit hash of sequence of length @length stored at memory
+ * address @input.
+ * @seed can be used to alter the result predictably.
+ * This function usually runs faster on 64-bit systems, but slower on 32-bit
+ * systems (see benchmark).
+ */
+XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t length, XXH64_hash_t seed);
 
-/*======   Streaming   ======*/
+/*******   Streaming   *******/
 typedef struct XXH64_state_s XXH64_state_t;   /* incomplete type */
 XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void);
 XXH_PUBLIC_API XXH_errorcode  XXH64_freeState(XXH64_state_t* statePtr);
 XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dst_state, const XXH64_state_t* src_state);
 
-XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, unsigned long long seed);
+XXH_PUBLIC_API XXH_errorcode XXH64_reset  (XXH64_state_t* statePtr, XXH64_hash_t seed);
 XXH_PUBLIC_API XXH_errorcode XXH64_update (XXH64_state_t* statePtr, const void* input, size_t length);
 XXH_PUBLIC_API XXH64_hash_t  XXH64_digest (const XXH64_state_t* statePtr);
 
-/*======   Canonical representation   ======*/
+/*******   Canonical representation   *******/
 typedef struct { unsigned char digest[8]; } XXH64_canonical_t;
 XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash);
 XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src);
+
+
 #endif  /* XXH_NO_LONG_LONG */
 
+#endif /* XXHASH_H_5627135585666179 */
+
 
-#ifdef XXH_STATIC_LINKING_ONLY
 
-/* ================================================================================================
-   This section contains definitions which are not guaranteed to remain stable.
-   They may change in future versions, becoming incompatible with a different version of the library.
-   They shall only be used with static linking.
-   Never use these definitions in association with dynamic linking !
-=================================================================================================== */
+#if defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742)
+#define XXHASH_H_STATIC_13879238742
+/* ****************************************************************************
+ * This section contains declarations which are not guaranteed to remain stable.
+ * They may change in future versions, becoming incompatible with a different
+ * version of the library.
+ * These declarations should only be used with static linking.
+ * Never use them in association with dynamic linking!
+ ***************************************************************************** */
 
-/* These definitions are only meant to make possible
-   static allocation of XXH state, on stack or in a struct for example.
-   Never use members directly. */
+/*
+ * These definitions are only present to allow static allocation of an XXH
+ * state, for example, on the stack or in a struct.
+ * Never **ever** access members directly.
+ */
 
 struct XXH32_state_s {
-   unsigned total_len_32;
-   unsigned large_len;
-   unsigned v1;
-   unsigned v2;
-   unsigned v3;
-   unsigned v4;
-   unsigned mem32[4];   /* buffer defined as U32 for alignment */
-   unsigned memsize;
-   unsigned reserved;   /* never read nor write, will be removed in a future version */
+   XXH32_hash_t total_len_32;
+   XXH32_hash_t large_len;
+   XXH32_hash_t v1;
+   XXH32_hash_t v2;
+   XXH32_hash_t v3;
+   XXH32_hash_t v4;
+   XXH32_hash_t mem32[4];
+   XXH32_hash_t memsize;
+   XXH32_hash_t reserved;   /* never read nor write, might be removed in a future version */
 };   /* typedef'd to XXH32_state_t */
 
-#ifndef XXH_NO_LONG_LONG   /* remove 64-bits support */
+
+#ifndef XXH_NO_LONG_LONG  /* defined when there is no 64-bit support */
+
 struct XXH64_state_s {
-   unsigned long long total_len;
-   unsigned long long v1;
-   unsigned long long v2;
-   unsigned long long v3;
-   unsigned long long v4;
-   unsigned long long mem64[4];   /* buffer defined as U64 for alignment */
-   unsigned memsize;
-   unsigned reserved[2];          /* never read nor write, will be removed in a future version */
+   XXH64_hash_t total_len;
+   XXH64_hash_t v1;
+   XXH64_hash_t v2;
+   XXH64_hash_t v3;
+   XXH64_hash_t v4;
+   XXH64_hash_t mem64[4];
+   XXH32_hash_t memsize;
+   XXH32_hash_t reserved32;  /* required for padding anyway */
+   XXH64_hash_t reserved64;  /* never read nor write, might be removed in a future version */
 };   /* typedef'd to XXH64_state_t */
+
+
+/*-**********************************************************************
+*  XXH3
+*  New experimental hash
+************************************************************************/
+
+/* ************************************************************************
+ * XXH3 is a new hash algorithm featuring:
+ *  - Improved speed for both small and large inputs
+ *  - True 64-bit and 128-bit outputs
+ *  - SIMD acceleration
+ *  - Improved 32-bit viability
+ *
+ * Speed analysis methodology is explained here:
+ *
+ *    https://fastcompression.blogspot.com/2019/03/presenting-xxh3.html
+ *
+ * In general, expect XXH3 to run about ~2x faster on large inputs and >3x
+ * faster on small ones compared to XXH64, though exact differences depend on
+ * the platform.
+ *
+ * The algorithm is portable: Like XXH32 and XXH64, it generates the same hash
+ * on all platforms.
+ *
+ * It benefits greatly from SIMD and 64-bit arithmetic, but does not require it.
+ *
+ * Almost all 32-bit and 64-bit targets that can run XXH32 smoothly can run
+ * XXH3 at usable speeds, even if XXH64 runs slowly. Further details are
+ * explained in the implementation.
+ *
+ * Optimized implementations are provided for AVX2, SSE2, NEON, POWER8, ZVector,
+ * and scalar targets. This can be controlled with the XXH_VECTOR macro.
+ *
+ * XXH3 offers 2 variants, _64bits and _128bits.
+ * When only 64 bits are needed, prefer calling the _64bits variant, as it
+ * reduces the amount of mixing, resulting in faster speed on small inputs.
+ *
+ * It's also generally simpler to manipulate a scalar return type than a struct.
+ *
+ * The 128-bit version adds additional strength, but it is slightly slower.
+ *
+ * The XXH3 algorithm is still in development.
+ * The results it produces may still change in future versions.
+ *
+ * Results produced by v0.7.x are not comparable with results from v0.7.y.
+ * However, the API is completely stable, and it can safely be used for
+ * ephemeral data (local sessions).
+ *
+ * Avoid storing values in long-term storage until the algorithm is finalized.
+ *
+ * The API supports one-shot hashing, streaming mode, and custom secrets.
+ */
+
+#ifdef XXH_NAMESPACE
+#  define XXH3_64bits XXH_NAME2(XXH_NAMESPACE, XXH3_64bits)
+#  define XXH3_64bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSecret)
+#  define XXH3_64bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_withSeed)
+
+#  define XXH3_createState XXH_NAME2(XXH_NAMESPACE, XXH3_createState)
+#  define XXH3_freeState XXH_NAME2(XXH_NAMESPACE, XXH3_freeState)
+#  define XXH3_copyState XXH_NAME2(XXH_NAMESPACE, XXH3_copyState)
+
+#  define XXH3_64bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset)
+#  define XXH3_64bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSeed)
+#  define XXH3_64bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_reset_withSecret)
+#  define XXH3_64bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_update)
+#  define XXH3_64bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_64bits_digest)
 #endif
 
-#ifdef XXH_PRIVATE_API
-#  include "xxhash.c"   /* include xxhash function bodies as `static`, for inlining */
+/* XXH3_64bits():
+ * default 64-bit variant, using default secret and default seed of 0.
+ * It's the fastest variant. */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits(const void* data, size_t len);
+
+/*
+ * XXH3_64bits_withSecret():
+ * It's possible to provide any blob of bytes as a "secret" to generate the hash.
+ * This makes it more difficult for an external actor to prepare an intentional
+ * collision.
+ * The secret *must* be large enough (>= XXH3_SECRET_SIZE_MIN).
+ * It should consist of random bytes.
+ * Avoid trivial sequences, such as repeating sequences and especially '\0',
+ * as this can cancel out itself.
+ * Failure to respect these conditions will result in a poor quality hash.
+ */
+#define XXH3_SECRET_SIZE_MIN 136
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
+
+/*
+ * XXH3_64bits_withSeed():
+ * This variant generates a custom secret on the fly based on the default
+ * secret, altered using the `seed` value.
+ * While this operation is decently fast, note that it's not completely free.
+ * Note: seed==0 produces the same results as XXH3_64bits().
+ */
+XXH_PUBLIC_API XXH64_hash_t XXH3_64bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);
+
+
+/* streaming 64-bit */
+
+#if defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L)   /* C11+ */
+#  include <stdalign.h>
+#  define XXH_ALIGN(n)      alignas(n)
+#elif defined(__GNUC__)
+#  define XXH_ALIGN(n)      __attribute__ ((aligned(n)))
+#elif defined(_MSC_VER)
+#  define XXH_ALIGN(n)      __declspec(align(n))
+#else
+#  define XXH_ALIGN(n)   /* disabled */
+#endif
+
+/* Old GCC versions only accept the attribute after the type in structures. */
+#if !(defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 201112L))   /* C11+ */ \
+    && defined(__GNUC__)
+#   define XXH_ALIGN_MEMBER(align, type) type XXH_ALIGN(align)
+#else
+#   define XXH_ALIGN_MEMBER(align, type) XXH_ALIGN(align) type
 #endif
 
-#endif /* XXH_STATIC_LINKING_ONLY */
+typedef struct XXH3_state_s XXH3_state_t;
 
+#define XXH3_SECRET_DEFAULT_SIZE 192   /* minimum XXH3_SECRET_SIZE_MIN */
+#define XXH3_INTERNALBUFFER_SIZE 256
+struct XXH3_state_s {
+   XXH_ALIGN_MEMBER(64, XXH64_hash_t acc[8]);
+  /* used to store a custom secret generated from the seed. Makes state larger.
+   * Design might change */
+   XXH_ALIGN_MEMBER(64, unsigned char customSecret[XXH3_SECRET_DEFAULT_SIZE]);
+   XXH_ALIGN_MEMBER(64, unsigned char buffer[XXH3_INTERNALBUFFER_SIZE]);
+   XXH32_hash_t bufferedSize;
+   XXH32_hash_t nbStripesPerBlock;
+   XXH32_hash_t nbStripesSoFar;
+   XXH32_hash_t secretLimit;
+   XXH32_hash_t reserved32;
+   XXH32_hash_t reserved32_2;
+   XXH64_hash_t totalLen;
+   XXH64_hash_t seed;
+   XXH64_hash_t reserved64;
+   /* note: there is some padding after due to alignment on 64 bytes */
+   const unsigned char* secret;
+};   /* typedef'd to XXH3_state_t */
 
-#if defined (__cplusplus)
+#undef XXH_ALIGN_MEMBER
+
+/*
+ * Streaming requires state maintenance.
+ * This operation costs memory and CPU.
+ * As a consequence, streaming is slower than one-shot hashing.
+ * For better performance, prefer one-shot functions whenever possible.
+ */
+XXH_PUBLIC_API XXH3_state_t* XXH3_createState(void);
+XXH_PUBLIC_API XXH_errorcode XXH3_freeState(XXH3_state_t* statePtr);
+XXH_PUBLIC_API void XXH3_copyState(XXH3_state_t* dst_state, const XXH3_state_t* src_state);
+
+
+/*
+ * XXH3_64bits_reset():
+ * Initialize with the default parameters.
+ * The result will be equivalent to `XXH3_64bits()`.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset(XXH3_state_t* statePtr);
+/*
+ * XXH3_64bits_reset_withSeed():
+ * Generate a custom secret from `seed`, and store it into `statePtr`.
+ * digest will be equivalent to `XXH3_64bits_withSeed()`.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
+/*
+ * XXH3_64bits_reset_withSecret():
+ * `secret` is referenced, and must outlive the hash streaming session, so
+ * be careful when using stack arrays.
+ * `secretSize` must be >= `XXH3_SECRET_SIZE_MIN`.
+ */
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
+
+XXH_PUBLIC_API XXH_errorcode XXH3_64bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
+XXH_PUBLIC_API XXH64_hash_t  XXH3_64bits_digest (const XXH3_state_t* statePtr);
+
+
+/* 128-bit */
+
+#ifdef XXH_NAMESPACE
+#  define XXH128 XXH_NAME2(XXH_NAMESPACE, XXH128)
+#  define XXH3_128bits XXH_NAME2(XXH_NAMESPACE, XXH3_128bits)
+#  define XXH3_128bits_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSeed)
+#  define XXH3_128bits_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_withSecret)
+
+#  define XXH3_128bits_reset XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset)
+#  define XXH3_128bits_reset_withSeed XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSeed)
+#  define XXH3_128bits_reset_withSecret XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_reset_withSecret)
+#  define XXH3_128bits_update XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_update)
+#  define XXH3_128bits_digest XXH_NAME2(XXH_NAMESPACE, XXH3_128bits_digest)
+
+#  define XXH128_isEqual XXH_NAME2(XXH_NAMESPACE, XXH128_isEqual)
+#  define XXH128_cmp     XXH_NAME2(XXH_NAMESPACE, XXH128_cmp)
+#  define XXH128_canonicalFromHash XXH_NAME2(XXH_NAMESPACE, XXH128_canonicalFromHash)
+#  define XXH128_hashFromCanonical XXH_NAME2(XXH_NAMESPACE, XXH128_hashFromCanonical)
+#endif
+
+typedef struct {
+    XXH64_hash_t low64;
+    XXH64_hash_t high64;
+} XXH128_hash_t;
+
+XXH_PUBLIC_API XXH128_hash_t XXH128(const void* data, size_t len, XXH64_hash_t seed);
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits(const void* data, size_t len);
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSeed(const void* data, size_t len, XXH64_hash_t seed);  /* == XXH128() */
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_withSecret(const void* data, size_t len, const void* secret, size_t secretSize);
+
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset(XXH3_state_t* statePtr);
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSeed(XXH3_state_t* statePtr, XXH64_hash_t seed);
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_reset_withSecret(XXH3_state_t* statePtr, const void* secret, size_t secretSize);
+
+XXH_PUBLIC_API XXH_errorcode XXH3_128bits_update (XXH3_state_t* statePtr, const void* input, size_t length);
+XXH_PUBLIC_API XXH128_hash_t XXH3_128bits_digest (const XXH3_state_t* statePtr);
+
+
+/* Note: For better performance, these functions can be inlined using XXH_INLINE_ALL */
+
+/*!
+ * XXH128_isEqual():
+ * Return: 1 if `h1` and `h2` are equal, 0 if they are not.
+ */
+XXH_PUBLIC_API int XXH128_isEqual(XXH128_hash_t h1, XXH128_hash_t h2);
+
+/*!
+ * XXH128_cmp():
+ *
+ * This comparator is compatible with stdlib's `qsort()`/`bsearch()`.
+ *
+ * return: >0 if *h128_1  > *h128_2
+ *         <0 if *h128_1  < *h128_2
+ *         =0 if *h128_1 == *h128_2
+ */
+XXH_PUBLIC_API int XXH128_cmp(const void* h128_1, const void* h128_2);
+
+
+/*******   Canonical representation   *******/
+typedef struct { unsigned char digest[16]; } XXH128_canonical_t;
+XXH_PUBLIC_API void XXH128_canonicalFromHash(XXH128_canonical_t* dst, XXH128_hash_t hash);
+XXH_PUBLIC_API XXH128_hash_t XXH128_hashFromCanonical(const XXH128_canonical_t* src);
+
+
+#endif  /* XXH_NO_LONG_LONG */
+
+#if defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API)
+#  define XXH_IMPLEMENTATION
+#endif
+
+#endif  /* defined(XXH_STATIC_LINKING_ONLY) && !defined(XXHASH_H_STATIC_13879238742) */
+
+
+/* ======================================================================== */
+/* ======================================================================== */
+/* ======================================================================== */
+
+
+/*-**********************************************************************
+ * xxHash implementation
+ *-**********************************************************************
+ * xxHash's implementation used to be found in xxhash.c.
+ *
+ * However, code inlining requires the implementation to be visible to the
+ * compiler, usually within the header.
+ *
+ * As a workaround, xxhash.c used to be included within xxhash.h. This caused
+ * some issues with some build systems, especially ones which treat .c files
+ * as source files.
+ *
+ * Therefore, the implementation is now directly integrated within xxhash.h.
+ * Another small advantage is that xxhash.c is no longer needed in /include.
+ ************************************************************************/
+
+#if ( defined(XXH_INLINE_ALL) || defined(XXH_PRIVATE_API) \
+   || defined(XXH_IMPLEMENTATION) ) && !defined(XXH_IMPLEM_13a8737387)
+#  define XXH_IMPLEM_13a8737387
+
+/* *************************************
+*  Tuning parameters
+***************************************/
+/*!
+ * XXH_FORCE_MEMORY_ACCESS:
+ * By default, access to unaligned memory is controlled by `memcpy()`, which is
+ * safe and portable.
+ *
+ * Unfortunately, on some target/compiler combinations, the generated assembly
+ * is sub-optimal.
+ *
+ * The below switch allow to select a different access method for improved
+ * performance.
+ * Method 0 (default):
+ *     Use `memcpy()`. Safe and portable.
+ * Method 1:
+ *     `__attribute__((packed))` statement. It depends on compiler extensions
+ *     and is therefore not portable.
+ *     This method is safe if your compiler supports it, and *generally* as
+ *     fast or faster than `memcpy`.
+ * Method 2:
+ *     Direct access via cast. This method doesn't depend on the compiler but
+ *     violates the C standard.
+ *     It can generate buggy code on targets which do not support unaligned
+ *     memory accesses.
+ *     But in some circumstances, it's the only known way to get the most
+ *     performance (ie GCC + ARMv6)
+ * Method 3:
+ *     Byteshift. This can generate the best code on old compilers which don't
+ *     inline small `memcpy()` calls, and it might also be faster on big-endian
+ *     systems which lack a native byteswap instruction.
+ * See https://stackoverflow.com/a/32095106/646947 for details.
+ * Prefer these methods in priority order (0 > 1 > 2 > 3)
+ */
+#ifndef XXH_FORCE_MEMORY_ACCESS   /* can be defined externally, on command line for example */
+#  if !defined(__clang__) && defined(__GNUC__) && defined(__ARM_FEATURE_UNALIGNED) && defined(__ARM_ARCH) && (__ARM_ARCH == 6)
+#    define XXH_FORCE_MEMORY_ACCESS 2
+#  elif !defined(__clang__) && ((defined(__INTEL_COMPILER) && !defined(_WIN32)) || \
+  (defined(__GNUC__) && (defined(__ARM_ARCH) && __ARM_ARCH >= 7)))
+#    define XXH_FORCE_MEMORY_ACCESS 1
+#  endif
+#endif
+
+/*!
+ *XXH_ACCEPT_NULL_INPUT_POINTER:
+ * If the input pointer is NULL, xxHash's default behavior is to dereference it,
+ * triggering a segfault.
+ * When this macro is enabled, xxHash actively checks the input for a null pointer.
+ * If it is, the result for null input pointers is the same as a zero-length input.
+ */
+#ifndef XXH_ACCEPT_NULL_INPUT_POINTER   /* can be defined externally */
+#  define XXH_ACCEPT_NULL_INPUT_POINTER 0
+#endif
+
+/*!
+ * XXH_FORCE_ALIGN_CHECK:
+ * This is a minor performance trick, only useful with lots of very small keys.
+ * It means: check for aligned/unaligned input.
+ * The check costs one initial branch per hash;
+ * Set it to 0 when the input is guaranteed to be aligned or when alignment
+ * doesn't matter for performance.
+ *
+ * This option does not affect XXH3.
+ */
+#ifndef XXH_FORCE_ALIGN_CHECK /* can be defined externally */
+#  if defined(__i386) || defined(_M_IX86) || defined(__x86_64__) || defined(_M_X64)
+#    define XXH_FORCE_ALIGN_CHECK 0
+#  else
+#    define XXH_FORCE_ALIGN_CHECK 1
+#  endif
+#endif
+
+/*!
+ * XXH_NO_INLINE_HINTS:
+ *
+ * By default, xxHash tries to force the compiler to inline almost all internal
+ * functions.
+ *
+ * This can usually improve performance due to reduced jumping and improved
+ * constant folding, but significantly increases the size of the binary which
+ * might not be favorable.
+ *
+ * Additionally, sometimes the forced inlining can be detrimental to performance,
+ * depending on the architecture.
+ *
+ * XXH_NO_INLINE_HINTS marks all internal functions as static, giving the
+ * compiler full control on whether to inline or not.
+ *
+ * When not optimizing (-O0), optimizing for size (-Os, -Oz), or using
+ * -fno-inline with GCC or Clang, this will automatically be defined.
+ */
+#ifndef XXH_NO_INLINE_HINTS
+#  if defined(__OPTIMIZE_SIZE__) /* -Os, -Oz */ \
+   || defined(__NO_INLINE__)     /* -O0, -fno-inline */
+#    define XXH_NO_INLINE_HINTS 1
+#  else
+#    define XXH_NO_INLINE_HINTS 0
+#  endif
+#endif
+
+/*!
+ * XXH_REROLL:
+ * Whether to reroll XXH32_finalize, and XXH64_finalize,
+ * instead of using an unrolled jump table/if statement loop.
+ *
+ * This is automatically defined on -Os/-Oz on GCC and Clang.
+ */
+#ifndef XXH_REROLL
+#  if defined(__OPTIMIZE_SIZE__)
+#    define XXH_REROLL 1
+#  else
+#    define XXH_REROLL 0
+#  endif
+#endif
+
+
+/* *************************************
+*  Includes & Memory related functions
+***************************************/
+/*!
+ * Modify the local functions below should you wish to use some other memory
+ * routines for malloc() and free()
+ */
+#include <stdlib.h>
+static void* XXH_malloc(size_t s) { return malloc(s); }
+static void  XXH_free  (void* p)  { free(p); }
+/*! and for memcpy() */
+#include <string.h>
+static void* XXH_memcpy(void* dest, const void* src, size_t size)
+{
+    return memcpy(dest,src,size);
 }
+
+#include <limits.h>   /* ULLONG_MAX */
+
+
+/* *************************************
+*  Compiler Specific Options
+***************************************/
+#ifdef _MSC_VER /* Visual Studio warning fix */
+#  pragma warning(disable : 4127) /* disable: C4127: conditional expression is constant */
 #endif
 
-#endif /* XXHASH_H_5627135585666179 */
+#if XXH_NO_INLINE_HINTS /* disable inlining hints */
+#  define XXH_FORCE_INLINE static
+#  define XXH_NO_INLINE static
+#elif defined(_MSC_VER)    /* Visual Studio */
+#  define XXH_FORCE_INLINE static __forceinline
+#  define XXH_NO_INLINE static __declspec(noinline)
+#else
+#  if defined (__cplusplus) \
+    || defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L   /* C99 */
+#    ifdef __GNUC__
+#      define XXH_FORCE_INLINE static inline __attribute__((always_inline))
+#      define XXH_NO_INLINE static __attribute__((noinline))
+#    else
+#      define XXH_FORCE_INLINE static inline
+#      define XXH_NO_INLINE static
+#    endif
+#  else
+#    define XXH_FORCE_INLINE static
+#    define XXH_NO_INLINE static
+#  endif /* __STDC_VERSION__ */
+#endif
+
+
+
+/* *************************************
+*  Debug
+***************************************/
+/*
+ * DEBUGLEVEL is expected to be defined externally, typically via the compiler's
+ * command line options. The value must be a number.
+ */
+#ifndef DEBUGLEVEL
+#  define DEBUGLEVEL 0
+#endif
+
+#if (DEBUGLEVEL>=1)
+#  include <assert.h>   /* note: can still be disabled with NDEBUG */
+#  define XXH_ASSERT(c)   assert(c)
+#else
+#  define XXH_ASSERT(c)   ((void)0)
+#endif
+
+/* note: use after variable declarations */
+#define XXH_STATIC_ASSERT(c)  { enum { XXH_sa = 1/(int)(!!(c)) }; }
+
+
+/* *************************************
+*  Basic Types
+***************************************/
+#if !defined (__VMS) \
+ && (defined (__cplusplus) \
+ || (defined (__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L) /* C99 */) )
+# include <stdint.h>
+  typedef uint8_t  xxh_u8;
+#else
+  typedef unsigned char      xxh_u8;
+#endif
+typedef XXH32_hash_t xxh_u32;
+
+
+/* ***   Memory access   *** */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE32 and XXH_readBE32.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/*
+ * Force direct memory access. Only works on CPU which support unaligned memory
+ * access in hardware.
+ */
+static xxh_u32 XXH_read32(const void* memPtr) { return *(const xxh_u32*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+typedef union { xxh_u32 u32; } __attribute__((packed)) unalign;
+static xxh_u32 XXH_read32(const void* ptr) { return ((const unalign*)ptr)->u32; }
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://stackoverflow.com/a/32095106/646947
+ */
+static xxh_u32 XXH_read32(const void* memPtr)
+{
+    xxh_u32 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+
+/* ***   Endianess   *** */
+typedef enum { XXH_bigEndian=0, XXH_littleEndian=1 } XXH_endianess;
+
+/*!
+ * XXH_CPU_LITTLE_ENDIAN:
+ * Defined to 1 if the target is little endian, or 0 if it is big endian.
+ * It can be defined externally, for example on the compiler command line.
+ *
+ * If it is not defined, a runtime check (which is usually constant folded)
+ * is used instead.
+ */
+#ifndef XXH_CPU_LITTLE_ENDIAN
+/*
+ * Try to detect endianness automatically, to avoid the nonstandard behavior
+ * in `XXH_isLittleEndian()`
+ */
+#  if defined(_WIN32) /* Windows is always little endian */ \
+     || defined(__LITTLE_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 1
+#  elif defined(__BIG_ENDIAN__) \
+     || (defined(__BYTE_ORDER__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__)
+#    define XXH_CPU_LITTLE_ENDIAN 0
+#  else
+static int XXH_isLittleEndian(void)
+{
+    /*
+     * Nonstandard, but well-defined behavior in practice.
+     * Don't use static: it is detrimental to performance.
+     */
+    const union { xxh_u32 u; xxh_u8 c[4]; } one = { 1 };
+    return one.c[0];
+}
+#   define XXH_CPU_LITTLE_ENDIAN   XXH_isLittleEndian()
+#  endif
+#endif
+
+
+
+
+/* ****************************************
+*  Compiler-specific Functions and Macros
+******************************************/
+#define XXH_GCC_VERSION (__GNUC__ * 100 + __GNUC_MINOR__)
+
+#ifndef __has_builtin
+#  define __has_builtin(x) 0
+#endif
+
+#if !defined(NO_CLANG_BUILTIN) && __has_builtin(__builtin_rotateleft32) \
+                               && __has_builtin(__builtin_rotateleft64)
+#  define XXH_rotl32 __builtin_rotateleft32
+#  define XXH_rotl64 __builtin_rotateleft64
+/* Note: although _rotl exists for minGW (GCC under windows), performance seems poor */
+#elif defined(_MSC_VER)
+#  define XXH_rotl32(x,r) _rotl(x,r)
+#  define XXH_rotl64(x,r) _rotl64(x,r)
+#else
+#  define XXH_rotl32(x,r) (((x) << (r)) | ((x) >> (32 - (r))))
+#  define XXH_rotl64(x,r) (((x) << (r)) | ((x) >> (64 - (r))))
+#endif
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap32 _byteswap_ulong
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap32 __builtin_bswap32
+#else
+static xxh_u32 XXH_swap32 (xxh_u32 x)
+{
+    return  ((x << 24) & 0xff000000 ) |
+            ((x <<  8) & 0x00ff0000 ) |
+            ((x >>  8) & 0x0000ff00 ) |
+            ((x >> 24) & 0x000000ff );
+}
+#endif
+
+
+/* ***************************
+*  Memory reads
+*****************************/
+typedef enum { XXH_aligned, XXH_unaligned } XXH_alignment;
+
+/*
+ * XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load.
+ *
+ * This is ideal for older compilers which don't inline memcpy.
+ */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u32)bytePtr[1] << 8)
+         | ((xxh_u32)bytePtr[2] << 16)
+         | ((xxh_u32)bytePtr[3] << 24);
+}
+
+XXH_FORCE_INLINE xxh_u32 XXH_readBE32(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[3]
+         | ((xxh_u32)bytePtr[2] << 8)
+         | ((xxh_u32)bytePtr[1] << 16)
+         | ((xxh_u32)bytePtr[0] << 24);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u32 XXH_readLE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read32(ptr) : XXH_swap32(XXH_read32(ptr));
+}
+
+static xxh_u32 XXH_readBE32(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap32(XXH_read32(ptr)) : XXH_read32(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u32
+XXH_readLE32_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned) {
+        return XXH_readLE32(ptr);
+    } else {
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u32*)ptr : XXH_swap32(*(const xxh_u32*)ptr);
+    }
+}
+
+
+/* *************************************
+*  Misc
+***************************************/
+XXH_PUBLIC_API unsigned XXH_versionNumber (void) { return XXH_VERSION_NUMBER; }
+
+
+/* *******************************************************************
+*  32-bit hash functions
+*********************************************************************/
+static const xxh_u32 PRIME32_1 = 0x9E3779B1U;   /* 0b10011110001101110111100110110001 */
+static const xxh_u32 PRIME32_2 = 0x85EBCA77U;   /* 0b10000101111010111100101001110111 */
+static const xxh_u32 PRIME32_3 = 0xC2B2AE3DU;   /* 0b11000010101100101010111000111101 */
+static const xxh_u32 PRIME32_4 = 0x27D4EB2FU;   /* 0b00100111110101001110101100101111 */
+static const xxh_u32 PRIME32_5 = 0x165667B1U;   /* 0b00010110010101100110011110110001 */
+
+static xxh_u32 XXH32_round(xxh_u32 acc, xxh_u32 input)
+{
+    acc += input * PRIME32_2;
+    acc  = XXH_rotl32(acc, 13);
+    acc *= PRIME32_1;
+#if defined(__GNUC__) && defined(__SSE4_1__) && !defined(XXH_ENABLE_AUTOVECTORIZE)
+    /*
+     * UGLY HACK:
+     * This inline assembly hack forces acc into a normal register. This is the
+     * only thing that prevents GCC and Clang from autovectorizing the XXH32
+     * loop (pragmas and attributes don't work for some resason) without globally
+     * disabling SSE4.1.
+     *
+     * The reason we want to avoid vectorization is because despite working on
+     * 4 integers at a time, there are multiple factors slowing XXH32 down on
+     * SSE4:
+     * - There's a ridiculous amount of lag from pmulld (10 cycles of latency on
+     *   newer chips!) making it slightly slower to multiply four integers at
+     *   once compared to four integers independently. Even when pmulld was
+     *   fastest, Sandy/Ivy Bridge, it is still not worth it to go into SSE
+     *   just to multiply unless doing a long operation.
+     *
+     * - Four instructions are required to rotate,
+     *      movqda tmp,  v // not required with VEX encoding
+     *      pslld  tmp, 13 // tmp <<= 13
+     *      psrld  v,   19 // x >>= 19
+     *      por    v,  tmp // x |= tmp
+     *   compared to one for scalar:
+     *      roll   v, 13    // reliably fast across the board
+     *      shldl  v, v, 13 // Sandy Bridge and later prefer this for some reason
+     *
+     * - Instruction level parallelism is actually more beneficial here because
+     *   the SIMD actually serializes this operation: While v1 is rotating, v2
+     *   can load data, while v3 can multiply. SSE forces them to operate
+     *   together.
+     *
+     * How this hack works:
+     * __asm__(""       // Declare an assembly block but don't declare any instructions
+     *          :       // However, as an Input/Output Operand,
+     *          "+r"    // constrain a read/write operand (+) as a general purpose register (r).
+     *          (acc)   // and set acc as the operand
+     * );
+     *
+     * Because of the 'r', the compiler has promised that seed will be in a
+     * general purpose register and the '+' says that it will be 'read/write',
+     * so it has to assume it has changed. It is like volatile without all the
+     * loads and stores.
+     *
+     * Since the argument has to be in a normal register (not an SSE register),
+     * each time XXH32_round is called, it is impossible to vectorize.
+     */
+    __asm__("" : "+r" (acc));
+#endif
+    return acc;
+}
+
+/* mix all bits */
+static xxh_u32 XXH32_avalanche(xxh_u32 h32)
+{
+    h32 ^= h32 >> 15;
+    h32 *= PRIME32_2;
+    h32 ^= h32 >> 13;
+    h32 *= PRIME32_3;
+    h32 ^= h32 >> 16;
+    return(h32);
+}
+
+#define XXH_get32bits(p) XXH_readLE32_align(p, align)
+
+static xxh_u32
+XXH32_finalize(xxh_u32 h32, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define PROCESS1               \
+    h32 += (*ptr++) * PRIME32_5; \
+    h32 = XXH_rotl32(h32, 11) * PRIME32_1 ;
+
+#define PROCESS4                         \
+    h32 += XXH_get32bits(ptr) * PRIME32_3; \
+    ptr+=4;                                \
+    h32  = XXH_rotl32(h32, 17) * PRIME32_4 ;
+
+    /* Compact rerolled version */
+    if (XXH_REROLL) {
+        len &= 15;
+        while (len >= 4) {
+            PROCESS4;
+            len -= 4;
+        }
+        while (len > 0) {
+            PROCESS1;
+            --len;
+        }
+        return XXH32_avalanche(h32);
+    } else {
+         switch(len&15) /* or switch(bEnd - p) */ {
+           case 12:      PROCESS4;
+                         /* fallthrough */
+           case 8:       PROCESS4;
+                         /* fallthrough */
+           case 4:       PROCESS4;
+                         return XXH32_avalanche(h32);
+
+           case 13:      PROCESS4;
+                         /* fallthrough */
+           case 9:       PROCESS4;
+                         /* fallthrough */
+           case 5:       PROCESS4;
+                         PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 14:      PROCESS4;
+                         /* fallthrough */
+           case 10:      PROCESS4;
+                         /* fallthrough */
+           case 6:       PROCESS4;
+                         PROCESS1;
+                         PROCESS1;
+                         return XXH32_avalanche(h32);
+
+           case 15:      PROCESS4;
+                         /* fallthrough */
+           case 11:      PROCESS4;
+                         /* fallthrough */
+           case 7:       PROCESS4;
+                         /* fallthrough */
+           case 3:       PROCESS1;
+                         /* fallthrough */
+           case 2:       PROCESS1;
+                         /* fallthrough */
+           case 1:       PROCESS1;
+                         /* fallthrough */
+           case 0:       return XXH32_avalanche(h32);
+        }
+        XXH_ASSERT(0);
+        return h32;   /* reaching this point is deemed impossible */
+    }
+}
+
+XXH_FORCE_INLINE xxh_u32
+XXH32_endian_align(const xxh_u8* input, size_t len, xxh_u32 seed, XXH_alignment align)
+{
+    const xxh_u8* bEnd = input + len;
+    xxh_u32 h32;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (input==NULL) {
+        len=0;
+        bEnd=input=(const xxh_u8*)(size_t)16;
+    }
+#endif
+
+    if (len>=16) {
+        const xxh_u8* const limit = bEnd - 15;
+        xxh_u32 v1 = seed + PRIME32_1 + PRIME32_2;
+        xxh_u32 v2 = seed + PRIME32_2;
+        xxh_u32 v3 = seed + 0;
+        xxh_u32 v4 = seed - PRIME32_1;
+
+        do {
+            v1 = XXH32_round(v1, XXH_get32bits(input)); input += 4;
+            v2 = XXH32_round(v2, XXH_get32bits(input)); input += 4;
+            v3 = XXH32_round(v3, XXH_get32bits(input)); input += 4;
+            v4 = XXH32_round(v4, XXH_get32bits(input)); input += 4;
+        } while (input < limit);
+
+        h32 = XXH_rotl32(v1, 1)  + XXH_rotl32(v2, 7)
+            + XXH_rotl32(v3, 12) + XXH_rotl32(v4, 18);
+    } else {
+        h32  = seed + PRIME32_5;
+    }
+
+    h32 += (xxh_u32)len;
+
+    return XXH32_finalize(h32, input, len&15, align);
+}
+
+
+XXH_PUBLIC_API XXH32_hash_t XXH32 (const void* input, size_t len, XXH32_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH32_state_t state;
+    XXH32_reset(&state, seed);
+    XXH32_update(&state, (const xxh_u8*)input, len);
+    return XXH32_digest(&state);
+
+#else
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 3) == 0) {   /* Input is 4-bytes aligned, leverage the speed benefit */
+            return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH32_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+#endif
+}
+
+
+
+/*******   Hash streaming   *******/
+
+XXH_PUBLIC_API XXH32_state_t* XXH32_createState(void)
+{
+    return (XXH32_state_t*)XXH_malloc(sizeof(XXH32_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH32_freeState(XXH32_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH32_copyState(XXH32_state_t* dstState, const XXH32_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH32_reset(XXH32_state_t* statePtr, XXH32_hash_t seed)
+{
+    XXH32_state_t state;   /* using a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME32_1 + PRIME32_2;
+    state.v2 = seed + PRIME32_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME32_1;
+    /* do not write into reserved, planned to be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved));
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH_errorcode
+XXH32_update(XXH32_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len_32 += (XXH32_hash_t)len;
+        state->large_len |= (XXH32_hash_t)((len>=16) | (state->total_len_32>=16));
+
+        if (state->memsize + len < 16)  {   /* fill in tmp buffer */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, len);
+            state->memsize += (XXH32_hash_t)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* some data left from previous update */
+            XXH_memcpy((xxh_u8*)(state->mem32) + state->memsize, input, 16-state->memsize);
+            {   const xxh_u32* p32 = state->mem32;
+                state->v1 = XXH32_round(state->v1, XXH_readLE32(p32)); p32++;
+                state->v2 = XXH32_round(state->v2, XXH_readLE32(p32)); p32++;
+                state->v3 = XXH32_round(state->v3, XXH_readLE32(p32)); p32++;
+                state->v4 = XXH32_round(state->v4, XXH_readLE32(p32));
+            }
+            p += 16-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p <= bEnd-16) {
+            const xxh_u8* const limit = bEnd - 16;
+            xxh_u32 v1 = state->v1;
+            xxh_u32 v2 = state->v2;
+            xxh_u32 v3 = state->v3;
+            xxh_u32 v4 = state->v4;
+
+            do {
+                v1 = XXH32_round(v1, XXH_readLE32(p)); p+=4;
+                v2 = XXH32_round(v2, XXH_readLE32(p)); p+=4;
+                v3 = XXH32_round(v3, XXH_readLE32(p)); p+=4;
+                v4 = XXH32_round(v4, XXH_readLE32(p)); p+=4;
+            } while (p<=limit);
+
+            state->v1 = v1;
+            state->v2 = v2;
+            state->v3 = v3;
+            state->v4 = v4;
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem32, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_digest (const XXH32_state_t* state)
+{
+    xxh_u32 h32;
+
+    if (state->large_len) {
+        h32 = XXH_rotl32(state->v1, 1)
+            + XXH_rotl32(state->v2, 7)
+            + XXH_rotl32(state->v3, 12)
+            + XXH_rotl32(state->v4, 18);
+    } else {
+        h32 = state->v3 /* == seed */ + PRIME32_5;
+    }
+
+    h32 += state->total_len_32;
+
+    return XXH32_finalize(h32, (const xxh_u8*)state->mem32, state->memsize, XXH_aligned);
+}
+
+
+/*******   Canonical representation   *******/
+
+/*
+ * The default return values from XXH functions are unsigned 32 and 64 bit
+ * integers.
+ *
+ * The canonical representation uses big endian convention, the same convention
+ * as human-readable numbers (large digits first).
+ *
+ * This way, hash values can be written into a file or buffer, remaining
+ * comparable across different systems.
+ *
+ * The following functions allow transformation of hash values to and from their
+ * canonical format.
+ */
+XXH_PUBLIC_API void XXH32_canonicalFromHash(XXH32_canonical_t* dst, XXH32_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH32_canonical_t) == sizeof(XXH32_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap32(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH32_hash_t XXH32_hashFromCanonical(const XXH32_canonical_t* src)
+{
+    return XXH_readBE32(src);
+}
+
+
+#ifndef XXH_NO_LONG_LONG
+
+/* *******************************************************************
+*  64-bit hash functions
+*********************************************************************/
+
+/*******   Memory access   *******/
+
+typedef XXH64_hash_t xxh_u64;
+
+
+/*!
+ * XXH_REROLL_XXH64:
+ * Whether to reroll the XXH64_finalize() loop.
+ *
+ * Just like XXH32, we can unroll the XXH64_finalize() loop. This can be a
+ * performance gain on 64-bit hosts, as only one jump is required.
+ *
+ * However, on 32-bit hosts, because arithmetic needs to be done with two 32-bit
+ * registers, and 64-bit arithmetic needs to be simulated, it isn't beneficial
+ * to unroll. The code becomes ridiculously large (the largest function in the
+ * binary on i386!), and rerolling it saves anywhere from 3kB to 20kB. It is
+ * also slightly faster because it fits into cache better and is more likely
+ * to be inlined by the compiler.
+ *
+ * If XXH_REROLL is defined, this is ignored and the loop is always rerolled.
+ */
+#ifndef XXH_REROLL_XXH64
+#  if (defined(__ILP32__) || defined(_ILP32)) /* ILP32 is often defined on 32-bit GCC family */ \
+   || !(defined(__x86_64__) || defined(_M_X64) || defined(_M_AMD64) /* x86-64 */ \
+     || defined(_M_ARM64) || defined(__aarch64__) || defined(__arm64__) /* aarch64 */ \
+     || defined(__PPC64__) || defined(__PPC64LE__) || defined(__ppc64__) || defined(__powerpc64__) /* ppc64 */ \
+     || defined(__mips64__) || defined(__mips64)) /* mips64 */ \
+   || (!defined(SIZE_MAX) || SIZE_MAX < ULLONG_MAX) /* check limits */
+#    define XXH_REROLL_XXH64 1
+#  else
+#    define XXH_REROLL_XXH64 0
+#  endif
+#endif /* !defined(XXH_REROLL_XXH64) */
+
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+/*
+ * Manual byteshift. Best for old compilers which don't inline memcpy.
+ * We actually directly use XXH_readLE64 and XXH_readBE64.
+ */
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==2))
+
+/* Force direct memory access. Only works on CPU which support unaligned memory access in hardware */
+static xxh_u64 XXH_read64(const void* memPtr) { return *(const xxh_u64*) memPtr; }
+
+#elif (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==1))
+
+/*
+ * __pack instructions are safer, but compiler specific, hence potentially
+ * problematic for some compilers.
+ *
+ * Currently only defined for GCC and ICC.
+ */
+typedef union { xxh_u32 u32; xxh_u64 u64; } __attribute__((packed)) unalign64;
+static xxh_u64 XXH_read64(const void* ptr) { return ((const unalign64*)ptr)->u64; }
+
+#else
+
+/*
+ * Portable and safe solution. Generally efficient.
+ * see: https://stackoverflow.com/a/32095106/646947
+ */
+static xxh_u64 XXH_read64(const void* memPtr)
+{
+    xxh_u64 val;
+    memcpy(&val, memPtr, sizeof(val));
+    return val;
+}
+
+#endif   /* XXH_FORCE_DIRECT_MEMORY_ACCESS */
+
+#if defined(_MSC_VER)     /* Visual Studio */
+#  define XXH_swap64 _byteswap_uint64
+#elif XXH_GCC_VERSION >= 403
+#  define XXH_swap64 __builtin_bswap64
+#else
+static xxh_u64 XXH_swap64 (xxh_u64 x)
+{
+    return  ((x << 56) & 0xff00000000000000ULL) |
+            ((x << 40) & 0x00ff000000000000ULL) |
+            ((x << 24) & 0x0000ff0000000000ULL) |
+            ((x << 8)  & 0x000000ff00000000ULL) |
+            ((x >> 8)  & 0x00000000ff000000ULL) |
+            ((x >> 24) & 0x0000000000ff0000ULL) |
+            ((x >> 40) & 0x000000000000ff00ULL) |
+            ((x >> 56) & 0x00000000000000ffULL);
+}
+#endif
+
+
+/* XXH_FORCE_MEMORY_ACCESS==3 is an endian-independent byteshift load. */
+#if (defined(XXH_FORCE_MEMORY_ACCESS) && (XXH_FORCE_MEMORY_ACCESS==3))
+
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[0]
+         | ((xxh_u64)bytePtr[1] << 8)
+         | ((xxh_u64)bytePtr[2] << 16)
+         | ((xxh_u64)bytePtr[3] << 24)
+         | ((xxh_u64)bytePtr[4] << 32)
+         | ((xxh_u64)bytePtr[5] << 40)
+         | ((xxh_u64)bytePtr[6] << 48)
+         | ((xxh_u64)bytePtr[7] << 56);
+}
+
+XXH_FORCE_INLINE xxh_u64 XXH_readBE64(const void* memPtr)
+{
+    const xxh_u8* bytePtr = (const xxh_u8 *)memPtr;
+    return bytePtr[7]
+         | ((xxh_u64)bytePtr[6] << 8)
+         | ((xxh_u64)bytePtr[5] << 16)
+         | ((xxh_u64)bytePtr[4] << 24)
+         | ((xxh_u64)bytePtr[3] << 32)
+         | ((xxh_u64)bytePtr[2] << 40)
+         | ((xxh_u64)bytePtr[1] << 48)
+         | ((xxh_u64)bytePtr[0] << 56);
+}
+
+#else
+XXH_FORCE_INLINE xxh_u64 XXH_readLE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_read64(ptr) : XXH_swap64(XXH_read64(ptr));
+}
+
+static xxh_u64 XXH_readBE64(const void* ptr)
+{
+    return XXH_CPU_LITTLE_ENDIAN ? XXH_swap64(XXH_read64(ptr)) : XXH_read64(ptr);
+}
+#endif
+
+XXH_FORCE_INLINE xxh_u64
+XXH_readLE64_align(const void* ptr, XXH_alignment align)
+{
+    if (align==XXH_unaligned)
+        return XXH_readLE64(ptr);
+    else
+        return XXH_CPU_LITTLE_ENDIAN ? *(const xxh_u64*)ptr : XXH_swap64(*(const xxh_u64*)ptr);
+}
+
+
+/*******   xxh64   *******/
+
+static const xxh_u64 PRIME64_1 = 0x9E3779B185EBCA87ULL;   /* 0b1001111000110111011110011011000110000101111010111100101010000111 */
+static const xxh_u64 PRIME64_2 = 0xC2B2AE3D27D4EB4FULL;   /* 0b1100001010110010101011100011110100100111110101001110101101001111 */
+static const xxh_u64 PRIME64_3 = 0x165667B19E3779F9ULL;   /* 0b0001011001010110011001111011000110011110001101110111100111111001 */
+static const xxh_u64 PRIME64_4 = 0x85EBCA77C2B2AE63ULL;   /* 0b1000010111101011110010100111011111000010101100101010111001100011 */
+static const xxh_u64 PRIME64_5 = 0x27D4EB2F165667C5ULL;   /* 0b0010011111010100111010110010111100010110010101100110011111000101 */
+
+static xxh_u64 XXH64_round(xxh_u64 acc, xxh_u64 input)
+{
+    acc += input * PRIME64_2;
+    acc  = XXH_rotl64(acc, 31);
+    acc *= PRIME64_1;
+    return acc;
+}
+
+static xxh_u64 XXH64_mergeRound(xxh_u64 acc, xxh_u64 val)
+{
+    val  = XXH64_round(0, val);
+    acc ^= val;
+    acc  = acc * PRIME64_1 + PRIME64_4;
+    return acc;
+}
+
+static xxh_u64 XXH64_avalanche(xxh_u64 h64)
+{
+    h64 ^= h64 >> 33;
+    h64 *= PRIME64_2;
+    h64 ^= h64 >> 29;
+    h64 *= PRIME64_3;
+    h64 ^= h64 >> 32;
+    return h64;
+}
+
+
+#define XXH_get64bits(p) XXH_readLE64_align(p, align)
+
+static xxh_u64
+XXH64_finalize(xxh_u64 h64, const xxh_u8* ptr, size_t len, XXH_alignment align)
+{
+#define PROCESS1_64            \
+    h64 ^= (*ptr++) * PRIME64_5; \
+    h64 = XXH_rotl64(h64, 11) * PRIME64_1;
+
+#define PROCESS4_64          \
+    h64 ^= (xxh_u64)(XXH_get32bits(ptr)) * PRIME64_1; \
+    ptr+=4;                    \
+    h64 = XXH_rotl64(h64, 23) * PRIME64_2 + PRIME64_3;
+
+#define PROCESS8_64 {        \
+    xxh_u64 const k1 = XXH64_round(0, XXH_get64bits(ptr)); \
+    ptr+=8;                    \
+    h64 ^= k1;               \
+    h64  = XXH_rotl64(h64,27) * PRIME64_1 + PRIME64_4; \
+}
+
+    /* Rerolled version for 32-bit targets is faster and much smaller. */
+    if (XXH_REROLL || XXH_REROLL_XXH64) {
+        len &= 31;
+        while (len >= 8) {
+            PROCESS8_64;
+            len -= 8;
+        }
+        if (len >= 4) {
+            PROCESS4_64;
+            len -= 4;
+        }
+        while (len > 0) {
+            PROCESS1_64;
+            --len;
+        }
+         return  XXH64_avalanche(h64);
+    } else {
+        switch(len & 31) {
+           case 24: PROCESS8_64;
+                         /* fallthrough */
+           case 16: PROCESS8_64;
+                         /* fallthrough */
+           case  8: PROCESS8_64;
+                    return XXH64_avalanche(h64);
+
+           case 28: PROCESS8_64;
+                         /* fallthrough */
+           case 20: PROCESS8_64;
+                         /* fallthrough */
+           case 12: PROCESS8_64;
+                         /* fallthrough */
+           case  4: PROCESS4_64;
+                    return XXH64_avalanche(h64);
+
+           case 25: PROCESS8_64;
+                         /* fallthrough */
+           case 17: PROCESS8_64;
+                         /* fallthrough */
+           case  9: PROCESS8_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 29: PROCESS8_64;
+                         /* fallthrough */
+           case 21: PROCESS8_64;
+                         /* fallthrough */
+           case 13: PROCESS8_64;
+                         /* fallthrough */
+           case  5: PROCESS4_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 26: PROCESS8_64;
+                         /* fallthrough */
+           case 18: PROCESS8_64;
+                         /* fallthrough */
+           case 10: PROCESS8_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 30: PROCESS8_64;
+                         /* fallthrough */
+           case 22: PROCESS8_64;
+                         /* fallthrough */
+           case 14: PROCESS8_64;
+                         /* fallthrough */
+           case  6: PROCESS4_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 27: PROCESS8_64;
+                         /* fallthrough */
+           case 19: PROCESS8_64;
+                         /* fallthrough */
+           case 11: PROCESS8_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    PROCESS1_64;
+                    return XXH64_avalanche(h64);
+
+           case 31: PROCESS8_64;
+                         /* fallthrough */
+           case 23: PROCESS8_64;
+                         /* fallthrough */
+           case 15: PROCESS8_64;
+                         /* fallthrough */
+           case  7: PROCESS4_64;
+                         /* fallthrough */
+           case  3: PROCESS1_64;
+                         /* fallthrough */
+           case  2: PROCESS1_64;
+                         /* fallthrough */
+           case  1: PROCESS1_64;
+                         /* fallthrough */
+           case  0: return XXH64_avalanche(h64);
+        }
+    }
+    /* impossible to reach */
+    XXH_ASSERT(0);
+    return 0;  /* unreachable, but some compilers complain without it */
+}
+
+XXH_FORCE_INLINE xxh_u64
+XXH64_endian_align(const xxh_u8* input, size_t len, xxh_u64 seed, XXH_alignment align)
+{
+    const xxh_u8* bEnd = input + len;
+    xxh_u64 h64;
+
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+    if (input==NULL) {
+        len=0;
+        bEnd=input=(const xxh_u8*)(size_t)32;
+    }
+#endif
+
+    if (len>=32) {
+        const xxh_u8* const limit = bEnd - 32;
+        xxh_u64 v1 = seed + PRIME64_1 + PRIME64_2;
+        xxh_u64 v2 = seed + PRIME64_2;
+        xxh_u64 v3 = seed + 0;
+        xxh_u64 v4 = seed - PRIME64_1;
+
+        do {
+            v1 = XXH64_round(v1, XXH_get64bits(input)); input+=8;
+            v2 = XXH64_round(v2, XXH_get64bits(input)); input+=8;
+            v3 = XXH64_round(v3, XXH_get64bits(input)); input+=8;
+            v4 = XXH64_round(v4, XXH_get64bits(input)); input+=8;
+        } while (input<=limit);
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+
+    } else {
+        h64  = seed + PRIME64_5;
+    }
+
+    h64 += (xxh_u64) len;
+
+    return XXH64_finalize(h64, input, len, align);
+}
+
+
+XXH_PUBLIC_API XXH64_hash_t XXH64 (const void* input, size_t len, XXH64_hash_t seed)
+{
+#if 0
+    /* Simple version, good for code maintenance, but unfortunately slow for small inputs */
+    XXH64_state_t state;
+    XXH64_reset(&state, seed);
+    XXH64_update(&state, (const xxh_u8*)input, len);
+    return XXH64_digest(&state);
+
+#else
+
+    if (XXH_FORCE_ALIGN_CHECK) {
+        if ((((size_t)input) & 7)==0) {  /* Input is aligned, let's leverage the speed advantage */
+            return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_aligned);
+    }   }
+
+    return XXH64_endian_align((const xxh_u8*)input, len, seed, XXH_unaligned);
+
+#endif
+}
+
+/*******   Hash Streaming   *******/
+
+XXH_PUBLIC_API XXH64_state_t* XXH64_createState(void)
+{
+    return (XXH64_state_t*)XXH_malloc(sizeof(XXH64_state_t));
+}
+XXH_PUBLIC_API XXH_errorcode XXH64_freeState(XXH64_state_t* statePtr)
+{
+    XXH_free(statePtr);
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API void XXH64_copyState(XXH64_state_t* dstState, const XXH64_state_t* srcState)
+{
+    memcpy(dstState, srcState, sizeof(*dstState));
+}
+
+XXH_PUBLIC_API XXH_errorcode XXH64_reset(XXH64_state_t* statePtr, XXH64_hash_t seed)
+{
+    XXH64_state_t state;   /* use a local state to memcpy() in order to avoid strict-aliasing warnings */
+    memset(&state, 0, sizeof(state));
+    state.v1 = seed + PRIME64_1 + PRIME64_2;
+    state.v2 = seed + PRIME64_2;
+    state.v3 = seed + 0;
+    state.v4 = seed - PRIME64_1;
+     /* do not write into reserved64, might be removed in a future version */
+    memcpy(statePtr, &state, sizeof(state) - sizeof(state.reserved64));
+    return XXH_OK;
+}
+
+XXH_PUBLIC_API XXH_errorcode
+XXH64_update (XXH64_state_t* state, const void* input, size_t len)
+{
+    if (input==NULL)
+#if defined(XXH_ACCEPT_NULL_INPUT_POINTER) && (XXH_ACCEPT_NULL_INPUT_POINTER>=1)
+        return XXH_OK;
+#else
+        return XXH_ERROR;
+#endif
+
+    {   const xxh_u8* p = (const xxh_u8*)input;
+        const xxh_u8* const bEnd = p + len;
+
+        state->total_len += len;
+
+        if (state->memsize + len < 32) {  /* fill in tmp buffer */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, len);
+            state->memsize += (xxh_u32)len;
+            return XXH_OK;
+        }
+
+        if (state->memsize) {   /* tmp buffer is full */
+            XXH_memcpy(((xxh_u8*)state->mem64) + state->memsize, input, 32-state->memsize);
+            state->v1 = XXH64_round(state->v1, XXH_readLE64(state->mem64+0));
+            state->v2 = XXH64_round(state->v2, XXH_readLE64(state->mem64+1));
+            state->v3 = XXH64_round(state->v3, XXH_readLE64(state->mem64+2));
+            state->v4 = XXH64_round(state->v4, XXH_readLE64(state->mem64+3));
+            p += 32-state->memsize;
+            state->memsize = 0;
+        }
+
+        if (p+32 <= bEnd) {
+            const xxh_u8* const limit = bEnd - 32;
+            xxh_u64 v1 = state->v1;
+            xxh_u64 v2 = state->v2;
+            xxh_u64 v3 = state->v3;
+            xxh_u64 v4 = state->v4;
+
+            do {
+                v1 = XXH64_round(v1, XXH_readLE64(p)); p+=8;
+                v2 = XXH64_round(v2, XXH_readLE64(p)); p+=8;
+                v3 = XXH64_round(v3, XXH_readLE64(p)); p+=8;
+                v4 = XXH64_round(v4, XXH_readLE64(p)); p+=8;
+            } while (p<=limit);
+
+            state->v1 = v1;
+            state->v2 = v2;
+            state->v3 = v3;
+            state->v4 = v4;
+        }
+
+        if (p < bEnd) {
+            XXH_memcpy(state->mem64, p, (size_t)(bEnd-p));
+            state->memsize = (unsigned)(bEnd-p);
+        }
+    }
+
+    return XXH_OK;
+}
+
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_digest (const XXH64_state_t* state)
+{
+    xxh_u64 h64;
+
+    if (state->total_len >= 32) {
+        xxh_u64 const v1 = state->v1;
+        xxh_u64 const v2 = state->v2;
+        xxh_u64 const v3 = state->v3;
+        xxh_u64 const v4 = state->v4;
+
+        h64 = XXH_rotl64(v1, 1) + XXH_rotl64(v2, 7) + XXH_rotl64(v3, 12) + XXH_rotl64(v4, 18);
+        h64 = XXH64_mergeRound(h64, v1);
+        h64 = XXH64_mergeRound(h64, v2);
+        h64 = XXH64_mergeRound(h64, v3);
+        h64 = XXH64_mergeRound(h64, v4);
+    } else {
+        h64  = state->v3 /*seed*/ + PRIME64_5;
+    }
+
+    h64 += (xxh_u64) state->total_len;
+
+    return XXH64_finalize(h64, (const xxh_u8*)state->mem64, (size_t)state->total_len, XXH_aligned);
+}
+
+
+/******* Canonical representation   *******/
+
+XXH_PUBLIC_API void XXH64_canonicalFromHash(XXH64_canonical_t* dst, XXH64_hash_t hash)
+{
+    XXH_STATIC_ASSERT(sizeof(XXH64_canonical_t) == sizeof(XXH64_hash_t));
+    if (XXH_CPU_LITTLE_ENDIAN) hash = XXH_swap64(hash);
+    memcpy(dst, &hash, sizeof(*dst));
+}
+
+XXH_PUBLIC_API XXH64_hash_t XXH64_hashFromCanonical(const XXH64_canonical_t* src)
+{
+    return XXH_readBE64(src);
+}
+
+
+
+/* *********************************************************************
+*  XXH3
+*  New generation hash designed for speed on small keys and vectorization
+************************************************************************ */
+
+#include "xxh3.h"
+
+
+#endif  /* XXH_NO_LONG_LONG */
+
+
+#endif  /* XXH_IMPLEMENTATION */
+
+
+#if defined (__cplusplus)
+}
+#endif

From 2a79ea749df01f8ae113ff64adcce0ea4e64763f Mon Sep 17 00:00:00 2001
From: David Lawson <dmrlawson@gmail.com>
Date: Wed, 6 May 2020 07:00:37 +0100
Subject: [PATCH 07/28] Remove CRC.cpp and use GLideN64 implementations

---
 Makefile.common         |  6 ++--
 custom/GLideN64/CRC.cpp | 72 -----------------------------------------
 2 files changed, 2 insertions(+), 76 deletions(-)
 delete mode 100644 custom/GLideN64/CRC.cpp

diff --git a/Makefile.common b/Makefile.common
index c7caf096..84827018 100644
--- a/Makefile.common
+++ b/Makefile.common
@@ -420,12 +420,10 @@ endif
 
 SOURCES_C += $(LIBRETRO_COMM_DIR)/libco/libco.c
 
-ifneq (,$(findstring rpi3,$(platform)))
-	SOURCES_CXX += $(VIDEODIR_GLIDEN64)/src/CRC32_ARMV8.cpp
-else ifeq ($(platform), libnx)
+ifeq ($(platform), $(filter $(platform), rpi3 rpi4 libnx))
 	SOURCES_CXX += $(VIDEODIR_GLIDEN64)/src/CRC32_ARMV8.cpp
 else
-	SOURCES_CXX += $(ROOT_DIR)/custom/GLideN64/CRC.cpp
+	SOURCES_CXX += $(VIDEODIR_GLIDEN64)/src/CRC_OPT.cpp
 endif
 
 ifeq ($(HAVE_NEON),1)
diff --git a/custom/GLideN64/CRC.cpp b/custom/GLideN64/CRC.cpp
deleted file mode 100644
index 75d7585d..00000000
--- a/custom/GLideN64/CRC.cpp
+++ /dev/null
@@ -1,72 +0,0 @@
-#include "CRC.h"
-#define XXH_INLINE_ALL
-#include "xxhash.h"
-
-#define CRC32_POLYNOMIAL     0x04C11DB7
-
-unsigned int CRCTable[ 256 ];
-
-static
-u32 Reflect( u32 ref, char ch )
-{
-	 u32 value = 0;
-
-	 // Swap bit 0 for bit 7
-	 // bit 1 for bit 6, etc.
-	 for (int i = 1; i < (ch + 1); ++i) {
-		  if(ref & 1)
-			value |= 1 << (ch - i);
-		  ref >>= 1;
-	 }
-	 return value;
-}
-
-void CRC_Init()
-{
-	u32 crc;
-
-	for (int i = 0; i < 256; ++i) {
-		crc = Reflect( i, 8 ) << 24;
-		for (int j = 0; j < 8; ++j)
-			crc = (crc << 1) ^ (crc & (1 << 31) ? CRC32_POLYNOMIAL : 0);
-
-		CRCTable[i] = Reflect( crc, 32 );
-	}
-}
-
-u32 CRC_Calculate_Strict( u32 crc, const void * buffer, u32 count )
-{
-	u8 *p;
-	u32 orig = crc;
-
-	p = (u8*) buffer;
-	while (count--)
-		crc = (crc >> 8) ^ CRCTable[(crc & 0xFF) ^ *p++];
-
-	return crc ^ orig;
-}
-
-u64 CRC_Calculate( u64 crc, const void * buffer, u32 count )
-{
-#ifdef __x86_64__
-	return XXH64(buffer, count, crc);
-#else
-	return XXH32(buffer, count, crc);
-#endif
-}
-
-u64 CRC_CalculatePalette(u64 crc, const void * buffer, u32 count )
-{
-	u8 *p;
-	u32 orig = crc;
-
-	p = (u8*) buffer;
-	while (count--) {
-		crc = (crc >> 8) ^ CRCTable[(crc & 0xFF) ^ *p++];
-		crc = (crc >> 8) ^ CRCTable[(crc & 0xFF) ^ *p++];
-
-		p += 6;
-	}
-
-	return crc ^ orig;
-}

From 905a026d587800dae7a8ec4e4a2aa679457f17cc Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 12:49:41 +0200
Subject: [PATCH 08/28] First revision of new Core options - Deprecated GLN
 header for Core options - Add Hybrid Filter Core option - Add Dithering
 Pattern Core option - Add Dithering Quantization Core option - Add RDRAM
 Image Dithering Mode Core option - Additional thanks to Tatsuya79 and
 dmrlawson

---
 GLideN64/src/Textures.cpp                     |    2 +-
 custom/GLideN64/GLideN64_libretro.h           |   44 -
 .../GLideN64/mupenplus/Config_mupenplus.cpp   |   13 +
 custom/mupen64plus-next_common.h              |   50 +-
 libretro-common/glsm/glsm.c                   |    2 +-
 libretro/libretro.c                           |  231 +--
 libretro/libretro_core_options.h              | 1274 +++++++++++++++++
 .../src/device/rcp/vi/vi_controller.c         |    2 +-
 mupen64plus-core/src/main/main.c              |    4 +-
 9 files changed, 1392 insertions(+), 230 deletions(-)
 create mode 100644 libretro/libretro_core_options.h

diff --git a/GLideN64/src/Textures.cpp b/GLideN64/src/Textures.cpp
index 70401982..cc42874e 100644
--- a/GLideN64/src/Textures.cpp
+++ b/GLideN64/src/Textures.cpp
@@ -21,7 +21,7 @@
 #include "Graphics/Context.h"
 #include "Graphics/Parameters.h"
 #include "DisplayWindow.h"
-#include <GLideN64/GLideN64_libretro.h>
+#include <mupen64plus-next_common.h>
 
 using namespace std;
 using namespace graphics;
diff --git a/custom/GLideN64/GLideN64_libretro.h b/custom/GLideN64/GLideN64_libretro.h
index bc7b4c5e..50d3b6d3 100644
--- a/custom/GLideN64/GLideN64_libretro.h
+++ b/custom/GLideN64/GLideN64_libretro.h
@@ -38,48 +38,4 @@ typedef char GLchar;
 #endif // OS_MAC_OS_X
 #endif // GLES2
 
-extern uint32_t bilinearMode;
-extern uint32_t EnableHWLighting;
-extern uint32_t CorrectTexrectCoords;
-extern uint32_t enableNativeResTexrects;
-extern uint32_t enableLegacyBlending;
-extern uint32_t EnableCopyColorToRDRAM;
-extern uint32_t EnableCopyDepthToRDRAM;
-extern uint32_t AspectRatio;
-extern uint32_t MaxTxCacheSize;
-extern uint32_t txFilterMode;
-extern uint32_t txEnhancementMode;
-extern uint32_t txHiresEnable;
-extern uint32_t txHiresFullAlphaChannel;
-extern uint32_t txFilterIgnoreBG;
-extern uint32_t EnableFXAA;
-extern uint32_t MultiSampling;
-extern uint32_t EnableFragmentDepthWrite;
-extern uint32_t EnableShadersStorage;
-extern uint32_t EnableTextureCache;
-extern uint32_t EnableFBEmulation;
-extern uint32_t EnableFrameDuping;
-extern uint32_t EnableLODEmulation;
-extern uint32_t EnableFullspeed;
-extern uint32_t CountPerOp;
-extern uint32_t CountPerScanlineOverride;
-extern uint32_t BackgroundMode;
-extern uint32_t EnableEnhancedTextureStorage;
-extern uint32_t EnableEnhancedHighResStorage;
-extern uint32_t EnableTxCacheCompression;
-extern uint32_t ForceDisableExtraMem;
-extern uint32_t EnableNativeResFactor;
-extern uint32_t EnableN64DepthCompare;
-
-// Overscan Options
-extern uint32_t EnableOverscan;
-extern uint32_t OverscanTop;
-extern uint32_t OverscanLeft;
-extern uint32_t OverscanRight;
-extern uint32_t OverscanBottom;
-
-// Others
-#define RETRO_MEMORY_DD 0x100 + 1
-#define RETRO_GAME_TYPE_DD  1
-
 #endif
diff --git a/custom/GLideN64/mupenplus/Config_mupenplus.cpp b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
index ceecaf10..17230999 100644
--- a/custom/GLideN64/mupenplus/Config_mupenplus.cpp
+++ b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
@@ -1,3 +1,4 @@
+#include <mupen64plus-next_common.h>
 #include "GLideN64_mupenplus.h"
 #include "GLideN64_libretro.h"
 #include <assert.h>
@@ -69,6 +70,14 @@ void LoadCustomSettings(bool internal)
 				if (found) {
 					if (!strcmp(l.name, "video\\multisampling"))
 						config.video.multisampling = atoi(l.value);
+					else if (!strcmp(l.name, "generalEmulation\\enableDitheringPattern"))
+						config.generalEmulation.enableDitheringPattern = atoi(l.value);
+					else if (!strcmp(l.name, "generalEmulation\\enableHiresNoiseDithering"))
+						config.generalEmulation.enableHiresNoiseDithering = atoi(l.value);
+					else if (!strcmp(l.name, "generalEmulation\\enableDitheringQuantization"))
+						config.generalEmulation.enableDitheringQuantization = atoi(l.value);
+					else if (!strcmp(l.name, "generalEmulation\\rdramImageDitheringMode"))
+						config.generalEmulation.rdramImageDitheringMode = atoi(l.value);
 					else if (!strcmp(l.name, "frameBufferEmulation\\aspect"))
 						config.frameBufferEmulation.aspect = atoi(l.value);
 					else if (!strcmp(l.name, "frameBufferEmulation\\nativeResFactor"))
@@ -120,6 +129,10 @@ extern "C" void Config_LoadConfig()
 	config.frameBufferEmulation.N64DepthCompare = EnableN64DepthCompare;
 
 	config.texture.bilinearMode = bilinearMode;
+	config.generalEmulation.enableHybridFilter = EnableHybridFilter;
+	config.generalEmulation.enableDitheringPattern = EnableDitheringPattern;
+	config.generalEmulation.enableDitheringQuantization = EnableDitheringQuantization;
+	config.generalEmulation.rdramImageDitheringMode = RDRAMImageDitheringMode;
 	config.generalEmulation.enableHWLighting = EnableHWLighting;
 	config.generalEmulation.enableLegacyBlending = enableLegacyBlending;
 	config.generalEmulation.enableLOD = EnableLODEmulation;
diff --git a/custom/mupen64plus-next_common.h b/custom/mupen64plus-next_common.h
index 4383ef1b..53531b74 100644
--- a/custom/mupen64plus-next_common.h
+++ b/custom/mupen64plus-next_common.h
@@ -1,6 +1,6 @@
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
  *   Mupen64plus-Next - mupen64plus-next_common.h                          *
- *   Copyright (C) 2020 M4xw <m4x@m4xw.net                                 *
+ *   Copyright (C) 2020 M4xw <m4x@m4xw.net>                                *
  *   Copyright (C) 2020 Daniel De Matteis                                  *
  *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
@@ -60,6 +60,54 @@ extern enum rdp_plugin_type current_rdp_type;
 extern enum rsp_plugin_type current_rsp_type;
 extern bool libretro_swap_buffer;
 
+extern uint32_t bilinearMode;
+extern uint32_t EnableHybridFilter;
+extern uint32_t EnableDitheringPattern;
+extern uint32_t EnableDitheringQuantization;
+extern uint32_t RDRAMImageDitheringMode;
+extern uint32_t EnableHWLighting;
+extern uint32_t CorrectTexrectCoords;
+extern uint32_t enableNativeResTexrects;
+extern uint32_t enableLegacyBlending;
+extern uint32_t EnableCopyColorToRDRAM;
+extern uint32_t EnableCopyDepthToRDRAM;
+extern uint32_t AspectRatio;
+extern uint32_t MaxTxCacheSize;
+extern uint32_t txFilterMode;
+extern uint32_t txEnhancementMode;
+extern uint32_t txHiresEnable;
+extern uint32_t txHiresFullAlphaChannel;
+extern uint32_t txFilterIgnoreBG;
+extern uint32_t EnableFXAA;
+extern uint32_t MultiSampling;
+extern uint32_t EnableFragmentDepthWrite;
+extern uint32_t EnableShadersStorage;
+extern uint32_t EnableTextureCache;
+extern uint32_t EnableFBEmulation;
+extern uint32_t EnableFrameDuping;
+extern uint32_t EnableLODEmulation;
+extern uint32_t EnableFullspeed;
+extern uint32_t CountPerOp;
+extern uint32_t CountPerScanlineOverride;
+extern uint32_t BackgroundMode;
+extern uint32_t EnableEnhancedTextureStorage;
+extern uint32_t EnableEnhancedHighResStorage;
+extern uint32_t EnableTxCacheCompression;
+extern uint32_t ForceDisableExtraMem;
+extern uint32_t EnableNativeResFactor;
+extern uint32_t EnableN64DepthCompare;
+
+// Overscan Options
+extern uint32_t EnableOverscan;
+extern uint32_t OverscanTop;
+extern uint32_t OverscanLeft;
+extern uint32_t OverscanRight;
+extern uint32_t OverscanBottom;
+
+// Others
+#define RETRO_MEMORY_DD 0x100 + 1
+#define RETRO_GAME_TYPE_DD  1
+
 #ifdef __cplusplus
 }
 #endif /* __cplusplus */
diff --git a/libretro-common/glsm/glsm.c b/libretro-common/glsm/glsm.c
index c145fe27..0c54f70b 100644
--- a/libretro-common/glsm/glsm.c
+++ b/libretro-common/glsm/glsm.c
@@ -25,7 +25,7 @@
 #include <string.h>
 #include <glsym/glsym.h>
 #include <glsm/glsm.h>
-#include <GLideN64_libretro.h>
+#include <mupen64plus-next_common.h>
 
 #if defined(HAVE_OPENGLES)
 #if !defined(IOS)
diff --git a/libretro/libretro.c b/libretro/libretro.c
index 32e2e3c9..0f14fb24 100644
--- a/libretro/libretro.c
+++ b/libretro/libretro.c
@@ -24,6 +24,8 @@
 
 #include "libretro.h"
 #include "libretro_private.h"
+#include "libretro_core_options.h"
+
 #include "GLideN64_libretro.h"
 #include "mupen64plus-next_common.h"
 
@@ -92,28 +94,6 @@ struct rgba
 extern struct rgba prescale[PRESCALE_WIDTH * PRESCALE_HEIGHT];
 #endif // HAVE_THR_AL
 
-// Option entries
-#define OPTION_ENTRY_RDP_GLIDEN64 "gliden64"
-#define OPTION_ENTRY_RSP_HLE "hle"
-
-#ifdef HAVE_THR_AL
-#define OPTION_ENTRY_RDP_ANGRYLION "|angrylion"
-#else
-#define OPTION_ENTRY_RDP_ANGRYLION ""
-#endif // HAVE_THR_AL
-
-#ifdef HAVE_PARALLEL_RSP
-#define OPTION_ENTRY_RSP_PARALLEL "|parallel"
-#else
-#define OPTION_ENTRY_RSP_PARALLEL ""
-#endif // HAVE_PARALLEL_RSP
-
-#ifdef HAVE_LLE
-#define OPTION_ENTRY_RSP_CXD4 "|cxd4"
-#else
-#define OPTION_ENTRY_RSP_CXD4 ""
-#endif // HAVE_LLE
-
 struct retro_perf_callback perf_cb;
 retro_get_cpu_features_t perf_get_cpu_features_cb = NULL;
 
@@ -164,6 +144,10 @@ char* retro_dd_path_img;
 char* retro_dd_path_rom;
 
 uint32_t bilinearMode = 0;
+uint32_t EnableHybridFilter = 0;
+uint32_t EnableDitheringPattern = 0;
+uint32_t RDRAMImageDitheringMode = 0;
+uint32_t EnableDitheringQuantization = 0;
 uint32_t EnableHWLighting = 0;
 uint32_t CorrectTexrectCoords = 0;
 uint32_t enableNativeResTexrects = 0;
@@ -232,161 +216,6 @@ extern m64p_rom_header ROM_HEADER;
 
 static void setup_variables(void)
 {
-    struct retro_variable variables[] = {
-        { CORE_NAME "-cpucore",
-#ifdef DYNAREC
-            "CPU Core; dynamic_recompiler|cached_interpreter|pure_interpreter" },
-#else
-            "CPU Core; cached_interpreter|pure_interpreter" },
-#endif
-        { CORE_NAME "-rdp-plugin",
-            "RDP Mode; " OPTION_ENTRY_RDP_GLIDEN64 OPTION_ENTRY_RDP_ANGRYLION },
-        { CORE_NAME "-rsp-plugin",
-            "RSP Mode; " OPTION_ENTRY_RSP_HLE OPTION_ENTRY_RSP_PARALLEL OPTION_ENTRY_RSP_CXD4 },
-        { CORE_NAME "-43screensize",
-            "(GLN64) 4:3 Resolution; 640x480|320x240|960x720|1280x960|1440x1080|1600x1200|1920x1440|2240x1680|2560x1920|2880x2160|3200x2400|3520x2640|3840x2880" },
-        { CORE_NAME "-169screensize",
-            "(GLN64) 16:9 Resolution; 960x540|640x360|1280x720|1920x1080|2560x1440|3840x2160|4096x2160|7680x4320" },
-        { CORE_NAME "-aspect",
-            "(GLN64) Aspect Ratio; 4:3|16:9|16:9 adjusted" },
-        { CORE_NAME "-BilinearMode",
-            "(GLN64) Bilinear filtering mode; standard|3point" },
-#ifndef HAVE_OPENGLES2
-        { CORE_NAME "-MultiSampling",
-            "(GLN64) MSAA level; 0|2|4|8|16" },
-#endif
-        { CORE_NAME "-FXAA",
-            "(GLN64) FXAA; 0|1" },
-
-        { CORE_NAME "-EnableFBEmulation",
-#ifdef VC
-            "(GLN64) Framebuffer Emulation; False|True" },
-#else
-            "(GLN64) Framebuffer Emulation; True|False" },
-#endif
-
-        { CORE_NAME "-EnableLODEmulation",
-            "(GLN64) LOD Emulation; True|False" },
-        { CORE_NAME "-EnableCopyColorToRDRAM",
-#ifndef HAVE_OPENGLES
-            "(GLN64) Color buffer to RDRAM; Async|Sync|Off" },
-#else
-            "(GLN64) Color buffer to RDRAM; Off|Async|Sync" },
-#endif
-        { CORE_NAME "-EnableCopyDepthToRDRAM",
-            "(GLN64) Depth buffer to RDRAM; Software|FromMem|Off" },
-        { CORE_NAME "-BackgroundMode",
-            "(GLN64) Background Mode; OnePiece|Stripped" },
-        { CORE_NAME "-EnableHWLighting",
-            "(GLN64) Hardware per-pixel lighting; False|True" },
-        { CORE_NAME "-CorrectTexrectCoords",
-            "(GLN64) Continuous texrect coords; Off|Auto|Force" },
-        { CORE_NAME "-EnableNativeResTexrects",
-            "(GLN64) Native res. 2D texrects; Disabled|Optimized|Unoptimized" },
-#if defined(HAVE_OPENGLES)
-        { CORE_NAME "-EnableLegacyBlending",
-            "(GLN64) Less accurate blending mode; True|False" },
-        { CORE_NAME "-EnableFragmentDepthWrite",
-            "(GLN64) GPU shader depth write; False|True" },
-#else
-        { CORE_NAME "-EnableLegacyBlending",
-            "(GLN64) Less accurate blending mode; False|True" },
-        { CORE_NAME "-EnableFragmentDepthWrite",
-            "(GLN64) GPU shader depth write; True|False" },
-#endif
-#if !defined(VC) && !defined(HAVE_OPENGLES)
-        // Not supported on all GPU's
-        { CORE_NAME "-EnableN64DepthCompare",
-            "(GLN64) N64 Depth Compare; False|True" },
-        { CORE_NAME "-EnableShadersStorage",
-            "(GLN64) Cache GPU Shaders; True|False" },
-#endif // !defined(VC) && !defined(HAVE_OPENGLES)
-        { CORE_NAME "-EnableTextureCache",
-            "(GLN64) Cache Textures; True|False" },
-        { CORE_NAME "-EnableOverscan",
-            "(GLN64) Overscan; Enabled|Disabled" },
-        { CORE_NAME "-OverscanTop",
-            "(GLN64) Overscan Offset (Top); " GLN64_OVERSCAN_SCALING },
-        { CORE_NAME "-OverscanLeft",
-            "(GLN64) Overscan Offset (Left); " GLN64_OVERSCAN_SCALING },
-        { CORE_NAME "-OverscanRight",
-            "(GLN64) Overscan Offset (Right); " GLN64_OVERSCAN_SCALING },
-        { CORE_NAME "-OverscanBottom",
-            "(GLN64) Overscan Offset (Bottom); " GLN64_OVERSCAN_SCALING },
-
-        { CORE_NAME "-MaxTxCacheSize",
-#if defined(VC)
-            "(GLN64) Max texture cache size; 1500|8000|4000" },
-#elif defined(HAVE_LIBNX)
-            "(GLN64) Max texture cache size; 4000|1500|8000" },
-#else
-            "(GLN64) Max texture cache size; 8000|4000|1500" },
-#endif
-        { CORE_NAME "-txFilterMode",
-            "(GLN64) Texture filter; None|Smooth filtering 1|Smooth filtering 2|Smooth filtering 3|Smooth filtering 4|Sharp filtering 1|Sharp filtering 2" },
-        { CORE_NAME "-txEnhancementMode",
-            "(GLN64) Texture Enhancement; None|As Is|X2|X2SAI|HQ2X|HQ2XS|LQ2X|LQ2XS|HQ4X|2xBRZ|3xBRZ|4xBRZ|5xBRZ|6xBRZ" },
-        { CORE_NAME "-txFilterIgnoreBG",
-            "(GLN64) Filter background textures; True|False" },
-        { CORE_NAME "-txHiresEnable",
-            "(GLN64) Use High-Res textures; False|True" },
-        { CORE_NAME "-txCacheCompression",
-            "(GLN64) Use High-Res Texture Cache Compression; True|False" },
-        { CORE_NAME "-txHiresFullAlphaChannel",
-            "(GLN64) Use High-Res Full Alpha Channel; False|True" },
-        { CORE_NAME "-EnableEnhancedTextureStorage",
-            "(GLN64) Use enhanced Texture Storage; False|True" },
-        { CORE_NAME "-EnableEnhancedHighResStorage",
-            "(GLN64) Use enhanced Hi-Res Storage; False|True" },
-#ifdef HAVE_THR_AL
-        { CORE_NAME "-angrylion-vioverlay",
-            "(AL) VI Overlay; Filtered|AA+Blur|AA+Dedither|AA only|Unfiltered|Depth|Coverage" },
-        { CORE_NAME "-angrylion-sync",
-            "(AL) Thread sync level; Low|Medium|High" },
-        { CORE_NAME "-angrylion-multithread",
-            "(AL) Multi-threading; all threads|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60|61|62|63" },
-        { CORE_NAME "-angrylion-overscan",
-            "(AL) Hide overscan; disabled|enabled" },
-#endif // HAVE_THR_AL
-        { CORE_NAME "-FrameDuping",
-#ifdef HAVE_LIBNX
-            "Frame Duplication; True|False" },
-#else
-            "Frame Duplication; False|True" },
-#endif
-        { CORE_NAME "-Framerate",
-            "Framerate; Original|Fullspeed" },
-        { CORE_NAME "-virefresh",
-            "VI Refresh (Overclock); Auto|1500|2200" },
-        { CORE_NAME "-astick-deadzone",
-           "Analog Deadzone (percent); 15|20|25|30|0|5|10"},
-        { CORE_NAME "-astick-sensitivity",
-           "Analog Sensitivity (percent); 100|105|110|115|120|125|130|135|140|145|150|50|55|60|65|70|75|80|85|90|95"},
-        { CORE_NAME "-r-cbutton",
-           "Right C Button; C1|C2|C3|C4"},
-        { CORE_NAME "-l-cbutton",
-           "Left C Button; C2|C3|C4|C1"},
-        { CORE_NAME "-d-cbutton",
-           "Down C Button; C3|C4|C1|C2"},
-        { CORE_NAME "-u-cbutton",
-           "Up C Button; C4|C1|C2|C3"},
-        { CORE_NAME "-alt-map",
-           "Independent C-button Controls; False|True" },
-        { CORE_NAME "-ForceDisableExtraMem",
-           "Disable Expansion Pak; False|True"},
-        { CORE_NAME "-pak1",
-           "Player 1 Pak; memory|rumble|none"},
-        { CORE_NAME "-pak2",
-           "Player 2 Pak; none|memory|rumble"},
-        { CORE_NAME "-pak3",
-           "Player 3 Pak; none|memory|rumble"},
-        { CORE_NAME "-pak4",
-           "Player 4 Pak; none|memory|rumble"},
-        { CORE_NAME "-CountPerOp",
-            "Count Per Op; 0|1|2|3" },
-        { NULL, NULL },
-    };
-
     static const struct retro_controller_description port[] = {
         { "Controller", RETRO_DEVICE_JOYPAD },
         { "RetroPad", RETRO_DEVICE_JOYPAD },
@@ -400,7 +229,7 @@ static void setup_variables(void)
         { 0, 0 }
     };
 
-    environ_cb(RETRO_ENVIRONMENT_SET_VARIABLES, variables);
+    libretro_set_core_options(environ_cb);
     environ_cb(RETRO_ENVIRONMENT_SET_CONTROLLER_INFO, (void*)ports);
 }
 
@@ -787,6 +616,41 @@ static void update_variables(bool startup)
           bilinearMode = !strcmp(var.value, "3point") ? 0 : 1;
        }
 
+       var.key = CORE_NAME "-HybridFilter";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          EnableHybridFilter = !strcmp(var.value, "False") ? 0 : 1;
+       }
+
+       var.key = CORE_NAME "-DitheringPattern";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          EnableDitheringPattern = !strcmp(var.value, "False") ? 0 : 1;
+       }
+
+       var.key = CORE_NAME "-DitheringQuantization";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          EnableDitheringQuantization = !strcmp(var.value, "False") ? 0 : 1;
+       }
+       
+       var.key = CORE_NAME "-RDRAMImageDitheringMode";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          if (!strcmp(var.value, "BlueNoise"))
+             RDRAMImageDitheringMode = 2; // bdmBlueNoise
+          else if (!strcmp(var.value, "MagicSquare"))
+             RDRAMImageDitheringMode = 1; // bdmMagicSquare
+          else if (!strcmp(var.value, "Bayer"))
+             RDRAMImageDitheringMode = 1; // bdmBayer
+          else
+             RDRAMImageDitheringMode = 0; // bdmDisable
+       }
+       
        var.key = CORE_NAME "-FXAA";
        var.value = NULL;
        if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
@@ -840,14 +704,21 @@ static void update_variables(bool startup)
        var.value = NULL;
        if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
        {
-          EnableN64DepthCompare = !strcmp(var.value, "False") ? 0 : 1;
+          if (!strcmp(var.value, "Compatible"))
+             EnableN64DepthCompare = 2; // dcCompatible
+          else if (!strcmp(var.value, "True"))
+             EnableN64DepthCompare = 1; // dcFast
+          else
+             EnableN64DepthCompare = 0; // dcDisable
        }
 
        var.key = CORE_NAME "-EnableCopyColorToRDRAM";
        var.value = NULL;
        if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
        {
-          if (!strcmp(var.value, "Async"))
+          if (!strcmp(var.value, "TripleBuffer"))
+             EnableCopyColorToRDRAM = 3;
+          else if (!strcmp(var.value, "Async"))
              EnableCopyColorToRDRAM = 2;
           else if (!strcmp(var.value, "Sync"))
              EnableCopyColorToRDRAM = 1;
diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
new file mode 100644
index 00000000..b57daf3f
--- /dev/null
+++ b/libretro/libretro_core_options.h
@@ -0,0 +1,1274 @@
+/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
+ *   Mupen64plus-Next - libretro_core_options.h                            *
+ *   Copyright (C) 2020 M4xw <m4x@m4xw.net>                                *
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This program is distributed in the hope that it will be useful,       *
+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
+ *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
+ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
+
+#ifndef LIBRETRO_CORE_OPTIONS_H__
+#define LIBRETRO_CORE_OPTIONS_H__
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <libretro.h>
+#include <retro_inline.h>
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#ifndef CORE_NAME
+#define CORE_NAME "mupen64plus"
+#endif
+
+struct retro_core_option_definition option_defs_us[] = {
+    {
+        CORE_NAME "-cpucore",
+        "CPU Core",
+        "Select the R4300 CPU Backend, use Interpreter for best compability",
+        {
+            {"pure_interpreter", "Pure Interpreter"},
+            {"cached_interpreter", "Cached Interpreter"},
+#ifdef DYNAREC
+            {"dynamic_recompiler", "Dynarec"},
+#endif
+            {NULL, NULL},
+        },
+#ifdef DYNAREC
+        "dynamic_recompiler"
+#else
+        "cached_interpreter"
+#endif
+    },
+    {
+        CORE_NAME "-rdp-plugin",
+        "RDP Plugin",
+        "Select a RDP Plugin, use Angrylion (if available) for best compability, GLideN64 for Performance",
+        {
+#ifdef HAVE_THR_AL
+            {"angrylion", "Angrylion"},
+#endif
+            {"gliden64", "GLideN64"},
+            {NULL, NULL},
+        },
+        "gliden64"
+    },
+    {
+        CORE_NAME "-rsp-plugin",
+        "RSP Plugin",
+        "Select a RSP Plugin, use HLE for best performance, ParaLLEl for best LLE Performance and CXD4 as LLE fallback",
+        {
+#ifdef HAVE_LLE
+            {"cxd4", "CXD4"},
+#endif
+#ifdef HAVE_PARALLEL_RSP
+            {"parallel", "ParaLLEl"},
+#endif
+            {"hle", "HLE"},
+            {NULL, NULL},
+        },
+        "hle"
+    },
+    {
+        CORE_NAME "-43screensize",
+        "4:3 Resolution",
+        "(GLN64) Select Render Viewport dimensions (4:3).",
+        {
+            {"320x240", NULL},
+            {"640x480", NULL},
+            {"960x720", NULL},
+            {"1280x960", NULL},
+            {"1440x1080", NULL},
+            {"1600x1200", NULL},
+            {"1920x1440", NULL},
+            {"2240x1680", NULL},
+            {"2560x1920", NULL},
+            {"2880x2160", NULL},
+            {"3200x2400", NULL},
+            {"3520x2640", NULL},
+            {"3840x2880", NULL},
+            {NULL, NULL},
+        },
+        "640x480"
+    },
+    {
+        CORE_NAME "-169screensize",
+        "16:9 Resolution",
+        "(GLN64) Select Render Viewport dimensions (16:9).",
+        {
+            {"640x360", NULL},
+            {"960x540", NULL},
+            {"1280x720", NULL},
+            {"1920x1080", NULL},
+            {"2560x1440", NULL},
+            {"3840x2160", NULL},
+            {"4096x2160", NULL},
+            {"7680x4320", NULL},
+            {NULL, NULL},
+        },
+        "960x540"
+    },
+    {
+        CORE_NAME "-aspect",
+        "Aspect Ratio",
+        "(GLN64) Select the aspect ratio, 16:9 adjusted means essentially Widescreen hacks.",
+        {
+            {"4:3", NULL},
+            {"16:9", NULL},
+            {"16:9 adjusted", NULL},
+            {NULL, NULL},
+        },
+        "4:3"
+    },
+    {
+        CORE_NAME "-BilinearMode",
+        "Bilinear filtering mode",
+        "(GLN64) Select a Bilinear filtering method, 3point is the original system specific way.",
+        {
+            {"3point", NULL},
+            {"standard", NULL},
+            {NULL, NULL},
+        },
+        "standard"
+    },
+    {
+        CORE_NAME "-HybridFilter",
+        "Hybrid Filter",
+        "(GLN64) Hybrid integer scaling filter, this can be slow with low-end GPUs.",
+        {
+            {"True", "Enabled"},
+            {"False", "Disabled"},
+            {NULL, NULL},
+        },
+        "True"
+    },
+    {
+        CORE_NAME "-DitheringPattern",
+        "Dithering",
+        "(GLN64) Applies dithering pattern to output image.",
+        {
+            {"True", "Enabled"},
+            {"False", "Disabled"},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-DitheringQuantization",
+        "Dithering Quantization",
+        "(GLN64) Dither with color quantization.",
+        {
+            {"True", "Enabled"},
+            {"False", "Disabled"},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-RDRAMImageDitheringMode",
+        "Image Dithering Mode",
+        "(GLN64) Dithering mode for image in RDRAM.",
+        {
+            {"False", "Disabled"},
+            {"Bayer", NULL},
+            {"MagicSquare", "Magic Square"},
+            {"BlueNoise", "Blue Noise"},
+            {NULL, NULL},
+        },
+        "False"
+    },
+#ifndef HAVE_OPENGLES2
+    {
+        CORE_NAME "-MultiSampling",
+        "MSAA level",
+        "(GLN64) Anti-Aliasing level (0 = disabled).",
+        {
+            {"0", NULL},
+            {"2", NULL},
+            {"4", NULL},
+            {"8", NULL},
+            {"16", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+#endif
+    {
+        CORE_NAME "-FXAA",
+        "FXAA",
+        "(GLN64) Fast Approximate Anti-Aliasing shader, moderately blur textures (0 = disabled).",
+        {
+            {"0", NULL},
+            {"1", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+    {
+        CORE_NAME "-EnableLODEmulation",
+        "LOD Emulation",
+        "(GLN64) Calculate per-pixel Level Of Details to select texture mip levels and blend them with each other using LOD fraction.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "True"
+    },
+    {
+        CORE_NAME "-EnableFBEmulation",
+        "Framebuffer Emulation",
+        "(GLN64) Frame/depth buffer emulation. Disabling it can shorten input lag for particular games, but also break some special effects.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+#ifdef VC
+        "True"
+#else
+        "False"
+#endif // VC
+    },
+    {
+        CORE_NAME "-EnableCopyColorToRDRAM",
+        "Color buffer to RDRAM",
+        "(GLN64) Color buffer copy to RDRAM (Off will trade compatibility for Performance).",
+        {
+            {"Off", NULL},
+            {"Sync", NULL},
+#ifndef HAVE_OPENGLES2
+            {"Async", "DoubleBuffer"},
+            {"TripleBuffer", "TripleBuffer"},
+#endif // HAVE_OPENGLES2
+            {NULL, NULL},
+        },
+#ifndef HAVE_OPENGLES2
+        "Async"
+#else
+        "Off"
+#endif // HAVE_OPENGLES2
+    },
+    {
+        CORE_NAME "-EnableCopyDepthToRDRAM",
+        "Depth buffer to RDRAM",
+        "(GLN64) Depth buffer copy to RDRAM (Off will trade compatibility for Performance).",
+        {
+            {"Off", NULL},
+            {"Software", NULL},
+            {"FromMem", NULL},
+            {NULL, NULL},
+        },
+        "Software"
+    },
+    {
+        CORE_NAME "-BackgroundMode",
+        "Background Mode",
+        "(GLN64) Render backgrounds mode (HLE only). One piece (fast), Stripped (precise)",
+        {
+            {"Stripped", NULL},
+            {"OnePiece", NULL},
+            {NULL, NULL},
+        },
+        "OnePiece"
+    },
+    {
+        CORE_NAME "-EnableHWLighting",
+        "Hardware per-pixel lighting",
+        "(GLN64) Standard per-vertex lighting when disabled. Slightly different rendering.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-CorrectTexrectCoords",
+        "Continuous texrect coords",
+        "(GLN64) Make texrect coordinates continuous to avoid black lines between them.",
+        {
+            {"Off", NULL},
+            {"Auto", NULL},
+            {"Force", NULL},
+            {NULL, NULL},
+        },
+        "Off"
+    },
+    {
+        CORE_NAME "-EnableNativeResTexrects",
+        "Native res. 2D texrects",
+        "(GLN64) Render 2D texrects in native resolution to fix misalignment between parts of 2D image (example: Mario Kart driver selection portraits).",
+        {
+            {"Disabled", NULL},
+            {"Unoptimized", NULL},
+            {"Optimized", NULL},
+            {NULL, NULL},
+        },
+        "Disabled"
+    },
+    {
+        CORE_NAME "-EnableLegacyBlending",
+        "Less accurate blending mode",
+        "(GLN64) Do not use shaders to emulate N64 blending modes. Works faster on slow GPU. Can cause glitches.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+#ifdef HAVE_OPENGLES
+        "True"
+#else
+        "False"
+#endif
+    },
+    {
+        CORE_NAME "-EnableFragmentDepthWrite",
+        "GPU shader depth write",
+        "(GLN64) Enable writing of fragment depth. Some mobile GPUs do not support it, thus it's optional. Leave enabled.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+#ifdef HAVE_OPENGLES
+        "False"
+#else
+        "True"
+#endif
+    },
+#if !defined(VC) && !defined(HAVE_OPENGLES)
+    {
+        CORE_NAME "-EnableN64DepthCompare",
+        "N64 Depth Compare",
+        "(GLN64) Enable N64 depth compare instead of OpenGL standard one. Experimental, Fast mode will have more glitches.",
+        {
+            {"False", "Off"},
+            {"True", "Fast"},
+            {"Compatible", NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-EnableShadersStorage",
+        "Cache GPU Shaders",
+        "(GLN64) Use persistent storage for compiled shaders.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "True"
+    },
+#endif
+    {
+        CORE_NAME "-EnableTextureCache",
+        "Cache Textures",
+        "(GLN64) Save texture cache to hard disk.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "True"
+    },
+    {
+        CORE_NAME "-EnableOverscan",
+        "Overscan",
+        "(GLN64) Crop black borders from the overscan region around the screen.",
+        {
+            {"Disabled", NULL},
+            {"Enabled", NULL},
+            {NULL, NULL},
+        },
+        "Enabled"
+    },
+    {
+        CORE_NAME "-OverscanTop",
+        "Overscan Offset (Top)",
+        "(GLN64) Overscan Top Offset.",
+        {
+            {"0", NULL},
+            {"1", NULL},
+            {"2", NULL},
+            {"3", NULL},
+            {"4", NULL},
+            {"5", NULL},
+            {"6", NULL},
+            {"7", NULL},
+            {"8", NULL},
+            {"9", NULL},
+            {"10", NULL},
+            {"11", NULL},
+            {"12", NULL},
+            {"13", NULL},
+            {"14", NULL},
+            {"15", NULL},
+            {"16", NULL},
+            {"17", NULL},
+            {"18", NULL},
+            {"19", NULL},
+            {"20", NULL},
+            {"21", NULL},
+            {"22", NULL},
+            {"23", NULL},
+            {"24", NULL},
+            {"25", NULL},
+            {"26", NULL},
+            {"27", NULL},
+            {"28", NULL},
+            {"29", NULL},
+            {"30", NULL},
+            {"31", NULL},
+            {"32", NULL},
+            {"33", NULL},
+            {"34", NULL},
+            {"35", NULL},
+            {"36", NULL},
+            {"37", NULL},
+            {"38", NULL},
+            {"39", NULL},
+            {"40", NULL},
+            {"41", NULL},
+            {"42", NULL},
+            {"43", NULL},
+            {"44", NULL},
+            {"45", NULL},
+            {"46", NULL},
+            {"47", NULL},
+            {"48", NULL},
+            {"49", NULL},
+            {"50", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+    {
+        CORE_NAME "-OverscanLeft",
+        "Overscan Offset (Left)",
+        "(GLN64) Overscan Left Offset.",
+        {
+            {"0", NULL},
+            {"1", NULL},
+            {"2", NULL},
+            {"3", NULL},
+            {"4", NULL},
+            {"5", NULL},
+            {"6", NULL},
+            {"7", NULL},
+            {"8", NULL},
+            {"9", NULL},
+            {"10", NULL},
+            {"11", NULL},
+            {"12", NULL},
+            {"13", NULL},
+            {"14", NULL},
+            {"15", NULL},
+            {"16", NULL},
+            {"17", NULL},
+            {"18", NULL},
+            {"19", NULL},
+            {"20", NULL},
+            {"21", NULL},
+            {"22", NULL},
+            {"23", NULL},
+            {"24", NULL},
+            {"25", NULL},
+            {"26", NULL},
+            {"27", NULL},
+            {"28", NULL},
+            {"29", NULL},
+            {"30", NULL},
+            {"31", NULL},
+            {"32", NULL},
+            {"33", NULL},
+            {"34", NULL},
+            {"35", NULL},
+            {"36", NULL},
+            {"37", NULL},
+            {"38", NULL},
+            {"39", NULL},
+            {"40", NULL},
+            {"41", NULL},
+            {"42", NULL},
+            {"43", NULL},
+            {"44", NULL},
+            {"45", NULL},
+            {"46", NULL},
+            {"47", NULL},
+            {"48", NULL},
+            {"49", NULL},
+            {"50", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+    {
+        CORE_NAME "-OverscanRight",
+        "Overscan Offset (Right)",
+        "(GLN64) Overscan Right Offset.",
+        {
+            {"0", NULL},
+            {"1", NULL},
+            {"2", NULL},
+            {"3", NULL},
+            {"4", NULL},
+            {"5", NULL},
+            {"6", NULL},
+            {"7", NULL},
+            {"8", NULL},
+            {"9", NULL},
+            {"10", NULL},
+            {"11", NULL},
+            {"12", NULL},
+            {"13", NULL},
+            {"14", NULL},
+            {"15", NULL},
+            {"16", NULL},
+            {"17", NULL},
+            {"18", NULL},
+            {"19", NULL},
+            {"20", NULL},
+            {"21", NULL},
+            {"22", NULL},
+            {"23", NULL},
+            {"24", NULL},
+            {"25", NULL},
+            {"26", NULL},
+            {"27", NULL},
+            {"28", NULL},
+            {"29", NULL},
+            {"30", NULL},
+            {"31", NULL},
+            {"32", NULL},
+            {"33", NULL},
+            {"34", NULL},
+            {"35", NULL},
+            {"36", NULL},
+            {"37", NULL},
+            {"38", NULL},
+            {"39", NULL},
+            {"40", NULL},
+            {"41", NULL},
+            {"42", NULL},
+            {"43", NULL},
+            {"44", NULL},
+            {"45", NULL},
+            {"46", NULL},
+            {"47", NULL},
+            {"48", NULL},
+            {"49", NULL},
+            {"50", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+    {
+        CORE_NAME "-OverscanBottom",
+        "Overscan Offset (Bottom)",
+        "(GLN64) Overscan Bottom Offset.",
+        {
+            {"0", NULL},
+            {"1", NULL},
+            {"2", NULL},
+            {"3", NULL},
+            {"4", NULL},
+            {"5", NULL},
+            {"6", NULL},
+            {"7", NULL},
+            {"8", NULL},
+            {"9", NULL},
+            {"10", NULL},
+            {"11", NULL},
+            {"12", NULL},
+            {"13", NULL},
+            {"14", NULL},
+            {"15", NULL},
+            {"16", NULL},
+            {"17", NULL},
+            {"18", NULL},
+            {"19", NULL},
+            {"20", NULL},
+            {"21", NULL},
+            {"22", NULL},
+            {"23", NULL},
+            {"24", NULL},
+            {"25", NULL},
+            {"26", NULL},
+            {"27", NULL},
+            {"28", NULL},
+            {"29", NULL},
+            {"30", NULL},
+            {"31", NULL},
+            {"32", NULL},
+            {"33", NULL},
+            {"34", NULL},
+            {"35", NULL},
+            {"36", NULL},
+            {"37", NULL},
+            {"38", NULL},
+            {"39", NULL},
+            {"40", NULL},
+            {"41", NULL},
+            {"42", NULL},
+            {"43", NULL},
+            {"44", NULL},
+            {"45", NULL},
+            {"46", NULL},
+            {"47", NULL},
+            {"48", NULL},
+            {"49", NULL},
+            {"50", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+    {
+        CORE_NAME "-MaxTxCacheSize",
+        "Max texture cache size",
+        "(GLN64) Set Max texture cache size (in elements). Reduce it if you experience black textures leading to a crash.",
+        {
+            {"1500", NULL},
+            {"4000", NULL},
+            {"8000", NULL},
+            {NULL, NULL},
+        },
+#if defined(VC)
+        "1500"
+#elif defined(HAVE_LIBNX)
+        "4000"
+#else
+        "8000"
+#endif
+    },
+    {
+        CORE_NAME "-txFilterMode",
+        "Texture filter",
+        "(GLN64) Select Texture Filtering mode.",
+        {
+            {"None", NULL},
+            {"Smooth filtering 1", NULL},
+            {"Smooth filtering 2", NULL},
+            {"Smooth filtering 3", NULL},
+            {"Smooth filtering 4", NULL},
+            {"Sharp filtering 1", NULL},
+            {"Sharp filtering 2", NULL},
+            {NULL, NULL},
+        },
+        "None"
+    },
+    {
+        CORE_NAME "-txEnhancementMode",
+        "Texture Enhancement",
+        "(GLN64) Various Texture Filters ('As-Is' will just cache).",
+        {
+            {"None", NULL},
+            {"As Is", NULL},
+            {"X2", NULL},
+            {"X2SAI", NULL},
+            {"HQ2X", NULL},
+            {"HQ2XS", NULL},
+            {"LQ2X", NULL},
+            {"LQ2XS", NULL},
+            {"HQ4X", NULL},
+            {"2xBRZ", NULL},
+            {"3xBRZ", NULL},
+            {"4xBRZ", NULL},
+            {"5xBRZ", NULL},
+            {"6xBRZ", NULL},
+            {NULL, NULL},
+        },
+        "None"
+    },
+    {
+        CORE_NAME "-txFilterIgnoreBG",
+        "Don't filter background textures",
+        "(GLN64) Ignore filtering for Background Textures.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "True"
+    },
+    {
+        CORE_NAME "-txHiresEnable",
+        "Use High-Res textures",
+        "(GLN64) Enable High-Res Texture packs if available.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-txCacheCompression",
+        "Use High-Res Texture Cache Compression",
+        "(GLN64) Compress created texture caches.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "True"
+    },
+    {
+        CORE_NAME "-txHiresFullAlphaChannel",
+        "Use High-Res Full Alpha Channel",
+        "(GLN64) This should be enabled unless it's a old RICE Texture pack.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-EnableEnhancedTextureStorage",
+        "Use enhanced Texture Storage",
+        "(GLN64) Use in addition to Texture cache, will use lazy loading and trade memory consumption against loading speeds.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-EnableEnhancedHighResStorage",
+        "Use enhanced Hi-Res Storage",
+        "(GLN64) Use in addition to High-Res textures, will use lazy loading and trade memory consumption against loading speeds.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+#ifdef HAVE_THR_AL
+    {
+        CORE_NAME "-angrylion-vioverlay",
+        "VI Overlay",
+        "(AL) Select VI Overlay filtering. 'Filtered' is the original system rendering.",
+        {
+            {"Filtered", NULL},
+            {"AA+Blur", NULL},
+            {"AA+Dedither", NULL},
+            {"AA only", NULL},
+            {"Unfiltered", NULL},
+            {"Depth", NULL},
+            {"Coverage", NULL},
+            {NULL, NULL},
+        },
+        "Filtered"
+    },
+    {
+        CORE_NAME "-angrylion-sync",
+        "Thread sync level",
+        "(AL) Select Sync level (trades accuracy for performance).",
+        {
+            {"Low", NULL},
+            {"Medium", NULL},
+            {"High", NULL},
+            {NULL, NULL},
+        },
+        "Low"
+    },
+    {
+        CORE_NAME "-angrylion-multithread",
+        "Multi-threading",
+        "(AL) Default 'all threads' is prefered to have it match your Physical CPU Core count. '1' should behave as the original angrylion, possibly fixing some bugs.",
+        {
+            {"all threads", NULL},
+            {"1", NULL},
+            {"2", NULL},
+            {"3", NULL},
+            {"4", NULL},
+            {"5", NULL},
+            {"6", NULL},
+            {"7", NULL},
+            {"8", NULL},
+            {"9", NULL},
+            {"10", NULL},
+            {"11", NULL},
+            {"12", NULL},
+            {"13", NULL},
+            {"14", NULL},
+            {"15", NULL},
+            {"16", NULL},
+            {"17", NULL},
+            {"18", NULL},
+            {"19", NULL},
+            {"20", NULL},
+            {"21", NULL},
+            {"22", NULL},
+            {"23", NULL},
+            {"24", NULL},
+            {"25", NULL},
+            {"26", NULL},
+            {"27", NULL},
+            {"28", NULL},
+            {"29", NULL},
+            {"30", NULL},
+            {"31", NULL},
+            {"32", NULL},
+            {"33", NULL},
+            {"34", NULL},
+            {"35", NULL},
+            {"36", NULL},
+            {"37", NULL},
+            {"38", NULL},
+            {"39", NULL},
+            {"40", NULL},
+            {"41", NULL},
+            {"42", NULL},
+            {"43", NULL},
+            {"44", NULL},
+            {"45", NULL},
+            {"46", NULL},
+            {"47", NULL},
+            {"48", NULL},
+            {"49", NULL},
+            {"50", NULL},
+            {"51", NULL},
+            {"52", NULL},
+            {"53", NULL},
+            {"54", NULL},
+            {"55", NULL},
+            {"56", NULL},
+            {"57", NULL},
+            {"58", NULL},
+            {"59", NULL},
+            {"60", NULL},
+            {"61", NULL},
+            {"62", NULL},
+            {"63", NULL},
+            {"75", NULL},
+            {NULL, NULL},
+        },
+        "all threads"
+    },
+    {
+        CORE_NAME "-angrylion-overscan",
+        "Hide overscan",
+        "(AL) Hide overscan borders.",
+        {
+            {"disabled", NULL},
+            {"enabled", NULL},
+            {NULL, NULL},
+        },
+        "disabled"
+    },
+#endif
+    {
+        CORE_NAME "-FrameDuping",
+        "Frame Duplication",
+        "Enable Frame duplication to improve smoothing on low-end. Different from frameskip.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+#ifdef HAVE_LIBNX
+        "True"
+#else
+        "False"
+#endif
+    },
+    {
+        CORE_NAME "-Framerate",
+        "Framerate",
+        "Fullspeed will enforce Count per Op 1 and FBEmu settings, this will break some games!",
+        {
+            {"Original", NULL},
+            {"Fullspeed", NULL},
+            {NULL, NULL},
+        },
+        "Original"
+    },
+    {
+        CORE_NAME "-virefresh",
+        "VI Refresh (Overclock)",
+        "Select a VI Refresh clock, Auto does not impact behaviour, other values override CountPerScanline.",
+        {
+            {"Auto", NULL},
+            {"1500", NULL},
+            {"2200", NULL},
+            {NULL, NULL},
+        },
+        "Auto"
+    },
+    {
+        CORE_NAME "-astick-deadzone",
+        "Analog Deadzone (percent)",
+        "Size of the non responsive area around an analog stick.",
+        {
+            {"0", NULL},
+            {"5", NULL},
+            {"10", NULL},
+            {"15", NULL},
+            {"20", NULL},
+            {"25", NULL},
+            {"30", NULL},
+            {NULL, NULL},
+        },
+        "15"
+    },
+    {
+        CORE_NAME "-astick-sensitivity",
+        "Analog Sensitivity (percent)",
+        "Adjust how far the stick needs to be moved to reach its max value.",
+        {
+            {"50", NULL},
+            {"55", NULL},
+            {"60", NULL},
+            {"65", NULL},
+            {"70", NULL},
+            {"75", NULL},
+            {"80", NULL},
+            {"85", NULL},
+            {"90", NULL},
+            {"95", NULL},
+            {"100", NULL},
+            {"105", NULL},
+            {"110", NULL},
+            {"115", NULL},
+            {"120", NULL},
+            {"125", NULL},
+            {"130", NULL},
+            {"135", NULL},
+            {"140", NULL},
+            {"145", NULL},
+            {"150", NULL},
+            {NULL, NULL},
+        },
+        "100"
+    },
+    {
+        CORE_NAME "-r-cbutton",
+        "Right C Button",
+        "Select Right C Button mapping.",
+        {
+            {"C1", NULL},
+            {"C2", NULL},
+            {"C3", NULL},
+            {"C4", NULL},
+            {NULL, NULL},
+        },
+        "C1"
+    },
+    {
+        CORE_NAME "-l-cbutton",
+        "Left C Button",
+        "Select Left C Button mapping.",
+        {
+            {"C1", NULL},
+            {"C2", NULL},
+            {"C3", NULL},
+            {"C4", NULL},
+            {NULL, NULL},
+        },
+        "C2"
+    },
+    {
+        CORE_NAME "-d-cbutton",
+        "Down C Button",
+        "Select Down C Button mapping.",
+        {
+            {"C1", NULL},
+            {"C2", NULL},
+            {"C3", NULL},
+            {"C4", NULL},
+            {NULL, NULL},
+        },
+        "C3"
+    },
+    {
+        CORE_NAME "-u-cbutton",
+        "Up C Button",
+        "Select Up C Button mapping.",
+        {
+            {"C1", NULL},
+            {"C2", NULL},
+            {"C3", NULL},
+            {"C4", NULL},
+            {NULL, NULL},
+        },
+        "C4"
+    },
+    {
+        CORE_NAME "-alt-map",
+        "Independent C-button Controls",
+        "Use an alternate control scheme, useful for some 3rdparty controllers.",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-ForceDisableExtraMem",
+        "Disable Expansion Pak",
+        "Force disable Expansion Pak (might improve performance for some games while reducing emulation accuracy, will break games that require it).",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False"
+    },
+    {
+        CORE_NAME "-pak1",
+        "Player 1 Pak",
+        "Select Payer 1 Controller Pak.",
+        {
+            {"none", NULL},
+            {"memory", NULL},
+            {"rumble", NULL},
+            {NULL, NULL},
+        },
+        "memory"
+    },
+    {
+        CORE_NAME "-pak2",
+        "Player 2 Pak",
+        "Select Payer 2 Controller Pak.",
+        {
+            {"none", NULL},
+            {"memory", NULL},
+            {"rumble", NULL},
+            {NULL, NULL},
+        },
+        "none"
+    },
+    {
+        CORE_NAME "-pak3",
+        "Player 3 Pak",
+        "Select Payer 3 Controller Pak.",
+        {
+            {"none", NULL},
+            {"memory", NULL},
+            {"rumble", NULL},
+            {NULL, NULL},
+        },
+        "none"
+    },
+    {
+        CORE_NAME "-pak4",
+        "Player 4 Pak",
+        "Select Payer 4 Controller Pak.",
+        {
+            {"none", NULL},
+            {"memory", NULL},
+            {"rumble", NULL},
+            {NULL, NULL},
+        },
+        "none"
+    },
+    {
+        CORE_NAME "-CountPerOp",
+        "Count Per Op",
+        "Count per Op is used to approximate the Counter reg, 0 will use the embedded Database (or default to 2). Changing this will break stuff!",
+        {
+            {"0", NULL},
+            {"1", NULL},
+            {"2", NULL},
+            {"3", NULL},
+            {NULL, NULL},
+        },
+        "0"
+    },
+    {NULL, NULL, NULL, {{0}}, NULL},
+};
+
+struct retro_core_option_definition *option_defs_intl[RETRO_LANGUAGE_LAST] = {
+    option_defs_us, /* RETRO_LANGUAGE_ENGLISH */
+    NULL,           /* RETRO_LANGUAGE_JAPANESE */
+    NULL,           /* RETRO_LANGUAGE_FRENCH */
+    NULL,           /* RETRO_LANGUAGE_SPANISH */
+    NULL,           /* RETRO_LANGUAGE_GERMAN */
+    NULL,           /* RETRO_LANGUAGE_ITALIAN */
+    NULL,           /* RETRO_LANGUAGE_DUTCH */
+    NULL,           /* RETRO_LANGUAGE_PORTUGUESE_BRAZIL */
+    NULL,           /* RETRO_LANGUAGE_PORTUGUESE_PORTUGAL */
+    NULL,           /* RETRO_LANGUAGE_RUSSIAN */
+    NULL,           /* RETRO_LANGUAGE_KOREAN */
+    NULL,           /* RETRO_LANGUAGE_CHINESE_TRADITIONAL */
+    NULL,           /* RETRO_LANGUAGE_CHINESE_SIMPLIFIED */
+    NULL,           /* RETRO_LANGUAGE_ESPERANTO */
+    NULL,           /* RETRO_LANGUAGE_POLISH */
+    NULL,           /* RETRO_LANGUAGE_VIETNAMESE */
+    NULL,           /* RETRO_LANGUAGE_ARABIC */
+    NULL,           /* RETRO_LANGUAGE_GREEK */
+    NULL,           /* RETRO_LANGUAGE_TURKISH */
+};
+
+static INLINE void libretro_set_core_options(retro_environment_t environ_cb)
+{
+    unsigned version = 0;
+
+    if (!environ_cb)
+        return;
+
+    if (environ_cb(RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION, &version) && (version == 1))
+    {
+        struct retro_core_options_intl core_options_intl;
+        unsigned language = 0;
+
+        core_options_intl.us = option_defs_us;
+        core_options_intl.local = NULL;
+
+        if (environ_cb(RETRO_ENVIRONMENT_GET_LANGUAGE, &language) &&
+            (language < RETRO_LANGUAGE_LAST) && (language != RETRO_LANGUAGE_ENGLISH))
+            core_options_intl.local = option_defs_intl[language];
+
+        environ_cb(RETRO_ENVIRONMENT_SET_CORE_OPTIONS_INTL, &core_options_intl);
+    }
+    else
+    {
+        size_t i;
+        size_t option_index = 0;
+        size_t num_options = 0;
+        struct retro_variable *variables = NULL;
+        char **values_buf = NULL;
+
+        /* Determine number of options
+    * > Note: We are going to skip a number of irrelevant
+    *   core options when building the retro_variable array,
+    *   but we'll allocate space for all of them. The difference
+    *   in resource usage is negligible, and this allows us to
+    *   keep the code 'cleaner' */
+        while (true)
+        {
+            if (option_defs_us[num_options].key)
+                num_options++;
+            else
+                break;
+        }
+
+        /* Allocate arrays */
+        variables = (struct retro_variable *)calloc(num_options + 1, sizeof(struct retro_variable));
+        values_buf = (char **)calloc(num_options, sizeof(char *));
+
+        if (!variables || !values_buf)
+            goto error;
+
+        /* Copy parameters from option_defs_us array */
+        for (i = 0; i < num_options; i++)
+        {
+            const char *key = option_defs_us[i].key;
+            const char *desc = option_defs_us[i].desc;
+            const char *default_value = option_defs_us[i].default_value;
+            struct retro_core_option_value *values = option_defs_us[i].values;
+            size_t buf_len = 3;
+            size_t default_index = 0;
+
+            values_buf[i] = NULL;
+
+            if (desc)
+            {
+                size_t num_values = 0;
+
+                /* Determine number of values */
+                while (true)
+                {
+                    if (values[num_values].value)
+                    {
+                        /* Check if this is the default value */
+                        if (default_value)
+                            if (strcmp(values[num_values].value, default_value) == 0)
+                                default_index = num_values;
+
+                        buf_len += strlen(values[num_values].value);
+                        num_values++;
+                    }
+                    else
+                        break;
+                }
+
+                /* Build values string */
+                if (num_values > 1)
+                {
+                    size_t j;
+
+                    buf_len += num_values - 1;
+                    buf_len += strlen(desc);
+
+                    values_buf[i] = (char *)calloc(buf_len, sizeof(char));
+                    if (!values_buf[i])
+                        goto error;
+
+                    strcpy(values_buf[i], desc);
+                    strcat(values_buf[i], "; ");
+
+                    /* Default value goes first */
+                    strcat(values_buf[i], values[default_index].value);
+
+                    /* Add remaining values */
+                    for (j = 0; j < num_values; j++)
+                    {
+                        if (j != default_index)
+                        {
+                            strcat(values_buf[i], "|");
+                            strcat(values_buf[i], values[j].value);
+                        }
+                    }
+                }
+            }
+
+            variables[option_index].key = key;
+            variables[option_index].value = values_buf[i];
+            option_index++;
+        }
+
+        /* Set variables */
+        environ_cb(RETRO_ENVIRONMENT_SET_VARIABLES, variables);
+
+    error:
+
+        /* Clean up */
+        if (values_buf)
+        {
+            for (i = 0; i < num_options; i++)
+            {
+                if (values_buf[i])
+                {
+                    free(values_buf[i]);
+                    values_buf[i] = NULL;
+                }
+            }
+
+            free(values_buf);
+            values_buf = NULL;
+        }
+
+        if (variables)
+        {
+            free(variables);
+            variables = NULL;
+        }
+    }
+}
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/mupen64plus-core/src/device/rcp/vi/vi_controller.c b/mupen64plus-core/src/device/rcp/vi/vi_controller.c
index 744212aa..b2e0e98c 100644
--- a/mupen64plus-core/src/device/rcp/vi/vi_controller.c
+++ b/mupen64plus-core/src/device/rcp/vi/vi_controller.c
@@ -29,7 +29,7 @@
 #include "device/rcp/mi/mi_controller.h"
 #include "main/main.h"
 #include "plugin/plugin.h"
-#include "../../../../../custom/GLideN64/GLideN64_libretro.h"
+#include <mupen64plus-next_common.h>
 
 unsigned int vi_clock_from_tv_standard(m64p_system_type tv_standard)
 {
diff --git a/mupen64plus-core/src/main/main.c b/mupen64plus-core/src/main/main.c
index fc61d302..55ae4838 100644
--- a/mupen64plus-core/src/main/main.c
+++ b/mupen64plus-core/src/main/main.c
@@ -82,8 +82,8 @@
 
 #ifdef __LIBRETRO__
 #include <file/file_path.h>
-#include "../../../libretro/libretro_memory.h"
-#include "../../../custom/GLideN64/GLideN64_libretro.h"
+#include <libretro_memory.h>
+#include <mupen64plus-next_common.h>
 extern retro_environment_t environ_cb;
 extern char* retro_dd_path_img;
 extern char* retro_dd_path_rom;

From 94eeea3a110a4775cc29171ebaad7c78add6fd63 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 12:54:12 +0200
Subject: [PATCH 09/28] git subrepo push mupen64plus-core

subrepo:
  subdir:   "mupen64plus-core"
  merged:   "5f6b7b8e"
upstream:
  origin:   "https://github.com/libretro/mupen64plus-core.git"
  branch:   "rebase"
  commit:   "5f6b7b8e"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 mupen64plus-core/.gitrepo | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/mupen64plus-core/.gitrepo b/mupen64plus-core/.gitrepo
index 0e1ad4dc..e4ba1c29 100644
--- a/mupen64plus-core/.gitrepo
+++ b/mupen64plus-core/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = https://github.com/libretro/mupen64plus-core.git
 	branch = rebase
-	commit = 62dbd20030039bbf1aad36860df20ac54bfcfe27
-	parent = 083235485f6cab948f80e0d9cc1263a0562b0399
+	commit = 5f6b7b8ee0130cbca152166eae1da9455a276d4a
+	parent = 905a026d587800dae7a8ec4e4a2aa679457f17cc
 	method = rebase
 	cmdver = 0.4.0

From 4bef4f21a5c57748fddc04f7f1a3710ee6e94dc0 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 12:54:50 +0200
Subject: [PATCH 10/28] git subrepo push GLideN64

subrepo:
  subdir:   "GLideN64"
  merged:   "f53bc5e6"
upstream:
  origin:   "git@github.com:libretro/GLideN64.git"
  branch:   "rebase"
  commit:   "f53bc5e6"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 GLideN64/.gitrepo | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/GLideN64/.gitrepo b/GLideN64/.gitrepo
index db1534a1..2582df20 100644
--- a/GLideN64/.gitrepo
+++ b/GLideN64/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = git@github.com:libretro/GLideN64.git
 	branch = rebase
-	commit = 589b1b617c11cfee99fd87d5db0fb42752c21942
-	parent = 2171d0866885ad820fdf1da96073e5025f648c89
+	commit = f53bc5e6fe8f13a7657c3714d0323da9b61e597a
+	parent = 94eeea3a110a4775cc29171ebaad7c78add6fd63
 	method = rebase
 	cmdver = 0.4.0

From 3e29f5cda15e8975e32918d6048c2fe55dfe8381 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 12:56:20 +0200
Subject: [PATCH 11/28] git subrepo push mupen64plus-rsp-hle

subrepo:
  subdir:   "mupen64plus-rsp-hle"
  merged:   "932014af"
upstream:
  origin:   "https://github.com/libretro/mupen64plus-rsp-hle.git"
  branch:   "master"
  commit:   "932014af"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 mupen64plus-rsp-hle/.gitrepo | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/mupen64plus-rsp-hle/.gitrepo b/mupen64plus-rsp-hle/.gitrepo
index 1d66d27c..5b07a125 100644
--- a/mupen64plus-rsp-hle/.gitrepo
+++ b/mupen64plus-rsp-hle/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = https://github.com/libretro/mupen64plus-rsp-hle.git
 	branch = master
-	commit = 8510c79723e4e0ee5e31c1b47c76020a45b14413
-	parent = 6d1638583bdd9486ae6826506e7923211bac43a9
+	commit = 932014af4eaff529857f97857871fb0b5ef7a3c8
+	parent = 4bef4f21a5c57748fddc04f7f1a3710ee6e94dc0
 	method = rebase
 	cmdver = 0.4.0

From c3dc5096835e578ecddd84704c1e996fc4c367df Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 13:01:08 +0200
Subject: [PATCH 12/28] git subrepo clone --force --branch=rebase
 git@github.com:libretro/GLideN64.git GLideN64

subrepo:
  subdir:   "GLideN64"
  merged:   "494227c4"
upstream:
  origin:   "git@github.com:libretro/GLideN64.git"
  branch:   "rebase"
  commit:   "494227c4"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 GLideN64/.gitrepo                             |   4 +-
 .../src/BufferCopy/ColorBufferToRDRAM.cpp     |   8 +-
 .../src/BufferCopy/RDRAMtoColorBuffer.cpp     |   3 +
 GLideN64/src/Combiner.cpp                     |  30 +-
 GLideN64/src/Combiner.h                       |  12 +-
 GLideN64/src/Debugger.cpp                     |  87 ++-
 GLideN64/src/Debugger.h                       |   1 +
 GLideN64/src/FrameBuffer.cpp                  |  39 +-
 GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp       |   4 +-
 GLideN64/src/GLideNUI-wtl/GLideNUI.rc         | Bin 53324 -> 53324 bytes
 GLideN64/src/GLideNUI-wtl/Settings.cpp        |   2 +
 .../src/GLideNUI-wtl/config-framebuffer.cpp   |   2 +-
 GLideN64/src/GLideNUI-wtl/config-osd.cpp      |  20 +-
 GLideN64/src/GLideNUI-wtl/config-texture.cpp  |   4 +-
 GLideN64/src/GLideNUI-wtl/config-video.cpp    |  91 ++-
 GLideN64/src/GLideNUI-wtl/config-video.h      |   3 +
 GLideN64/src/GLideNUI-wtl/wtl-tooltip.h       |   2 +-
 GLideN64/src/Graphics/Context.cpp             |  18 +-
 GLideN64/src/Graphics/Context.h               |   8 +-
 GLideN64/src/Graphics/ContextImpl.h           |   6 +-
 .../GLSL/glsl_CombinerProgramBuilder.cpp      | 737 ++++++++++--------
 .../GLSL/glsl_CombinerProgramBuilder.h        |   8 +-
 .../glsl_CombinerProgramUniformFactory.cpp    | 156 ++--
 .../OpenGLContext/GLSL/glsl_ShaderStorage.h   |   2 +-
 .../GLSL/glsl_SpecialShadersFactory.cpp       | 272 ++++---
 .../GLSL/glsl_SpecialShadersFactory.h         |   8 +-
 .../OpenGLContext/opengl_ContextImpl.cpp      |  18 +-
 .../OpenGLContext/opengl_ContextImpl.h        |   8 +-
 GLideN64/src/GraphicsDrawer.cpp               |  32 +-
 GLideN64/src/GraphicsDrawer.h                 |  13 +-
 GLideN64/src/Textures.cpp                     |  25 +-
 GLideN64/src/Textures.h                       |   1 +
 GLideN64/src/gSP.cpp                          |  27 +-
 GLideN64/src/gSP.h                            |   1 +
 34 files changed, 1019 insertions(+), 633 deletions(-)

diff --git a/GLideN64/.gitrepo b/GLideN64/.gitrepo
index 2582df20..0a84ee67 100644
--- a/GLideN64/.gitrepo
+++ b/GLideN64/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = git@github.com:libretro/GLideN64.git
 	branch = rebase
-	commit = f53bc5e6fe8f13a7657c3714d0323da9b61e597a
-	parent = 94eeea3a110a4775cc29171ebaad7c78add6fd63
+	commit = 494227c4df80df4a3ba852320dbd15624350fa32
+	parent = 3e29f5cda15e8975e32918d6048c2fe55dfe8381
 	method = rebase
 	cmdver = 0.4.0
diff --git a/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp b/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp
index d8784f76..464ed433 100644
--- a/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp
+++ b/GLideN64/src/BufferCopy/ColorBufferToRDRAM.cpp
@@ -219,9 +219,9 @@ bool ColorBufferToRDRAM::_prepareCopy(u32& _startAddress)
 		blitParams.dstY1 = bufferHeight;
 		blitParams.dstWidth = m_pTexture->width;
 		blitParams.dstHeight = m_pTexture->height;
-		blitParams.filter = textureParameters::FILTER_NEAREST;
+		blitParams.filter = textureParameters::FILTER_LINEAR;
 		blitParams.tex[0] = pInputTexture;
-		blitParams.combiner = CombinerInfo::get().getTexrectCopyProgram();
+		blitParams.combiner = CombinerInfo::get().getTexrectDownscaleCopyProgram();
 		blitParams.readBuffer = readBuffer;
 		blitParams.drawBuffer = m_FBO;
 		blitParams.mask = blitMask::COLOR_BUFFER;
@@ -260,7 +260,7 @@ u16 ColorBufferToRDRAM::_RGBAtoRGBA16(u32 _c, u32 x, u32 y) {
 
 	union RGBA c;
 	c.raw = _c;
-	
+
 	if (config.generalEmulation.enableDitheringPattern == 0 || config.frameBufferEmulation.nativeResFactor != 1) {
 		// Apply color dithering
 		switch (config.generalEmulation.rdramImageDitheringMode) {
@@ -286,7 +286,7 @@ u16 ColorBufferToRDRAM::_RGBAtoRGBA16(u32 _c, u32 x, u32 y) {
 		}
 	}
 
-	return ((c.r >> 3) << 11) | ((c.g >> 3) << 6) | ((c.b >> 3) << 1) | (c.a == 0 ? 0 : 1);	
+	return ((c.r >> 3) << 11) | ((c.g >> 3) << 6) | ((c.b >> 3) << 1) | (c.a == 0 ? 0 : 1);
 }
 
 u32 ColorBufferToRDRAM::_RGBAtoRGBA32(u32 _c, u32 x, u32 y) {
diff --git a/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp b/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp
index f0bc76c3..37e9ee58 100644
--- a/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp
+++ b/GLideN64/src/BufferCopy/RDRAMtoColorBuffer.cpp
@@ -45,6 +45,9 @@ void RDRAMtoColorBuffer::init()
 	m_pTexture->height = 580;
 	m_pTexture->textureBytes = m_pTexture->width * m_pTexture->height * fbTexFormats.colorFormatBytes;
 
+	m_pTexture->hdRatioS = 1.0f;
+	m_pTexture->hdRatioT = 1.0f;
+
 	Context::InitTextureParams initParams;
 	initParams.handle = m_pTexture->name;
 	initParams.width = m_pTexture->width;
diff --git a/GLideN64/src/Combiner.cpp b/GLideN64/src/Combiner.cpp
index 8f2edb98..7cadc5ef 100644
--- a/GLideN64/src/Combiner.cpp
+++ b/GLideN64/src/Combiner.cpp
@@ -111,15 +111,19 @@ void CombinerInfo::init()
 	}
 
 	m_shadowmapProgram.reset(gfxContext.createDepthFogShader());
-	m_texrectCopyProgram.reset(gfxContext.createTexrectCopyShader());
-	m_texrectColorAndDepthCopyProgram.reset(gfxContext.createTexrectColorAndDepthCopyShader());
+	m_texrectUpscaleCopyProgram.reset(gfxContext.createTexrectUpscaleCopyShader());
+	m_texrectColorAndDepthUpscaleCopyProgram.reset(gfxContext.createTexrectColorAndDepthUpscaleCopyShader());
+	m_texrectDownscaleCopyProgram.reset(gfxContext.createTexrectDownscaleCopyShader());
+	m_texrectColorAndDepthDownscaleCopyProgram.reset(gfxContext.createTexrectColorAndDepthDownscaleCopyShader());
 }
 
 void CombinerInfo::destroy()
 {
 	m_shadowmapProgram.reset();
-	m_texrectCopyProgram.reset();
-	m_texrectColorAndDepthCopyProgram.reset();
+	m_texrectUpscaleCopyProgram.reset();
+	m_texrectColorAndDepthUpscaleCopyProgram.reset();
+	m_texrectDownscaleCopyProgram.reset();
+	m_texrectColorAndDepthDownscaleCopyProgram.reset();
 
 	m_pCurrent = nullptr;
 	if (config.generalEmulation.enableShadersStorage != 0)
@@ -315,14 +319,24 @@ void CombinerInfo::setDepthFogCombiner()
 	}
 }
 
-ShaderProgram * CombinerInfo::getTexrectCopyProgram()
+ShaderProgram * CombinerInfo::getTexrectUpscaleCopyProgram()
 {
-	return m_texrectCopyProgram.get();
+	return m_texrectUpscaleCopyProgram.get();
 }
 
-ShaderProgram * CombinerInfo::getTexrectColorAndDepthCopyProgram()
+ShaderProgram * CombinerInfo::getTexrectColorAndDepthUpscaleCopyProgram()
 {
-	return m_texrectColorAndDepthCopyProgram.get();
+	return m_texrectColorAndDepthUpscaleCopyProgram.get();
+}
+
+ShaderProgram * CombinerInfo::getTexrectDownscaleCopyProgram()
+{
+	return m_texrectDownscaleCopyProgram.get();
+}
+
+ShaderProgram * CombinerInfo::getTexrectColorAndDepthDownscaleCopyProgram()
+{
+	return m_texrectColorAndDepthDownscaleCopyProgram.get();
 }
 
 bool CombinerInfo::isShaderCacheSupported() const
diff --git a/GLideN64/src/Combiner.h b/GLideN64/src/Combiner.h
index 46456d4b..603494a2 100644
--- a/GLideN64/src/Combiner.h
+++ b/GLideN64/src/Combiner.h
@@ -127,8 +127,10 @@ class CombinerInfo
 	void updateParameters();
 
 	void setDepthFogCombiner();
-	graphics::ShaderProgram * getTexrectCopyProgram();
-	graphics::ShaderProgram * getTexrectColorAndDepthCopyProgram();
+	graphics::ShaderProgram * getTexrectUpscaleCopyProgram();
+	graphics::ShaderProgram * getTexrectColorAndDepthUpscaleCopyProgram();
+	graphics::ShaderProgram * getTexrectDownscaleCopyProgram();
+	graphics::ShaderProgram * getTexrectColorAndDepthDownscaleCopyProgram();
 
 	graphics::CombinerProgram * getCurrent() const { return m_pCurrent; }
 	bool isChanged() const {return m_bChanged;}
@@ -160,8 +162,10 @@ class CombinerInfo
 	graphics::Combiners m_combiners;
 
 	std::unique_ptr<graphics::ShaderProgram> m_shadowmapProgram;
-	std::unique_ptr<graphics::ShaderProgram> m_texrectCopyProgram;
-	std::unique_ptr<graphics::ShaderProgram> m_texrectColorAndDepthCopyProgram;
+	std::unique_ptr<graphics::ShaderProgram> m_texrectUpscaleCopyProgram;
+	std::unique_ptr<graphics::ShaderProgram> m_texrectColorAndDepthUpscaleCopyProgram;
+	std::unique_ptr<graphics::ShaderProgram> m_texrectDownscaleCopyProgram;
+	std::unique_ptr<graphics::ShaderProgram> m_texrectColorAndDepthDownscaleCopyProgram;
 };
 
 inline
diff --git a/GLideN64/src/Debugger.cpp b/GLideN64/src/Debugger.cpp
index ff41337d..63419968 100644
--- a/GLideN64/src/Debugger.cpp
+++ b/GLideN64/src/Debugger.cpp
@@ -261,6 +261,8 @@ void Debugger::_fillTriInfo(TriInfo & _info)
 	_info.prim_color = gDP.primColor;
 	_info.primDepthZ = gDP.primDepth.z;
 	_info.primDepthDeltaZ = gDP.primDepth.deltaZ;
+	_info.fogMultiplier = gSP.fog.multiplierf;
+	_info.fogOffset = gSP.fog.offsetf;
 	_info.K4 = gDP.convert.k4;
 	_info.K5 = gDP.convert.k5;
 	_info.viewport = gSP.viewport;
@@ -460,6 +462,7 @@ void Debugger::_drawTriangleFrame()
 void Debugger::_drawTextureCache()
 {
 	DisplayWindow & wnd = dwnd();
+	TextureCache & cache = textureCache();
 
 	const s32 hOffset = (wnd.getScreenWidth() - wnd.getWidth()) / 2;
 	const s32 vOffset = (wnd.getScreenHeight() - wnd.getHeight()) / 2 + wnd.getHeightOffset();
@@ -567,12 +570,12 @@ void Debugger::_drawTextureCache()
 
 			rect[0].s0 = 0;
 			rect[0].t0 = 0;
-			rect[1].s0 = 1;
+			rect[1].s0 = (*infoIter)->texture->width;
 			rect[1].t0 = 0;
 			rect[2].s0 = 0;
-			rect[2].t0 = 1;
-			rect[3].s0 = 1;
-			rect[3].t0 = 1;
+			rect[2].t0 = (*infoIter)->texture->height;
+			rect[3].s0 = rect[1].s0;
+			rect[3].t0 = rect[2].t0;
 
 			if (r == m_selectedTexPos[m_tmu].row && c == m_selectedTexPos[m_tmu].col) {
 				memcpy(rectSelected, rect, sizeof(rect));
@@ -584,13 +587,17 @@ void Debugger::_drawTextureCache()
 			texParams.textureUnitIndex = textureIndices::Tex[0];
 			texParams.minFilter = textureParameters::FILTER_NEAREST;
 			texParams.magFilter = textureParameters::FILTER_NEAREST;
+			texParams.wrapS = textureParameters::WRAP_CLAMP_TO_EDGE;
+			texParams.wrapT = textureParameters::WRAP_CLAMP_TO_EDGE;
 			gfxContext.setTextureParameters(texParams);
 
+			cache.current[0] = const_cast<CachedTexture*>((*infoIter)->texture);
 			Context::DrawRectParameters rectParams;
 			rectParams.mode = drawmode::TRIANGLE_STRIP;
 			rectParams.verticesCount = 4;
 			rectParams.vertices = rect;
 			rectParams.combiner = currentCombiner();
+			currentCombiner()->update(false);
 			gfxContext.drawRects(rectParams);
 
 			X += rectWidth;
@@ -629,8 +636,6 @@ void Debugger::_drawFrameBuffer(FrameBuffer * _pBuffer)
 	float clearColor[4] = { 0.0f, 0.0f, 0.0f, 0.0f };
 	drawer.clearColorBuffer(clearColor);
 
-	TextureParam filter = textureParameters::FILTER_LINEAR;
-
 	GraphicsDrawer::BlitOrCopyRectParams blitParams;
 	blitParams.srcX0 = srcCoord[0];
 	blitParams.srcY0 = srcCoord[3];
@@ -644,10 +649,14 @@ void Debugger::_drawFrameBuffer(FrameBuffer * _pBuffer)
 	blitParams.dstY1 = dstCoord[3];
 	blitParams.dstWidth = wnd.getScreenWidth();
 	blitParams.dstHeight = wnd.getScreenHeight() + wnd.getHeightOffset();
-	blitParams.filter = filter;
+	blitParams.filter = config.generalEmulation.enableHybridFilter > 0 ?
+		textureParameters::FILTER_LINEAR :
+		textureParameters::FILTER_NEAREST;
 	blitParams.mask = blitMask::COLOR_BUFFER;
 	blitParams.tex[0] = pBufferTexture;
-	blitParams.combiner = CombinerInfo::get().getTexrectCopyProgram();
+	const bool downscale = blitParams.srcWidth >= blitParams.dstWidth && blitParams.srcHeight >= blitParams.dstHeight;
+	blitParams.combiner = downscale ? CombinerInfo::get().getTexrectDownscaleCopyProgram() :
+		CombinerInfo::get().getTexrectUpscaleCopyProgram();
 	blitParams.readBuffer = readBuffer;
 
 	drawer.blitOrCopyTexturedRect(blitParams);
@@ -748,7 +757,7 @@ void Debugger::_drawTex(f32 _ulx, f32 _uly, f32 _yShift)
 	}
 	const CachedTexture * texture = m_triSel->tex_info[tex]->texture;
 	const gDPLoadTileInfo & texLoadInfo = m_triSel->tex_info[tex]->texLoadInfo;
-	OUTPUT1("CRC: 0x%08x", texture->crc);
+	OUTPUT1("CRC: 0x%llx", texture->crc);
 	OUTPUT1("tex_size: %s", ImageSizeText[texture->size]);
 	OUTPUT1("tex_format: %s", ImageFormatText[texture->format]);
 	OUTPUT1("width: %d", texture->width);
@@ -982,7 +991,23 @@ void Debugger::_drawVertexCoords(f32 _ulx, f32 _uly, f32 _yShift)
 			OUTPUT2("v[%d].r: %.2f", j, v.r);
 			OUTPUT2("v[%d].g: %.2f", j, v.g);
 			OUTPUT2("v[%d].b: %.2f", j, v.b);
-			OUTPUT2("v[%d].a: %.2f", j, v.a);
+			if (RSP.LLE) {
+				OUTPUT2("v[%d].a: %.2f", j, v.a);
+			}
+			else {
+				if ((m_triSel->geometryMode & G_FOG) == 0) {
+					OUTPUT2("v[%d].a: %.2f", j, v.a);
+				}
+				else {
+					f32 f = v.z / v.w * m_triSel->fogMultiplier + m_triSel->fogOffset;
+					if (f < 0.0f)
+						f = 0.0f;
+					if (f > 1.0f)
+						f = 1.0f;
+					OUTPUT2("v[%d].a: %.2f", j, f);
+				}
+			}
+
 		}
 		return;
 	}
@@ -1007,7 +1032,8 @@ void Debugger::_drawTexture(f32 _ulx, f32 _uly, f32 _lrx, f32 _lry, f32 _yShift)
 	OUTPUT0("TEXTURE (page 0)");
 	if (m_pCurTexInfo == nullptr)
 		return;
-	const CachedTexture * texture = m_pCurTexInfo->texture;
+	const CachedTexture * pTexture = m_pCurTexInfo->texture;
+	textureCache().current[0] = const_cast<CachedTexture *>(pTexture);
 	const gDPLoadTileInfo & texLoadInfo = m_pCurTexInfo->texLoadInfo;
 
 	COL_TEXT();
@@ -1015,17 +1041,17 @@ void Debugger::_drawTexture(f32 _ulx, f32 _uly, f32 _lrx, f32 _lry, f32 _yShift)
 	OUTPUT1("scale_s: %f", m_pCurTexInfo->scales);
 	OUTPUT1("scale_t: %f", m_pCurTexInfo->scalet);
 	OUTPUT1("load: %s", LoadType[texLoadInfo.loadType&1]);
-	OUTPUT1("t_mem: %04x", texture->tMem);
+	OUTPUT1("t_mem: %04x", pTexture->tMem);
+	OUTPUT1("framebuffer: %s", FrameBufferType[(u32)pTexture->frameBufferTexture]);
+	OUTPUT1("crc: %llx", pTexture->crc);
 	//	OUTPUT1("texrecting: %d", cache[_debugger.tex_sel].texrecting);
-	OUTPUT1("tex_size: %s", ImageSizeText[texture->size]);
-	OUTPUT1("tex_format: %s", ImageFormatText[texture->format]);
-	OUTPUT1("width: %d", texture->width);
-	OUTPUT1("height: %d", texture->height);
-	OUTPUT1("palette: %d", texture->palette);
-	OUTPUT1("line: %d", texture->line);
-	OUTPUT1("lod: %d", texture->max_level);
-	OUTPUT1("framebuffer: %s", FrameBufferType[(u32)texture->frameBufferTexture]);
-	OUTPUT1("crc: %08x", texture->crc);
+	OUTPUT1("tex_size: %s", ImageSizeText[pTexture->size]);
+	OUTPUT1("tex_format: %s", ImageFormatText[pTexture->format]);
+	OUTPUT1("width: %d", pTexture->width);
+	OUTPUT1("height: %d", pTexture->height);
+	OUTPUT1("palette: %d", pTexture->palette);
+	OUTPUT1("line: %d", pTexture->line);
+	OUTPUT1("lod: %d", pTexture->max_level);
 
 	const f32 Z = 0.0f;
 	const f32 W = 1.0f;
@@ -1052,14 +1078,14 @@ void Debugger::_drawTexture(f32 _ulx, f32 _uly, f32 _lrx, f32 _lry, f32 _yShift)
 		height = fabsf(_lry - uly);
 	}
 
-	if (texture->width <= texture->height) {
-		f32 tex_aspect = f32(texture->width) / f32(texture->height);
+	if (pTexture->width <= pTexture->height) {
+		f32 tex_aspect = f32(pTexture->width) / f32(pTexture->height);
 		f32 scale = tex_aspect / winAspect;
 		f32 diff = 0.5f * width * (1.0f - scale);
 		ulx += diff;
 		_lrx -= diff;
 	} else {
-		f32 tex_aspect = f32(texture->height) / f32(texture->width);
+		f32 tex_aspect = f32(pTexture->height) / f32(pTexture->width);
 		f32 scale = tex_aspect / winAspect;
 		f32 diff = 0.5f * height * (1.0f - scale);
 		uly -= diff;
@@ -1084,16 +1110,16 @@ void Debugger::_drawTexture(f32 _ulx, f32 _uly, f32 _lrx, f32 _lry, f32 _yShift)
 	rect[3].z = Z;
 	rect[3].w = W;
 
-	f32 s0 = 0, t0 = 0, s1 = 1, t1 = 1;
+	f32 s0 = 0, t0 = 0, s1 = f32(pTexture->width), t1 = f32(pTexture->height);
 
 	rect[0].s0 = s0;
-	rect[0].t0 = t0;
+	rect[0].t0 = t1;
 	rect[1].s0 = s1;
-	rect[1].t0 = t0;
+	rect[1].t0 = t1;
 	rect[2].s0 = s0;
-	rect[2].t0 = t1;
+	rect[2].t0 = t0;
 	rect[3].s0 = s1;
-	rect[3].t0 = t1;
+	rect[3].t0 = t0;
 
 	_setTextureCombiner();
 	Context::TexParameters texParams;
@@ -1102,6 +1128,9 @@ void Debugger::_drawTexture(f32 _ulx, f32 _uly, f32 _lrx, f32 _lry, f32 _yShift)
 	texParams.textureUnitIndex = textureIndices::Tex[0];
 	texParams.minFilter = textureParameters::FILTER_NEAREST;
 	texParams.magFilter = textureParameters::FILTER_NEAREST;
+	texParams.wrapS = textureParameters::WRAP_CLAMP_TO_EDGE;
+	texParams.wrapT = textureParameters::WRAP_CLAMP_TO_EDGE;
+
 	gfxContext.setTextureParameters(texParams);
 
 	Context::DrawRectParameters rectParams;
diff --git a/GLideN64/src/Debugger.h b/GLideN64/src/Debugger.h
index ab2cb1ec..834e0ec9 100644
--- a/GLideN64/src/Debugger.h
+++ b/GLideN64/src/Debugger.h
@@ -104,6 +104,7 @@ class Debugger
 		gDPInfo::FillColor fill_color;
 		gDPInfo::PrimColor prim_color;
 		f32 primDepthZ, primDepthDeltaZ;
+		f32 fogMultiplier, fogOffset;
 		s32 K4, K5;
 
 		f32 getScreenX(const Vertex & _v) const;
diff --git a/GLideN64/src/FrameBuffer.cpp b/GLideN64/src/FrameBuffer.cpp
index 1a776aa9..9e4a8323 100644
--- a/GLideN64/src/FrameBuffer.cpp
+++ b/GLideN64/src/FrameBuffer.cpp
@@ -106,6 +106,8 @@ void _initFrameBufferTexture(u32 _address, u16 _width, u16 _height, f32 _scale,
 	_pTexture->mirrorS = 0;
 	_pTexture->mirrorT = 0;
 	_pTexture->textureBytes = _pTexture->width * _pTexture->height;
+	_pTexture->hdRatioS = _scale;
+	_pTexture->hdRatioT = _scale;
 	if (_size > G_IM_SIZ_8b)
 		_pTexture->textureBytes *= fbTexFormats.colorFormatBytes;
 	else
@@ -385,6 +387,8 @@ bool FrameBuffer::_initSubTexture(u32 _t)
 	m_pSubTexture->clampT = pTile->clampt;
 	m_pSubTexture->offsetS = 0.0f;
 	m_pSubTexture->offsetT = 0.0f;
+	m_pSubTexture->hdRatioS = m_pTexture->hdRatioS;
+	m_pSubTexture->hdRatioT = m_pTexture->hdRatioT;
 
 
 	_setAndAttachTexture(m_SubFBO, m_pSubTexture, _t, false);
@@ -1009,8 +1013,6 @@ void FrameBufferList::_renderScreenSizeBuffer()
 
 	gfxContext.clearColorBuffer(0.0f, 0.0f, 0.0f, 0.0f);
 
-	TextureParam filter = textureParameters::FILTER_LINEAR;
-
 	GraphicsDrawer::BlitOrCopyRectParams blitParams;
 	blitParams.srcX0 = srcCoord[0];
 	blitParams.srcY0 = srcCoord[3];
@@ -1024,10 +1026,14 @@ void FrameBufferList::_renderScreenSizeBuffer()
 	blitParams.dstY1 = dstCoord[3];
 	blitParams.dstWidth = screenWidth;
 	blitParams.dstHeight = screenHeight + wndHeightOffset;
-	blitParams.filter = filter;
+	blitParams.filter = config.generalEmulation.enableHybridFilter > 0 ?
+		textureParameters::FILTER_LINEAR :
+		textureParameters::FILTER_NEAREST;
 	blitParams.mask = blitMask::COLOR_BUFFER;
 	blitParams.tex[0] = pBufferTexture;
-	blitParams.combiner = CombinerInfo::get().getTexrectCopyProgram();
+	const bool downscale = blitParams.srcWidth >= blitParams.dstWidth && blitParams.srcHeight >= blitParams.dstHeight;
+	blitParams.combiner = downscale ? CombinerInfo::get().getTexrectDownscaleCopyProgram() :
+		CombinerInfo::get().getTexrectUpscaleCopyProgram();
 	blitParams.readBuffer = pFilteredBuffer->m_FBO;
 
 	drawer.blitOrCopyTexturedRect(blitParams);
@@ -1346,17 +1352,23 @@ void FrameBufferList::OverscanBuffer::draw(u32 _fullHeight, bool _PAL)
 	blitParams.dstY1 = m_vOffset + wnd.getHeight() + wnd.getHeightOffset();
 	blitParams.dstWidth = wnd.getScreenWidth();
 	blitParams.dstHeight = wnd.getScreenHeight() + wnd.getHeightOffset();
-	blitParams.filter = textureParameters::FILTER_LINEAR;
+	blitParams.filter = config.generalEmulation.enableHybridFilter > 0 ?
+		textureParameters::FILTER_LINEAR :
+		textureParameters::FILTER_NEAREST;
 	blitParams.mask = blitMask::COLOR_BUFFER;
 	blitParams.tex[0] = m_pTexture;
+	const bool downscale = blitParams.srcWidth >= blitParams.dstWidth && blitParams.srcHeight >= blitParams.dstHeight;
 	if (config.frameBufferEmulation.copyDepthToMainDepthBuffer != 0) {
 		blitParams.tex[1] = m_pDepthTexture;
-		blitParams.combiner = CombinerInfo::get().getTexrectColorAndDepthCopyProgram();
+		blitParams.combiner = downscale ? CombinerInfo::get().getTexrectColorAndDepthDownscaleCopyProgram() :
+			CombinerInfo::get().getTexrectColorAndDepthUpscaleCopyProgram();
 	}
 	if (blitParams.combiner == nullptr) {
 		// copyDepthToMainDepthBuffer not set or not supported
-		blitParams.combiner = CombinerInfo::get().getTexrectCopyProgram();
+		blitParams.combiner = downscale ? CombinerInfo::get().getTexrectDownscaleCopyProgram() :
+			CombinerInfo::get().getTexrectUpscaleCopyProgram();
 	}
+
 	blitParams.readBuffer = m_FBO;
 	blitParams.invertY = false;
 
@@ -1486,7 +1498,6 @@ void FrameBufferList::renderBuffer()
 						hOffset + dstX1,
 						vOffset + (s32)(dstY1*dstScaleY) };
 
-	const TextureParam filter = textureParameters::FILTER_NEAREST;
 	ObjectHandle readBuffer;
 
 	if (pFilteredBuffer->m_pTexture->frameBufferTexture == CachedTexture::fbMultiSample) {
@@ -1516,16 +1527,21 @@ void FrameBufferList::renderBuffer()
 	blitParams.dstY1 = dstCoord[3];
 	blitParams.dstWidth = m_overscan.getBufferWidth();
 	blitParams.dstHeight = m_overscan.getBufferHeight();
-	blitParams.filter = filter;
+	blitParams.filter = config.generalEmulation.enableHybridFilter > 0 ?
+		textureParameters::FILTER_LINEAR :
+		textureParameters::FILTER_NEAREST;
 	blitParams.mask = blitMask::COLOR_BUFFER;
 	blitParams.tex[0] = pBufferTexture;
+	const bool downscale = blitParams.srcWidth >= blitParams.dstWidth && blitParams.srcHeight >= blitParams.dstHeight;
 	if (config.frameBufferEmulation.copyDepthToMainDepthBuffer != 0) {
 		blitParams.tex[1] = pBuffer->m_pDepthTexture;
-		blitParams.combiner = CombinerInfo::get().getTexrectColorAndDepthCopyProgram();
+		blitParams.combiner = downscale ? CombinerInfo::get().getTexrectColorAndDepthDownscaleCopyProgram():
+			CombinerInfo::get().getTexrectColorAndDepthUpscaleCopyProgram();
 	}
 	if (blitParams.combiner == nullptr) {
 		// copyDepthToMainDepthBuffer not set or not supported
-		blitParams.combiner = CombinerInfo::get().getTexrectCopyProgram();
+		blitParams.combiner = downscale ? CombinerInfo::get().getTexrectDownscaleCopyProgram() :
+			CombinerInfo::get().getTexrectUpscaleCopyProgram();
 	}
 	blitParams.readBuffer = readBuffer;
 	blitParams.invertY = config.frameBufferEmulation.enableOverscan == 0;
@@ -1559,7 +1575,6 @@ void FrameBufferList::renderBuffer()
 		blitParams.dstHeight = m_overscan.getBufferHeight();
 		blitParams.tex[0] = pBufferTexture;
 		blitParams.tex[1] = pNextBuffer->m_pDepthTexture;
-		blitParams.filter = filter;
 		blitParams.mask = blitMask::COLOR_BUFFER;
 		blitParams.readBuffer = readBuffer;
 
diff --git a/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp b/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp
index 2889704d..e1c697ce 100644
--- a/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp
+++ b/GLideN64/src/GLideNUI-wtl/ConfigDlg.cpp
@@ -70,7 +70,7 @@ LRESULT CConfigDlg::OnInitDialog(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lPar
 		dc.CreateCompatibleDC(NULL);
 		dc.SelectFont(dlgItem.GetFont());
 		SIZE size;
-		dc.GetTextExtent(RomName.c_str(), RomName.length(), &size);
+		dc.GetTextExtent(RomName.c_str(), static_cast<int>(RomName.length()), &size);
 
 		RECT Rect;
 		dlgItem.GetWindowRect(&Rect);
@@ -326,7 +326,7 @@ void CConfigDlg::Init(bool reInit, bool blockCustomSettings) {
 	m_blockReInit = true;
 	bool CustomSettings = m_EmulationTab != NULL && CButton(m_EmulationTab->GetDlgItem(IDC_CHK_USE_PER_GAME)).GetCheck() == BST_CHECKED;
 
-	if (reInit && m_romName != NULL && CustomSettings && CButton(m_EmulationTab->GetDlgItem(IDC_GAME_PROFILE)).GetCheck() == BST_CHECKED) {
+	if (reInit && m_romName != NULL && CustomSettings && CButton(GetDlgItem(IDC_GAME_PROFILE)).GetCheck() == BST_CHECKED) {
 		loadCustomRomSettings(m_strIniPath.c_str(), m_romName);
 	} else if (reInit) {
 		loadSettings(m_strIniPath.c_str());
diff --git a/GLideN64/src/GLideNUI-wtl/GLideNUI.rc b/GLideN64/src/GLideNUI-wtl/GLideNUI.rc
index e1dbb1b10480ba56d3d57a6a034514abf274c187..5b5176e47c600ac432e4dbf997925b18a9667365 100644
GIT binary patch
delta 22
ecmX@JfceY<<_&f7lNYU2n*6JSYx64kMH>KqvI`ji

delta 21
dcmX@JfceY<<_&f7lN6LD+sJclULn6^0{~-<2*dyY

diff --git a/GLideN64/src/GLideNUI-wtl/Settings.cpp b/GLideN64/src/GLideNUI-wtl/Settings.cpp
index c6a15564..e9d8fb77 100644
--- a/GLideN64/src/GLideNUI-wtl/Settings.cpp
+++ b/GLideN64/src/GLideNUI-wtl/Settings.cpp
@@ -105,6 +105,8 @@ void _loadSettings(GlSettings & settings)
 
 	settings.beginGroup("font");
 	config.font.name = settings.value("name", config.font.name.c_str()).toString();
+	if (config.font.name.empty())
+		config.font.name = "arial.ttf";
 	config.font.size = settings.value("size", config.font.size).toInt();
 	GlColor fontColor = settings.value("color", GlColor(config.font.color[0], config.font.color[1], config.font.color[2])).toGlColor();
 	config.font.color[0] = fontColor.Red();
diff --git a/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp b/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp
index 7c486d37..1346c8bf 100644
--- a/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp
+++ b/GLideN64/src/GLideNUI-wtl/config-framebuffer.cpp
@@ -178,7 +178,7 @@ void CFrameBufferTab::SaveSettings()
 	config.frameBufferEmulation.enable = CButton(GetDlgItem(IDC_CHK_ENABLE_FRAMEBUFFER)).GetCheck() == BST_CHECKED ? 1 : 0;
 	config.frameBufferEmulation.copyAuxToRDRAM = CButton(GetDlgItem(IDC_CHK_COPY_AUX_BUFFERS)).GetCheck() == BST_CHECKED ? 1 : 0;
 	config.frameBufferEmulation.bufferSwapMode = CComboBox(GetDlgItem(IDC_CMB_FRAMEBUFFER_SWAP)).GetCurSel();
-	config.frameBufferEmulation.fbInfoDisabled = CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).GetCheck() == BST_CHECKED ? 1 : 0;
+	config.frameBufferEmulation.fbInfoDisabled = CButton(GetDlgItem(IDC_CHK_FB_INFO_ENABLE)).GetCheck() == BST_CHECKED ? 0 : 1;
 	config.frameBufferEmulation.fbInfoReadColorChunk = CButton(GetDlgItem(IDC_CHK_READ_COLOR_CHUNK)).GetCheck() == BST_CHECKED ? 1 : 0;
 	config.frameBufferEmulation.fbInfoReadDepthChunk = CButton(GetDlgItem(IDC_CHK_READ_DEPTH_CHUNK)).GetCheck() == BST_CHECKED ? 1 : 0;
 	config.frameBufferEmulation.copyToRDRAM = CComboBox(GetDlgItem(IDC_CMB_COPY_COLOR_BUFFER)).GetCurSel();
diff --git a/GLideN64/src/GLideNUI-wtl/config-osd.cpp b/GLideN64/src/GLideNUI-wtl/config-osd.cpp
index 8c923089..70eb22f2 100644
--- a/GLideN64/src/GLideNUI-wtl/config-osd.cpp
+++ b/GLideN64/src/GLideNUI-wtl/config-osd.cpp
@@ -75,14 +75,14 @@ void COsdTab::LoadFonts(void)
 		if (hParent == TVI_ROOT) {
 			tv.item.mask = TVIF_TEXT;
 			tv.item.pszText = (LPWSTR)FontName.c_str();
-			tv.item.cchTextMax = FontName.length();
+			tv.item.cchTextMax = static_cast<int>(FontName.length());
 			tv.hInsertAfter = TVI_SORT;
 			tv.hParent = TVI_ROOT;
 			hParent = m_Fonts.InsertItem(&tv);
 		}
 		tv.item.mask = TVIF_TEXT;
 		tv.item.pszText = (LPWSTR)FontFile.c_str();
-		tv.item.cchTextMax = FontFile.length();
+		tv.item.cchTextMax = static_cast<int>(FontFile.length());
 		tv.hInsertAfter = TVI_SORT;
 		tv.hParent = hParent;
 		m_Fonts.InsertItem(&tv);
@@ -239,13 +239,13 @@ void COsdTab::LoadSettings(bool /*blockCustomSettings*/)
 		m_OsdColor.SetColor(config.font.color[0], config.font.color[1], config.font.color[2]);
 		m_OsdPreview.SetColor(config.font.color[0], config.font.color[1], config.font.color[2]);
 	}
-	
-	m_PosTopLeft.SetChecked(config.onScreenDisplay.pos == Config::posTopLeft); 
-	m_PosTop.SetChecked(config.onScreenDisplay.pos == Config::posTopCenter); 
+
+	m_PosTopLeft.SetChecked(config.onScreenDisplay.pos == Config::posTopLeft);
+	m_PosTop.SetChecked(config.onScreenDisplay.pos == Config::posTopCenter);
 	m_PosTopRight.SetChecked(config.onScreenDisplay.pos == Config::posTopRight);
 	m_PosBottomLeft.SetChecked(config.onScreenDisplay.pos == Config::posBottomLeft);
 	m_PosBottom.SetChecked(config.onScreenDisplay.pos == Config::posBottomCenter);
-	m_PosBottomRight.SetChecked(config.onScreenDisplay.pos == Config::posBottomRight); 
+	m_PosBottomRight.SetChecked(config.onScreenDisplay.pos == Config::posBottomRight);
 
 	CButton(GetDlgItem(IDC_CHK_FPS)).SetCheck(config.onScreenDisplay.fps != 0 ? BST_CHECKED : BST_UNCHECKED);
 	CButton(GetDlgItem(IDC_CHK_VIS)).SetCheck(config.onScreenDisplay.vis != 0 ? BST_CHECKED : BST_UNCHECKED);
@@ -272,7 +272,11 @@ void COsdTab::SaveSettings()
 	config.onScreenDisplay.internalResolution = CButton(GetDlgItem(IDC_INTERNAL_RESOLUTION)).GetCheck() == BST_CHECKED ? 1 : 0;
 	config.onScreenDisplay.renderingResolution = CButton(GetDlgItem(IDC_RENDERING_RESOLUTION)).GetCheck() == BST_CHECKED ? 1 : 0;
 
-	config.font.name = FromUTF16(GetSelectedFont().c_str());
+	std::string SelectedFont = FromUTF16(GetSelectedFont().c_str());
+	if (!SelectedFont.empty())
+		config.font.name = SelectedFont;
+	if (config.font.name.empty())
+		config.font.name = "arial.ttf";
 	config.font.size = m_FontSizeSpin.GetPos();
 
 	config.font.color[0] = m_OsdColor.Red();
@@ -287,6 +291,8 @@ void COsdTab::SaveSettings()
 
 std::wstring COsdTab::GetSelectedFont()
 {
+	if (!m_FontsLoaded)
+		return ToUTF16(config.font.name.c_str());
 	HTREEITEM hItem = m_Fonts.GetSelectedItem();
 	if (hItem == NULL)
 		return L"";
diff --git a/GLideN64/src/GLideNUI-wtl/config-texture.cpp b/GLideN64/src/GLideNUI-wtl/config-texture.cpp
index 40ca72be..a270b40e 100644
--- a/GLideN64/src/GLideNUI-wtl/config-texture.cpp
+++ b/GLideN64/src/GLideNUI-wtl/config-texture.cpp
@@ -208,7 +208,7 @@ void CTextureEnhancementTab::SaveDirectory(int EditCtrl, wchar_t * txPath)
 	int TxtLen = EditWnd.GetWindowTextLength();
 	std::wstring Path;
 	Path.resize(TxtLen + 1);
-	EditWnd.GetWindowText((wchar_t *)Path.data(), Path.size());
+	EditWnd.GetWindowText((wchar_t *)Path.data(), static_cast<int>(Path.size()));
 
 	WIN32_FIND_DATA	FindData;
 	HANDLE hFindFile = FindFirstFile(Path.c_str(), &FindData);
@@ -269,7 +269,7 @@ void CTextureEnhancementTab::SelectDir(wchar_t * Title, int EditCtrl)
 	int TxtLen = EditWnd.GetWindowTextLength();
 	std::wstring EditText;
 	EditText.resize(TxtLen + 1);
-	EditWnd.GetWindowText((wchar_t *)EditText.data(), EditText.size());
+	EditWnd.GetWindowText((wchar_t *)EditText.data(), static_cast<int>(EditText.size()));
 
 	bi.hwndOwner = m_hWnd;
 	bi.pidlRoot = NULL;
diff --git a/GLideN64/src/GLideNUI-wtl/config-video.cpp b/GLideN64/src/GLideNUI-wtl/config-video.cpp
index fde578b4..43df690a 100644
--- a/GLideN64/src/GLideNUI-wtl/config-video.cpp
+++ b/GLideN64/src/GLideNUI-wtl/config-video.cpp
@@ -54,6 +54,7 @@ CVideoTab::CVideoTab(CConfigDlg & Dlg, CFrameBufferTab & FrameBufferTab, const c
 	m_Dlg(Dlg),
 	m_FrameBufferTab(FrameBufferTab)
 {
+	m_AAInfoWarning = false;
 }
 
 CVideoTab::~CVideoTab() {
@@ -133,7 +134,7 @@ void CVideoTab::ApplyLanguage(void) {
 	SetDlgItemTextW(IDC_BILINEAR, wGS(VIDEO_BILINEAR).c_str());
 	SetDlgItemTextW(IDC_BILINEAR_STANDARD, wGS(VIDEO_BILINEAR_STANDARD).c_str());
 	SetDlgItemTextW(IDC_BILINEAR_3POINT, wGS(VIDEO_BILINEAR_3POINT).c_str());
-	
+
 	SetDlgItemTextW(IDC_DITHERING_GROUP, wGS(VIDEO_DITHERING_GROUP).c_str());
 	SetDlgItemTextW(IDC_PATTERN, wGS(VIDEO_PATTERN).c_str());
 	SetDlgItemTextW(IDC_CHK_APPLY_TO_OUTPUT, wGS(VIDEO_DITHERING_APPLY_TO_OUTPUT).c_str());
@@ -273,6 +274,65 @@ LRESULT CVideoTab::OnLanguageChanged(WORD /*wNotifyCode*/, WORD /*wID*/, HWND /*
 	return 0;
 }
 
+void CVideoTab::HideMSAADepthWarning(bool hide)
+{
+	int nID[] = {
+	IDC_AA_INFO,
+	IDC_AA_INFO_ICON,
+	IDC_FILTERING_GROUP,
+	IDC_ANISOTROPIC,
+	IDC_ANISOTROPIC_OFF,
+	IDC_ANISOTROPIC_HIGH,
+	IDC_ANISOTROPIC_SLIDER,
+	IDC_ANISOTROPIC_LABEL,
+	IDC_BILINEAR,
+	IDC_BILINEAR_STANDARD,
+	IDC_BILINEAR_3POINT,
+	IDC_DITHERING_GROUP,
+	IDC_PATTERN,
+	IDC_CMB_PATTERN,
+	IDC_CHK_APPLY_TO_OUTPUT,
+	IDC_CHK_5BIT_QUANTIZATION,
+	IDC_CHK_HIRES_NOISE
+	};
+
+	RECT Rect; RECT groupRect;
+	GetDlgItem(nID[0]).GetWindowRect(&Rect);
+	::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+	int32_t Move = Rect.bottom - Rect.top + 2;
+
+	GetDlgItem(nID[0]).ShowWindow(hide ? SW_HIDE : SW_SHOWNORMAL);
+	GetDlgItem(nID[1]).ShowWindow(hide ? SW_HIDE : SW_SHOWNORMAL);
+
+	CWindow AAgroup = GetDlgItem(IDC_AA_GROUP);
+	AAgroup.GetWindowRect(&groupRect);
+	::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&groupRect, 2);
+	SIZE AAgroupSz = { groupRect.right - groupRect.left, hide ? groupRect.bottom - groupRect.top - Move - 1 : groupRect.bottom - groupRect.top + Move + 1 };
+	AAgroup.SetWindowPos(HWND_TOP, 0, 0, AAgroupSz.cx, AAgroupSz.cy, SWP_NOMOVE | SWP_NOZORDER);
+
+	for (size_t i = 2, n = sizeof(nID) / sizeof(nID[0]); i < n; i++) {
+		CWindow window = GetDlgItem(nID[i]);
+		window.GetWindowRect(&Rect);
+		::MapWindowPoints(NULL, m_hWnd, (LPPOINT)&Rect, 2);
+
+		Rect.top -= hide ? Move : -Move;
+		Rect.bottom -= hide ? Move : -Move;
+		window.MoveWindow(&Rect);
+	}
+
+	m_AAInfoWarning = hide;
+}
+
+void CVideoTab::DisallowMSAA(bool disallow)
+{
+	GetDlgItem(IDC_MSAA_RADIO).EnableWindow(!disallow);
+	GetDlgItem(IDC_ALIASING_SLIDER).EnableWindow(!disallow);
+	GetDlgItem(IDC_ALIASING_LABEL).EnableWindow(!disallow);
+	GetDlgItem(IDC_AA_HIGH).EnableWindow(!disallow);
+	GetDlgItem(IDC_AA_OFF).EnableWindow(!disallow);
+}
+
+
 void CVideoTab::AddOverScanTab(languageStringID caption) {
 	m_OverScanTab.AddItem(TCIF_TEXT | TCIF_PARAM, wGS(caption).c_str(), 0, caption);
 
@@ -348,7 +408,14 @@ void CVideoTab::LoadSettings(bool /*blockCustomSettings*/) {
 		if (fullscreenMode == i)
 			fullScreenResolutionComboBox.SetCurSel(index);
 	}
-	OnFullScreenChanged(0, 0, NULL);
+	CComboBox RefreshRateComboBox(GetDlgItem(IDC_CMB_REFRESH_RATE));
+	RefreshRateComboBox.ResetContent();
+	for (size_t i = 0, n = fullscreenRatesList.size(); i < n; i++) {
+		std::wstring fullscreenRateStr(fullscreenRatesList[i].begin(), fullscreenRatesList[i].end());
+		int index = RefreshRateComboBox.AddString(fullscreenRateStr.c_str());
+		if (fullscreenRate == i)
+			RefreshRateComboBox.SetCurSel(index);
+	}
 	const unsigned int multisampling = config.video.fxaa == 0 && config.video.multisampling > 0
 		? config.video.multisampling
 		: 8;
@@ -356,8 +423,22 @@ void CVideoTab::LoadSettings(bool /*blockCustomSettings*/) {
 	std::wstring AliasingText = FormatStrW(L"%dx", multisampling);
 	CWindow(GetDlgItem(IDC_ALIASING_LABEL)).SetWindowTextW(AliasingText.c_str());
 
-	CButton(GetDlgItem(IDC_NOAA_RADIO)).SetCheck(config.video.multisampling == 0 ? BST_CHECKED : BST_UNCHECKED);
-	CButton(GetDlgItem(IDC_FXAA_RADIO)).SetCheck(config.video.fxaa != 0 && config.video.multisampling != 0 ? BST_CHECKED : BST_UNCHECKED);
+	if (config.frameBufferEmulation.N64DepthCompare == 0) {
+		if (!m_AAInfoWarning) {
+			HideMSAADepthWarning(true);
+			DisallowMSAA(false);
+			RedrawWindow();
+		}
+	} else {
+		if (m_AAInfoWarning) {
+			HideMSAADepthWarning(false);
+			DisallowMSAA(true);
+			RedrawWindow();
+		}
+	}
+
+	CButton(GetDlgItem(IDC_NOAA_RADIO)).SetCheck(config.video.multisampling == 0 && config.video.fxaa == 0 ? BST_CHECKED : BST_UNCHECKED);
+	CButton(GetDlgItem(IDC_FXAA_RADIO)).SetCheck(config.video.fxaa != 0 && config.video.multisampling == 0 ? BST_CHECKED : BST_UNCHECKED);
 	CButton(GetDlgItem(IDC_MSAA_RADIO)).SetCheck(config.video.fxaa == 0 && config.video.multisampling != 0 ? BST_CHECKED : BST_UNCHECKED);
 	m_AnisotropicSlider.SetPos(config.texture.maxAnisotropy);
 	CWindow(GetDlgItem(IDC_ANISOTROPIC_LABEL)).SetWindowTextW(FormatStrW(L"%dx", m_AnisotropicSlider.GetPos()).c_str());
@@ -394,7 +475,7 @@ void CVideoTab::LoadSettings(bool /*blockCustomSettings*/) {
 			break;
 		}
 	} // default: attempt to use gliden64_en.Lang
-	if (englishIndx >= 0 && translationsComboBox.GetCurSel() < 0) 
+	if (englishIndx >= 0 && translationsComboBox.GetCurSel() < 0)
 		translationsComboBox.SetCurSel(englishIndx);
 	else if (translationsComboBox.GetCurSel() < 0) // gliden64_en.Lang not found; select hardcoded english
 		translationsComboBox.SetCurSel(translationsComboBox.FindString(-1, englishLang));
diff --git a/GLideN64/src/GLideNUI-wtl/config-video.h b/GLideN64/src/GLideNUI-wtl/config-video.h
index cc87b2b1..882940ee 100644
--- a/GLideN64/src/GLideNUI-wtl/config-video.h
+++ b/GLideN64/src/GLideNUI-wtl/config-video.h
@@ -38,6 +38,7 @@ class CVideoTab :
 	CVideoTab(CConfigDlg & Dlg, CFrameBufferTab & FrameBufferTab, const char * strIniPath);
 	~CVideoTab();
 
+	bool m_AAInfoWarning;
 	BOOL OnInitDialog(CWindow /*wndFocus*/, LPARAM /*lInitParam*/);
 	LRESULT OnScroll(UINT /*uMsg*/, WPARAM wParam, LPARAM lParam, BOOL& /*bHandled*/);
 	void OnOverscan(UINT /*Code*/, int id, HWND /*ctl*/);
@@ -45,6 +46,8 @@ class CVideoTab :
 	LRESULT OnOverscanTabChange(NMHDR* /*pNMHDR*/);
 	void OnFullScreenChanged(UINT /*Code*/, int id, HWND /*ctl*/);
 	LRESULT OnLanguageChanged(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& bHandled);
+	void HideMSAADepthWarning(bool hide);
+	void DisallowMSAA(bool disallow);
 	void AddOverScanTab(languageStringID caption);
 	void ShowOverScanTab(int nTab);
 	void ApplyLanguage(void);
diff --git a/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h b/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h
index 6ae4e19a..f2cee08e 100644
--- a/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h
+++ b/GLideN64/src/GLideNUI-wtl/wtl-tooltip.h
@@ -102,7 +102,7 @@ class CToolTipDialog
 	static BOOL CALLBACK SetTool(HWND hTool, LPARAM pDlg)
 	{
 		T* pT = (T*)pDlg;
-		int idTool = ::GetWindowLong(hTool, GWL_ID);
+		auto idTool = ::GetWindowLong(hTool, GWL_ID);
 		if (idTool != IDC_STATIC)
 		{
 			CToolInfo ToolInfo(pT->m_uToolFlags, hTool, 0, 0, (LPTSTR)idTool);
diff --git a/GLideN64/src/Graphics/Context.cpp b/GLideN64/src/Graphics/Context.cpp
index 0e744b16..02979fc8 100644
--- a/GLideN64/src/Graphics/Context.cpp
+++ b/GLideN64/src/Graphics/Context.cpp
@@ -280,14 +280,24 @@ ShaderProgram * Context::createTexrectDrawerClearShader()
 	return m_impl->createTexrectDrawerClearShader();
 }
 
-ShaderProgram * Context::createTexrectCopyShader()
+ShaderProgram * Context::createTexrectUpscaleCopyShader()
 {
-	return m_impl->createTexrectCopyShader();
+	return m_impl->createTexrectUpscaleCopyShader();
 }
 
-ShaderProgram * Context::createTexrectColorAndDepthCopyShader()
+ShaderProgram * Context::createTexrectColorAndDepthUpscaleCopyShader()
 {
-	return m_impl->createTexrectColorAndDepthCopyShader();
+	return m_impl->createTexrectColorAndDepthUpscaleCopyShader();
+}
+
+ShaderProgram * Context::createTexrectDownscaleCopyShader()
+{
+  return m_impl->createTexrectDownscaleCopyShader();
+}
+
+ShaderProgram * Context::createTexrectColorAndDepthDownscaleCopyShader()
+{
+  return m_impl->createTexrectColorAndDepthDownscaleCopyShader();
 }
 
 ShaderProgram * Context::createGammaCorrectionShader()
diff --git a/GLideN64/src/Graphics/Context.h b/GLideN64/src/Graphics/Context.h
index 4baa8c39..ed8ea47b 100644
--- a/GLideN64/src/Graphics/Context.h
+++ b/GLideN64/src/Graphics/Context.h
@@ -233,9 +233,13 @@ namespace graphics {
 
 		ShaderProgram * createTexrectDrawerClearShader();
 
-		ShaderProgram * createTexrectCopyShader();
+		ShaderProgram * createTexrectUpscaleCopyShader();
 
-		ShaderProgram * createTexrectColorAndDepthCopyShader();
+		ShaderProgram * createTexrectColorAndDepthUpscaleCopyShader();
+
+		ShaderProgram * createTexrectDownscaleCopyShader();
+
+		ShaderProgram * createTexrectColorAndDepthDownscaleCopyShader();
 
 		ShaderProgram * createGammaCorrectionShader();
 
diff --git a/GLideN64/src/Graphics/ContextImpl.h b/GLideN64/src/Graphics/ContextImpl.h
index a77f3b58..d56e4a12 100644
--- a/GLideN64/src/Graphics/ContextImpl.h
+++ b/GLideN64/src/Graphics/ContextImpl.h
@@ -57,8 +57,10 @@ namespace graphics {
 		virtual ShaderProgram * createDepthFogShader() = 0;
 		virtual TexrectDrawerShaderProgram * createTexrectDrawerDrawShader() = 0;
 		virtual ShaderProgram * createTexrectDrawerClearShader() = 0;
-		virtual ShaderProgram * createTexrectCopyShader() = 0;
-		virtual ShaderProgram * createTexrectColorAndDepthCopyShader() = 0;
+		virtual ShaderProgram * createTexrectUpscaleCopyShader() = 0;
+		virtual ShaderProgram * createTexrectColorAndDepthUpscaleCopyShader() = 0;
+		virtual ShaderProgram * createTexrectDownscaleCopyShader() = 0;
+		virtual ShaderProgram * createTexrectColorAndDepthDownscaleCopyShader() = 0;
 		virtual ShaderProgram * createGammaCorrectionShader() = 0;
 		virtual ShaderProgram * createOrientationCorrectionShader() = 0;
 		virtual ShaderProgram * createFXAAShader() = 0;
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
index d4cd0ec4..a1fea7aa 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
@@ -296,26 +296,28 @@ class VertexShaderTexturedTriangle : public ShaderPart
 			"OUT highp vec2 vTexCoord1;							\n"
 			"OUT mediump vec2 vLodTexCoord;						\n"
 			"OUT lowp float vNumLights;							\n"
-			;
+			"OUT lowp vec4 vShadeColor;							\n"
+		;
 		if (!_glinfo.isGLESX || _glinfo.noPerspective)
-			m_part += "noperspective OUT lowp vec4 vShadeColor;	\n";
+			m_part += "noperspective OUT lowp vec4 vShadeColorNoperspective;\n";
 		else
-			m_part += "OUT lowp vec4 vShadeColor;				\n";
+			m_part += "OUT lowp vec4 vShadeColorNoperspective;				\n";
 		m_part +=
 			"mediump vec2 calcTexCoord(in vec2 texCoord, in int idx)		\n"
 			"{																\n"
 			"    vec2 texCoordOut = texCoord*uCacheShiftScale[idx];			\n"
 			"    texCoordOut -= uTexOffset[idx];							\n"
 			"    texCoordOut += uCacheOffset[idx];							\n"
-			"    if (uTextureFilterMode != 0 && uCacheFrameBuffer[idx] == 0)\n"
-			"      texCoordOut += vec2(0.5);								\n"
-			"    return texCoordOut* uCacheScale[idx];						\n"
+			"    if (uTextureFilterMode != 0 && uCacheFrameBuffer[idx] != 0) \n"
+			"      texCoordOut -= vec2(0.5);								\n"
+			"    return texCoordOut * uCacheScale[idx];						\n"
 			"}																\n"
 			"																\n"
 			"void main()													\n"
 			"{																\n"
 			"  gl_Position = aPosition;										\n"
 			"  vShadeColor = aColor;										\n"
+			"  vShadeColorNoperspective = aColor;							\n"
 			"  vec2 texCoord = aTexCoord;									\n"
 			"  texCoord *= uTexScale;										\n"
 			"  if (uTexturePersp == 0 && aModify[2] == 0.0) texCoord *= 0.5;\n"
@@ -366,17 +368,19 @@ class VertexShaderTriangle : public ShaderPart
 			"uniform mediump vec2 uScreenCoordsScale;						\n"
 			"																\n"
 			"OUT lowp float vNumLights;										\n"
-			;
+			"OUT lowp vec4 vShadeColor;										\n"
+		;
 		if (!_glinfo.isGLESX || _glinfo.noPerspective)
-			m_part += "noperspective OUT lowp vec4 vShadeColor;				\n";
+			m_part += "noperspective OUT lowp vec4 vShadeColorNoperspective;\n";
 		else
-			m_part += "OUT lowp vec4 vShadeColor;							\n";
+			m_part += "OUT lowp vec4 vShadeColorNoperspective;				\n";
 		m_part +=
 			"																\n"
 			"void main()													\n"
 			"{																\n"
 			"  gl_Position = aPosition;										\n"
 			"  vShadeColor = aColor;										\n"
+			"  vShadeColorNoperspective = aColor;							\n"
 			"  vNumLights = aNumLights;										\n"
 			"  if (aModify != vec4(0.0)) {									\n"
 			"    if ((aModify[0]) != 0.0) {									\n"
@@ -417,17 +421,19 @@ class VertexShaderTexturedRect : public ShaderPart
 			"													\n"
 			"OUT highp vec2 vTexCoord0;							\n"
 			"OUT highp vec2 vTexCoord1;							\n"
-			;
+			"OUT lowp vec4 vShadeColor;							\n"
+		;
 		if (!_glinfo.isGLESX || _glinfo.noPerspective)
-			m_part += "noperspective OUT lowp vec4 vShadeColor;	\n";
+			m_part += "noperspective OUT lowp vec4 vShadeColorNoperspective;\n";
 		else
-			m_part += "OUT lowp vec4 vShadeColor;				\n";
+			m_part += "OUT lowp vec4 vShadeColorNoperspective;				\n";
 		m_part +=
 			"uniform lowp vec4 uRectColor;						\n"
 			"void main()										\n"
 			"{													\n"
 			"  gl_Position = aRectPosition;						\n"
 			"  vShadeColor = uRectColor;						\n"
+			"  vShadeColorNoperspective = uRectColor;			\n"
 			"  vTexCoord0 = aTexCoord0;							\n"
 			"  vTexCoord1 = aTexCoord1;							\n"
 			;
@@ -442,17 +448,19 @@ class VertexShaderRect : public ShaderPart
 		m_part =
 			"IN highp vec4 aRectPosition;						\n"
 			"													\n"
+			"OUT lowp vec4 vShadeColor;							\n"
 			;
 		if (!_glinfo.isGLESX || _glinfo.noPerspective)
-			m_part += "noperspective OUT lowp vec4 vShadeColor;	\n";
+			m_part += "noperspective OUT lowp vec4 vShadeColorNoperspective;\n";
 		else
-			m_part += "OUT lowp vec4 vShadeColor;				\n";
+			m_part += "OUT lowp vec4 vShadeColorNoperspective;				\n";
 		m_part +=
 			"uniform lowp vec4 uRectColor;						\n"
 			"void main()										\n"
 			"{													\n"
 			"  gl_Position = aRectPosition;						\n"
 			"  vShadeColor = uRectColor;						\n"
+			"  vShadeColorNoperspective = uRectColor;			\n"
 			;
 	}
 };
@@ -848,20 +856,28 @@ class ShaderFragmentGlobalVariablesTex : public ShaderPart
 			"uniform lowp int uDepthSource;			\n"
 			"uniform highp float uPrimDepth;		\n"
 			"uniform mediump vec2 uScreenScale;		\n"
-			"uniform highp vec4 uTexClamp0;			\n"
-			"uniform highp vec4 uTexClamp1;			\n"
+			"uniform highp vec2 uTexClamp0;			\n"
+			"uniform highp vec2 uTexClamp1;			\n"
 			"uniform highp vec2 uTexWrap0;			\n"
 			"uniform highp vec2 uTexWrap1;			\n"
-			"uniform lowp vec2 uTexMirror0;			\n"
-			"uniform lowp vec2 uTexMirror1;			\n"
-			"uniform highp vec2 uTexScale0;			\n"
-			"uniform highp vec2 uTexScale1;			\n"
-			"uniform lowp int uFogUsage;			\n"
+			"uniform lowp vec2 uTexWrapEn0;			\n"
+			"uniform lowp vec2 uTexWrapEn1;			\n"
+			"uniform lowp vec2 uTexMirrorEn0;		\n"
+			"uniform lowp vec2 uTexMirrorEn1;		\n"
+			"uniform lowp vec2 uTexClampEn0;		\n"
+			"uniform lowp vec2 uTexClampEn1;		\n"
+			"uniform lowp int uScreenSpaceTriangle;	\n"
 			"highp vec2 texCoord0;					\n"
 			"highp vec2 texCoord1;					\n"
-			;
+			"highp vec2[5] tcData0;					\n"
+			"highp vec2[5] tcData1;					\n"
+		;
 
-		if (config.generalEmulation.enableLegacyBlending == 0) {
+		if (config.generalEmulation.enableLegacyBlending != 0) {
+			m_part +=
+				"uniform lowp int uFogUsage;		\n"
+			;
+		} else {
 			m_part +=
 				"uniform lowp ivec4 uBlendMux1;		\n"
 				"uniform lowp int uForceBlendCycle1;\n"
@@ -896,23 +912,24 @@ class ShaderFragmentGlobalVariablesTex : public ShaderPart
 		}
 
 		if (!_glinfo.isGLESX || _glinfo.noPerspective)
-			m_part += "noperspective IN lowp vec4 vShadeColor;	\n";
+			m_part += "noperspective IN lowp vec4 vShadeColorNoperspective;	\n";
 		else
-			m_part += "IN lowp vec4 vShadeColor;	\n";
+			m_part += "IN lowp vec4 vShadeColorNoperspective;				\n";
 
 		m_part +=
-			"IN highp vec2 vTexCoord0;\n"
-			"IN highp vec2 vTexCoord1;\n"
-			"IN mediump vec2 vLodTexCoord;\n"
-			"IN lowp float vNumLights;	\n"
-			;
+			"IN lowp vec4 vShadeColor;		\n"
+			"IN highp vec2 vTexCoord0;		\n"
+			"IN highp vec2 vTexCoord1;		\n"
+			"IN mediump vec2 vLodTexCoord;	\n"
+			"IN lowp float vNumLights;		\n"
+		;
 
 		if (config.frameBufferEmulation.N64DepthCompare == Config::dcFast && _glinfo.ext_fetch) {
 			m_part +=
-				"layout(location = 0) OUT lowp vec4 fragColor;	\n"
-				"layout(location = 1) inout highp vec4 depthZ;	\n"
+				"layout(location = 0) OUT lowp vec4 fragColor;		\n"
+				"layout(location = 1) inout highp vec4 depthZ;		\n"
 				"layout(location = 2) inout highp vec4 depthDeltaZ;	\n"
-				;
+			;
 		} else {
 			m_part +=
 				"OUT lowp vec4 fragColor;	\n"
@@ -946,17 +963,18 @@ class ShaderFragmentGlobalVariablesNotex : public ShaderPart
 			"uniform lowp int uDepthSource;			\n"
 			"uniform highp float uPrimDepth;		\n"
 			"uniform mediump vec2 uScreenScale;		\n"
-			;
+			"uniform lowp int uScreenSpaceTriangle;	\n"
+		;
 
 		if (config.generalEmulation.enableLegacyBlending != 0) {
 			m_part +=
 				"uniform lowp int uFogUsage;		\n"
-				;
+			;
 		} else {
 			m_part +=
 				"uniform lowp ivec4 uBlendMux1;		\n"
 				"uniform lowp int uForceBlendCycle1;\n"
-				;
+			;
 		}
 
 		if (!_glinfo.isGLES2) {
@@ -979,18 +997,21 @@ class ShaderFragmentGlobalVariablesNotex : public ShaderPart
 		}
 
 		if (!_glinfo.isGLESX || _glinfo.noPerspective)
-			m_part += "noperspective IN lowp vec4 vShadeColor;	\n";
+			m_part += "noperspective IN lowp vec4 vShadeColorNoperspective;	\n";
 		else
-			m_part += "IN lowp vec4 vShadeColor;	\n";
+			m_part += "IN lowp vec4 vShadeColorNoperspective;				\n";
 
-		m_part += "IN lowp float vNumLights;	\n";
+		m_part +=
+			"IN lowp vec4 vShadeColor;	\n"
+			"IN lowp float vNumLights;	\n"
+		;
 
 		if (config.frameBufferEmulation.N64DepthCompare == Config::dcFast && _glinfo.ext_fetch) {
 			m_part +=
-				"layout(location = 0) OUT lowp vec4 fragColor;	\n"
-				"layout(location = 1) inout highp vec4 depthZ;	\n"
+				"layout(location = 0) OUT lowp vec4 fragColor;		\n"
+				"layout(location = 1) inout highp vec4 depthZ;		\n"
 				"layout(location = 2) inout highp vec4 depthDeltaZ;	\n"
-				;
+			;
 		} else {
 			m_part +=
 				"OUT lowp vec4 fragColor;	\n"
@@ -1053,16 +1074,18 @@ class ShaderFragmentHeaderMipMap : public ShaderPart
 	}
 };
 
-class ShaderFragmentHeaderClampWrapMirror : public ShaderPart
+class ShaderFragmentHeaderTextureEngine : public ShaderPart
 {
 public:
-	ShaderFragmentHeaderClampWrapMirror(const opengl::GLInfo & _glinfo)
+	ShaderFragmentHeaderTextureEngine(const opengl::GLInfo & _glinfo)
 	{
 		m_part =
 			"highp vec2 clampWrapMirror(in highp vec2 vTexCoord,	\n"
-			"	in highp vec4 vClamp, in highp vec2 vWrap,			\n"
-			"	in lowp vec2 vMirror, in highp vec2 vOffset);		\n"
-		;
+			"	in highp vec2 vWrap, in highp vec2 vClamp,			\n"
+			"	in lowp vec2 vClampEn, in lowp vec2 vMirrorEn );		\n"
+			 "lowp vec2[5] textureEngine0(in highp vec2 texCoord); \n"
+			 "lowp vec2[5] textureEngine1(in highp vec2 texCoord); \n"
+			;
 	}
 };
 
@@ -1080,7 +1103,7 @@ class ShaderFragmentHeaderReadMSTex : public ShaderPart
 			(g_cycleType == G_CYC_COPY || g_textureConvert.useTextureFiltering()))
 		{
 			shader <<
-				"lowp vec4 readTexMS(in lowp sampler2DMS mstex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha);\n";
+				"lowp vec4 readTexMS(in lowp sampler2DMS mstex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha);\n";
 		}
 	}
 
@@ -1127,6 +1150,7 @@ class ShaderFragmentHeaderDepthCompare : public ShaderPart
 
 class ShaderFragmentHeaderReadTex : public ShaderPart
 {
+#define USE_TEX_WORKAROUND // Enable workaround for issue with Mario Tennis Intro
 public:
 	ShaderFragmentHeaderReadTex(const opengl::GLInfo & _glinfo) : m_glinfo(_glinfo)
 	{
@@ -1135,50 +1159,61 @@ class ShaderFragmentHeaderReadTex : public ShaderPart
 	void write(std::stringstream & shader) const override
 	{
 		std::string shaderPart;
-
 		if (!m_glinfo.isGLES2) {
 
 			if (g_textureConvert.useTextureFiltering()) {
 				shaderPart += "uniform lowp int uTextureFilterMode;								\n";
+				shaderPart += "#define TEX_NEAREST(name, tex, tcData)							\\\n"
+					"{																			\\\n"
+					" name = texelFetch(tex, ivec2(tcData[0]), 0); \\\n"
+					"}																			\n"
+					;
 				switch (config.texture.bilinearMode + config.texture.enableHalosRemoval * 2) {
 				case BILINEAR_3POINT:
 					// 3 point texture filtering.
 					// Original author: ArthurCarvalho
 					// GLSL implementation: twinaphex, mupen64plus-libretro project.
 					shaderPart +=
-						"#define TEX_OFFSET(off, tex, texCoord) texture(tex, texCoord - (off)/texSize)			\n"
-						"#define TEX_FILTER(name, tex, texCoord)												\\\n"
+						"#define TEX_FILTER(name, tex, tcData)												\\\n"
 						"  {																					\\\n"
-						"  mediump vec2 texSize = vec2(textureSize(tex,0));										\\\n"
-						"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));							\\\n"
-						"  offset -= step(1.0, offset.x + offset.y);											\\\n"
-						"  lowp vec4 c0 = TEX_OFFSET(offset, tex, texCoord);									\\\n"
-						"  lowp vec4 c1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y), tex, texCoord);	\\\n"
-						"  lowp vec4 c2 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)), tex, texCoord);	\\\n"
-						"  name = c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0); 							\\\n"
+						"  lowp float bottomRightTri = step(1.0, tcData[4].s + tcData[4].t);					\\\n"
+#ifndef USE_TEX_WORKAROUND
+						"  lowp vec4 c00 = texelFetch(tex, ivec2(tcData[0]), 0); \\\n"
+						"  lowp vec4 c01 = texelFetch(tex, ivec2(tcData[1]), 0); \\\n"
+						"  lowp vec4 c10 = texelFetch(tex, ivec2(tcData[2]), 0); \\\n"
+						"  lowp vec4 c11 = texelFetch(tex, ivec2(tcData[3]), 0); \\\n"
+#else
+						"  lowp vec2 texSize = vec2(textureSize(tex,0)); \\\n"
+						"  lowp vec4 c00 = texture(tex, (tcData[0] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c01 = texture(tex, (tcData[1] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c10 = texture(tex, (tcData[2] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c11 = texture(tex, (tcData[3] + 0.5)/texSize); \\\n"
+#endif
+						"  lowp vec4 c0 = c00 + tcData[4].s*(c10-c00) + tcData[4].t*(c01-c00);			\\\n"
+						"  lowp vec4 c1 = c11 + (1.0-tcData[4].s)*(c01-c11) + (1.0-tcData[4].t)*(c10-c11); \\\n"
+						"  name = c0 + bottomRightTri * (c1-c0); \\\n"
 						"  }																					\n"
 						;
 				break;
 				case BILINEAR_STANDARD:
 					shaderPart +=
-						"#define TEX_OFFSET(off, tex, texCoord) texture(tex, texCoord - (off)/texSize)									\n"
-						"#define TEX_FILTER(name, tex, texCoord)																		\\\n"
-						"{																												\\\n"
-						"  mediump vec2 texSize = vec2(textureSize(tex,0));																\\\n"
-						"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));													\\\n"
-						"  offset -= step(1.0, offset.x + offset.y);																	\\\n"
-						"  lowp vec4 zero = vec4(0.0);																					\\\n"
-						"																												\\\n"
-						"  lowp vec4 p0q0 = TEX_OFFSET(offset, tex, texCoord);															\\\n"
-						"  lowp vec4 p1q0 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y), tex, texCoord);						\\\n"
-						"																												\\\n"
-						"  lowp vec4 p0q1 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)), tex, texCoord);						\\\n"
-						"  lowp vec4 p1q1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y - sign(offset.y)), tex, texCoord);		\\\n"
-						"																												\\\n"
-						"  mediump vec2 interpolationFactor = abs(offset);																\\\n"
-						"  lowp vec4 pInterp_q0 = mix( p0q0, p1q0, interpolationFactor.x ); 											\\\n" // Interpolates top row in X direction.
-						"  lowp vec4 pInterp_q1 = mix( p0q1, p1q1, interpolationFactor.x ); 											\\\n" // Interpolates bottom row in X direction.
-						"  name = mix( pInterp_q0, pInterp_q1, interpolationFactor.y ); 												\\\n" // Interpolate in Y direction.
+						"#define TEX_FILTER(name, tex, tcData)																		\\\n"
+						"{																											\\\n"
+#ifndef USE_TEX_WORKAROUND
+						"  lowp vec4 c00 = texelFetch(tex, ivec2(tcData[0]), 0); \\\n"
+						"  lowp vec4 c01 = texelFetch(tex, ivec2(tcData[1]), 0); \\\n"
+						"  lowp vec4 c10 = texelFetch(tex, ivec2(tcData[2]), 0); \\\n"
+						"  lowp vec4 c11 = texelFetch(tex, ivec2(tcData[3]), 0); \\\n"
+#else
+						"  lowp vec2 texSize = vec2(textureSize(tex,0)); \\\n"
+						"  lowp vec4 c00 = texture(tex, (tcData[0] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c01 = texture(tex, (tcData[1] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c10 = texture(tex, (tcData[2] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c11 = texture(tex, (tcData[3] + 0.5)/texSize); \\\n"
+#endif
+						"  lowp vec4 c0 = c00 + tcData[4].s * (c10-c00);						\\\n"
+						"  lowp vec4 c1 = c01 + tcData[4].s * (c11-c01);						\\\n"
+						"  name = c0 + tcData[4].t * (c1-c0);									\\\n"
 						"}																												\n"
 						;
 				break;
@@ -1187,89 +1222,76 @@ class ShaderFragmentHeaderReadTex : public ShaderPart
 					// Original author: ArthurCarvalho
 					// GLSL implementation: twinaphex, mupen64plus-libretro project.
 					shaderPart +=
-						"#define TEX_OFFSET(off, tex, texCoord) texture(tex, texCoord - (off)/texSize)									\n"
-						"#define TEX_FILTER(name, tex, texCoord)												\\\n"
+						"#define TEX_FILTER(name, tex, tcData)												\\\n"
 						"{																						\\\n"
-						"  mediump vec2 texSize = vec2(textureSize(tex,0));										\\\n"
-						"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));							\\\n"
-						"  offset -= step(1.0, offset.x + offset.y);											\\\n"
-						"  lowp vec4 c0 = TEX_OFFSET(offset, tex, texCoord);									\\\n"
-						"  lowp vec4 c1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y), tex, texCoord);	\\\n"
-						"  lowp vec4 c2 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)), tex, texCoord);	\\\n"
-						"																						\\\n"
+						"  lowp float bottomRightTri = step(1.0, tcData[4].s + tcData[4].t);					\\\n"
+#ifndef USE_TEX_WORKAROUND
+						"  lowp vec4 c00 = texelFetch(tex, ivec2(tcData[0]), 0);								\\\n"
+						"  lowp vec4 c01 = texelFetch(tex, ivec2(tcData[1]), 0);								\\\n"
+						"  lowp vec4 c10 = texelFetch(tex, ivec2(tcData[2]), 0);								\\\n"
+						"  lowp vec4 c11 = texelFetch(tex, ivec2(tcData[3]), 0);								\\\n"
+#else
+						"  lowp vec2 texSize = vec2(textureSize(tex,0)); \\\n"
+						"  lowp vec4 c00 = texture(tex, (tcData[0] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c01 = texture(tex, (tcData[1] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c10 = texture(tex, (tcData[2] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c11 = texture(tex, (tcData[3] + 0.5)/texSize); \\\n"
+#endif
 						"  if(uEnableAlphaTest == 1 ){															\\\n" // Calculate premultiplied color values
-						"    c0.rgb *= c0.a;																	\\\n"
-						"    c1.rgb *= c1.a;																	\\\n"
-						"    c2.rgb *= c2.a;																	\\\n"
-						"    name = c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0); 						\\\n"
-						"    name.rgb /= name.a;																\\\n" // Divide alpha to get actual color value
+						"    c00.rgb *= c00.a;																	\\\n"
+						"    c01.rgb *= c01.a;																	\\\n"
+						"    c10.rgb *= c10.a;																	\\\n"
+						"    c11.rgb *= c11.a;																	\\\n"
 						"  }																					\\\n"
-						"  else name = c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0); 						\\\n"
+						"  lowp vec4 c0 = c00 + tcData[4].s*(c10-c00) + tcData[4].t*(c01-c00);				\\\n"
+						"  lowp vec4 c1 = c11 + (1.0-tcData[4].s)*(c01-c11) + (1.0-tcData[4].t)*(c10-c11);	\\\n"
+						"  name = c0 + bottomRightTri * (c1-c0); \\\n"
+						"  if(uEnableAlphaTest == 1 ) name.rgb /= name.a;										\\\n" // Divide alpha to get actual color value
 						"}																						\n"
 						;
 				break;
 				case BILINEAR_STANDARD_WITH_COLOR_BLEEDING_AND_PREMULTIPLIED_ALPHA:
 					shaderPart +=
-						"#define TEX_OFFSET(off, tex, texCoord) texture(tex, texCoord - (off)/texSize)									\n"
-						"#define TEX_FILTER(name, tex, texCoord)																		\\\n"
-						"{																												\\\n"
-						"  mediump vec2 texSize = vec2(textureSize(tex,0));																\\\n"
-						"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));													\\\n"
-						"  offset -= step(1.0, offset.x + offset.y);																	\\\n"
-						"  lowp vec4 zero = vec4(0.0);																					\\\n"
-						"																												\\\n"
-						"  lowp vec4 p0q0 = TEX_OFFSET(offset, tex, texCoord);															\\\n"
-						"  lowp vec4 p1q0 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y), tex, texCoord);						\\\n"
-						"																												\\\n"
-						"  lowp vec4 p0q1 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)), tex, texCoord);						\\\n"
-						"  lowp vec4 p1q1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y - sign(offset.y)), tex, texCoord);		\\\n"
-						"																												\\\n"
-						"  if(uEnableAlphaTest == 1){																					\\\n" // Calculate premultiplied color values
-						"    p0q0.rgb *= p0q0.a;																						\\\n"
-						"    p1q0.rgb *= p1q0.a;																						\\\n"
-						"    p0q1.rgb *= p0q1.a;																						\\\n"
-						"    p1q1.rgb *= p1q1.a;																						\\\n"
-						"																												\\\n"
-						"    mediump vec2 interpolationFactor = abs(offset);															\\\n"
-						"    lowp vec4 pInterp_q0 = mix( p0q0, p1q0, interpolationFactor.x ); 											\\\n" // Interpolates top row in X direction.
-						"    lowp vec4 pInterp_q1 = mix( p0q1, p1q1, interpolationFactor.x ); 											\\\n" // Interpolates bottom row in X direction.
-						"    name = mix( pInterp_q0, pInterp_q1, interpolationFactor.y ); 												\\\n" // Interpolate in Y direction.
-						"    name.rgb /= name.a;																						\\\n" // Divide alpha to get actual color value
-						"  }																											\\\n"
-						"  else if(uCvgXAlpha == 1){																					\\\n" // Use texture bleeding for mk64
-						"    if(p0q0.a > p1q0.a) p1q0.rgb = p0q0.rgb;																	\\\n"
-						"    if(p1q0.a > p0q0.a) p0q0.rgb = p1q0.rgb;																	\\\n"
-						"    if(p0q1.a > p1q1.a) p1q1.rgb = p0q1.rgb;																	\\\n"
-						"    if(p1q1.a > p0q1.a) p0q1.rgb = p1q1.rgb;																	\\\n"
-						"    if(p0q0.a > p0q1.a) p0q1.rgb = p0q0.rgb;																	\\\n"
-						"    if(p0q1.a > p0q0.a) p0q0.rgb = p0q1.rgb;																	\\\n"
-						"    if(p1q0.a > p1q1.a) p1q1.rgb = p1q0.rgb;																	\\\n"
-						"    if(p1q1.a > p1q0.a) p1q0.rgb = p1q1.rgb;																	\\\n"
-						"																												\\\n"
-						"    mediump vec2 interpolationFactor = abs(offset);															\\\n"
-						"    lowp vec4 pInterp_q0 = mix( p0q0, p1q0, interpolationFactor.x );											\\\n" // Interpolates top row in X direction.
-						"    lowp vec4 pInterp_q1 = mix( p0q1, p1q1, interpolationFactor.x );											\\\n" // Interpolates bottom row in X direction.
-						"    name = mix( pInterp_q0, pInterp_q1, interpolationFactor.y );												\\\n"
-						"  }																											\\\n"
-						"  else{																										\\\n"
-						"    mediump vec2 interpolationFactor = abs(offset);															\\\n"
-						"    lowp vec4 pInterp_q0 = mix( p0q0, p1q0, interpolationFactor.x ); 											\\\n" // Interpolates top row in X direction.
-						"    lowp vec4 pInterp_q1 = mix( p0q1, p1q1, interpolationFactor.x ); 											\\\n" // Interpolates bottom row in X direction.
-						"    name = mix( pInterp_q0, pInterp_q1, interpolationFactor.y ); 												\\\n" // Interpolate in Y direction.
-						"  }																											\\\n"
-						"}																												\n"
+						"#define TEX_FILTER(name, tex, tcData)																	\\\n"
+						"{																										\\\n"
+#ifndef USE_TEX_WORKAROUND
+						"  lowp vec4 c00 = texelFetch(tex, ivec2(tcData[0]), 0);												\\\n"
+						"  lowp vec4 c01 = texelFetch(tex, ivec2(tcData[1]), 0);												\\\n"
+						"  lowp vec4 c10 = texelFetch(tex, ivec2(tcData[2]), 0);												\\\n"
+						"  lowp vec4 c11 = texelFetch(tex, ivec2(tcData[3]), 0);												\\\n"
+#else
+						"  lowp vec2 texSize = vec2(textureSize(tex,0)); \\\n"
+						"  lowp vec4 c00 = texture(tex, (tcData[0] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c01 = texture(tex, (tcData[1] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c10 = texture(tex, (tcData[2] + 0.5)/texSize); \\\n"
+						"  lowp vec4 c11 = texture(tex, (tcData[3] + 0.5)/texSize); \\\n"
+#endif
+						"  if(uEnableAlphaTest == 1){																			\\\n" // Calculate premultiplied color values
+						"    c00.rgb *= c00.a;																					\\\n"
+						"    c01.rgb *= c01.a;																					\\\n"
+						"    c10.rgb *= c10.a;																					\\\n"
+						"    c11.rgb *= c11.a;																					\\\n"
+						"  }																									\\\n"
+						"  lowp vec4 c0 = c00 + tcData[4].s * (c10-c00);														\\\n"
+						"  lowp vec4 c1 = c01 + tcData[4].s * (c11-c01);														\\\n"
+						"  name = c0 + tcData[4].t * (c1-c0);																	\\\n"
+						"  if(uEnableAlphaTest == 1)  name.rgb /= name.a;														\\\n" 
+						"}																										\n"
 						;
 				break;
 				}
 				shaderPart +=
-					"#define READ_TEX(name, tex, texCoord, fbMonochrome, fbFixedAlpha)	\\\n"
+					"#define READ_TEX(name, tex, tcData, fbMonochrome, fbFixedAlpha)	\\\n"
 					"  {																\\\n"
 					"  if (fbMonochrome == 3) {											\\\n"
 					"    mediump ivec2 coord = ivec2(gl_FragCoord.xy);					\\\n"
 					"    name = texelFetch(tex, coord, 0);								\\\n"
 					"  } else {															\\\n"
-					"    if (uTextureFilterMode == 0) name = texture(tex, texCoord);	\\\n"
-					"    else TEX_FILTER(name, tex, texCoord);			 				\\\n"
+					"    if (uTextureFilterMode == 0)									\\\n"
+					"  {																\\\n"
+					"    TEX_NEAREST(name, tex, tcData);								\\\n"
+					"  }																\\\n"
+					"    else TEX_FILTER(name, tex, tcData);			 				\\\n"
 					"  }																\\\n"
 					"  if (fbMonochrome == 1) name = vec4(name.r);						\\\n"
 					"  else if (fbMonochrome == 2) 										\\\n"
@@ -1298,15 +1320,15 @@ class ShaderFragmentHeaderReadTex : public ShaderPart
 					"  iconvert.b = icolor.b + (uConvertParams[3]*icolor.r + 128)/256;	\\\n"
 					"  iconvert.a = icolor.b;											\\\n"
 					"  name = vec4(iconvert)/255.0;										\n"
-					"#define YUVCONVERT_TEX0(name, tex, texCoord, format)				\\\n"
+					"#define YUVCONVERT_TEX0(name, tex, tcData, format)				\\\n"
 					"  {																\\\n"
-					"  name = texture(tex, texCoord);									\\\n"
+					"  name = texelFetch(tex, ivec2(tcData[0]), 0);									\\\n"
 					"  YUVCONVERT(name, format)											\\\n"
 					"  }																\n"
-					"#define YUVCONVERT_TEX1(name, tex, texCoord, format, prev)			\\\n"
+					"#define YUVCONVERT_TEX1(name, tex, tcData, format, prev)			\\\n"
 					"  {																\\\n"
 					"  if (uTextureConvert != 0) name = prev;							\\\n"
-					"  else name = texture(tex, texCoord);								\\\n"
+					"  else name = texelFetch(tex, ivec2(tcData[0]), 0);								\\\n"
 					"  YUVCONVERT(name, format)											\\\n"
 					"  }																\n"
 					;
@@ -1316,7 +1338,7 @@ class ShaderFragmentHeaderReadTex : public ShaderPart
 			if (g_textureConvert.useTextureFiltering()) {
 				shaderPart +=
 					"uniform lowp int uTextureFilterMode;								\n"
-					"lowp vec4 readTex(in sampler2D tex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha);	\n"
+					"lowp vec4 readTex(in sampler2D tex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha);	\n"
 					;
 			}
 			if (g_textureConvert.useYUVCoversion()) {
@@ -1324,7 +1346,7 @@ class ShaderFragmentHeaderReadTex : public ShaderPart
 					"uniform lowp ivec2 uTextureFormat;									\n"
 					"uniform lowp int uTextureConvert;									\n"
 					"uniform mediump ivec4 uConvertParams;								\n"
-					"lowp vec4 YUV_Convert(in sampler2D tex, in highp vec2 texCoord, in lowp int convert, in lowp int format, in lowp vec4 prev);	\n"
+					"lowp vec4 YUV_Convert(in sampler2D tex, in highp vec2[5] tcData, in lowp int convert, in lowp int format, in lowp vec4 prev);	\n"
 					;
 			}
 		}
@@ -1343,13 +1365,13 @@ class ShaderFragmentHeaderReadTexCopyMode : public ShaderPart
 	{
 		if (!_glinfo.isGLES2) {
 			m_part =
-				"#define READ_TEX(name, tex, texCoord, fbMonochrome, fbFixedAlpha)	\\\n"
+				"#define READ_TEX(name, tex, tcData, fbMonochrome, fbFixedAlpha)	\\\n"
 				"  {																\\\n"
 				"  if (fbMonochrome == 3) {											\\\n"
 				"    mediump ivec2 coord = ivec2(gl_FragCoord.xy);					\\\n"
 				"    name = texelFetch(tex, coord, 0);								\\\n"
 				"  } else {															\\\n"
-				"    name = texture(tex, texCoord);									\\\n"
+				"    name = texelFetch(tex, ivec2(tcData[0]),0);					\\\n"
 				"  }																\\\n"
 				"  if (fbMonochrome == 1) name = vec4(name.r);						\\\n"
 				"  else if (fbMonochrome == 2) 										\\\n"
@@ -1363,7 +1385,7 @@ class ShaderFragmentHeaderReadTexCopyMode : public ShaderPart
 				;
 		} else {
 			m_part =
-				"lowp vec4 readTex(in sampler2D tex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha);	\n"
+				"lowp vec4 readTex(in sampler2D tex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha);	\n"
 			;
 		}
 	}
@@ -1387,7 +1409,8 @@ class ShaderFragmentMain : public ShaderPart
 			"  lowp vec4 vec_color;				\n"
 			"  lowp float alpha1;				\n"
 			"  lowp vec3 color1, input_color;	\n"
-			;
+			"  lowp vec4 shadeColor = uScreenSpaceTriangle == 0 ? vShadeColor : vShadeColorNoperspective;	\n"
+		;
 		m_part += "#define WRAP(x, low, high) mod((x)-(low), (high)-(low)) + (low) \n"; // Return wrapped value of x in interval [low, high)
 		// m_part += "#define WRAP(x, low, high) (x) - ((high)-(low)) * floor(((x)-(low))/((high)-(low)))  \n"; // Perhaps more compatible?
 		// m_part += "#define WRAP(x, low, high) (x) + ((high)-(low)) * (1.0-step(low,x)) - ((high)-(low)) * step(high,x) \n"; // Step based version. Only wraps correctly if input is in the range [low-(high-low), high + (high-low)). Similar to old code.
@@ -1413,6 +1436,7 @@ class ShaderFragmentMain2Cycle : public ShaderPart
 			"  lowp vec4 vec_color, combined_color;		\n"
 			"  lowp float alpha1, alpha2;				\n"
 			"  lowp vec3 color1, color2, input_color;	\n"
+			"  lowp vec4 shadeColor = uScreenSpaceTriangle == 0 ? vShadeColor : vShadeColorNoperspective;	\n"
 		;
 		m_part += "#define WRAP(x, low, high) mod((x)-(low), (high)-(low)) + (low) \n"; // Return wrapped value of x in interval [low, high)
 		// m_part += "#define WRAP(x, low, high) (x) - ((high)-(low)) * floor(((x)-(low))/((high)-(low)))  \n"; // Perhaps more compatible?
@@ -1428,35 +1452,13 @@ class ShaderFragmentBlendMux : public ShaderPart
 		if (config.generalEmulation.enableLegacyBlending == 0) {
 			m_part =
 				"  lowp mat4 muxPM = mat4(vec4(0.0), vec4(0.0), uBlendColor, uFogColor);	\n"
-				"  lowp vec4 muxA = vec4(0.0, uFogColor.a, vShadeColor.a, 0.0);				\n"
+				"  lowp vec4 muxA = vec4(0.0, uFogColor.a, shadeColor.a, 0.0);				\n"
 				"  lowp vec4 muxB = vec4(0.0, 1.0, 1.0, 0.0);								\n"
 			;
 		}
 	}
 };
 
-class ShaderFragmentClampWrapMirrorTex0 : public ShaderPart
-{
-public:
-	ShaderFragmentClampWrapMirrorTex0(const opengl::GLInfo & _glinfo)
-	{
-		m_part =
-			"  texCoord0 = clampWrapMirror(vTexCoord0, uTexClamp0, uTexWrap0, uTexMirror0, uTexScale0);	\n"
-			;
-	}
-};
-
-class ShaderFragmentClampWrapMirrorTex1 : public ShaderPart
-{
-public:
-	ShaderFragmentClampWrapMirrorTex1(const opengl::GLInfo & _glinfo)
-	{
-		m_part =
-			"  texCoord1 = clampWrapMirror(vTexCoord1, uTexClamp1, uTexWrap1, uTexMirror1, uTexScale1);	\n"
-			;
-	}
-};
-
 class ShaderFragmentReadTexMipmap : public ShaderPart
 {
 public:
@@ -1477,20 +1479,20 @@ class ShaderFragmentReadTexCopyMode : public ShaderPart
 		if (_glinfo.isGLES2) {
 			m_part =
 				"  nCurrentTile = 0; \n"
-				"  lowp vec4 readtex0 = readTex(uTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0]);		\n"
+				"  lowp vec4 readtex0 = readTex(uTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0]);		\n"
 				;
 		} else {
 			if (config.video.multisampling > 0) {
 				m_part =
 					"  lowp vec4 readtex0;																	\n"
 					"  if (uMSTexEnabled[0] == 0) {															\n"
-					"      READ_TEX(readtex0, uTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0])		\n"
-					"  } else readtex0 = readTexMS(uMSTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0]);\n"
+					"      READ_TEX(readtex0, uTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0])		\n"
+					"  } else readtex0 = readTexMS(uMSTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0]);\n"
 					;
 			} else {
 				m_part =
 					"  lowp vec4 readtex0;																	\n"
-					"  READ_TEX(readtex0, uTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0])			\n"
+					"  READ_TEX(readtex0, uTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0])			\n"
 					;
 			}
 		}
@@ -1512,27 +1514,27 @@ class ShaderFragmentReadTex0 : public ShaderPart
 
 			shaderPart = "  nCurrentTile = 0; \n";
 			if (g_textureConvert.getBilerp0()) {
-				shaderPart += "  lowp vec4 readtex0 = readTex(uTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0]);		\n";
+				shaderPart += "  lowp vec4 readtex0 = readTex(uTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0]);		\n";
 			} else {
 				shaderPart += "  lowp vec4 tmpTex = vec4(0.0);																\n"
-							  "  lowp vec4 readtex0 = YUV_Convert(uTex0, texCoord0, 0, uTextureFormat[0], tmpTex);			\n";
+							  "  lowp vec4 readtex0 = YUV_Convert(uTex0, tcData0, 0, uTextureFormat[0], tmpTex);			\n";
 			}
 
 		} else {
 
 			if (!g_textureConvert.getBilerp0()) {
 				shaderPart = "  lowp vec4 readtex0;																			\n"
-							 "  YUVCONVERT_TEX0(readtex0, uTex0, texCoord0, uTextureFormat[0])								\n";
+							 "  YUVCONVERT_TEX0(readtex0, uTex0, tcData0, uTextureFormat[0])								\n";
 			} else {
 				if (config.video.multisampling > 0) {
 					shaderPart =
 						"  lowp vec4 readtex0;																				\n"
 						"  if (uMSTexEnabled[0] == 0) {																		\n"
-						"    READ_TEX(readtex0, uTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0])						\n"
-						"  } else readtex0 = readTexMS(uMSTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0]);			\n";
+						"    READ_TEX(readtex0, uTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0])						\n"
+						"  } else readtex0 = readTexMS(uMSTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0]);			\n";
 				} else {
 					shaderPart = "  lowp vec4 readtex0;																		\n"
-								 "  READ_TEX(readtex0, uTex0, texCoord0, uFbMonochrome[0], uFbFixedAlpha[0])				\n";
+								" READ_TEX(readtex0, uTex0, tcData0, uFbMonochrome[0], uFbFixedAlpha[0])				\n";
 				}
 			}
 
@@ -1561,9 +1563,9 @@ class ShaderFragmentReadTex1 : public ShaderPart
 			shaderPart = "  nCurrentTile = 1; \n";
 
 			if (g_textureConvert.getBilerp1()) {
-				shaderPart += "  lowp vec4 readtex1 = readTex(uTex1, texCoord1, uFbMonochrome[1], uFbFixedAlpha[1]);				\n";
+				shaderPart += "  lowp vec4 readtex1 = readTex(uTex1, tcData1, uFbMonochrome[1], uFbFixedAlpha[1]);				\n";
 			} else {
-				shaderPart += "  lowp vec4 readtex1 = YUV_Convert(uTex1, texCoord1, uTextureConvert, uTextureFormat[1], readtex0);	\n";
+				shaderPart += "  lowp vec4 readtex1 = YUV_Convert(uTex1, tcData1, uTextureConvert, uTextureFormat[1], readtex0);	\n";
 			}
 
 		} else {
@@ -1571,17 +1573,18 @@ class ShaderFragmentReadTex1 : public ShaderPart
 			if (!g_textureConvert.getBilerp1()) {
 				shaderPart =
 					"  lowp vec4 readtex1;																							\n"
-					"    YUVCONVERT_TEX1(readtex1, uTex1, texCoord1, uTextureFormat[1], readtex0)					\n";
+					"    YUVCONVERT_TEX1(readtex1, uTex1, tcData1, uTextureFormat[1], readtex0)					\n";
 			} else {
 				if (config.video.multisampling > 0) {
 					shaderPart =
 						"  lowp vec4 readtex1;																						\n"
 						"  if (uMSTexEnabled[1] == 0) {																				\n"
-						"    READ_TEX(readtex1, uTex1, texCoord1, uFbMonochrome[1], uFbFixedAlpha[1])								\n"
-						"  } else readtex1 = readTexMS(uMSTex1, texCoord1, uFbMonochrome[1], uFbFixedAlpha[1]);					\n";
+						"    READ_TEX(readtex1, uTex1, tcData1, uFbMonochrome[1], uFbFixedAlpha[1])								\n"
+						"  } else readtex1 = readTexMS(uMSTex1, tcData1, uFbMonochrome[1], uFbFixedAlpha[1]);					\n";
 				} else {
 					shaderPart = "  lowp vec4 readtex1;																				\n"
-								 "  READ_TEX(readtex1, uTex1, texCoord1, uFbMonochrome[1], uFbFixedAlpha[1])						\n";
+								"  READ_TEX(readtex1, uTex1, tcData1, uFbMonochrome[1], uFbFixedAlpha[1])						\n";
+
 				}
 			}
 
@@ -1851,6 +1854,23 @@ class ShaderMipmap : public ShaderPart
 	ShaderMipmap(const opengl::GLInfo & _glinfo)
 	{
 		if (_glinfo.isGLES2) {
+			"uniform mediump vec2 uTextureSize[2];										\n"
+				"lowp vec4 TextureMipMap(in sampler2D tex, in highp vec2[5] tcData, in lowp float lod)	\n"
+				"{																					\n"
+				"  mediump vec2 texSize;															\n"
+				"  if (nCurrentTile == 0)															\n"
+				"    texSize = uTextureSize[0];														\n"
+				"  else																				\n"
+				"    texSize = uTextureSize[1];														\n"
+				"  lowp vec4 c00 = texture2DLodEXT(tex, (tcData[0] + 0.5)/texSize, lod);			\n"
+				"  lowp vec4 c01 = texture2DLodEXT(tex, (tcData[1] + 0.5)/texSize, lod);			\n"
+				"  lowp vec4 c10 = texture2DLodEXT(tex, (tcData[2] + 0.5)/texSize, lod);			\n"
+				"  lowp vec4 c11 = texture2DLodEXT(tex, (tcData[3] + 0.5)/texSize, lod);			\n"
+				"  lowp vec4 c0 = c00 + tcData[4].s * (c10-c00);									\n"
+				"  lowp vec4 c1 = c01 + tcData[4].s * (c11-c01);									\n"
+				"  return c0 + tcData[4].t * (c1-c0);												\n"
+				"  }																				\n"
+				;
 			if (config.generalEmulation.enableLOD == 0) {
 				// Fake mipmap
 				m_part =
@@ -1858,8 +1878,8 @@ class ShaderMipmap : public ShaderPart
 					"uniform mediump float uMinLod;		\n"
 					"														\n"
 					"mediump float mipmap(out lowp vec4 readtex0, out lowp vec4 readtex1) {	\n"
-					"  readtex0 = texture2D(uTex0, texCoord0);				\n"
-					"  readtex1 = texture2D(uTex1, texCoord1);				\n"
+					"  readtex0 = TextureMipMap(uTex0, tcData0, 0.0);				\n"
+					"  readtex1 = TextureMipMap(uTex1, tcData1, 0.0);				\n"
 					"  if (uMaxTile == 0) return 1.0;						\n"
 					"  return uMinLod;										\n"
 					"}														\n"
@@ -1872,8 +1892,8 @@ class ShaderMipmap : public ShaderPart
 					"uniform lowp int uTextureDetail;	\n"
 					"														\n"
 					"mediump float mipmap(out lowp vec4 readtex0, out lowp vec4 readtex1) {	\n"
-					"  readtex0 = texture2D(uTex0, texCoord0);				\n"
-					"  readtex1 = texture2DLodEXT(uTex1, texCoord1, 0.0);		\n"
+					"  readtex0 = TextureMipMap(uTex0, tcData0, 0.0);		\n"
+					"  readtex1 = TextureMipMap(uTex1, tcData1, 0.0);		\n"
 					"														\n"
 					"  mediump float fMaxTile = float(uMaxTile);			\n"
 					"  mediump vec2 dx = abs(dFdx(vLodTexCoord)) * uScreenScale;	\n"
@@ -1902,9 +1922,9 @@ class ShaderMipmap : public ShaderPart
 					"  lod_tile = min(lod_tile, fMaxTile);					\n"
 					"  lowp float lod_tile_m1 = max(0.0, lod_tile - 1.0);	\n"
 					"  lowp float lod_tile_p1 = min(fMaxTile - 1.0, lod_tile + 1.0);	\n"
-					"  lowp vec4 lodT = texture2DLodEXT(uTex1, texCoord1, lod_tile);	\n"
-					"  lowp vec4 lodT_m1 = texture2DLodEXT(uTex1, texCoord1, lod_tile_m1);	\n"
-					"  lowp vec4 lodT_p1 = texture2DLodEXT(uTex1, texCoord1, lod_tile_p1);	\n"
+					"  lowp vec4 lodT = TextureMipMap(uTex1, tcData1, lod_tile);	\n"
+					"  lowp vec4 lodT_m1 = TextureMipMap(uTex1, tcData1, lod_tile_m1);	\n"
+					"  lowp vec4 lodT_p1 = TextureMipMap(uTex1, tcData1, lod_tile_p1);	\n"
 					"  if (lod_tile < 1.0) {								\n"
 					"    if (magnify) {									\n"
 					//     !sharpen && !detail
@@ -1931,52 +1951,49 @@ class ShaderMipmap : public ShaderPart
 			}
 		}
 		else {
+			if (config.texture.bilinearMode == BILINEAR_3POINT)
+				m_part =
+				"#define READ_TEX_MIPMAP(name, tex, tcData, lod)																		\\\n"
+				"{																												\\\n"
+				"  lowp float bottomRightTri = step(1.0, tcData[4].s + tcData[4].t);					\\\n"
+				"  lowp vec2 lod_scale = vec2(textureSize(tex,int(lod))) / vec2(textureSize(tex,0)); \\\n"
+				"  lowp vec4 c00 = texelFetch(tex, ivec2(tcData[0]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c01 = texelFetch(tex, ivec2(tcData[1]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c10 = texelFetch(tex, ivec2(tcData[2]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c11 = texelFetch(tex, ivec2(tcData[3]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c0 = c00 + tcData[4].s*(c10-c00) + tcData[4].t*(c01-c00);			\\\n"
+				"  lowp vec4 c1 = c11 + (1.0-tcData[4].s)*(c01-c11) + (1.0-tcData[4].t)*(c10-c11); \\\n"
+				"  name = c0 + bottomRightTri * (c1-c0); \\\n"
+				"}																												\n"
+				;
+			else
+				m_part =
+				"#define READ_TEX_MIPMAP(name, tex, tcData, lod)																		\\\n"
+				"{																												\\\n"
+				"  lowp vec2 lod_scale = vec2(textureSize(tex,int(lod))) / vec2(textureSize(tex,0)); \\\n"
+				"  lowp vec4 c00 = texelFetch(tex, ivec2(tcData[0]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c01 = texelFetch(tex, ivec2(tcData[1]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c10 = texelFetch(tex, ivec2(tcData[2]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c11 = texelFetch(tex, ivec2(tcData[3]*lod_scale), int(lod)); \\\n"
+				"  lowp vec4 c0 = c00 + tcData[4].s * (c10-c00);						\\\n"
+				"  lowp vec4 c1 = c01 + tcData[4].s * (c11-c01);						\\\n"
+				"  name = c0 + tcData[4].t * (c1-c0);									\\\n"
+				"}																												\n"
+				;
 			if (config.generalEmulation.enableLOD == 0) {
 				// Fake mipmap
-				m_part =
+				m_part +=
 					"uniform lowp int uMaxTile;			\n"
 					"uniform mediump float uMinLod;		\n"
 					"														\n"
 					"mediump float mipmap(out lowp vec4 readtex0, out lowp vec4 readtex1) {	\n"
-					"  readtex0 = texture(uTex0, texCoord0);				\n"
-					"  readtex1 = texture(uTex1, texCoord1);				\n"
-					"  if (uMaxTile == 0) return 1.0;						\n"
-					"  return uMinLod;										\n"
-					"}														\n"
+					"  READ_TEX_MIPMAP(readtex0, uTex0, tcData0, 0);			\n"
+					"  READ_TEX_MIPMAP(readtex1, uTex1, tcData1, 0);			\n"
+					"  if (uMaxTile == 0) return 1.0;							\n"
+					"  return uMinLod;											\n"
+					"}															\n"
 				;
 			} else {
-				if (config.texture.bilinearMode == BILINEAR_3POINT)
-					m_part =
-					"#define TEX_OFFSET_NORMAL(off, tex, texCoord, lod) texture(tex, texCoord - (off)/texSize)			\n"
-					"#define TEX_OFFSET_MIPMAP(off, tex, texCoord, lod) textureLod(tex, texCoord - (off)/texSize, lod)	\n"
-					"#define READ_TEX_NORMAL(name, tex, texCoord, lod)											\\\n"
-					"  {																								\\\n"
-					"  mediump vec2 texSize = vec2(textureSize(tex, int(lod)));											\\\n"
-					"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));										\\\n"
-					"  offset -= step(1.0, offset.x + offset.y);														\\\n"
-					"  lowp vec4 c0 = TEX_OFFSET_NORMAL(offset, tex, texCoord, lod);									\\\n"
-					"  lowp vec4 c1 = TEX_OFFSET_NORMAL(vec2(offset.x - sign(offset.x), offset.y), tex, texCoord, lod);	\\\n"
-					"  lowp vec4 c2 = TEX_OFFSET_NORMAL(vec2(offset.x, offset.y - sign(offset.y)), tex, texCoord, lod);	\\\n"
-					"  name = c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0); 										\\\n"
-					"  }																								\n"
-					"#define READ_TEX_MIPMAP(name, tex, texCoord, lod)													\\\n"
-					"  {																								\\\n"
-					"  mediump vec2 texSize = vec2(textureSize(tex, int(lod)));											\\\n"
-					"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));										\\\n"
-					"  offset -= step(1.0, offset.x + offset.y);														\\\n"
-					"  lowp vec4 c0 = TEX_OFFSET_MIPMAP(offset, tex, texCoord, lod);									\\\n"
-					"  lowp vec4 c1 = TEX_OFFSET_MIPMAP(vec2(offset.x - sign(offset.x), offset.y), tex, texCoord, lod);	\\\n"
-					"  lowp vec4 c2 = TEX_OFFSET_MIPMAP(vec2(offset.x, offset.y - sign(offset.y)), tex, texCoord, lod);	\\\n"
-					"  name = c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0); 										\\\n"
-					"  }																								\n"
-					;
-				else
-					m_part =
-					"#define TEX_FETCH_NORMAL(tex, texCoord, lod) texture(tex, texCoord)									\n"
-					"#define TEX_FETCH_MIPMAP(tex, texCoord, lod) textureLod(tex, texCoord, lod)							\n"
-					"#define READ_TEX_NORMAL(name, tex, texCoord, lod) name = TEX_FETCH_NORMAL(tex, texCoord, lod)	\n"
-					"#define READ_TEX_MIPMAP(name, tex, texCoord, lod) name = TEX_FETCH_MIPMAP(tex, texCoord, lod)	\n"
-					;
 				m_part +=
 					"uniform lowp int uEnableLod;		\n"
 					"uniform mediump float uMinLod;		\n"
@@ -1984,8 +2001,8 @@ class ShaderMipmap : public ShaderPart
 					"uniform lowp int uTextureDetail;	\n"
 					"																		\n"
 					"mediump float mipmap(out lowp vec4 readtex0, out lowp vec4 readtex1) {	\n"
-					"  READ_TEX_NORMAL(readtex0, uTex0, texCoord0, 0.0);					\n"
-					"  READ_TEX_MIPMAP(readtex1, uTex1, texCoord1, 0.0);					\n"
+					"  READ_TEX_MIPMAP(readtex0, uTex0, tcData0, 0);					\n"
+					"  READ_TEX_MIPMAP(readtex1, uTex1, tcData1, 0);					\n"
 					"																		\n"
 					"  mediump float fMaxTile = float(uMaxTile);							\n"
 					"  mediump vec2 dx = abs(dFdx(vLodTexCoord));							\n"
@@ -2015,9 +2032,9 @@ class ShaderMipmap : public ShaderPart
 					"  lowp float lod_tile_m1 = max(0.0, lod_tile - 1.0);					\n"
 					"  lowp float lod_tile_p1 = min(fMaxTile - 1.0, lod_tile + 1.0);		\n"
 					"  lowp vec4 lodT, lodT_m1, lodT_p1;									\n"
-					"  READ_TEX_MIPMAP(lodT, uTex1, texCoord1, lod_tile);					\n"
-					"  READ_TEX_MIPMAP(lodT_m1, uTex1, texCoord1, lod_tile_m1);				\n"
-					"  READ_TEX_MIPMAP(lodT_p1, uTex1, texCoord1, lod_tile_p1);				\n"
+					"  READ_TEX_MIPMAP(lodT, uTex1, tcData1, lod_tile);						\n"
+					"  READ_TEX_MIPMAP(lodT_m1, uTex1, tcData1, lod_tile_m1);				\n"
+					"  READ_TEX_MIPMAP(lodT_p1, uTex1, tcData1, lod_tile_p1);				\n"
 					"  if (lod_tile < 1.0) {												\n"
 					"    if (magnify) {														\n"
 					//     !sharpen && !detail
@@ -2083,13 +2100,25 @@ class ShaderReadtex : public ShaderPart
 		std::string shaderPart;
 
 		if (m_glinfo.isGLES2) {
+			shaderPart +=
+				"uniform mediump vec2 uTextureSize[2];										\n"
+				"lowp vec4 TextureNearest(in sampler2D tex, in highp vec2[5] tcData)		\n"
+				"{																					\n"
+				"  mediump vec2 texSize;															\n"
+				"  if (nCurrentTile == 0)															\n"
+				"    texSize = uTextureSize[0];														\n"
+				"  else																				\n"
+				"    texSize = uTextureSize[1];														\n"
+				"  return texture2D(tex, (tcData[0] + 0.5) / texSize);								\n"
+				"  }																				\n"
+				;
 			if (g_textureConvert.useYUVCoversion())
 				shaderPart +=
-				"lowp vec4 YUV_Convert(in sampler2D tex, in highp vec2 texCoord, in lowp int convert, in lowp int format, in lowp vec4 prev)	\n"
+				"lowp vec4 YUV_Convert(in sampler2D tex, in highp vec2[5] tcData, in lowp int convert, in lowp int format, in lowp vec4 prev)	\n"
 				"{																	\n"
 				"  lowp vec4 texColor;												\n"
 				"  if (convert != 0) texColor = prev;								\n"
-				"  else texColor = texture2D(tex, texCoord);						\n"
+				"  else texColor = TextureNearest(tex, tcData);						\n"
 				"  mediump ivec4 icolor = ivec4(texColor*255.0);					\n"
 				"  if (format == 1)													\n"
 				"    icolor.rg -= 128;												\n"
@@ -2104,61 +2133,54 @@ class ShaderReadtex : public ShaderPart
 			if (g_textureConvert.useTextureFiltering()) {
 				if (config.texture.bilinearMode == BILINEAR_3POINT) {
 					shaderPart +=
-						"uniform mediump vec2 uTextureSize[2];										\n"
+						// "uniform mediump vec2 uTextureSize[2];										\n" NOT NEEDED HERE?
 						// 3 point texture filtering.
 						// Original author: ArthurCarvalho
 						// GLSL implementation: twinaphex, mupen64plus-libretro project.
-						"#define TEX_OFFSET(off) texture2D(tex, texCoord - (off)/texSize)			\n"
-						"lowp vec4 TextureFilter(in sampler2D tex, in highp vec2 texCoord)		\n"
-						"{																			\n"
-						"  mediump vec2 texSize;													\n"
-						"  if (nCurrentTile == 0)													\n"
-						"    texSize = uTextureSize[0];												\n"
-						"  else																		\n"
-						"    texSize = uTextureSize[1];												\n"
-						"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));				\n"
-						"  offset -= step(1.0, offset.x + offset.y);								\n"
-						"  lowp vec4 c0 = TEX_OFFSET(offset);										\n"
-						"  lowp vec4 c1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y));	\n"
-						"  lowp vec4 c2 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)));	\n"
-						"  return c0 + abs(offset.x)*(c1-c0) + abs(offset.y)*(c2-c0);				\n"
-						"}																			\n"
+						"lowp vec4 TextureFilter(in sampler2D tex, in highp vec2[5] tcData)		\n"
+						"{																					\n"
+						"  mediump vec2 texSize;															\n"
+						"  if (nCurrentTile == 0)															\n"
+						"    texSize = uTextureSize[0];														\n"
+						"  else																				\n"
+						"    texSize = uTextureSize[1];														\n"
+						"  lowp float bottomRightTri = step(1.0, tcData[4].s + tcData[4].t);				\n"
+						"  lowp vec4 c00 = texture2D(tex, (tcData[0] + 0.5)/texSize);						\n"
+						"  lowp vec4 c01 = texture2D(tex, (tcData[1] + 0.5)/texSize);						\n"
+						"  lowp vec4 c10 = texture2D(tex, (tcData[2] + 0.5)/texSize);						\n"
+						"  lowp vec4 c11 = texture2D(tex, (tcData[3] + 0.5)/texSize);						\n"
+						"  lowp vec4 c0 = c00 + tcData[4].s*(c10-c00) + tcData[4].t*(c01-c00);				\n"
+						"  lowp vec4 c1 = c11 + (1.0-tcData[4].s)*(c01-c11) + (1.0-tcData[4].t)*(c10-c11);	\n"
+						"  return c0 + bottomRightTri * (c1-c0);											\n"
+						"  }																				\n"
 						;
 				} else {
 					shaderPart +=
 						// bilinear filtering.
-						"uniform mediump vec2 uTextureSize[2];										\n"
-						"#define TEX_OFFSET(off) texture2D(tex, texCoord - (off)/texSize)			\n"
-						"lowp vec4 TextureFilter(in sampler2D tex, in highp vec2 texCoord)		\n"
-						"{																			\n"
-						"  mediump vec2 texSize;													\n"
-						"  if (nCurrentTile == 0)													\n"
-						"    texSize = uTextureSize[0];												\n"
-						"  else																		\n"
-						"    texSize = uTextureSize[1];												\n"
-						"  mediump vec2 offset = fract(texCoord*texSize - vec2(0.5));				\n"
-						"  offset -= step(1.0, offset.x + offset.y);								\n"
-						"  lowp vec4 zero = vec4(0.0);												\n"
-						"																			\n"
-						"  lowp vec4 p0q0 = TEX_OFFSET(offset);										\n"
-						"  lowp vec4 p1q0 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y));	\n"
-						"																			\n"
-						"  lowp vec4 p0q1 = TEX_OFFSET(vec2(offset.x, offset.y - sign(offset.y)));	\n"
-						"  lowp vec4 p1q1 = TEX_OFFSET(vec2(offset.x - sign(offset.x), offset.y - sign(offset.y)));\n"
-						"																			\n"
-						"  mediump vec2 interpolationFactor = abs(offset);							\n"
-						"  lowp vec4 pInterp_q0 = mix( p0q0, p1q0, interpolationFactor.x ); 		\n" // Interpolates top row in X direction.
-						"  lowp vec4 pInterp_q1 = mix( p0q1, p1q1, interpolationFactor.x ); 		\n" // Interpolates bottom row in X direction.
-						"  return mix( pInterp_q0, pInterp_q1, interpolationFactor.y ); 			\n" // Interpolate in Y direction.
-						"}																			\n"
+						//"uniform mediump vec2 uTextureSize[2];										\n" NOT NEEDED HERE?
+						"lowp vec4 TextureFilter(in sampler2D tex, in highp vec2[5] tcData)		\n"
+						"{																					\n"
+						"  mediump vec2 texSize;															\n"
+						"  if (nCurrentTile == 0)															\n"
+						"    texSize = uTextureSize[0];														\n"
+						"  else																				\n"
+						"    texSize = uTextureSize[1];														\n"
+						"  lowp vec4 c00 = texture2D(tex, (tcData[0] + 0.5)/texSize);						\n"
+						"  lowp vec4 c01 = texture2D(tex, (tcData[1] + 0.5)/texSize);						\n"
+						"  lowp vec4 c10 = texture2D(tex, (tcData[2] + 0.5)/texSize);						\n"
+						"  lowp vec4 c11 = texture2D(tex, (tcData[3] + 0.5)/texSize);						\n"
+						"  lowp vec4 c0 = c00 + tcData[4].s * (c10-c00);									\n"
+						"  lowp vec4 c1 = c01 + tcData[4].s * (c11-c01);									\n"
+						"  return c0 + tcData[4].t * (c1-c0);												\n"
+						"  }																				\n"
 						;
 				}
 				shaderPart +=
-					"lowp vec4 readTex(in sampler2D tex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
+					"lowp vec4 readTex(in sampler2D tex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
 					"{																			\n"
 					"  lowp vec4 texColor;														\n"
-					"  if (uTextureFilterMode == 0) texColor = texture2D(tex, texCoord);		\n"
-					"  else texColor = TextureFilter(tex, texCoord);							\n"
+					"  if (uTextureFilterMode == 0) texColor = TextureNearest(tex, tcData);		\n"
+					"  else texColor = TextureFilter(tex, tcData);							\n"
 					"  if (fbMonochrome == 1) texColor = vec4(texColor.r);						\n"
 					"  else if (fbMonochrome == 2) 												\n"
 					"    texColor.rgb = vec3(dot(vec3(0.2126, 0.7152, 0.0722), texColor.rgb));	\n"
@@ -2179,14 +2201,13 @@ class ShaderReadtex : public ShaderPart
 					"  return texel / float(uMSAASamples);										\n"
 					"}																			\n"
 					"																			\n"
-					"lowp vec4 readTexMS(in lowp sampler2DMS mstex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
+					"lowp vec4 readTexMS(in lowp sampler2DMS mstex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
 					"{																			\n"
 					"  mediump ivec2 itexCoord;													\n"
 					"  if (fbMonochrome == 3) {													\n"
 					"    itexCoord = ivec2(gl_FragCoord.xy);									\n"
 					"  } else {																	\n"
-					"    mediump vec2 msTexSize = vec2(textureSize(mstex));						\n"
-					"    itexCoord = ivec2(msTexSize * texCoord);								\n"
+					"    itexCoord = ivec2(tcData[0]);											\n"
 					"  }																		\n"
 					"  lowp vec4 texColor = sampleMS(mstex, itexCoord);							\n"
 					"  if (fbMonochrome == 1) texColor = vec4(texColor.r);						\n"
@@ -2217,15 +2238,25 @@ class ShaderReadtexCopyMode : public ShaderPart
 	{
 		if (_glinfo.isGLES2) {
 			m_part =
-					"lowp vec4 readTex(in sampler2D tex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
-					"{																			\n"
-					"  lowp vec4 texColor = texture2D(tex, texCoord);							\n"
-					"  if (fbMonochrome == 1) texColor = vec4(texColor.r);						\n"
-					"  else if (fbMonochrome == 2) 												\n"
-					"    texColor.rgb = vec3(dot(vec3(0.2126, 0.7152, 0.0722), texColor.rgb));	\n"
-					"  if (fbFixedAlpha == 1) texColor.a = 0.825;								\n"
-					"  return texColor;															\n"
-					"}																			\n"
+				"uniform mediump vec2 uTextureSize[2];										\n"
+				"lowp vec4 TextureNearest(in sampler2D tex, in highp vec2[5] tcData)		\n"
+				"{																					\n"
+				"  mediump vec2 texSize;															\n"
+				"  if (nCurrentTile == 0)															\n"
+				"    texSize = uTextureSize[0];														\n"
+				"  else																				\n"
+				"    texSize = uTextureSize[1];														\n"
+				"  return texture2D(tex, (tcData[0] + 0.5) / texSize);								\n"
+				"  }																				\n"
+				"lowp vec4 readTex(in sampler2D tex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
+				"{																			\n"
+				"  lowp vec4 texColor = TextureNearest(tex, tcData);						\n"
+				"  if (fbMonochrome == 1) texColor = vec4(texColor.r);						\n"
+				"  else if (fbMonochrome == 2) 												\n"
+				"    texColor.rgb = vec3(dot(vec3(0.2126, 0.7152, 0.0722), texColor.rgb));	\n"
+				"  if (fbFixedAlpha == 1) texColor.a = 0.825;								\n"
+				"  return texColor;															\n"
+				"}																			\n"
 				;
 		} else {
 			if (config.video.multisampling > 0) {
@@ -2239,14 +2270,13 @@ class ShaderReadtexCopyMode : public ShaderPart
 					"  return texel / float(uMSAASamples);										\n"
 					"}																			\n"
 					"																			\n"
-					"lowp vec4 readTexMS(in lowp sampler2DMS mstex, in highp vec2 texCoord, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
+					"lowp vec4 readTexMS(in lowp sampler2DMS mstex, in highp vec2[5] tcData, in lowp int fbMonochrome, in lowp int fbFixedAlpha)	\n"
 					"{																			\n"
 					"  mediump ivec2 itexCoord;													\n"
 					"  if (fbMonochrome == 3) {													\n"
 					"    itexCoord = ivec2(gl_FragCoord.xy);									\n"
 					"  } else {																	\n"
-					"    mediump vec2 msTexSize = vec2(textureSize(mstex));						\n"
-					"    itexCoord = ivec2(msTexSize * texCoord);								\n"
+					"    itexCoord = ivec2(tcData[0]);											\n"
 					"  }																		\n"
 					"  lowp vec4 texColor = sampleMS(mstex, itexCoord);							\n"
 					"  if (fbMonochrome == 1) texColor = vec4(texColor.r);						\n"
@@ -2381,31 +2411,70 @@ class ShaderN64DepthRender : public ShaderPart
 	}
 };
 
-class ShaderClampWrapMirror : public ShaderPart
+
+class ShaderTextureEngine : public ShaderPart
 {
 public:
-	ShaderClampWrapMirror(const opengl::GLInfo & _glinfo)
-	{
+	ShaderTextureEngine(const opengl::GLInfo _glinfo) {
 		m_part =
-			"highp vec2 clampWrapMirror(in highp vec2 vTexCoord, in highp vec4 vClamp,		\n"
-			"	in highp vec2 vWrap, in lowp vec2 vMirror, in highp vec2 vScale)			\n"
+			"highp vec2 clampWrapMirror(in highp vec2 vTexCoord, in highp vec2 vWrap,		\n"
+			"	in highp vec2 vClamp, in lowp vec2 vWrapEn, in lowp vec2 vClampEn, in lowp vec2 vMirrorEn)		\n"
 			"{																				\n"
-			"  highp vec2 texCoord = clamp(vTexCoord, vClamp.xy, vClamp.zw);				\n"
-			"  lowp vec2 one = vec2(1.0);													\n"
-			"  lowp vec2 clamped = step(vClamp.zw, texCoord);								\n"
-			"  lowp vec2 notClamped = one - clamped;										\n"
-			"  lowp vec2 wrapped = step(vWrap , texCoord);									\n"
-			"  lowp vec2 notWrapped = one - wrapped;										\n"
-			"  texCoord = clamped * texCoord + notClamped * (wrapped*mod(texCoord, vWrap) + notWrapped*texCoord);			\n"
-			"  highp vec2 intPart = floor(texCoord);										\n"
-			"  highp vec2 fractPart = fract(texCoord);										\n"
-			"  lowp vec2 needMirror = step(vec2(0.5), mod(intPart, vWrap)) * vMirror;	\n"
-			"  texCoord = clamped * texCoord + notClamped * fractPart;						\n"
-			"  texCoord = (one - vMirror) * texCoord + vMirror * fractPart;					\n"
-			"  texCoord = (one - texCoord) * needMirror + texCoord * (one - needMirror);	\n"
-			"  texCoord *= vScale;															\n"
-			"  return texCoord;																\n"
+			"	highp vec2 texCoord = vTexCoord;											\n"
+			"	highp vec2 clampedCoord = clamp(texCoord, vec2(0.0), vClamp);				\n"
+			"	texCoord += vClampEn*(clampedCoord-texCoord);								\n"
+			"   lowp vec2 needMirror = step(vWrap, mod(texCoord, 2.0*vWrap));				\n"
+			"	highp vec2 invertedCoord = mod(-texCoord-vec2(1.0), vWrap);	 				\n"
+			"	texCoord += vMirrorEn*needMirror*(invertedCoord-texCoord);	 				\n"
+			"   highp vec2 wrappedCoord = mod(texCoord,vWrap);								\n"
+			"	texCoord += vWrapEn*(wrappedCoord-texCoord);								\n"
+			"	return texCoord;															\n"
 			"}																				\n"
+
+			"highp vec2[5] textureEngine0(in highp vec2 texCoord) \n"
+			"{  \n"
+			"  highp vec2[5] tcData; \n" // {tc00, tc01, tc10, tc11, frPart}
+			"  mediump vec2 intPart = floor(texCoord); \n"
+			"  tcData[0] = clampWrapMirror(intPart, uTexWrap0, uTexClamp0, uTexWrapEn0, uTexClampEn0, uTexMirrorEn0); \n"
+			"  tcData[3] = clampWrapMirror(intPart + vec2(1.0,1.0), uTexWrap0, uTexClamp0, uTexWrapEn0, uTexClampEn0, uTexMirrorEn0); \n"
+			"  tcData[1] = vec2(tcData[0].s, tcData[3].t); \n"
+			"  tcData[2] = vec2(tcData[3].s, tcData[0].t); \n"
+			"  tcData[4] = texCoord - intPart; \n"
+			"  return tcData;"
+			"}  \n"
+
+			"highp vec2[5] textureEngine1(in highp vec2 texCoord) \n"
+			"{  \n"
+			"  highp vec2[5] tcData; \n" // {tc00, tc01, tc10, tc11, frPart}
+			"  mediump vec2 intPart = floor(texCoord); \n"
+			"  tcData[0] = clampWrapMirror(intPart, uTexWrap1, uTexClamp1, uTexWrapEn1, uTexClampEn1, uTexMirrorEn1); \n"
+			"  tcData[3] = clampWrapMirror(intPart + vec2(1.0,1.0), uTexWrap1, uTexClamp1, uTexWrapEn1, uTexClampEn1, uTexMirrorEn1); \n"
+			"  tcData[1] = vec2(tcData[0].s, tcData[3].t); \n"
+			"  tcData[2] = vec2(tcData[3].s, tcData[0].t); \n"
+			"  tcData[4] = texCoord - intPart; \n"
+			"  return tcData;"
+			"}  \n"
+			;
+	}
+};
+
+
+class ShaderFragmentTextureEngineTex0 : public ShaderPart {
+public:
+	ShaderFragmentTextureEngineTex0(const opengl::GLInfo _glinfo)
+	{
+		m_part =
+			"tcData0 = textureEngine0(vTexCoord0); \n"
+			;
+	}
+};
+
+class ShaderFragmentTextureEngineTex1 : public ShaderPart {
+public:
+	ShaderFragmentTextureEngineTex1(const opengl::GLInfo _glinfo)
+	{
+		m_part =
+			"tcData1 = textureEngine1(vTexCoord1); \n"
 			;
 	}
 };
@@ -2578,7 +2647,7 @@ graphics::CombinerProgram * CombinerProgramBuilder::buildCombinerProgram(Combine
 		m_fragmentHeaderWriteDepth->write(ssShader);
 		m_fragmentHeaderDepthCompare->write(ssShader);
 		m_fragmentHeaderReadMSTex->write(ssShader);
-		m_fragmentHeaderClampWrapMirror->write(ssShader);
+		m_fragmentHeaderTextureEngine->write(ssShader);
 		if (bUseLod)
 			m_fragmentHeaderMipMap->write(ssShader);
 		else if (g_cycleType < G_CYC_COPY)
@@ -2612,9 +2681,13 @@ graphics::CombinerProgram * CombinerProgramBuilder::buildCombinerProgram(Combine
 
 	if (bUseTextures) {
 		if (combinerInputs.usesTile(0))
-			m_fragmentClampWrapMirrorTex0->write(ssShader);
+		{
+			m_fragmentTextureEngineTex0->write(ssShader);
+		}
 		if (combinerInputs.usesTile(1))
-			m_fragmentClampWrapMirrorTex1->write(ssShader);
+		{
+			m_fragmentTextureEngineTex1->write(ssShader);
+		}
 
 		if (bUseLod) {
 			m_fragmentReadTexMipmap->write(ssShader);
@@ -2633,11 +2706,11 @@ graphics::CombinerProgram * CombinerProgramBuilder::buildCombinerProgram(Combine
 	}
 
 	if (bUseHWLight)
-		ssShader << "  calc_light(vNumLights, vShadeColor.rgb, input_color);" << std::endl;
+		ssShader << "  calc_light(vNumLights, shadeColor.rgb, input_color);" << std::endl;
 	else
-		ssShader << "  input_color = vShadeColor.rgb;" << std::endl;
+		ssShader << "  input_color = shadeColor.rgb;" << std::endl;
 
-	ssShader << "  vec_color = vec4(input_color, vShadeColor.a);" << std::endl;
+	ssShader << "  vec_color = vec4(input_color, shadeColor.a);" << std::endl;
 	ssShader << strCombiner << std::endl;
 
 	if (config.frameBufferEmulation.N64DepthCompare != Config::dcDisable)
@@ -2653,7 +2726,7 @@ graphics::CombinerProgram * CombinerProgramBuilder::buildCombinerProgram(Combine
 		m_shaderCalcLight->write(ssShader);
 
 	if (bUseTextures) {
-		m_shaderClampWrapMirror->write(ssShader);
+		m_shaderTextureEngine->write(ssShader);
 		if (bUseLod)
 			m_shaderMipmap->write(ssShader);
 		else {
@@ -2764,7 +2837,7 @@ CombinerProgramBuilder::CombinerProgramBuilder(const opengl::GLInfo & _glinfo, o
 , m_fragmentHeaderWriteDepth(new ShaderFragmentHeaderWriteDepth(_glinfo))
 , m_fragmentHeaderCalcLight(new ShaderFragmentHeaderCalcLight(_glinfo))
 , m_fragmentHeaderMipMap(new ShaderFragmentHeaderMipMap(_glinfo))
-, m_fragmentHeaderClampWrapMirror(new ShaderFragmentHeaderClampWrapMirror(_glinfo))
+, m_fragmentHeaderTextureEngine(new ShaderFragmentHeaderTextureEngine(_glinfo))
 , m_fragmentHeaderReadMSTex(new ShaderFragmentHeaderReadMSTex(_glinfo))
 , m_fragmentHeaderDither(new ShaderFragmentHeaderDither(_glinfo))
 , m_fragmentHeaderDepthCompare(new ShaderFragmentHeaderDepthCompare(_glinfo))
@@ -2775,8 +2848,8 @@ CombinerProgramBuilder::CombinerProgramBuilder(const opengl::GLInfo & _glinfo, o
 , m_fragmentBlendMux(new ShaderFragmentBlendMux(_glinfo))
 , m_fragmentReadTex0(new ShaderFragmentReadTex0(_glinfo))
 , m_fragmentReadTex1(new ShaderFragmentReadTex1(_glinfo))
-, m_fragmentClampWrapMirrorTex0(new ShaderFragmentClampWrapMirrorTex0(_glinfo))
-, m_fragmentClampWrapMirrorTex1(new ShaderFragmentClampWrapMirrorTex1(_glinfo))
+, m_fragmentTextureEngineTex0(new ShaderFragmentTextureEngineTex0(_glinfo))
+, m_fragmentTextureEngineTex1(new ShaderFragmentTextureEngineTex1(_glinfo))
 , m_fragmentReadTexCopyMode(new ShaderFragmentReadTexCopyMode(_glinfo))
 , m_fragmentReadTexMipmap(new ShaderFragmentReadTexMipmap(_glinfo))
 , m_fragmentCallN64Depth(new ShaderFragmentCallN64Depth(_glinfo))
@@ -2791,7 +2864,7 @@ CombinerProgramBuilder::CombinerProgramBuilder(const opengl::GLInfo & _glinfo, o
 , m_shaderReadtexCopyMode(new ShaderReadtexCopyMode(_glinfo))
 , m_shaderN64DepthCompare(new ShaderN64DepthCompare(_glinfo))
 , m_shaderN64DepthRender(new ShaderN64DepthRender(_glinfo))
-, m_shaderClampWrapMirror(new ShaderClampWrapMirror(_glinfo))
+, m_shaderTextureEngine(new ShaderTextureEngine(_glinfo))
 , m_useProgram(_useProgram)
 , m_combinerOptionsBits(graphics::CombinerProgram::getShaderCombinerOptionsBits())
 {
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.h b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.h
index 41c94e42..f69fe927 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.h
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.h
@@ -62,7 +62,7 @@ namespace glsl {
 		ShaderPartPtr m_fragmentHeaderWriteDepth;
 		ShaderPartPtr m_fragmentHeaderCalcLight;
 		ShaderPartPtr m_fragmentHeaderMipMap;
-		ShaderPartPtr m_fragmentHeaderClampWrapMirror;
+		ShaderPartPtr m_fragmentHeaderTextureEngine;
 		ShaderPartPtr m_fragmentHeaderReadMSTex;
 		ShaderPartPtr m_fragmentHeaderDither;
 		ShaderPartPtr m_fragmentHeaderDepthCompare;
@@ -73,8 +73,8 @@ namespace glsl {
 		ShaderPartPtr m_fragmentBlendMux;
 		ShaderPartPtr m_fragmentReadTex0;
 		ShaderPartPtr m_fragmentReadTex1;
-		ShaderPartPtr m_fragmentClampWrapMirrorTex0;
-		ShaderPartPtr m_fragmentClampWrapMirrorTex1;
+		ShaderPartPtr m_fragmentTextureEngineTex0;
+		ShaderPartPtr m_fragmentTextureEngineTex1;
 		ShaderPartPtr m_fragmentReadTexCopyMode;
 		ShaderPartPtr m_fragmentReadTexMipmap;
 		ShaderPartPtr m_fragmentCallN64Depth;
@@ -90,7 +90,7 @@ namespace glsl {
 		ShaderPartPtr m_shaderReadtexCopyMode;
 		ShaderPartPtr m_shaderN64DepthCompare;
 		ShaderPartPtr m_shaderN64DepthRender;
-		ShaderPartPtr m_shaderClampWrapMirror;
+		ShaderPartPtr m_shaderTextureEngine;
 
 		std::unique_ptr<CombinerProgramUniformFactory> m_uniformFactory;
 
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
index bfaa1328..42207d70 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
@@ -7,6 +7,7 @@
 #include <NoiseTexture.h>
 #include <FrameBuffer.h>
 #include <DisplayWindow.h>
+#include <Debugger.h>
 #include <GBI.h>
 #include <RSP.h>
 #include <gSP.h>
@@ -198,6 +199,23 @@ class UMSAATextures : public UniformGroup
 	iUniform uMSAASamples;
 };
 
+class UScreenSpaceTriangleInfo : public UniformGroup
+{
+public:
+	UScreenSpaceTriangleInfo(GLuint _program) {
+		LocateUniform(uScreenSpaceTriangle);
+	}
+
+	void update(bool _force) override
+	{
+		uScreenSpaceTriangle.set(
+			(dwnd().getDrawer().getDrawingState() == DrawingState::ScreenSpaceTriangle) ? 1 : 0, _force);
+	}
+
+private:
+	iUniform uScreenSpaceTriangle;
+};
+
 class UFrameBufferInfo : public UniformGroup
 {
 public:
@@ -897,7 +915,7 @@ class UTextureParams : public UniformGroup
 				f32 shiftScaleT = 1.0f;
 				getTextureShiftScale(t, cache, shiftScaleS, shiftScaleT);
 				uCacheShiftScale[t].set(shiftScaleS, shiftScaleT, _force);
-				uCacheScale[t].set(_pTexture->scaleS, _pTexture->scaleT, _force);
+				uCacheScale[t].set(_pTexture->hdRatioS, _pTexture->hdRatioT, _force);
 				uCacheOffset[t].set(_pTexture->offsetS, _pTexture->offsetT, _force);
 				nFB[t] = _pTexture->frameBufferTexture;
 			}
@@ -917,30 +935,33 @@ class UTextureParams : public UniformGroup
 	iv2Uniform uCacheFrameBuffer;
 };
 
-class UClampWrapMirrorTex : public UniformGroup
+class UTextureEngine : public UniformGroup
 {
 public:
-	UClampWrapMirrorTex(GLuint _program, bool _useT0, bool _useT1)
+	UTextureEngine(GLuint _program, bool _useT0, bool _useT1)
 	{
 		m_useTile[0] = _useT0;
 		m_useTile[1] = _useT1;
-		LocateUniform(uTexClamp0);
-		LocateUniform(uTexClamp1);
 		LocateUniform(uTexWrap0);
 		LocateUniform(uTexWrap1);
-		LocateUniform(uTexMirror0);
-		LocateUniform(uTexMirror1);
-		LocateUniform(uTexScale0);
-		LocateUniform(uTexScale1);
+		LocateUniform(uTexClamp0);
+		LocateUniform(uTexClamp1);
+		LocateUniform(uTexWrapEn0);
+		LocateUniform(uTexWrapEn1);
+		LocateUniform(uTexClampEn0);
+		LocateUniform(uTexClampEn1);
+		LocateUniform(uTexMirrorEn0);
+		LocateUniform(uTexMirrorEn1);
 	}
 
 	void update(bool _force) override
 	{
-		std::array<f32, 4> aTexClamp[2] = { { -10000.0f, -10000.0f, 10000.0f, 10000.0f },
-											{ -10000.0f, -10000.0f, 10000.0f, 10000.0f } };
-		std::array<f32, 2> aTexWrap[2] = { { 10000.0f, 10000.0f }, { 10000.0f, 10000.0f } };
-		std::array<f32, 2> aTexMirror[2] = { { 0.0f, 0.0f}, { 0.0f, 0.0f } };
-		std::array<f32, 2> aTexScale[2] = { { 1.0f, 1.0f },{ 1.0f, 1.0f } };
+		std::array<f32, 2> aTexWrap[2] = { {0.0f,0.0f}, {0.0f,0.0f} };
+		std::array<f32, 2> aTexClamp[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
+		std::array<f32, 2> aTexWrapEn[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
+		std::array<f32, 2> aTexClampEn[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
+		std::array<f32, 2> aTexMirrorEn[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
+
 		TextureCache & cache = textureCache();
 		const bool replaceTex1ByTex0 = needReplaceTex1ByTex0();
 		for (u32 t = 0; t < 2; ++t) {
@@ -952,75 +973,61 @@ class UClampWrapMirrorTex : public UniformGroup
 			CachedTexture * pTexture = cache.current[tile];
 			if (pTile == nullptr || pTexture == nullptr)
 				continue;
-
-			if (gDP.otherMode.cycleType != G_CYC_COPY) {
-				if (pTexture->clampS) {
-					aTexClamp[t][0] = 0.0f; // S lower bound
-					if (pTexture->frameBufferTexture != CachedTexture::fbNone ||
-						pTile->textureMode == TEXTUREMODE_BGIMAGE)
-						aTexClamp[t][2] = 1.0f;
-					else {
-						u32 tileWidth = ((pTile->lrs - pTile->uls) & 0x03FF) + 1;
-						if (pTile->size > pTexture->size)
-							tileWidth <<= pTile->size - pTexture->size;
-						//	aTexClamp[t][2] = f32(tileWidth) / (pTexture->mirrorS ? f32(pTexture->width) : f32(pTexture->clampWidth)); // S upper bound
-						aTexClamp[t][2] = f32(tileWidth) / f32(pTexture->width); // S upper bound
-					}
-				}
-				if (pTexture->clampT) {
-					aTexClamp[t][1] = 0.0f; // T lower bound
-					if (pTexture->frameBufferTexture != CachedTexture::fbNone ||
-						pTile->textureMode == TEXTUREMODE_BGIMAGE)
-						aTexClamp[t][3] = 1.0f;
-					else {
-						const u32 tileHeight = ((pTile->lrt - pTile->ult) & 0x03FF) + 1;
-						//	aTexClamp[t][3] = f32(tileHeight) / (pTexture->mirrorT ? f32(pTexture->height) : f32(pTexture->clampHeight)); // T upper bound
-						aTexClamp[t][3] = f32(tileHeight) / f32(pTexture->height); // T upper bound
-					}
-				}
-			}
-			if (pTexture->maskS) {
-				const f32 wrapWidth = static_cast<f32>(1 << pTile->originalMaskS);
-				const f32 pow2Width = static_cast<f32>(pow2(pTexture->width));
-				aTexWrap[t][0] = wrapWidth / pow2Width;
-				aTexScale[t][0] = pow2Width / f32(pTexture->width);
-			}
-			if (pTexture->maskT) {
-				const f32 wrapHeight = static_cast<f32>(1 << pTile->originalMaskT);
-				const f32 pow2Height = static_cast<f32>(pow2(pTexture->height));
-				aTexWrap[t][1] = wrapHeight / pow2Height;
-				aTexScale[t][1] = pow2Height / f32(pTexture->height);
-			}
-			if (pTexture->mirrorS) {
-				aTexMirror[t][0] = 1.0f;
-				aTexWrap[t][0] *= 2.0f;
-			}
-			if (pTexture->mirrorT) {
-				aTexMirror[t][1] = 1.0f;
-				aTexWrap[t][1] *= 2.0f;
+			
+			/* Not sure if special treatment of framebuffer textures is correct */
+			if (pTexture->frameBufferTexture != CachedTexture::fbNone ||
+				pTile->textureMode != TEXTUREMODE_NORMAL ||
+				g_debugger.isDebugMode())
+			{
+				aTexWrap[t][0] = 1.0;
+				aTexWrap[t][1] = 1.0;
+				aTexClamp[t][0] = f32(pTexture->width) - 1.0f;
+				aTexClamp[t][1] = f32(pTexture->height) - 1.0f;
+				aTexWrapEn[t][0] = 0.0;
+				aTexWrapEn[t][1] = 0.0;
+				aTexClampEn[t][0] = 1.0;
+				aTexClampEn[t][1] = 1.0;
+				aTexMirrorEn[t][0] = 0.0;
+				aTexMirrorEn[t][1] = 0.0;
+			} else {
+				aTexWrap[t][0] = f32(1 << pTile->masks) * pTexture->hdRatioS;
+				aTexWrap[t][1] = f32(1 << pTile->maskt) * pTexture->hdRatioT;
+				aTexClamp[t][0] = (pTile->flrs - pTile->fuls + 1.0f) * pTexture->hdRatioS - 1.0f;
+				aTexClamp[t][1] = (pTile->flrt - pTile->fult + 1.0f) * pTexture->hdRatioT - 1.0f;
+				aTexWrapEn[t][0] = f32(pTile->masks == 0 ? 0 : 1);
+				aTexWrapEn[t][1] = f32(pTile->maskt == 0 ? 0 : 1);
+				aTexClampEn[t][0] = f32(pTile->masks == 0 ? 1 : pTile->clamps);
+				aTexClampEn[t][1] = f32(pTile->maskt == 0 ? 1 : pTile->clampt);
+				aTexMirrorEn[t][0] = f32(pTile->masks == 0 ? 0 : pTile->mirrors);
+				aTexMirrorEn[t][1] = f32(pTile->maskt == 0 ? 0 : pTile->mirrort);
 			}
 		}
-		
-		uTexClamp0.set(aTexClamp[0].data(), _force);
-		uTexClamp1.set(aTexClamp[1].data(), _force);
+
 		uTexWrap0.set(aTexWrap[0][0], aTexWrap[0][1], _force);
 		uTexWrap1.set(aTexWrap[1][0], aTexWrap[1][1], _force);
-		uTexMirror0.set(aTexMirror[0][0], aTexMirror[0][1], _force);
-		uTexMirror1.set(aTexMirror[1][0], aTexMirror[1][1], _force);
-		uTexScale0.set(aTexScale[0][0], aTexScale[0][1], _force);
-		uTexScale1.set(aTexScale[1][0], aTexScale[1][1], _force);
+		uTexClamp0.set(aTexClamp[0][0], aTexClamp[0][1], _force);
+		uTexClamp1.set(aTexClamp[1][0], aTexClamp[1][1], _force);
+		uTexWrapEn0.set(aTexWrapEn[0][0], aTexWrapEn[0][1], _force);
+		uTexWrapEn1.set(aTexWrapEn[1][0], aTexWrapEn[1][1], _force);
+		uTexClampEn0.set(aTexClampEn[0][0], aTexClampEn[0][1], _force);
+		uTexClampEn1.set(aTexClampEn[1][0], aTexClampEn[1][1], _force);
+		uTexMirrorEn0.set(aTexMirrorEn[0][0], aTexMirrorEn[0][1], _force);
+		uTexMirrorEn1.set(aTexMirrorEn[1][0], aTexMirrorEn[1][1], _force);
+				
 	}
 
 private:
 	bool m_useTile[2];
-	fv4Uniform uTexClamp0;
-	fv4Uniform uTexClamp1;
 	fv2Uniform uTexWrap0;
 	fv2Uniform uTexWrap1;
-	fv2Uniform uTexMirror0;
-	fv2Uniform uTexMirror1;
-	fv2Uniform uTexScale0;
-	fv2Uniform uTexScale1;
+	fv2Uniform uTexClamp0;
+	fv2Uniform uTexClamp1;
+	fv2Uniform uTexWrapEn0;
+	fv2Uniform uTexWrapEn1;
+	fv2Uniform uTexClampEn0;
+	fv2Uniform uTexClampEn1;
+	fv2Uniform uTexMirrorEn0;
+	fv2Uniform uTexMirrorEn1;
 };
 
 class ULights : public UniformGroup
@@ -1059,6 +1066,7 @@ void CombinerProgramUniformFactory::buildUniforms(GLuint _program,
 												  UniformGroups & _uniforms)
 {
 	_uniforms.emplace_back(new UNoiseTex(_program));
+	_uniforms.emplace_back(new UScreenSpaceTriangleInfo(_program));
 
 	if (!m_glInfo.isGLES2) {
 		_uniforms.emplace_back(new UDepthTex(_program));
@@ -1089,7 +1097,7 @@ void CombinerProgramUniformFactory::buildUniforms(GLuint _program,
 		if (!_key.isRectKey())
 			_uniforms.emplace_back(new UTextureParams(_program, _inputs.usesTile(0), _inputs.usesTile(1)));
 
-		_uniforms.emplace_back(new UClampWrapMirrorTex(_program, _inputs.usesTile(0), _inputs.usesTile(1)));
+		_uniforms.emplace_back(new UTextureEngine(_program, _inputs.usesTile(0), _inputs.usesTile(1)));
 	}
 
 	_uniforms.emplace_back(new UFog(_program));
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h
index 10ef119e..9b0bf660 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_ShaderStorage.h
@@ -20,7 +20,7 @@ namespace glsl {
 		bool _saveCombinerKeys(const graphics::Combiners & _combiners) const;
 		bool _loadFromCombinerKeys(graphics::Combiners & _combiners);
 
-		const u32 m_formatVersion = 0x2CU;
+		const u32 m_formatVersion = 0x2DU;
 		const u32 m_keysFormatVersion = 0x04;
 		const opengl::GLInfo & m_glinfo;
 		opengl::CachedUseProgram * m_useProgram;
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp
index 63e0a83c..c400f8e2 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.cpp
@@ -359,105 +359,84 @@ namespace glsl {
 		std::string const& getHybridTextureFilter()
 	{
 		static std::string strFilter =
-			"uniform sampler2D uTex0;                                                           \n"
-			"                                                                                   \n"
-			"mediump vec2 norm2denorm(in mediump vec2 uv, in ivec2 texture_size)                \n"
-			"{                                                                                  \n"
-			"       return uv * vec2(texture_size) - 0.5;                                       \n"
-			"}                                                                                  \n"
-			"ivec2 denorm2idx(in mediump vec2 d_uv)                                             \n"
-			"{                                                                                  \n"
-			"       return ivec2(floor(d_uv));                                                  \n"
-			"}                                                                                  \n"
-			"ivec2 norm2idx(in mediump vec2 uv, in ivec2 texture_size)                          \n"
-			"{                                                                                  \n"
-			"       return denorm2idx(norm2denorm(uv, texture_size));                           \n"
-			"}                                                                                  \n"
-			"mediump vec2 idx2norm(in ivec2 idx, in ivec2 texture_size)                         \n"
-			"{                                                                                  \n"
-			"       mediump vec2 denorm_uv = vec2(idx) + 0.5;                                   \n"
-			"       return denorm_uv / vec2(texture_size);                                      \n"
-			"}                                                                                  \n"
-			"mediump vec4 texel_fetch(in ivec2 idx, in ivec2 texture_size)                      \n"
-			"{                                                                                  \n"
-			"       mediump vec2 uv = idx2norm(idx, texture_size);                              \n"
-			"       return texture2D(uTex0, uv);                                                \n"
-			"}                                                                                  \n"
-			"mediump vec4 hybridFilter(in mediump vec2 uv)                                      \n"
-			"{                                                                                  \n"
-			"       ivec2 texSize = textureSize(uTex0, 0);                                      \n"
-			"       mediump vec2 denorm_uv = norm2denorm(uv,texSize);                           \n"
-			"       ivec2 idx_low = denorm2idx(denorm_uv);                                      \n"
-			"       mediump vec2 ratio = denorm_uv - vec2(idx_low);                             \n"
-			"       ivec2 rounded_idx = idx_low + ivec2(step(0.5, ratio));                      \n"
-			"                                                                                   \n"
-			"       ivec2 idx00 = idx_low;                                                      \n"
-			"       mediump vec4 t00 = texel_fetch(idx00, texSize);                             \n"
-			"                                                                                   \n"
-			"       ivec2 idx01 = idx00 + ivec2(0, 1);                                          \n"
-			"       mediump vec4 t01 = texel_fetch(idx01, texSize);                             \n"
-			"                                                                                   \n"
-			"       ivec2 idx10 = idx00 + ivec2(1, 0);                                          \n"
-			"       mediump vec4 t10 = texel_fetch(idx10, texSize);                             \n"
-			"                                                                                   \n"
-			"       ivec2 idx11 = idx00 + ivec2(1, 1);                                          \n"
-			"       mediump vec4 t11 = texel_fetch(idx11, texSize);                             \n"
-			"                                                                                   \n"
-			"       /*                                                                          \n"
-			"       * radius is the distance from the edge where interpolation happens.         \n"
-			"       * It's calculated based on  how big a fragment is in denormalized           \n"
-			"       * texture coordinates.                                                      \n"
-			"       *                                                                           \n"
-			"       * E.g.: If a texel maps to 5 fragments, then each fragment is               \n"
-			"       * 1/5 texels big. So the smooth transition should be between one and        \n"
-			"       * two fragments big, since there are enough fragments to show the full      \n"
-			"       * color of the texel.                                                       \n"
-			"       *                                                                           \n"
-			"       * If a fragment is larger than one texel, we don't care, we're already      \n"
-			"       * sampling the wrong texels, and should be using mipmaps instead.           \n"
-			"       */                                                                          \n"
-			"                                                                                   \n"
-			"       // Here, fwidth() is used to estimte how much denorm_uv changes per fragment. \n"
-			"       // But we divide it by 2, since fwidth() is adding abs(dx) + abs(dy).       \n"
-			"       mediump vec2 fragment_size = fwidth(denorm_uv) / 2.0;                       \n"
-			"                                                                                   \n"
-			"       mediump float is_frag_gt1, radius;                                          \n"
-			"       // Do nothing if fragment is greater than 1 texel                           \n"
-			"       // Don't make the transition more than one fragment (+/- 0.5 fragment)      \n"
-			"       is_frag_gt1 = step(1.0, fragment_size.s);                                   \n"
-			"       radius = min(fragment_size.s, 0.5);                                         \n"
-			"       ratio.s = ratio.s * is_frag_gt1 + smoothstep(0.5 - radius,                  \n"
-			"           0.5 + radius,	ratio.s) * (1.0 - is_frag_gt1);                         \n"
-			"       is_frag_gt1 = step(1.0, fragment_size.t);                                   \n"
-			"       radius = min(fragment_size.t, 0.5);                                         \n"
-			"       ratio.t = ratio.t * is_frag_gt1 + smoothstep(0.5 - radius,                  \n"
-			"           0.5 + radius,	ratio.t) * (1.0 - is_frag_gt1);                         \n"
-			"                                                                                   \n"
-			"       // interpolate first on S direction then on T.                              \n"
-			"       mediump vec4 top = mix(t00, t10, ratio.s);                                  \n"
-			"       mediump vec4 bottom = mix(t01, t11, ratio.s);                               \n"
-			"       return mix(top, bottom, ratio.t);                                           \n"
-			"}                                                                                  \n"
+			"uniform sampler2D uTex0;                                                         \n"
+			"                                                                                 \n"
+			"ivec2 get_texture_size(sampler2D tex)                                            \n"
+			"{                                                                                \n"
+			"    return textureSize(tex, 0);                                                  \n"
+			"}                                                                                \n"
+			"                                                                                 \n"
+			"mediump vec2 norm2denorm(sampler2D tex, mediump vec2 uv)                         \n"
+			"{                                                                                \n"
+			"    return uv * vec2(get_texture_size(tex)) - 0.5;                               \n"
+			"}                                                                                \n"
+			"                                                                                 \n"
+			"mediump vec2 denorm2norm(sampler2D tex, mediump vec2 denorm_uv)                  \n"
+			"{                                                                                \n"
+			"    return (denorm_uv + 0.5) / vec2(get_texture_size(tex));                      \n"
+			"}                                                                                \n"
+			"                                                                                 \n"
+			"mediump vec4 hybridFilter(sampler2D tex, mediump vec2 uv)                        \n"
+			"{                                                                                \n"
+			"    mediump vec2 denorm_uv = norm2denorm(tex, uv);                               \n"
+			"    mediump vec2 low_corner = floor(denorm_uv);                                  \n"
+			"    mediump vec2 ratio = denorm_uv - low_corner;                                 \n"
+			"                                                                                 \n"
+			"    /*                                                                           \n"
+			"     * 'radius' is the distance from the edge where interpolation happens.       \n"
+			"     * It's calculated based on  how big a fragment is in denormalized           \n"
+			"     * texture coordinates.                                                      \n"
+			"     *                                                                           \n"
+			"     * E.g.: If a texel maps to 5 fragments, then each fragment is               \n"
+			"     * 1/5 texels big. So the smooth transition should be between one and        \n"
+			"     * two fragments big, since there are enough fragments to show the full      \n"
+			"     * color of the texel.                                                       \n"
+			"     *                                                                           \n"
+			"     * If a fragment is larger than one texel, we don't care, we're already      \n"
+			"     * sampling the wrong texels, and should be using mipmaps instead.           \n"
+			"     */                                                                          \n"
+			"                                                                                 \n"
+			"    // Here, fwidth() is used to estimte how much denorm_uv changes per fragment.\n"
+			"    // But we divide it by 2, since fwidth() is adding abs(dx) + abs(dy).        \n"
+			"    mediump vec2 fragment_size  = fwidth(denorm_uv) / 2.0;                       \n"
+			"                                                                                 \n"
+			"    mediump float is_frag_gt1, radius;                                           \n"
+			"    // Do nothing if fragment is greater than 1 texel                            \n"
+			"    // Don't make the transition more than one fragment (+/- 0.5 fragment)       \n"
+			"    is_frag_gt1 = step(1.0, fragment_size.s);                                    \n"
+			"    radius = min(fragment_size.s, 0.5);                                          \n"
+			"    ratio.s = ratio.s * is_frag_gt1 + smoothstep(0.5 - radius,                   \n"
+			"        0.5 + radius,	ratio.s) * (1.0 - is_frag_gt1);                           \n"
+			"    is_frag_gt1 = step(1.0, fragment_size.t);                                    \n"
+			"    radius = min(fragment_size.t, 0.5);                                          \n"
+			"    ratio.t = ratio.t * is_frag_gt1 + smoothstep(0.5 - radius,                   \n"
+			"        0.5 + radius,	ratio.t) * (1.0 - is_frag_gt1);                           \n"
+			"                                                                                 \n"
+			"    // now bump the coord to the texel using ratio                               \n"
+			"    mediump vec2 new_denorm_uv = low_corner + ratio;                             \n"
+			"    mediump vec2 new_uv = denorm2norm(tex, new_denorm_uv);                       \n"
+			"    return texture2D(tex, new_uv);                                               \n"
+			"}                                                                                \n"
 			;
 		return strFilter;
 	}
 
 	/*---------------TexrectCopyShaderPart-------------*/
 
-	class TexrectCopy : public ShaderPart
+	class TexrectUpscaleCopy : public ShaderPart
 	{
 	public:
-		TexrectCopy(const opengl::GLInfo & _glinfo)
+		TexrectUpscaleCopy(const opengl::GLInfo & _glinfo)
 		{
 			if (config.generalEmulation.enableHybridFilter) {
 				m_part = getHybridTextureFilter();
 				m_part +=
-					"IN mediump vec2 vTexCoord0;				\n"
-					"OUT lowp vec4 fragColor;					\n"
-					"											\n"
-					"void main()								\n"
-					"{											\n"
-					"	fragColor = hybridFilter(vTexCoord0);	\n"
+					"IN mediump vec2 vTexCoord0;						\n"
+					"OUT lowp vec4 fragColor;							\n"
+					"													\n"
+					"void main()										\n"
+					"{													\n"
+					"	fragColor = hybridFilter(uTex0, vTexCoord0);	\n"
 					;
 			} else {
 				m_part =
@@ -473,12 +452,29 @@ namespace glsl {
 		}
 	};
 
+	class TexrectDownscaleCopy : public ShaderPart
+	{
+	public:
+		TexrectDownscaleCopy(const opengl::GLInfo & _glinfo)
+		{
+			m_part =
+				"IN mediump vec2 vTexCoord0;							\n"
+				"uniform sampler2D uTex0;								\n"
+				"OUT lowp vec4 fragColor;								\n"
+				"														\n"
+				"void main()											\n"
+				"{														\n"
+				"	fragColor = texture2D(uTex0, vTexCoord0);			\n"
+				;
+		}
+	};
+
 	/*---------------TexrectDepthCopyShaderPart-------------*/
 
-	class TexrectColorAndDepthCopy : public ShaderPart
+	class TexrectColorAndDepthUpscaleCopy : public ShaderPart
 	{
 	public:
-		TexrectColorAndDepthCopy(const opengl::GLInfo & _glinfo)
+		TexrectColorAndDepthUpscaleCopy(const opengl::GLInfo & _glinfo)
 		{
 			if (config.generalEmulation.enableHybridFilter) {
 				m_part = getHybridTextureFilter();
@@ -489,7 +485,7 @@ namespace glsl {
 					"													\n"
 					"void main()										\n"
 					"{													\n"
-					"	fragColor = hybridFilter(vTexCoord0);			\n"
+					"	fragColor = hybridFilter(uTex0, vTexCoord0);	\n"
 					"	gl_FragDepth = texture2D(uTex1, vTexCoord0).r;	\n"
 					;
 			} else {
@@ -508,6 +504,25 @@ namespace glsl {
 		}
 	};
 
+	class TexrectColorAndDepthDownscaleCopy : public ShaderPart
+	{
+	public:
+		TexrectColorAndDepthDownscaleCopy(const opengl::GLInfo & _glinfo)
+		{
+			m_part =
+				"IN mediump vec2 vTexCoord0;							\n"
+				"uniform sampler2D uTex0;								\n"
+				"uniform sampler2D uTex1;								\n"
+				"OUT lowp vec4 fragColor;								\n"
+				"														\n"
+				"void main()											\n"
+				"{														\n"
+				"	fragColor = texture2D(uTex0, vTexCoord0);			\n"
+				"	gl_FragDepth = texture2D(uTex1, vTexCoord0).r;		\n"
+				;
+		}
+	};
+
 	/*---------------PostProcessorShaderPart-------------*/
 
 	class GammaCorrection : public ShaderPart
@@ -782,17 +797,36 @@ namespace glsl {
 
 	/*---------------TexrectCopyShader-------------*/
 
-	typedef SpecialShader<VertexShaderTexturedRect, TexrectCopy> TexrectCopyShaderBase;
+	typedef SpecialShader<VertexShaderTexturedRect, TexrectUpscaleCopy> TexrectUpscaleCopyShaderBase;
+
+	class TexrectUpscaleCopyShader : public TexrectUpscaleCopyShaderBase
+	{
+	public:
+		TexrectUpscaleCopyShader(const opengl::GLInfo & _glinfo,
+			opengl::CachedUseProgram * _useProgram,
+			const ShaderPart * _vertexHeader,
+			const ShaderPart * _fragmentHeader,
+			const ShaderPart * _fragmentEnd)
+			: TexrectUpscaleCopyShaderBase(_glinfo, _useProgram, _vertexHeader, _fragmentHeader, _fragmentEnd)
+		{
+			m_useProgram->useProgram(m_program);
+			const int texLoc = glGetUniformLocation(GLuint(m_program), "uTex0");
+			glUniform1i(texLoc, 0);
+			m_useProgram->useProgram(graphics::ObjectHandle::null);
+		}
+	};
+
+	typedef SpecialShader<VertexShaderTexturedRect, TexrectDownscaleCopy> TexrectDownscaleCopyShaderBase;
 
-	class TexrectCopyShader : public TexrectCopyShaderBase
+	class TexrectDownscaleCopyShader : public TexrectDownscaleCopyShaderBase
 	{
 	public:
-		TexrectCopyShader(const opengl::GLInfo & _glinfo,
+		TexrectDownscaleCopyShader(const opengl::GLInfo & _glinfo,
 			opengl::CachedUseProgram * _useProgram,
 			const ShaderPart * _vertexHeader,
 			const ShaderPart * _fragmentHeader,
 			const ShaderPart * _fragmentEnd)
-			: TexrectCopyShaderBase(_glinfo, _useProgram, _vertexHeader, _fragmentHeader, _fragmentEnd)
+			: TexrectDownscaleCopyShaderBase(_glinfo, _useProgram, _vertexHeader, _fragmentHeader, _fragmentEnd)
 		{
 			m_useProgram->useProgram(m_program);
 			const int texLoc = glGetUniformLocation(GLuint(m_program), "uTex0");
@@ -803,17 +837,38 @@ namespace glsl {
 
 	/*---------------TexrectColorAndDepthCopyShader-------------*/
 
-	typedef SpecialShader<VertexShaderTexturedRect, TexrectColorAndDepthCopy> TexrectColorAndDepthCopyShaderBase;
+	typedef SpecialShader<VertexShaderTexturedRect, TexrectColorAndDepthUpscaleCopy> TexrectColorAndDepthUpscaleCopyShaderBase;
 
-	class TexrectColorAndDepthCopyShader : public TexrectColorAndDepthCopyShaderBase
+	class TexrectColorAndDepthUpscaleCopyShader : public TexrectColorAndDepthUpscaleCopyShaderBase
 	{
 	public:
-		TexrectColorAndDepthCopyShader(const opengl::GLInfo & _glinfo,
+		TexrectColorAndDepthUpscaleCopyShader(const opengl::GLInfo & _glinfo,
 			opengl::CachedUseProgram * _useProgram,
 			const ShaderPart * _vertexHeader,
 			const ShaderPart * _fragmentHeader,
 			const ShaderPart * _fragmentEnd)
-			: TexrectColorAndDepthCopyShaderBase(_glinfo, _useProgram, _vertexHeader, _fragmentHeader, _fragmentEnd)
+			: TexrectColorAndDepthUpscaleCopyShaderBase(_glinfo, _useProgram, _vertexHeader, _fragmentHeader, _fragmentEnd)
+		{
+			m_useProgram->useProgram(m_program);
+			const int texLoc0 = glGetUniformLocation(GLuint(m_program), "uTex0");
+			glUniform1i(texLoc0, 0);
+			const int texLoc1 = glGetUniformLocation(GLuint(m_program), "uTex1");
+			glUniform1i(texLoc1, 1);
+			m_useProgram->useProgram(graphics::ObjectHandle::null);
+		}
+	};
+
+	typedef SpecialShader<VertexShaderTexturedRect, TexrectColorAndDepthDownscaleCopy> TexrectColorAndDepthDownscaleCopyShaderBase;
+
+	class TexrectColorAndDepthDownscaleCopyShader : public TexrectColorAndDepthDownscaleCopyShaderBase
+	{
+	public:
+		TexrectColorAndDepthDownscaleCopyShader(const opengl::GLInfo & _glinfo,
+			opengl::CachedUseProgram * _useProgram,
+			const ShaderPart * _vertexHeader,
+			const ShaderPart * _fragmentHeader,
+			const ShaderPart * _fragmentEnd)
+			: TexrectColorAndDepthDownscaleCopyShaderBase(_glinfo, _useProgram, _vertexHeader, _fragmentHeader, _fragmentEnd)
 		{
 			m_useProgram->useProgram(m_program);
 			const int texLoc0 = glGetUniformLocation(GLuint(m_program), "uTex0");
@@ -933,17 +988,30 @@ namespace glsl {
 		return new TexrectDrawerShaderClear(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader);
 	}
 
-	graphics::ShaderProgram * SpecialShadersFactory::createTexrectCopyShader() const
+	graphics::ShaderProgram * SpecialShadersFactory::createTexrectUpscaleCopyShader() const
+	{
+		return new TexrectUpscaleCopyShader(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader, m_fragmentEnd);
+	}
+
+	graphics::ShaderProgram * SpecialShadersFactory::createTexrectColorAndDepthUpscaleCopyShader() const
+	{
+		if (m_glinfo.isGLES2)
+			return nullptr;
+
+		return new TexrectColorAndDepthUpscaleCopyShader(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader, m_fragmentEnd);
+	}
+
+	graphics::ShaderProgram * SpecialShadersFactory::createTexrectDownscaleCopyShader() const
 	{
-		return new TexrectCopyShader(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader, m_fragmentEnd);
+		return new TexrectDownscaleCopyShader(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader, m_fragmentEnd);
 	}
 
-	graphics::ShaderProgram * SpecialShadersFactory::createTexrectColorAndDepthCopyShader() const
+	graphics::ShaderProgram * SpecialShadersFactory::createTexrectColorAndDepthDownscaleCopyShader() const
 	{
 		if (m_glinfo.isGLES2)
 			return nullptr;
 
-		return new TexrectColorAndDepthCopyShader(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader, m_fragmentEnd);
+		return new TexrectColorAndDepthDownscaleCopyShader(m_glinfo, m_useProgram, m_vertexHeader, m_fragmentHeader, m_fragmentEnd);
 	}
 
 	graphics::ShaderProgram * SpecialShadersFactory::createGammaCorrectionShader() const
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.h b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.h
index c34943da..78dc0c17 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.h
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_SpecialShadersFactory.h
@@ -28,9 +28,13 @@ namespace glsl {
 
 		graphics::ShaderProgram * createTexrectDrawerClearShader() const;
 
-		graphics::ShaderProgram * createTexrectCopyShader() const;
+		graphics::ShaderProgram * createTexrectUpscaleCopyShader() const;
 
-		graphics::ShaderProgram * createTexrectColorAndDepthCopyShader() const;
+		graphics::ShaderProgram * createTexrectColorAndDepthUpscaleCopyShader() const;
+
+		graphics::ShaderProgram * createTexrectDownscaleCopyShader() const;
+
+		graphics::ShaderProgram * createTexrectColorAndDepthDownscaleCopyShader() const;
 
 		graphics::ShaderProgram * createGammaCorrectionShader() const;
 
diff --git a/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.cpp b/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.cpp
index 050f886b..8498df03 100644
--- a/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.cpp
@@ -418,14 +418,24 @@ graphics::ShaderProgram * ContextImpl::createTexrectDrawerClearShader()
 	return m_specialShadersFactory->createTexrectDrawerClearShader();
 }
 
-graphics::ShaderProgram * ContextImpl::createTexrectCopyShader()
+graphics::ShaderProgram * ContextImpl::createTexrectUpscaleCopyShader()
 {
-	return m_specialShadersFactory->createTexrectCopyShader();
+	return m_specialShadersFactory->createTexrectUpscaleCopyShader();
 }
 
-graphics::ShaderProgram * ContextImpl::createTexrectColorAndDepthCopyShader()
+graphics::ShaderProgram * ContextImpl::createTexrectColorAndDepthUpscaleCopyShader()
 {
-	return m_specialShadersFactory->createTexrectColorAndDepthCopyShader();
+	return m_specialShadersFactory->createTexrectColorAndDepthUpscaleCopyShader();
+}
+
+graphics::ShaderProgram * ContextImpl::createTexrectDownscaleCopyShader()
+{
+	return m_specialShadersFactory->createTexrectDownscaleCopyShader();
+}
+
+graphics::ShaderProgram * ContextImpl::createTexrectColorAndDepthDownscaleCopyShader()
+{
+	return m_specialShadersFactory->createTexrectColorAndDepthDownscaleCopyShader();
 }
 
 graphics::ShaderProgram * ContextImpl::createGammaCorrectionShader()
diff --git a/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.h b/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.h
index ff2b8ce5..074177bf 100644
--- a/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.h
+++ b/GLideN64/src/Graphics/OpenGLContext/opengl_ContextImpl.h
@@ -122,9 +122,13 @@ namespace opengl {
 
 		graphics::ShaderProgram * createTexrectDrawerClearShader() override;
 
-		graphics::ShaderProgram * createTexrectCopyShader() override;
+		graphics::ShaderProgram * createTexrectUpscaleCopyShader() override;
 
-		graphics::ShaderProgram * createTexrectColorAndDepthCopyShader() override;
+		graphics::ShaderProgram * createTexrectColorAndDepthUpscaleCopyShader() override;
+
+		graphics::ShaderProgram * createTexrectDownscaleCopyShader() override;
+
+		graphics::ShaderProgram * createTexrectColorAndDepthDownscaleCopyShader() override;
 
 		graphics::ShaderProgram * createGammaCorrectionShader() override;
 
diff --git a/GLideN64/src/GraphicsDrawer.cpp b/GLideN64/src/GraphicsDrawer.cpp
index 47f9e238..cddd5572 100644
--- a/GLideN64/src/GraphicsDrawer.cpp
+++ b/GLideN64/src/GraphicsDrawer.cpp
@@ -725,17 +725,17 @@ void GraphicsDrawer::_updateStates(DrawingState _drawingState) const
 	}
 }
 
-void GraphicsDrawer::_prepareDrawTriangle()
+void GraphicsDrawer::_prepareDrawTriangle(DrawingState _drawingState)
 {
 	m_texrectDrawer.draw();
 
 	if ((m_modifyVertices & MODIFY_XY) != 0)
 		gSP.changed &= ~CHANGED_VIEWPORT;
 
-	if (gSP.changed || gDP.changed)
-		_updateStates(DrawingState::Triangle);
+	m_drawingState = _drawingState;
 
-	m_drawingState = DrawingState::Triangle;
+	if (gSP.changed || gDP.changed)
+		_updateStates(_drawingState);
 
 	bool bFlatColors = false;
 	if (!RSP.LLE && (gSP.geometryMode & G_LIGHTING) == 0) {
@@ -762,7 +762,7 @@ void GraphicsDrawer::drawTriangles()
 		return;
 	}
 
-	_prepareDrawTriangle();
+	_prepareDrawTriangle(DrawingState::Triangle);
 
 	Context::DrawTriangleParameters triParams;
 	triParams.mode = drawmode::TRIANGLES;
@@ -813,7 +813,8 @@ void GraphicsDrawer::drawScreenSpaceTriangle(u32 _numVtx, graphics::DrawModePara
 	m_modifyVertices = MODIFY_ALL;
 
 	gSP.changed &= ~CHANGED_GEOMETRYMODE; // Don't update cull mode
-	_prepareDrawTriangle();
+	_prepareDrawTriangle(DrawingState::ScreenSpaceTriangle);
+	gfxContext.enable(enable::CULL_FACE, false);
 
 	Context::DrawTriangleParameters triParams;
 	triParams.mode = _mode;
@@ -844,7 +845,7 @@ void GraphicsDrawer::drawDMATriangles(u32 _numVtx)
 {
 	if (_numVtx == 0 || !_canDraw())
 		return;
-	_prepareDrawTriangle();
+	_prepareDrawTriangle(DrawingState::Triangle);
 
 
 	Context::DrawTriangleParameters triParams;
@@ -1339,10 +1340,19 @@ void GraphicsDrawer::drawTexturedRect(const TexturedRectParams & _params)
 				}
 			}
 
-			texST[t].s0 *= cache.current[t]->scaleS;
-			texST[t].t0 *= cache.current[t]->scaleT;
-			texST[t].s1 *= cache.current[t]->scaleS;
-			texST[t].t1 *= cache.current[t]->scaleT;
+			if (gDP.otherMode.textureFilter != G_TF_POINT && gDP.otherMode.cycleType != G_CYC_COPY) {
+				texST[t].s0 -= 0.5f;
+				texST[t].t0 -= 0.5f;
+				texST[t].s1 -= 0.5f;
+				texST[t].t1 -= 0.5f;
+			}
+
+			texST[t].s0 *= cache.current[t]->hdRatioS;
+			texST[t].t0 *= cache.current[t]->hdRatioT;
+			texST[t].s1 *= cache.current[t]->hdRatioS;
+			texST[t].t1 *= cache.current[t]->hdRatioT;
+
+
 		}
 	}
 
diff --git a/GLideN64/src/GraphicsDrawer.h b/GLideN64/src/GraphicsDrawer.h
index f15c6bf0..67e339c7 100644
--- a/GLideN64/src/GraphicsDrawer.h
+++ b/GLideN64/src/GraphicsDrawer.h
@@ -22,11 +22,12 @@ struct FrameBuffer;
 
 enum class DrawingState
 {
-	Non = 0,
-	Line = 1,
-	Triangle = 2,
-	Rect = 3,
-	TexRect = 4,
+	Non,
+	Line,
+	Triangle,
+	ScreenSpaceTriangle,
+	Rect,
+	TexRect
 };
 
 struct RectVertex
@@ -181,7 +182,7 @@ class GraphicsDrawer
 	void _updateDepthCompare() const;
 	void _updateTextures() const;
 	void _updateStates(DrawingState _drawingState) const;
-	void _prepareDrawTriangle();
+	void _prepareDrawTriangle(DrawingState _drawingState);
 	bool _canDraw() const;
 	void _drawThickLine(int _v0, int _v1, float _width);
 
diff --git a/GLideN64/src/Textures.cpp b/GLideN64/src/Textures.cpp
index cc42874e..937e81ad 100644
--- a/GLideN64/src/Textures.cpp
+++ b/GLideN64/src/Textures.cpp
@@ -156,7 +156,7 @@ inline u32 GetI8_RGBA4444( u64 *src, u16 x, u16 i, u8 palette )
 inline u32 GetCI16IA_RGBA8888(u64 *src, u16 x, u16 i, u8 palette)
 {
 	const u16 tex = ((u16*)src)[x^i];
-	const u16 col = (*(u16*)&TMEM[256 + (tex >> 8)]);
+	const u16 col = (*(u16*)&TMEM[256 + (tex & 0xFF)]);
 	const u16 c = col >> 8;
 	const u16 a = col & 0xFF;
 	return (a << 24) | (c << 16) | (c << 8) | c;
@@ -165,7 +165,7 @@ inline u32 GetCI16IA_RGBA8888(u64 *src, u16 x, u16 i, u8 palette)
 inline u32 GetCI16IA_RGBA4444(u64 *src, u16 x, u16 i, u8 palette)
 {
 	const u16 tex = ((u16*)src)[x^i];
-	const u16 col = (*(u16*)&TMEM[256 + (tex >> 8)]);
+	const u16 col = (*(u16*)&TMEM[256 + (tex & 0xFF)]);
 	const u16 c = col >> 12;
 	const u16 a = col & 0x0F;
 	return (a << 12) | (c << 8) | (c << 4) | c;
@@ -447,6 +447,8 @@ void TextureCache::_initDummyTexture(CachedTexture * _pDummy)
 	_pDummy->maskT = 0;
 	_pDummy->scaleS = 0.5f;
 	_pDummy->scaleT = 0.5f;
+	_pDummy->hdRatioS = 1.0f;
+	_pDummy->hdRatioT = 1.0f;
 	_pDummy->shiftScaleS = 1.0f;
 	_pDummy->shiftScaleT = 1.0f;
 	_pDummy->textureBytes = 2 * 2 * 4;
@@ -672,6 +674,9 @@ void _updateCachedTexture(const GHQTexInfo & _info, CachedTexture *_pTexture, u1
 
 	_pTexture->scaleS = 1.0f / (_pTexture->maskS ? f32(pow2(widthOrg)) : f32(widthOrg));
 	_pTexture->scaleT = 1.0f / (_pTexture->maskT ? f32(pow2(heightOrg)) : f32(heightOrg));
+	
+	_pTexture->hdRatioS = f32(_info.width / _pTexture->width);
+	_pTexture->hdRatioT = f32(_info.height / _pTexture->height);
 
 	_pTexture->bHDTexture = true;
 }
@@ -1320,8 +1325,14 @@ void TextureCache::activateTexture(u32 _t, CachedTexture *_pTexture)
 		params.wrapT = _pTexture->clampT ? textureParameters::WRAP_CLAMP_TO_EDGE :
 			_pTexture->mirrorT ? textureParameters::WRAP_MIRRORED_REPEAT : textureParameters::WRAP_REPEAT;
 
-		if (dwnd().getDrawer().getDrawingState() == DrawingState::Triangle && config.texture.maxAnisotropyF > 0.0f)
-			params.maxAnisotropy = Parameter(config.texture.maxAnisotropyF);
+		if (config.texture.maxAnisotropyF > 0.0f) {
+			switch (dwnd().getDrawer().getDrawingState()) {
+				case DrawingState::Triangle:
+				case DrawingState::ScreenSpaceTriangle:
+					params.maxAnisotropy = Parameter(config.texture.maxAnisotropyF);
+					break;
+			}
+		}
 	}
 
 	gfxContext.setTextureParameters(params);
@@ -1412,6 +1423,9 @@ void TextureCache::_updateBackground()
 	pCurrent->scaleS = 1.0f / (f32)(pCurrent->width);
 	pCurrent->scaleT = 1.0f / (f32)(pCurrent->height);
 
+	pCurrent->hdRatioS = 1.0f;
+	pCurrent->hdRatioT = 1.0f;
+
 	pCurrent->shiftScaleS = 1.0f;
 	pCurrent->shiftScaleT = 1.0f;
 
@@ -1565,6 +1579,9 @@ void TextureCache::update(u32 _t)
 	pCurrent->scaleS = 1.0f / (pCurrent->maskS ? f32(pow2(pCurrent->width)) : f32(pCurrent->width));
 	pCurrent->scaleT = 1.0f / (pCurrent->maskT ? f32(pow2(pCurrent->height)) : f32(pCurrent->height));
 
+	pCurrent->hdRatioS = 1.0f;
+	pCurrent->hdRatioT = 1.0f;
+
 	pCurrent->offsetS = 0.0f;
 	pCurrent->offsetT = 0.0f;
 
diff --git a/GLideN64/src/Textures.h b/GLideN64/src/Textures.h
index db866158..b1080fd0 100644
--- a/GLideN64/src/Textures.h
+++ b/GLideN64/src/Textures.h
@@ -33,6 +33,7 @@ struct CachedTexture
 	u16		width, height;			  // N64 width and height
 	u16		clampWidth, clampHeight;  // Size to clamp to
 	f32		scaleS, scaleT;			  // Scale to map to 0.0-1.0
+	f32     hdRatioS, hdRatioT;       // HD / N64 width and height 
 	f32		shiftScaleS, shiftScaleT; // Scale to shift
 	u32		textureBytes;
 
diff --git a/GLideN64/src/gSP.cpp b/GLideN64/src/gSP.cpp
index 150e73d6..263b9c05 100644
--- a/GLideN64/src/gSP.cpp
+++ b/GLideN64/src/gSP.cpp
@@ -318,6 +318,9 @@ void gSPLight( u32 l, s32 n )
 		gSP.lights.rgb[n][R] = _FIXED2FLOATCOLOR(light->r,8);
 		gSP.lights.rgb[n][G] = _FIXED2FLOATCOLOR(light->g,8);
 		gSP.lights.rgb[n][B] = _FIXED2FLOATCOLOR(light->b,8);
+		gSP.lights.rgb2[n][R] = _FIXED2FLOATCOLOR(light->r2, 8);
+		gSP.lights.rgb2[n][G] = _FIXED2FLOATCOLOR(light->g2, 8);
+		gSP.lights.rgb2[n][B] = _FIXED2FLOATCOLOR(light->b2, 8);
 
 		gSP.lights.xyz[n][X] = light->x;
 		gSP.lights.xyz[n][Y] = light->y;
@@ -359,6 +362,9 @@ void gSPLightCBFD( u32 l, s32 n )
 		gSP.lights.rgb[n][R] = _FIXED2FLOATCOLOR(light->r, 8);
 		gSP.lights.rgb[n][G] = _FIXED2FLOATCOLOR(light->g, 8);
 		gSP.lights.rgb[n][B] = _FIXED2FLOATCOLOR(light->b, 8);
+		gSP.lights.rgb2[n][R] = _FIXED2FLOATCOLOR(light->r2, 8);
+		gSP.lights.rgb2[n][G] = _FIXED2FLOATCOLOR(light->g2, 8);
+		gSP.lights.rgb2[n][B] = _FIXED2FLOATCOLOR(light->b2, 8);
 
 		gSP.lights.xyz[n][X] = light->x;
 		gSP.lights.xyz[n][Y] = light->y;
@@ -397,6 +403,9 @@ void gSPLightAcclaim(u32 l, s32 n)
 		gSP.lights.rgb[n][R] = _FIXED2FLOATCOLOR((RDRAM[(addrByte + 6) ^ 3]), 8);
 		gSP.lights.rgb[n][G] = _FIXED2FLOATCOLOR((RDRAM[(addrByte + 7) ^ 3]), 8);
 		gSP.lights.rgb[n][B] = _FIXED2FLOATCOLOR((RDRAM[(addrByte + 8) ^ 3]), 8);
+		gSP.lights.rgb2[n][R] = gSP.lights.rgb[n][R];
+		gSP.lights.rgb2[n][G] = gSP.lights.rgb[n][G];
+		gSP.lights.rgb2[n][B] = gSP.lights.rgb[n][B];
 	}
 
 	gSP.changed |= CHANGED_LIGHT;
@@ -481,17 +490,20 @@ void gSPLightVertexStandard(u32 v, SPVertex * spVtx)
 	if (!isHWLightingAllowed()) {
 		for(int j = 0; j < VNUM; ++j) {
 			SPVertex & vtx = spVtx[v+j];
-			vtx.r = gSP.lights.rgb[gSP.numLights][R];
-			vtx.g = gSP.lights.rgb[gSP.numLights][G];
-			vtx.b = gSP.lights.rgb[gSP.numLights][B];
+			const bool useFirstColor = ((v + j) & 1) == 0;
+			const float* pColor = useFirstColor ? gSP.lights.rgb[gSP.numLights] : gSP.lights.rgb2[gSP.numLights];
+			vtx.r = pColor[R];
+			vtx.g = pColor[G];
+			vtx.b = pColor[B];
 			vtx.HWLight = 0;
 
 			for (u32 i = 0; i < gSP.numLights; ++i) {
 				const f32 intensity = DotProduct( &vtx.nx, gSP.lights.i_xyz[i] );
 				if (intensity > 0.0f) {
-					vtx.r += gSP.lights.rgb[i][R] * intensity;
-					vtx.g += gSP.lights.rgb[i][G] * intensity;
-					vtx.b += gSP.lights.rgb[i][B] * intensity;
+					pColor = useFirstColor ? gSP.lights.rgb[i] : gSP.lights.rgb2[i];
+					vtx.r += pColor[R] * intensity;
+					vtx.g += pColor[G] * intensity;
+					vtx.b += pColor[B] * intensity;
 				}
 			}
 			vtx.r = min(1.0f, vtx.r);
@@ -1719,6 +1731,9 @@ void gSPLightColor( u32 lightNum, u32 packedColor )
 		gSP.lights.rgb[lightNum][R] = _FIXED2FLOATCOLOR(_SHIFTR( packedColor, 24, 8 ),8);
 		gSP.lights.rgb[lightNum][G] = _FIXED2FLOATCOLOR(_SHIFTR( packedColor, 16, 8 ),8);
 		gSP.lights.rgb[lightNum][B] = _FIXED2FLOATCOLOR(_SHIFTR( packedColor, 8, 8 ),8);
+		gSP.lights.rgb2[lightNum][R] = gSP.lights.rgb[lightNum][R];
+		gSP.lights.rgb2[lightNum][G] = gSP.lights.rgb[lightNum][G];
+		gSP.lights.rgb2[lightNum][B] = gSP.lights.rgb[lightNum][B];
 		gSP.changed |= CHANGED_HW_LIGHT;
 	}
 	DebugMsg(DEBUG_NORMAL, "gSPLightColor( %i, 0x%08X );\n", lightNum, packedColor );
diff --git a/GLideN64/src/gSP.h b/GLideN64/src/gSP.h
index a6687849..5cd8ae48 100644
--- a/GLideN64/src/gSP.h
+++ b/GLideN64/src/gSP.h
@@ -66,6 +66,7 @@ struct gSPInfo
 	struct
 	{
 		f32 rgb[12][3];
+		f32 rgb2[12][3];
 		f32 xyz[12][3];
 		f32 i_xyz[12][3];
 		f32 pos_xyzw[12][4];

From 903d22aee2634a92eaa539ef43c91e610effed27 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 14:00:13 +0200
Subject: [PATCH 13/28] Fix inverted ifdef for new Core options

---
 libretro/libretro_core_options.h | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
index b57daf3f..9dfd3345 100644
--- a/libretro/libretro_core_options.h
+++ b/libretro/libretro_core_options.h
@@ -239,7 +239,7 @@ struct retro_core_option_definition option_defs_us[] = {
             {"True", NULL},
             {NULL, NULL},
         },
-#ifdef VC
+#ifndef VC
         "True"
 #else
         "False"

From 4359d87288d4a5dd6eeec4d3724d19d57a2fa170 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 14:05:35 +0200
Subject: [PATCH 14/28] Update & Revert to Stock INI Headers - Removes OoT
 Subscreen fix, might've caused Issues

---
 custom/GLideN64/GLideN64.custom.ini.h         | 19 +++++++++++++
 .../mupen64plus-core/main/mupen64plus.ini.h   | 27 ++++++++++++-------
 mupen64plus-core/data/mupen64plus.ini         |  9 +++++++
 3 files changed, 45 insertions(+), 10 deletions(-)

diff --git a/custom/GLideN64/GLideN64.custom.ini.h b/custom/GLideN64/GLideN64.custom.ini.h
index 9b5210d6..d0c66917 100644
--- a/custom/GLideN64/GLideN64.custom.ini.h
+++ b/custom/GLideN64/GLideN64.custom.ini.h
@@ -14,6 +14,11 @@ char customini[] =
 "Good_Name=Bio F.R.E.A.K.S. (E)(U)\n"
 "frameBufferEmulation\\copyToRDRAM=1\n"
 "\n"
+"[BioHazard%20II]\n"
+"frameBufferEmulation\\copyFromRDRAM=1\n"
+"frameBufferEmulation\\copyToRDRAM=0\n"
+"frameBufferEmulation\\copyDepthToRDRAM=0\n"
+"\n"
 "[52150A67]\n"
 "Good_Name=Bokujou Monogatari 2 (J)\n"
 "frameBufferEmulation\\N64DepthCompare=1\n"
@@ -45,7 +50,9 @@ char customini[] =
 "\n"
 "[DR.MARIO%2064]\n"
 "Good_Name=Dr. Mario 64 (U)\n"
+"frameBufferEmulation\\fbInfoDisabled=0\n"
 "frameBufferEmulation\\copyFromRDRAM=1\n"
+"frameBufferEmulation\\copyToRDRAM=0\n"
 "\n"
 "[EXTREME_G]\n"
 "Good_Name=Extreme-G (E)\n"
@@ -71,6 +78,12 @@ char customini[] =
 "Good_Name=F-1 Pole Position 64 (E)(U)\n"
 "frameBufferEmulation\\copyToRDRAM=1\n"
 "\n"
+"[FLAPPYBIRD64]\n"
+"Good_Name=FlappyBird64\n"
+"frameBufferEmulation\\fbInfoDisabled=0\n"
+"frameBufferEmulation\\copyFromRDRAM=1\n"
+"frameBufferEmulation\\copyToRDRAM=0\n"
+"\n"
 "[GOEMON2%20DERODERO]\n"
 "Good_Name=Ganbare Goemon - Dero Dero Douchuu Obake Tenkomori (J)\n"
 "graphics2D\\enableNativeResTexrects=1\n"
@@ -181,6 +194,7 @@ char customini[] =
 "\n"
 "[POKEMON%20SNAP]\n"
 "Good_Name=Pokemon Snap (U)\n"
+"generalEmulation\\rdramImageDitheringMode=1\n"
 "frameBufferEmulation\\copyAuxToRDRAM=1\n"
 "frameBufferEmulation\\copyToRDRAM=1\n"
 "frameBufferEmulation\\fbInfoDisabled=0\n"
@@ -203,6 +217,11 @@ char customini[] =
 "Good_Name=Rat Attack\n"
 "frameBufferEmulation\\fbInfoDisabled=0\n"
 "\n"
+"[RESIDENT%20EVIL%20II]\n"
+"frameBufferEmulation\\copyFromRDRAM=1\n"
+"frameBufferEmulation\\copyToRDRAM=0\n"
+"frameBufferEmulation\\copyDepthToRDRAM=0\n"
+"\n"
 "[ROCKMAN%20DASH]\n"
 "Good_Name=Rockman Dash - Hagane no Boukenshin (J)\n"
 "graphics2D\\correctTexrectCoords=2\n"
diff --git a/custom/mupen64plus-core/main/mupen64plus.ini.h b/custom/mupen64plus-core/main/mupen64plus.ini.h
index 23a2fcdb..a29d5c4a 100644
--- a/custom/mupen64plus-core/main/mupen64plus.ini.h
+++ b/custom/mupen64plus-core/main/mupen64plus.ini.h
@@ -5,7 +5,7 @@ char inifile[] =
 "; Mupen64Plus Rom Catalog\n"
 "; Generated by M64P_INICreater.php\n"
 "; Script coded by: okaygo\n"
-"; \n"
+";\n"
 "; Total Rom Count: 3048\n"
 "; Fri, 06 Jun 08 23:13:38 -0400\n"
 "\n"
@@ -1447,6 +1447,7 @@ char inifile[] =
 "[3406A505C22BAC2F40D9BFC6FF08CF86]\n"
 "GoodName=BattleTanx (U) [!]\n"
 "CRC=6AA4DDE7 E3E2F4E7\n"
+"CountPerOp=3\n"
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Players=4\n"
@@ -1484,7 +1485,7 @@ char inifile[] =
 "[654557C316F901A2CA6F7F4B43343147]\n"
 "GoodName=BattleTanx - Global Assault (U) [!]\n"
 "CRC=75A4E247 6008963D\n"
-"CountPerOp=1\n"
+"CountPerOp=3\n"
 "Players=4\n"
 "SaveType=None\n"
 "Mempak=Yes\n"
@@ -4022,6 +4023,7 @@ char inifile[] =
 "Rumble=Yes\n"
 "CountPerOp=1\n"
 "; Bone displacement fix\n"
+"; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise\n"
 "Cheat0=806128E2 0000\n"
 "\n"
 "[428067DC7DB42DFC977A775F0A6E55B1]\n"
@@ -4047,7 +4049,8 @@ char inifile[] =
 "CountPerOp=1\n"
 "Rumble=Yes\n"
 "; Bone displacement fix\n"
-"Cheat0=806170A2 0000\n"
+"; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise\n"
+"Cheat0=806128E2 0000\n"
 "\n"
 "[98A5836E3A5DA7BD0B5819E7498ACEA2]\n"
 "GoodName=Donkey Kong 64 (U) (Kiosk Demo) [!]\n"
@@ -4079,7 +4082,8 @@ char inifile[] =
 "CountPerOp=1\n"
 "Rumble=Yes\n"
 "; Bone displacement fix\n"
-"Cheat0=80619632 0000\n"
+"; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise\n"
+"Cheat0=806128E2 0000\n"
 "\n"
 "[6B4772AA1743FEAC1919618B3FC6B3E1]\n"
 "GoodName=Donkey Kong 64 (U) [b1]\n"
@@ -7972,8 +7976,6 @@ char inifile[] =
 "SaveType=SRAM\n"
 "Players=1\n"
 "Rumble=Yes\n"
-"; Subscreen fix\n"
-"Cheat0=801DA5CB 0002\n"
 "\n"
 "[A43A350385FA814EC9793B7ACD9E18F4]\n"
 "GoodName=Legend of Zelda, The - Ocarina of Time (U) (V1.0) (Room121 Hack)\n"
@@ -8146,8 +8148,6 @@ char inifile[] =
 "SaveType=SRAM\n"
 "Players=1\n"
 "Rumble=Yes\n"
-"; Subscreen fix\n"
-"Cheat0=801DA78B 0002\n"
 "\n"
 "[92C842FC8CF706FF290044D40A64D346]\n"
 "GoodName=Legend of Zelda, The - Ocarina of Time (U) (V1.1) [T+Ita100]\n"
@@ -8195,8 +8195,6 @@ char inifile[] =
 "Players=1\n"
 "SaveType=SRAM\n"
 "Rumble=Yes\n"
-"; Subscreen fix\n"
-"Cheat0=801DAE8B 0002\n"
 "\n"
 "[CD09029EDCFB7C097AC01986A0F83D3F]\n"
 "GoodName=Legend of Zelda, The - Ocarina of Time (U) (GC) [!]\n"
@@ -14635,6 +14633,7 @@ char inifile[] =
 "Players=1\n"
 "SaveType=Eeprom 4KB\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[3CB88B934572E7520F35E5458798775B]\n"
 "GoodName=Star Wars Episode I - Battle for Naboo (U) [!]\n"
@@ -14642,6 +14641,7 @@ char inifile[] =
 "Players=1\n"
 "SaveType=Eeprom 4KB\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[B4724120C269A1DC86991D34B1561F3D]\n"
 "GoodName=Star Wars Episode I - Battle for Naboo (U) [b1]\n"
@@ -15688,6 +15688,7 @@ char inifile[] =
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[0072538EF925645DB310F8E23A480B89]\n"
 "GoodName=Top Gear Hyper Bike (E) [!]\n"
@@ -15696,6 +15697,7 @@ char inifile[] =
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[561B438F6E8240BEF1DAEB36AAE72675]\n"
 "GoodName=Top Gear Hyper Bike (E) [b1]\n"
@@ -15709,6 +15711,7 @@ char inifile[] =
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[7258F4AB367B025C95A4F476C461E717]\n"
 "GoodName=Top Gear Hyper Bike (U) [!]\n"
@@ -15717,6 +15720,7 @@ char inifile[] =
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[6C65A252F227AEF18DF2DD3CE04CC821]\n"
 "GoodName=Top Gear Overdrive (E) [!]\n"
@@ -15724,6 +15728,7 @@ char inifile[] =
 "Players=4\n"
 "SaveType=Eeprom 4KB\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[11D6FFF288DE1BD61CCBD7CCA0C4A97B]\n"
 "GoodName=Top Gear Overdrive (E) [h1C]\n"
@@ -15736,6 +15741,7 @@ char inifile[] =
 "Players=4\n"
 "SaveType=Eeprom 4KB\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[8C0F46FEF9A6034FCF0B7D6952FFEC53]\n"
 "GoodName=Top Gear Overdrive (J) [b1]\n"
@@ -15748,6 +15754,7 @@ char inifile[] =
 "Players=4\n"
 "SaveType=Eeprom 4KB\n"
 "Rumble=Yes\n"
+"CountPerOp=1\n"
 "\n"
 "[773FD446DA7F4E392907505053BF2A42]\n"
 "GoodName=Top Gear Overdrive (U) [o1]\n"
diff --git a/mupen64plus-core/data/mupen64plus.ini b/mupen64plus-core/data/mupen64plus.ini
index c7518b04..e88f19ab 100644
--- a/mupen64plus-core/data/mupen64plus.ini
+++ b/mupen64plus-core/data/mupen64plus.ini
@@ -4018,6 +4018,9 @@ SaveType=Eeprom 16KB
 Players=4
 Rumble=Yes
 CountPerOp=1
+; Bone displacement fix
+; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise
+Cheat0=806128E2 0000
 
 [428067DC7DB42DFC977A775F0A6E55B1]
 GoodName=Donkey Kong 64 (E) [b1]
@@ -4041,6 +4044,9 @@ SaveType=Eeprom 16KB
 Players=4
 CountPerOp=1
 Rumble=Yes
+; Bone displacement fix
+; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise
+Cheat0=806128E2 0000
 
 [98A5836E3A5DA7BD0B5819E7498ACEA2]
 GoodName=Donkey Kong 64 (U) (Kiosk Demo) [!]
@@ -4071,6 +4077,9 @@ SaveType=Eeprom 16KB
 Players=4
 CountPerOp=1
 Rumble=Yes
+; Bone displacement fix
+; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise
+Cheat0=806128E2 0000
 
 [6B4772AA1743FEAC1919618B3FC6B3E1]
 GoodName=Donkey Kong 64 (U) [b1]

From 39eb6e4d08a80c144ee4d3c381301584276fabcf Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 21:05:02 +0200
Subject: [PATCH 15/28] [GLN64] Implement Threaded Renderer

---
 .../Graphics/OpenGLContext/GLFunctions.cpp    |  18 +-
 .../src/Graphics/OpenGLContext/GLFunctions.h  |   7 +-
 .../ThreadedOpenGl/opengl_WrappedFunctions.h  |  12 +-
 .../ThreadedOpenGl/opengl_Wrapper.cpp         |  30 +++-
 .../ThreadedOpenGl/opengl_Wrapper.h           |   3 +-
 .../mupen64plus/mupen64plus_DisplayWindow.cpp |   9 +-
 .../OpenGLContext/opengl_CachedFunctions.cpp  |  11 --
 GLideN64/src/Log.h                            |   6 +-
 custom/mupen64plus-next_common.h              |  17 ++
 libretro/libretro.c                           | 162 ++++++++++++++----
 libretro/libretro_core_options.h              |  11 ++
 mupen64plus-core/src/device/r4300/interrupt.c |   8 +-
 mupen64plus-core/src/main/main.c              |  15 +-
 mupen64plus-core/src/main/savestates.c        |  60 ++++++-
 14 files changed, 287 insertions(+), 82 deletions(-)

diff --git a/GLideN64/src/Graphics/OpenGLContext/GLFunctions.cpp b/GLideN64/src/Graphics/OpenGLContext/GLFunctions.cpp
index adddad6b..1c6b3e10 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLFunctions.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLFunctions.cpp
@@ -5,7 +5,9 @@
 
 #include "GLFunctions.h"
 
-#define ASSIGN_PROC_ADR(proc_type, proc_name) ptr##proc_name = gl##proc_name
+#define ASSIGN_PROC_ADR(proc_type, proc_name) ptr##proc_name = rgl##proc_name
+#define ASSIGN_GL_PROC_ADR(proc_type, proc_name) ptr##proc_name = gl##proc_name
+
 #if defined(GL_USE_DLSYM)
 // Use dlsym() to load GL symbols from the default shared object search order
 #define GL_GET_PROC_ADR(proc_type, proc_name) ptr##proc_name = (proc_type) dlsym(RTLD_DEFAULT, "gl"#proc_name)
@@ -237,8 +239,8 @@ extern "C" void initGLFunctions()
 	ASSIGN_PROC_ADR(PFNGLCULLFACEPROC, CullFace);
 	ASSIGN_PROC_ADR(PFNGLDEPTHFUNCPROC, DepthFunc);
 	ASSIGN_PROC_ADR(PFNGLDEPTHMASKPROC, DepthMask);
-	GL_GET_PROC_ADR(PFNGLDISABLEPROC, Disable);
-	GL_GET_PROC_ADR(PFNGLENABLEPROC, Enable);
+	ASSIGN_PROC_ADR(PFNGLDISABLEPROC, Disable);
+	ASSIGN_PROC_ADR(PFNGLENABLEPROC, Enable);
 	ASSIGN_PROC_ADR(PFNGLPOLYGONOFFSETPROC, PolygonOffset);
 	ASSIGN_PROC_ADR(PFNGLSCISSORPROC, Scissor);
 	ASSIGN_PROC_ADR(PFNGLVIEWPORTPROC, Viewport);
@@ -281,9 +283,9 @@ extern "C" void initGLFunctions()
 	ASSIGN_PROC_ADR(PFNGLVIEWPORTPROC, Viewport);
 	ASSIGN_PROC_ADR(PFNGLBINDTEXTUREPROC, BindTexture);
 	GL_GET_PROC_ADR(PFNGLTEXIMAGE2DPROC, TexImage2D);
-	ASSIGN_PROC_ADR(PFNGLTEXPARAMETERIPROC, TexParameteri);
-	ASSIGN_PROC_ADR(PFNGLGETINTEGERVPROC, GetIntegerv);
-	ASSIGN_PROC_ADR(PFNGLGETSTRINGPROC, GetString);
+	ASSIGN_GL_PROC_ADR(PFNGLTEXPARAMETERIPROC, TexParameteri);
+	ASSIGN_GL_PROC_ADR(PFNGLGETINTEGERVPROC, GetIntegerv);
+	ASSIGN_GL_PROC_ADR(PFNGLGETSTRINGPROC, GetString);
 	ASSIGN_PROC_ADR(PFNGLREADPIXELSPROC, ReadPixels);
 	ASSIGN_PROC_ADR(PFNGLTEXSUBIMAGE2DPROC, TexSubImage2D);
 	ASSIGN_PROC_ADR(PFNGLDRAWARRAYSPROC, DrawArrays);
@@ -291,12 +293,12 @@ extern "C" void initGLFunctions()
 	ASSIGN_PROC_ADR(PFNGLDRAWELEMENTSPROC, DrawElements);
 	ASSIGN_PROC_ADR(PFNGLLINEWIDTHPROC, LineWidth);
 	ASSIGN_PROC_ADR(PFNGLCLEARPROC, Clear);
-	ASSIGN_PROC_ADR(PFNGLGETFLOATVPROC, GetFloatv);
+	ASSIGN_GL_PROC_ADR(PFNGLGETFLOATVPROC, GetFloatv);
 	ASSIGN_PROC_ADR(PFNGLDELETETEXTURESPROC, DeleteTextures);
 	ASSIGN_PROC_ADR(PFNGLGENTEXTURESPROC, GenTextures);
 	GL_GET_PROC_ADR(PFNGLTEXPARAMETERFPROC, TexParameterf);
 	ASSIGN_PROC_ADR(PFNGLREADBUFFERPROC, ReadBuffer);
-	ASSIGN_PROC_ADR(PFNGLFINISHPROC, Finish);
+	ASSIGN_GL_PROC_ADR(PFNGLFINISHPROC, Finish);
 #endif
 
 	ASSIGN_PROC_ADR(PFNGLCREATESHADERPROC, CreateShader);
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLFunctions.h b/GLideN64/src/Graphics/OpenGLContext/GLFunctions.h
index ac4c719b..d6eb7836 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLFunctions.h
+++ b/GLideN64/src/Graphics/OpenGLContext/GLFunctions.h
@@ -208,6 +208,9 @@ extern PFNGLEGLIMAGETARGETRENDERBUFFERSTORAGEOESPROC ptrEGLImageTargetRenderbuff
 extern "C" void initGLFunctions();
 
 #ifndef NO_GL_WRAP
+#ifdef __LIBRETRO__
+#include <glsm/glsm_caps.h>
+#endif // __LIBRETRO__
 #define glGetError(...) opengl::FunctionWrapper::wrGetError(__VA_ARGS__)
 #define glBlendFunc(...) opengl::FunctionWrapper::wrBlendFunc(__VA_ARGS__)
 #define glPixelStorei(...) opengl::FunctionWrapper::wrPixelStorei(__VA_ARGS__)
@@ -215,8 +218,8 @@ extern "C" void initGLFunctions();
 #define glCullFace(...) opengl::FunctionWrapper::wrCullFace(__VA_ARGS__)
 #define glDepthFunc(...) opengl::FunctionWrapper::wrDepthFunc(__VA_ARGS__)
 #define glDepthMask(...) opengl::FunctionWrapper::wrDepthMask(__VA_ARGS__)
-#define glDisable(...) opengl::FunctionWrapper::wrDisable(__VA_ARGS__)
-#define glEnable(...) opengl::FunctionWrapper::wrEnable(__VA_ARGS__)
+#define glDisable(T) opengl::FunctionWrapper::wrDisable(S##T)
+#define glEnable(T) opengl::FunctionWrapper::wrEnable(S##T)
 #define glPolygonOffset(...) opengl::FunctionWrapper::wrPolygonOffset(__VA_ARGS__)
 #define glScissor(...) opengl::FunctionWrapper::wrScissor(__VA_ARGS__)
 #define glViewport(...) opengl::FunctionWrapper::wrViewport(__VA_ARGS__)
diff --git a/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_WrappedFunctions.h b/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_WrappedFunctions.h
index 0c9a19e2..19434abb 100644
--- a/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_WrappedFunctions.h
+++ b/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_WrappedFunctions.h
@@ -20,6 +20,10 @@
 #include "RingBufferPool.h"
 #include <string.h> // memcpy
 
+#include <mupen64plus-next_common.h>
+#include <libco.h>
+extern "C" cothread_t retro_thread;
+
 #ifdef MUPENPLUSAPI
 #include <mupenplus/GLideN64_mupenplus.h>
 #else
@@ -5162,8 +5166,14 @@ class CoreVideoGLSwapBuffersCommand : public OpenGlCommand
 	{
 #ifndef __LIBRETRO__
 		::CoreVideo_GL_SwapBuffers();
-#endif
+#else
+		libretro_swap_buffer = true;
+		if(EnableThreadedRenderer)
+		{
+			co_switch(retro_thread);
+		}
 		m_swapBuffersCallback();
+#endif
 	}
 
 private:
diff --git a/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp b/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp
index 75aa9cb2..9dc62ede 100644
--- a/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.cpp
@@ -4,6 +4,16 @@
 #include <memory>
 #include <set>
 
+extern "C" {
+	extern void context_reset();
+	bool threaded_gl_safe_shutdown = false;
+
+	void gln64_thr_gl_invoke_command_loop()
+	{
+		opengl::FunctionWrapper::commandLoop();
+	}
+}
+
 namespace opengl {
 
 	bool FunctionWrapper::m_threaded_wrapper = false;
@@ -63,6 +73,8 @@ namespace opengl {
 	void FunctionWrapper::commandLoop()
 	{
 		bool timeToShutdown = false;
+		threaded_gl_safe_shutdown = false;
+        
 		while (!timeToShutdown) {
 			std::shared_ptr<OpenGlCommand> command;
 
@@ -76,7 +88,16 @@ namespace opengl {
 					timeToShutdown = command->isTimeToShutdown();
 				}
 			}
+			if(!retro_savestate_complete)
+			{				
+				// Yield to frontend
+				co_switch(retro_thread);
+			}
 		}
+		
+		// Return
+		threaded_gl_safe_shutdown = true;
+		co_switch(retro_thread);
 	}
 
 #if defined(GL_DEBUG) && defined(GL_PROFILE)
@@ -125,8 +146,7 @@ namespace opengl {
 		if (_threaded == 1) {
 			m_threaded_wrapper = true;
 			m_shutdown = false;
-			m_commandExecutionThread = std::thread(&FunctionWrapper::commandLoop);
-
+			//m_commandExecutionThread = std::thread(&FunctionWrapper::commandLoop);
 		}
 		else {
 			m_threaded_wrapper = false;
@@ -1418,7 +1438,6 @@ namespace opengl {
 #endif
 
 #ifdef MUPENPLUSAPI
-
 	m64p_error FunctionWrapper::CoreVideo_Init()
 	{
 		m64p_error returnValue;
@@ -1443,7 +1462,7 @@ namespace opengl {
 #ifndef GL_DEBUG
 		if (m_threaded_wrapper) {
 			m_condition.notify_all();
-			m_commandExecutionThread.join();
+			//m_commandExecutionThread.join();
 		}
 #endif
 	}
@@ -1484,7 +1503,6 @@ namespace opengl {
 			executeCommand(CoreVideoGLSwapBuffersCommand::get([]{ReduceSwapBuffersQueued();}));
 		else
 			CoreVideoGLSwapBuffersCommand::get([]{ReduceSwapBuffersQueued();})->performCommandSingleThreaded();
-
 	}
 #else
 	bool FunctionWrapper::windowsStart()
@@ -1512,7 +1530,7 @@ namespace opengl {
 #ifndef GL_DEBUG
 		if (m_threaded_wrapper) {
 			m_condition.notify_all();
-			m_commandExecutionThread.join();
+			//m_commandExecutionThread.join();
 		}
 #endif
 	}
diff --git a/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h b/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h
index 733d57ed..96dbd55b 100644
--- a/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h
+++ b/GLideN64/src/Graphics/OpenGLContext/ThreadedOpenGl/opengl_Wrapper.h
@@ -17,12 +17,13 @@ namespace opengl {
 
 	class FunctionWrapper
 	{
+    public:
+		static void commandLoop();
 	private:
 		static void executeCommand(std::shared_ptr<OpenGlCommand> _command);
 
 		static void executePriorityCommand(std::shared_ptr<OpenGlCommand> _command);
 
-		static void commandLoop();
 
 		static BlockingReaderWriterQueue<std::shared_ptr<OpenGlCommand>> m_commandQueue;
 		static BlockingReaderWriterQueue<std::shared_ptr<OpenGlCommand>> m_commandQueueHighPriority;
diff --git a/GLideN64/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp b/GLideN64/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp
index 1f7decf8..a9a4ea36 100644
--- a/GLideN64/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/mupen64plus/mupen64plus_DisplayWindow.cpp
@@ -15,8 +15,7 @@
 #include <DisplayWindow.h>
 
 #include <libretro_private.h>
-#include "../../../../../custom/GLideN64/mupenplus/GLideN64_mupenplus.h"
-
+#include <mupen64plus-next_common.h>
 using namespace opengl;
 
 #ifdef __cplusplus
@@ -62,7 +61,7 @@ void DisplayWindowMupen64plus::_setAttributes()
 
 bool DisplayWindowMupen64plus::_start()
 {
-	FunctionWrapper::setThreadedMode(false);
+	FunctionWrapper::setThreadedMode(EnableThreadedRenderer);
 	
 	_setAttributes();
 
@@ -82,14 +81,14 @@ bool DisplayWindowMupen64plus::_start()
 
 void DisplayWindowMupen64plus::_stop()
 {
+    FunctionWrapper::CoreVideo_Quit();
 }
 
 void DisplayWindowMupen64plus::_swapBuffers()
 {
 	//Don't let the command queue grow too big buy waiting on no more swap buffers being queued
 	FunctionWrapper::WaitForSwapBuffersQueued();
-
-	libretro_swap_buffer = true;
+	FunctionWrapper::CoreVideo_GL_SwapBuffers();
 }
 
 void DisplayWindowMupen64plus::_saveScreenshot()
diff --git a/GLideN64/src/Graphics/OpenGLContext/opengl_CachedFunctions.cpp b/GLideN64/src/Graphics/OpenGLContext/opengl_CachedFunctions.cpp
index ef7c1817..eeef9a92 100644
--- a/GLideN64/src/Graphics/OpenGLContext/opengl_CachedFunctions.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/opengl_CachedFunctions.cpp
@@ -7,17 +7,6 @@
 using namespace graphics;
 using namespace opengl;
 
-#ifdef __LIBRETRO__
-#include <glsm/glsm_caps.h>
-// TODO: Fix macro mess
-#undef glDisable
-#undef glEnable
-extern "C" void rglEnable(GLenum cap);
-extern "C" void rglDisable(GLenum cap);
-#define glDisable(T) rglDisable(S##T)
-#define glEnable(T)  rglEnable(S##T)
-#endif // __LIBRETRO__
-
 /*---------------CachedEnable-------------*/
 
 CachedEnable::CachedEnable(Parameter _parameter)
diff --git a/GLideN64/src/Log.h b/GLideN64/src/Log.h
index 250f74e6..c6d006b1 100644
--- a/GLideN64/src/Log.h
+++ b/GLideN64/src/Log.h
@@ -8,7 +8,11 @@
 #define LOG_VERBOSE 4
 #define LOG_APIFUNC 5
 
-#define LOG_LEVEL LOG_WARNING
+#define LOG_LEVEL LOG_NONE
+
+#include "Types.h"
+#include <cstdio>
+#include <string>
 
 #if LOG_LEVEL > 0
 
diff --git a/custom/mupen64plus-next_common.h b/custom/mupen64plus-next_common.h
index 53531b74..ff2a325f 100644
--- a/custom/mupen64plus-next_common.h
+++ b/custom/mupen64plus-next_common.h
@@ -27,6 +27,7 @@ extern "C" {
 #endif /* __cplusplus */
 
 #include <stdbool.h>
+#include <libretro.h>
 
 #include "api/m64p_common.h"
 #include "api/m64p_plugin.h"
@@ -58,8 +59,23 @@ uint32_t get_retro_screen_height();
 
 extern enum rdp_plugin_type current_rdp_type;
 extern enum rsp_plugin_type current_rsp_type;
+extern retro_environment_t environ_cb;
 extern bool libretro_swap_buffer;
 
+// Savestate globals
+extern bool retro_savestate_complete;
+extern int  retro_savestate_result;
+
+// 64DD globals
+extern char* retro_dd_path_img;
+extern char* retro_dd_path_rom;
+
+// Threaded GL Callback
+extern void gln64_thr_gl_invoke_command_loop();
+extern bool threaded_gl_safe_shutdown;
+
+// Core options
+// GLN64
 extern uint32_t bilinearMode;
 extern uint32_t EnableHybridFilter;
 extern uint32_t EnableDitheringPattern;
@@ -96,6 +112,7 @@ extern uint32_t EnableTxCacheCompression;
 extern uint32_t ForceDisableExtraMem;
 extern uint32_t EnableNativeResFactor;
 extern uint32_t EnableN64DepthCompare;
+extern uint32_t EnableThreadedRenderer;
 
 // Overscan Options
 extern uint32_t EnableOverscan;
diff --git a/libretro/libretro.c b/libretro/libretro.c
index 0f14fb24..a45e589e 100644
--- a/libretro/libretro.c
+++ b/libretro/libretro.c
@@ -1,20 +1,20 @@
 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
- *   Mupen64plus-Next - libretro.c                                       *
- *   Copyright (C) 2020 M4xw <m4x@m4xw.net                               *
- *                                                                    *
+ *   Mupen64plus-Next - libretro.c                                         *
+ *   Copyright (C) 2020 M4xw <m4x@m4xw.net>                                *
+ *                                                                         *
  *   This program is free software; you can redistribute it and/or modify  *
  *   it under the terms of the GNU General Public License as published by  *
  *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                 *
- *                                                                    *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
  *   This program is distributed in the hope that it will be useful,       *
  *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
- *   GNU General Public License for more details.                         *
- *                                                                    *
+ *   GNU General Public License for more details.                          *
+ *                                                                         *
  *   You should have received a copy of the GNU General Public License     *
- *   along with this program; if not, write to the                        *
- *   Free Software Foundation, Inc.,                                     *
+ *   along with this program; if not, write to the                         *
+ *   Free Software Foundation, Inc.,                                       *
  *   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.          *
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
@@ -34,7 +34,7 @@
 #ifdef HAVE_LIBNX
 #include <switch.h>
 #endif
-
+#include <pthread.h>
 #include <glsm/glsmsym.h>
 
 #include "api/m64p_frontend.h"
@@ -142,6 +142,8 @@ float retro_screen_aspect = 4.0 / 3.0;
 
 char* retro_dd_path_img;
 char* retro_dd_path_rom;
+bool retro_savestate_complete = false;
+int  retro_savestate_result = 0;
 
 uint32_t bilinearMode = 0;
 uint32_t EnableHybridFilter = 0;
@@ -169,16 +171,13 @@ uint32_t EnableTextureCache = 0;
 uint32_t EnableFBEmulation = 0;
 uint32_t EnableFrameDuping = 0;
 uint32_t EnableLODEmulation = 0;
-uint32_t EnableFullspeed = 0;
-uint32_t CountPerOp = 0;
-uint32_t CountPerScanlineOverride = 0;
 uint32_t BackgroundMode = 0; // 0 is bgOnePiece
 uint32_t EnableEnhancedTextureStorage;
 uint32_t EnableEnhancedHighResStorage;
 uint32_t EnableTxCacheCompression = 0;
-uint32_t ForceDisableExtraMem = 0;
 uint32_t EnableNativeResFactor = 0;
 uint32_t EnableN64DepthCompare = 0;
+uint32_t EnableThreadedRenderer = 0;
 
 // Overscan options
 #define GLN64_OVERSCAN_SCALING "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50"
@@ -188,10 +187,18 @@ uint32_t OverscanLeft = 0;
 uint32_t OverscanRight = 0;
 uint32_t OverscanBottom = 0;
 
+uint32_t EnableFullspeed = 0;
+uint32_t CountPerOp = 0;
+uint32_t CountPerScanlineOverride = 0;
+uint32_t ForceDisableExtraMem = 0;
+
 extern struct device g_dev;
 extern unsigned int r4300_emumode;
 extern struct cheat_ctx g_cheat_ctx;
 
+static bool emuThreadRunning = false;
+static pthread_t emuThread;
+
 // after the controller's CONTROL* member has been assigned we can update
 // them straight from here...
 extern struct
@@ -231,12 +238,21 @@ static void setup_variables(void)
 
     libretro_set_core_options(environ_cb);
     environ_cb(RETRO_ENVIRONMENT_SET_CONTROLLER_INFO, (void*)ports);
+    //environ_cb(RETRO_ENVIRONMENT_SET_SAVE_STATE_IN_BACKGROUND, false);
 }
 
+static void n64StateCallback(void *Context, m64p_core_param param_type, int new_value)
+{
+    if(param_type == M64CORE_STATE_LOADCOMPLETE || param_type == M64CORE_STATE_SAVECOMPLETE)
+    {
+        retro_savestate_complete = true;
+        retro_savestate_result = new_value;
+    }
+}
 
 static bool emu_step_load_data()
 {
-    m64p_error ret = CoreStartup(FRONTEND_API_VERSION, ".", ".", "Core", n64DebugCallback, 0, 0);
+    m64p_error ret = CoreStartup(FRONTEND_API_VERSION, ".", ".", NULL, n64DebugCallback, 0, n64StateCallback);
     if(ret && log_cb)
         log_cb(RETRO_LOG_ERROR, CORE_NAME ": failed to initialize core (err=%i)\n", ret);
 
@@ -281,12 +297,20 @@ static void emu_step_initialize(void)
     plugin_connect_all();
 }
 
-static void EmuThreadFunction(void)
+static void* EmuThreadFunction(void* param)
 {
     log_cb(RETRO_LOG_DEBUG, CORE_NAME ": [EmuThread] M64CMD_EXECUTE\n");
 
     initializing = false;
+
+    // Runs until CMD_STOP
     CoreDoCommand(M64CMD_EXECUTE, 0, NULL);
+
+    if(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer)
+    {
+        // Unset
+        emuThreadRunning = false;
+    }
 }
 
 void reinit_gfx_plugin(void)
@@ -449,16 +473,23 @@ void retro_init(void)
 
     environ_cb(RETRO_ENVIRONMENT_SET_PIXEL_FORMAT, &colorMode);
     environ_cb(RETRO_ENVIRONMENT_GET_RUMBLE_INTERFACE, &rumble);
-    initializing = true;
+    if(!(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer))
+    {
+        initializing = true;
 
-    retro_thread = co_active();
-    game_thread = co_create(65536 * sizeof(void*) * 16, EmuThreadFunction);
+        retro_thread = co_active();
+        game_thread = co_create(65536 * sizeof(void*) * 16, EmuThreadFunction);
+    }
 }
 
 void retro_deinit(void)
-{
-    CoreDoCommand(M64CMD_STOP, 0, NULL);
-    co_switch(game_thread); /* Let the core thread finish */
+{    
+    if(!(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer))
+    {
+        CoreDoCommand(M64CMD_STOP, 0, NULL);
+        co_switch(game_thread); /* Let the core thread finish */
+    }
+
     deinit_audio_libretro();
 
     if (perf_cb.perf_log)
@@ -609,6 +640,13 @@ static void update_variables(bool startup)
           }
        }
 
+       var.key = CORE_NAME "-ThreadedRenderer";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          EnableThreadedRenderer = !strcmp(var.value, "True") ? 1 : 0;
+       }
+
        var.key = CORE_NAME "-BilinearMode";
        var.value = NULL;
        if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
@@ -1232,7 +1270,7 @@ static void format_saved_memory(void)
     format_mempak(saved_memory.mempack + 3 * MEMPAK_SIZE);
 }
 
-static void context_reset(void)
+void context_reset(void)
 {
     static bool first_init = true;
 
@@ -1288,12 +1326,22 @@ bool retro_load_game(const struct retro_game_info *game)
         }
     }
 
+    // Init savestate job var
+    retro_savestate_complete = true;
+
     glsm_ctx_params_t params = {0};
     format_saved_memory();
 
     update_variables(true);
     initial_boot = false;
 
+    if(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer)
+    {
+       initializing = true;
+       retro_thread = co_active();
+       game_thread = co_create(65536 * sizeof(void*) * 16, gln64_thr_gl_invoke_command_loop);
+    }
+
     init_audio_libretro(audio_buffer_size);
 
     params.context_reset         = context_reset;
@@ -1335,7 +1383,26 @@ bool retro_load_game(const struct retro_game_info *game)
 void retro_unload_game(void)
 {
     CoreDoCommand(M64CMD_ROM_CLOSE, 0, NULL);
+
+    if(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer)
+    {
+       CoreDoCommand(M64CMD_STOP, 0, NULL);
+
+       // Run one more frame to unlock it
+       glsm_ctl(GLSM_CTL_STATE_BIND, NULL);
+       while(!threaded_gl_safe_shutdown)
+       {
+          co_switch(game_thread);
+       }
+       glsm_ctl(GLSM_CTL_STATE_UNBIND, NULL);
+    
+       pthread_join(emuThread, NULL);
+    }
+
     emu_initialized = false;
+
+    // Reset savestate job var
+    retro_savestate_complete = false;
 }
 
 void retro_run (void)
@@ -1350,6 +1417,15 @@ void retro_run (void)
 
     if(current_rdp_type == RDP_PLUGIN_GLIDEN64)
     {
+       if(EnableThreadedRenderer)
+       {
+          if(!emuThreadRunning)
+          {
+             pthread_create(&emuThread, NULL, &EmuThreadFunction, NULL);
+             emuThreadRunning = true;
+          }
+       }
+       
        glsm_ctl(GLSM_CTL_STATE_BIND, NULL);
     }
 
@@ -1378,7 +1454,12 @@ void retro_run (void)
         // screen_pitch will be 0 for GLN
         video_cb(NULL, retro_screen_width, retro_screen_height, screen_pitch);
     }
-        
+
+    // Poll needs to happen here on threaded gl
+    if(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer)
+    {
+       poll_cb();
+    }
 }
 
 void retro_reset (void)
@@ -1418,11 +1499,17 @@ bool retro_serialize(void *data, size_t size)
     if (initializing)
         return false;
 
-    int success = savestates_save_m64p(&g_dev, data);
-    if (success)
-        return true;
+    retro_savestate_complete = false;
+    retro_savestate_result = 0;
 
-    return false;
+    savestates_set_job(savestates_job_save, savestates_type_m64p, data);
+
+    while(!retro_savestate_complete)
+    {
+        retro_run();
+    }
+    
+    return !!retro_savestate_result;
 }
 
 bool retro_unserialize(const void * data, size_t size)
@@ -1430,11 +1517,17 @@ bool retro_unserialize(const void * data, size_t size)
     if (initializing)
         return false;
 
-    int success = savestates_load_m64p(&g_dev, data);
-    if (success)
-        return true;
+    retro_savestate_complete = false;
+    retro_savestate_result = 0;
+    
+    savestates_set_job(savestates_job_load, savestates_type_m64p, data);
 
-    return false;
+    while(!retro_savestate_complete)
+    {
+        retro_run();
+    }
+    
+    return true;
 }
 
 //Needed to be able to detach controllers for Lylat Wars multiplayer
@@ -1515,7 +1608,10 @@ void retro_cheat_set(unsigned index, bool enabled, const char* codeLine)
 
 void retro_return(void)
 {
-    co_switch(retro_thread);
+    if(!(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer))
+    {
+       co_switch(retro_thread);
+    }
 }
 
 uint32_t get_retro_screen_width()
diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
index 9dfd3345..bef56c7a 100644
--- a/libretro/libretro_core_options.h
+++ b/libretro/libretro_core_options.h
@@ -135,6 +135,17 @@ struct retro_core_option_definition option_defs_us[] = {
         },
         "4:3"
     },
+    {
+        CORE_NAME "-ThreadedRenderer",
+        "Threaded Renderer",
+        "(GLN64) Use the Threaded Renderer, improves performance but increases input lag.",
+        {
+            {"True", "Enabled"},
+            {"False", "Disabled"},
+            {NULL, NULL},
+        },
+        "False"
+    },
     {
         CORE_NAME "-BilinearMode",
         "Bilinear filtering mode",
diff --git a/mupen64plus-core/src/device/r4300/interrupt.c b/mupen64plus-core/src/device/r4300/interrupt.c
index b99aa534..d8799dcc 100644
--- a/mupen64plus-core/src/device/r4300/interrupt.c
+++ b/mupen64plus-core/src/device/r4300/interrupt.c
@@ -552,11 +552,11 @@ void gen_interrupt(struct r4300_core* r4300)
 
     if (!r4300->cp0.interrupt_unsafe_state)
     {
-        /*if (savestates_get_job() == savestates_job_load)
+        if (savestates_get_job() == savestates_job_load)
         {
             savestates_load();
             return;
-        }*/
+        }
 
         if (r4300->reset_hard_job)
         {
@@ -647,11 +647,11 @@ void gen_interrupt(struct r4300_core* r4300)
 
     if (!r4300->cp0.interrupt_unsafe_state)
     {
-        /*if (savestates_get_job() == savestates_job_save)
+        if (savestates_get_job() == savestates_job_save)
         {
             savestates_save();
             return;
-        }*/
+        }
     }
 }
 
diff --git a/mupen64plus-core/src/main/main.c b/mupen64plus-core/src/main/main.c
index 55ae4838..d02ddfcc 100644
--- a/mupen64plus-core/src/main/main.c
+++ b/mupen64plus-core/src/main/main.c
@@ -84,9 +84,6 @@
 #include <file/file_path.h>
 #include <libretro_memory.h>
 #include <mupen64plus-next_common.h>
-extern retro_environment_t environ_cb;
-extern char* retro_dd_path_img;
-extern char* retro_dd_path_rom;
 #endif // __LIBRETRO__
 
 #ifdef DBG
@@ -202,7 +199,10 @@ static void main_check_inputs(void)
 #ifdef WITH_LIRC
     lircCheckInput();
 #endif
-    poll_cb();
+    if(!(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer))
+    {
+        poll_cb();
+    }
 }
 
 /*********************************************************************************************************
@@ -1327,7 +1327,12 @@ m64p_error main_run(void)
      * Jump back to frontend for deinit
      */
     extern cothread_t retro_thread;
-    co_switch(retro_thread);
+
+    // For GLN64 Threaded GL we just sanely return, exit sync is handled elsewhere
+    if(!(current_rdp_type == RDP_PLUGIN_GLIDEN64 && EnableThreadedRenderer))
+    {
+        co_switch(retro_thread);
+    }
 
     return M64ERR_SUCCESS;
 
diff --git a/mupen64plus-core/src/main/savestates.c b/mupen64plus-core/src/main/savestates.c
index 9d43176d..d281b24f 100644
--- a/mupen64plus-core/src/main/savestates.c
+++ b/mupen64plus-core/src/main/savestates.c
@@ -25,6 +25,8 @@
 #ifdef USE_SDL
 #include <SDL.h>
 #include <SDL_thread.h>
+#else
+#include <pthread.h>
 #endif
 #include <stddef.h>
 #include <stdint.h>
@@ -65,6 +67,9 @@ static const unsigned char pj64_magic[4] = { 0xC8, 0xA6, 0xD8, 0x23 };
 
 static savestates_job job = savestates_job_nothing;
 static savestates_type type = savestates_type_unknown;
+
+// Libretro will re-use fname for the ptr
+// This avoids ifdef shenanigans
 static char *fname = NULL;
 
 static unsigned int slot = 0;
@@ -72,6 +77,8 @@ static int autoinc_save_slot = 0;
 
 #ifdef USE_SDL
 static SDL_mutex *savestates_lock;
+#else
+static pthread_mutex_t savestates_lock;
 #endif
 
 struct savestate_work {
@@ -158,16 +165,23 @@ savestates_job savestates_get_job(void)
 
 void savestates_set_job(savestates_job j, savestates_type t, const char *fn)
 {
+#ifndef __LIBRETRO__
     if (fname != NULL)
     {
         free(fname);
         fname = NULL;
     }
-
+#endif // __LIBRETRO__
     job = j;
     type = t;
+#ifndef __LIBRETRO__
     if (fn != NULL)
         fname = strdup(fn);
+#else
+    pthread_mutex_lock(&savestates_lock);
+    fname = (char*)fn;
+    pthread_mutex_unlock(&savestates_lock);
+#endif // __LIBRETRO__
 }
 
 static void savestates_clear_job(void)
@@ -212,6 +226,8 @@ int savestates_load_m64p(struct device* dev, const void *data)
 
 #ifdef USE_SDL
     SDL_LockMutex(savestates_lock);
+#else
+    pthread_mutex_lock(&savestates_lock);
 #endif
 
 #ifndef __LIBRETRO__
@@ -271,6 +287,8 @@ int savestates_load_m64p(struct device* dev, const void *data)
 #endif
 #ifdef USE_SDL
         SDL_UnlockMutex(savestates_lock);
+#else
+        pthread_mutex_unlock(&savestates_lock);
 #endif
         return 0;
     }
@@ -283,6 +301,8 @@ int savestates_load_m64p(struct device* dev, const void *data)
 #endif
 #ifdef USE_SDL
         SDL_UnlockMutex(savestates_lock);
+#else
+        pthread_mutex_unlock(&savestates_lock);
 #endif
         return 0;
     }
@@ -299,6 +319,8 @@ int savestates_load_m64p(struct device* dev, const void *data)
 #endif
 #ifdef USE_SDL
         SDL_UnlockMutex(savestates_lock);
+#else
+        pthread_mutex_unlock(&savestates_lock);
 #endif
         return 0;
     }
@@ -371,6 +393,8 @@ int savestates_load_m64p(struct device* dev, const void *data)
 #endif
 #ifdef USE_SDL
     SDL_UnlockMutex(savestates_lock);
+#else
+    pthread_mutex_unlock(&savestates_lock);
 #endif
 
     // Parse savestate
@@ -1435,9 +1459,12 @@ static savestates_type savestates_detect_type(char *filepath)
 
 int savestates_load(void)
 {
+    int ret = 0;
+    struct device* dev = &g_dev;
+
+#ifndef __LIBRETRO__
     FILE *fPtr = NULL;
     char *filepath = NULL;
-    int ret = 0;
 
     if (fname == NULL) // For slots, autodetect the savestate type
     {
@@ -1492,8 +1519,6 @@ int savestates_load(void)
 
     if (filepath != NULL)
     {
-        struct device* dev = &g_dev;
-
         switch (type)
         {
             case savestates_type_m64p: ret = savestates_load_m64p(dev, filepath); break;
@@ -1504,6 +1529,15 @@ int savestates_load(void)
         free(filepath);
         filepath = NULL;
     }
+#else
+    if(fname)
+    {
+        ret = savestates_load_m64p(dev, fname);
+        fname = NULL;
+    } else {
+        ret = 0;
+    }
+#endif // __LIBRETRO__
 
     // deliver callback to indicate completion of state loading operation
     StateChanged(M64CORE_STATE_LOADCOMPLETE, ret);
@@ -1519,6 +1553,8 @@ static void savestates_save_m64p_work(struct work_struct *work)
 
 #ifdef USE_SDL
     SDL_LockMutex(savestates_lock);
+#else
+    pthread_mutex_lock(&savestates_lock);
 #endif
 
 #ifndef __LIBRETRO__
@@ -1556,6 +1592,8 @@ static void savestates_save_m64p_work(struct work_struct *work)
 
 #ifdef USE_SDL
     SDL_UnlockMutex(savestates_lock);
+#else
+    pthread_mutex_unlock(&savestates_lock);
 #endif
 }
 
@@ -2192,10 +2230,12 @@ static int savestates_save_pj64_unc(const struct device* dev, char *filepath)
 
 int savestates_save(void)
 {
-    char *filepath;
     int ret = 0;
     const struct device* dev = &g_dev;
 
+#ifndef __LIBRETRO__
+    char *filepath;
+
     /* Can only save PJ64 savestates on VI / COMPARE interrupt.
        Otherwise try again in a little while. */
     if ((type == savestates_type_pj64_zip ||
@@ -2220,11 +2260,21 @@ int savestates_save(void)
         }
         free(filepath);
     }
+#else
+    if(fname)
+    {
+        ret = savestates_save_m64p(dev, fname);
+        fname = NULL;
+    } else {
+        ret = 0;
+    }
+#endif // __LIBRETRO__
 
     // deliver callback to indicate completion of state saving operation
     StateChanged(M64CORE_STATE_SAVECOMPLETE, ret);
 
     savestates_clear_job();
+
     return ret;
 }
 

From b05f0ea7400c935a1d233890b43764108a318f76 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Wed, 23 Oct 2019 23:28:11 +0200
Subject: [PATCH 16/28] [NX] Test JIT Changes - Lowers platform requirements

---
 .../device/r4300/new_dynarec/new_dynarec.c    |  7 ++++--
 switch/mman.h                                 | 24 ++++++-------------
 2 files changed, 12 insertions(+), 19 deletions(-)

diff --git a/mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c b/mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c
index c383a339..79a54a9e 100644
--- a/mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c
+++ b/mupen64plus-core/src/device/r4300/new_dynarec/new_dynarec.c
@@ -7520,6 +7520,9 @@ static void disassemble_inst(int i)
     }
 }
 
+#ifdef HAVE_LIBNX
+ALIGN(4096, char jit_memory[33554432]) __attribute__((section(".text")));
+#endif
 void new_dynarec_init(void)
 {
   DebugMessage(M64MSG_INFO, "Init new dynarec");
@@ -7544,8 +7547,8 @@ void new_dynarec_init(void)
 
 #if CACHE_ADDR==DOUBLE_CACHE_ADDR
 #ifdef HAVE_LIBNX
-  base_addr = mmap((u_char *)g_dev.r4300.extra_memory, 1<<TARGET_SIZE_2, 0,0,0,0);
-  base_addr_rx = jit_rx_addr;
+  base_addr = mmap((u_char *)jit_memory, 1<<TARGET_SIZE_2, 0,0,0,0);
+  base_addr_rx = (void*)jit_memory;
 #else
   #include <unistd.h>
   #include <sys/types.h>
diff --git a/switch/mman.h b/switch/mman.h
index 5ffc297d..6a5166e0 100644
--- a/switch/mman.h
+++ b/switch/mman.h
@@ -21,26 +21,18 @@ extern "C"
 #define MAP_ANONYMOUS 0x20
 
 #define MAP_FAILED ((void *)-1)
-
-Jit dynarec_jit;
-void *jit_rx_addr = 0;
-void *jit_rw_addr = 0;
-size_t jit_len = 0;
+void* ptr_rw = NULL;
 
 static inline void *mmap(void *addr, size_t len, int prot, int flags, int fd, off_t offset)
 {
     (void)fd;
     (void)offset;
 
-    if (R_SUCCEEDED(jitCreate(&dynarec_jit, len)))
+    size_t size = (len + 0xFFF) &~ 0xFFF;
+	ptr_rw = virtmemReserve(size);
+    if (R_SUCCEEDED(svcMapProcessMemory(ptr_rw, envGetOwnProcessHandle(), (u64)addr, size)))
     {
-        jit_len = dynarec_jit.size;
-        jit_rw_addr = jitGetRwAddr(&dynarec_jit);
-        jit_rx_addr = jitGetRxAddr(&dynarec_jit);
-        
-        printf("[NXJIT]: Jit Initialized: RX %p, RW %p\n", jit_rx_addr, jit_rw_addr);
-
-        return jit_rw_addr;
+        return ptr_rw;
     }
     else
     {
@@ -56,10 +48,8 @@ static inline int mprotect(void *addr, size_t len, int prot)
 
 static inline int munmap(void *addr, size_t len)
 {
-    jitClose(&dynarec_jit);
-    jit_rx_addr = jit_rw_addr = NULL;
-    jit_len = 0;
-
+    size_t size = (len + 0xFFF) &~ 0xFFF;
+    svcUnmapProcessMemory(ptr_rw, envGetOwnProcessHandle(), (u64)addr, size);
     printf("[NXJIT]: Jit closed\n");
     
     return 0;

From 716f02a427dc782665b2b40bb0adf1ca679b3651 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Tue, 25 Feb 2020 13:56:51 +0100
Subject: [PATCH 17/28] [GLN64] Allow higher Count per Op

---
 libretro/libretro_core_options.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
index bef56c7a..6238544d 100644
--- a/libretro/libretro_core_options.h
+++ b/libretro/libretro_core_options.h
@@ -1102,6 +1102,8 @@ struct retro_core_option_definition option_defs_us[] = {
             {"1", NULL},
             {"2", NULL},
             {"3", NULL},
+            {"4", NULL},
+            {"5", NULL},
             {NULL, NULL},
         },
         "0"

From d8d30ae2836f8188c902e4061742f3fa0dc4d998 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 18:10:58 +0200
Subject: [PATCH 18/28] [Core] Remove CountPerOp=1 for Quake 2 and Goldfinger -
 This cripples perf on Switch and Android with GLN64 - No regression has been
 found so far

---
 mupen64plus-core/data/mupen64plus.ini | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/mupen64plus-core/data/mupen64plus.ini b/mupen64plus-core/data/mupen64plus.ini
index e88f19ab..96bab243 100644
--- a/mupen64plus-core/data/mupen64plus.ini
+++ b/mupen64plus-core/data/mupen64plus.ini
@@ -11,7 +11,6 @@ CRC=B2242748 FFBD61DA
 Status=1
 Rumble=Yes
 Players=4
-CountPerOp=1
 
 [34AB1DEA3111A233A8B5C5679DE22E83]
 GoodName=007 - The World is Not Enough (E) (M3) [!]
@@ -12697,7 +12696,6 @@ Players=4
 SaveType=None
 Mempak=Yes
 Rumble=Yes
-CountPerOp=1
 
 [55A789C553827114306E29D71E26E5DC]
 GoodName=Quake II (E) [h1C]
@@ -12711,7 +12709,6 @@ Players=4
 SaveType=None
 Mempak=Yes
 Rumble=Yes
-CountPerOp=1
 
 [920FAACCE1F8A80022433ACFD5CD2BC3]
 GoodName=Quake II (U) [f1] (PAL)

From 8ba277c7b861a31ce87e99dbbe53f976dd718841 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 18:11:21 +0200
Subject: [PATCH 19/28] [GLN64] Only force N64DepthCompare preset if enabled
 See comment. TODO.

---
 custom/GLideN64/mupenplus/Config_mupenplus.cpp | 12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/custom/GLideN64/mupenplus/Config_mupenplus.cpp b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
index 17230999..d727dade 100644
--- a/custom/GLideN64/mupenplus/Config_mupenplus.cpp
+++ b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
@@ -93,7 +93,17 @@ void LoadCustomSettings(bool internal)
 					else if (!strcmp(l.name, "frameBufferEmulation\\fbInfoDisabled"))
 						config.frameBufferEmulation.fbInfoDisabled = atoi(l.value);
 					else if (!strcmp(l.name, "frameBufferEmulation\\N64DepthCompare"))
-						config.frameBufferEmulation.N64DepthCompare = atoi(l.value);
+					{
+						// We only allow N64DepthCompare if its actually on in the settings
+						// I know this is a bit counter productive
+						// Maybe needs a "Auto" mode in the future, since it soon has a "fast" mode too.
+						// Currently its often not supported anyway or causes crippling issues otherwise
+						if(EnableN64DepthCompare)
+						{
+							// Set to config val, ignoring the actual pre-set, see above.
+							config.frameBufferEmulation.N64DepthCompare = atoi(l.value);
+						}
+					}
 					else if (!strcmp(l.name, "frameBufferEmulation\\bufferSwapMode"))
 						config.frameBufferEmulation.bufferSwapMode = atoi(l.value);
 					else if (!strcmp(l.name, "texture\\bilinearMode"))

From 04479b5e948e33e066db3e1c357cc6da42ce8787 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Tue, 25 Feb 2020 14:22:06 +0100
Subject: [PATCH 20/28] Version increment

---
 libretro/libretro.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/libretro/libretro.c b/libretro/libretro.c
index a45e589e..4110ff43 100644
--- a/libretro/libretro.c
+++ b/libretro/libretro.c
@@ -411,7 +411,7 @@ void retro_get_system_info(struct retro_system_info *info)
 #ifndef GIT_VERSION
 #define GIT_VERSION " git"
 #endif
-    info->library_version = "2.0.5" GIT_VERSION;
+    info->library_version = "2.1" GIT_VERSION;
     info->valid_extensions = "n64|v64|z64|bin|u1";
     info->need_fullpath = false;
     info->block_extract = false;

From 40c7196a654cae163cef8aafbb67fbf136237505 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 11 May 2020 21:17:53 +0200
Subject: [PATCH 21/28] Remove Bone displacement fix after testing for DK64,
 update INI headers

---
 custom/mupen64plus-core/main/mupen64plus.ini.h | 12 ------------
 mupen64plus-core/data/mupen64plus.ini          |  9 ---------
 2 files changed, 21 deletions(-)

diff --git a/custom/mupen64plus-core/main/mupen64plus.ini.h b/custom/mupen64plus-core/main/mupen64plus.ini.h
index a29d5c4a..6b7a97aa 100644
--- a/custom/mupen64plus-core/main/mupen64plus.ini.h
+++ b/custom/mupen64plus-core/main/mupen64plus.ini.h
@@ -15,7 +15,6 @@ char inifile[] =
 "Status=1\n"
 "Rumble=Yes\n"
 "Players=4\n"
-"CountPerOp=1\n"
 "\n"
 "[34AB1DEA3111A233A8B5C5679DE22E83]\n"
 "GoodName=007 - The World is Not Enough (E) (M3) [!]\n"
@@ -4022,9 +4021,6 @@ char inifile[] =
 "Players=4\n"
 "Rumble=Yes\n"
 "CountPerOp=1\n"
-"; Bone displacement fix\n"
-"; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise\n"
-"Cheat0=806128E2 0000\n"
 "\n"
 "[428067DC7DB42DFC977A775F0A6E55B1]\n"
 "GoodName=Donkey Kong 64 (E) [b1]\n"
@@ -4048,9 +4044,6 @@ char inifile[] =
 "Players=4\n"
 "CountPerOp=1\n"
 "Rumble=Yes\n"
-"; Bone displacement fix\n"
-"; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise\n"
-"Cheat0=806128E2 0000\n"
 "\n"
 "[98A5836E3A5DA7BD0B5819E7498ACEA2]\n"
 "GoodName=Donkey Kong 64 (U) (Kiosk Demo) [!]\n"
@@ -4081,9 +4074,6 @@ char inifile[] =
 "Players=4\n"
 "CountPerOp=1\n"
 "Rumble=Yes\n"
-"; Bone displacement fix\n"
-"; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise\n"
-"Cheat0=806128E2 0000\n"
 "\n"
 "[6B4772AA1743FEAC1919618B3FC6B3E1]\n"
 "GoodName=Donkey Kong 64 (U) [b1]\n"
@@ -12701,7 +12691,6 @@ char inifile[] =
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Rumble=Yes\n"
-"CountPerOp=1\n"
 "\n"
 "[55A789C553827114306E29D71E26E5DC]\n"
 "GoodName=Quake II (E) [h1C]\n"
@@ -12715,7 +12704,6 @@ char inifile[] =
 "SaveType=None\n"
 "Mempak=Yes\n"
 "Rumble=Yes\n"
-"CountPerOp=1\n"
 "\n"
 "[920FAACCE1F8A80022433ACFD5CD2BC3]\n"
 "GoodName=Quake II (U) [f1] (PAL)\n"
diff --git a/mupen64plus-core/data/mupen64plus.ini b/mupen64plus-core/data/mupen64plus.ini
index 96bab243..34749fc8 100644
--- a/mupen64plus-core/data/mupen64plus.ini
+++ b/mupen64plus-core/data/mupen64plus.ini
@@ -4017,9 +4017,6 @@ SaveType=Eeprom 16KB
 Players=4
 Rumble=Yes
 CountPerOp=1
-; Bone displacement fix
-; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise
-Cheat0=806128E2 0000
 
 [428067DC7DB42DFC977A775F0A6E55B1]
 GoodName=Donkey Kong 64 (E) [b1]
@@ -4043,9 +4040,6 @@ SaveType=Eeprom 16KB
 Players=4
 CountPerOp=1
 Rumble=Yes
-; Bone displacement fix
-; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise
-Cheat0=806128E2 0000
 
 [98A5836E3A5DA7BD0B5819E7498ACEA2]
 GoodName=Donkey Kong 64 (U) (Kiosk Demo) [!]
@@ -4076,9 +4070,6 @@ SaveType=Eeprom 16KB
 Players=4
 CountPerOp=1
 Rumble=Yes
-; Bone displacement fix
-; Doesnt seem required anymore but causes instability on AArch64 dynarec otherwise
-Cheat0=806128E2 0000
 
 [6B4772AA1743FEAC1919618B3FC6B3E1]
 GoodName=Donkey Kong 64 (U) [b1]

From b8c86dd58bbfc2f554640980e85d4d5b14501f53 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Wed, 13 May 2020 10:58:13 +0200
Subject: [PATCH 22/28] git subrepo push GLideN64

subrepo:
  subdir:   "GLideN64"
  merged:   "bea0e2fa"
upstream:
  origin:   "git@github.com:libretro/GLideN64.git"
  branch:   "rebase"
  commit:   "bea0e2fa"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 GLideN64/.gitrepo | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/GLideN64/.gitrepo b/GLideN64/.gitrepo
index 0a84ee67..fc5306b7 100644
--- a/GLideN64/.gitrepo
+++ b/GLideN64/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = git@github.com:libretro/GLideN64.git
 	branch = rebase
-	commit = 494227c4df80df4a3ba852320dbd15624350fa32
-	parent = 3e29f5cda15e8975e32918d6048c2fe55dfe8381
+	commit = bea0e2faece462a9bba1e451a61e1b2fff0425d0
+	parent = 40c7196a654cae163cef8aafbb67fbf136237505
 	method = rebase
 	cmdver = 0.4.0

From 461a97b4c1ab9b38f7adb7da71e1a445254f6c99 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Wed, 13 May 2020 10:59:05 +0200
Subject: [PATCH 23/28] git subrepo push mupen64plus-core

subrepo:
  subdir:   "mupen64plus-core"
  merged:   "8e9a16d5"
upstream:
  origin:   "https://github.com/libretro/mupen64plus-core.git"
  branch:   "rebase"
  commit:   "8e9a16d5"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 mupen64plus-core/.gitrepo | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/mupen64plus-core/.gitrepo b/mupen64plus-core/.gitrepo
index e4ba1c29..026cbce5 100644
--- a/mupen64plus-core/.gitrepo
+++ b/mupen64plus-core/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = https://github.com/libretro/mupen64plus-core.git
 	branch = rebase
-	commit = 5f6b7b8ee0130cbca152166eae1da9455a276d4a
-	parent = 905a026d587800dae7a8ec4e4a2aa679457f17cc
+	commit = 8e9a16d587e8b5ee756e651365eb379c6675315a
+	parent = b8c86dd58bbfc2f554640980e85d4d5b14501f53
 	method = rebase
 	cmdver = 0.4.0

From 947849ae93a6d1ad955a3c0e6946a56102bc0c8a Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Wed, 13 May 2020 11:01:44 +0200
Subject: [PATCH 24/28] git subrepo clone --force --branch=rebase
 git@github.com:libretro/GLideN64.git GLideN64

subrepo:
  subdir:   "GLideN64"
  merged:   "c36df3de"
upstream:
  origin:   "git@github.com:libretro/GLideN64.git"
  branch:   "rebase"
  commit:   "c36df3de"
git-subrepo:
  version:  "0.4.0"
  origin:   "???"
  commit:   "???"
---
 GLideN64/.gitrepo                             |  4 +--
 GLideN64/src/GBI.cpp                          |  2 +-
 .../GLSL/glsl_CombinerProgramBuilder.cpp      | 27 ++++++++++++++-----
 .../glsl_CombinerProgramUniformFactory.cpp    | 17 ++++++++++--
 GLideN64/src/gSP.cpp                          | 20 +++++++-------
 5 files changed, 48 insertions(+), 22 deletions(-)

diff --git a/GLideN64/.gitrepo b/GLideN64/.gitrepo
index fc5306b7..3d1aa14e 100644
--- a/GLideN64/.gitrepo
+++ b/GLideN64/.gitrepo
@@ -6,7 +6,7 @@
 [subrepo]
 	remote = git@github.com:libretro/GLideN64.git
 	branch = rebase
-	commit = bea0e2faece462a9bba1e451a61e1b2fff0425d0
-	parent = 40c7196a654cae163cef8aafbb67fbf136237505
+	commit = c36df3def09407bccc360bdebbe6173b29686a12
+	parent = 461a97b4c1ab9b38f7adb7da71e1a445254f6c99
 	method = rebase
 	cmdver = 0.4.0
diff --git a/GLideN64/src/GBI.cpp b/GLideN64/src/GBI.cpp
index 4400b580..0109a28f 100644
--- a/GLideN64/src/GBI.cpp
+++ b/GLideN64/src/GBI.cpp
@@ -63,7 +63,7 @@ std::vector<SpecialMicrocodeInfo> specialMicrocodes =
 	{ Turbo3D,		false,	true,	false,	0x2bdcfc8a }, // Dark Rift, Turbo3D
 	{ F3DSETA,		false,	true,	true,	0x2edee7be }, // RSP SW Version: 2.0D, 04-01-96
 	{ F3DGOLDEN,	true,	true,	false,	0x302bca09 }, // RSP SW Version: 2.0G, 09-30-96 GoldenEye
-	{ F3D,			false,	true,	false,	0x4AED6B3B }, // Vivid Dolls [ALECK64]
+	{ F3D,			false,	false,	false,	0x4AED6B3B }, // Vivid Dolls [ALECK64]
 	{ F3D,			true,	true,	true,	0x54c558ba }, // RSP SW Version: 2.0D, 04-01-96 Pilot Wings, Blast Corps
 	{ ZSortBOSS,	false,	false,	false,	0x553538cc }, // World Driver Championship
 	{ F3D,			false,	false,	true,	0x55be9bad }, // RSP SW Version: 2.0D, 04-01-96, Mischief Makers, Mortal Combat Trilogy, J.League Live
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
index a1fea7aa..150fd369 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramBuilder.cpp
@@ -1082,9 +1082,9 @@ class ShaderFragmentHeaderTextureEngine : public ShaderPart
 		m_part =
 			"highp vec2 clampWrapMirror(in highp vec2 vTexCoord,	\n"
 			"	in highp vec2 vWrap, in highp vec2 vClamp,			\n"
-			"	in lowp vec2 vClampEn, in lowp vec2 vMirrorEn );		\n"
-			 "lowp vec2[5] textureEngine0(in highp vec2 texCoord); \n"
-			 "lowp vec2[5] textureEngine1(in highp vec2 texCoord); \n"
+			"	in lowp vec2 vClampEn, in lowp vec2 vMirrorEn );	\n"
+			"highp vec2[5] textureEngine0(in highp vec2 texCoord);	\n"
+			"highp vec2[5] textureEngine1(in highp vec2 texCoord);	\n"
 			;
 	}
 };
@@ -2431,29 +2431,42 @@ class ShaderTextureEngine : public ShaderPart
 			"	return texCoord;															\n"
 			"}																				\n"
 
+			"highp vec2 wrap2D(in highp vec2 tc, in highp float width) \n"
+			"{ \n"
+			"  highp float div = floor(tc.s/width);	\n"
+			"  return tc + vec2(-div*width, div);	\n"
+			"} \n"
+
+			"uniform mediump vec2 uTexSize0;		\n"
 			"highp vec2[5] textureEngine0(in highp vec2 texCoord) \n"
 			"{  \n"
 			"  highp vec2[5] tcData; \n" // {tc00, tc01, tc10, tc11, frPart}
 			"  mediump vec2 intPart = floor(texCoord); \n"
-			"  tcData[0] = clampWrapMirror(intPart, uTexWrap0, uTexClamp0, uTexWrapEn0, uTexClampEn0, uTexMirrorEn0); \n"
-			"  tcData[3] = clampWrapMirror(intPart + vec2(1.0,1.0), uTexWrap0, uTexClamp0, uTexWrapEn0, uTexClampEn0, uTexMirrorEn0); \n"
+			"  highp vec2 tc00 = clampWrapMirror(intPart, uTexWrap0, uTexClamp0, uTexWrapEn0, uTexClampEn0, uTexMirrorEn0); \n"
+			"  highp vec2 tc11 = clampWrapMirror(intPart + vec2(1.0,1.0), uTexWrap0, uTexClamp0, uTexWrapEn0, uTexClampEn0, uTexMirrorEn0); \n"
+			"  tcData[0] = wrap2D(tc00, uTexSize0.s); \n"
+			"  tcData[3] = wrap2D(tc11, uTexSize0.s); \n"
 			"  tcData[1] = vec2(tcData[0].s, tcData[3].t); \n"
 			"  tcData[2] = vec2(tcData[3].s, tcData[0].t); \n"
 			"  tcData[4] = texCoord - intPart; \n"
 			"  return tcData;"
 			"}  \n"
 
+			"uniform mediump vec2 uTexSize1;		\n"
 			"highp vec2[5] textureEngine1(in highp vec2 texCoord) \n"
 			"{  \n"
 			"  highp vec2[5] tcData; \n" // {tc00, tc01, tc10, tc11, frPart}
 			"  mediump vec2 intPart = floor(texCoord); \n"
-			"  tcData[0] = clampWrapMirror(intPart, uTexWrap1, uTexClamp1, uTexWrapEn1, uTexClampEn1, uTexMirrorEn1); \n"
-			"  tcData[3] = clampWrapMirror(intPart + vec2(1.0,1.0), uTexWrap1, uTexClamp1, uTexWrapEn1, uTexClampEn1, uTexMirrorEn1); \n"
+			"  highp vec2 tc00 = clampWrapMirror(intPart, uTexWrap1, uTexClamp1, uTexWrapEn1, uTexClampEn1, uTexMirrorEn1); \n"
+			"  highp vec2 tc11 = clampWrapMirror(intPart + vec2(1.0,1.0), uTexWrap1, uTexClamp1, uTexWrapEn1, uTexClampEn1, uTexMirrorEn1); \n"
+			"  tcData[0] = wrap2D(tc00, uTexSize1.s); \n"
+			"  tcData[3] = wrap2D(tc11, uTexSize1.s); \n"
 			"  tcData[1] = vec2(tcData[0].s, tcData[3].t); \n"
 			"  tcData[2] = vec2(tcData[3].s, tcData[0].t); \n"
 			"  tcData[4] = texCoord - intPart; \n"
 			"  return tcData;"
 			"}  \n"
+
 			;
 	}
 };
diff --git a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
index 42207d70..7ab58813 100644
--- a/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
+++ b/GLideN64/src/Graphics/OpenGLContext/GLSL/glsl_CombinerProgramUniformFactory.cpp
@@ -876,6 +876,8 @@ class UTextureParams : public UniformGroup
 		LocateUniform(uCacheOffset[0]);
 		LocateUniform(uCacheOffset[1]);
 		LocateUniform(uTexScale);
+		LocateUniform(uTexSize[0]);
+		LocateUniform(uTexSize[1]);
 		LocateUniform(uCacheFrameBuffer);
 	}
 
@@ -932,6 +934,7 @@ class UTextureParams : public UniformGroup
 	fv2Uniform uCacheScale[2];
 	fv2Uniform uCacheOffset[2];
 	fv2Uniform uTexScale;
+	fv2Uniform uTexSize[2];
 	iv2Uniform uCacheFrameBuffer;
 };
 
@@ -952,6 +955,8 @@ class UTextureEngine : public UniformGroup
 		LocateUniform(uTexClampEn1);
 		LocateUniform(uTexMirrorEn0);
 		LocateUniform(uTexMirrorEn1);
+		LocateUniform(uTexSize0);
+		LocateUniform(uTexSize1);
 	}
 
 	void update(bool _force) override
@@ -961,6 +966,7 @@ class UTextureEngine : public UniformGroup
 		std::array<f32, 2> aTexWrapEn[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
 		std::array<f32, 2> aTexClampEn[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
 		std::array<f32, 2> aTexMirrorEn[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
+		std::array<f32, 2> aTexSize[2] = { { 0.0f,0.0f },{ 0.0f,0.0f } };
 
 		TextureCache & cache = textureCache();
 		const bool replaceTex1ByTex0 = needReplaceTex1ByTex0();
@@ -974,6 +980,9 @@ class UTextureEngine : public UniformGroup
 			if (pTile == nullptr || pTexture == nullptr)
 				continue;
 			
+			aTexSize[t][0] = pTexture->width * pTexture->hdRatioS;
+			aTexSize[t][1] = pTexture->height * pTexture->hdRatioT;
+
 			/* Not sure if special treatment of framebuffer textures is correct */
 			if (pTexture->frameBufferTexture != CachedTexture::fbNone ||
 				pTile->textureMode != TEXTUREMODE_NORMAL ||
@@ -996,8 +1005,8 @@ class UTextureEngine : public UniformGroup
 				aTexClamp[t][1] = (pTile->flrt - pTile->fult + 1.0f) * pTexture->hdRatioT - 1.0f;
 				aTexWrapEn[t][0] = f32(pTile->masks == 0 ? 0 : 1);
 				aTexWrapEn[t][1] = f32(pTile->maskt == 0 ? 0 : 1);
-				aTexClampEn[t][0] = f32(pTile->masks == 0 ? 1 : pTile->clamps);
-				aTexClampEn[t][1] = f32(pTile->maskt == 0 ? 1 : pTile->clampt);
+				aTexClampEn[t][0] = f32(gDP.otherMode.cycleType == G_CYC_COPY ? 0 : (pTile->masks == 0 ? 1 : pTile->clamps));
+				aTexClampEn[t][1] = f32(gDP.otherMode.cycleType == G_CYC_COPY ? 0 : (pTile->maskt == 0 ? 1 : pTile->clampt));
 				aTexMirrorEn[t][0] = f32(pTile->masks == 0 ? 0 : pTile->mirrors);
 				aTexMirrorEn[t][1] = f32(pTile->maskt == 0 ? 0 : pTile->mirrort);
 			}
@@ -1013,6 +1022,8 @@ class UTextureEngine : public UniformGroup
 		uTexClampEn1.set(aTexClampEn[1][0], aTexClampEn[1][1], _force);
 		uTexMirrorEn0.set(aTexMirrorEn[0][0], aTexMirrorEn[0][1], _force);
 		uTexMirrorEn1.set(aTexMirrorEn[1][0], aTexMirrorEn[1][1], _force);
+		uTexSize0.set(aTexSize[0][0], aTexSize[0][1], _force);
+		uTexSize1.set(aTexSize[1][0], aTexSize[1][1], _force);
 				
 	}
 
@@ -1028,6 +1039,8 @@ class UTextureEngine : public UniformGroup
 	fv2Uniform uTexClampEn1;
 	fv2Uniform uTexMirrorEn0;
 	fv2Uniform uTexMirrorEn1;
+	fv2Uniform uTexSize0;
+	fv2Uniform uTexSize1;
 };
 
 class ULights : public UniformGroup
diff --git a/GLideN64/src/gSP.cpp b/GLideN64/src/gSP.cpp
index 263b9c05..ea7c9743 100644
--- a/GLideN64/src/gSP.cpp
+++ b/GLideN64/src/gSP.cpp
@@ -857,18 +857,18 @@ void gSPProcessVertex(u32 v, SPVertex * spVtx)
 			if (GBI.getMicrocodeType() != F3DFLX2) {
 				for(int i = 0; i < VNUM; ++i) {
 					SPVertex & vtx = spVtx[v+i];
-					f32 fLightDir[3] = {vtx.nx, vtx.ny, vtx.nz};
+					f32 vNormale[3] = {vtx.nx, vtx.ny, vtx.nz};
 					f32 x, y;
 					if (gSP.lookatEnable) {
-						x = DotProduct(gSP.lookat.i_xyz[0], fLightDir);
-						y = DotProduct(gSP.lookat.i_xyz[1], fLightDir);
+						x = DotProduct(gSP.lookat.i_xyz[0], vNormale);
+						y = DotProduct(gSP.lookat.i_xyz[1], vNormale);
 					} else {
-						fLightDir[0] *= 128.0f;
-						fLightDir[1] *= 128.0f;
-						fLightDir[2] *= 128.0f;
-						TransformVectorNormalize(fLightDir, gSP.matrix.modelView[gSP.matrix.modelViewi]);
-						x = fLightDir[0];
-						y = fLightDir[1];
+						vNormale[0] *= 128.0f;
+						vNormale[1] *= 128.0f;
+						vNormale[2] *= 128.0f;
+						TransformVectorNormalize(vNormale, gSP.matrix.modelView[gSP.matrix.modelViewi]);
+						x = vNormale[0];
+						y = vNormale[1];
 					}
 					if (gSP.geometryMode & G_TEXTURE_GEN_LINEAR) {
 						if (x < -1.0f) x = -1.0f;
@@ -877,7 +877,7 @@ void gSPProcessVertex(u32 v, SPVertex * spVtx)
 						if (y > 1.0f) y = 1.0f;
 						vtx.s = acosf(-x) * 325.94931f;
 						vtx.t = acosf(-y) * 325.94931f;
-					} else { // G_TEXTURE_GEN
+					} else {
 						vtx.s = (x + 1.0f) * 512.0f;
 						vtx.t = (y + 1.0f) * 512.0f;
 					}

From 52f95ac30b68fad45d1f6402fbd1201ed82f817f Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 8 Jun 2020 12:40:14 +0200
Subject: [PATCH 25/28] Backport Core options fix

---
 libretro/libretro_core_options.h | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
index 6238544d..63d74b3c 100644
--- a/libretro/libretro_core_options.h
+++ b/libretro/libretro_core_options.h
@@ -1140,7 +1140,7 @@ static INLINE void libretro_set_core_options(retro_environment_t environ_cb)
     if (!environ_cb)
         return;
 
-    if (environ_cb(RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION, &version) && (version == 1))
+    if (environ_cb(RETRO_ENVIRONMENT_GET_CORE_OPTIONS_VERSION, &version) && (version >= 1))
     {
         struct retro_core_options_intl core_options_intl;
         unsigned language = 0;
@@ -1217,7 +1217,7 @@ static INLINE void libretro_set_core_options(retro_environment_t environ_cb)
                 }
 
                 /* Build values string */
-                if (num_values > 1)
+                if (num_values > 0)
                 {
                     size_t j;
 

From d957ea7d248c720839f7adaf8c739eed3e0e6764 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 8 Jun 2020 13:30:05 +0200
Subject: [PATCH 26/28] Add EnableCopyAuxToRDRAM Core Option

---
 custom/GLideN64/mupenplus/Config_mupenplus.cpp |  2 +-
 custom/mupen64plus-next_common.h               |  1 +
 libretro/libretro.c                            |  8 ++++++++
 libretro/libretro_core_options.h               | 11 +++++++++++
 4 files changed, 21 insertions(+), 1 deletion(-)

diff --git a/custom/GLideN64/mupenplus/Config_mupenplus.cpp b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
index d727dade..cafe092f 100644
--- a/custom/GLideN64/mupenplus/Config_mupenplus.cpp
+++ b/custom/GLideN64/mupenplus/Config_mupenplus.cpp
@@ -161,13 +161,13 @@ extern "C" void Config_LoadConfig()
 #else
 	config.generalEmulation.enableFragmentDepthWrite = EnableFragmentDepthWrite;
 #endif
-
 #ifdef VC
 	config.generalEmulation.enableShadersStorage = 0;
 #else
 	config.generalEmulation.enableShadersStorage = EnableShadersStorage;
 #endif
 
+	config.frameBufferEmulation.copyAuxToRDRAM = EnableCopyAuxToRDRAM;
 	config.textureFilter.txSaveCache = EnableTextureCache;
 	
 	config.textureFilter.txFilterMode = txFilterMode;
diff --git a/custom/mupen64plus-next_common.h b/custom/mupen64plus-next_common.h
index ff2a325f..07f37dfe 100644
--- a/custom/mupen64plus-next_common.h
+++ b/custom/mupen64plus-next_common.h
@@ -113,6 +113,7 @@ extern uint32_t ForceDisableExtraMem;
 extern uint32_t EnableNativeResFactor;
 extern uint32_t EnableN64DepthCompare;
 extern uint32_t EnableThreadedRenderer;
+extern uint32_t EnableCopyAuxToRDRAM;
 
 // Overscan Options
 extern uint32_t EnableOverscan;
diff --git a/libretro/libretro.c b/libretro/libretro.c
index 4110ff43..93896614 100644
--- a/libretro/libretro.c
+++ b/libretro/libretro.c
@@ -178,6 +178,7 @@ uint32_t EnableTxCacheCompression = 0;
 uint32_t EnableNativeResFactor = 0;
 uint32_t EnableN64DepthCompare = 0;
 uint32_t EnableThreadedRenderer = 0;
+uint32_t EnableCopyAuxToRDRAM = 0;
 
 // Overscan options
 #define GLN64_OVERSCAN_SCALING "0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|43|44|45|46|47|48|49|50"
@@ -952,6 +953,13 @@ static void update_variables(bool startup)
           EnableEnhancedHighResStorage = !strcmp(var.value, "False") ? 0 : 1;
        }
 
+       var.key = CORE_NAME "-EnableCopyAuxToRDRAM";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          EnableCopyAuxToRDRAM = !strcmp(var.value, "False") ? 0 : 1;
+       }
+
        var.key = CORE_NAME "-cpucore";
        var.value = NULL;
        if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
index 63d74b3c..d80a72e7 100644
--- a/libretro/libretro_core_options.h
+++ b/libretro/libretro_core_options.h
@@ -256,6 +256,17 @@ struct retro_core_option_definition option_defs_us[] = {
         "False"
 #endif // VC
     },
+    {
+        CORE_NAME "-EnableCopyAuxToRDRAM",
+        "Copy auxiliary buffers to RDRAM",
+        "(GLN64) Copy auxiliary buffers to RDRAM (fixes some Game artifacts like Paper Mario Intro) .",
+        {
+            {"False", NULL},
+            {"True", NULL},
+            {NULL, NULL},
+        },
+        "False",
+    },
     {
         CORE_NAME "-EnableCopyColorToRDRAM",
         "Color buffer to RDRAM",

From ba73792f43ccc20a40b5317e77a15195daa69128 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 8 Jun 2020 13:52:37 +0200
Subject: [PATCH 27/28] Add IgnoreTLBExceptions Options - Current workaround
 for the tricky Dynarec Issue for OoT - Added 3 Modes, one only skips if the
 game doesn't use TLB, one always skips (useful for GdbStub) and one is
 upstream behaviour

---
 custom/mupen64plus-next_common.h        |  1 +
 libretro/libretro.c                     | 13 +++++++++++++
 libretro/libretro_core_options.h        | 12 ++++++++++++
 mupen64plus-core/src/device/r4300/tlb.c | 16 +++++++++++++++-
 4 files changed, 41 insertions(+), 1 deletion(-)

diff --git a/custom/mupen64plus-next_common.h b/custom/mupen64plus-next_common.h
index 07f37dfe..9c6dd461 100644
--- a/custom/mupen64plus-next_common.h
+++ b/custom/mupen64plus-next_common.h
@@ -110,6 +110,7 @@ extern uint32_t EnableEnhancedTextureStorage;
 extern uint32_t EnableEnhancedHighResStorage;
 extern uint32_t EnableTxCacheCompression;
 extern uint32_t ForceDisableExtraMem;
+extern uint32_t IgnoreTLBExceptions;
 extern uint32_t EnableNativeResFactor;
 extern uint32_t EnableN64DepthCompare;
 extern uint32_t EnableThreadedRenderer;
diff --git a/libretro/libretro.c b/libretro/libretro.c
index 93896614..b954f0c0 100644
--- a/libretro/libretro.c
+++ b/libretro/libretro.c
@@ -192,6 +192,7 @@ uint32_t EnableFullspeed = 0;
 uint32_t CountPerOp = 0;
 uint32_t CountPerScanlineOverride = 0;
 uint32_t ForceDisableExtraMem = 0;
+uint32_t IgnoreTLBExceptions = 0;
 
 extern struct device g_dev;
 extern unsigned int r4300_emumode;
@@ -1153,6 +1154,18 @@ static void update_variables(bool startup)
        {
           ForceDisableExtraMem = !strcmp(var.value, "False") ? 0 : 1;
        }
+
+       var.key = CORE_NAME "-IgnoreTLBExceptions";
+       var.value = NULL;
+       if (environ_cb(RETRO_ENVIRONMENT_GET_VARIABLE, &var) && var.value)
+       {
+          if (!strcmp(var.value, "False"))
+             IgnoreTLBExceptions = 0;
+          else if (!strcmp(var.value, "OnlyNotEnabled"))
+             IgnoreTLBExceptions = 1;
+          else if (!strcmp(var.value, "AlwaysIgnoreTLB"))
+             IgnoreTLBExceptions = 2;
+       }
     }
 
 #ifdef HAVE_THR_AL
diff --git a/libretro/libretro_core_options.h b/libretro/libretro_core_options.h
index d80a72e7..c19679c6 100644
--- a/libretro/libretro_core_options.h
+++ b/libretro/libretro_core_options.h
@@ -1056,6 +1056,18 @@ struct retro_core_option_definition option_defs_us[] = {
         },
         "False"
     },
+    {
+        CORE_NAME "-IgnoreTLBExceptions",
+        "Ignore emulated TLB Exceptions",
+        "(HACK) Ignore emulated TLB Exceptions, this might fix some broken romhacks and works around the OoT dynarec freeze. This option might be removed in the future.",
+        {
+            {"False", "Don't Ignore"},
+            {"OnlyNotEnabled", "Ignore TLB Exceptions if not using TLB"},
+            {"AlwaysIgnoreTLB", "Always Ignore TLB Exceptions"},
+            {NULL, NULL},
+        },
+        "False"
+    },
     {
         CORE_NAME "-pak1",
         "Player 1 Pak",
diff --git a/mupen64plus-core/src/device/r4300/tlb.c b/mupen64plus-core/src/device/r4300/tlb.c
index b7a29e8d..4b6925f7 100644
--- a/mupen64plus-core/src/device/r4300/tlb.c
+++ b/mupen64plus-core/src/device/r4300/tlb.c
@@ -20,6 +20,7 @@
  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
 
 #include "tlb.h"
+#include <mupen64plus-next_common.h>
 
 #include "api/m64p_types.h"
 #include "device/r4300/r4300_core.h"
@@ -140,7 +141,20 @@ uint32_t virtual_to_physical_address(struct r4300_core* r4300, uint32_t address,
     //printf("tlb exception !!! @ %x, %x, add:%x\n", address, w, r4300->pc->addr);
     //getchar();
 
-    TLB_refill_exception(r4300, address, w);
+    if(IgnoreTLBExceptions == 0) {
+        /* False, Default Behaviour */
+        TLB_refill_exception(r4300, address, w);
+    } else if(IgnoreTLBExceptions == 1) {
+        /* OnlyNotEnabled */
+        if(using_tlb)
+        {
+            TLB_refill_exception(r4300, address, w);
+        }
+    } else if(IgnoreTLBExceptions == 2)
+    {
+        /* AlwaysIgnoreTLB */
+        /* Do nothing, primary use-case for GdbStub... */
+    }
 
     //return 0x80000000;
     return 0x00000000;

From 328c430f56682cdee00744e8c0b317624d9b46b4 Mon Sep 17 00:00:00 2001
From: M4xw <m4x@m4xw.net>
Date: Mon, 8 Jun 2020 13:55:19 +0200
Subject: [PATCH 28/28] Fix GCC common symbols - For now lets just link those
 against GLN64 - They never run at the same time, are same type and it lowers
 maintenance efforts

---
 GLideN64/src/N64.cpp      | 14 ++++++++++++--
 GLideN64/src/N64.h        |  9 +++++++--
 mupen64plus-rsp-cxd4/su.c |  6 ++++--
 3 files changed, 23 insertions(+), 6 deletions(-)

diff --git a/GLideN64/src/N64.cpp b/GLideN64/src/N64.cpp
index dc91c4cc..e10e0558 100644
--- a/GLideN64/src/N64.cpp
+++ b/GLideN64/src/N64.cpp
@@ -1,8 +1,18 @@
 #include "N64.h"
 
 u8 *HEADER;
-u8 *DMEM;
-u8 *IMEM;
+
+/* 
+    DMEM and IMEM conflict with CXD4 with GCC 10.x
+    It's defined as pu8 so it's the same type as used in GLN64, just typedef'd.
+    Since we never run both at the same time, let's just link CXD4's to this
+    Also we always assume that we will build with GLideN64 at all times
+*/
+extern "C" {
+    u8 *DMEM;
+    u8 *IMEM;
+}
+
 u64 TMEM[512];
 u8 *RDRAM;
 
diff --git a/GLideN64/src/N64.h b/GLideN64/src/N64.h
index 2b2a650c..4fdd01f5 100644
--- a/GLideN64/src/N64.h
+++ b/GLideN64/src/N64.h
@@ -38,8 +38,13 @@ struct N64Regs
 
 extern N64Regs REG;
 extern u8 *HEADER;
-extern u8 *DMEM;
-extern u8 *IMEM;
+
+extern "C" {
+	// See comment in N64.cpp
+	extern u8 *DMEM;
+	extern u8 *IMEM;
+}
+
 extern u8 *RDRAM;
 extern u64 TMEM[512];
 extern u32 RDRAMSize;
diff --git a/mupen64plus-rsp-cxd4/su.c b/mupen64plus-rsp-cxd4/su.c
index b8033cb6..96613acc 100644
--- a/mupen64plus-rsp-cxd4/su.c
+++ b/mupen64plus-rsp-cxd4/su.c
@@ -27,8 +27,10 @@ u32 SR[32];
 typedef VECTOR_OPERATION(*p_vector_func)(v16, v16);
 
 pu8 DRAM;
-pu8 DMEM;
-pu8 IMEM;
+
+// NOTE: Links against GLideN64\src\N64.cpp due to conflicts and maintenance efforts
+extern pu8 DMEM;
+extern pu8 IMEM;
 
 NOINLINE void res_S(void)
 {
