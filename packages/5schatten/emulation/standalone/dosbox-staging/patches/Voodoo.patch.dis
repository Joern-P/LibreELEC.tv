From 594e3209e38e5bcf34f772df9164c7f1f793fafb Mon Sep 17 00:00:00 2001
From: KJ Liew <liewkj@yahoo.com>
Date: Sat, 21 Feb 2015 08:05:00 +0100
Subject: [PATCH] Add Voodoo1 emulation and Glide API pass-through

Voodoo1 patch developed by kekko
Glide pass-through developed by gulikoza
Patches combined and maintained by kjliew
Maintained by Yesterplay80

Vogons thread: https://www.vogons.org/viewtopic.php?f=32&t=42449
---
 configure.ac                      |    2 +-
 include/Makefile.am               |    3 +-
 include/glide.h                   |  331 +++
 include/glidedef.h                |  179 ++
 include/logging.h                 |    1 +
 include/mem.h                     |    2 +
 include/pci_bus.h                 |    8 +-
 include/video.h                   |    8 +
 include/voodoo.h                  |   42 +
 src/cpu/paging.cpp                |    4 +
 src/debug/debug_gui.cpp           |    2 +
 src/dosbox.cpp                    |   38 +
 src/gui/sdlmain.cpp               |   16 +-
 src/hardware/Makefile.am          |    5 +-
 src/hardware/glide.cpp            | 1970 +++++++++++++++
 src/hardware/memory.cpp           |   24 +
 src/hardware/pci_bus.cpp          |   64 +
 src/hardware/pci_devices.h        |  227 ++
 src/hardware/vga_s3.cpp           |    3 +
 src/hardware/voodoo.cpp           |  187 ++
 src/hardware/voodoo_data.h        | 2238 +++++++++++++++++
 src/hardware/voodoo_def.h         |  559 +++++
 src/hardware/voodoo_emu.cpp       | 3730 +++++++++++++++++++++++++++++
 src/hardware/voodoo_emu.h         |   54 +
 src/hardware/voodoo_interface.cpp |  309 +++
 src/hardware/voodoo_interface.h   |   65 +
 src/hardware/voodoo_opengl.cpp    | 1905 +++++++++++++++
 src/hardware/voodoo_opengl.h      |   93 +
 src/hardware/voodoo_types.h       |  371 +++
 src/hardware/voodoo_vogl.cpp      |  457 ++++
 src/hardware/voodoo_vogl.h        |  122 +
 31 files changed, 13014 insertions(+), 5 deletions(-)
 create mode 100644 include/glide.h
 create mode 100644 include/glidedef.h
 create mode 100644 include/voodoo.h
 create mode 100644 src/hardware/glide.cpp
 create mode 100644 src/hardware/voodoo.cpp
 create mode 100644 src/hardware/voodoo_data.h
 create mode 100644 src/hardware/voodoo_def.h
 create mode 100644 src/hardware/voodoo_emu.cpp
 create mode 100644 src/hardware/voodoo_emu.h
 create mode 100644 src/hardware/voodoo_interface.cpp
 create mode 100644 src/hardware/voodoo_interface.h
 create mode 100644 src/hardware/voodoo_opengl.cpp
 create mode 100644 src/hardware/voodoo_opengl.h
 create mode 100644 src/hardware/voodoo_types.h
 create mode 100644 src/hardware/voodoo_vogl.cpp
 create mode 100644 src/hardware/voodoo_vogl.h

diff --git a/configure.ac b/configure.ac
index e993b7597..32255143e 100644
--- a/configure.ac
+++ b/configure.ac
@@ -579,7 +579,7 @@ int main(int argc,char * argv[]) {
 dnl Some target detection and actions for them
 case "$host" in
     *-*-cygwin* | *-*-mingw32*)
-       LIBS="$LIBS -lwinmm"
+       LIBS="$LIBS -lwinmm -lshlwapi"
        AC_DEFINE(C_DIRECTSERIAL, 1, [ Define to 1 if you want serial passthrough support (Win32, Posix and OS/2 only).])
        if test x$have_sdl_net_lib = xyes -a x$have_sdl_net_h = xyes ; then
          LIBS="$LIBS -lws2_32"
diff --git a/include/Makefile.am b/include/Makefile.am
index 570d78c61..b3b771876 100644
--- a/include/Makefile.am
+++ b/include/Makefile.am
@@ -36,5 +36,6 @@ shell.h \
 support.h \
 timer.h \
 vga.h \
-video.h
+video.h \
+voodoo.h
 
diff --git a/include/glide.h b/include/glide.h
new file mode 100644
index 000000000..dbe4eaeb2
--- /dev/null
+++ b/include/glide.h
@@ -0,0 +1,331 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef DOSBOX_GLIDE_H
+#define DOSBOX_GLIDE_H
+
+#define __3DFX_H__
+
+/*
+** basic data types
+*/
+typedef Bit8u   FxU8;
+typedef Bit8s   FxI8;
+typedef Bit16u  FxU16;
+typedef Bit16s  FxI16;
+typedef Bit32u  FxU32;
+typedef Bit32s  FxI32;
+typedef Bit32s  FxBool;
+typedef float   FxFloat;
+typedef double  FxDouble;
+
+/*
+** color types
+*/
+typedef Bit32u                       FxColor_t;
+typedef struct { float r, g, b, a; } FxColor4;
+
+/*
+** fundamental types
+*/
+#define FXTRUE    1
+#define FXFALSE   0
+
+/*
+** helper macros
+*/
+#define FXUNUSED( a ) ((void)(a))
+#define FXBIT( i )    ( 1L << (i) )
+
+#define FX_ENTRY
+#define FX_GLIDE_NO_FUNC_PROTO
+
+#if defined (WIN32)
+#define FX_CALL __stdcall
+#else
+#define FX_CALL
+#endif
+
+#include <sdk2_glide.h>
+#include "glidedef.h"
+
+// Careful with structures containing pointers
+//
+// GrTexInfo; GrLfbInfo_t; Gu3dfInfo; GrMipMapInfo;
+//
+
+// Some glide structs might have different size in guest 32-bit DOS (pointers)
+typedef struct {
+    Bit32s		smallLod;
+    Bit32s		largeLod;
+    Bit32s		aspectRatio;
+    Bit32s		format;
+    PhysPt		data;
+} DBGrTexInfo;
+
+typedef struct {
+    Bit32s		size;
+    PhysPt		lfbPtr;
+    Bit32u		strideInBytes;
+    Bit32s		writeMode;
+    Bit32s		origin;
+} DBGrLfbInfo_t;
+
+typedef struct {
+    Gu3dfHeader 	header;
+    GuTexTable		table;
+    PhysPt		data;
+    Bit32u		mem_required;
+} DBGu3dfInfo;
+
+typedef struct {
+    const char * name;
+    const Bit8u parms;
+} GLIDE_TABLE;
+
+typedef void (FX_CALL *pfunc0)		(void);
+typedef void (FX_CALL *pfunc1i)		(FxU32);
+typedef void (FX_CALL *pfunc1p)		(void*);
+typedef void (FX_CALL *pfunc1f)		(float);
+typedef void (FX_CALL *pfunc2i)		(FxU32, FxU32);
+typedef void (FX_CALL *pfunc1i1p)	(FxU32, void*);
+typedef void (FX_CALL *pfunc2p)		(void*, void*);
+typedef void (FX_CALL *pfunc1i1f)	(FxU32, float);
+typedef void (FX_CALL *pfunc1p1f)	(void*, float);
+typedef void (FX_CALL *pfunc3i)		(FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc2i1p)	(FxU32, FxU32, void*);
+typedef void (FX_CALL *pfunc1i2p)	(FxU32, void*, void*);
+typedef void (FX_CALL *pfunc3p)		(void*, void*, void*);
+typedef void (FX_CALL *pfunc1p2f)	(void*, float, float);
+typedef void (FX_CALL *pfunc4i)		(FxU32, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc3i1p)	(FxU32, FxU32, FxU32, void*);
+typedef void (FX_CALL *pfunc3i1f)	(FxU32, FxU32, FxU32, float);
+typedef void (FX_CALL *pfunc4f)		(float, float, float, float);
+typedef void (FX_CALL *pfunc5i)		(FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc2i1p2i)	(FxU32, FxU32, void*, FxU32, FxU32);
+typedef void (FX_CALL *pfunc4f1i)	(float, float, float, float, FxU32);
+typedef void (FX_CALL *pfunc3p3i)	(void*, void*, void*, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc7i)		(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef void (FX_CALL *pfunc7i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef void (FX_CALL *pfunc7i1p2i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*,
+					    FxU32, FxU32);
+typedef void (FX_CALL *pfunc7i1p7i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*,
+					    FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+
+typedef FxU32 (FX_CALL *prfunc0)		(void);
+typedef FxU32 (FX_CALL *prfunc1i)	(FxU32);
+typedef FxU32 (FX_CALL *prfunc1p)	(void*);
+typedef FxU32 (FX_CALL *prfunc2i)	(FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc1i1p)	(FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc2p)	(void*, void*);
+typedef FxU32 (FX_CALL *prfunc4i)	(FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc5i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc7i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc1p6i)	(void*, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc6i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc7i1p)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, void*);
+typedef FxU32 (FX_CALL *prfunc12i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32,
+					    FxU32, FxU32, FxU32, FxU32, FxU32);
+typedef FxU32 (FX_CALL *prfunc13i1f1i)	(FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32, FxU32,
+					    FxU32, FxU32, FxU32, FxU32, FxU32, float, FxU32);
+
+typedef void* (FX_CALL *prptfunc1i)	(FxU32);
+typedef float (FX_CALL *pffunc1i)	(FxU32);
+
+typedef union {
+    pfunc0	grFunction0;
+    pfunc1i	grFunction1i;
+    pfunc1p	grFunction1p;
+    pfunc1f	grFunction1f;
+    pfunc2i	grFunction2i;
+    pfunc1i1p	grFunction1i1p;
+    pfunc2p	grFunction2p;
+    pfunc1i1f	grFunction1i1f;
+    pfunc1p1f	grFunction1p1f;
+    pfunc3i	grFunction3i;
+    pfunc2i1p	grFunction2i1p;
+    pfunc1i2p	grFunction1i2p;
+    pfunc3p	grFunction3p;
+    pfunc1p2f	grFunction1p2f;
+    pfunc4i	grFunction4i;
+    pfunc3i1p	grFunction3i1p;
+    pfunc3i1f	grFunction3i1f;
+    pfunc4f	grFunction4f;
+    pfunc5i	grFunction5i;
+    pfunc2i1p2i	grFunction2i1p2i;
+    pfunc4f1i	grFunction4f1i;
+    pfunc3p3i	grFunction3p3i;
+    pfunc7i	grFunction7i;
+    pfunc7i1p	grFunction7i1p;
+    pfunc7i1p2i	grFunction7i1p2i;
+    pfunc7i1p7i1p grFunction7i1p7i1p;
+
+    prfunc0	grRFunction0;
+    prfunc1i	grRFunction1i;
+    prfunc1p	grRFunction1p;
+    prfunc2i	grRFunction2i;
+    prfunc1i1p	grRFunction1i1p;
+    prfunc2p	grRFunction2p;
+    prfunc4i	grRFunction4i;
+    prfunc5i1p	grRFunction5i1p;
+    prfunc7i	grRFunction7i;
+    prfunc1p6i	grRFunction1p6i;
+    prfunc6i1p	grRFunction6i1p;
+    prfunc7i1p	grRFunction7i1p;
+    prfunc12i	grRFunction12i;
+    prfunc13i1f1i grRFunction13i1f1i;
+
+    prptfunc1i	grRPTFunction1i;
+
+    pffunc1i	grFFunction1i;
+} FncPointers;
+
+static const GLIDE_TABLE grTable[] = {
+    { "grAADrawLine", 8 },
+    { "grAADrawPoint", 4 },
+    { "grAADrawPolygon", 12 },
+    { "grAADrawPolygonVertexList", 8 },
+    { "grAADrawTriangle", 24 },
+    { "grAlphaBlendFunction", 16 },
+    { "grAlphaCombine", 20 },
+    { "grAlphaControlsITRGBLighting", 4 },
+    { "grAlphaTestFunction", 4 },
+    { "grAlphaTestReferenceValue", 4 },
+    { "grBufferClear", 12 },
+    { "grBufferNumPending", 0 },
+    { "grBufferSwap", 4 },
+    { "grCheckForRoom", 4 },
+    { "grChromakeyMode", 4 },
+    { "grChromakeyValue", 4 },
+    { "grClipWindow", 16 },
+    { "grColorCombine", 20 },
+    { "grColorMask", 8 },
+    { "grConstantColorValue4", 16 },
+    { "grConstantColorValue", 4 },
+    { "grCullMode", 4 },
+    { "grDepthBiasLevel", 4 },
+    { "grDepthBufferFunction", 4 },
+    { "grDepthBufferMode", 4 },
+    { "grDepthMask", 4 },
+    { "grDisableAllEffects", 0 },
+    { "grDitherMode", 4 },
+    { "grDrawLine", 8 },
+    { "grDrawPlanarPolygon", 12 },
+    { "grDrawPlanarPolygonVertexList", 8 },
+    { "grDrawPoint", 4 },
+    { "grDrawPolygon", 12 },
+    { "grDrawPolygonVertexList", 8 },
+    { "grDrawTriangle", 12 },
+    { "grErrorSetCallback", 4 },
+    { "grFogColorValue", 4 },
+    { "grFogMode", 4 },
+    { "grFogTable", 4 },
+    { "grGammaCorrectionValue", 4 },
+    { "grGlideGetState", 4 },
+    { "grGlideGetVersion", 4 },
+    { "grGlideInit", 0 },
+    { "grGlideSetState", 4 },
+    { "grGlideShamelessPlug", 4 },
+    { "grGlideShutdown", 0 },
+    { "grHints", 8 },
+    { "grLfbConstantAlpha", 4 },
+    { "grLfbConstantDepth", 4 },
+    { "grLfbLock", 24 },
+    { "grLfbReadRegion", 28 },
+    { "grLfbUnlock", 8 },
+    { "grLfbWriteColorFormat", 4 },
+    { "grLfbWriteColorSwizzle", 8 },
+    { "grLfbWriteRegion", 32 },
+    { "grRenderBuffer", 4 },
+    { "grResetTriStats", 0 },
+    { "grSplash", 20 },
+    { "grSstConfigPipeline", 12 },
+    { "grSstControl", 4 },
+    { "grSstIdle", 0 },
+    { "grSstIsBusy", 0 },
+    { "grSstOrigin", 4 },
+    { "grSstPerfStats", 4 },
+    { "grSstQueryBoards", 4 },
+    { "grSstQueryHardware", 4 },
+    { "grSstResetPerfStats", 0 },
+    { "grSstScreenHeight", 0 },
+    { "grSstScreenWidth", 0 },
+    { "grSstSelect", 4 },
+    { "grSstStatus", 0 },
+    { "grSstVRetraceOn", 0 },
+    { "grSstVidMode", 8 },
+    { "grSstVideoLine", 0 },
+    { "grSstWinClose", 0 },
+    { "grSstWinOpen", 28 },
+    { "grTexCalcMemRequired", 16 },
+    { "grTexClampMode", 12 },
+    { "grTexCombine", 28 },
+    { "grTexCombineFunction", 8 },
+    { "grTexDetailControl", 16 },
+    { "grTexDownloadMipMap", 16 },
+    { "grTexDownloadMipMapLevel", 32 },
+    { "grTexDownloadMipMapLevelPartial", 40 },
+    { "grTexDownloadTable", 12 },
+    { "grTexDownloadTablePartial", 20 },
+    { "grTexFilterMode", 12 },
+    { "grTexLodBiasValue", 8 },
+    { "grTexMaxAddress", 4 },
+    { "grTexMinAddress", 4 },
+    { "grTexMipMapMode", 12 },
+    { "grTexMultibase", 8 },
+    { "grTexMultibaseAddress", 20 },
+    { "grTexNCCTable", 8 },
+    { "grTexSource", 16 },
+    { "grTexTextureMemRequired", 8 },
+    { "grTriStats", 8 },
+    { "gu3dfGetInfo", 8 },
+    { "gu3dfLoad", 8 },
+    { "guAADrawTriangleWithClip", 12 },
+    { "guAlphaSource", 4 },
+    { "guColorCombineFunction", 4 },
+    { "guDrawPolygonVertexListWithClip", 8 },
+    { "guDrawTriangleWithClip", 12 },
+    { "guEncodeRLE16", 16 },
+    { "guEndianSwapBytes", 4 },
+    { "guEndianSwapWords", 4 },
+    { "guFogGenerateExp2", 8 },
+    { "guFogGenerateExp", 8 },
+    { "guFogGenerateLinear", 12 },
+    { "guFogTableIndexToW", 4 },
+    { "guMPDrawTriangle", 12 },
+    { "guMPInit", 0 },
+    { "guMPTexCombineFunction", 4 },
+    { "guMPTexSource", 8 },
+    { "guMovieSetName", 4 },
+    { "guMovieStart", 0 },
+    { "guMovieStop", 0 },
+    { "guTexAllocateMemory", 60 },
+    { "guTexChangeAttributes", 48 },
+    { "guTexCombineFunction", 8 },
+    { "guTexCreateColorMipMap", 0 },
+    { "guTexDownloadMipMap", 12 },
+    { "guTexDownloadMipMapLevel", 12 },
+    { "guTexGetCurrentMipMap", 4 },
+    { "guTexGetMipMapInfo", 4 },
+    { "guTexMemQueryAvail", 4 },
+    { "guTexMemReset", 0 },
+    { "guTexSource", 4 },
+    { "ConvertAndDownloadRle", 64 }
+};
+
+#endif // DOSBOX_GLIDE_H
diff --git a/include/glidedef.h b/include/glidedef.h
new file mode 100644
index 000000000..227333589
--- /dev/null
+++ b/include/glidedef.h
@@ -0,0 +1,179 @@
+/*
+ *  Copyright (C) 2002-2007  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#ifndef GLIDEDEF_H
+#define GLIDEDEF_H
+
+#ifdef DOSBOX_DOSBOX_H
+struct GLIDE_Block
+{
+    bool splash;
+    bool enabled;
+    bool * fullscreen;
+    Bit16u width, height;
+    class GLIDE_PageHandler * lfb_pagehandler;
+    GLIDE_Block():enabled(false),fullscreen(0),width(0),height(0),lfb_pagehandler((GLIDE_PageHandler*)0) { }
+};
+extern GLIDE_Block glide;
+extern void GLIDE_ResetScreen(bool update=false);
+extern void GLIDE_DisableScreen(void);
+#endif
+
+#define GLIDE_LFB		0x60000000
+#define GLIDE_BUFFERS		3			/* Front, Back, AUX */
+#define GLIDE_PAGE_BITS		11			/* =2048 pages per buffer, should be enough for 1600x1200x4 */
+#define GLIDE_PAGES		(GLIDE_BUFFERS*(1<<GLIDE_PAGE_BITS))
+
+#ifdef __3DFX_H__
+/* If you change these defines, don't forget to change the table in glide.h and compile a matching GLIDE2X.OVL */
+
+#define	_grAADrawLine8			0	// void grAADrawLine(GrVertex *va, GrVertex *vb)
+#define	_grAADrawPoint4			1	// void grAADrawPoint(GrVertex *p)
+#define	_grAADrawPolygon12		2	// void grAADrawPolygon(int nVerts, const int ilist[], const GrVertex vlist[])
+#define	_grAADrawPolygonVertexList8	3	// void grAADrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+#define	_grAADrawTriangle24		4	// void grAADrawTriangle(GrVertex *a, GrVertex *b, GrVertex *c, FxBool antialiasAB, FxBool antialiasBC, FxBool antialiasCA)
+#define	_grAlphaBlendFunction16		5	// void grAlphaBlendFunction(GrAlphaBlendFnc_t rgb_sf, GrAlphaBlendFnc_t rgb_df, GrAlphaBlendFnc_t alpha_sf, GrAlphaBlendFnc_t alpha_df)
+#define	_grAlphaCombine20		6	// void grAlphaCombine(GrCombineFunction_t func, GrCombineFactor_t factor, GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+#define	_grAlphaControlsITRGBLighting4	7	// void grAlphaControlsITRGBLighting(FxBool enable)
+#define	_grAlphaTestFunction4		8	// void grAlphaTestFunction(GrCmpFnc_t function)
+#define	_grAlphaTestReferenceValue4	9	// void grAlphaTestReferenceValue(GrAlpha_t value)
+#define	_grBufferClear12		10	// void grBufferClear(GrColor_t color, GrAlpha_t alpha, FxU16 depth)
+#define	_grBufferNumPending0		11	// int grBufferNumPending(void)
+#define	_grBufferSwap4			12	// void grBufferSwap(int swap_interval)
+#define	_grCheckForRoom4		13	// void grCheckForRoom(FxI32 n)
+#define	_grChromakeyMode4		14	// void grChromakeyMode(GrChromakeyMode_t mode)
+#define	_grChromakeyValue4		15	// void grChromakeyValue(GrColor_t value)
+#define	_grClipWindow16			16	// void grClipWindow(FxU32 minx, FxU32 miny, FxU32 maxx, FxU32 maxy)
+#define	_grColorCombine20		17	// void grColorCombine(GrCombineFunction_t func, GrCombineFactor_t factor, GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+#define	_grColorMask8			18	// void grColorMask(FxBool rgb, FxBool alpha)
+#define	_grConstantColorValue416	19	// void grConstantColorValue4(float a, float r, float g, float b)
+#define	_grConstantColorValue4		20	// void grConstantColorValue(GrColor_t color)
+#define	_grCullMode4			21	// void grCullMode(GrCullMode_t mode)
+#define	_grDepthBiasLevel4		22	// void grDepthBiasLevel(FxI16 level)
+#define	_grDepthBufferFunction4		23	// void grDepthBufferFunction(GrCmpFnc_t func)
+#define	_grDepthBufferMode4		24	// void grDepthBufferMode(GrDepthBufferMode_t mode)
+#define	_grDepthMask4			25	// void grDepthMask(FxBool enable)
+#define	_grDisableAllEffects0		26	// void grDisableAllEffects(void)
+#define	_grDitherMode4			27	// void grDitherMode(GrDitherMode_t mode)
+#define	_grDrawLine8			28	// void grDrawLine(const GrVertex *a, const GrVertex *b)
+#define	_grDrawPlanarPolygon12		29	// void grDrawPlanarPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+#define	_grDrawPlanarPolygonVertexList8 30	// void grDrawPlanarPolygonVertexList(int nVerts, const GrVertex vlist[])
+#define	_grDrawPoint4			31	// void grDrawPoint(const GrVertex *a)
+#define	_grDrawPolygon12		32	// void grDrawPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+#define	_grDrawPolygonVertexList8	33	// void grDrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+#define	_grDrawTriangle12		34	// void grDrawTriangle(const GrVertex *a, const GrVertex *b, const GrVertex *c)
+#define	_grErrorSetCallback4		35	// void grErrorSetCallback(void (*function)(const char *string, FxBool fatal))
+#define	_grFogColorValue4		36	// void grFogColorValue(GrColor_t value)
+#define	_grFogMode4			37	// void grFogMode(GrFogMode_t mode)
+#define	_grFogTable4			38	// void grFogTable(const GrFog_t table[GR_FOG_TABLE_SIZE])
+#define	_grGammaCorrectionValue4	39	// void grGammaCorrectionValue(float value)
+#define	_grGlideGetState4		40	// void grGlideGetState(GrState *state)
+#define	_grGlideGetVersion4		41	// void grGlideGetVersion(char version[80])
+#define	_grGlideInit0			42	// void grGlideInit(void)
+#define	_grGlideSetState4		43	// void grGlideSetState(const GrState *state)
+#define	_grGlideShamelessPlug4		44	// void grGlideShamelessPlug(const FxBool on)
+#define	_grGlideShutdown0		45	// void grGlideShutdown(void)
+#define	_grHints8			46	// void grHints(GrHint_t type, FxU32 hintMask)
+#define	_grLfbConstantAlpha4		47	// void grLfbConstantAlpha(GrAlpha_t alpha)
+#define	_grLfbConstantDepth4		48	// void grLfbConstantDepth(FxU16 depth)
+#define	_grLfbLock24			49	// FxBool grLfbLock(GrLock_t type, GrBuffer_t buffer, GrLfbWriteMode_t writeMode, GrOriginLocation_t origin, FxBool pixelPipeline, GrLfbInfo_t *info)
+#define	_grLfbReadRegion28		50	// FxBool grLfbReadRegion(GrBuffer_t src_buffer, FxU32 src_x, FxU32 src_y, FxU32 src_width, FxU32 src_height, FxU32 dst_stride, void *dst_data)
+#define	_grLfbUnlock8			51	// FxBool grLfbUnlock(GrLock_t type, GrBuffer_t buffer)
+#define	_grLfbWriteColorFormat4		52	// void grLfbWriteColorFormat(GrColorFormat_t colorFormat)
+#define	_grLfbWriteColorSwizzle8	53	// void grLfbWriteColorSwizzle(FxBool swizzleBytes, FxBool swapWords)
+#define	_grLfbWriteRegion32		54	// FxBool grLfbWriteRegion(GrBuffer_t dst_buffer, FxU32 dst_x, FxU32 dst_y, GrLfbSrcFmt_t src_format, FxU32 src_width, FxU32 src_height, FxU32 src_stride, void *src_data)
+#define	_grRenderBuffer4		55	// void grRenderBuffer(GrBuffer_t buffer)
+#define	_grResetTriStats0		56	// void grResetTriStats()
+#define	_grSplash20			57	// void grSplash(float x, float y, float width, float height, FxU32 frame)
+#define	_grSstConfigPipeline12		58	//
+#define	_grSstControl4			59	// FxBool grSstControl(FxU32 code)
+#define	_grSstIdle0			60	// void grSstIdle(void)
+#define	_grSstIsBusy0			61	// FxBool grSstIsBusy(void)
+#define	_grSstOrigin4			62	// void grSstOrigin(GrOriginLocation_t origin)
+#define	_grSstPerfStats4		63	// void grSstPerfStats(GrSstPerfStats_t *pStats)
+#define	_grSstQueryBoards4		64	// FxBool grSstQueryBoards(GrHwConfiguration *hwConfig)
+#define	_grSstQueryHardware4		65	// FxBool grSstQueryHardware(GrHwConfiguration *hwConfig)
+#define	_grSstResetPerfStats0		66	// void grSstResetPerfStats(void)
+#define	_grSstScreenHeight0		67	// FxU32 grSstScreenHeight(void)
+#define	_grSstScreenWidth0		68	// FxU32 grSstScreenWidth(void)
+#define	_grSstSelect4			69	// void grSstSelect(int which_sst)
+#define	_grSstStatus0			70	// FxU32 grSstStatus(void)
+#define	_grSstVRetraceOn0		71	// FxBool grSstVRetraceOn(void)
+#define	_grSstVidMode8			72	//
+#define	_grSstVideoLine0		73	// FxU32 grSstVideoLine(void)
+#define	_grSstWinClose0			74	// void grSstWinClose(void)
+#define	_grSstWinOpen28			75	// FxBool grSstWinOpen(FxU32 hwnd, GrScreenResolution_t res, GrScreenRefresh_t ref, GrColorFormat_t cformat, GrOriginLocation_t org_loc, int num_buffers, int num_aux_buffers)
+#define	_grTexCalcMemRequired16		76	// FxU32 grTexCalcMemRequired(GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspect, GrTextureFormat_t format)
+#define	_grTexClampMode12		77	// void grTexClampMode(GrChipID_t tmu, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode)
+#define	_grTexCombine28			78	// void grTexCombine(GrChipID_t tmu, GrCombineFunction_t rgb_function, GrCombineFactor_t rgb_factor, GrCombineFunction_t alpha_function, GrCombineFactor_t alpha_factor, FxBool rgb_invert, FxBool alpha_invert)
+#define	_grTexCombineFunction8		79	// void grTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t fnc)
+#define	_grTexDetailControl16		80	// void grTexDetailControl(GrChipID_t tmu, int lodBias, FxU8 detailScale, float detailMax)
+#define	_grTexDownloadMipMap16		81	// void grTexDownloadMipMap(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+#define	_grTexDownloadMipMapLevel32	82	// void grTexDownloadMipMapLevel(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd, void *data)
+#define	_grTexDownloadMipMapLevelPartial40 83	// void grTexDownloadMipMapLevelPartial(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd, void *data, int start, int end)
+#define	_grTexDownloadTable12		84	// void grTexDownloadTable(GrChipID_t tmu, GrTexTable_t type, void *data)
+#define	_grTexDownloadTablePartial20	85	// void grTexDownloadTablePartial(GrChipID_t tmu, GrTexTable_t type, void *data, int start, int end)
+#define	_grTexFilterMode12		86	// void grTexFilterMode(GrChipID_t tmu, GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode)
+#define	_grTexLodBiasValue8		87	// void grTexLodBiasValue(GrChipID_t tmu, float bias)
+#define	_grTexMaxAddress4		88	// FxU32 grTexMaxAddress(GrChipID_t tmu)
+#define	_grTexMinAddress4		89	// FxU32 grTexMinAddress(GrChipID_t tmu)
+#define	_grTexMipMapMode12		90	// void grTexMipMapMode(GrChipID_t tmu, GrMipMapMode_t mode, FxBool lodBlend)
+#define	_grTexMultibase8		91	// void grTexMultibase(GrChipID_t tmu, FxBool enable)
+#define	_grTexMultibaseAddress20	92	// void grTexMultibaseAddress(GrChipID_t tmu, GrTexBaseRange_t range, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+#define	_grTexNCCTable8			93	// void grTexNCCTable(GrChipID_t tmu, GrNCCTable_t table)
+#define	_grTexSource16			94	// void grTexSource(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+#define	_grTexTextureMemRequired8	95	// FxU32 grTexTextureMemRequired(FxU32 evenOdd, GrTexInfo *info)
+#define	_grTriStats8			96	// void grTriStats(FxU32 *trisProcessed, FxU32 *trisDrawn)
+#define	_gu3dfGetInfo8			97	// FxBool gu3dfGetInfo(const char *filename, Gu3dfInfo *info)
+#define	_gu3dfLoad8			98	// FxBool gu3dfLoad(const char *filename, Gu3dfInfo *info)
+#define	_guAADrawTriangleWithClip12	99	// void guAADrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+#define	_guAlphaSource4			100	// void guAlphaSource(GrAlphaSource_t mode)
+#define	_guColorCombineFunction4	101	// void guColorCombineFunction(GrColorCombineFnc_t func)
+#define	_guDrawPolygonVertexListWithClip8 102	// void guDrawPolygonVertexListWithClip(int nverts, const GrVertex vlist[])
+#define	_guDrawTriangleWithClip12	103	// void guDrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+#define	_guEncodeRLE1616		104	//
+#define	_guEndianSwapBytes4		105	//
+#define	_guEndianSwapWords4		106	//
+#define	_guFogGenerateExp28		107	// void guFogGenerateExp2(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+#define	_guFogGenerateExp8		108	// void guFogGenerateExp(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+#define	_guFogGenerateLinear12		109	// void guFogGenerateLinear(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float nearW, float farW)
+#define	_guFogTableIndexToW4		110	// float guFogTableIndexToW(int i)
+#define	_guMPDrawTriangle12		111	//
+#define	_guMPInit0			112	//
+#define	_guMPTexCombineFunction4	113	//
+#define	_guMPTexSource8			114	//
+#define	_guMovieSetName4		115	//
+#define	_guMovieStart0			116	//
+#define	_guMovieStop0			117	//
+#define	_guTexAllocateMemory60		118	// GrMipMapId_t guTexAllocateMemory(GrChipID_t tmu, FxU8 evenOddMask, int width, int height, GrTextureFormat_t format, GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode, GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode, float lodBias, FxBool lodBlend)
+#define	_guTexChangeAttributes48	119	// FxBool guTexChangeAttributes(GrMipMapID_t mmid, int width, int height, GrTextureFormat_t format, GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode, GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode)
+#define	_guTexCombineFunction8		120	// void guTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t func)
+#define	_guTexCreateColorMipMap0	121	//
+#define	_guTexDownloadMipMap12		122	// void guTexDownloadMipMap(GrMipMapId_t mmid, const void *src, const GuNccTable *nccTable)
+#define	_guTexDownloadMipMapLevel12	123	// void guTexDownloadMipMapLevel(GrMipMapId_t mmid, GrLOD_t lod, const void **src)
+#define	_guTexGetCurrentMipMap4		124	// GrMipMapId_t guTexGetCurrentMipMap (GrChipID_t tmu)
+#define	_guTexGetMipMapInfo4		125	// GrMipMapInfo *guTexGetMipMapInfo(GrMipMapId_t mmid)
+#define	_guTexMemQueryAvail4		126	// FxU32 guTexMemQueryAvail(GrChipID_t tmu)
+#define	_guTexMemReset0			127	// void guTexMemReset(void)
+#define	_guTexSource4			128	// void guTexSource(GrMipMapId_t mmid)
+#define	_ConvertAndDownloadRle64	129	// void ConvertAndDownloadRle(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd, FxU8 *bm_data, long  bm_h, FxU32 u0, FxU32 v0, FxU32 width, FxU32 height, FxU32 dest_width, FxU32 dest_height, FxU16 *tlut)
+#define GLIDE_MAX			129
+
+#endif // __3DFX_H__
+
+#endif // GLIDEDEF_H
diff --git a/include/logging.h b/include/logging.h
index 0e9c40eab..37e881643 100644
--- a/include/logging.h
+++ b/include/logging.h
@@ -28,6 +28,7 @@ enum LOG_TYPES {
 	LOG_MOUSE,LOG_BIOS,LOG_GUI,LOG_MISC,
 	LOG_IO,
 	LOG_PCI,
+	LOG_VOODOO,
 	LOG_MAX
 };
 
diff --git a/include/mem.h b/include/mem.h
index 99b082e88..2a840aa4c 100644
--- a/include/mem.h
+++ b/include/mem.h
@@ -152,6 +152,8 @@ static INLINE Bit32u phys_readd(PhysPt addr){
 
 void MEM_BlockWrite(PhysPt pt,void const * const data,Bitu size);
 void MEM_BlockRead(PhysPt pt,void * data,Bitu size);
+void MEM_BlockWrite32(PhysPt pt,void * data,Bitu size);
+void MEM_BlockRead32(PhysPt pt,void * data,Bitu size);
 void MEM_BlockCopy(PhysPt dest,PhysPt src,Bitu size);
 void MEM_StrCopy(PhysPt pt,char * data,Bitu size);
 
diff --git a/include/pci_bus.h b/include/pci_bus.h
index 3b8e332ee..477dbaac9 100644
--- a/include/pci_bus.h
+++ b/include/pci_bus.h
@@ -19,7 +19,7 @@
 #ifndef DOSBOX_PCI_H
 #define DOSBOX_PCI_H
 
-//#define PCI_FUNCTIONALITY_ENABLED 0
+#define PCI_FUNCTIONALITY_ENABLED 1
 
 #if defined PCI_FUNCTIONALITY_ENABLED
 
@@ -83,4 +83,10 @@ RealPt PCI_GetPModeInterface(void);
 
 #endif
 
+void PCI_AddSVGAS3_Device(void);
+void PCI_RemoveSVGAS3_Device(void);
+
+void PCI_AddSST_Device(Bitu type);
+void PCI_RemoveSST_Device(void);
+
 #endif
diff --git a/include/video.h b/include/video.h
index 3696ced70..80c49962f 100644
--- a/include/video.h
+++ b/include/video.h
@@ -59,6 +59,7 @@ void GFX_SetPalette(Bitu start,Bitu count,GFX_PalEntry * entries);
 Bitu GFX_GetBestMode(Bitu flags);
 Bitu GFX_GetRGB(Bit8u red,Bit8u green,Bit8u blue);
 Bitu GFX_SetSize(Bitu width,Bitu height,Bitu flags,double scalex,double scaley,GFX_CallBack_t cb);
+void GFX_TearDown(void);
 
 void GFX_ResetScreen(void);
 void GFX_Start(void);
@@ -69,6 +70,13 @@ void GFX_EndUpdate( const Bit16u *changedLines );
 void GFX_GetSize(int &width, int &height, bool &fullscreen);
 void GFX_LosingFocus(void);
 
+bool GFX_IsFullscreen(void);
+void GFX_SwitchLazyFullscreen(bool lazy);
+bool GFX_LazyFullscreenRequested(void);
+void GFX_SwitchFullscreenNoReset(void);
+void GFX_RestoreMode(void);
+void GFX_UpdateSDLCaptureState(void);
+
 #if defined (WIN32)
 bool GFX_SDLUsingWinDIB(void);
 #endif
diff --git a/include/voodoo.h b/include/voodoo.h
new file mode 100644
index 000000000..0c44f9434
--- /dev/null
+++ b/include/voodoo.h
@@ -0,0 +1,42 @@
+ /*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef DOSBOX_VOODOO_H
+#define DOSBOX_VOODOO_H
+
+
+#define VOODOO_INITIAL_LFB	0xd0000000
+#define VOODOO_REG_PAGES	1024
+#define VOODOO_LFB_PAGES	1024
+#define VOODOO_TEX_PAGES	2048
+#define VOODOO_PAGES (VOODOO_REG_PAGES+VOODOO_LFB_PAGES+VOODOO_TEX_PAGES)
+
+
+#define VOODOO_EMU_TYPE_OFF			0
+#define VOODOO_EMU_TYPE_SOFTWARE	1
+#define VOODOO_EMU_TYPE_ACCELERATED	2
+
+
+void VOODOO_PCI_InitEnable(Bitu val);
+void VOODOO_PCI_Enable(bool enable);
+void VOODOO_PCI_SetLFB(Bit32u lfbaddr);
+bool VOODOO_PCI_CheckLFBPage(Bitu page);
+PageHandler* VOODOO_GetPageHandler();
+
+#endif
diff --git a/src/cpu/paging.cpp b/src/cpu/paging.cpp
index b91cdfaf0..aa810064d 100644
--- a/src/cpu/paging.cpp
+++ b/src/cpu/paging.cpp
@@ -144,6 +144,8 @@ void PAGING_PageFault(PhysPt lin_addr,Bitu page_addr,Bitu faultcode) {
 	old_cpudecoder=cpudecoder;
 	cpudecoder=&PageFaultCore;
 	paging.cr2=lin_addr;
+	if (pf_queue.used > 0)
+	    LOG_MSG("PageFault at %X type [%x] queue %d",lin_addr,faultcode,pf_queue.used);
 	PF_Entry * entry=&pf_queue.entries[pf_queue.used++];
 	LOG(LOG_PAGING,LOG_NORMAL)("PageFault at %X type [%x] queue %d",lin_addr,faultcode,pf_queue.used);
 //	LOG_MSG("EAX:%04X ECX:%04X EDX:%04X EBX:%04X",reg_eax,reg_ecx,reg_edx,reg_ebx);
@@ -160,6 +162,8 @@ void PAGING_PageFault(PhysPt lin_addr,Bitu page_addr,Bitu faultcode) {
 #endif
 	DOSBOX_RunMachine();
 	pf_queue.used--;
+	if (pf_queue.used > 0)
+	    LOG_MSG("Left PageFault for %x queue %d",lin_addr,pf_queue.used);
 	LOG(LOG_PAGING,LOG_NORMAL)("Left PageFault for %x queue %d",lin_addr,pf_queue.used);
 	memcpy(&lflags,&old_lflags,sizeof(LazyFlags));
 	cpudecoder=old_cpudecoder;
diff --git a/src/debug/debug_gui.cpp b/src/debug/debug_gui.cpp
index a25e385ca..74e4a8665 100644
--- a/src/debug/debug_gui.cpp
+++ b/src/debug/debug_gui.cpp
@@ -256,6 +256,8 @@ void LOG_StartUp(void) {
 	loggrp[LOG_IO].front="IO";
 	loggrp[LOG_PCI].front="PCI";
 	
+	loggrp[LOG_VOODOO].front="SST";
+
 	/* Register the log section */
 	Section_prop * sect=control->AddSection_prop("log",LOG_Init);
 	Prop_string* Pstring = sect->Add_string("logfile",Property::Changeable::Always,"");
diff --git a/src/dosbox.cpp b/src/dosbox.cpp
index 1e48915c3..1f14529e3 100644
--- a/src/dosbox.cpp
+++ b/src/dosbox.cpp
@@ -76,11 +76,13 @@ void HARDWARE_Init(Section*);
 
 #if defined(PCI_FUNCTIONALITY_ENABLED)
 void PCI_Init(Section*);
+void VOODOO_Init(Section*);
 #endif
 
 
 void KEYBOARD_Init(Section*);	//TODO This should setup INT 16 too but ok ;)
 void JOYSTICK_Init(Section*);
+void GLIDE_Init(Section*);
 void MOUSE_Init(Section*);
 void SBLASTER_Init(Section*);
 void GUS_Init(Section*);
@@ -527,6 +529,31 @@ void DOSBOX_Init(void) {
 
 #if defined(PCI_FUNCTIONALITY_ENABLED)
 	secprop=control->AddSection_prop("pci",&PCI_Init,false); //PCI bus
+
+	secprop->AddInitFunction(&VOODOO_Init,true);
+	const char* voodoo_settings[] = {
+		"false",
+		"software",
+#if C_OPENGL
+		"opengl",
+#endif
+		"auto",
+		0
+	};
+	Pstring = secprop->Add_string("voodoo",Property::Changeable::WhenIdle,"auto");
+	Pstring->Set_values(voodoo_settings);
+	Pstring->Set_help("Enable VOODOO support.");
+
+	const char* voodoo_memory[] = {
+		"standard",
+		"max",
+		0
+	};
+	Pstring = secprop->Add_string("voodoomem",Property::Changeable::OnlyAtStart,"standard");
+	Pstring->Set_values(voodoo_memory);
+	Pstring->Set_help("Specify VOODOO card memory size.\n"
+		              "  'standard'      4MB card (2MB front buffer + 1x2MB texture unit)\n"
+					  "  'max'           12MB card (4MB front buffer + 2x4MB texture units)");
 #endif
 
 
@@ -744,6 +771,17 @@ void DOSBOX_Init(void) {
 	Pmulti_remain->Set_help("see serial1");
 
 
+	secprop=control->AddSection_prop("glide",&GLIDE_Init,true);
+	Pbool = secprop->Add_bool("glide",Property::Changeable::WhenIdle,false);
+	Pbool->Set_help("Enable glide emulation: true,false.");
+	//Phex = secprop->Add_hex("grport",Property::Changeable::WhenIdle,0x600);
+	//Phex->Set_help("I/O port to use for host communication.");
+	Pstring = secprop->Add_string("lfb",Property::Changeable::WhenIdle,"full_noaux");
+	Pstring->Set_help("LFB access: full,full_noaux,read,read_noaux,write,write_noaux,none.\n"
+		"OpenGlide does not support locking aux buffer, please use _noaux modes.");
+	Pbool = secprop->Add_bool("splash",Property::Changeable::WhenIdle,true);
+	Pbool->Set_help("Show 3dfx splash screen (requires 3dfxSpl2.dll).");
+
 	/* All the DOS Related stuff, which will eventually start up in the shell */
 	secprop=control->AddSection_prop("dos",&DOS_Init,false);//done
 	secprop->AddInitFunction(&XMS_Init,true);//done
diff --git a/src/gui/sdlmain.cpp b/src/gui/sdlmain.cpp
index 96f003124..8b2e50f54 100644
--- a/src/gui/sdlmain.cpp
+++ b/src/gui/sdlmain.cpp
@@ -49,6 +49,7 @@
 #include "cpu.h"
 #include "cross.h"
 #include "control.h"
+#include "glidedef.h"
 
 #define MAPPERFILE "mapper-" VERSION ".map"
 //#define DISABLE_JOYSTICK
@@ -439,6 +440,10 @@ Bitu GFX_GetBestMode(Bitu flags) {
 
 
 void GFX_ResetScreen(void) {
+	if(glide.enabled) {
+		GLIDE_ResetScreen(true);
+		return;
+	}
 	GFX_Stop();
 	if (sdl.draw.callback)
 		(sdl.draw.callback)( GFX_CallBackReset );
@@ -847,6 +852,9 @@ void GFX_SwitchFullScreen(void) {
 		sticky_keys(true); //restore sticky keys to default state in windowed mode.
 #endif
 	}
+	if (glide.enabled)
+		GLIDE_ResetScreen();
+	else
 	GFX_ResetScreen();
 }
 
@@ -1667,7 +1675,7 @@ void GFX_Events() {
 			throw(0);
 			break;
 		case SDL_VIDEOEXPOSE:
-			if (sdl.draw.callback) sdl.draw.callback( GFX_CallBackRedraw );
+			if ((sdl.draw.callback) && (!glide.enabled)) sdl.draw.callback( GFX_CallBackRedraw );
 			break;
 #ifdef WIN32
 		case SDL_KEYDOWN:
@@ -2121,6 +2129,8 @@ int main(int argc, char* argv[]) {
 			if (strcmp(sdl_drv_name,"windib")==0) LOG_MSG("SDL_Init: Starting up with SDL windib video driver.\n          Try to update your video card and directx drivers!");
 		}
 #endif
+	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
+	glide.fullscreen = &sdl.desktop.fullscreen;
 	sdl.num_joysticks=SDL_NumJoysticks();
 
 	/* Parse configuration files */
@@ -2245,3 +2255,7 @@ void GFX_GetSize(int &width, int &height, bool &fullscreen) {
 	height = sdl.draw.height;
 	fullscreen = sdl.desktop.fullscreen;
 }
+
+bool OpenGL_using(void) {
+	return (sdl.desktop.want_type==SCREEN_OPENGL?true:false);
+}
diff --git a/src/hardware/Makefile.am b/src/hardware/Makefile.am
index 2d7394821..c39424edf 100644
--- a/src/hardware/Makefile.am
+++ b/src/hardware/Makefile.am
@@ -2,14 +2,17 @@ AM_CPPFLAGS = -I$(top_srcdir)/include
 
 SUBDIRS = serialport mame
 
-EXTRA_DIST = opl.cpp opl.h adlib.h dbopl.h pci_devices.h
+EXTRA_DIST = opl.cpp opl.h adlib.h dbopl.h pci_devices.h \
+	     voodoo_data.h voodoo_def.h voodoo_emu.h voodoo_interface.h voodoo_opengl.h voodoo_types.h voodoo_vogl.h
 
 noinst_LIBRARIES = libhardware.a
 
 libhardware_a_SOURCES = adlib.cpp dma.cpp gameblaster.cpp hardware.cpp iohandler.cpp joystick.cpp keyboard.cpp \
+			glide.cpp \
                         memory.cpp mixer.cpp pcspeaker.cpp pci_bus.cpp pic.cpp sblaster.cpp tandy_sound.cpp timer.cpp \
 			vga.cpp vga_attr.cpp vga_crtc.cpp vga_dac.cpp vga_draw.cpp vga_gfx.cpp vga_other.cpp \
 			vga_memory.cpp vga_misc.cpp vga_seq.cpp vga_xga.cpp vga_s3.cpp vga_tseng.cpp vga_paradise.cpp \
+			voodoo.cpp voodoo_emu.cpp voodoo_interface.cpp voodoo_opengl.cpp voodoo_vogl.cpp \
 			cmos.cpp disney.cpp gus.cpp mpu401.cpp ipx.cpp ipxserver.cpp dbopl.cpp
 
 
diff --git a/src/hardware/glide.cpp b/src/hardware/glide.cpp
new file mode 100644
index 000000000..3b0c3beff
--- /dev/null
+++ b/src/hardware/glide.cpp
@@ -0,0 +1,1970 @@
+/*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU Library General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include "dosbox.h"
+#include "inout.h"
+#include "mem.h"
+#include "paging.h"
+#include "glide.h"
+#include "setup.h"
+#include "vga.h"
+#include "dos_inc.h"		/* for Drives[] */
+#include "control.h"
+#include "../dos/drives.h"
+
+#include <iomanip>
+#include <sstream>
+using namespace std;
+
+#include "SDL.h"
+#include "SDL_syswm.h"
+
+#if defined (WIN32)
+#include <windows.h>
+#include <Shlwapi.h>
+
+#ifdef _MSC_VER
+#pragma comment( lib, "Shlwapi" )
+#endif
+
+#else // *nix
+#include <dlfcn.h>
+
+#include <dirent.h>
+#include <errno.h>
+
+#endif
+
+extern void GFX_Stop(void);
+extern void GFX_ResetScreen(void);
+extern const char* RunningProgram;
+
+static float int_to_float(const Bit32u i)
+{
+    float f;
+    Bit32u i_native = SDL_SwapLE32(i);
+    SDL_memcpy(&f, &i_native, 4);
+    return f;
+}
+
+#define SAFE_DELETE(p)	{ if(p) { delete p; p = NULL; } }
+
+#define G_OK	1
+#define G_FAIL	0
+
+// Print debug messages
+#define LOG_GLIDE 0
+
+void VFILE_Remove(const char *name);
+static void process_msg(Bitu);
+
+/** Global Variables **/
+GLIDE_Block glide;
+
+//  Pointers to loaded routines
+static FncPointers FP;
+static void ** fn_pt=NULL;
+
+// Shared memory
+static Bit32u param[20];
+
+// Pointer to return value
+static PhysPt ret;
+static Bit16u ret_value;
+
+// Temporary texture buffer
+static Bit32u texsize=0;
+static void* texmem=NULL;
+
+static HostPt hwnd=NULL;
+static char lfbacc=0;
+
+// Tomb Rider shadow hack
+static Bit8u tomb = 0;
+static FxI32 GrOriginLocation = 0;
+
+#if defined (WIN32)
+static HINSTANCE hdll=NULL;	//  Handle to glide2x lib file
+#else
+static void * hdll=NULL;
+#endif
+
+#if LOG_GLIDE
+static int GLIDE_count[GLIDE_MAX+2];
+#endif
+
+static Bitu read_gl(Bitu port,Bitu iolen)
+{
+    Bitu r=ret_value;
+#if LOG_GLIDE
+    if(ret_value == G_OK)
+	LOG_MSG("Glide:Port read. Return address: 0x%x, value: %d", ret, mem_readd(ret));
+    else if(ret_value == G_FAIL)
+	LOG_MSG("Glide:Port read. Return address: 0x%x, value: %d. Writing G_FAIL to port", ret, mem_readd(ret));
+    else
+	LOG_MSG("Glide:Port read. Returning %hu", ret_value);
+#endif
+
+    ret_value = ret_value >> 8;
+
+    return r;
+}
+
+static void write_gl(Bitu port,Bitu val,Bitu iolen)
+{
+    static Bit16u glsegment = 0;
+
+    ret = 0;
+    ret_value = G_FAIL;
+    FP.grFunction0 = NULL;
+
+    // Allocate shared memory (80 bytes)
+    if(val > GLIDE_MAX) {
+	if(glsegment==0) {
+	    glsegment=DOS_GetMemory(5);
+#if LOG_GLIDE
+	    LOG_MSG("Glide:Memory allocated at 0x%x (segment: %hu)", glsegment<<4, glsegment);
+#endif
+	}
+	ret_value=glsegment;
+	LOG_MSG("Glide:Activated");
+	return;
+    }
+
+    // Process function parameters (80 bytes)
+    MEM_BlockRead32(PhysMake(glsegment,0), param, 80);
+    process_msg(val);
+
+//  LOG_MSG("Glide:Function %s executed OK", grTable[val].name);
+}
+
+static void statWMInfo(void)
+{
+    // Get hwnd information
+    SDL_SysWMinfo wmi;
+    SDL_VERSION(&wmi.version);
+    if(SDL_GetWMInfo(&wmi)) {
+#if defined (WIN32)
+	hwnd = (HostPt)wmi.window;
+#else
+	hwnd = (HostPt)wmi.info.x11.window;
+#endif
+    } else {
+	LOG_MSG("SDL:Error retrieving window information");
+    }
+}
+
+class GLIDE_PageHandler : public PageHandler {
+private:
+    PhysPt base_addr[GLIDE_BUFFERS];	// GLIDE_LFB physical address
+    PhysPt lin_addr[GLIDE_BUFFERS];	// GLIDE_LFB linear address
+    HostPt lfb_addr[GLIDE_BUFFERS];	// Address offset from base_addr for the readable/writable buffers
+
+    /* Calculate physical address for access */
+    #define LFB_getAddr(addr) (lfb_addr[((addr - base_addr[0])>>12)>>GLIDE_PAGE_BITS]+addr)
+
+public:
+
+    FxU8 locked[GLIDE_BUFFERS];
+
+    GLIDE_PageHandler(HostPt addr, PhysPt phyaddr = GLIDE_LFB) {
+
+	if(addr == NULL) {
+	    LOG_MSG("Glide:NULL address passed to pagehandler!");
+	}
+
+	/* Set base addresses */
+	for(int i = 0; i < GLIDE_BUFFERS; i++) {
+	    locked[i] = 0;
+	    base_addr[i] = phyaddr;
+	    phyaddr += ((1<<GLIDE_PAGE_BITS)<<12);
+
+	    /* store offset from base address */
+	    lfb_addr[i] = (addr == NULL) ? NULL : (addr - base_addr[i]);
+	}
+
+	flags=PFLAG_READABLE|PFLAG_WRITEABLE|PFLAG_NOCODE;
+	PAGING_UnlinkPages(base_addr[0]>>12, GLIDE_PAGES);
+#if LOG_GLIDE
+	LOG_MSG("Glide:GLIDE_PageHandler installed at 0x%x", base_addr[0]);
+#endif
+    }
+
+    ~GLIDE_PageHandler() {
+#if LOG_GLIDE
+	LOG_MSG("Glide:Resetting page handler at 0x%x", base_addr[0]);
+#endif
+	PAGING_UnlinkPages(base_addr[0]>>12, GLIDE_PAGES);
+    }
+
+    void SetLFBAddr(HostPt addr, Bitu buffer) {
+	if(buffer >= GLIDE_BUFFERS) return;
+
+	addr = addr - base_addr[buffer];	/* Calculate offset for current buffer */
+
+	if(addr != lfb_addr[buffer]) {
+	    lfb_addr[buffer] = addr;
+#if LOG_GLIDE
+	    LOG_MSG("Glide:LFB for buffer %d offset set to 0x%p (addr: 0x%p), clear TLB", buffer, lfb_addr[buffer], addr+base_addr[buffer]);
+#endif
+	    PAGING_UnlinkPages(base_addr[buffer]>>12, 1<<GLIDE_PAGE_BITS);
+	}
+    }
+
+    PhysPt GetPhysPt(Bitu buffer = 0) {
+	if(buffer >= GLIDE_BUFFERS) return base_addr[0];
+	return base_addr[buffer];
+    }
+
+    void SetLinPt(PhysPt linaddr) {
+	for(int i = 0; i < GLIDE_BUFFERS; i++) {
+	    lin_addr[i] = linaddr;
+	    linaddr += ((1<<GLIDE_PAGE_BITS)<<12);
+	}
+    }
+
+    PhysPt GetLinPt(Bitu buffer = 0) {
+	if(buffer >= GLIDE_BUFFERS) return lin_addr[0];
+	return lin_addr[buffer];
+    }
+
+    Bitu readb(PhysPt addr) {
+//	LOG_MSG("Glide:Read from 0x%p", LFB_getAddr(addr));
+	return *(Bit8u *)(LFB_getAddr(addr));
+    }
+
+    Bitu readw(PhysPt addr) {
+//	LOG_MSG("Glide:Read from 0x%p", LFB_getAddr(addr));
+	return *(Bit16u *)(LFB_getAddr(addr));
+    }
+
+    Bitu readd(PhysPt addr) {
+//	LOG_MSG("Glide:Read from 0x%p", LFB_getAddr(addr));
+	return *(Bit32u *)(LFB_getAddr(addr));
+    }
+
+    void writeb(PhysPt addr,Bitu val) {
+//	LOG_MSG("Glide:Write to 0x%p", LFB_getAddr(addr));
+	*(Bit8u *)(LFB_getAddr(addr))=(Bit8u)val;
+    }
+
+    void writew(PhysPt addr,Bitu val) {
+//	LOG_MSG("Glide:Write to 0x%p", LFB_getAddr(addr));
+	*(Bit16u *)(LFB_getAddr(addr))=(Bit16u)val;
+    }
+
+    void writed(PhysPt addr,Bitu val) {
+//	LOG_MSG("Glide:Write to 0x%p", LFB_getAddr(addr));
+	*(Bit32u *)(LFB_getAddr(addr))=(Bit32u)val;
+    }
+
+    HostPt GetHostReadPt(Bitu phys_page) {
+	Bitu buffer = (((phys_page<<12) - base_addr[0])>>12)>>GLIDE_PAGE_BITS;
+#if LOG_GLIDE
+	// This only makes sense if full lfb access is used...
+	if (!locked[buffer]) LOG_MSG("Glide:Read from unlocked LFB at: 0x%x", phys_page<<12);
+#endif
+//	LOG_MSG("Glide:GetHostReadPt called with %d, returning 0x%p", phys_page, LFB_getAddr((phys_page*MEM_PAGESIZE)));
+	return lfb_addr[buffer]+(phys_page<<12);
+    }
+
+    HostPt GetHostWritePt(Bitu phys_page) {
+	Bitu buffer = (((phys_page<<12) - base_addr[0])>>12)>>GLIDE_PAGE_BITS;
+#if LOG_GLIDE
+	// This only makes sense if full lfb access is used...
+	if (!locked[buffer]) LOG_MSG("Glide:Write to unlocked LFB at: 0x%x", phys_page<<12);
+#endif
+//	LOG_MSG("Glide:GetHostWritePt called with %d, returning 0x%p", phys_page, LFB_getAddr((phys_page*MEM_PAGESIZE)));
+	return lfb_addr[buffer]+(phys_page<<12);
+    }
+
+    #undef LFB_getAddr
+};
+
+class GLIDE: public Module_base {
+private:
+    AutoexecObject autoexecline;
+    // Glide port
+    Bitu glide_base;
+    Bit8u *ovl_data;
+public:
+    GLIDE(Section* configuration):Module_base(configuration),glide_base(0),ovl_data(NULL) {
+	Section_prop * section=static_cast<Section_prop *>(configuration);
+
+	if(!section->Get_bool("glide")) return;
+	std::string str = section->Get_string("lfb");
+	lowcase(str);
+	if(str == "none") {
+	    LOG_MSG("Glide:Disabled LFB access");
+	    lfbacc=0;
+	} else if(str == "read_noaux") {
+	    LOG_MSG("Glide:LFB access: read-only (no aux)");
+	    lfbacc=1;
+	} else if(str == "write_noaux") {
+	    LOG_MSG("Glide:LFB access: write-only (no aux)");
+	    lfbacc=2;
+	} else if(str == "full_noaux") {
+	    LOG_MSG("Glide:LFB access: read-write (no aux)");
+	    lfbacc=3;
+	} else if(str == "read") {
+	    LOG_MSG("Glide:LFB access: read-only");
+	    lfbacc=5;
+	} else if(str == "write") {
+	    LOG_MSG("Glide:LFB access: write-only");
+	    lfbacc=6;
+	} else {
+	    LOG_MSG("Glide:LFB access: read-write");
+	    lfbacc=7;
+	}
+
+	// Load glide2x.dll
+#if defined(WIN32)
+	hdll = LoadLibrary("glide2x.dll");
+#elif defined(MACOSX)
+	hdll = dlopen("libglide2x.dylib", RTLD_NOW);
+#else
+	hdll = dlopen("libglide2x.so", RTLD_NOW);
+#endif
+
+	if(!hdll) {
+	    LOG_MSG("Glide:Unable to load glide2x library, glide emulation disabled");
+	    return;
+	}
+
+	// Allocate some temporary space
+	texmem = (void*)malloc(1600*1200*4);
+	if(texmem == NULL) {
+	    LOG_MSG("Glide:Unable to allocate texture memory, glide disabled");
+	    return;
+	}
+
+	glide.lfb_pagehandler = new GLIDE_PageHandler((HostPt)texmem);
+	if(!glide.lfb_pagehandler) {
+	    LOG_MSG("Glide:Failed to install page handler, glide disabled!");
+	    free(texmem); texmem = NULL;
+	    return;
+	}
+
+	// Load glide2x.ovl if possible, so it is available on the Z: drive
+	const char ovl_name[] = "glide2x.ovl";
+
+#if defined (WIN32)
+	// Windows is simple, the search is case insensitive
+	FILE * ovl = fopen(ovl_name, "rb");
+
+	// if not successful try to specifically search dosbox directory
+	if (ovl == NULL) {
+	    char * path = (char*)texmem;
+	    GetModuleFileName(NULL, path, 32768);
+	    // strip "\dosbox.exe" from path
+	    PathRemoveFileSpec(path);
+	    strcat(path, "\\"); strcat(path, ovl_name);
+	    ovl = fopen(path, "rb");
+	}
+
+#else
+	// Try a bit harder in *nix, perform case insensitive search and check /usr/share/dosbox as well
+	DIR * pdir; struct dirent * pfile;
+	char * path = (char*)texmem;
+	FILE * ovl = NULL;
+
+	const char * const dirname[] = { "./", "/usr/share/dosbox/", NULL };
+
+	for (int i = 0; dirname[i]; i++) {
+	    if((pdir = opendir(dirname[i]))) {
+		while(pfile = readdir(pdir)) {
+		    if(!strcasecmp(pfile->d_name, ovl_name)) {
+			strcpy(path, dirname[i]); strcat(path, pfile->d_name);
+			ovl = fopen(path, "rb");
+			if(ovl) break;
+		    }
+		}
+		closedir(pdir);
+		if(ovl) break;
+	    }
+	}
+#endif
+
+	long ovl_size = 0;
+
+	if(ovl == NULL) {
+	    LOG_MSG("Glide:GLIDE2X.OVL could not be found, make sure correct (compatible) version is in the game directory!");
+	} else {
+	    fseek(ovl, 0, SEEK_END);
+	    ovl_size=ftell(ovl);
+	    ovl_data=(Bit8u*)malloc(ovl_size);
+	    fseek(ovl, 0, SEEK_SET);
+	    fread(ovl_data, sizeof(char), ovl_size, ovl);
+	    fclose(ovl);
+	}
+
+#if LOG_GLIDE
+	SDL_memset(GLIDE_count, 0, sizeof(GLIDE_count));
+#endif
+
+	// Allocate memory for dll pointers
+	fn_pt = (void**)malloc(sizeof(void*)*(GLIDE_MAX+1));
+	if(fn_pt == NULL) {
+	    LOG_MSG("Glide:Unable to allocate memory, glide disabled");
+	    free(texmem); texmem = NULL;
+	    if(ovl_data) free(ovl_data); ovl_data = NULL;
+	    return;
+	}
+
+	for(int i=0; i<(GLIDE_MAX+1); i++) {
+#if defined(WIN32)
+	    ostringstream temp;
+	    // Add function decoration
+	    temp << "_" << grTable[i].name << "@" << (Bitu)grTable[i].parms;
+	    fn_pt[i] = (void*)(GetProcAddress(hdll, temp.str().c_str()));
+#else
+	    fn_pt[i] = (void*)(dlsym(hdll, grTable[i].name));
+#endif
+#if LOG_GLIDE
+	    if(fn_pt[i] == NULL) {
+		LOG_MSG("Glide:Warning, unable to load %s from glide2x", grTable[i].name);
+	    }
+#endif
+	}
+
+	//glide_base=section->Get_hex("grport");
+	glide_base=0x600;	// Anybody else got a better idea?
+
+	IO_RegisterReadHandler(glide_base,read_gl,IO_MB);
+	IO_RegisterWriteHandler(glide_base,write_gl,IO_MB);
+
+	ostringstream temp;
+	temp << "SET GLIDE=" << hex << glide_base << ends;
+
+	autoexecline.Install(temp.str());
+	glide.splash = section->Get_bool("splash");
+
+	if(ovl_data) {
+	    VFILE_Register("GLIDE2X.OVL", ovl_data, ovl_size);
+	}
+    }
+
+    ~GLIDE() {
+	if(glide.enabled) {
+	    // void grGlideShutdown(void)
+	    FP.grFunction0 = (pfunc0)fn_pt[_grGlideShutdown0];
+	    if(FP.grFunction0) FP.grFunction0();
+	    glide.enabled = false;
+	}
+
+	SAFE_DELETE(glide.lfb_pagehandler);
+	if(fn_pt)
+	    free(fn_pt); fn_pt = NULL;
+	if(texmem)
+	    free(texmem); texmem = NULL;
+
+	if(glide_base) {
+	    IO_FreeReadHandler(glide_base,IO_MB);
+	    IO_FreeWriteHandler(glide_base,IO_MB);
+	}
+
+	if(hdll) {
+#if defined (WIN32)
+	    FreeLibrary(hdll);
+#else
+	    dlclose(hdll);
+#endif
+	    hdll = NULL;
+	}
+
+	VFILE_Remove("GLIDE2X.OVL");
+	if(ovl_data) free(ovl_data);
+    }
+};
+
+static GLIDE* test;
+void GLIDE_ShutDown(Section* sec) {
+    delete test;
+}
+
+void GLIDE_Init(Section* sec) {
+    test = new GLIDE(sec);
+    sec->AddDestroyFunction(&GLIDE_ShutDown,true);
+}
+
+SDL_Surface* SDL_SetVideoMode_Wrap(int width,int height,int bpp,Bit32u flags);
+void GLIDE_ResetScreen(bool update)
+{
+#if LOG_GLIDE
+	LOG_MSG("Glide:ResetScreen");
+#endif
+	VGA_SetOverride(true);
+	GFX_Stop();
+
+	// OpenGlide will resize the window on it's own (using SDL)
+	if(glide.width && (
+#ifdef WIN32
+	// dgVoodoo needs a little help :)
+	// Most other wrappers render fullscreen by default
+	  (GetProcAddress(hdll, "DispatchDosNT") != NULL) ||
+#endif
+	// and resize when mapper and/or GUI finish
+	  update)) {
+	    SDL_SetVideoMode_Wrap(glide.width,glide.height,0,
+		(glide.fullscreen[0]?SDL_FULLSCREEN:0)|SDL_ANYFORMAT|SDL_SWSURFACE);
+	}
+}
+
+void GLIDE_DisableScreen(void)
+{
+	glide.enabled = false;	/* if not disabled, GFX_ResetScreen() will call GLIDE_ResetScreen() */
+	VGA_SetOverride(false);
+	GFX_ResetScreen();
+}
+
+static bool GetFileName(char * filename)
+{
+    localDrive	*ldp;
+    Bit8u	drive;
+    char	fullname[DOS_PATHLENGTH];
+
+    // Get full path
+    if(!DOS_MakeName(filename,fullname,&drive)) return false;
+
+#if LOG_GLIDE
+    LOG_MSG("Glide:Fullname: %s", fullname);
+#endif
+
+    // Get real system path
+    ldp = dynamic_cast<localDrive*>(Drives[drive]);
+    if(ldp == NULL) return false;
+
+    ldp->GetSystemFilename(filename,fullname);
+#if LOG_GLIDE
+    LOG_MSG("Glide:System path: %s", filename);
+#endif
+    return true;
+}
+
+typedef FxBool (FX_CALL *pfxSplashInit)(FxU32 hWnd, FxU32 screenWidth, FxU32 screenHeight,
+					FxU32 numColBuf, FxU32 numAuxBuf, GrColorFormat_t colorFormat);
+typedef void (FX_CALL *pfxSplash)(float x, float y, float w, float h, FxU32 frameNumber);
+
+static void grSplash(void)
+{
+#ifdef WIN32
+    FxU32 screenWidth = glide.width, screenHeight = glide.height;
+    HINSTANCE dll = LoadLibrary("3dfxSpl2.dll");
+    if(dll == NULL) {
+	return;
+    }
+
+    pfxSplashInit fxSplashInit = (pfxSplashInit)GetProcAddress(dll, "_fxSplashInit@24");
+    pfxSplash fxSplash = (pfxSplash)GetProcAddress(dll, "_fxSplash@20");
+
+    if((fxSplashInit == NULL) || (fxSplash == NULL)) {
+	FreeLibrary(dll);
+	return;
+    }
+
+    if (screenWidth == 0) {
+	screenWidth = 640;
+	screenHeight = 480;
+    }
+
+    fxSplashInit(0, screenWidth, screenHeight, 2, 1, GR_COLORFORMAT_ABGR);
+    fxSplash(0, 0, screenWidth, screenHeight, 0);
+
+    // OpenGlide does not restore this state
+    FP.grFunction1i = (pfunc1i)fn_pt[_grSstOrigin4];
+    if(FP.grFunction1i) {
+	FP.grFunction1i(GrOriginLocation);
+    }
+
+    FreeLibrary(dll);
+#endif
+}
+
+static void process_msg(Bitu value)
+{
+    GrLfbInfo_t   lfbinfo;
+    DBGrLfbInfo_t dblfbinfo;
+
+    GrTexInfo     texinfo;
+    DBGrTexInfo   dbtexinfo;
+
+    Gu3dfInfo     guinfo;
+    DBGu3dfInfo   dbguinfo;
+
+    GrVertex      vertex[3];
+
+    GrMipMapInfo * mipmap;
+
+    // Temporary memory used in functions
+    FxI32	* ilist = (FxI32*)texmem;
+    FxU16	* ptr16 = (FxU16*)texmem;
+
+    // Filename translation
+    char	  filename[512];
+
+    // Used so that the pagehandler returns the same address after buffer swap
+    static char	  b_swap = 0;
+
+    // Return value address
+    ret = param[0];
+    Bitu i = value;
+    Bitu buffer;
+    FxU32 j, k;
+
+    if((i > GLIDE_MAX) || (fn_pt[i] == NULL)) {
+	LOG_MSG("Glide:Invalid function pointer for call %s", (i > GLIDE_MAX) ? "(invalid)" : grTable[i].name);
+	return;
+    }
+
+#if LOG_GLIDE
+    LOG_MSG("Glide:Processing call %s (%d), return address: 0x%x", grTable[i].name, value, ret);
+    GLIDE_count[i]++;
+#endif
+
+    switch (value) {
+
+    case _grAADrawLine8:
+	// void grAADrawLine(GrVertex *va, GrVertex *vb)
+	FP.grFunction2p = (pfunc2p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	FP.grFunction2p(&vertex[0], &vertex[1]);
+	break;
+    case _grAADrawPoint4:
+	// void grAADrawPoint(GrVertex *p)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	FP.grFunction1p(&vertex[0]);
+	break;
+    case _grAADrawPolygon12:
+	// void grAADrawPolygon(int nVerts, const int ilist[], const GrVertex vlist[])
+	FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	i = sizeof(FxI32)*param[1];
+	MEM_BlockRead32(param[2], ilist, i);
+
+	// Find the number of vertices (?)
+	k = 0;
+	for(j = 0; j < param[1]; j++) {
+	    if(ilist[j] > k)
+		k = ilist[j];
+	}
+	k++;
+
+	MEM_BlockRead32(param[3], ilist+i, sizeof(GrVertex)*k);
+	FP.grFunction1i2p(param[1], ilist, ilist+i);
+	break;
+    case _grAADrawPolygonVertexList8:
+	// void grAADrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _grAADrawTriangle24:
+	// void grAADrawTriangle(GrVertex *a, GrVertex *b, GrVertex *c,
+	//	FxBool antialiasAB, FxBool antialiasBC, FxBool antialiasCA)
+	FP.grFunction3p3i = (pfunc3p3i)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p3i(&vertex[0], &vertex[1], &vertex[2], param[4], param[5], param[6]);
+	break;
+    case _grAlphaBlendFunction16:
+	// void grAlphaBlendFunction(GrAlphaBlendFnc_t rgb_sf, GrAlphaBlendFnc_t rgb_df,
+	//		GrAlphaBlendFnc_t alpha_sf, GrAlphaBlendFnc_t alpha_df)
+	if(tomb == 1) {
+	    if((FP.grFunction1i = (pfunc1i)fn_pt[_grConstantColorValue4]))
+		FP.grFunction1i(0x7f000000);
+	} else if(tomb == 2) {
+	    float color1 = 127.0;
+	    float color2 = 0.0;
+	    if((FP.grFunction4f = (pfunc4f)fn_pt[_grConstantColorValue416]))
+		FP.grFunction4f(color1, color2, color2, color2);
+	}
+	FP.grFunction4i = (pfunc4i)fn_pt[i];
+	FP.grFunction4i(param[1], param[2], param[3], param[4]);
+	break;
+    case _grAlphaCombine20:
+	// void grAlphaCombine(GrCombineFunction_t func, GrCombineFactor_t factor,
+	//		GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+	FP.grFunction5i = (pfunc5i)fn_pt[i];
+	FP.grFunction5i(param[1], param[2], param[3], param[4], param[5]);
+	break;
+    case _grAlphaControlsITRGBLighting4:
+	// void grAlphaControlsITRGBLighting(FxBool enable)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grAlphaTestFunction4:
+	// void grAlphaTestFunction(GrCmpFnc_t function)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grAlphaTestReferenceValue4:
+	// void grAlphaTestReferenceValue(GrAlpha_t value)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grBufferClear12:
+	// void grBufferClear(GrColor_t color, GrAlpha_t alpha, FxU16 depth)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grBufferNumPending0:
+	// int grBufferNumPending(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grBufferSwap4:
+	// void grBufferSwap(int swap_interval)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	/* Breaks Extreme Assault (which always writes to same address ?) */
+	//if(!(glide.lfb_pagehandler->locked[0] || glide.lfb_pagehandler->locked[1])) b_swap = !b_swap;
+#if LOG_GLIDE
+	LOG_MSG("Glide:BufferSwap (0x%x)", b_swap);
+#endif
+	break;
+    case _grCheckForRoom4:
+	// void grCheckForRoom(FxI32 n)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grChromakeyMode4:
+	// void grChromakeyMode(GrChromakeyMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grChromakeyValue4:
+	// void grChromakeyValue(GrColor_t value)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grClipWindow16:
+	// void grClipWindow(FxU32 minx, FxU32 miny, FxU32 maxx, FxU32 maxy)
+	FP.grFunction4i = (pfunc4i)fn_pt[i];
+	FP.grFunction4i(param[1], param[2], param[3], param[4]);
+	break;
+    case _grColorCombine20:
+	// void grColorCombine(GrCombineFunction_t func, GrCombineFactor_t factor,
+	//		GrCombineLocal_t local, GrCombineOther_t other, FxBool invert)
+	FP.grFunction5i = (pfunc5i)fn_pt[i];
+	FP.grFunction5i(param[1], param[2], param[3], param[4], param[5]);
+	break;
+    case _grColorMask8:
+	// void grColorMask(FxBool rgb, FxBool alpha)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grConstantColorValue416:
+	// void grConstantColorValue4(float a, float r, float g, float b)
+	FP.grFunction4f = (pfunc4f)fn_pt[i];
+	FP.grFunction4f(int_to_float(param[1]), int_to_float(param[2]), int_to_float(param[3]), int_to_float(param[4]));
+	break;
+    case _grConstantColorValue4:
+	// void grConstantColorValue(GrColor_t color)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grCullMode4:
+	// void grCullMode(GrCullMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthBiasLevel4:
+	// void grDepthBiasLevel(FxI16 level)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthBufferFunction4:
+	// void grDepthBufferFunction(GrCmpFnc_t func)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthBufferMode4:
+	// void grDepthBufferMode(GrDepthBufferMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDepthMask4:
+	// void grDepthMask(FxBool enable)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDisableAllEffects0:
+	// void grDisableAllEffects(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grDitherMode4:
+	// void grDitherMode(GrDitherMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grDrawLine8:
+	// void grDrawLine(const GrVertex *a, const GrVertex *b)
+	FP.grFunction2p = (pfunc2p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	FP.grFunction2p(&vertex[0], &vertex[1]);
+	break;
+    case _grDrawPlanarPolygon12:
+	// void grDrawPlanarPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+	FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	i = sizeof(FxI32)*param[1];
+	MEM_BlockRead32(param[2], ilist, i);
+
+	// Find the number of vertices (?)
+	k = 0;
+	for(j = 0; j < param[1]; j++) {
+	    if(ilist[j] > k)
+		k = ilist[j];
+	}
+	k++;
+
+	MEM_BlockRead32(param[3], ilist+i, sizeof(GrVertex)*k);
+	FP.grFunction1i2p(param[1], ilist, ilist+i);
+	break;
+    case _grDrawPlanarPolygonVertexList8:
+	// void grDrawPlanarPolygonVertexList(int nVertices, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _grDrawPoint4:
+	// void grDrawPoint(const GrVertex *a)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	FP.grFunction1p(&vertex[0]);
+	break;
+    case _grDrawPolygon12:
+	// void grDrawPolygon(int nVerts, int ilist[], const GrVertex vlist[])
+	FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	i = sizeof(FxI32)*param[1];
+	MEM_BlockRead32(param[2], ilist, i);
+
+	// Find the number of vertices (?)
+	k = 0;
+	for(j = 0; j < param[1]; j++) {
+	    if(ilist[j] > k)
+		k = ilist[j];
+	}
+	k++;
+
+	MEM_BlockRead32(param[3], ilist+i, sizeof(GrVertex)*k);
+	FP.grFunction1i2p(param[1], ilist, ilist+i);
+	break;
+    case _grDrawPolygonVertexList8:
+	// void grDrawPolygonVertexList(int nVerts, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _grDrawTriangle12:
+	// void grDrawTriangle(const GrVertex *a, const GrVertex *b, const GrVertex *c)
+	FP.grFunction3p = (pfunc3p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p(&vertex[0], &vertex[1], &vertex[2]);
+	break;
+/*
+    case _grErrorSetCallback4:
+	// void grErrorSetCallback(void (*function)(const char *string, FxBool fatal))
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(*param[1]);
+	break;
+*/
+    case _grFogColorValue4:
+	// void grFogColorValue(GrColor_t value)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grFogMode4:
+	// void grFogMode(GrFogMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grFogTable4:
+	// void grFogTable(const GrFog_t grTable[GR_FOG_TABLE_SIZE])
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrFog_t)*GR_FOG_TABLE_SIZE);
+	FP.grFunction1p(texmem);
+	break;
+    case _grGammaCorrectionValue4:
+	// void grGammaCorrectionValue(float value)
+	FP.grFunction1f = (pfunc1f)fn_pt[i];
+	FP.grFunction1f(int_to_float(param[1]));
+	break;
+    case _grGlideGetState4:
+	// void grGlideGetState(GrState *state)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrState));
+	FP.grFunction1p(texmem);
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrState));
+	break;
+    case _grGlideGetVersion4:
+	// void grGlideGetVersion(char version[80])
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	FP.grFunction1p(filename);
+	k = 0;
+	do {
+	    mem_writeb(param[1]++, filename[k++]);
+	} while(filename[k] != '\0');
+	mem_writeb(param[1], '\0');
+	break;
+    case _grGlideInit0:
+	// void grGlideInit(void)
+	if(glide.enabled) break;	/* Tie Break Tennis */
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+
+	// Enable Tomb Rider displaying shadow
+	if(!strncasecmp(RunningProgram, "Tombub", 6)) tomb = 2;
+	else if(!strncasecmp(RunningProgram, "Tomb", 4)) tomb = 1;
+	else tomb = 0;
+
+	// Send LFB to the OVL (so it can map it in linear address)
+	if(mem_readd(param[1]) == 0xFFFFF1FB) {		// Find LFB magic
+	    mem_writed(param[1], glide.lfb_pagehandler->GetPhysPt());
+	    mem_writed(param[2], GLIDE_PAGES);
+	} else {
+	    LOG_MSG("Glide:Detected incompatible guest ovl/dll!");
+	}
+	break;
+    case _grGlideSetState4:
+	// void grGlideSetState(const GrState *state)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrState));
+	FP.grFunction1p(texmem);
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrState));
+	break;
+    case _grGlideShamelessPlug4:
+	// void grGlideShamelessPlug(const FxBool on)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grGlideShutdown0: {
+	// void grGlideShutdown(void)
+	if(glide.enabled) {
+	    FP.grFunction0 = (pfunc0)fn_pt[_grSstWinClose0];
+	    FP.grFunction0();
+	    GLIDE_DisableScreen();
+	}
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+
+	Section_prop *section=static_cast<Section_prop *>(control->GetSection("glide"));
+	if (section) glide.splash = section->Get_bool("splash");
+
+#if LOG_GLIDE
+	for(j=0;j<(GLIDE_MAX+1);j++) {
+	    if(GLIDE_count[j]) {
+		LOG_MSG("Glide:%6d calls function %s (%d)", GLIDE_count[j], grTable[j].name, j);
+	    }
+	}
+	LOG_MSG("Glide: %d framebuffer locks (%d read, %d write)", GLIDE_count[_grLfbLock24],
+	    GLIDE_count[GLIDE_MAX+1], GLIDE_count[_grLfbLock24] - GLIDE_count[GLIDE_MAX+1]);
+	SDL_memset(GLIDE_count, 0, sizeof(GLIDE_count));
+#endif
+	break;
+	}
+    case _grHints8:
+	// void grHints(GrHints_t type, FxU32 hintMask)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grLfbConstantAlpha4:
+	// void grLfbConstantAlpha(GrAlpha_t alpha)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grLfbConstantDepth4:
+	// void grLfbConstantDepth(FxU16 depth)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grLfbLock24:
+	// FxBool grLfbLock(GrLock_t type, GrBuffer_t buffer, GrLfbWriteMode_t writeMode,
+	//		GrOriginLocation_t origin, FxBool pixelPipeline, GrLfbInfo_t *info)
+	FP.grRFunction5i1p = (prfunc5i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	buffer = (Bitu)param[2];
+	if (buffer >= GLIDE_BUFFERS) {
+	    LOG_MSG("Glide:Invalid buffer passed in grLfbLock (%d)", buffer);
+	    return;
+	}
+
+	// Buffer address should stay the same after BufferSwap, so check which buffer to lock
+	// (currently disabled, see _grBufferSwap4)
+	//if (buffer < 2) buffer = buffer ^ b_swap;
+
+	// Read parameters
+	MEM_BlockRead32(param[6], &dblfbinfo, sizeof(DBGrLfbInfo_t));
+	lfbinfo.size = sizeof(GrLfbInfo_t);
+	lfbinfo.origin = dblfbinfo.origin;
+	lfbinfo.lfbPtr = texmem;
+
+	k = FXTRUE;
+	j = param[1]&1; j++;
+	j = j&lfbacc;				// Check LFB access (j = 0 : fake lock)
+	if((buffer > 1) && (lfbacc < 4)) j = 0;	// Disable access to AUX buffers
+
+	if(j) {
+		// Lock the buffer
+		k = FP.grRFunction5i1p(param[1], param[2], param[3], param[4], param[5], &lfbinfo);
+		if(k == FXTRUE) {
+		    glide.lfb_pagehandler->locked[buffer]++;
+		    dblfbinfo.writeMode = lfbinfo.writeMode;
+		    dblfbinfo.strideInBytes = lfbinfo.strideInBytes;
+		    dblfbinfo.lfbPtr = glide.lfb_pagehandler->GetLinPt(buffer);
+		    MEM_BlockWrite32(param[6], &dblfbinfo, sizeof(DBGrLfbInfo_t));
+		} else {
+		    LOG_MSG("Glide:LFB Lock failed!");
+		    //k = FXFALSE;	// Lock failed ?
+		}
+	} else {
+		// else lock is faked (texmem used for read/write)
+		if(param[3] == GR_LFBWRITEMODE_ANY) dblfbinfo.writeMode = GR_LFBWRITEMODE_565;
+		else dblfbinfo.writeMode = param[3];
+
+		if(param[4] == GR_ORIGIN_ANY) dblfbinfo.origin = GR_ORIGIN_UPPER_LEFT;
+		else dblfbinfo.origin = param[4];
+
+		dblfbinfo.strideInBytes = ((glide.width>0) ? glide.width : 1600) * 4;
+		dblfbinfo.lfbPtr = glide.lfb_pagehandler->GetLinPt(buffer);
+
+		//if(!(param[1]&GR_LFB_WRITE_ONLY)) SDL_memset(texmem, 0, 1600*1200*4);	// Clear memory on read-lock
+
+		MEM_BlockWrite32(param[6], &dblfbinfo, sizeof(DBGrLfbInfo_t));
+	}
+
+	// Set LFB address for page handler to read from/write to
+	glide.lfb_pagehandler->SetLFBAddr((HostPt)lfbinfo.lfbPtr, buffer);
+	if(dblfbinfo.strideInBytes > 1600*4) LOG_MSG("Glide:WARNING LFB stride (%d) is larger than max supported: %d!", dblfbinfo.strideInBytes, 1600*4);
+
+	if(param[1]&GR_LFB_WRITE_ONLY) {	// Is a write-only lock
+#if LOG_GLIDE
+		LOG_MSG("Glide:W/O lock (%d). %s LFB: 0x%p. Returning 0x%x (stride: %d)", param[2], (j ? "Real" : "Fake"),
+			lfbinfo.lfbPtr, dblfbinfo.lfbPtr, dblfbinfo.strideInBytes);
+#endif
+	} else {	// Is a read-only lock
+#if LOG_GLIDE
+		LOG_MSG("Glide:R/O lock (%d). %s LFB: 0x%p. Returning 0x%x (stride: %d)", param[2], (j ? "Real" : "Fake"),
+			lfbinfo.lfbPtr, dblfbinfo.lfbPtr, dblfbinfo.strideInBytes);
+		GLIDE_count[GLIDE_MAX+1]++;
+#endif
+	}
+
+	mem_writed(ret, k);
+	ret_value = G_OK;
+	break;
+    case _grLfbReadRegion28:
+	// FxBool grLfbReadRegion(GrBuffer_t src_buffer, FxU32 src_x, FxU32 src_y, FxU32 src_width,
+	//		FxU32 src_height, FxU32 dst_stride, void *dst_data)
+	FP.grRFunction6i1p = (prfunc6i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction6i1p(param[1], param[2], param[3], param[4], param[5], param[6], ptr16));
+	MEM_BlockWrite(param[7], ptr16, param[5]*param[6]);
+	ret_value = G_OK;
+	break;
+    case _grLfbUnlock8:
+	// FxBool grLfbUnlock(GrLock_t type, GrBuffer_t buffer)
+	FP.grRFunction2i = (prfunc2i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle (%d)!", _grLfbUnlock8);
+	    return;
+	}
+	k = FXTRUE;
+	buffer = param[2];
+	if (buffer < 2) buffer = buffer ^ b_swap;
+#if LOG_GLIDE
+	LOG_MSG("Glide:LFB unlock buffer (%d), %d locks active", param[2], glide.lfb_pagehandler->locked[buffer]);
+#endif
+	if(glide.lfb_pagehandler->locked[buffer]) {
+	    k = FP.grRFunction2i(param[1], param[2]);
+	    glide.lfb_pagehandler->locked[buffer]--;
+	    glide.lfb_pagehandler->SetLFBAddr((HostPt)texmem, buffer);	// Reset page handler and clear TLB
+	} else {
+	    //k = FXFALSE;
+	}
+	mem_writed(ret, k);
+	ret_value = G_OK;
+	break;
+    case _grLfbWriteColorFormat4:
+	// void grLfbWriteColorFormat(GrColorFormat_t colorFormat)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grLfbWriteColorSwizzle8:
+	// void grLfbWriteColorSwizzle(FxBool swizzleBytes, FxBool swapWords)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grLfbWriteRegion32:
+	// FxBool grLfbWriteRegion(GrBuffer_t dst_buffer, FxU32 dst_x, FxU32 dst_y,
+	//	GrLfbSrcFmt_t src_format, FxU32 src_width, FxU32 src_height, FxU32 src_stride, void *src_data)
+	FP.grRFunction7i1p = (prfunc7i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	MEM_BlockRead(param[8], ptr16, param[6]*param[7]);
+	mem_writed(ret, FP.grRFunction7i1p(param[1], param[2], param[3], param[4], param[5], param[6], param[7], ptr16));
+	ret_value = G_OK;
+	break;
+    case _grRenderBuffer4:
+	// void grRenderBuffer(GrBuffer_t buffer)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grResetTriStats0:
+	// void grResetTriStats()
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grSplash20:
+	// void grSplash(float x, float y, float width, float height, FxU32 frame)
+	FP.grFunction4f1i = (pfunc4f1i)fn_pt[i];
+	FP.grFunction4f1i(int_to_float(param[1]), int_to_float(param[2]), int_to_float(param[3]), int_to_float(param[4]), param[5]);
+	break;
+/*
+    case _grSstConfigPipeline12:
+	//
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i();
+	break;
+*/
+    case _grSstControl4:
+	// FxBool grSstControl(FxU32 code)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _grSstIdle0:
+	// void grSstIdle(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grSstIsBusy0:
+	// FxBool grSstIsBusy(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstOrigin4:
+	// void grSstOrigin(GrOriginLocation_t origin)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	GrOriginLocation = param[1];
+	break;
+    case _grSstPerfStats4:
+	// void grSstPerfStats(GrSstPerfStats_t *pStats)
+	FP.grFunction1p = (pfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrSstPerfStats_t));
+	FP.grFunction1p(texmem);
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrSstPerfStats_t));
+	break;
+    case _grSstQueryBoards4:
+	// FxBool grSstQueryBoards(GrHwConfiguration *hwConfig)
+	FP.grRFunction1p = (prfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrHwConfiguration));
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1p(texmem));
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrHwConfiguration));
+	ret_value = G_OK;
+	break;
+    case _grSstQueryHardware4:
+	// FxBool grSstQueryHardware(GrHwConfiguration *hwConfig)
+	FP.grRFunction1p = (prfunc1p)fn_pt[i];
+	MEM_BlockRead32(param[1], texmem, sizeof(GrHwConfiguration));
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1p(texmem));
+	MEM_BlockWrite32(param[1], texmem, sizeof(GrHwConfiguration));
+	ret_value = G_OK;
+	break;
+    case _grSstResetPerfStats0:
+	// void grSstResetPerfStats(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _grSstScreenHeight0:
+	// FxU32 grSstScreenHeight(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstScreenWidth0:
+	// FxU32 grSstScreenWidth(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstSelect4:
+	// void grSstSelect(int which_sst)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _grSstStatus0:
+	// FxU32 grSstStatus(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstVRetraceOn0:
+	// FxBool grSstVRetraceOn(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+/*
+    case _grSstVidMode8:
+	//
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i();
+	break;
+*/
+    case _grSstVideoLine0:
+	// FxU32 grSstVideoLine(void)
+	FP.grRFunction0 = (prfunc0)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction0());
+	ret_value = G_OK;
+	break;
+    case _grSstWinClose0:
+	// void grSstWinClose(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	if(glide.enabled) {
+	    GLIDE_DisableScreen();
+	}
+	break;
+    case _grSstWinOpen28:
+	// FxBool grSstWinOpen(FxU32 hwnd, GrScreenResolution_t res, GrScreenRefresh_t ref,
+	//	GrColorFormat_t cformat, GrOriginLocation_t org_loc, int num_buffers, int num_aux_buffers)
+	FP.grRFunction1p6i = (prfunc1p6i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	/* Tie Break Tennis */
+	if(glide.enabled) {
+	    LOG_MSG("Glide:grSstWinOpen called when glide is active!");
+	    mem_writed(ret, FXTRUE);
+	    ret_value = G_OK;
+	    break;
+	}
+
+	// Check for successful memory map
+	if(mem_readd(param[10]) == 0) {
+	    LOG_MSG("Glide:LFB memory map failed, using default LFB address!");
+	    // Write physical address instead, it can crash but it just might work
+	    mem_writed(param[10], glide.lfb_pagehandler->GetPhysPt());
+	}
+
+	glide.enabled = true;
+	glide.width = param[8];
+	glide.height = param[9];
+	GrOriginLocation = param[5];
+
+	// Resize window and disable updates
+	GLIDE_ResetScreen(true);
+
+	statWMInfo();
+
+	k = FP.grRFunction1p6i(hwnd, param[2], param[3], param[4], param[5], param[6], param[7]);
+	if(k == FXFALSE) {
+	    LOG_MSG("Glide:grSstWinOpen failed!");
+	    GLIDE_DisableScreen();
+	    mem_writed(ret, FXFALSE);
+	    ret_value = G_OK;
+	    break;
+	}
+
+	mem_writed(ret, k);
+	if(glide.splash) {
+	    grSplash();
+	    glide.splash = false;
+	}
+
+	glide.lfb_pagehandler->SetLinPt(mem_readd(param[10]));
+	LOG_MSG("Glide:Resolution:%dx%d, LFB at 0x%x (physical) / 0x%x (linear)",
+		glide.width, glide.height, glide.lfb_pagehandler->GetPhysPt(), glide.lfb_pagehandler->GetLinPt());
+	ret_value = G_OK;
+	break;
+    case _grTexCalcMemRequired16:
+	// FxU32 grTexCalcMemRequired(GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspect,
+	//	    GrTextureFormat_t format)
+	FP.grRFunction4i = (prfunc4i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction4i(param[1], param[2], param[3], param[4]));
+	ret_value = G_OK;
+	break;
+    case _grTexClampMode12:
+	// void grTexClampMode(GrChipID_t tmu, GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grTexCombine28:
+	// void grTexCombine(GrChipID_t tmu, GrCombineFunction_t rgb_function, GrCombineFactor_t rgb_factor,
+	//	GrCombineFunction_t alpha_function, GrCombineFactor_t alpha_factor, FxBool rgb_invert,
+	//	FxBool alpha_invert)
+	FP.grFunction7i = (pfunc7i)fn_pt[i];
+	FP.grFunction7i(param[1], param[2], param[3], param[4], param[5], param[6], param[7]);
+	break;
+    case _grTexCombineFunction8:
+	// void grTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t fnc)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grTexDetailControl16:
+	// void grTexDetailControl(GrChipID_t tmu, int lodBias, FxU8 detailScale, float detailMax)
+	FP.grFunction3i1f = (pfunc3i1f)fn_pt[i];
+	FP.grFunction3i1f(param[1], param[2], param[3], int_to_float(param[4]));
+	break;
+    case _grTexDownloadMipMap16:
+	// void grTexDownloadMipMap(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	if(FP.grRFunction1i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+	    return;
+	}
+
+	MEM_BlockRead32(param[4], &dbtexinfo, sizeof(DBGrTexInfo));
+
+	texinfo.smallLod = dbtexinfo.smallLod;
+	texinfo.largeLod = dbtexinfo.largeLod;
+	texinfo.aspectRatio = dbtexinfo.aspectRatio;
+	texinfo.format = dbtexinfo.format;
+	texinfo.data = NULL;
+
+	// grTexTextureMemRequired
+	texsize = FP.grRFunction1i1p(param[3], &texinfo);
+	MEM_BlockRead(dbtexinfo.data, texmem, texsize);
+	texinfo.data = texmem;
+
+	FP.grFunction3i1p = (pfunc3i1p)fn_pt[i];
+	FP.grFunction3i1p(param[1], param[2], param[3], &texinfo);
+	break;
+    case _grTexDownloadMipMapLevel32:
+	// void grTexDownloadMipMapLevel(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod,
+	//	GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format,
+	//	FxU32 evenOdd, void *data)
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	if(FP.grRFunction1i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+	    return;
+	}
+
+	texinfo.smallLod = param[3];
+	texinfo.largeLod = param[3];		// Calculate only thisLod
+	texinfo.aspectRatio = param[5];
+	texinfo.format = param[6];
+	texinfo.data = NULL;
+
+	// grTexTextureMemRequired
+	texsize = FP.grRFunction1i1p(param[7], &texinfo);
+	MEM_BlockRead(param[8], texmem, texsize);
+
+#if LOG_GLIDE
+	LOG_MSG("Read %d (%d %d %d %d %d) bytes of texture data", texsize, param[3], param[4], param[5], param[6], param[7]);
+#endif
+
+	FP.grFunction7i1p = (pfunc7i1p)fn_pt[i];
+	FP.grFunction7i1p(param[1], param[2], param[3], param[4], param[5], param[6], param[7], texmem);
+	break;
+    case _grTexDownloadMipMapLevelPartial40:
+	// FX_ENTRY void FX_CALL grTexDownloadMipMapLevelPartial(GrChipID_t tmu, FxU32 startAddress,
+	//    GrLOD_t thisLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio, GrTextureFormat_t format,
+	//    FxU32 evenOdd, void *data, int start, int end);
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	if(FP.grRFunction1i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+	    return;
+	}
+
+	texinfo.smallLod = param[3];
+	texinfo.largeLod = param[3];		// Calculate only thisLod
+	texinfo.aspectRatio = param[5];
+	texinfo.format = param[6];
+	texinfo.data = NULL;
+
+	// grTexTextureMemRequired
+	texsize = FP.grRFunction1i1p(param[7], &texinfo);
+	MEM_BlockRead(param[8], texmem, texsize);
+
+	FP.grFunction7i1p2i = (pfunc7i1p2i)fn_pt[i];
+	FP.grFunction7i1p2i(param[1], param[2], param[3], param[4], param[5], param[6], param[7], texmem,
+			    param[9], param[10]);
+	break;
+    case _grTexDownloadTable12:
+	// void grTexDownloadTable(GrChipID_t tmu, GrTexTable_t type, void *data)
+	FP.grFunction2i1p = (pfunc2i1p)fn_pt[i];
+
+	if(param[2] == GR_TEXTABLE_PALETTE) {
+	    MEM_BlockRead32(param[3], texmem, sizeof(GuTexPalette));
+	} else { // GR_TEXTABLE_NCC0 or GR_TEXTABLE_NCC1
+	    MEM_BlockRead32(param[3], texmem, sizeof(GuNccTable));
+	}
+
+	FP.grFunction2i1p(param[1], param[2], texmem);
+	break;
+    case _grTexDownloadTablePartial20:
+	// void grTexDownloadTablePartial(GrChipID_t tmu, GrTexTable_t type, void *data, int start, int end)
+	FP.grFunction2i1p2i = (pfunc2i1p2i)fn_pt[i];
+
+	if(param[2] == GR_TEXTABLE_PALETTE) {
+	    MEM_BlockRead32(param[3], texmem, sizeof(GuTexPalette));
+	    FP.grFunction2i1p2i(param[1], param[2], texmem, param[4], param[5]);
+	} else { // GR_TEXTABLE_NCC0 or GR_TEXTABLE_NCC1
+	    LOG_MSG("Glide:Downloading partial NCC tables is not supported!");
+	}
+
+	break;
+    case _grTexFilterMode12:
+	// void grTexFilterMode(GrChipID_t tmu, GrTextureFilterMode_t minFilterMode,
+	//	GrTextureFilterMode_t magFilterMode)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grTexLodBiasValue8:
+	// void grTexLodBiasValue(GrChipID_t tmu, float bias)
+	FP.grFunction1i1f = (pfunc1i1f)fn_pt[i];
+	FP.grFunction1i1f(param[1], int_to_float(param[2]));
+	break;
+    case _grTexMaxAddress4:
+	// FxU32 grTexMaxAddress(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _grTexMinAddress4:
+	// FxU32 grTexMinAddress(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _grTexMipMapMode12:
+	// void grTexMipMapMode(GrChipID_t tmu, GrMipMapMode_t mode, FxBool lodBlend)
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i(param[1], param[2], param[3]);
+	break;
+    case _grTexMultibase8:
+	// void grTexMultibase(GrChipID_t tmu, FxBool enable)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+/*
+    case _grTexMultibaseAddress20:
+	// void grTexMultibaseAddress(GrChipID_t tmu, GrTexBaseRange_t range, FxU32 startAddress,
+	//	FxU32 evenOdd, GrTexInfo *info)
+	FP.grFunction4i1p = (pfunc4i1p)fn_pt[i];
+
+	// This is a bit more complicated since *info contains a pointer to data
+	texinfo = (GrTexInfo*)param[5];
+	data = (PhysPt)texinfo->data;			// Store for later reference
+	texinfo->data = VIRTOREAL(data);
+#if LOG_GLIDE
+	if(log_func[value-_grAADrawLine8] == 1) {
+	    LOG_MSG("Glide:Replacing pointer 0x%x with 0x%x in function %d", data, texinfo->data, _grTexMultibaseAddress20);
+	    log_func[value-_grAADrawLine8] = 2;
+	}
+#endif
+	FP.grFunction20(param[1], param[2], param[3], param[4], (int)texinfo);
+	texinfo->data = (void*)data;			// Change the pointer back
+	break;
+*/
+    case _grTexNCCTable8:
+	// void grTexNCCTable(GrChipID_t tmu, GrNCCTable_t table)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+    case _grTexSource16:
+	// void grTexSource(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+	FP.grFunction3i1p = (pfunc3i1p)fn_pt[i];
+
+	// Copy the data from DB struct
+	MEM_BlockRead32(param[4], &dbtexinfo, sizeof(DBGrTexInfo));
+
+	texinfo.smallLod = dbtexinfo.smallLod;
+	texinfo.largeLod = dbtexinfo.largeLod;
+	texinfo.aspectRatio = dbtexinfo.aspectRatio;
+	texinfo.format = dbtexinfo.format;
+	// Should the data pointer be filled ?
+
+	FP.grFunction3i1p(param[1], param[2], param[3], &texinfo);
+	break;
+    case _grTexTextureMemRequired8:
+	// FxU32 grTexTextureMemRequired(FxU32 evenOdd, GrTexInfo *info)
+	FP.grRFunction1i1p = (prfunc1i1p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	// Copy the data from DB struct
+	MEM_BlockRead32(param[2], &dbtexinfo, sizeof(DBGrTexInfo));
+
+	texinfo.smallLod = dbtexinfo.smallLod;
+	texinfo.largeLod = dbtexinfo.largeLod;
+	texinfo.aspectRatio = dbtexinfo.aspectRatio;
+	texinfo.format = dbtexinfo.format;
+
+	mem_writed(ret, FP.grRFunction1i1p(param[1], &texinfo));
+
+	ret_value = G_OK;
+	break;
+    case _grTriStats8:
+	// void grTriStats(FxU32 *trisProcessed, FxU32 *trisDrawn)
+	FP.grFunction2p = (pfunc2p)fn_pt[i];
+	MEM_BlockRead32(param[1], ilist, sizeof(FxU32));
+	MEM_BlockRead32(param[2], ilist + 1, sizeof(FxU32));
+	FP.grFunction2p(ilist, ilist + 1);
+	MEM_BlockWrite32(param[1], ilist, sizeof(FxU32));
+	MEM_BlockWrite32(param[2], ilist + 1, sizeof(FxU32));
+	break;
+    case _gu3dfGetInfo8:
+	// FxBool gu3dfGetInfo(const char *filename, Gu3dfInfo *info)
+	FP.grRFunction2p = (prfunc2p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	MEM_StrCopy(param[1], filename, 512);
+
+#if LOG_GLIDE
+	LOG_MSG("Glide:Filename info found in gu3dfGetInfo: %s", filename);
+#endif
+	if(!GetFileName(filename)) break;
+	mem_writed(ret, FP.grRFunction2p(filename, &guinfo));
+
+	// Copy the data back to DB struct if successful
+	if(mem_readd(ret)) {
+	    MEM_BlockRead32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	    dbguinfo.header.width = (Bit32u)guinfo.header.width;
+	    dbguinfo.header.height = (Bit32u)guinfo.header.height;
+	    dbguinfo.header.small_lod = (Bit32s)guinfo.header.small_lod;
+	    dbguinfo.header.large_lod = (Bit32s)guinfo.header.large_lod;
+	    dbguinfo.header.aspect_ratio = (Bit32s)guinfo.header.aspect_ratio;
+	    dbguinfo.header.format = (Bit32s)guinfo.header.format;
+	    dbguinfo.mem_required = (Bit32u)guinfo.mem_required;
+	    MEM_BlockWrite32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	}
+
+	ret_value = G_OK;
+	break;
+    case _gu3dfLoad8:
+	// FxBool gu3dfLoad(const char *filename, Gu3dfInfo *info)
+	FP.grRFunction2p = (prfunc2p)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+
+	// Although glide ref specifies *info should be filled by gu3dfGetInfo before calling gu3dfLoad,
+	// OpenGlide will re-read the header in gu3dfLoad as well
+	MEM_BlockRead32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	MEM_StrCopy(param[1], filename, 512);
+
+#if LOG_GLIDE
+	LOG_MSG("Glide:Filename info found in gu3dfLoad: %s", filename);
+#endif
+	if(!GetFileName(filename)) break;
+
+	guinfo.data = texmem;
+	mem_writed(ret, FP.grRFunction2p(filename, &guinfo));
+
+	// Copy the data back to DB struct if successful
+	if(mem_readd(ret)) {
+	    for(j=0;j<256;j++)
+		dbguinfo.table.palette.data[j] = (Bit32u)guinfo.table.palette.data[j];
+	    MEM_BlockWrite(dbguinfo.data, guinfo.data, guinfo.mem_required);
+	}
+
+	MEM_BlockWrite32(param[2], &dbguinfo, sizeof(DBGu3dfInfo));
+	ret_value = G_OK;
+	break;
+    case _guAADrawTriangleWithClip12:
+	// void guAADrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+	FP.grFunction3p = (pfunc3p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p(&vertex[0], &vertex[1], &vertex[2]);
+	break;
+    case _guAlphaSource4:
+	// void guAlphaSource(GrAlphaSourceMode_t mode)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _guColorCombineFunction4:
+	// void guColorCombineFunction(GrColorCombineFunction_t func)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _guDrawPolygonVertexListWithClip8:
+	// void guDrawPolygonVertexListWithClip(int nverts, const GrVertex vlist[])
+	FP.grFunction1i1p = (pfunc1i1p)fn_pt[i];
+	MEM_BlockRead32(param[2], texmem, sizeof(GrVertex)*param[1]);
+	FP.grFunction1i1p(param[1], texmem);
+	break;
+    case _guDrawTriangleWithClip12:
+	// void guDrawTriangleWithClip(const GrVertex *va, const GrVertex *vb, const GrVertex *vc)
+	FP.grFunction3p = (pfunc3p)fn_pt[i];
+	MEM_BlockRead32(param[1], &vertex[0], sizeof(GrVertex));
+	MEM_BlockRead32(param[2], &vertex[1], sizeof(GrVertex));
+	MEM_BlockRead32(param[3], &vertex[2], sizeof(GrVertex));
+	FP.grFunction3p(&vertex[0], &vertex[1], &vertex[2]);
+	break;
+/*
+    case _guEncodeRLE1616:
+	//
+	FP.grFunction16 = (pfunc16)fn_pt[i];
+	FP.grFunction16();
+	break;
+    case _guEndianSwapBytes4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+    case _guEndianSwapWords4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+*/
+    case _guFogGenerateExp28:
+	// void guFogGenerateExp2(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+	FP.grFunction1p1f = (pfunc1p1f)fn_pt[i];
+	FP.grFunction1p1f(texmem, int_to_float(param[2]));
+	MEM_BlockWrite32(param[1], texmem, GR_FOG_TABLE_SIZE*sizeof(GrFog_t));
+	break;
+    case _guFogGenerateExp8:
+	// void guFogGenerateExp(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float density)
+	FP.grFunction1p1f = (pfunc1p1f)fn_pt[i];
+	FP.grFunction1p1f(texmem, int_to_float(param[2]));
+	MEM_BlockWrite32(param[1], texmem, GR_FOG_TABLE_SIZE*sizeof(GrFog_t));
+	break;
+    case _guFogGenerateLinear12:
+	// void guFogGenerateLinear(GrFog_t fogTable[GR_FOG_TABLE_SIZE], float nearW, float farW)
+	FP.grFunction1p2f = (pfunc1p2f)fn_pt[i];
+	FP.grFunction1p2f(texmem, int_to_float(param[2]), int_to_float(param[3]));
+	MEM_BlockWrite32(param[1], texmem, GR_FOG_TABLE_SIZE*sizeof(GrFog_t));
+	break;
+    case _guFogTableIndexToW4: {
+	// float guFogTableIndexToW(int i)
+	FP.grFFunction1i = (pffunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	float tmp = FP.grFFunction1i(param[1]);
+	SDL_memcpy(&j, &tmp, 4);
+	mem_writed(ret, SDL_SwapLE32(j));
+	ret_value = G_OK;
+	break;
+    }
+/*
+    case _guMPDrawTriangle12:
+	//
+	FP.grFunction3i = (pfunc3i)fn_pt[i];
+	FP.grFunction3i();
+	break;
+    case _guMPInit0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _guMPTexCombineFunction4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+    case _guMPTexSource8:
+	//
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i();
+	break;
+    case _guMovieSetName4:
+	//
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i();
+	break;
+    case _guMovieStart0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _guMovieStop0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+*/
+    case _guTexAllocateMemory60:
+	// GrMipMapId_t guTexAllocateMemory(GrChipID_t tmu, FxU8 evenOddMask, int width, int height,
+	//	    GrTextureFormat_t format, GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod,
+	//	    GrAspectRatio_t aspectRatio, GrTextureClampMode_t sClampMode,
+	//	    GrTextureClampMode_t tClampMode, GrTextureFilterMode_t minFilterMode,
+	//	    GrTextureFilterMode_t magFilterMode, float lodBias, FxBool lodBlend)
+	FP.grRFunction13i1f1i = (prfunc13i1f1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction13i1f1i(param[1], param[2], param[3], param[4], param[5], param[6], param[7],
+			    param[8], param[9], param[10], param[11], param[12], param[13], int_to_float(param[14]), param[15]));
+	ret_value = G_OK;
+	break;
+    case _guTexChangeAttributes48:
+	// FxBool guTexChangeAttributes(GrMipMapID_t mmid, int width, int height, GrTextureFormat_t format,
+	//	    GrMipMapMode_t mmMode, GrLOD_t smallLod, GrLOD_t largeLod, GrAspectRatio_t aspectRatio,
+	//	    GrTextureClampMode_t sClampMode, GrTextureClampMode_t tClampMode,
+	//	    GrTextureFilterMode_t minFilterMode, GrTextureFilterMode_t magFilterMode)
+	FP.grRFunction12i = (prfunc12i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction12i(param[1], param[2], param[3], param[4], param[5], param[6], param[7],
+			param[8], param[9], param[10], param[11], param[12]));
+	ret_value = G_OK;
+	break;
+    case _guTexCombineFunction8:
+	// void guTexCombineFunction(GrChipID_t tmu, GrTextureCombineFnc_t func)
+	FP.grFunction2i = (pfunc2i)fn_pt[i];
+	FP.grFunction2i(param[1], param[2]);
+	break;
+/*
+    case _guTexCreateColorMipMap0:
+	//
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+*/
+    case _guTexDownloadMipMap12:
+	// void guTexDownloadMipMap(GrMipMapId_t mmid, const void *src, const GuNccTable *nccTable)
+	FP.grRPTFunction1i = (prptfunc1i)fn_pt[_guTexGetMipMapInfo4];
+	mipmap = (GrMipMapInfo*)FP.grRPTFunction1i(param[1]);
+
+	if(mipmap) {
+	    texinfo.aspectRatio = mipmap->aspect_ratio;
+	    texinfo.format      = mipmap->format;
+	    texinfo.largeLod    = mipmap->lod_max;
+	    texinfo.smallLod    = mipmap->lod_min;
+
+	    FP.grRFunction1i1p = (prfunc1i1p)fn_pt[_grTexTextureMemRequired8];
+	    if(FP.grRFunction1i1p == NULL) {
+		LOG_MSG("Glide:Unable to get pointer to grTexTextureMemRequired");
+		return;
+	    }
+
+	    texsize = FP.grRFunction1i1p(mipmap->odd_even_mask, &texinfo);
+
+	    MEM_BlockRead(param[2], texmem, texsize);
+	    MEM_BlockRead32(param[3], (Bit8u*)texmem+texsize, sizeof(GuNccTable));
+
+	    FP.grFunction1i2p = (pfunc1i2p)fn_pt[i];
+	    FP.grFunction1i2p(param[1], texmem, (Bit8u*)texmem+texsize);
+	} else {
+	    LOG_MSG("Glide:Unable to get GrMipMapInfo pointer");
+	}
+	break;
+/*
+    case _guTexDownloadMipMapLevel12:
+	// void guTexDownloadMipMapLevel(GrMipMapId_t mmid, GrLOD_t lod, const void **src)
+	FP.grFunction2i1p = (pfunc2i1p)fn_pt[i];
+	FP.grFunction2i1p(param[1], param[2], *param[3]);
+	break;
+*/
+    case _guTexGetCurrentMipMap4:
+	// GrMipMapId_t guTexGetCurrentMipMap(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+/*
+    case _guTexGetMipMapInfo4:
+	// GrMipMapInfo *guTexGetMipMapInfo(GrMipMapId_t mmid)
+	FP.grRFunction4 = (prfunc4)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction4(param[1]));
+	ret_value = G_OK;
+	break;
+*/
+    case _guTexMemQueryAvail4:
+	// FxU32 guTexMemQueryAvail(GrChipID_t tmu)
+	FP.grRFunction1i = (prfunc1i)fn_pt[i];
+	if(ret == 0) {
+	    LOG_MSG("Glide:Invalid return value handle for %s!", grTable[i].name);
+	    return;
+	}
+	mem_writed(ret, FP.grRFunction1i(param[1]));
+	ret_value = G_OK;
+	break;
+    case _guTexMemReset0:
+	// void guTexMemReset(void)
+	FP.grFunction0 = (pfunc0)fn_pt[i];
+	FP.grFunction0();
+	break;
+    case _guTexSource4:
+	// void guTexSource(GrMipMapId_t mmid)
+	FP.grFunction1i = (pfunc1i)fn_pt[i];
+	FP.grFunction1i(param[1]);
+	break;
+    case _ConvertAndDownloadRle64: {
+	// void ConvertAndDownloadRle(GrChipID_t tmu, FxU32 startAddress, GrLOD_t thisLod, GrLOD_t largeLod,
+	//				GrAspectRatio_t aspectRatio, GrTextureFormat_t format, FxU32 evenOdd,
+	//				FxU8 *bm_data, long  bm_h, FxU32 u0, FxU32 v0, FxU32 width, FxU32 height,
+	//				FxU32 dest_width, FxU32 dest_height, FxU16 *tlut)
+
+#if LOG_GLIDE
+	LOG_MSG("Glide: RLE width: %d, height: %d, bm_h: %d, u0: %d, v0: %d, dest %dx%d",
+	    param[12], param[13], param[9], param[10], param[11], param[14], param[15]);
+#endif
+
+	FxU8 c;
+	FxU32 scount = 0;
+	FxU32 dcount = 0;
+
+	FxU16 * src = ptr16 + param[14]*param[15];
+	FxU32 offset = 4 + param[9];
+
+	// Line offset (v0)
+	for(j = 0; j < param[11]; j++ ) {
+	    offset += mem_readb(param[8]+4+j);
+	}
+
+	// Write height lines
+	for(k = 0; k < param[13]; k++) {
+
+	    // Decode one RLE line
+	    scount = offset;
+	    while((c = mem_readb(param[8]+scount)) != 0xE0) {
+
+		if(c > 0xE0) {
+		    for(int count = 0; count < (c&0x1f); count++) {
+
+			// tlut is FxU16*
+			src[dcount] = mem_readw(param[16]+(mem_readb(param[8]+scount+1)<<1));
+			dcount++;
+		    }
+		    scount += 2;
+
+		} else {
+		    src[dcount] = mem_readw(param[16]+(c<<1));
+		    dcount++; scount++;
+		}
+	    }
+
+	    // Copy Line into destination texture, offset u0
+	    SDL_memcpy(ptr16 + (k*param[14]), src + param[10], sizeof(FxU16)*param[14]);
+	    offset += mem_readb(param[8] + 4 + j++);
+	    dcount = 0;
+	}
+
+	// One additional line
+	if(param[13] < param[15])
+	    SDL_memcpy(ptr16 + (k*param[14]), src + param[10], sizeof(FxU16)*param[14]);
+
+	// Download decoded texture
+	texinfo.smallLod = param[3];
+	texinfo.largeLod = param[4];
+	texinfo.aspectRatio = param[5];
+	texinfo.format = param[6];
+	texinfo.data = ptr16;
+
+	// void grTexDownloadMipMap(GrChipID_t tmu, FxU32 startAddress, FxU32 evenOdd, GrTexInfo *info)
+	FP.grFunction3i1p = (pfunc3i1p)fn_pt[_grTexDownloadMipMap16];
+	if(FP.grFunction3i1p == NULL) {
+	    LOG_MSG("Glide:Unable to get pointer to grTexDownloadMipMap");
+	    break;
+	}
+	FP.grFunction3i1p(param[1], param[2], param[7], &texinfo);
+	break;
+    }
+    default:
+	LOG_MSG("Glide:Unsupported glide call %s", grTable[i].name);
+	break;
+
+    }	/* switch */
+}	/* process_msg() */
diff --git a/src/hardware/memory.cpp b/src/hardware/memory.cpp
index 5069b8a54..560a3e302 100644
--- a/src/hardware/memory.cpp
+++ b/src/hardware/memory.cpp
@@ -23,6 +23,8 @@
 #include "setup.h"
 #include "paging.h"
 #include "regs.h"
+#include "glidedef.h"
+#include "voodoo.h"
 
 #include <string.h>
 
@@ -140,6 +142,10 @@ PageHandler * MEM_GetPageHandler(Bitu phys_page) {
 	} else if ((phys_page>=memory.lfb.start_page+0x01000000/4096) &&
 				(phys_page<memory.lfb.start_page+0x01000000/4096+16)) {
 		return memory.lfb.mmiohandler;
+	} else if (VOODOO_PCI_CheckLFBPage(phys_page)) {
+		return VOODOO_GetPageHandler();
+	} else if (glide.enabled && (phys_page>=(GLIDE_LFB>>12)) && (phys_page<(GLIDE_LFB>>12)+GLIDE_PAGES)) {
+		return (PageHandler*)glide.lfb_pagehandler;
 	}
 	return &illegal_page_handler;
 }
@@ -191,6 +197,24 @@ void MEM_BlockWrite(PhysPt pt,void const * const data,Bitu size) {
 	}
 }
 
+void MEM_BlockRead32(PhysPt pt,void * data,Bitu size) {
+	Bit32u * write=(Bit32u *) data;
+	size>>=2;
+	while (size--) {
+		*write++=mem_readd_inline(pt);
+		pt+=4;
+	}
+}
+
+void MEM_BlockWrite32(PhysPt pt,void * data,Bitu size) {
+	Bit32u * read=(Bit32u *) data;
+	size>>=2;
+	while (size--) {
+		mem_writed_inline(pt,*read++);
+		pt+=4;
+	}
+}
+
 void MEM_BlockCopy(PhysPt dest,PhysPt src,Bitu size) {
 	mem_memcpy(dest,src,size);
 }
diff --git a/src/hardware/pci_bus.cpp b/src/hardware/pci_bus.cpp
index 05e5d6777..7a1988351 100644
--- a/src/hardware/pci_bus.cpp
+++ b/src/hardware/pci_bus.cpp
@@ -19,12 +19,15 @@
 
 #include "dosbox.h"
 #include "inout.h"
+#include "paging.h"
 #include "mem.h"
 #include "pci_bus.h"
 #include "setup.h"
 #include "debug.h"
 #include "callback.h"
 #include "regs.h"
+#include "../ints/int10.h"
+#include "voodoo.h"
 
 
 #if defined(PCI_FUNCTIONALITY_ENABLED)
@@ -418,6 +421,53 @@ class PCI:public Module_base{
 static PCI* pci_interface=NULL;
 
 
+void PCI_AddSVGAS3_Device(void) {
+	PCI_Device* svga_dev=new PCI_VGADevice();
+	if (pci_interface!=NULL) {
+		pci_interface->RegisterPCIDevice(svga_dev);
+	} else {
+		if (num_rqueued_devices<max_rqueued_devices)
+			rqueued_devices[num_rqueued_devices++]=svga_dev;
+	}
+}
+
+void PCI_RemoveSVGAS3_Device(void) {
+	if (pci_interface!=NULL) {
+		Bit16u vendor=PCI_VGADevice::VendorID();
+		Bit16u device=PCI_VGADevice::DeviceID();
+		pci_interface->RemoveDevice(vendor,device);
+	}
+}
+
+void PCI_AddSST_Device(Bitu type) {
+	Bitu ctype = 1;
+	switch (type) {
+		case 1:
+		case 2:
+			ctype = type;
+			break;
+		default:
+			LOG_MSG("PCI:SST: Invalid board type %x specified",type);
+			break;
+	}
+	PCI_Device* voodoo_dev=new PCI_SSTDevice(ctype);
+	if (pci_interface!=NULL) {
+		pci_interface->RegisterPCIDevice(voodoo_dev);
+	} else {
+		if (num_rqueued_devices<max_rqueued_devices)
+			rqueued_devices[num_rqueued_devices++]=voodoo_dev;
+	}
+}
+
+void PCI_RemoveSST_Device(void) {
+	if (pci_interface!=NULL) {
+		Bit16u vendor=PCI_SSTDevice::VendorID();
+		pci_interface->RemoveDevice(vendor,1);
+		pci_interface->RemoveDevice(vendor,2);
+	}
+}
+
+
 PhysPt PCI_GetPModeInterface(void) {
 	if (pci_interface) {
 		return pci_interface->GetPModeCallbackPointer();
@@ -441,4 +491,18 @@ void PCI_Init(Section* sec) {
 	sec->AddDestroyFunction(&PCI_ShutDown,false);
 }
 
+#else
+
+void PCI_AddSVGAS3_Device(void) {
+}
+
+void PCI_RemoveSVGAS3_Device(void) {
+}
+
+void PCI_AddSST_Device(Bitu type) {
+}
+
+void PCI_RemoveSST_Device(void) {
+}
+
 #endif
diff --git a/src/hardware/pci_devices.h b/src/hardware/pci_devices.h
index 86f5f2dc8..b872cdc30 100644
--- a/src/hardware/pci_devices.h
+++ b/src/hardware/pci_devices.h
@@ -16,3 +16,230 @@
  *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
  */
 
+
+class PCI_VGADevice:public PCI_Device {
+private:
+	static const Bit16u vendor=0x5333;		// S3
+	static const Bit16u device=0x8811;		// trio64
+//	static const Bit16u device=0x8810;		// trio32
+public:
+	PCI_VGADevice():PCI_Device(vendor,device) {
+	}
+
+	static Bit16u VendorID(void) { return vendor; }
+	static Bit16u DeviceID(void) { return device; }
+
+	Bits ParseReadRegister(Bit8u regnum) {
+		return regnum;
+	}
+
+	bool OverrideReadRegister(Bit8u regnum, Bit8u* rval, Bit8u* rval_mask) {
+		return false;
+	}
+
+	Bits ParseWriteRegister(Bit8u regnum,Bit8u value) {
+		if ((regnum>=0x18) && (regnum<0x28)) return -1;	// base addresses are read-only
+		if ((regnum>=0x30) && (regnum<0x34)) return -1;	// expansion rom addresses are read-only
+		switch (regnum) {
+			case 0x10:
+				return (pci_cfg_data[this->PCIId()][this->PCISubfunction()][0x10]&0x0f);
+			case 0x11:
+				return 0x00;
+			case 0x12:
+//				return (value&0xc0);	// -> 4mb addressable
+				return (value&0x00);	// -> 16mb addressable
+			case 0x13:
+				return value;
+			case 0x14:
+				return (pci_cfg_data[this->PCIId()][this->PCISubfunction()][0x10]&0x0f);
+			case 0x15:
+				return 0x00;
+			case 0x16:
+				return value;	// -> 64kb addressable
+			case 0x17:
+				return value;
+			default:
+				break;
+		}
+		return value;
+	}
+
+	bool InitializeRegisters(Bit8u registers[256]) {
+		// init (S3 graphics card)
+//		registers[0x08] = 0x44;	// revision ID (s3 trio64v+)
+		registers[0x08] = 0x00;	// revision ID
+		registers[0x09] = 0x00;	// interface
+		registers[0x0a] = 0x00;	// subclass type (vga compatible)
+//		registers[0x0a] = 0x01;	// subclass type (xga device)
+		registers[0x0b] = 0x03;	// class type (display controller)
+		registers[0x0c] = 0x00;	// cache line size
+		registers[0x0d] = 0x00;	// latency timer
+		registers[0x0e] = 0x00;	// header type (other)
+
+		// reset
+		registers[0x04] = 0x23;	// command register (vga palette snoop, ports enabled, memory space enabled)
+		registers[0x05] = 0x00;
+		registers[0x06] = 0x80;	// status register (medium timing, fast back-to-back)
+		registers[0x07] = 0x02;
+
+//		registers[0x3c] = 0x0b;	// irq line
+//		registers[0x3d] = 0x01;	// irq pin
+
+//		Bit32u gfx_address_space=(((Bit32u)S3_LFB_BASE)&0xfffffff0) | 0x08;	// memory space, within first 4GB, prefetchable
+		Bit32u gfx_address_space=(((Bit32u)S3_LFB_BASE)&0xfffffff0);	// memory space, within first 4GB
+		registers[0x10] = (Bit8u)(gfx_address_space&0xff);		// base addres 0
+		registers[0x11] = (Bit8u)((gfx_address_space>>8)&0xff);
+		registers[0x12] = (Bit8u)((gfx_address_space>>16)&0xff);
+		registers[0x13] = (Bit8u)((gfx_address_space>>24)&0xff);
+
+		Bit32u gfx_address_space_mmio=(((Bit32u)S3_LFB_BASE+0x1000000)&0xfffffff0);	// memory space, within first 4GB
+		registers[0x14] = (Bit8u)(gfx_address_space_mmio&0xff);		// base addres 0
+		registers[0x15] = (Bit8u)((gfx_address_space_mmio>>8)&0xff);
+		registers[0x16] = (Bit8u)((gfx_address_space_mmio>>16)&0xff);
+		registers[0x17] = (Bit8u)((gfx_address_space_mmio>>24)&0xff);
+
+		return true;
+	}
+};
+
+
+class PCI_SSTDevice:public PCI_Device {
+private:
+	static const Bit16u vendor=0x121a;	// 3dfx
+	Bit16u oscillator_ctr;
+	Bit16u pci_ctr;
+public:
+	PCI_SSTDevice(Bitu type):PCI_Device(vendor,(type==2)?0x0002:0x0001) {
+		oscillator_ctr=0;
+		pci_ctr=0;
+	}
+
+	static Bit16u VendorID(void) { return vendor; }
+
+	Bits ParseReadRegister(Bit8u regnum) {
+//		LOG_MSG("SST ParseReadRegister %x",regnum);
+		switch (regnum) {
+			case 0x4c:
+			case 0x4d:
+			case 0x4e:
+			case 0x4f:
+				LOG_MSG("SST ParseReadRegister STATUS %x",regnum);
+				break;
+			case 0x54:
+			case 0x55:
+			case 0x56:
+			case 0x57:
+				if (DeviceID() >= 2) return -1;
+				break;
+			default:
+				break;
+		}
+		return regnum;
+	}
+
+	bool OverrideReadRegister(Bit8u regnum, Bit8u* rval, Bit8u* rval_mask) {
+		switch (regnum) {
+			case 0x54:
+				if (DeviceID() >= 2) {
+					oscillator_ctr++;
+					pci_ctr--;
+					*rval=(oscillator_ctr | ((pci_ctr<<16) & 0x0fff0000)) & 0xff;
+					*rval_mask=0xff;
+					return true;
+				}
+				break;
+			case 0x55:
+				if (DeviceID() >= 2) {
+					*rval=((oscillator_ctr | ((pci_ctr<<16) & 0x0fff0000)) >> 8) & 0xff;
+					*rval_mask=0xff;
+					return true;
+				}
+				break;
+			case 0x56:
+				if (DeviceID() >= 2) {
+					*rval=((oscillator_ctr | ((pci_ctr<<16) & 0x0fff0000)) >> 16) & 0xff;
+					*rval_mask=0xff;
+					return true;
+				}
+				break;
+			case 0x57:
+				if (DeviceID() >= 2) {
+					*rval=((oscillator_ctr | ((pci_ctr<<16) & 0x0fff0000)) >> 24) & 0xff;
+					*rval_mask=0x0f;
+					return true;
+				}
+				break;
+			default:
+				break;
+		}
+		return false;
+	}
+
+	Bits ParseWriteRegister(Bit8u regnum,Bit8u value) {
+//		LOG_MSG("SST ParseWriteRegister %x:=%x",regnum,value);
+		if ((regnum>=0x14) && (regnum<0x28)) return -1;	// base addresses are read-only
+		if ((regnum>=0x30) && (regnum<0x34)) return -1;	// expansion rom addresses are read-only
+		switch (regnum) {
+			case 0x10:
+				return (pci_cfg_data[this->PCIId()][this->PCISubfunction()][0x10]&0x0f);
+			case 0x11:
+				return 0x00;
+			case 0x12:
+				return (value&0x00);	// -> 16mb addressable (whyever)
+			case 0x13:
+				VOODOO_PCI_SetLFB(value<<24);
+				return value;
+			case 0x40:
+				VOODOO_PCI_InitEnable(value&7);
+				break;
+			case 0x41:
+			case 0x42:
+			case 0x43:
+				return -1;
+			case 0xc0:
+				VOODOO_PCI_Enable(true);
+				return -1;
+			case 0xe0:
+				VOODOO_PCI_Enable(false);
+				return -1;
+			default:
+				break;
+		}
+		return value;
+	}
+
+	bool InitializeRegisters(Bit8u registers[256]) {
+		// init (3dfx voodoo)
+		registers[0x08] = 0x02;	// revision
+		registers[0x09] = 0x00;	// interface
+//		registers[0x0a] = 0x00;	// subclass code
+		registers[0x0a] = 0x00;	// subclass code (video/graphics controller)
+//		registers[0x0b] = 0x00;	// class code (generic)
+		registers[0x0b] = 0x04;	// class code (multimedia device)
+		registers[0x0e] = 0x00;	// header type (other)
+
+		// reset
+		registers[0x04] = 0x02;	// command register (memory space enabled)
+		registers[0x05] = 0x00;
+		registers[0x06] = 0x80;	// status register (fast back-to-back)
+		registers[0x07] = 0x00;
+
+		registers[0x3c] = 0xff;	// no irq
+
+		// memBaseAddr: size is 16MB
+		Bit32u address_space=(((Bit32u)VOODOO_INITIAL_LFB)&0xfffffff0) | 0x08;	// memory space, within first 4GB, prefetchable
+		registers[0x10] = (Bit8u)(address_space&0xff);		// base addres 0
+		registers[0x11] = (Bit8u)((address_space>>8)&0xff);
+		registers[0x12] = (Bit8u)((address_space>>16)&0xff);
+		registers[0x13] = (Bit8u)((address_space>>24)&0xff);
+
+		if (DeviceID() >= 2) {
+			registers[0x40] = 0x00;
+			registers[0x41] = 0x40;	// voodoo2 revision ID (rev4)
+			registers[0x42] = 0x01;
+			registers[0x43] = 0x00;
+		}
+
+		return true;
+	}
+};
diff --git a/src/hardware/vga_s3.cpp b/src/hardware/vga_s3.cpp
index b0347ea8f..501a781be 100644
--- a/src/hardware/vga_s3.cpp
+++ b/src/hardware/vga_s3.cpp
@@ -21,6 +21,7 @@
 #include "inout.h"
 #include "vga.h"
 #include "mem.h"
+#include "pci_bus.h"
 
 void SVGA_S3_WriteCRTC(Bitu reg,Bitu val,Bitu iolen) {
 	switch (reg) {
@@ -562,4 +563,6 @@ void SVGA_Setup_S3Trio(void) {
 	phys_writeb(rom_base+0x0045,'7');
 	phys_writeb(rom_base+0x0046,'6');
 	phys_writeb(rom_base+0x0047,'4');
+
+	PCI_AddSVGAS3_Device();
 }
diff --git a/src/hardware/voodoo.cpp b/src/hardware/voodoo.cpp
new file mode 100644
index 000000000..5a0677325
--- /dev/null
+++ b/src/hardware/voodoo.cpp
@@ -0,0 +1,187 @@
+/*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "dosbox.h"
+#include "config.h"
+#include "setup.h"
+#include "cross.h"
+
+#include "paging.h"
+#include "mem.h"
+
+#include "voodoo.h"
+#include "pci_bus.h"
+#include "voodoo_interface.h"
+
+
+class VOODOO;
+static VOODOO* voodoo_dev;
+
+static Bit32u voodoo_current_lfb=(VOODOO_INITIAL_LFB&0xffff0000);
+
+
+class VOODOO:public Module_base{
+private:
+	Bits emulation_type;
+public:
+	VOODOO(Section* configuration):Module_base(configuration){
+		emulation_type=-1;
+
+		Section_prop * section=static_cast<Section_prop *>(configuration);
+		std::string voodoo_type_str(section->Get_string("voodoo"));
+		if (voodoo_type_str=="false") {
+			emulation_type=0;
+		} else if (voodoo_type_str=="software") {
+			emulation_type=1;
+#if C_OPENGL
+		} else if ((voodoo_type_str=="opengl") || (voodoo_type_str=="auto")) {
+			emulation_type=2;
+#else
+		} else if (voodoo_type_str=="auto") {
+			emulation_type=1;
+#endif
+		} else {
+			emulation_type=0;
+		}
+
+		if (emulation_type<=0) return;
+
+
+		Bits card_type = 1;
+		bool max_voodoomem;
+		std::string voodoo_mem_str(section->Get_string("voodoomem"));
+		if (voodoo_mem_str=="max") {
+			max_voodoomem = true;
+		} else {
+			max_voodoomem = false;
+		}
+
+		bool needs_pci_device = false;
+
+		switch (emulation_type) {
+			case 1:
+			case 2:
+				Voodoo_Initialize(emulation_type, card_type, max_voodoomem);
+				needs_pci_device = true;
+				break;
+			default:
+				break;
+		}
+
+		if (needs_pci_device) PCI_AddSST_Device(card_type);
+	}
+
+	~VOODOO(){
+		PCI_RemoveSST_Device();
+
+		if (emulation_type<=0) return;
+
+		switch (emulation_type) {
+			case 1:
+			case 2:
+				Voodoo_Shut_Down();
+				break;
+			default:
+				break;
+		}
+
+		emulation_type=-1;
+	}
+
+	void PCI_InitEnable(Bitu val) {
+		switch (emulation_type) {
+			case 1:
+			case 2:
+				Voodoo_PCI_InitEnable(val);
+				break;
+			default:
+				break;
+		}
+	}
+
+	void PCI_Enable(bool enable) {
+		switch (emulation_type) {
+			case 1:
+			case 2:
+				Voodoo_PCI_Enable(enable);
+				break;
+			default:
+				break;
+		}
+	}
+
+	PageHandler* GetPageHandler() {
+		switch (emulation_type) {
+			case 1:
+			case 2:
+				return Voodoo_GetPageHandler();
+			default:
+				break;
+		}
+		return NULL;
+	}
+
+};
+
+
+void VOODOO_PCI_InitEnable(Bitu val) {
+	if (voodoo_dev!=NULL) {
+		voodoo_dev->PCI_InitEnable(val);
+	}
+}
+
+void VOODOO_PCI_Enable(bool enable) {
+	if (voodoo_dev!=NULL) {
+		voodoo_dev->PCI_Enable(enable);
+	}
+}
+
+
+void VOODOO_PCI_SetLFB(Bit32u lfbaddr) {
+	voodoo_current_lfb=(lfbaddr&0xffff0000);
+}
+
+bool VOODOO_PCI_CheckLFBPage(Bitu page) {
+	if ((page>=(voodoo_current_lfb>>12)) &&
+		(page<(voodoo_current_lfb>>12)+VOODOO_PAGES))
+		return true;
+	return false;
+}
+
+PageHandler* VOODOO_GetPageHandler() {
+	if (voodoo_dev!=NULL) {
+		return voodoo_dev->GetPageHandler();
+	}
+	return NULL;
+}
+
+
+void VOODOO_Destroy(Section* /*sec*/) {
+	delete voodoo_dev;
+	voodoo_dev=NULL;
+}
+
+void VOODOO_Init(Section* sec) {
+	voodoo_current_lfb=(VOODOO_INITIAL_LFB&0xffff0000);
+	voodoo_dev = new VOODOO(sec);
+	sec->AddDestroyFunction(&VOODOO_Destroy,true);
+}
diff --git a/src/hardware/voodoo_data.h b/src/hardware/voodoo_data.h
new file mode 100644
index 000000000..1c6b15c0b
--- /dev/null
+++ b/src/hardware/voodoo_data.h
@@ -0,0 +1,2238 @@
+/***************************************************************************/
+/*        Portion of this software comes with the following license:       */
+/***************************************************************************/
+/*
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+/*************************************************************************
+
+    3dfx Voodoo Graphics SST-1/2 emulator
+
+    emulator by Aaron Giles
+
+**************************************************************************/
+
+
+#ifndef DOSBOX_VOODOO_DATA_H
+#define DOSBOX_VOODOO_DATA_H
+
+
+/*************************************
+ *
+ *  Misc. constants
+ *
+ *************************************/
+
+/* enumeration specifying which model of Voodoo we are emulating */
+enum
+{
+	VOODOO_1,
+	VOODOO_1_DTMU,
+	VOODOO_2,
+	MAX_VOODOO_TYPES
+};
+
+
+/* maximum number of TMUs */
+#define MAX_TMU					2
+
+/* maximum number of rasterizers */
+#define MAX_RASTERIZERS			1024
+
+/* size of the rasterizer hash table */
+#define RASTER_HASH_SIZE		97
+
+/* flags for LFB writes */
+#define LFB_RGB_PRESENT			1
+#define LFB_ALPHA_PRESENT		2
+#define LFB_DEPTH_PRESENT		4
+#define LFB_DEPTH_PRESENT_MSW	8
+
+/* flags for the register access array */
+#define REGISTER_READ			0x01		/* reads are allowed */
+#define REGISTER_WRITE			0x02		/* writes are allowed */
+#define REGISTER_PIPELINED		0x04		/* writes are pipelined */
+#define REGISTER_FIFO			0x08		/* writes go to FIFO */
+#define REGISTER_WRITETHRU		0x10		/* writes are valid even for CMDFIFO */
+
+/* shorter combinations to make the table smaller */
+#define REG_R					(REGISTER_READ)
+#define REG_W					(REGISTER_WRITE)
+#define REG_WT					(REGISTER_WRITE | REGISTER_WRITETHRU)
+#define REG_RW					(REGISTER_READ | REGISTER_WRITE)
+#define REG_RWT					(REGISTER_READ | REGISTER_WRITE | REGISTER_WRITETHRU)
+#define REG_RP					(REGISTER_READ | REGISTER_PIPELINED)
+#define REG_WP					(REGISTER_WRITE | REGISTER_PIPELINED)
+#define REG_RWP					(REGISTER_READ | REGISTER_WRITE | REGISTER_PIPELINED)
+#define REG_RWPT				(REGISTER_READ | REGISTER_WRITE | REGISTER_PIPELINED | REGISTER_WRITETHRU)
+#define REG_RF					(REGISTER_READ | REGISTER_FIFO)
+#define REG_WF					(REGISTER_WRITE | REGISTER_FIFO)
+#define REG_RWF					(REGISTER_READ | REGISTER_WRITE | REGISTER_FIFO)
+#define REG_RPF					(REGISTER_READ | REGISTER_PIPELINED | REGISTER_FIFO)
+#define REG_WPF					(REGISTER_WRITE | REGISTER_PIPELINED | REGISTER_FIFO)
+#define REG_RWPF				(REGISTER_READ | REGISTER_WRITE | REGISTER_PIPELINED | REGISTER_FIFO)
+
+/* lookup bits is the log2 of the size of the reciprocal/log table */
+#define RECIPLOG_LOOKUP_BITS	9
+
+/* input precision is how many fraction bits the input value has; this is a 64-bit number */
+#define RECIPLOG_INPUT_PREC		32
+
+/* lookup precision is how many fraction bits each table entry contains */
+#define RECIPLOG_LOOKUP_PREC	22
+
+/* output precision is how many fraction bits the result should have */
+#define RECIP_OUTPUT_PREC		15
+#define LOG_OUTPUT_PREC			8
+
+
+
+/*************************************
+ *
+ *  Dithering tables
+ *
+ *************************************/
+
+static const UINT8 dither_matrix_4x4[16] =
+{
+	 0,  8,  2, 10,
+	12,  4, 14,  6,
+	 3, 11,  1,  9,
+	15,  7, 13,  5
+};
+
+static const UINT8 dither_matrix_2x2[16] =
+{
+	 2, 10,  2, 10,
+	14,  6, 14,  6,
+	 2, 10,  2, 10,
+	14,  6, 14,  6
+};
+
+
+
+/*************************************
+ *
+ *  Macros for extracting pixels
+ *
+ *************************************/
+
+#define EXTRACT_565_TO_888(val, a, b, c)					\
+	(a) = (((val) >> 8) & 0xf8) | (((val) >> 13) & 0x07);	\
+	(b) = (((val) >> 3) & 0xfc) | (((val) >> 9) & 0x03);	\
+	(c) = (((val) << 3) & 0xf8) | (((val) >> 2) & 0x07);	\
+
+#define EXTRACT_x555_TO_888(val, a, b, c)					\
+	(a) = (((val) >> 7) & 0xf8) | (((val) >> 12) & 0x07);	\
+	(b) = (((val) >> 2) & 0xf8) | (((val) >> 7) & 0x07);	\
+	(c) = (((val) << 3) & 0xf8) | (((val) >> 2) & 0x07);	\
+
+#define EXTRACT_555x_TO_888(val, a, b, c)					\
+	(a) = (((val) >> 8) & 0xf8) | (((val) >> 13) & 0x07);	\
+	(b) = (((val) >> 3) & 0xf8) | (((val) >> 8) & 0x07);	\
+	(c) = (((val) << 2) & 0xf8) | (((val) >> 3) & 0x07);	\
+
+#define EXTRACT_1555_TO_8888(val, a, b, c, d)				\
+	(a) = ((INT16)(val) >> 15) & 0xff;						\
+	EXTRACT_x555_TO_888(val, b, c, d)						\
+
+#define EXTRACT_5551_TO_8888(val, a, b, c, d)				\
+	EXTRACT_555x_TO_888(val, a, b, c)						\
+	(d) = ((val) & 0x0001) ? 0xff : 0x00;					\
+
+#define EXTRACT_x888_TO_888(val, a, b, c)					\
+	(a) = ((val) >> 16) & 0xff;								\
+	(b) = ((val) >> 8) & 0xff;								\
+	(c) = ((val) >> 0) & 0xff;								\
+
+#define EXTRACT_888x_TO_888(val, a, b, c)					\
+	(a) = ((val) >> 24) & 0xff;								\
+	(b) = ((val) >> 16) & 0xff;								\
+	(c) = ((val) >> 8) & 0xff;								\
+
+#define EXTRACT_8888_TO_8888(val, a, b, c, d)				\
+	(a) = ((val) >> 24) & 0xff;								\
+	(b) = ((val) >> 16) & 0xff;								\
+	(c) = ((val) >> 8) & 0xff;								\
+	(d) = ((val) >> 0) & 0xff;								\
+
+#define EXTRACT_4444_TO_8888(val, a, b, c, d)				\
+	(a) = (((val) >> 8) & 0xf0) | (((val) >> 12) & 0x0f);	\
+	(b) = (((val) >> 4) & 0xf0) | (((val) >> 8) & 0x0f);	\
+	(c) = (((val) >> 0) & 0xf0) | (((val) >> 4) & 0x0f);	\
+	(d) = (((val) << 4) & 0xf0) | (((val) >> 0) & 0x0f);	\
+
+#define EXTRACT_332_TO_888(val, a, b, c)					\
+	(a) = (((val) >> 0) & 0xe0) | (((val) >> 3) & 0x1c) | (((val) >> 6) & 0x03); \
+	(b) = (((val) << 3) & 0xe0) | (((val) >> 0) & 0x1c) | (((val) >> 3) & 0x03); \
+	(c) = (((val) << 6) & 0xc0) | (((val) << 4) & 0x30) | (((val) << 2) & 0xc0) | (((val) << 0) & 0x03); \
+
+
+
+/*************************************
+ *
+ *  Misc. macros
+ *
+ *************************************/
+
+/* macro for clamping a value between minimum and maximum values */
+#define CLAMP(val,min,max)		do { if ((val) < (min)) { (val) = (min); } else if ((val) > (max)) { (val) = (max); } } while (0)
+
+/* macro to compute the base 2 log for LOD calculations */
+#define LOGB2(x)				(log((double)(x)) / log(2.0))
+
+
+
+/*************************************
+ *
+ *  Macros for extracting bitfields
+ *
+ *************************************/
+
+#define INITEN_ENABLE_HW_INIT(val)			(((val) >> 0) & 1)
+#define INITEN_ENABLE_PCI_FIFO(val)			(((val) >> 1) & 1)
+#define INITEN_REMAP_INIT_TO_DAC(val)		(((val) >> 2) & 1)
+#define INITEN_ENABLE_SNOOP0(val)			(((val) >> 4) & 1)
+#define INITEN_SNOOP0_MEMORY_MATCH(val)		(((val) >> 5) & 1)
+#define INITEN_SNOOP0_READWRITE_MATCH(val)	(((val) >> 6) & 1)
+#define INITEN_ENABLE_SNOOP1(val)			(((val) >> 7) & 1)
+#define INITEN_SNOOP1_MEMORY_MATCH(val)		(((val) >> 8) & 1)
+#define INITEN_SNOOP1_READWRITE_MATCH(val)	(((val) >> 9) & 1)
+#define INITEN_SLI_BUS_OWNER(val)			(((val) >> 10) & 1)
+#define INITEN_SLI_ODD_EVEN(val)			(((val) >> 11) & 1)
+#define INITEN_SECONDARY_REV_ID(val)		(((val) >> 12) & 0xf)	/* voodoo 2 only */
+#define INITEN_MFCTR_FAB_ID(val)			(((val) >> 16) & 0xf)	/* voodoo 2 only */
+#define INITEN_ENABLE_PCI_INTERRUPT(val)	(((val) >> 20) & 1)		/* voodoo 2 only */
+#define INITEN_PCI_INTERRUPT_TIMEOUT(val)	(((val) >> 21) & 1)		/* voodoo 2 only */
+#define INITEN_ENABLE_NAND_TREE_TEST(val)	(((val) >> 22) & 1)		/* voodoo 2 only */
+#define INITEN_ENABLE_SLI_ADDRESS_SNOOP(val) (((val) >> 23) & 1)	/* voodoo 2 only */
+#define INITEN_SLI_SNOOP_ADDRESS(val)		(((val) >> 24) & 0xff)	/* voodoo 2 only */
+
+#define FBZCP_CC_RGBSELECT(val)				(((val) >> 0) & 3)
+#define FBZCP_CC_ASELECT(val)				(((val) >> 2) & 3)
+#define FBZCP_CC_LOCALSELECT(val)			(((val) >> 4) & 1)
+#define FBZCP_CCA_LOCALSELECT(val)			(((val) >> 5) & 3)
+#define FBZCP_CC_LOCALSELECT_OVERRIDE(val)	(((val) >> 7) & 1)
+#define FBZCP_CC_ZERO_OTHER(val)			(((val) >> 8) & 1)
+#define FBZCP_CC_SUB_CLOCAL(val)			(((val) >> 9) & 1)
+#define FBZCP_CC_MSELECT(val)				(((val) >> 10) & 7)
+#define FBZCP_CC_REVERSE_BLEND(val)			(((val) >> 13) & 1)
+#define FBZCP_CC_ADD_ACLOCAL(val)			(((val) >> 14) & 3)
+#define FBZCP_CC_INVERT_OUTPUT(val)			(((val) >> 16) & 1)
+#define FBZCP_CCA_ZERO_OTHER(val)			(((val) >> 17) & 1)
+#define FBZCP_CCA_SUB_CLOCAL(val)			(((val) >> 18) & 1)
+#define FBZCP_CCA_MSELECT(val)				(((val) >> 19) & 7)
+#define FBZCP_CCA_REVERSE_BLEND(val)		(((val) >> 22) & 1)
+#define FBZCP_CCA_ADD_ACLOCAL(val)			(((val) >> 23) & 3)
+#define FBZCP_CCA_INVERT_OUTPUT(val)		(((val) >> 25) & 1)
+#define FBZCP_CCA_SUBPIXEL_ADJUST(val)		(((val) >> 26) & 1)
+#define FBZCP_TEXTURE_ENABLE(val)			(((val) >> 27) & 1)
+#define FBZCP_RGBZW_CLAMP(val)				(((val) >> 28) & 1)		/* voodoo 2 only */
+#define FBZCP_ANTI_ALIAS(val)				(((val) >> 29) & 1)		/* voodoo 2 only */
+
+#define ALPHAMODE_ALPHATEST(val)			(((val) >> 0) & 1)
+#define ALPHAMODE_ALPHAFUNCTION(val)		(((val) >> 1) & 7)
+#define ALPHAMODE_ALPHABLEND(val)			(((val) >> 4) & 1)
+#define ALPHAMODE_ANTIALIAS(val)			(((val) >> 5) & 1)
+#define ALPHAMODE_SRCRGBBLEND(val)			(((val) >> 8) & 15)
+#define ALPHAMODE_DSTRGBBLEND(val)			(((val) >> 12) & 15)
+#define ALPHAMODE_SRCALPHABLEND(val)		(((val) >> 16) & 15)
+#define ALPHAMODE_DSTALPHABLEND(val)		(((val) >> 20) & 15)
+#define ALPHAMODE_ALPHAREF(val)				(((val) >> 24) & 0xff)
+
+#define FOGMODE_ENABLE_FOG(val)				(((val) >> 0) & 1)
+#define FOGMODE_FOG_ADD(val)				(((val) >> 1) & 1)
+#define FOGMODE_FOG_MULT(val)				(((val) >> 2) & 1)
+#define FOGMODE_FOG_ZALPHA(val)				(((val) >> 3) & 3)
+#define FOGMODE_FOG_CONSTANT(val)			(((val) >> 5) & 1)
+#define FOGMODE_FOG_DITHER(val)				(((val) >> 6) & 1)		/* voodoo 2 only */
+#define FOGMODE_FOG_ZONES(val)				(((val) >> 7) & 1)		/* voodoo 2 only */
+
+#define FBZMODE_ENABLE_CLIPPING(val)		(((val) >> 0) & 1)
+#define FBZMODE_ENABLE_CHROMAKEY(val)		(((val) >> 1) & 1)
+#define FBZMODE_ENABLE_STIPPLE(val)			(((val) >> 2) & 1)
+#define FBZMODE_WBUFFER_SELECT(val)			(((val) >> 3) & 1)
+#define FBZMODE_ENABLE_DEPTHBUF(val)		(((val) >> 4) & 1)
+#define FBZMODE_DEPTH_FUNCTION(val)			(((val) >> 5) & 7)
+#define FBZMODE_ENABLE_DITHERING(val)		(((val) >> 8) & 1)
+#define FBZMODE_RGB_BUFFER_MASK(val)		(((val) >> 9) & 1)
+#define FBZMODE_AUX_BUFFER_MASK(val)		(((val) >> 10) & 1)
+#define FBZMODE_DITHER_TYPE(val)			(((val) >> 11) & 1)
+#define FBZMODE_STIPPLE_PATTERN(val)		(((val) >> 12) & 1)
+#define FBZMODE_ENABLE_ALPHA_MASK(val)		(((val) >> 13) & 1)
+#define FBZMODE_DRAW_BUFFER(val)			(((val) >> 14) & 3)
+#define FBZMODE_ENABLE_DEPTH_BIAS(val)		(((val) >> 16) & 1)
+#define FBZMODE_Y_ORIGIN(val)				(((val) >> 17) & 1)
+#define FBZMODE_ENABLE_ALPHA_PLANES(val)	(((val) >> 18) & 1)
+#define FBZMODE_ALPHA_DITHER_SUBTRACT(val)	(((val) >> 19) & 1)
+#define FBZMODE_DEPTH_SOURCE_COMPARE(val)	(((val) >> 20) & 1)
+#define FBZMODE_DEPTH_FLOAT_SELECT(val)		(((val) >> 21) & 1)		/* voodoo 2 only */
+
+#define LFBMODE_WRITE_FORMAT(val)			(((val) >> 0) & 0xf)
+#define LFBMODE_WRITE_BUFFER_SELECT(val)	(((val) >> 4) & 3)
+#define LFBMODE_READ_BUFFER_SELECT(val)		(((val) >> 6) & 3)
+#define LFBMODE_ENABLE_PIXEL_PIPELINE(val)	(((val) >> 8) & 1)
+#define LFBMODE_RGBA_LANES(val)				(((val) >> 9) & 3)
+#define LFBMODE_WORD_SWAP_WRITES(val)		(((val) >> 11) & 1)
+#define LFBMODE_BYTE_SWIZZLE_WRITES(val)	(((val) >> 12) & 1)
+#define LFBMODE_Y_ORIGIN(val)				(((val) >> 13) & 1)
+#define LFBMODE_WRITE_W_SELECT(val)			(((val) >> 14) & 1)
+#define LFBMODE_WORD_SWAP_READS(val)		(((val) >> 15) & 1)
+#define LFBMODE_BYTE_SWIZZLE_READS(val)		(((val) >> 16) & 1)
+
+#define CHROMARANGE_BLUE_EXCLUSIVE(val)		(((val) >> 24) & 1)
+#define CHROMARANGE_GREEN_EXCLUSIVE(val)	(((val) >> 25) & 1)
+#define CHROMARANGE_RED_EXCLUSIVE(val)		(((val) >> 26) & 1)
+#define CHROMARANGE_UNION_MODE(val)			(((val) >> 27) & 1)
+#define CHROMARANGE_ENABLE(val)				(((val) >> 28) & 1)
+
+#define FBIINIT0_VGA_PASSTHRU(val)			(((val) >> 0) & 1)
+#define FBIINIT0_GRAPHICS_RESET(val)		(((val) >> 1) & 1)
+#define FBIINIT0_FIFO_RESET(val)			(((val) >> 2) & 1)
+#define FBIINIT0_SWIZZLE_REG_WRITES(val)	(((val) >> 3) & 1)
+#define FBIINIT0_STALL_PCIE_FOR_HWM(val)	(((val) >> 4) & 1)
+#define FBIINIT0_PCI_FIFO_LWM(val)			(((val) >> 6) & 0x1f)
+#define FBIINIT0_LFB_TO_MEMORY_FIFO(val)	(((val) >> 11) & 1)
+#define FBIINIT0_TEXMEM_TO_MEMORY_FIFO(val) (((val) >> 12) & 1)
+#define FBIINIT0_ENABLE_MEMORY_FIFO(val)	(((val) >> 13) & 1)
+#define FBIINIT0_MEMORY_FIFO_HWM(val)		(((val) >> 14) & 0x7ff)
+#define FBIINIT0_MEMORY_FIFO_BURST(val)		(((val) >> 25) & 0x3f)
+
+#define FBIINIT1_PCI_DEV_FUNCTION(val)		(((val) >> 0) & 1)
+#define FBIINIT1_PCI_WRITE_WAIT_STATES(val)	(((val) >> 1) & 1)
+#define FBIINIT1_MULTI_SST1(val)			(((val) >> 2) & 1)		/* not on voodoo 2 */
+#define FBIINIT1_ENABLE_LFB(val)			(((val) >> 3) & 1)
+#define FBIINIT1_X_VIDEO_TILES(val)			(((val) >> 4) & 0xf)
+#define FBIINIT1_VIDEO_TIMING_RESET(val)	(((val) >> 8) & 1)
+#define FBIINIT1_SOFTWARE_OVERRIDE(val)		(((val) >> 9) & 1)
+#define FBIINIT1_SOFTWARE_HSYNC(val)		(((val) >> 10) & 1)
+#define FBIINIT1_SOFTWARE_VSYNC(val)		(((val) >> 11) & 1)
+#define FBIINIT1_SOFTWARE_BLANK(val)		(((val) >> 12) & 1)
+#define FBIINIT1_DRIVE_VIDEO_TIMING(val)	(((val) >> 13) & 1)
+#define FBIINIT1_DRIVE_VIDEO_BLANK(val)		(((val) >> 14) & 1)
+#define FBIINIT1_DRIVE_VIDEO_SYNC(val)		(((val) >> 15) & 1)
+#define FBIINIT1_DRIVE_VIDEO_DCLK(val)		(((val) >> 16) & 1)
+#define FBIINIT1_VIDEO_TIMING_VCLK(val)		(((val) >> 17) & 1)
+#define FBIINIT1_VIDEO_CLK_2X_DELAY(val)	(((val) >> 18) & 3)
+#define FBIINIT1_VIDEO_TIMING_SOURCE(val)	(((val) >> 20) & 3)
+#define FBIINIT1_ENABLE_24BPP_OUTPUT(val)	(((val) >> 22) & 1)
+#define FBIINIT1_ENABLE_SLI(val)			(((val) >> 23) & 1)
+#define FBIINIT1_X_VIDEO_TILES_BIT5(val)	(((val) >> 24) & 1)		/* voodoo 2 only */
+#define FBIINIT1_ENABLE_EDGE_FILTER(val)	(((val) >> 25) & 1)
+#define FBIINIT1_INVERT_VID_CLK_2X(val)		(((val) >> 26) & 1)
+#define FBIINIT1_VID_CLK_2X_SEL_DELAY(val)	(((val) >> 27) & 3)
+#define FBIINIT1_VID_CLK_DELAY(val)			(((val) >> 29) & 3)
+#define FBIINIT1_DISABLE_FAST_READAHEAD(val) (((val) >> 31) & 1)
+
+#define FBIINIT2_DISABLE_DITHER_SUB(val)	(((val) >> 0) & 1)
+#define FBIINIT2_DRAM_BANKING(val)			(((val) >> 1) & 1)
+#define FBIINIT2_ENABLE_TRIPLE_BUF(val)		(((val) >> 4) & 1)
+#define FBIINIT2_ENABLE_FAST_RAS_READ(val)	(((val) >> 5) & 1)
+#define FBIINIT2_ENABLE_GEN_DRAM_OE(val)	(((val) >> 6) & 1)
+#define FBIINIT2_ENABLE_FAST_READWRITE(val)	(((val) >> 7) & 1)
+#define FBIINIT2_ENABLE_PASSTHRU_DITHER(val) (((val) >> 8) & 1)
+#define FBIINIT2_SWAP_BUFFER_ALGORITHM(val)	(((val) >> 9) & 3)
+#define FBIINIT2_VIDEO_BUFFER_OFFSET(val)	(((val) >> 11) & 0x1ff)
+#define FBIINIT2_ENABLE_DRAM_BANKING(val)	(((val) >> 20) & 1)
+#define FBIINIT2_ENABLE_DRAM_READ_FIFO(val)	(((val) >> 21) & 1)
+#define FBIINIT2_ENABLE_DRAM_REFRESH(val)	(((val) >> 22) & 1)
+#define FBIINIT2_REFRESH_LOAD_VALUE(val)	(((val) >> 23) & 0x1ff)
+
+#define FBIINIT3_TRI_REGISTER_REMAP(val)	(((val) >> 0) & 1)
+#define FBIINIT3_VIDEO_FIFO_THRESH(val)		(((val) >> 1) & 0x1f)
+#define FBIINIT3_DISABLE_TMUS(val)			(((val) >> 6) & 1)
+#define FBIINIT3_FBI_MEMORY_TYPE(val)		(((val) >> 8) & 7)
+#define FBIINIT3_VGA_PASS_RESET_VAL(val)	(((val) >> 11) & 1)
+#define FBIINIT3_HARDCODE_PCI_BASE(val)		(((val) >> 12) & 1)
+#define FBIINIT3_FBI2TREX_DELAY(val)		(((val) >> 13) & 0xf)
+#define FBIINIT3_TREX2FBI_DELAY(val)		(((val) >> 17) & 0x1f)
+#define FBIINIT3_YORIGIN_SUBTRACT(val)		(((val) >> 22) & 0x3ff)
+
+#define FBIINIT4_PCI_READ_WAITS(val)		(((val) >> 0) & 1)
+#define FBIINIT4_ENABLE_LFB_READAHEAD(val)	(((val) >> 1) & 1)
+#define FBIINIT4_MEMORY_FIFO_LWM(val)		(((val) >> 2) & 0x3f)
+#define FBIINIT4_MEMORY_FIFO_START_ROW(val)	(((val) >> 8) & 0x3ff)
+#define FBIINIT4_MEMORY_FIFO_STOP_ROW(val)	(((val) >> 18) & 0x3ff)
+#define FBIINIT4_VIDEO_CLOCKING_DELAY(val)	(((val) >> 29) & 7)		/* voodoo 2 only */
+
+#define FBIINIT5_DISABLE_PCI_STOP(val)		(((val) >> 0) & 1)		/* voodoo 2 only */
+#define FBIINIT5_PCI_SLAVE_SPEED(val)		(((val) >> 1) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DAC_DATA_OUTPUT_WIDTH(val)	(((val) >> 2) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DAC_DATA_17_OUTPUT(val)	(((val) >> 3) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DAC_DATA_18_OUTPUT(val)	(((val) >> 4) & 1)		/* voodoo 2 only */
+#define FBIINIT5_GENERIC_STRAPPING(val)		(((val) >> 5) & 0xf)	/* voodoo 2 only */
+#define FBIINIT5_BUFFER_ALLOCATION(val)		(((val) >> 9) & 3)		/* voodoo 2 only */
+#define FBIINIT5_DRIVE_VID_CLK_SLAVE(val)	(((val) >> 11) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DRIVE_DAC_DATA_16(val)		(((val) >> 12) & 1)		/* voodoo 2 only */
+#define FBIINIT5_VCLK_INPUT_SELECT(val)		(((val) >> 13) & 1)		/* voodoo 2 only */
+#define FBIINIT5_MULTI_CVG_DETECT(val)		(((val) >> 14) & 1)		/* voodoo 2 only */
+#define FBIINIT5_SYNC_RETRACE_READS(val)	(((val) >> 15) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_RHBORDER_COLOR(val)	(((val) >> 16) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_LHBORDER_COLOR(val)	(((val) >> 17) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_BVBORDER_COLOR(val)	(((val) >> 18) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_TVBORDER_COLOR(val)	(((val) >> 19) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DOUBLE_HORIZ(val)			(((val) >> 20) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DOUBLE_VERT(val)			(((val) >> 21) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_16BIT_GAMMA(val)	(((val) >> 22) & 1)		/* voodoo 2 only */
+#define FBIINIT5_INVERT_DAC_HSYNC(val)		(((val) >> 23) & 1)		/* voodoo 2 only */
+#define FBIINIT5_INVERT_DAC_VSYNC(val)		(((val) >> 24) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_24BIT_DACDATA(val)	(((val) >> 25) & 1)		/* voodoo 2 only */
+#define FBIINIT5_ENABLE_INTERLACING(val)	(((val) >> 26) & 1)		/* voodoo 2 only */
+#define FBIINIT5_DAC_DATA_18_CONTROL(val)	(((val) >> 27) & 1)		/* voodoo 2 only */
+#define FBIINIT5_RASTERIZER_UNIT_MODE(val)	(((val) >> 30) & 3)		/* voodoo 2 only */
+
+#define FBIINIT6_WINDOW_ACTIVE_COUNTER(val)	(((val) >> 0) & 7)		/* voodoo 2 only */
+#define FBIINIT6_WINDOW_DRAG_COUNTER(val)	(((val) >> 3) & 0x1f)	/* voodoo 2 only */
+#define FBIINIT6_SLI_SYNC_MASTER(val)		(((val) >> 8) & 1)		/* voodoo 2 only */
+#define FBIINIT6_DAC_DATA_22_OUTPUT(val)	(((val) >> 9) & 3)		/* voodoo 2 only */
+#define FBIINIT6_DAC_DATA_23_OUTPUT(val)	(((val) >> 11) & 3)		/* voodoo 2 only */
+#define FBIINIT6_SLI_SYNCIN_OUTPUT(val)		(((val) >> 13) & 3)		/* voodoo 2 only */
+#define FBIINIT6_SLI_SYNCOUT_OUTPUT(val)	(((val) >> 15) & 3)		/* voodoo 2 only */
+#define FBIINIT6_DAC_RD_OUTPUT(val)			(((val) >> 17) & 3)		/* voodoo 2 only */
+#define FBIINIT6_DAC_WR_OUTPUT(val)			(((val) >> 19) & 3)		/* voodoo 2 only */
+#define FBIINIT6_PCI_FIFO_LWM_RDY(val)		(((val) >> 21) & 0x7f)	/* voodoo 2 only */
+#define FBIINIT6_VGA_PASS_N_OUTPUT(val)		(((val) >> 28) & 3)		/* voodoo 2 only */
+#define FBIINIT6_X_VIDEO_TILES_BIT0(val)	(((val) >> 30) & 1)		/* voodoo 2 only */
+
+#define FBIINIT7_GENERIC_STRAPPING(val)		(((val) >> 0) & 0xff)	/* voodoo 2 only */
+#define FBIINIT7_CMDFIFO_ENABLE(val)		(((val) >> 8) & 1)		/* voodoo 2 only */
+#define FBIINIT7_CMDFIFO_MEMORY_STORE(val)	(((val) >> 9) & 1)		/* voodoo 2 only */
+#define FBIINIT7_DISABLE_CMDFIFO_HOLES(val)	(((val) >> 10) & 1)		/* voodoo 2 only */
+#define FBIINIT7_CMDFIFO_READ_THRESH(val)	(((val) >> 11) & 0x1f)	/* voodoo 2 only */
+#define FBIINIT7_SYNC_CMDFIFO_WRITES(val)	(((val) >> 16) & 1)		/* voodoo 2 only */
+#define FBIINIT7_SYNC_CMDFIFO_READS(val)	(((val) >> 17) & 1)		/* voodoo 2 only */
+#define FBIINIT7_RESET_PCI_PACKER(val)		(((val) >> 18) & 1)		/* voodoo 2 only */
+#define FBIINIT7_ENABLE_CHROMA_STUFF(val)	(((val) >> 19) & 1)		/* voodoo 2 only */
+#define FBIINIT7_CMDFIFO_PCI_TIMEOUT(val)	(((val) >> 20) & 0x7f)	/* voodoo 2 only */
+#define FBIINIT7_ENABLE_TEXTURE_BURST(val)	(((val) >> 27) & 1)		/* voodoo 2 only */
+
+#define TEXMODE_ENABLE_PERSPECTIVE(val)		(((val) >> 0) & 1)
+#define TEXMODE_MINIFICATION_FILTER(val)	(((val) >> 1) & 1)
+#define TEXMODE_MAGNIFICATION_FILTER(val)	(((val) >> 2) & 1)
+#define TEXMODE_CLAMP_NEG_W(val)			(((val) >> 3) & 1)
+#define TEXMODE_ENABLE_LOD_DITHER(val)		(((val) >> 4) & 1)
+#define TEXMODE_NCC_TABLE_SELECT(val)		(((val) >> 5) & 1)
+#define TEXMODE_CLAMP_S(val)				(((val) >> 6) & 1)
+#define TEXMODE_CLAMP_T(val)				(((val) >> 7) & 1)
+#define TEXMODE_FORMAT(val)					(((val) >> 8) & 0xf)
+#define TEXMODE_TC_ZERO_OTHER(val)			(((val) >> 12) & 1)
+#define TEXMODE_TC_SUB_CLOCAL(val)			(((val) >> 13) & 1)
+#define TEXMODE_TC_MSELECT(val)				(((val) >> 14) & 7)
+#define TEXMODE_TC_REVERSE_BLEND(val)		(((val) >> 17) & 1)
+#define TEXMODE_TC_ADD_ACLOCAL(val)			(((val) >> 18) & 3)
+#define TEXMODE_TC_INVERT_OUTPUT(val)		(((val) >> 20) & 1)
+#define TEXMODE_TCA_ZERO_OTHER(val)			(((val) >> 21) & 1)
+#define TEXMODE_TCA_SUB_CLOCAL(val)			(((val) >> 22) & 1)
+#define TEXMODE_TCA_MSELECT(val)			(((val) >> 23) & 7)
+#define TEXMODE_TCA_REVERSE_BLEND(val)		(((val) >> 26) & 1)
+#define TEXMODE_TCA_ADD_ACLOCAL(val)		(((val) >> 27) & 3)
+#define TEXMODE_TCA_INVERT_OUTPUT(val)		(((val) >> 29) & 1)
+#define TEXMODE_TRILINEAR(val)				(((val) >> 30) & 1)
+#define TEXMODE_SEQ_8_DOWNLD(val)			(((val) >> 31) & 1)
+
+#define TEXLOD_LODMIN(val)					(((val) >> 0) & 0x3f)
+#define TEXLOD_LODMAX(val)					(((val) >> 6) & 0x3f)
+#define TEXLOD_LODBIAS(val)					(((val) >> 12) & 0x3f)
+#define TEXLOD_LOD_ODD(val)					(((val) >> 18) & 1)
+#define TEXLOD_LOD_TSPLIT(val)				(((val) >> 19) & 1)
+#define TEXLOD_LOD_S_IS_WIDER(val)			(((val) >> 20) & 1)
+#define TEXLOD_LOD_ASPECT(val)				(((val) >> 21) & 3)
+#define TEXLOD_LOD_ZEROFRAC(val)			(((val) >> 23) & 1)
+#define TEXLOD_TMULTIBASEADDR(val)			(((val) >> 24) & 1)
+#define TEXLOD_TDATA_SWIZZLE(val)			(((val) >> 25) & 1)
+#define TEXLOD_TDATA_SWAP(val)				(((val) >> 26) & 1)
+#define TEXLOD_TDIRECT_WRITE(val)			(((val) >> 27) & 1)		/* Voodoo 2 only */
+
+#define TEXDETAIL_DETAIL_MAX(val)			(((val) >> 0) & 0xff)
+#define TEXDETAIL_DETAIL_BIAS(val)			(((val) >> 8) & 0x3f)
+#define TEXDETAIL_DETAIL_SCALE(val)			(((val) >> 14) & 7)
+#define TEXDETAIL_RGB_MIN_FILTER(val)		(((val) >> 17) & 1)		/* Voodoo 2 only */
+#define TEXDETAIL_RGB_MAG_FILTER(val)		(((val) >> 18) & 1)		/* Voodoo 2 only */
+#define TEXDETAIL_ALPHA_MIN_FILTER(val)		(((val) >> 19) & 1)		/* Voodoo 2 only */
+#define TEXDETAIL_ALPHA_MAG_FILTER(val)		(((val) >> 20) & 1)		/* Voodoo 2 only */
+#define TEXDETAIL_SEPARATE_RGBA_FILTER(val)	(((val) >> 21) & 1)		/* Voodoo 2 only */
+
+#define TREXINIT_SEND_TMU_CONFIG(val)		(((val) >> 18) & 1)
+
+
+/*************************************
+ *
+ *  Core types
+ *
+ *************************************/
+
+typedef struct _voodoo_state voodoo_state;
+typedef struct _poly_extra_data poly_extra_data;
+
+typedef UINT32 rgb_t;
+
+typedef struct _rgba rgba;
+#define LSB_FIRST
+struct _rgba
+{
+#ifdef LSB_FIRST
+	UINT8				b, g, r, a;
+#else
+	UINT8				a, r, g, b;
+#endif
+};
+
+
+typedef union _voodoo_reg voodoo_reg;
+union _voodoo_reg
+{
+	INT32				i;
+	UINT32				u;
+	float				f;
+	rgba				rgb;
+};
+
+
+typedef voodoo_reg rgb_union;
+
+
+/* note that this structure is an even 64 bytes long */
+typedef struct _stats_block stats_block;
+struct _stats_block
+{
+	INT32				pixels_in;				/* pixels in statistic */
+	INT32				pixels_out;				/* pixels out statistic */
+	INT32				chroma_fail;			/* chroma test fail statistic */
+	INT32				zfunc_fail;				/* z function test fail statistic */
+	INT32				afunc_fail;				/* alpha function test fail statistic */
+	INT32				clip_fail;				/* clipping fail statistic */
+	INT32				stipple_count;			/* stipple statistic */
+	INT32				filler[64/4 - 7];		/* pad this structure to 64 bytes */
+};
+
+
+typedef struct _fifo_state fifo_state;
+struct _fifo_state
+{
+	INT32				size;					/* size of the FIFO */
+};
+
+
+typedef struct _pci_state pci_state;
+struct _pci_state
+{
+	fifo_state			fifo;					/* PCI FIFO */
+	UINT32				init_enable;			/* initEnable value */
+	bool				op_pending;				/* true if an operation is pending */
+};
+
+
+typedef struct _ncc_table ncc_table;
+struct _ncc_table
+{
+	bool				dirty;					/* is the texel lookup dirty? */
+	voodoo_reg *		reg;					/* pointer to our registers */
+	INT32				ir[4], ig[4], ib[4];	/* I values for R,G,B */
+	INT32				qr[4], qg[4], qb[4];	/* Q values for R,G,B */
+	INT32				y[16];					/* Y values */
+	rgb_t *				palette;				/* pointer to associated RGB palette */
+	rgb_t *				palettea;				/* pointer to associated ARGB palette */
+	rgb_t				texel[256];				/* texel lookup */
+};
+
+
+typedef struct _tmu_state tmu_state;
+struct _tmu_state
+{
+	UINT8 *				ram;					/* pointer to our RAM */
+	UINT32				mask;					/* mask to apply to pointers */
+	voodoo_reg *		reg;					/* pointer to our register base */
+	bool				regdirty;				/* true if the LOD/mode/base registers have changed */
+
+	UINT32				texaddr_mask;			/* mask for texture address */
+	UINT8				texaddr_shift;			/* shift for texture address */
+
+	INT64				starts, startt;			/* starting S,T (14.18) */
+	INT64				startw;					/* starting W (2.30) */
+	INT64				dsdx, dtdx;				/* delta S,T per X */
+	INT64				dwdx;					/* delta W per X */
+	INT64				dsdy, dtdy;				/* delta S,T per Y */
+	INT64				dwdy;					/* delta W per Y */
+
+	INT32				lodmin, lodmax;			/* min, max LOD values */
+	INT32				lodbias;				/* LOD bias */
+	UINT32				lodmask;				/* mask of available LODs */
+	UINT32				lodoffset[9];			/* offset of texture base for each LOD */
+	INT32				detailmax;				/* detail clamp */
+	INT32				detailbias;				/* detail bias */
+	UINT8				detailscale;			/* detail scale */
+
+	UINT32				wmask;					/* mask for the current texture width */
+	UINT32				hmask;					/* mask for the current texture height */
+
+	UINT8				bilinear_mask;			/* mask for bilinear resolution (0xf0 for V1, 0xff for V2) */
+
+	ncc_table			ncc[2];					/* two NCC tables */
+
+	rgb_t *				lookup;					/* currently selected lookup */
+	rgb_t *				texel[16];				/* texel lookups for each format */
+
+	rgb_t				palette[256];			/* palette lookup table */
+	rgb_t				palettea[256];			/* palette+alpha lookup table */
+};
+
+
+typedef struct _tmu_shared_state tmu_shared_state;
+struct _tmu_shared_state
+{
+	rgb_t				rgb332[256];			/* RGB 3-3-2 lookup table */
+	rgb_t				alpha8[256];			/* alpha 8-bit lookup table */
+	rgb_t				int8[256];				/* intensity 8-bit lookup table */
+	rgb_t				ai44[256];				/* alpha, intensity 4-4 lookup table */
+
+	rgb_t				rgb565[65536];			/* RGB 5-6-5 lookup table */
+	rgb_t				argb1555[65536];		/* ARGB 1-5-5-5 lookup table */
+	rgb_t				argb4444[65536];		/* ARGB 4-4-4-4 lookup table */
+};
+
+
+typedef struct _setup_vertex setup_vertex;
+struct _setup_vertex
+{
+	float				x, y;					/* X, Y coordinates */
+	float				a, r, g, b;				/* A, R, G, B values */
+	float				z, wb;					/* Z and broadcast W values */
+	float				w0, s0, t0;				/* W, S, T for TMU 0 */
+	float				w1, s1, t1;				/* W, S, T for TMU 1 */
+};
+
+
+typedef struct _fbi_state fbi_state;
+struct _fbi_state
+{
+	UINT8 *				ram;					/* pointer to frame buffer RAM */
+	UINT32				mask;					/* mask to apply to pointers */
+	UINT32				rgboffs[3];				/* word offset to 3 RGB buffers */
+	UINT32				auxoffs;				/* word offset to 1 aux buffer */
+
+	UINT8				frontbuf;				/* front buffer index */
+	UINT8				backbuf;				/* back buffer index */
+
+	UINT32				yorigin;				/* Y origin subtract value */
+
+	UINT32				width;					/* width of current frame buffer */
+	UINT32				height;					/* height of current frame buffer */
+//	UINT32				xoffs;					/* horizontal offset (back porch) */
+//	UINT32				yoffs;					/* vertical offset (back porch) */
+//	UINT32				vsyncscan;				/* vertical sync scanline */
+	UINT32				rowpixels;				/* pixels per row */
+	UINT32				tile_width;				/* width of video tiles */
+	UINT32				tile_height;			/* height of video tiles */
+	UINT32				x_tiles;				/* number of tiles in the X direction */
+
+	UINT8				vblank;					/* VBLANK state */
+	bool				vblank_dont_swap;		/* don't actually swap when we hit this point */
+	bool				vblank_flush_pending;
+
+	/* triangle setup info */
+	INT16				ax, ay;					/* vertex A x,y (12.4) */
+	INT16				bx, by;					/* vertex B x,y (12.4) */
+	INT16				cx, cy;					/* vertex C x,y (12.4) */
+	INT32				startr, startg, startb, starta; /* starting R,G,B,A (12.12) */
+	INT32				startz;					/* starting Z (20.12) */
+	INT64				startw;					/* starting W (16.32) */
+	INT32				drdx, dgdx, dbdx, dadx;	/* delta R,G,B,A per X */
+	INT32				dzdx;					/* delta Z per X */
+	INT64				dwdx;					/* delta W per X */
+	INT32				drdy, dgdy, dbdy, dady;	/* delta R,G,B,A per Y */
+	INT32				dzdy;					/* delta Z per Y */
+	INT64				dwdy;					/* delta W per Y */
+
+	stats_block			lfb_stats;				/* LFB-access statistics */
+
+	UINT8				sverts;					/* number of vertices ready */
+	setup_vertex		svert[3];				/* 3 setup vertices */
+
+	fifo_state			fifo;					/* framebuffer memory fifo */
+
+	UINT8				fogblend[64];			/* 64-entry fog table */
+	UINT8				fogdelta[64];			/* 64-entry fog table */
+	UINT8				fogdelta_mask;			/* mask for for delta (0xff for V1, 0xfc for V2) */
+
+//	rgb_t				clut[512];				/* clut gamma data */
+};
+
+
+typedef struct _dac_state dac_state;
+struct _dac_state
+{
+	UINT8				reg[8];					/* 8 registers */
+	UINT8				read_result;			/* pending read result */
+};
+
+
+typedef struct _raster_info raster_info;
+struct _raster_info
+{
+	struct _raster_info *next;					/* pointer to next entry with the same hash */
+	poly_draw_scanline_func callback;			/* callback pointer */
+	bool				is_generic;				/* true if this is one of the generic rasterizers */
+	UINT8				display;				/* display index */
+	UINT32				hits;					/* how many hits (pixels) we've used this for */
+	UINT32				polys;					/* how many polys we've used this for */
+	UINT32				eff_color_path;			/* effective fbzColorPath value */
+	UINT32				eff_alpha_mode;			/* effective alphaMode value */
+	UINT32				eff_fog_mode;			/* effective fogMode value */
+	UINT32				eff_fbz_mode;			/* effective fbzMode value */
+	UINT32				eff_tex_mode_0;			/* effective textureMode value for TMU #0 */
+	UINT32				eff_tex_mode_1;			/* effective textureMode value for TMU #1 */
+
+	bool				shader_ready;
+	UINT32				so_shader_program;
+	UINT32				so_vertex_shader;
+	UINT32				so_fragment_shader;
+	INT32*				shader_ulocations;
+};
+
+
+struct _poly_extra_data
+{
+	voodoo_state *		state;					/* pointer back to the voodoo state */
+	raster_info *		info;					/* pointer to rasterizer information */
+
+	INT16				ax, ay;					/* vertex A x,y (12.4) */
+	INT32				startr, startg, startb, starta; /* starting R,G,B,A (12.12) */
+	INT32				startz;					/* starting Z (20.12) */
+	INT64				startw;					/* starting W (16.32) */
+	INT32				drdx, dgdx, dbdx, dadx;	/* delta R,G,B,A per X */
+	INT32				dzdx;					/* delta Z per X */
+	INT64				dwdx;					/* delta W per X */
+	INT32				drdy, dgdy, dbdy, dady;	/* delta R,G,B,A per Y */
+	INT32				dzdy;					/* delta Z per Y */
+	INT64				dwdy;					/* delta W per Y */
+
+	INT64				starts0, startt0;		/* starting S,T (14.18) */
+	INT64				startw0;				/* starting W (2.30) */
+	INT64				ds0dx, dt0dx;			/* delta S,T per X */
+	INT64				dw0dx;					/* delta W per X */
+	INT64				ds0dy, dt0dy;			/* delta S,T per Y */
+	INT64				dw0dy;					/* delta W per Y */
+	INT32				lodbase0;				/* used during rasterization */
+
+	INT64				starts1, startt1;		/* starting S,T (14.18) */
+	INT64				startw1;				/* starting W (2.30) */
+	INT64				ds1dx, dt1dx;			/* delta S,T per X */
+	INT64				dw1dx;					/* delta W per X */
+	INT64				ds1dy, dt1dy;			/* delta S,T per Y */
+	INT64				dw1dy;					/* delta W per Y */
+	INT32				lodbase1;				/* used during rasterization */
+
+	UINT16				dither[16];				/* dither matrix, for fastfill */
+
+	Bitu				texcount;
+	Bitu				r_fbzColorPath;
+	Bitu				r_fbzMode;
+	Bitu				r_alphaMode;
+	Bitu				r_fogMode;
+	INT32				r_textureMode0;
+	INT32				r_textureMode1;
+};
+
+
+/* typedef struct _voodoo_state voodoo_state; -- declared above */
+struct _voodoo_state
+{
+	UINT8				type;					/* type of system */
+	UINT8				chipmask;				/* mask for which chips are available */
+
+	voodoo_reg			reg[0x400];				/* raw registers */
+	const UINT8 *		regaccess;				/* register access array */
+	const char *const *	regnames;				/* register names array */
+	bool				alt_regmap;				/* enable alternate register map? */
+
+	pci_state			pci;					/* PCI state */
+	dac_state			dac;					/* DAC state */
+
+	fbi_state			fbi;					/* FBI states */
+	tmu_state			tmu[MAX_TMU];			/* TMU states */
+	tmu_shared_state	tmushare;				/* TMU shared state */
+
+	stats_block	*		thread_stats;			/* per-thread statistics */
+
+	int					next_rasterizer;		/* next rasterizer index */
+	raster_info			rasterizer[MAX_RASTERIZERS];	/* array of rasterizers */
+	raster_info *		raster_hash[RASTER_HASH_SIZE];	/* hash table of rasterizers */
+
+	bool				send_config;
+	UINT32				tmu_config;
+
+	bool				ogl;
+	bool				ogl_dimchange;
+	bool				clock_enabled;
+	bool				output_on;
+	bool				active;
+};
+
+
+
+/*************************************
+ *
+ *  Inline FIFO management
+ *
+ *************************************/
+
+INLINE INT32 fifo_space(fifo_state *f)
+{
+	INT32 items = 0;
+	if (items < 0)
+		items += f->size;
+	return f->size - 1 - items;
+}
+
+
+INLINE UINT8 count_leading_zeros(UINT32 value)
+{
+	INT32 result;
+
+#if defined _MSC_VER
+	__asm
+	{
+		bsr   eax,value
+		jnz   skip
+		mov   eax,63
+	skip:
+		xor   eax,31
+		mov   result,eax
+	}
+#else
+	result = 32;
+	while(value > 0) {
+		result--;
+		value >>= 1;
+	}
+#endif
+
+	return (UINT8)result;
+}
+
+/*************************************
+ *
+ *  Computes a fast 16.16 reciprocal
+ *  of a 16.32 value; used for
+ *  computing 1/w in the rasterizer.
+ *
+ *  Since it is trivial to also
+ *  compute log2(1/w) = -log2(w) at
+ *  the same time, we do that as well
+ *  to 16.8 precision for LOD
+ *  calculations.
+ *
+ *  On a Pentium M, this routine is
+ *  20% faster than a 64-bit integer
+ *  divide and also produces the log
+ *  for free.
+ *
+ *************************************/
+
+INLINE INT64 fast_reciplog(INT64 value, INT32 *log2)
+{
+	extern UINT32 voodoo_reciplog[];
+	UINT32 temp, rlog;
+	UINT32 interp;
+	UINT32 *table;
+	UINT64 recip;
+	bool neg = false;
+	int lz, exp = 0;
+
+	/* always work with unsigned numbers */
+	if (value < 0)
+	{
+		value = -value;
+		neg = true;
+	}
+
+	/* if we've spilled out of 32 bits, push it down under 32 */
+	if (value & LONGTYPE(0xffff00000000))
+	{
+		temp = (UINT32)(value >> 16);
+		exp -= 16;
+	}
+	else
+		temp = (UINT32)value;
+
+	/* if the resulting value is 0, the reciprocal is infinite */
+	if (GCC_UNLIKELY(temp == 0))
+	{
+		*log2 = 1000 << LOG_OUTPUT_PREC;
+		return neg ? 0x80000000 : 0x7fffffff;
+	}
+
+	/* determine how many leading zeros in the value and shift it up high */
+	lz = count_leading_zeros(temp);
+	temp <<= lz;
+	exp += lz;
+
+	/* compute a pointer to the table entries we want */
+	/* math is a bit funny here because we shift one less than we need to in order */
+	/* to account for the fact that there are two UINT32's per table entry */
+	table = &voodoo_reciplog[(temp >> (31 - RECIPLOG_LOOKUP_BITS - 1)) & ((2 << RECIPLOG_LOOKUP_BITS) - 2)];
+
+	/* compute the interpolation value */
+	interp = (temp >> (31 - RECIPLOG_LOOKUP_BITS - 8)) & 0xff;
+
+	/* do a linear interpolatation between the two nearest table values */
+	/* for both the log and the reciprocal */
+	rlog = (table[1] * (0x100 - interp) + table[3] * interp) >> 8;
+	recip = (table[0] * (0x100 - interp) + table[2] * interp) >> 8;
+
+	/* the log result is the fractional part of the log; round it to the output precision */
+	rlog = (rlog + (1 << (RECIPLOG_LOOKUP_PREC - LOG_OUTPUT_PREC - 1))) >> (RECIPLOG_LOOKUP_PREC - LOG_OUTPUT_PREC);
+
+	/* the exponent is the non-fractional part of the log; normally, we would subtract it from rlog */
+	/* but since we want the log(1/value) = -log(value), we subtract rlog from the exponent */
+	*log2 = ((exp - (31 - RECIPLOG_INPUT_PREC)) << LOG_OUTPUT_PREC) - rlog;
+
+	/* adjust the exponent to account for all the reciprocal-related parameters to arrive at a final shift amount */
+	exp += (RECIP_OUTPUT_PREC - RECIPLOG_LOOKUP_PREC) - (31 - RECIPLOG_INPUT_PREC);
+
+	/* shift by the exponent */
+	if (exp < 0)
+		recip >>= -exp;
+	else
+		recip <<= exp;
+
+	/* on the way out, apply the original sign to the reciprocal */
+	return neg ? -(INT64)recip : (INT64)recip;
+}
+
+
+
+/*************************************
+ *
+ *  Float-to-int conversions
+ *
+ *************************************/
+
+INLINE INT32 float_to_int32(UINT32 data, int fixedbits)
+{
+	int exponent = ((data >> 23) & 0xff) - 127 - 23 + fixedbits;
+	INT32 result = (data & 0x7fffff) | 0x800000;
+	if (exponent < 0)
+	{
+		if (exponent > -32)
+			result >>= -exponent;
+		else
+			result = 0;
+	}
+	else
+	{
+		if (exponent < 32)
+			result <<= exponent;
+		else
+			result = 0x7fffffff;
+	}
+	if (data & 0x80000000)
+		result = -result;
+	return result;
+}
+
+
+INLINE INT64 float_to_int64(UINT32 data, int fixedbits)
+{
+	int exponent = ((data >> 23) & 0xff) - 127 - 23 + fixedbits;
+	INT64 result = (data & 0x7fffff) | 0x800000;
+	if (exponent < 0)
+	{
+		if (exponent > -64)
+			result >>= -exponent;
+		else
+			result = 0;
+	}
+	else
+	{
+		if (exponent < 64)
+			result <<= exponent;
+		else
+			result = LONGTYPE(0x7fffffffffffffff);
+	}
+	if (data & 0x80000000)
+		result = -result;
+	return result;
+}
+
+
+
+/*************************************
+ *
+ *  Rasterizer inlines
+ *
+ *************************************/
+
+INLINE UINT32 normalize_color_path(UINT32 eff_color_path)
+{
+	/* ignore the subpixel adjust and texture enable flags */
+	eff_color_path &= ~((1 << 26) | (1 << 27));
+
+	return eff_color_path;
+}
+
+
+INLINE UINT32 normalize_alpha_mode(UINT32 eff_alpha_mode)
+{
+	/* always ignore alpha ref value */
+	eff_alpha_mode &= ~(0xff << 24);
+
+	/* if not doing alpha testing, ignore the alpha function and ref value */
+	if (!ALPHAMODE_ALPHATEST(eff_alpha_mode))
+		eff_alpha_mode &= ~(7 << 1);
+
+	/* if not doing alpha blending, ignore the source and dest blending factors */
+	if (!ALPHAMODE_ALPHABLEND(eff_alpha_mode))
+		eff_alpha_mode &= ~((15 << 8) | (15 << 12) | (15 << 16) | (15 << 20));
+
+	return eff_alpha_mode;
+}
+
+
+INLINE UINT32 normalize_fog_mode(UINT32 eff_fog_mode)
+{
+	/* if not doing fogging, ignore all the other fog bits */
+	if (!FOGMODE_ENABLE_FOG(eff_fog_mode))
+		eff_fog_mode = 0;
+
+	return eff_fog_mode;
+}
+
+
+INLINE UINT32 normalize_fbz_mode(UINT32 eff_fbz_mode)
+{
+	/* ignore the draw buffer */
+	eff_fbz_mode &= ~(3 << 14);
+
+	return eff_fbz_mode;
+}
+
+
+INLINE UINT32 normalize_tex_mode(UINT32 eff_tex_mode)
+{
+	/* ignore the NCC table and seq_8_downld flags */
+	eff_tex_mode &= ~((1 << 5) | (1 << 31));
+
+	/* classify texture formats into 3 format categories */
+	if (TEXMODE_FORMAT(eff_tex_mode) < 8)
+		eff_tex_mode = (eff_tex_mode & ~(0xf << 8)) | (0 << 8);
+	else if (TEXMODE_FORMAT(eff_tex_mode) >= 10 && TEXMODE_FORMAT(eff_tex_mode) <= 12)
+		eff_tex_mode = (eff_tex_mode & ~(0xf << 8)) | (10 << 8);
+	else
+		eff_tex_mode = (eff_tex_mode & ~(0xf << 8)) | (8 << 8);
+
+	return eff_tex_mode;
+}
+
+
+INLINE UINT32 compute_raster_hash(const raster_info *info)
+{
+	UINT32 hash;
+
+	/* make a hash */
+	hash = info->eff_color_path;
+	hash = (hash << 1) | (hash >> 31);
+	hash ^= info->eff_fbz_mode;
+	hash = (hash << 1) | (hash >> 31);
+	hash ^= info->eff_alpha_mode;
+	hash = (hash << 1) | (hash >> 31);
+	hash ^= info->eff_fog_mode;
+	hash = (hash << 1) | (hash >> 31);
+	hash ^= info->eff_tex_mode_0;
+	hash = (hash << 1) | (hash >> 31);
+	hash ^= info->eff_tex_mode_1;
+
+	return hash % RASTER_HASH_SIZE;
+}
+
+
+
+/*************************************
+ *
+ *  Dithering macros
+ *
+ *************************************/
+
+/* note that these equations and the dither matrixes have
+   been confirmed to be exact matches to the real hardware */
+#define DITHER_RB(val,dith)	((((val) << 1) - ((val) >> 4) + ((val) >> 7) + (dith)) >> 1)
+#define DITHER_G(val,dith)	((((val) << 2) - ((val) >> 4) + ((val) >> 6) + (dith)) >> 2)
+
+#define DECLARE_DITHER_POINTERS 												\
+	const UINT8 *dither_lookup = NULL;											\
+	const UINT8 *dither4 = NULL;												\
+	const UINT8 *dither = NULL													\
+
+#define COMPUTE_DITHER_POINTERS(FBZMODE, YY)									\
+do																				\
+{																				\
+	/* compute the dithering pointers */										\
+	if (FBZMODE_ENABLE_DITHERING(FBZMODE))										\
+	{																			\
+		dither4 = &dither_matrix_4x4[((YY) & 3) * 4];							\
+		if (FBZMODE_DITHER_TYPE(FBZMODE) == 0)									\
+		{																		\
+			dither = dither4;													\
+			dither_lookup = &dither4_lookup[(YY & 3) << 11];					\
+		}																		\
+		else																	\
+		{																		\
+			dither = &dither_matrix_2x2[((YY) & 3) * 4];						\
+			dither_lookup = &dither2_lookup[(YY & 3) << 11];					\
+		}																		\
+	}																			\
+}																				\
+while (0)
+
+#define APPLY_DITHER(FBZMODE, XX, DITHER_LOOKUP, RR, GG, BB)					\
+do																				\
+{																				\
+	/* apply dithering */														\
+	if (FBZMODE_ENABLE_DITHERING(FBZMODE))										\
+	{																			\
+		/* look up the dither value from the appropriate matrix */				\
+		const UINT8 *dith = &DITHER_LOOKUP[((XX) & 3) << 1];					\
+																				\
+		/* apply dithering to R,G,B */											\
+		(RR) = dith[((RR) << 3) + 0];											\
+		(GG) = dith[((GG) << 3) + 1];											\
+		(BB) = dith[((BB) << 3) + 0];											\
+	}																			\
+	else																		\
+	{																			\
+		(RR) >>= 3;																\
+		(GG) >>= 2;																\
+		(BB) >>= 3;																\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Clamping macros
+ *
+ *************************************/
+
+#define CLAMPED_ARGB(ITERR, ITERG, ITERB, ITERA, FBZCP, RESULT)					\
+do																				\
+{																				\
+	INT32 r = (INT32)(ITERR) >> 12;												\
+	INT32 g = (INT32)(ITERG) >> 12;												\
+	INT32 b = (INT32)(ITERB) >> 12;												\
+	INT32 a = (INT32)(ITERA) >> 12;												\
+																				\
+	if (FBZCP_RGBZW_CLAMP(FBZCP) == 0)											\
+	{																			\
+		r &= 0xfff;																\
+		RESULT.rgb.r = r;														\
+		if (r == 0xfff)															\
+			RESULT.rgb.r = 0;													\
+		else if (r == 0x100)													\
+			RESULT.rgb.r = 0xff;												\
+																				\
+		g &= 0xfff;																\
+		RESULT.rgb.g = g;														\
+		if (g == 0xfff)															\
+			RESULT.rgb.g = 0;													\
+		else if (g == 0x100)													\
+			RESULT.rgb.g = 0xff;												\
+																				\
+		b &= 0xfff;																\
+		RESULT.rgb.b = b;														\
+		if (b == 0xfff)															\
+			RESULT.rgb.b = 0;													\
+		else if (b == 0x100)													\
+			RESULT.rgb.b = 0xff;												\
+																				\
+		a &= 0xfff;																\
+		RESULT.rgb.a = a;														\
+		if (a == 0xfff)															\
+			RESULT.rgb.a = 0;													\
+		else if (a == 0x100)													\
+			RESULT.rgb.a = 0xff;												\
+	}																			\
+	else																		\
+	{																			\
+		RESULT.rgb.r = (r < 0) ? 0 : (r > 0xff) ? 0xff : (UINT8)r;				\
+		RESULT.rgb.g = (g < 0) ? 0 : (g > 0xff) ? 0xff : (UINT8)g;				\
+		RESULT.rgb.b = (b < 0) ? 0 : (b > 0xff) ? 0xff : (UINT8)b;				\
+		RESULT.rgb.a = (a < 0) ? 0 : (a > 0xff) ? 0xff : (UINT8)a;				\
+	}																			\
+}																				\
+while (0)
+
+
+#define CLAMPED_Z(ITERZ, FBZCP, RESULT)											\
+do																				\
+{																				\
+	(RESULT) = (INT32)(ITERZ) >> 12;											\
+	if (FBZCP_RGBZW_CLAMP(FBZCP) == 0)											\
+	{																			\
+		(RESULT) &= 0xfffff;													\
+		if ((RESULT) == 0xfffff)												\
+			(RESULT) = 0;														\
+		else if ((RESULT) == 0x10000)											\
+			(RESULT) = 0xffff;													\
+		else																	\
+			(RESULT) &= 0xffff;													\
+	}																			\
+	else																		\
+	{																			\
+		CLAMP((RESULT), 0, 0xffff);												\
+	}																			\
+}																				\
+while (0)
+
+
+#define CLAMPED_W(ITERW, FBZCP, RESULT)											\
+do																				\
+{																				\
+	(RESULT) = (INT16)((ITERW) >> 32);											\
+	if (FBZCP_RGBZW_CLAMP(FBZCP) == 0)											\
+	{																			\
+		(RESULT) &= 0xffff;														\
+		if ((RESULT) == 0xffff)													\
+			(RESULT) = 0;														\
+		else if ((RESULT) == 0x100)												\
+			(RESULT) = 0xff;													\
+		(RESULT) &= 0xff;														\
+	}																			\
+	else																		\
+	{																			\
+		CLAMP((RESULT), 0, 0xff);												\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Chroma keying macro
+ *
+ *************************************/
+
+#define APPLY_CHROMAKEY(VV, STATS, FBZMODE, COLOR)								\
+do																				\
+{																				\
+	if (FBZMODE_ENABLE_CHROMAKEY(FBZMODE))										\
+	{																			\
+		/* non-range version */													\
+		if (!CHROMARANGE_ENABLE((VV)->reg[chromaRange].u))						\
+		{																		\
+			if (((COLOR.u ^ (VV)->reg[chromaKey].u) & 0xffffff) == 0)			\
+			{																	\
+				(STATS)->chroma_fail++;											\
+				goto skipdrawdepth;												\
+			}																	\
+		}																		\
+																				\
+		/* tricky range version */												\
+		else																	\
+		{																		\
+			INT32 low, high, test;												\
+			int results = 0;													\
+																				\
+			/* check blue */													\
+			low = (VV)->reg[chromaKey].rgb.b;									\
+			high = (VV)->reg[chromaRange].rgb.b;								\
+			test = COLOR.rgb.b;													\
+			results = (test >= low && test <= high);							\
+			results ^= CHROMARANGE_BLUE_EXCLUSIVE((VV)->reg[chromaRange].u);	\
+			results <<= 1;														\
+																				\
+			/* check green */													\
+			low = (VV)->reg[chromaKey].rgb.g;									\
+			high = (VV)->reg[chromaRange].rgb.g;								\
+			test = COLOR.rgb.g;													\
+			results |= (test >= low && test <= high);							\
+			results ^= CHROMARANGE_GREEN_EXCLUSIVE((VV)->reg[chromaRange].u);	\
+			results <<= 1;														\
+																				\
+			/* check red */														\
+			low = (VV)->reg[chromaKey].rgb.r;									\
+			high = (VV)->reg[chromaRange].rgb.r;								\
+			test = COLOR.rgb.r;													\
+			results |= (test >= low && test <= high);							\
+			results ^= CHROMARANGE_RED_EXCLUSIVE((VV)->reg[chromaRange].u);		\
+																				\
+			/* final result */													\
+			if (CHROMARANGE_UNION_MODE((VV)->reg[chromaRange].u))				\
+			{																	\
+				if (results != 0)												\
+				{																\
+					(STATS)->chroma_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+			}																	\
+			else																\
+			{																	\
+				if (results == 7)												\
+				{																\
+					(STATS)->chroma_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+			}																	\
+		}																		\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Alpha masking macro
+ *
+ *************************************/
+
+#define APPLY_ALPHAMASK(VV, STATS, FBZMODE, AA)									\
+do																				\
+{																				\
+	if (FBZMODE_ENABLE_ALPHA_MASK(FBZMODE))										\
+	{																			\
+		if (((AA) & 1) == 0)													\
+		{																		\
+			(STATS)->afunc_fail++;												\
+			goto skipdrawdepth;													\
+		}																		\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Alpha testing macro
+ *
+ *************************************/
+
+#define APPLY_ALPHATEST(VV, STATS, ALPHAMODE, AA)								\
+do																				\
+{																				\
+	if (ALPHAMODE_ALPHATEST(ALPHAMODE))											\
+	{																			\
+		UINT8 alpharef = (VV)->reg[alphaMode].rgb.a;							\
+		switch (ALPHAMODE_ALPHAFUNCTION(ALPHAMODE))								\
+		{																		\
+			case 0:		/* alphaOP = never */									\
+				(STATS)->afunc_fail++;											\
+				goto skipdrawdepth;												\
+																				\
+			case 1:		/* alphaOP = less than */								\
+				if ((AA) >= alpharef)											\
+				{																\
+					(STATS)->afunc_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+				break;															\
+																				\
+			case 2:		/* alphaOP = equal */									\
+				if ((AA) != alpharef)											\
+				{																\
+					(STATS)->afunc_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+				break;															\
+																				\
+			case 3:		/* alphaOP = less than or equal */						\
+				if ((AA) > alpharef)											\
+				{																\
+					(STATS)->afunc_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+				break;															\
+																				\
+			case 4:		/* alphaOP = greater than */							\
+				if ((AA) <= alpharef)											\
+				{																\
+					(STATS)->afunc_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+				break;															\
+																				\
+			case 5:		/* alphaOP = not equal */								\
+				if ((AA) == alpharef)											\
+				{																\
+					(STATS)->afunc_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+				break;															\
+																				\
+			case 6:		/* alphaOP = greater than or equal */					\
+				if ((AA) < alpharef)											\
+				{																\
+					(STATS)->afunc_fail++;										\
+					goto skipdrawdepth;											\
+				}																\
+				break;															\
+																				\
+			case 7:		/* alphaOP = always */									\
+				break;															\
+		}																		\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Alpha blending macro
+ *
+ *************************************/
+
+#define APPLY_ALPHA_BLEND(FBZMODE, ALPHAMODE, XX, DITHER, RR, GG, BB, AA)		\
+do																				\
+{																				\
+	if (ALPHAMODE_ALPHABLEND(ALPHAMODE))										\
+	{																			\
+		int dpix = dest[XX];													\
+		int dr = (dpix >> 8) & 0xf8;											\
+		int dg = (dpix >> 3) & 0xfc;											\
+		int db = (dpix << 3) & 0xf8;											\
+		int da = (FBZMODE_ENABLE_ALPHA_PLANES(FBZMODE) && depth) ? depth[XX] : 0xff;		\
+		int sr = (RR);															\
+		int sg = (GG);															\
+		int sb = (BB);															\
+		int sa = (AA);															\
+		int ta;																	\
+																				\
+		/* apply dither subtraction */											\
+		if ((FBZMODE_ALPHA_DITHER_SUBTRACT(FBZMODE)) && DITHER)					\
+		{																		\
+			/* look up the dither value from the appropriate matrix */			\
+			int dith = DITHER[(XX) & 3];										\
+																				\
+			/* subtract the dither value */										\
+			dr = ((dr << 1) + 15 - dith) >> 1;									\
+			dg = ((dg << 2) + 15 - dith) >> 2;									\
+			db = ((db << 1) + 15 - dith) >> 1;									\
+		}																		\
+																				\
+		/* compute source portion */											\
+		switch (ALPHAMODE_SRCRGBBLEND(ALPHAMODE))								\
+		{																		\
+			default:	/* reserved */											\
+			case 0:		/* AZERO */												\
+				(RR) = (GG) = (BB) = 0;											\
+				break;															\
+																				\
+			case 1:		/* ASRC_ALPHA */										\
+				(RR) = (sr * (sa + 1)) >> 8;									\
+				(GG) = (sg * (sa + 1)) >> 8;									\
+				(BB) = (sb * (sa + 1)) >> 8;									\
+				break;															\
+																				\
+			case 2:		/* A_COLOR */											\
+				(RR) = (sr * (dr + 1)) >> 8;									\
+				(GG) = (sg * (dg + 1)) >> 8;									\
+				(BB) = (sb * (db + 1)) >> 8;									\
+				break;															\
+																				\
+			case 3:		/* ADST_ALPHA */										\
+				(RR) = (sr * (da + 1)) >> 8;									\
+				(GG) = (sg * (da + 1)) >> 8;									\
+				(BB) = (sb * (da + 1)) >> 8;									\
+				break;															\
+																				\
+			case 4:		/* AONE */												\
+				break;															\
+																				\
+			case 5:		/* AOMSRC_ALPHA */										\
+				(RR) = (sr * (0x100 - sa)) >> 8;								\
+				(GG) = (sg * (0x100 - sa)) >> 8;								\
+				(BB) = (sb * (0x100 - sa)) >> 8;								\
+				break;															\
+																				\
+			case 6:		/* AOM_COLOR */											\
+				(RR) = (sr * (0x100 - dr)) >> 8;								\
+				(GG) = (sg * (0x100 - dg)) >> 8;								\
+				(BB) = (sb * (0x100 - db)) >> 8;								\
+				break;															\
+																				\
+			case 7:		/* AOMDST_ALPHA */										\
+				(RR) = (sr * (0x100 - da)) >> 8;								\
+				(GG) = (sg * (0x100 - da)) >> 8;								\
+				(BB) = (sb * (0x100 - da)) >> 8;								\
+				break;															\
+																				\
+			case 15:	/* ASATURATE */											\
+				ta = (sa < (0x100 - da)) ? sa : (0x100 - da);					\
+				(RR) = (sr * (ta + 1)) >> 8;									\
+				(GG) = (sg * (ta + 1)) >> 8;									\
+				(BB) = (sb * (ta + 1)) >> 8;									\
+				break;															\
+		}																		\
+																				\
+		/* add in dest portion */												\
+		switch (ALPHAMODE_DSTRGBBLEND(ALPHAMODE))								\
+		{																		\
+			default:	/* reserved */											\
+			case 0:		/* AZERO */												\
+				break;															\
+																				\
+			case 1:		/* ASRC_ALPHA */										\
+				(RR) += (dr * (sa + 1)) >> 8;									\
+				(GG) += (dg * (sa + 1)) >> 8;									\
+				(BB) += (db * (sa + 1)) >> 8;									\
+				break;															\
+																				\
+			case 2:		/* A_COLOR */											\
+				(RR) += (dr * (sr + 1)) >> 8;									\
+				(GG) += (dg * (sg + 1)) >> 8;									\
+				(BB) += (db * (sb + 1)) >> 8;									\
+				break;															\
+																				\
+			case 3:		/* ADST_ALPHA */										\
+				(RR) += (dr * (da + 1)) >> 8;									\
+				(GG) += (dg * (da + 1)) >> 8;									\
+				(BB) += (db * (da + 1)) >> 8;									\
+				break;															\
+																				\
+			case 4:		/* AONE */												\
+				(RR) += dr;														\
+				(GG) += dg;														\
+				(BB) += db;														\
+				break;															\
+																				\
+			case 5:		/* AOMSRC_ALPHA */										\
+				(RR) += (dr * (0x100 - sa)) >> 8;								\
+				(GG) += (dg * (0x100 - sa)) >> 8;								\
+				(BB) += (db * (0x100 - sa)) >> 8;								\
+				break;															\
+																				\
+			case 6:		/* AOM_COLOR */											\
+				(RR) += (dr * (0x100 - sr)) >> 8;								\
+				(GG) += (dg * (0x100 - sg)) >> 8;								\
+				(BB) += (db * (0x100 - sb)) >> 8;								\
+				break;															\
+																				\
+			case 7:		/* AOMDST_ALPHA */										\
+				(RR) += (dr * (0x100 - da)) >> 8;								\
+				(GG) += (dg * (0x100 - da)) >> 8;								\
+				(BB) += (db * (0x100 - da)) >> 8;								\
+				break;															\
+																				\
+			case 15:	/* A_COLORBEFOREFOG */									\
+				(RR) += (dr * (prefogr + 1)) >> 8;								\
+				(GG) += (dg * (prefogg + 1)) >> 8;								\
+				(BB) += (db * (prefogb + 1)) >> 8;								\
+				break;															\
+		}																		\
+																				\
+		/* blend the source alpha */											\
+		(AA) = 0;																\
+		if (ALPHAMODE_SRCALPHABLEND(ALPHAMODE) == 4)							\
+			(AA) = sa;															\
+																				\
+		/* blend the dest alpha */												\
+		if (ALPHAMODE_DSTALPHABLEND(ALPHAMODE) == 4)							\
+			(AA) += da;															\
+																				\
+		/* clamp */																\
+		CLAMP((RR), 0x00, 0xff);												\
+		CLAMP((GG), 0x00, 0xff);												\
+		CLAMP((BB), 0x00, 0xff);												\
+		CLAMP((AA), 0x00, 0xff);												\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Fogging macro
+ *
+ *************************************/
+
+#define APPLY_FOGGING(VV, FOGMODE, FBZCP, XX, DITHER4, RR, GG, BB, ITERZ, ITERW, ITERAXXX)	\
+do																				\
+{																				\
+	if (FOGMODE_ENABLE_FOG(FOGMODE))											\
+	{																			\
+		rgb_union fogcolor = (VV)->reg[fogColor];								\
+		INT32 fr, fg, fb;														\
+																				\
+		/* constant fog bypasses everything else */								\
+		if (FOGMODE_FOG_CONSTANT(FOGMODE))										\
+		{																		\
+			fr = fogcolor.rgb.r;												\
+			fg = fogcolor.rgb.g;												\
+			fb = fogcolor.rgb.b;												\
+		}																		\
+																				\
+		/* non-constant fog comes from several sources */						\
+		else																	\
+		{																		\
+			INT32 fogblend = 0;													\
+																				\
+			/* if fog_add is zero, we start with the fog color */				\
+			if (FOGMODE_FOG_ADD(FOGMODE) == 0)									\
+			{																	\
+				fr = fogcolor.rgb.r;											\
+				fg = fogcolor.rgb.g;											\
+				fb = fogcolor.rgb.b;											\
+			}																	\
+			else																\
+				fr = fg = fb = 0;												\
+																				\
+			/* if fog_mult is zero, we subtract the incoming color */			\
+			if (FOGMODE_FOG_MULT(FOGMODE) == 0)									\
+			{																	\
+				fr -= (RR);														\
+				fg -= (GG);														\
+				fb -= (BB);														\
+			}																	\
+																				\
+			/* fog blending mode */												\
+			switch (FOGMODE_FOG_ZALPHA(FOGMODE))								\
+			{																	\
+				case 0:		/* fog table */										\
+				{																\
+					INT32 delta = (VV)->fbi.fogdelta[wfloat >> 10];				\
+					INT32 deltaval;												\
+																				\
+					/* perform the multiply against lower 8 bits of wfloat */	\
+					deltaval = (delta & (VV)->fbi.fogdelta_mask) *				\
+								((wfloat >> 2) & 0xff);							\
+																				\
+					/* fog zones allow for negating this value */				\
+					if (FOGMODE_FOG_ZONES(FOGMODE) && (delta & 2))				\
+						deltaval = -deltaval;									\
+					deltaval >>= 6;												\
+																				\
+					/* apply dither */											\
+					if (FOGMODE_FOG_DITHER(FOGMODE))							\
+						if (DITHER4)											\
+							deltaval += DITHER4[(XX) & 3];						\
+					deltaval >>= 4;												\
+																				\
+					/* add to the blending factor */							\
+					fogblend = (VV)->fbi.fogblend[wfloat >> 10] + deltaval;		\
+					break;														\
+				}																\
+																				\
+				case 1:		/* iterated A */									\
+					fogblend = ITERAXXX.rgb.a;									\
+					break;														\
+																				\
+				case 2:		/* iterated Z */									\
+					CLAMPED_Z((ITERZ), FBZCP, fogblend);						\
+					fogblend >>= 8;												\
+					break;														\
+																				\
+				case 3:		/* iterated W - Voodoo 2 only */					\
+					CLAMPED_W((ITERW), FBZCP, fogblend);						\
+					break;														\
+			}																	\
+																				\
+			/* perform the blend */												\
+			fogblend++;															\
+			fr = (fr * fogblend) >> 8;											\
+			fg = (fg * fogblend) >> 8;											\
+			fb = (fb * fogblend) >> 8;											\
+		}																		\
+																				\
+		/* if fog_mult is 0, we add this to the original color */				\
+		if (FOGMODE_FOG_MULT(FOGMODE) == 0)										\
+		{																		\
+			(RR) += fr;															\
+			(GG) += fg;															\
+			(BB) += fb;															\
+		}																		\
+																				\
+		/* otherwise this just becomes the new color */							\
+		else																	\
+		{																		\
+			(RR) = fr;															\
+			(GG) = fg;															\
+			(BB) = fb;															\
+		}																		\
+																				\
+		/* clamp */																\
+		CLAMP((RR), 0x00, 0xff);												\
+		CLAMP((GG), 0x00, 0xff);												\
+		CLAMP((BB), 0x00, 0xff);												\
+	}																			\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Texture pipeline macro
+ *
+ *************************************/
+
+#define TEXTURE_PIPELINE(TT, XX, DITHER4, TEXMODE, COTHER, LOOKUP, LODBASE, ITERS, ITERT, ITERW, RESULT) \
+do																				\
+{																				\
+	INT32 blendr, blendg, blendb, blenda;										\
+	INT32 tr, tg, tb, ta;														\
+	INT32 s, t, lod, ilod;														\
+	INT64 oow;																	\
+	INT32 smax, tmax;															\
+	UINT32 texbase;																\
+	rgb_union c_local;															\
+																				\
+	/* determine the S/T/LOD values for this texture */							\
+	if (TEXMODE_ENABLE_PERSPECTIVE(TEXMODE))									\
+	{																			\
+		oow = fast_reciplog((ITERW), &lod);										\
+		s = (INT32)((oow * (ITERS)) >> 29);										\
+		t = (INT32)((oow * (ITERT)) >> 29);										\
+		lod += (LODBASE);														\
+	}																			\
+	else																		\
+	{																			\
+		s = (INT32)((ITERS) >> 14);												\
+		t = (INT32)((ITERT) >> 14);												\
+		lod = (LODBASE);														\
+	}																			\
+																				\
+	/* clamp W */																\
+	if (TEXMODE_CLAMP_NEG_W(TEXMODE) && (ITERW) < 0)							\
+		s = t = 0;																\
+																				\
+	/* clamp the LOD */															\
+	lod += (TT)->lodbias;														\
+	if (TEXMODE_ENABLE_LOD_DITHER(TEXMODE))										\
+		if (DITHER4)															\
+			lod += DITHER4[(XX) & 3] << 4;										\
+	if (lod < (TT)->lodmin)														\
+		lod = (TT)->lodmin;														\
+	if (lod > (TT)->lodmax)														\
+		lod = (TT)->lodmax;														\
+																				\
+	/* now the LOD is in range; if we don't own this LOD, take the next one */	\
+	ilod = lod >> 8;															\
+	if (!(((TT)->lodmask >> ilod) & 1))											\
+		ilod++;																	\
+																				\
+	/* fetch the texture base */												\
+	texbase = (TT)->lodoffset[ilod];											\
+																				\
+	/* compute the maximum s and t values at this LOD */						\
+	smax = (TT)->wmask >> ilod;													\
+	tmax = (TT)->hmask >> ilod;													\
+																				\
+	/* determine whether we are point-sampled or bilinear */					\
+	if ((lod == (TT)->lodmin && !TEXMODE_MAGNIFICATION_FILTER(TEXMODE)) ||		\
+		(lod != (TT)->lodmin && !TEXMODE_MINIFICATION_FILTER(TEXMODE)))			\
+	{																			\
+		/* point sampled */														\
+																				\
+		UINT32 texel0;															\
+																				\
+		/* adjust S/T for the LOD and strip off the fractions */				\
+		s >>= ilod + 18;														\
+		t >>= ilod + 18;														\
+																				\
+		/* clamp/wrap S/T if necessary */										\
+		if (TEXMODE_CLAMP_S(TEXMODE))											\
+			CLAMP(s, 0, smax);													\
+		if (TEXMODE_CLAMP_T(TEXMODE))											\
+			CLAMP(t, 0, tmax);													\
+		s &= smax;																\
+		t &= tmax;																\
+		t *= smax + 1;															\
+																				\
+		/* fetch texel data */													\
+		if (TEXMODE_FORMAT(TEXMODE) < 8)										\
+		{																		\
+			texel0 = *(UINT8 *)&(TT)->ram[(texbase + t + s) & (TT)->mask];		\
+			c_local.u = (LOOKUP)[texel0];										\
+		}																		\
+		else																	\
+		{																		\
+			texel0 = *(UINT16 *)&(TT)->ram[(texbase + 2*(t + s)) & (TT)->mask];	\
+			if (TEXMODE_FORMAT(TEXMODE) >= 10 && TEXMODE_FORMAT(TEXMODE) <= 12)	\
+				c_local.u = (LOOKUP)[texel0];									\
+			else																\
+				c_local.u = ((LOOKUP)[texel0 & 0xff] & 0xffffff) |				\
+							((texel0 & 0xff00) << 16);							\
+		}																		\
+	}																			\
+	else																		\
+	{																			\
+		/* bilinear filtered */													\
+																				\
+		UINT32 texel0, texel1, texel2, texel3;									\
+		UINT8 sfrac, tfrac;														\
+		INT32 s1, t1;															\
+																				\
+		/* adjust S/T for the LOD and strip off all but the low 8 bits of */	\
+		/* the fraction */														\
+		s >>= ilod + 10;														\
+		t >>= ilod + 10;														\
+																				\
+		/* also subtract 1/2 texel so that (0.5,0.5) = a full (0,0) texel */	\
+		s -= 0x80;																\
+		t -= 0x80;																\
+																				\
+		/* extract the fractions */												\
+		sfrac = (UINT8)(s & (TT)->bilinear_mask);								\
+		tfrac = (UINT8)(t & (TT)->bilinear_mask);								\
+																				\
+		/* now toss the rest */													\
+		s >>= 8;																\
+		t >>= 8;																\
+		s1 = s + 1;																\
+		t1 = t + 1;																\
+																				\
+		/* clamp/wrap S/T if necessary */										\
+		if (TEXMODE_CLAMP_S(TEXMODE))											\
+		{																		\
+			CLAMP(s, 0, smax);													\
+			CLAMP(s1, 0, smax);													\
+		}																		\
+		if (TEXMODE_CLAMP_T(TEXMODE))											\
+		{																		\
+			CLAMP(t, 0, tmax);													\
+			CLAMP(t1, 0, tmax);													\
+		}																		\
+		s &= smax;																\
+		s1 &= smax;																\
+		t &= tmax;																\
+		t1 &= tmax;																\
+		t *= smax + 1;															\
+		t1 *= smax + 1;															\
+																				\
+		/* fetch texel data */													\
+		if (TEXMODE_FORMAT(TEXMODE) < 8)										\
+		{																		\
+			texel0 = *(UINT8 *)&(TT)->ram[(texbase + t + s) & (TT)->mask];		\
+			texel1 = *(UINT8 *)&(TT)->ram[(texbase + t + s1) & (TT)->mask];		\
+			texel2 = *(UINT8 *)&(TT)->ram[(texbase + t1 + s) & (TT)->mask];		\
+			texel3 = *(UINT8 *)&(TT)->ram[(texbase + t1 + s1) & (TT)->mask];	\
+			texel0 = (LOOKUP)[texel0];											\
+			texel1 = (LOOKUP)[texel1];											\
+			texel2 = (LOOKUP)[texel2];											\
+			texel3 = (LOOKUP)[texel3];											\
+		}																		\
+		else																	\
+		{																		\
+			texel0 = *(UINT16 *)&(TT)->ram[(texbase + 2*(t + s)) & (TT)->mask];	\
+			texel1 = *(UINT16 *)&(TT)->ram[(texbase + 2*(t + s1)) & (TT)->mask];\
+			texel2 = *(UINT16 *)&(TT)->ram[(texbase + 2*(t1 + s)) & (TT)->mask];\
+			texel3 = *(UINT16 *)&(TT)->ram[(texbase + 2*(t1 + s1)) & (TT)->mask];\
+			if (TEXMODE_FORMAT(TEXMODE) >= 10 && TEXMODE_FORMAT(TEXMODE) <= 12)	\
+			{																	\
+				texel0 = (LOOKUP)[texel0];										\
+				texel1 = (LOOKUP)[texel1];										\
+				texel2 = (LOOKUP)[texel2];										\
+				texel3 = (LOOKUP)[texel3];										\
+			}																	\
+			else																\
+			{																	\
+				texel0 = ((LOOKUP)[texel0 & 0xff] & 0xffffff) | 				\
+							((texel0 & 0xff00) << 16);							\
+				texel1 = ((LOOKUP)[texel1 & 0xff] & 0xffffff) | 				\
+							((texel1 & 0xff00) << 16);							\
+				texel2 = ((LOOKUP)[texel2 & 0xff] & 0xffffff) | 				\
+							((texel2 & 0xff00) << 16);							\
+				texel3 = ((LOOKUP)[texel3 & 0xff] & 0xffffff) | 				\
+							((texel3 & 0xff00) << 16);							\
+			}																	\
+		}																		\
+																				\
+		/* weigh in each texel */												\
+		c_local.u = rgba_bilinear_filter(texel0, texel1, texel2, texel3, sfrac, tfrac);\
+	}																			\
+																				\
+	/* select zero/other for RGB */												\
+	if (!TEXMODE_TC_ZERO_OTHER(TEXMODE))										\
+	{																			\
+		tr = COTHER.rgb.r;														\
+		tg = COTHER.rgb.g;														\
+		tb = COTHER.rgb.b;														\
+	}																			\
+	else																		\
+		tr = tg = tb = 0;														\
+																				\
+	/* select zero/other for alpha */											\
+	if (!TEXMODE_TCA_ZERO_OTHER(TEXMODE))										\
+		ta = COTHER.rgb.a;														\
+	else																		\
+		ta = 0;																	\
+																				\
+	/* potentially subtract c_local */											\
+	if (TEXMODE_TC_SUB_CLOCAL(TEXMODE))											\
+	{																			\
+		tr -= c_local.rgb.r;													\
+		tg -= c_local.rgb.g;													\
+		tb -= c_local.rgb.b;													\
+	}																			\
+	if (TEXMODE_TCA_SUB_CLOCAL(TEXMODE))										\
+		ta -= c_local.rgb.a;													\
+																				\
+	/* blend RGB */																\
+	switch (TEXMODE_TC_MSELECT(TEXMODE))										\
+	{																			\
+		default:	/* reserved */												\
+		case 0:		/* zero */													\
+			blendr = blendg = blendb = 0;										\
+			break;																\
+																				\
+		case 1:		/* c_local */												\
+			blendr = c_local.rgb.r;												\
+			blendg = c_local.rgb.g;												\
+			blendb = c_local.rgb.b;												\
+			break;																\
+																				\
+		case 2:		/* a_other */												\
+			blendr = blendg = blendb = COTHER.rgb.a;							\
+			break;																\
+																				\
+		case 3:		/* a_local */												\
+			blendr = blendg = blendb = c_local.rgb.a;							\
+			break;																\
+																				\
+		case 4:		/* LOD (detail factor) */									\
+			if ((TT)->detailbias <= lod)										\
+				blendr = blendg = blendb = 0;									\
+			else																\
+			{																	\
+				blendr = ((((TT)->detailbias - lod) << (TT)->detailscale) >> 8);\
+				if (blendr > (TT)->detailmax)									\
+					blendr = (TT)->detailmax;									\
+				blendg = blendb = blendr;										\
+			}																	\
+			break;																\
+																				\
+		case 5:		/* LOD fraction */											\
+			blendr = blendg = blendb = lod & 0xff;								\
+			break;																\
+	}																			\
+																				\
+	/* blend alpha */															\
+	switch (TEXMODE_TCA_MSELECT(TEXMODE))										\
+	{																			\
+		default:	/* reserved */												\
+		case 0:		/* zero */													\
+			blenda = 0;															\
+			break;																\
+																				\
+		case 1:		/* c_local */												\
+			blenda = c_local.rgb.a;												\
+			break;																\
+																				\
+		case 2:		/* a_other */												\
+			blenda = COTHER.rgb.a;												\
+			break;																\
+																				\
+		case 3:		/* a_local */												\
+			blenda = c_local.rgb.a;												\
+			break;																\
+																				\
+		case 4:		/* LOD (detail factor) */									\
+			if ((TT)->detailbias <= lod)										\
+				blenda = 0;														\
+			else																\
+			{																	\
+				blenda = ((((TT)->detailbias - lod) << (TT)->detailscale) >> 8);\
+				if (blenda > (TT)->detailmax)									\
+					blenda = (TT)->detailmax;									\
+			}																	\
+			break;																\
+																				\
+		case 5:		/* LOD fraction */											\
+			blenda = lod & 0xff;												\
+			break;																\
+	}																			\
+																				\
+	/* reverse the RGB blend */													\
+	if (!TEXMODE_TC_REVERSE_BLEND(TEXMODE))										\
+	{																			\
+		blendr ^= 0xff;															\
+		blendg ^= 0xff;															\
+		blendb ^= 0xff;															\
+	}																			\
+																				\
+	/* reverse the alpha blend */												\
+	if (!TEXMODE_TCA_REVERSE_BLEND(TEXMODE))									\
+		blenda ^= 0xff;															\
+																				\
+	/* do the blend */															\
+	tr = (tr * (blendr + 1)) >> 8;												\
+	tg = (tg * (blendg + 1)) >> 8;												\
+	tb = (tb * (blendb + 1)) >> 8;												\
+	ta = (ta * (blenda + 1)) >> 8;												\
+																				\
+	/* add clocal or alocal to RGB */											\
+	switch (TEXMODE_TC_ADD_ACLOCAL(TEXMODE))									\
+	{																			\
+		case 3:		/* reserved */												\
+		case 0:		/* nothing */												\
+			break;																\
+																				\
+		case 1:		/* add c_local */											\
+			tr += c_local.rgb.r;												\
+			tg += c_local.rgb.g;												\
+			tb += c_local.rgb.b;												\
+			break;																\
+																				\
+		case 2:		/* add_alocal */											\
+			tr += c_local.rgb.a;												\
+			tg += c_local.rgb.a;												\
+			tb += c_local.rgb.a;												\
+			break;																\
+	}																			\
+																				\
+	/* add clocal or alocal to alpha */											\
+	if (TEXMODE_TCA_ADD_ACLOCAL(TEXMODE))										\
+		ta += c_local.rgb.a;													\
+																				\
+	/* clamp */																	\
+	RESULT.rgb.r = (tr < 0) ? 0 : (tr > 0xff) ? 0xff : (UINT8)tr;				\
+	RESULT.rgb.g = (tg < 0) ? 0 : (tg > 0xff) ? 0xff : (UINT8)tg;				\
+	RESULT.rgb.b = (tb < 0) ? 0 : (tb > 0xff) ? 0xff : (UINT8)tb;				\
+	RESULT.rgb.a = (ta < 0) ? 0 : (ta > 0xff) ? 0xff : (UINT8)ta;				\
+																				\
+	/* invert */																\
+	if (TEXMODE_TC_INVERT_OUTPUT(TEXMODE))										\
+		RESULT.u ^= 0x00ffffff;													\
+	if (TEXMODE_TCA_INVERT_OUTPUT(TEXMODE))										\
+		RESULT.rgb.a ^= 0xff;													\
+}																				\
+while (0)
+
+
+
+/*************************************
+ *
+ *  Pixel pipeline macros
+ *
+ *************************************/
+
+#define PIXEL_PIPELINE_BEGIN(VV, XX, YY, FBZCOLORPATH, FBZMODE, ITERZ, ITERW)	\
+do																				\
+{																				\
+	INT32 depthval, wfloat;														\
+	INT32 prefogr, prefogg, prefogb;											\
+	INT32 r, g, b, a;															\
+																				\
+	/* apply clipping */														\
+	/* note that for perf reasons, we assume the caller has done clipping */	\
+																				\
+	/* handle stippling */														\
+	if (FBZMODE_ENABLE_STIPPLE(FBZMODE))										\
+	{																			\
+		/* rotate mode */														\
+		if (FBZMODE_STIPPLE_PATTERN(FBZMODE) == 0)								\
+		{																		\
+			(VV)->reg[stipple].u = ((VV)->reg[stipple].u << 1) | ((VV)->reg[stipple].u >> 31);\
+			if (((VV)->reg[stipple].u & 0x80000000) == 0)						\
+			{																	\
+				goto skipdrawdepth;												\
+			}																	\
+		}																		\
+																				\
+		/* pattern mode */														\
+		else																	\
+		{																		\
+			int stipple_index = (((YY) & 3) << 3) | (~(XX) & 7);				\
+			if ((((VV)->reg[stipple].u >> stipple_index) & 1) == 0)				\
+			{																	\
+				goto skipdrawdepth;												\
+			}																	\
+		}																		\
+	}																			\
+																				\
+	/* compute "floating point" W value (used for depth and fog) */				\
+	if ((ITERW) & LONGTYPE(0xffff00000000))											\
+		wfloat = 0x0000;														\
+	else																		\
+	{																			\
+		UINT32 temp = (UINT32)(ITERW);											\
+		if ((temp & 0xffff0000) == 0)											\
+			wfloat = 0xffff;													\
+		else																	\
+		{																		\
+			int exp = count_leading_zeros(temp);								\
+			wfloat = ((exp << 12) | ((~temp >> (19 - exp)) & 0xfff));			\
+			if (wfloat < 0xffff) wfloat++;										\
+		}																		\
+	}																			\
+																				\
+	/* compute depth value (W or Z) for this pixel */							\
+	if (FBZMODE_WBUFFER_SELECT(FBZMODE) == 0)									\
+		CLAMPED_Z(ITERZ, FBZCOLORPATH, depthval);								\
+	else if (FBZMODE_DEPTH_FLOAT_SELECT(FBZMODE) == 0)							\
+		depthval = wfloat;														\
+	else																		\
+	{																			\
+		if ((ITERZ) & 0xf0000000)												\
+			depthval = 0x0000;													\
+		else																	\
+		{																		\
+			UINT32 temp = (ITERZ) << 4;											\
+			if ((temp & 0xffff0000) == 0)										\
+				depthval = 0xffff;												\
+			else																\
+			{																	\
+				int exp = count_leading_zeros(temp);							\
+				depthval = ((exp << 12) | ((~temp >> (19 - exp)) & 0xfff));		\
+				if (depthval < 0xffff) depthval++;								\
+			}																	\
+		}																		\
+	}																			\
+																				\
+	/* add the bias */															\
+	if (FBZMODE_ENABLE_DEPTH_BIAS(FBZMODE))										\
+	{																			\
+		depthval += (INT16)(VV)->reg[zaColor].u;								\
+		CLAMP(depthval, 0, 0xffff);												\
+	}																			\
+																				\
+	/* handle depth buffer testing */											\
+	if (FBZMODE_ENABLE_DEPTHBUF(FBZMODE))										\
+	{																			\
+		INT32 depthsource;														\
+																				\
+		/* the source depth is either the iterated W/Z+bias or a */				\
+		/* constant value */													\
+		if (FBZMODE_DEPTH_SOURCE_COMPARE(FBZMODE) == 0)							\
+			depthsource = depthval;												\
+		else																	\
+			depthsource = (UINT16)(VV)->reg[zaColor].u;							\
+																				\
+		/* test against the depth buffer */										\
+		switch (FBZMODE_DEPTH_FUNCTION(FBZMODE))								\
+		{																		\
+			case 0:		/* depthOP = never */									\
+				goto skipdrawdepth;												\
+																				\
+			case 1:		/* depthOP = less than */								\
+				if (depth)														\
+					if (depthsource >= depth[XX])								\
+					{															\
+						goto skipdrawdepth;										\
+					}															\
+				break;															\
+																				\
+			case 2:		/* depthOP = equal */									\
+				if (depth)														\
+					if (depthsource != depth[XX])								\
+					{															\
+						goto skipdrawdepth;										\
+					}															\
+				break;															\
+																				\
+			case 3:		/* depthOP = less than or equal */						\
+				if (depth)														\
+					if (depthsource > depth[XX])								\
+					{															\
+						goto skipdrawdepth;										\
+					}															\
+				break;															\
+																				\
+			case 4:		/* depthOP = greater than */							\
+				if (depth)														\
+					if (depthsource <= depth[XX])								\
+					{															\
+						goto skipdrawdepth;										\
+					}															\
+				break;															\
+																				\
+			case 5:		/* depthOP = not equal */								\
+				if (depth)														\
+					if (depthsource == depth[XX])								\
+					{															\
+						goto skipdrawdepth;										\
+					}															\
+				break;															\
+																				\
+			case 6:		/* depthOP = greater than or equal */					\
+				if (depth)														\
+					if (depthsource < depth[XX])								\
+					{															\
+						goto skipdrawdepth;										\
+					}															\
+				break;															\
+																				\
+			case 7:		/* depthOP = always */									\
+				break;															\
+		}																		\
+	}
+
+
+#define PIXEL_PIPELINE_MODIFY(VV, DITHER, DITHER4, XX, FBZMODE, FBZCOLORPATH, ALPHAMODE, FOGMODE, ITERZ, ITERW, ITERAXXX) \
+																				\
+	/* perform fogging */														\
+	prefogr = r;																\
+	prefogg = g;																\
+	prefogb = b;																\
+	APPLY_FOGGING(VV, FOGMODE, FBZCOLORPATH, XX, DITHER4, r, g, b,				\
+					ITERZ, ITERW, ITERAXXX);									\
+																				\
+	/* perform alpha blending */												\
+	APPLY_ALPHA_BLEND(FBZMODE, ALPHAMODE, XX, DITHER, r, g, b, a);
+
+
+#define PIXEL_PIPELINE_FINISH(VV, DITHER_LOOKUP, XX, dest, depth, FBZMODE)		\
+																				\
+	/* write to framebuffer */													\
+	if (FBZMODE_RGB_BUFFER_MASK(FBZMODE))										\
+	{																			\
+		/* apply dithering */													\
+		APPLY_DITHER(FBZMODE, XX, DITHER_LOOKUP, r, g, b);						\
+		dest[XX] = (UINT16)((r << 11) | (g << 5) | b);							\
+	}																			\
+																				\
+	/* write to aux buffer */													\
+	if (depth && FBZMODE_AUX_BUFFER_MASK(FBZMODE))								\
+	{																			\
+		if (FBZMODE_ENABLE_ALPHA_PLANES(FBZMODE) == 0)							\
+			depth[XX] = (UINT16)depthval;										\
+		else																	\
+			depth[XX] = (UINT16)a;												\
+	}
+
+#define PIXEL_PIPELINE_END(STATS)												\
+																				\
+	/* track pixel writes to the frame buffer regardless of mask */				\
+	(STATS)->pixels_out++;														\
+																				\
+skipdrawdepth:																	\
+	;																			\
+}																				\
+while (0)
+
+#endif
diff --git a/src/hardware/voodoo_def.h b/src/hardware/voodoo_def.h
new file mode 100644
index 000000000..90cd7019f
--- /dev/null
+++ b/src/hardware/voodoo_def.h
@@ -0,0 +1,559 @@
+/***************************************************************************/
+/*        Portion of this software comes with the following license:       */
+/***************************************************************************/
+/*
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+/*************************************************************************
+
+    3dfx Voodoo Graphics SST-1/2 emulator
+
+    emulator by Aaron Giles
+
+**************************************************************************/
+
+
+#ifndef DOSBOX_VOODOO_DEF_H
+#define DOSBOX_VOODOO_DEF_H
+
+
+/*************************************
+ *
+ *  Register constants
+ *
+ *************************************/
+
+/* Codes to the right:
+    R = readable
+    W = writeable
+    P = pipelined
+    F = goes to FIFO
+*/
+
+/* 0x000 */
+#define status			(0x000/4)	/* R  P  */
+#define intrCtrl		(0x004/4)	/* RW P   -- Voodoo2/Banshee only */
+#define vertexAx		(0x008/4)	/*  W PF */
+#define vertexAy		(0x00c/4)	/*  W PF */
+#define vertexBx		(0x010/4)	/*  W PF */
+#define vertexBy		(0x014/4)	/*  W PF */
+#define vertexCx		(0x018/4)	/*  W PF */
+#define vertexCy		(0x01c/4)	/*  W PF */
+#define startR			(0x020/4)	/*  W PF */
+#define startG			(0x024/4)	/*  W PF */
+#define startB			(0x028/4)	/*  W PF */
+#define startZ			(0x02c/4)	/*  W PF */
+#define startA			(0x030/4)	/*  W PF */
+#define startS			(0x034/4)	/*  W PF */
+#define startT			(0x038/4)	/*  W PF */
+#define startW			(0x03c/4)	/*  W PF */
+
+/* 0x040 */
+#define dRdX			(0x040/4)	/*  W PF */
+#define dGdX			(0x044/4)	/*  W PF */
+#define dBdX			(0x048/4)	/*  W PF */
+#define dZdX			(0x04c/4)	/*  W PF */
+#define dAdX			(0x050/4)	/*  W PF */
+#define dSdX			(0x054/4)	/*  W PF */
+#define dTdX			(0x058/4)	/*  W PF */
+#define dWdX			(0x05c/4)	/*  W PF */
+#define dRdY			(0x060/4)	/*  W PF */
+#define dGdY			(0x064/4)	/*  W PF */
+#define dBdY			(0x068/4)	/*  W PF */
+#define dZdY			(0x06c/4)	/*  W PF */
+#define dAdY			(0x070/4)	/*  W PF */
+#define dSdY			(0x074/4)	/*  W PF */
+#define dTdY			(0x078/4)	/*  W PF */
+#define dWdY			(0x07c/4)	/*  W PF */
+
+/* 0x080 */
+#define triangleCMD		(0x080/4)	/*  W PF */
+#define fvertexAx		(0x088/4)	/*  W PF */
+#define fvertexAy		(0x08c/4)	/*  W PF */
+#define fvertexBx		(0x090/4)	/*  W PF */
+#define fvertexBy		(0x094/4)	/*  W PF */
+#define fvertexCx		(0x098/4)	/*  W PF */
+#define fvertexCy		(0x09c/4)	/*  W PF */
+#define fstartR			(0x0a0/4)	/*  W PF */
+#define fstartG			(0x0a4/4)	/*  W PF */
+#define fstartB			(0x0a8/4)	/*  W PF */
+#define fstartZ			(0x0ac/4)	/*  W PF */
+#define fstartA			(0x0b0/4)	/*  W PF */
+#define fstartS			(0x0b4/4)	/*  W PF */
+#define fstartT			(0x0b8/4)	/*  W PF */
+#define fstartW			(0x0bc/4)	/*  W PF */
+
+/* 0x0c0 */
+#define fdRdX			(0x0c0/4)	/*  W PF */
+#define fdGdX			(0x0c4/4)	/*  W PF */
+#define fdBdX			(0x0c8/4)	/*  W PF */
+#define fdZdX			(0x0cc/4)	/*  W PF */
+#define fdAdX			(0x0d0/4)	/*  W PF */
+#define fdSdX			(0x0d4/4)	/*  W PF */
+#define fdTdX			(0x0d8/4)	/*  W PF */
+#define fdWdX			(0x0dc/4)	/*  W PF */
+#define fdRdY			(0x0e0/4)	/*  W PF */
+#define fdGdY			(0x0e4/4)	/*  W PF */
+#define fdBdY			(0x0e8/4)	/*  W PF */
+#define fdZdY			(0x0ec/4)	/*  W PF */
+#define fdAdY			(0x0f0/4)	/*  W PF */
+#define fdSdY			(0x0f4/4)	/*  W PF */
+#define fdTdY			(0x0f8/4)	/*  W PF */
+#define fdWdY			(0x0fc/4)	/*  W PF */
+
+/* 0x100 */
+#define ftriangleCMD	(0x100/4)	/*  W PF */
+#define fbzColorPath	(0x104/4)	/* RW PF */
+#define fogMode			(0x108/4)	/* RW PF */
+#define alphaMode		(0x10c/4)	/* RW PF */
+#define fbzMode			(0x110/4)	/* RW  F */
+#define lfbMode			(0x114/4)	/* RW  F */
+#define clipLeftRight	(0x118/4)	/* RW  F */
+#define clipLowYHighY	(0x11c/4)	/* RW  F */
+#define nopCMD			(0x120/4)	/*  W  F */
+#define fastfillCMD		(0x124/4)	/*  W  F */
+#define swapbufferCMD	(0x128/4)	/*  W  F */
+#define fogColor		(0x12c/4)	/*  W  F */
+#define zaColor			(0x130/4)	/*  W  F */
+#define chromaKey		(0x134/4)	/*  W  F */
+#define chromaRange		(0x138/4)	/*  W  F  -- Voodoo2/Banshee only */
+#define userIntrCMD		(0x13c/4)	/*  W  F  -- Voodoo2/Banshee only */
+
+/* 0x140 */
+#define stipple			(0x140/4)	/* RW  F */
+#define color0			(0x144/4)	/* RW  F */
+#define color1			(0x148/4)	/* RW  F */
+#define fbiPixelsIn		(0x14c/4)	/* R     */
+#define fbiChromaFail	(0x150/4)	/* R     */
+#define fbiZfuncFail	(0x154/4)	/* R     */
+#define fbiAfuncFail	(0x158/4)	/* R     */
+#define fbiPixelsOut	(0x15c/4)	/* R     */
+#define fogTable		(0x160/4)	/*  W  F */
+
+/* 0x1c0 */
+#define cmdFifoBaseAddr	(0x1e0/4)	/* RW     -- Voodoo2 only */
+#define cmdFifoBump		(0x1e4/4)	/* RW     -- Voodoo2 only */
+#define cmdFifoRdPtr	(0x1e8/4)	/* RW     -- Voodoo2 only */
+#define cmdFifoAMin		(0x1ec/4)	/* RW     -- Voodoo2 only */
+#define colBufferAddr	(0x1ec/4)	/* RW     -- Banshee only */
+#define cmdFifoAMax		(0x1f0/4)	/* RW     -- Voodoo2 only */
+#define colBufferStride	(0x1f0/4)	/* RW     -- Banshee only */
+#define cmdFifoDepth	(0x1f4/4)	/* RW     -- Voodoo2 only */
+#define auxBufferAddr	(0x1f4/4)	/* RW     -- Banshee only */
+#define cmdFifoHoles	(0x1f8/4)	/* RW     -- Voodoo2 only */
+#define auxBufferStride	(0x1f8/4)	/* RW     -- Banshee only */
+
+/* 0x200 */
+#define fbiInit4		(0x200/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define clipLeftRight1	(0x200/4)	/* RW     -- Banshee only */
+#define vRetrace		(0x204/4)	/* R      -- Voodoo/Voodoo2 only */
+#define clipTopBottom1	(0x204/4)	/* RW     -- Banshee only */
+#define backPorch		(0x208/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define videoDimensions	(0x20c/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define fbiInit0		(0x210/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define fbiInit1		(0x214/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define fbiInit2		(0x218/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define fbiInit3		(0x21c/4)	/* RW     -- Voodoo/Voodoo2 only */
+#define hSync			(0x220/4)	/*  W     -- Voodoo/Voodoo2 only */
+#define vSync			(0x224/4)	/*  W     -- Voodoo/Voodoo2 only */
+#define clutData		(0x228/4)	/*  W  F  -- Voodoo/Voodoo2 only */
+#define dacData			(0x22c/4)	/*  W     -- Voodoo/Voodoo2 only */
+#define maxRgbDelta		(0x230/4)	/*  W     -- Voodoo/Voodoo2 only */
+#define hBorder			(0x234/4)	/*  W     -- Voodoo2 only */
+#define vBorder			(0x238/4)	/*  W     -- Voodoo2 only */
+#define borderColor		(0x23c/4)	/*  W     -- Voodoo2 only */
+
+/* 0x240 */
+#define hvRetrace		(0x240/4)	/* R      -- Voodoo2 only */
+#define fbiInit5		(0x244/4)	/* RW     -- Voodoo2 only */
+#define fbiInit6		(0x248/4)	/* RW     -- Voodoo2 only */
+#define fbiInit7		(0x24c/4)	/* RW     -- Voodoo2 only */
+#define swapPending		(0x24c/4)	/*  W     -- Banshee only */
+#define leftOverlayBuf	(0x250/4)	/*  W     -- Banshee only */
+#define rightOverlayBuf	(0x254/4)	/*  W     -- Banshee only */
+#define fbiSwapHistory	(0x258/4)	/* R      -- Voodoo2/Banshee only */
+#define fbiTrianglesOut	(0x25c/4)	/* R      -- Voodoo2/Banshee only */
+#define sSetupMode		(0x260/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sVx				(0x264/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sVy				(0x268/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sARGB			(0x26c/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sRed			(0x270/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sGreen			(0x274/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sBlue			(0x278/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sAlpha			(0x27c/4)	/*  W PF  -- Voodoo2/Banshee only */
+
+/* 0x280 */
+#define sVz				(0x280/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sWb				(0x284/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sWtmu0			(0x288/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sS_W0			(0x28c/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sT_W0			(0x290/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sWtmu1			(0x294/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sS_Wtmu1		(0x298/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sT_Wtmu1		(0x29c/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sDrawTriCMD		(0x2a0/4)	/*  W PF  -- Voodoo2/Banshee only */
+#define sBeginTriCMD	(0x2a4/4)	/*  W PF  -- Voodoo2/Banshee only */
+
+/* 0x2c0 */
+#define bltSrcBaseAddr	(0x2c0/4)	/* RW PF  -- Voodoo2 only */
+#define bltDstBaseAddr	(0x2c4/4)	/* RW PF  -- Voodoo2 only */
+#define bltXYStrides	(0x2c8/4)	/* RW PF  -- Voodoo2 only */
+#define bltSrcChromaRange (0x2cc/4)	/* RW PF  -- Voodoo2 only */
+#define bltDstChromaRange (0x2d0/4)	/* RW PF  -- Voodoo2 only */
+#define bltClipX		(0x2d4/4)	/* RW PF  -- Voodoo2 only */
+#define bltClipY		(0x2d8/4)	/* RW PF  -- Voodoo2 only */
+#define bltSrcXY		(0x2e0/4)	/* RW PF  -- Voodoo2 only */
+#define bltDstXY		(0x2e4/4)	/* RW PF  -- Voodoo2 only */
+#define bltSize			(0x2e8/4)	/* RW PF  -- Voodoo2 only */
+#define bltRop			(0x2ec/4)	/* RW PF  -- Voodoo2 only */
+#define bltColor		(0x2f0/4)	/* RW PF  -- Voodoo2 only */
+#define bltCommand		(0x2f8/4)	/* RW PF  -- Voodoo2 only */
+#define bltData			(0x2fc/4)	/*  W PF  -- Voodoo2 only */
+
+/* 0x300 */
+#define textureMode		(0x300/4)	/*  W PF */
+#define tLOD			(0x304/4)	/*  W PF */
+#define tDetail			(0x308/4)	/*  W PF */
+#define texBaseAddr		(0x30c/4)	/*  W PF */
+#define texBaseAddr_1	(0x310/4)	/*  W PF */
+#define texBaseAddr_2	(0x314/4)	/*  W PF */
+#define texBaseAddr_3_8	(0x318/4)	/*  W PF */
+#define trexInit0		(0x31c/4)	/*  W  F  -- Voodoo/Voodoo2 only */
+#define trexInit1		(0x320/4)	/*  W  F */
+#define nccTable		(0x324/4)	/*  W  F */
+
+
+
+/*************************************
+ *
+ *  Alias map of the first 64
+ *  registers when remapped
+ *
+ *************************************/
+
+static const UINT8 register_alias_map[0x40] =
+{
+	status,		0x004/4,	vertexAx,	vertexAy,
+	vertexBx,	vertexBy,	vertexCx,	vertexCy,
+	startR,		dRdX,		dRdY,		startG,
+	dGdX,		dGdY,		startB,		dBdX,
+	dBdY,		startZ,		dZdX,		dZdY,
+	startA,		dAdX,		dAdY,		startS,
+	dSdX,		dSdY,		startT,		dTdX,
+	dTdY,		startW,		dWdX,		dWdY,
+
+	triangleCMD,0x084/4,	fvertexAx,	fvertexAy,
+	fvertexBx,	fvertexBy,	fvertexCx,	fvertexCy,
+	fstartR,	fdRdX,		fdRdY,		fstartG,
+	fdGdX,		fdGdY,		fstartB,	fdBdX,
+	fdBdY,		fstartZ,	fdZdX,		fdZdY,
+	fstartA,	fdAdX,		fdAdY,		fstartS,
+	fdSdX,		fdSdY,		fstartT,	fdTdX,
+	fdTdY,		fstartW,	fdWdX,		fdWdY
+};
+
+
+
+/*************************************
+ *
+ *  Table of per-register access rights
+ *
+ *************************************/
+
+static const UINT8 voodoo_register_access[0x100] =
+{
+	/* 0x000 */
+	REG_RP,		0,			REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x040 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x080 */
+	REG_WPF,	0,			REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x0c0 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x100 */
+	REG_WPF,	REG_RWPF,	REG_RWPF,	REG_RWPF,
+	REG_RWF,	REG_RWF,	REG_RWF,	REG_RWF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		0,			0,
+
+	/* 0x140 */
+	REG_RWF,	REG_RWF,	REG_RWF,	REG_R,
+	REG_R,		REG_R,		REG_R,		REG_R,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x180 */
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x1c0 */
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+
+	/* 0x200 */
+	REG_RW,		REG_R,		REG_RW,		REG_RW,
+	REG_RW,		REG_RW,		REG_RW,		REG_RW,
+	REG_W,		REG_W,		REG_W,		REG_W,
+	REG_W,		0,			0,			0,
+
+	/* 0x240 */
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+
+	/* 0x280 */
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+
+	/* 0x2c0 */
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+	0,			0,			0,			0,
+
+	/* 0x300 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x340 */
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x380 */
+	REG_WF
+};
+
+
+static const UINT8 voodoo2_register_access[0x100] =
+{
+	/* 0x000 */
+	REG_RP,		REG_RWPT,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x040 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x080 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x0c0 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x100 */
+	REG_WPF,	REG_RWPF,	REG_RWPF,	REG_RWPF,
+	REG_RWF,	REG_RWF,	REG_RWF,	REG_RWF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x140 */
+	REG_RWF,	REG_RWF,	REG_RWF,	REG_R,
+	REG_R,		REG_R,		REG_R,		REG_R,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x180 */
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x1c0 */
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_RWT,	REG_RWT,	REG_RWT,	REG_RWT,
+	REG_RWT,	REG_RWT,	REG_RWT,	REG_RW,
+
+	/* 0x200 */
+	REG_RWT,	REG_R,		REG_RWT,	REG_RWT,
+	REG_RWT,	REG_RWT,	REG_RWT,	REG_RWT,
+	REG_WT,		REG_WT,		REG_WF,		REG_WT,
+	REG_WT,		REG_WT,		REG_WT,		REG_WT,
+
+	/* 0x240 */
+	REG_R,		REG_RWT,	REG_RWT,	REG_RWT,
+	0,			0,			REG_R,		REG_R,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+
+	/* 0x280 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	0,			0,
+	0,			0,			0,			0,
+
+	/* 0x2c0 */
+	REG_RWPF,	REG_RWPF,	REG_RWPF,	REG_RWPF,
+	REG_RWPF,	REG_RWPF,	REG_RWPF,	REG_RWPF,
+	REG_RWPF,	REG_RWPF,	REG_RWPF,	REG_RWPF,
+	REG_RWPF,	REG_RWPF,	REG_RWPF,	REG_WPF,
+
+	/* 0x300 */
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WPF,
+	REG_WPF,	REG_WPF,	REG_WPF,	REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x340 */
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+	REG_WF,		REG_WF,		REG_WF,		REG_WF,
+
+	/* 0x380 */
+	REG_WF
+};
+
+
+
+/*************************************
+ *
+ *  Register string table for debug
+ *
+ *************************************/
+
+static const char *const voodoo_reg_name[] =
+{
+	/* 0x000 */
+	"status",		"{intrCtrl}",	"vertexAx",		"vertexAy",
+	"vertexBx",		"vertexBy",		"vertexCx",		"vertexCy",
+	"startR",		"startG",		"startB",		"startZ",
+	"startA",		"startS",		"startT",		"startW",
+	/* 0x040 */
+	"dRdX",			"dGdX",			"dBdX",			"dZdX",
+	"dAdX",			"dSdX",			"dTdX",			"dWdX",
+	"dRdY",			"dGdY",			"dBdY",			"dZdY",
+	"dAdY",			"dSdY",			"dTdY",			"dWdY",
+	/* 0x080 */
+	"triangleCMD",	"reserved084",	"fvertexAx",	"fvertexAy",
+	"fvertexBx",	"fvertexBy",	"fvertexCx",	"fvertexCy",
+	"fstartR",		"fstartG",		"fstartB",		"fstartZ",
+	"fstartA",		"fstartS",		"fstartT",		"fstartW",
+	/* 0x0c0 */
+	"fdRdX",		"fdGdX",		"fdBdX",		"fdZdX",
+	"fdAdX",		"fdSdX",		"fdTdX",		"fdWdX",
+	"fdRdY",		"fdGdY",		"fdBdY",		"fdZdY",
+	"fdAdY",		"fdSdY",		"fdTdY",		"fdWdY",
+	/* 0x100 */
+	"ftriangleCMD",	"fbzColorPath",	"fogMode",		"alphaMode",
+	"fbzMode",		"lfbMode",		"clipLeftRight","clipLowYHighY",
+	"nopCMD",		"fastfillCMD",	"swapbufferCMD","fogColor",
+	"zaColor",		"chromaKey",	"{chromaRange}","{userIntrCMD}",
+	/* 0x140 */
+	"stipple",		"color0",		"color1",		"fbiPixelsIn",
+	"fbiChromaFail","fbiZfuncFail",	"fbiAfuncFail",	"fbiPixelsOut",
+	"fogTable160",	"fogTable164",	"fogTable168",	"fogTable16c",
+	"fogTable170",	"fogTable174",	"fogTable178",	"fogTable17c",
+	/* 0x180 */
+	"fogTable180",	"fogTable184",	"fogTable188",	"fogTable18c",
+	"fogTable190",	"fogTable194",	"fogTable198",	"fogTable19c",
+	"fogTable1a0",	"fogTable1a4",	"fogTable1a8",	"fogTable1ac",
+	"fogTable1b0",	"fogTable1b4",	"fogTable1b8",	"fogTable1bc",
+	/* 0x1c0 */
+	"fogTable1c0",	"fogTable1c4",	"fogTable1c8",	"fogTable1cc",
+	"fogTable1d0",	"fogTable1d4",	"fogTable1d8",	"fogTable1dc",
+	"{cmdFifoBaseAddr}","{cmdFifoBump}","{cmdFifoRdPtr}","{cmdFifoAMin}",
+	"{cmdFifoAMax}","{cmdFifoDepth}","{cmdFifoHoles}","reserved1fc",
+	/* 0x200 */
+	"fbiInit4",		"vRetrace",		"backPorch",	"videoDimensions",
+	"fbiInit0",		"fbiInit1",		"fbiInit2",		"fbiInit3",
+	"hSync",		"vSync",		"clutData",		"dacData",
+	"maxRgbDelta",	"{hBorder}",	"{vBorder}",	"{borderColor}",
+	/* 0x240 */
+	"{hvRetrace}",	"{fbiInit5}",	"{fbiInit6}",	"{fbiInit7}",
+	"reserved250",	"reserved254",	"{fbiSwapHistory}","{fbiTrianglesOut}",
+	"{sSetupMode}",	"{sVx}",		"{sVy}",		"{sARGB}",
+	"{sRed}",		"{sGreen}",		"{sBlue}",		"{sAlpha}",
+	/* 0x280 */
+	"{sVz}",		"{sWb}",		"{sWtmu0}",		"{sS/Wtmu0}",
+	"{sT/Wtmu0}",	"{sWtmu1}",		"{sS/Wtmu1}",	"{sT/Wtmu1}",
+	"{sDrawTriCMD}","{sBeginTriCMD}","reserved2a8",	"reserved2ac",
+	"reserved2b0",	"reserved2b4",	"reserved2b8",	"reserved2bc",
+	/* 0x2c0 */
+	"{bltSrcBaseAddr}","{bltDstBaseAddr}","{bltXYStrides}","{bltSrcChromaRange}",
+	"{bltDstChromaRange}","{bltClipX}","{bltClipY}","reserved2dc",
+	"{bltSrcXY}",	"{bltDstXY}",	"{bltSize}",	"{bltRop}",
+	"{bltColor}",	"reserved2f4",	"{bltCommand}",	"{bltData}",
+	/* 0x300 */
+	"textureMode",	"tLOD",			"tDetail",		"texBaseAddr",
+	"texBaseAddr_1","texBaseAddr_2","texBaseAddr_3_8","trexInit0",
+	"trexInit1",	"nccTable0.0",	"nccTable0.1",	"nccTable0.2",
+	"nccTable0.3",	"nccTable0.4",	"nccTable0.5",	"nccTable0.6",
+	/* 0x340 */
+	"nccTable0.7",	"nccTable0.8",	"nccTable0.9",	"nccTable0.A",
+	"nccTable0.B",	"nccTable1.0",	"nccTable1.1",	"nccTable1.2",
+	"nccTable1.3",	"nccTable1.4",	"nccTable1.5",	"nccTable1.6",
+	"nccTable1.7",	"nccTable1.8",	"nccTable1.9",	"nccTable1.A",
+	/* 0x380 */
+	"nccTable1.B"
+};
+
+
+#endif
diff --git a/src/hardware/voodoo_emu.cpp b/src/hardware/voodoo_emu.cpp
new file mode 100644
index 000000000..310d8ca9a
--- /dev/null
+++ b/src/hardware/voodoo_emu.cpp
@@ -0,0 +1,3730 @@
+/***************************************************************************/
+/*        Portion of this software comes with the following license:       */
+/***************************************************************************/
+/*
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+****************************************************************************
+
+    3dfx Voodoo Graphics SST-1/2 emulator
+
+    emulator by Aaron Giles
+
+    --------------------------
+
+    Specs:
+
+    Voodoo 1 (SST1):
+        2,4MB frame buffer RAM
+        1,2,4MB texture RAM
+        50MHz clock frequency
+        clears @ 2 pixels/clock (RGB and depth simultaneously)
+        renders @ 1 pixel/clock
+        64 entry PCI FIFO
+        memory FIFO up to 65536 entries
+
+    Voodoo 2:
+        2,4MB frame buffer RAM
+        2,4,8,16MB texture RAM
+        90MHz clock frquency
+        clears @ 2 pixels/clock (RGB and depth simultaneously)
+        renders @ 1 pixel/clock
+        ultrafast clears @ 16 pixels/clock
+        128 entry PCI FIFO
+        memory FIFO up to 65536 entries
+
+    --------------------------
+
+
+iterated RGBA = 12.12 [24 bits]
+iterated Z    = 20.12 [32 bits]
+iterated W    = 18.32 [48 bits]
+
+**************************************************************************/
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#include "dosbox.h"
+#include "cross.h"
+
+#include "voodoo_emu.h"
+#include "voodoo_opengl.h"
+
+#include "voodoo_def.h"
+
+
+voodoo_state *v;
+
+
+#define LOG_VBLANK_SWAP		(0)
+#define LOG_REGISTERS		(0)
+#define LOG_LFB				(0)
+#define LOG_TEXTURE_RAM		(0)
+#define LOG_RASTERIZERS		(0)
+
+
+/* fast dither lookup */
+static UINT8 dither4_lookup[256*16*2];
+static UINT8 dither2_lookup[256*16*2];
+
+/* fast reciprocal+log2 lookup */
+UINT32 voodoo_reciplog[(2 << RECIPLOG_LOOKUP_BITS) + 2];
+
+
+
+/*************************************
+ *
+ *  Prototypes
+ *
+ *************************************/
+
+/* command handlers */
+static void fastfill(voodoo_state *v);
+static void swapbuffer(voodoo_state *v, UINT32 data);
+static void triangle(voodoo_state *v);
+static void begin_triangle(voodoo_state *v);
+static void draw_triangle(voodoo_state *v);
+
+/* triangle helpers */
+static void setup_and_draw_triangle(voodoo_state *v);
+static void triangle_create_work_item(voodoo_state *v, UINT16 *drawbuf, int texcount);
+
+/* rasterizer management */
+static raster_info *add_rasterizer(voodoo_state *v, const raster_info *cinfo);
+static raster_info *find_rasterizer(voodoo_state *v, int texcount);
+
+/* generic rasterizers */
+static void raster_fastfill(void *dest, INT32 scanline, const poly_extent *extent, const void *extradata);
+
+
+/***************************************************************************
+    RASTERIZER MANAGEMENT
+***************************************************************************/
+
+void raster_generic(UINT32 TMUS, UINT32 TEXMODE0, UINT32 TEXMODE1, void *destbase,
+					INT32 y, const poly_extent *extent,	const void *extradata)
+{
+	const poly_extra_data *extra = (const poly_extra_data *)extradata;
+	voodoo_state *v = extra->state;
+	stats_block *stats = &v->thread_stats[0];
+	DECLARE_DITHER_POINTERS;
+	INT32 startx = extent->startx;
+	INT32 stopx = extent->stopx;
+	INT32 iterr, iterg, iterb, itera;
+	INT32 iterz;
+	INT64 iterw, iterw0 = 0, iterw1 = 0;
+	INT64 iters0 = 0, iters1 = 0;
+	INT64 itert0 = 0, itert1 = 0;
+	UINT16 *depth;
+	UINT16 *dest;
+	INT32 dx, dy;
+	INT32 scry;
+	INT32 x;
+
+	/* determine the screen Y */
+	scry = y;
+	if (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))
+		scry = (v->fbi.yorigin - y) & 0x3ff;
+
+	/* compute the dithering pointers */
+	if (FBZMODE_ENABLE_DITHERING(v->reg[fbzMode].u))
+	{
+		dither4 = &dither_matrix_4x4[(y & 3) * 4];
+		if (FBZMODE_DITHER_TYPE(v->reg[fbzMode].u) == 0)
+		{
+			dither = dither4;
+			dither_lookup = &dither4_lookup[(y & 3) << 11];
+		}
+		else
+		{
+			dither = &dither_matrix_2x2[(y & 3) * 4];
+			dither_lookup = &dither2_lookup[(y & 3) << 11];
+		}
+	}
+
+	/* apply clipping */
+	if (FBZMODE_ENABLE_CLIPPING(v->reg[fbzMode].u))
+	{
+		INT32 tempclip;
+
+		/* Y clipping buys us the whole scanline */
+		if (scry < (INT32)((v->reg[clipLowYHighY].u >> 16) & 0x3ff) ||
+			scry >= (INT32)(v->reg[clipLowYHighY].u & 0x3ff))
+		{
+			stats->pixels_in += stopx - startx;
+			stats->clip_fail += stopx - startx;
+			return;
+		}
+
+		/* X clipping */
+		tempclip = (v->reg[clipLeftRight].u >> 16) & 0x3ff;
+		if (startx < tempclip)
+		{
+			stats->pixels_in += tempclip - startx;
+			startx = tempclip;
+		}
+		tempclip = v->reg[clipLeftRight].u & 0x3ff;
+		if (stopx >= tempclip)
+		{
+			stats->pixels_in += stopx - tempclip;
+			stopx = tempclip - 1;
+		}
+	}
+
+	/* get pointers to the target buffer and depth buffer */
+	dest = (UINT16 *)destbase + scry * v->fbi.rowpixels;
+	depth = (v->fbi.auxoffs != (UINT32)(~0)) ? ((UINT16 *)(v->fbi.ram + v->fbi.auxoffs) + scry * v->fbi.rowpixels) : NULL;
+
+	/* compute the starting parameters */
+	dx = startx - (extra->ax >> 4);
+	dy = y - (extra->ay >> 4);
+	iterr = extra->startr + dy * extra->drdy + dx * extra->drdx;
+	iterg = extra->startg + dy * extra->dgdy + dx * extra->dgdx;
+	iterb = extra->startb + dy * extra->dbdy + dx * extra->dbdx;
+	itera = extra->starta + dy * extra->dady + dx * extra->dadx;
+	iterz = extra->startz + dy * extra->dzdy + dx * extra->dzdx;
+	iterw = extra->startw + dy * extra->dwdy + dx * extra->dwdx;
+	if (TMUS >= 1)
+	{
+		iterw0 = extra->startw0 + dy * extra->dw0dy + dx * extra->dw0dx;
+		iters0 = extra->starts0 + dy * extra->ds0dy + dx * extra->ds0dx;
+		itert0 = extra->startt0 + dy * extra->dt0dy + dx * extra->dt0dx;
+	}
+	if (TMUS >= 2)
+	{
+		iterw1 = extra->startw1 + dy * extra->dw1dy + dx * extra->dw1dx;
+		iters1 = extra->starts1 + dy * extra->ds1dy + dx * extra->ds1dx;
+		itert1 = extra->startt1 + dy * extra->dt1dy + dx * extra->dt1dx;
+	}
+
+	/* loop in X */
+	for (x = startx; x < stopx; x++)
+	{
+		rgb_union iterargb = { 0 };
+		rgb_union texel = { 0 };
+
+		/* pixel pipeline part 1 handles depth testing and stippling */
+		PIXEL_PIPELINE_BEGIN(v, x, y, v->reg[fbzColorPath].u, v->reg[fbzMode].u, iterz, iterw);
+
+		/* run the texture pipeline on TMU1 to produce a value in texel */
+		/* note that they set LOD min to 8 to "disable" a TMU */
+
+		if (TMUS >= 2 && v->tmu[1].lodmin < (8 << 8))
+			TEXTURE_PIPELINE(&v->tmu[1], x, dither4, TEXMODE1, texel,
+								v->tmu[1].lookup, extra->lodbase1,
+								iters1, itert1, iterw1, texel);
+
+		/* run the texture pipeline on TMU0 to produce a final */
+		/* result in texel */
+		/* note that they set LOD min to 8 to "disable" a TMU */
+		if (TMUS >= 1 && v->tmu[0].lodmin < (8 << 8)) {
+			if (!v->send_config) {
+				TEXTURE_PIPELINE(&v->tmu[0], x, dither4, TEXMODE0, texel,
+								v->tmu[0].lookup, extra->lodbase0,
+								iters0, itert0, iterw0, texel);
+			} else {	/* send config data to the frame buffer */
+				texel.u=v->tmu_config;
+			}
+		}
+
+		/* colorpath pipeline selects source colors and does blending */
+		CLAMPED_ARGB(iterr, iterg, iterb, itera, v->reg[fbzColorPath].u, iterargb);
+
+
+		INT32 blendr, blendg, blendb, blenda;
+		rgb_union c_other;
+		rgb_union c_local;
+
+		/* compute c_other */
+		switch (FBZCP_CC_RGBSELECT(v->reg[fbzColorPath].u))
+		{
+			case 0:		/* iterated RGB */
+				c_other.u = iterargb.u;
+				break;
+			case 1:		/* texture RGB */
+				c_other.u = texel.u;
+				break;
+			case 2:		/* color1 RGB */
+				c_other.u = v->reg[color1].u;
+				break;
+			default:	/* reserved */
+				c_other.u = 0;
+				break;
+		}
+
+		/* handle chroma key */
+		APPLY_CHROMAKEY(v, stats, v->reg[fbzMode].u, c_other);
+
+		/* compute a_other */
+		switch (FBZCP_CC_ASELECT(v->reg[fbzColorPath].u))
+		{
+			case 0:		/* iterated alpha */
+				c_other.rgb.a = iterargb.rgb.a;
+				break;
+			case 1:		/* texture alpha */
+				c_other.rgb.a = texel.rgb.a;
+				break;
+			case 2:		/* color1 alpha */
+				c_other.rgb.a = v->reg[color1].rgb.a;
+				break;
+			default:	/* reserved */
+				c_other.rgb.a = 0;
+				break;
+		}
+
+		/* handle alpha mask */
+		APPLY_ALPHAMASK(v, stats, v->reg[fbzMode].u, c_other.rgb.a);
+
+		/* handle alpha test */
+		APPLY_ALPHATEST(v, stats, v->reg[alphaMode].u, c_other.rgb.a);
+
+		/* compute c_local */
+		if (FBZCP_CC_LOCALSELECT_OVERRIDE(v->reg[fbzColorPath].u) == 0)
+		{
+			if (FBZCP_CC_LOCALSELECT(v->reg[fbzColorPath].u) == 0)	/* iterated RGB */
+				c_local.u = iterargb.u;
+			else											/* color0 RGB */
+				c_local.u = v->reg[color0].u;
+		}
+		else
+		{
+			if (!(texel.rgb.a & 0x80))					/* iterated RGB */
+				c_local.u = iterargb.u;
+			else											/* color0 RGB */
+				c_local.u = v->reg[color0].u;
+		}
+
+		/* compute a_local */
+		switch (FBZCP_CCA_LOCALSELECT(v->reg[fbzColorPath].u))
+		{
+			default:
+			case 0:		/* iterated alpha */
+				c_local.rgb.a = iterargb.rgb.a;
+				break;
+			case 1:		/* color0 alpha */
+				c_local.rgb.a = v->reg[color0].rgb.a;
+				break;
+			case 2:		/* clamped iterated Z[27:20] */
+			{
+				int temp;
+				CLAMPED_Z(iterz, v->reg[fbzColorPath].u, temp);
+				c_local.rgb.a = (UINT8)temp;
+				break;
+			}
+			case 3:		/* clamped iterated W[39:32] */
+			{
+				int temp;
+				CLAMPED_W(iterw, v->reg[fbzColorPath].u, temp);			/* Voodoo 2 only */
+				c_local.rgb.a = (UINT8)temp;
+				break;
+			}
+		}
+
+		/* select zero or c_other */
+		if (FBZCP_CC_ZERO_OTHER(v->reg[fbzColorPath].u) == 0)
+		{
+			r = c_other.rgb.r;
+			g = c_other.rgb.g;
+			b = c_other.rgb.b;
+		}
+		else
+			r = g = b = 0;
+
+		/* select zero or a_other */
+		if (FBZCP_CCA_ZERO_OTHER(v->reg[fbzColorPath].u) == 0)
+			a = c_other.rgb.a;
+		else
+			a = 0;
+
+		/* subtract c_local */
+		if (FBZCP_CC_SUB_CLOCAL(v->reg[fbzColorPath].u))
+		{
+			r -= c_local.rgb.r;
+			g -= c_local.rgb.g;
+			b -= c_local.rgb.b;
+		}
+
+		/* subtract a_local */
+		if (FBZCP_CCA_SUB_CLOCAL(v->reg[fbzColorPath].u))
+			a -= c_local.rgb.a;
+
+		/* blend RGB */
+		switch (FBZCP_CC_MSELECT(v->reg[fbzColorPath].u))
+		{
+			default:	/* reserved */
+			case 0:		/* 0 */
+				blendr = blendg = blendb = 0;
+				break;
+			case 1:		/* c_local */
+				blendr = c_local.rgb.r;
+				blendg = c_local.rgb.g;
+				blendb = c_local.rgb.b;
+				break;
+			case 2:		/* a_other */
+				blendr = blendg = blendb = c_other.rgb.a;
+				break;
+			case 3:		/* a_local */
+				blendr = blendg = blendb = c_local.rgb.a;
+				break;
+			case 4:		/* texture alpha */
+				blendr = blendg = blendb = texel.rgb.a;
+				break;
+			case 5:		/* texture RGB (Voodoo 2 only) */
+				blendr = texel.rgb.r;
+				blendg = texel.rgb.g;
+				blendb = texel.rgb.b;
+				break;
+		}
+
+		/* blend alpha */
+		switch (FBZCP_CCA_MSELECT(v->reg[fbzColorPath].u))
+		{
+			default:	/* reserved */
+			case 0:		/* 0 */
+				blenda = 0;
+				break;
+			case 1:		/* a_local */
+				blenda = c_local.rgb.a;
+				break;
+			case 2:		/* a_other */
+				blenda = c_other.rgb.a;
+				break;
+			case 3:		/* a_local */
+				blenda = c_local.rgb.a;
+				break;
+			case 4:		/* texture alpha */
+				blenda = texel.rgb.a;
+				break;
+		}
+
+		/* reverse the RGB blend */
+		if (!FBZCP_CC_REVERSE_BLEND(v->reg[fbzColorPath].u))
+		{
+			blendr ^= 0xff;
+			blendg ^= 0xff;
+			blendb ^= 0xff;
+		}
+
+		/* reverse the alpha blend */
+		if (!FBZCP_CCA_REVERSE_BLEND(v->reg[fbzColorPath].u))
+			blenda ^= 0xff;
+
+		/* do the blend */
+		r = (r * (blendr + 1)) >> 8;
+		g = (g * (blendg + 1)) >> 8;
+		b = (b * (blendb + 1)) >> 8;
+		a = (a * (blenda + 1)) >> 8;
+
+		/* add clocal or alocal to RGB */
+		switch (FBZCP_CC_ADD_ACLOCAL(v->reg[fbzColorPath].u))
+		{
+			case 3:		/* reserved */
+			case 0:		/* nothing */
+				break;
+			case 1:		/* add c_local */
+				r += c_local.rgb.r;
+				g += c_local.rgb.g;
+				b += c_local.rgb.b;
+				break;
+			case 2:		/* add_alocal */
+				r += c_local.rgb.a;
+				g += c_local.rgb.a;
+				b += c_local.rgb.a;
+				break;
+		}
+
+		/* add clocal or alocal to alpha */
+		if (FBZCP_CCA_ADD_ACLOCAL(v->reg[fbzColorPath].u))
+			a += c_local.rgb.a;
+
+		/* clamp */
+		CLAMP(r, 0x00, 0xff);
+		CLAMP(g, 0x00, 0xff);
+		CLAMP(b, 0x00, 0xff);
+		CLAMP(a, 0x00, 0xff);
+
+		/* invert */
+		if (FBZCP_CC_INVERT_OUTPUT(v->reg[fbzColorPath].u))
+		{
+			r ^= 0xff;
+			g ^= 0xff;
+			b ^= 0xff;
+		}
+		if (FBZCP_CCA_INVERT_OUTPUT(v->reg[fbzColorPath].u))
+			a ^= 0xff;
+
+
+		/* pixel pipeline part 2 handles fog, alpha, and final output */
+		PIXEL_PIPELINE_MODIFY(v, dither, dither4, x,
+							v->reg[fbzMode].u, v->reg[fbzColorPath].u, v->reg[alphaMode].u, v->reg[fogMode].u,
+							iterz, iterw, iterargb);
+		PIXEL_PIPELINE_FINISH(v, dither_lookup, x, dest, depth, v->reg[fbzMode].u);
+		PIXEL_PIPELINE_END(stats);
+
+		/* update the iterated parameters */
+		iterr += extra->drdx;
+		iterg += extra->dgdx;
+		iterb += extra->dbdx;
+		itera += extra->dadx;
+		iterz += extra->dzdx;
+		iterw += extra->dwdx;
+		if (TMUS >= 1)
+		{
+			iterw0 += extra->dw0dx;
+			iters0 += extra->ds0dx;
+			itert0 += extra->dt0dx;
+		}
+		if (TMUS >= 2)
+		{
+			iterw1 += extra->dw1dx;
+			iters1 += extra->ds1dx;
+			itert1 += extra->dt1dx;
+		}
+	}
+}
+
+
+/***************************************************************************
+    RASTERIZER MANAGEMENT
+***************************************************************************/
+
+void raster_generic_0tmu(void *destbase, INT32 y, const poly_extent *extent, const void *extradata) {
+	raster_generic(0, 0, 0, destbase, y, extent, extradata);
+}
+
+void raster_generic_1tmu(void *destbase, INT32 y, const poly_extent *extent, const void *extradata) {
+	raster_generic(1, v->tmu[0].reg[textureMode].u, 0, destbase, y, extent, extradata);
+}
+
+void raster_generic_2tmu(void *destbase, INT32 y, const poly_extent *extent, const void *extradata) {
+	raster_generic(2, v->tmu[0].reg[textureMode].u, v->tmu[1].reg[textureMode].u, destbase, y, extent, extradata);
+}
+
+
+
+/*************************************
+ *
+ *  Common initialization
+ *
+ *************************************/
+
+void init_fbi(voodoo_state *v, fbi_state *f, int fbmem)
+{
+	if (fbmem <= 1) E_Exit("VOODOO: invalid frame buffer memory size requested");
+	/* allocate frame buffer RAM and set pointers */
+	f->ram = (UINT8*)malloc(fbmem);
+	f->mask = (UINT32)(fbmem - 1);
+	f->rgboffs[0] = f->rgboffs[1] = f->rgboffs[2] = 0;
+	f->auxoffs = (UINT32)(~0);
+
+	/* default to 0x0 */
+	f->frontbuf = 0;
+	f->backbuf = 1;
+	f->width = 640;
+	f->height = 480;
+//	f->xoffs = 0;
+//	f->yoffs = 0;
+
+//	f->vsyncscan = 0;
+
+	/* init the pens */
+/*	for (UINT8 pen = 0; pen < 32; pen++)
+		v->fbi.clut[pen] = MAKE_ARGB(pen, pal5bit(pen), pal5bit(pen), pal5bit(pen));
+	v->fbi.clut[32] = MAKE_ARGB(32,0xff,0xff,0xff); */
+
+	/* allocate a VBLANK timer */
+	f->vblank = FALSE;
+
+	/* initialize the memory FIFO */
+	f->fifo.size = 0;
+
+	/* set the fog delta mask */
+	f->fogdelta_mask = (v->type < VOODOO_2) ? 0xff : 0xfc;
+
+	f->yorigin = 0;
+
+	f->sverts = 0;
+
+	memset(&f->lfb_stats, 0, sizeof(f->lfb_stats));
+	memset(&f->fogblend, 0, sizeof(f->fogblend));
+	memset(&f->fogdelta, 0, sizeof(f->fogdelta));
+}
+
+
+void init_tmu_shared(tmu_shared_state *s)
+{
+	int val;
+
+	/* build static 8-bit texel tables */
+	for (val = 0; val < 256; val++)
+	{
+		int r, g, b, a;
+
+		/* 8-bit RGB (3-3-2) */
+		EXTRACT_332_TO_888(val, r, g, b);
+		s->rgb332[val] = MAKE_ARGB(0xff, r, g, b);
+
+		/* 8-bit alpha */
+		s->alpha8[val] = MAKE_ARGB(val, val, val, val);
+
+		/* 8-bit intensity */
+		s->int8[val] = MAKE_ARGB(0xff, val, val, val);
+
+		/* 8-bit alpha, intensity */
+		a = ((val >> 0) & 0xf0) | ((val >> 4) & 0x0f);
+		r = ((val << 4) & 0xf0) | ((val << 0) & 0x0f);
+		s->ai44[val] = MAKE_ARGB(a, r, r, r);
+	}
+
+	/* build static 16-bit texel tables */
+	for (val = 0; val < 65536; val++)
+	{
+		int r, g, b, a;
+
+		/* table 10 = 16-bit RGB (5-6-5) */
+		EXTRACT_565_TO_888(val, r, g, b);
+		s->rgb565[val] = MAKE_ARGB(0xff, r, g, b);
+
+		/* table 11 = 16 ARGB (1-5-5-5) */
+		EXTRACT_1555_TO_8888(val, a, r, g, b);
+		s->argb1555[val] = MAKE_ARGB(a, r, g, b);
+
+		/* table 12 = 16-bit ARGB (4-4-4-4) */
+		EXTRACT_4444_TO_8888(val, a, r, g, b);
+		s->argb4444[val] = MAKE_ARGB(a, r, g, b);
+	}
+}
+
+
+void init_tmu(voodoo_state *v, tmu_state *t, voodoo_reg *reg, int tmem)
+{
+	if (tmem <= 1) E_Exit("VOODOO: invalid texture buffer memory size requested");
+	/* allocate texture RAM */
+	t->ram = (UINT8*)malloc(tmem);
+	t->mask = (UINT32)(tmem - 1);
+	t->reg = reg;
+	t->regdirty = true;
+	t->bilinear_mask = (v->type >= VOODOO_2) ? 0xff : 0xf0;
+
+	/* mark the NCC tables dirty and configure their registers */
+	t->ncc[0].dirty = t->ncc[1].dirty = true;
+	t->ncc[0].reg = &t->reg[nccTable+0];
+	t->ncc[1].reg = &t->reg[nccTable+12];
+
+	/* create pointers to all the tables */
+	t->texel[0] = v->tmushare.rgb332;
+	t->texel[1] = t->ncc[0].texel;
+	t->texel[2] = v->tmushare.alpha8;
+	t->texel[3] = v->tmushare.int8;
+	t->texel[4] = v->tmushare.ai44;
+	t->texel[5] = t->palette;
+	t->texel[6] = (v->type >= VOODOO_2) ? t->palettea : NULL;
+	t->texel[7] = NULL;
+	t->texel[8] = v->tmushare.rgb332;
+	t->texel[9] = t->ncc[0].texel;
+	t->texel[10] = v->tmushare.rgb565;
+	t->texel[11] = v->tmushare.argb1555;
+	t->texel[12] = v->tmushare.argb4444;
+	t->texel[13] = v->tmushare.int8;
+	t->texel[14] = t->palette;
+	t->texel[15] = NULL;
+	t->lookup = t->texel[0];
+
+	/* attach the palette to NCC table 0 */
+	t->ncc[0].palette = t->palette;
+	if (v->type >= VOODOO_2)
+		t->ncc[0].palettea = t->palettea;
+
+	/* set up texture address calculations */
+	t->texaddr_mask = 0x0fffff;
+	t->texaddr_shift = 3;
+
+	t->lodmin=0;
+	t->lodmax=0;
+}
+
+
+/*************************************
+ *
+ *  VBLANK management
+ *
+ *************************************/
+
+void voodoo_swap_buffers(voodoo_state *v)
+{
+//	if (LOG_VBLANK_SWAP) LOG(LOG_VOODOO,LOG_WARN)("--- swap_buffers @ %d\n", video_screen_get_vpos(v->screen));
+
+	if (v->ogl && v->active) {
+		voodoo_ogl_swap_buffer();
+		return;
+	}
+
+	/* keep a history of swap intervals */
+	v->reg[fbiSwapHistory].u = (v->reg[fbiSwapHistory].u << 4);
+
+	/* rotate the buffers */
+	if (v->type < VOODOO_2 || !v->fbi.vblank_dont_swap)
+	{
+		if (v->fbi.rgboffs[2] == (UINT32)(~0))
+		{
+			v->fbi.frontbuf = (UINT8)(1 - v->fbi.frontbuf);
+			v->fbi.backbuf = (UINT8)(1 - v->fbi.frontbuf);
+		}
+		else
+		{
+			v->fbi.frontbuf = (v->fbi.frontbuf + 1) % 3;
+			v->fbi.backbuf = (v->fbi.frontbuf + 1) % 3;
+		}
+	}
+}
+
+
+
+/*************************************
+ *
+ *  Chip reset
+ *
+ *************************************/
+
+void reset_counters(voodoo_state *v)
+{
+	v->reg[fbiPixelsIn].u = 0;
+	v->reg[fbiChromaFail].u = 0;
+	v->reg[fbiZfuncFail].u = 0;
+	v->reg[fbiAfuncFail].u = 0;
+	v->reg[fbiPixelsOut].u = 0;
+}
+
+
+void soft_reset(voodoo_state *v)
+{
+	reset_counters(v);
+	v->reg[fbiTrianglesOut].u = 0;
+}
+
+
+
+/*************************************
+ *
+ *  Recompute video memory layout
+ *
+ *************************************/
+
+void recompute_video_memory(voodoo_state *v)
+{
+	UINT32 buffer_pages = FBIINIT2_VIDEO_BUFFER_OFFSET(v->reg[fbiInit2].u);
+	UINT32 fifo_start_page = FBIINIT4_MEMORY_FIFO_START_ROW(v->reg[fbiInit4].u);
+	UINT32 fifo_last_page = FBIINIT4_MEMORY_FIFO_STOP_ROW(v->reg[fbiInit4].u);
+	UINT32 memory_config;
+	int buf;
+
+	/* memory config is determined differently between V1 and V2 */
+	memory_config = FBIINIT2_ENABLE_TRIPLE_BUF(v->reg[fbiInit2].u);
+	if (v->type == VOODOO_2 && memory_config == 0)
+		memory_config = FBIINIT5_BUFFER_ALLOCATION(v->reg[fbiInit5].u);
+
+	/* tiles are 64x16/32; x_tiles specifies how many half-tiles */
+	v->fbi.tile_width = (v->type < VOODOO_2) ? 64 : 32;
+	v->fbi.tile_height = (v->type < VOODOO_2) ? 16 : 32;
+	v->fbi.x_tiles = FBIINIT1_X_VIDEO_TILES(v->reg[fbiInit1].u);
+	if (v->type == VOODOO_2)
+	{
+		v->fbi.x_tiles = (v->fbi.x_tiles << 1) |
+						(FBIINIT1_X_VIDEO_TILES_BIT5(v->reg[fbiInit1].u) << 5) |
+						(FBIINIT6_X_VIDEO_TILES_BIT0(v->reg[fbiInit6].u));
+	}
+	v->fbi.rowpixels = v->fbi.tile_width * v->fbi.x_tiles;
+
+//  logerror("VOODOO.%d.VIDMEM: buffer_pages=%X  fifo=%X-%X  tiles=%X  rowpix=%d\n", v->index, buffer_pages, fifo_start_page, fifo_last_page, v->fbi.x_tiles, v->fbi.rowpixels);
+
+	/* first RGB buffer always starts at 0 */
+	v->fbi.rgboffs[0] = 0;
+
+	/* second RGB buffer starts immediately afterwards */
+	v->fbi.rgboffs[1] = buffer_pages * 0x1000;
+
+	/* remaining buffers are based on the config */
+	switch (memory_config)
+	{
+	case 3:	/* reserved */
+		LOG(LOG_VOODOO,LOG_WARN)("VOODOO.ERROR:Unexpected memory configuration in recompute_video_memory!\n");
+
+	case 0:	/* 2 color buffers, 1 aux buffer */
+		v->fbi.rgboffs[2] = (UINT32)(~0);
+		v->fbi.auxoffs = 2 * buffer_pages * 0x1000;
+		break;
+
+	case 1:	/* 3 color buffers, 0 aux buffers */
+		v->fbi.rgboffs[2] = 2 * buffer_pages * 0x1000;
+		v->fbi.auxoffs = (UINT32)(~0);
+		break;
+
+	case 2:	/* 3 color buffers, 1 aux buffers */
+		v->fbi.rgboffs[2] = 2 * buffer_pages * 0x1000;
+		v->fbi.auxoffs = 3 * buffer_pages * 0x1000;
+		break;
+	}
+
+	/* clamp the RGB buffers to video memory */
+	for (buf = 0; buf < 3; buf++)
+		if (v->fbi.rgboffs[buf] != (UINT32)(~0) && v->fbi.rgboffs[buf] > v->fbi.mask)
+			v->fbi.rgboffs[buf] = v->fbi.mask;
+
+	/* clamp the aux buffer to video memory */
+	if (v->fbi.auxoffs != (UINT32)(~0) && v->fbi.auxoffs > v->fbi.mask)
+		v->fbi.auxoffs = v->fbi.mask;
+
+	/* compute the memory FIFO location and size */
+	if (fifo_last_page > v->fbi.mask / 0x1000)
+		fifo_last_page = v->fbi.mask / 0x1000;
+
+	/* is it valid and enabled? */
+	if (fifo_start_page <= fifo_last_page && FBIINIT0_ENABLE_MEMORY_FIFO(v->reg[fbiInit0].u))
+	{
+		v->fbi.fifo.size = (fifo_last_page + 1 - fifo_start_page) * 0x1000 / 4;
+		if (v->fbi.fifo.size > 65536*2)
+			v->fbi.fifo.size = 65536*2;
+	}
+	else	/* if not, disable the FIFO */
+	{
+		v->fbi.fifo.size = 0;
+	}
+
+	/* reset our front/back buffers if they are out of range */
+	if (v->fbi.rgboffs[2] == (UINT32)(~0))
+	{
+		if (v->fbi.frontbuf == 2)
+			v->fbi.frontbuf = 0;
+		if (v->fbi.backbuf == 2)
+			v->fbi.backbuf = 0;
+	}
+}
+
+
+
+/*************************************
+ *
+ *  NCC table management
+ *
+ *************************************/
+
+static bool palette_changed = false;
+
+void ncc_table_write(ncc_table *n, UINT32 regnum, UINT32 data)
+{
+	/* I/Q entries reference the palette if the high bit is set */
+	if (regnum >= 4 && (data & 0x80000000) && n->palette)
+	{
+		UINT32 index = ((data >> 23) & 0xfe) | (regnum & 1);
+
+		rgb_t palette_entry = 0xff000000 | data;
+
+		if (n->palette[index] != palette_entry) {
+			/* set the ARGB for this palette index */
+			n->palette[index] = palette_entry;
+			palette_changed = true;
+		}
+
+		/* if we have an ARGB palette as well, compute its value */
+		if (n->palettea)
+		{
+			UINT32 a = ((data >> 16) & 0xfc) | ((data >> 22) & 0x03);
+			UINT32 r = ((data >> 10) & 0xfc) | ((data >> 16) & 0x03);
+			UINT32 g = ((data >>  4) & 0xfc) | ((data >> 10) & 0x03);
+			UINT32 b = ((data <<  2) & 0xfc) | ((data >>  4) & 0x03);
+			n->palettea[index] = MAKE_ARGB(a, r, g, b);
+		}
+
+		/* this doesn't dirty the table or go to the registers, so bail */
+		return;
+	}
+
+	/* if the register matches, don't update */
+	if (data == n->reg[regnum].u)
+		return;
+	n->reg[regnum].u = data;
+
+	/* first four entries are packed Y values */
+	if (regnum < 4)
+	{
+		regnum *= 4;
+		n->y[regnum+0] = (data >>  0) & 0xff;
+		n->y[regnum+1] = (data >>  8) & 0xff;
+		n->y[regnum+2] = (data >> 16) & 0xff;
+		n->y[regnum+3] = (data >> 24) & 0xff;
+	}
+
+	/* the second four entries are the I RGB values */
+	else if (regnum < 8)
+	{
+		regnum &= 3;
+		n->ir[regnum] = (INT32)(data <<  5) >> 23;
+		n->ig[regnum] = (INT32)(data << 14) >> 23;
+		n->ib[regnum] = (INT32)(data << 23) >> 23;
+	}
+
+	/* the final four entries are the Q RGB values */
+	else
+	{
+		regnum &= 3;
+		n->qr[regnum] = (INT32)(data <<  5) >> 23;
+		n->qg[regnum] = (INT32)(data << 14) >> 23;
+		n->qb[regnum] = (INT32)(data << 23) >> 23;
+	}
+
+	/* mark the table dirty */
+	n->dirty = true;
+}
+
+
+void ncc_table_update(ncc_table *n)
+{
+	int r, g, b, i;
+
+	/* generte all 256 possibilities */
+	for (i = 0; i < 256; i++)
+	{
+		int vi = (i >> 2) & 0x03;
+		int vq = (i >> 0) & 0x03;
+
+		/* start with the intensity */
+		r = g = b = n->y[(i >> 4) & 0x0f];
+
+		/* add the coloring */
+		r += n->ir[vi] + n->qr[vq];
+		g += n->ig[vi] + n->qg[vq];
+		b += n->ib[vi] + n->qb[vq];
+
+		/* clamp */
+		CLAMP(r, 0, 255);
+		CLAMP(g, 0, 255);
+		CLAMP(b, 0, 255);
+
+		/* fill in the table */
+		n->texel[i] = MAKE_ARGB(0xff, r, g, b);
+	}
+
+	/* no longer dirty */
+	n->dirty = false;
+}
+
+
+
+/*************************************
+ *
+ *  Faux DAC implementation
+ *
+ *************************************/
+
+void dacdata_w(dac_state *d, UINT8 regnum, UINT8 data)
+{
+	d->reg[regnum] = data;
+}
+
+
+void dacdata_r(dac_state *d, UINT8 regnum)
+{
+	UINT8 result = 0xff;
+
+	/* switch off the DAC register requested */
+	switch (regnum)
+	{
+		case 5:
+			/* this is just to make startup happy */
+			switch (d->reg[7])
+			{
+				case 0x01:	result = 0x55; break;
+				case 0x07:	result = 0x71; break;
+				case 0x0b:	result = 0x79; break;
+			}
+			break;
+
+		default:
+			result = d->reg[regnum];
+			break;
+	}
+
+	/* remember the read result; it is fetched elsewhere */
+	d->read_result = result;
+}
+
+
+
+/*************************************
+ *
+ *  Texuture parameter computation
+ *
+ *************************************/
+
+void recompute_texture_params(tmu_state *t)
+{
+	int bppscale;
+	UINT32 base;
+	int lod;
+
+	/* extract LOD parameters */
+	t->lodmin = TEXLOD_LODMIN(t->reg[tLOD].u) << 6;
+	t->lodmax = TEXLOD_LODMAX(t->reg[tLOD].u) << 6;
+	t->lodbias = (INT8)(TEXLOD_LODBIAS(t->reg[tLOD].u) << 2) << 4;
+
+	/* determine which LODs are present */
+	t->lodmask = 0x1ff;
+	if (TEXLOD_LOD_TSPLIT(t->reg[tLOD].u))
+	{
+		if (!TEXLOD_LOD_ODD(t->reg[tLOD].u))
+			t->lodmask = 0x155;
+		else
+			t->lodmask = 0x0aa;
+	}
+
+	/* determine base texture width/height */
+	t->wmask = t->hmask = 0xff;
+	if (TEXLOD_LOD_S_IS_WIDER(t->reg[tLOD].u))
+		t->hmask >>= TEXLOD_LOD_ASPECT(t->reg[tLOD].u);
+	else
+		t->wmask >>= TEXLOD_LOD_ASPECT(t->reg[tLOD].u);
+
+	/* determine the bpp of the texture */
+	bppscale = TEXMODE_FORMAT(t->reg[textureMode].u) >> 3;
+
+	/* start with the base of LOD 0 */
+	if (t->texaddr_shift == 0 && (t->reg[texBaseAddr].u & 1))
+		LOG(LOG_VOODOO,LOG_WARN)("Tiled texture\n");
+	base = (t->reg[texBaseAddr].u & t->texaddr_mask) << t->texaddr_shift;
+	t->lodoffset[0] = base & t->mask;
+
+	/* LODs 1-3 are different depending on whether we are in multitex mode */
+	/* Several Voodoo 2 games leave the upper bits of TLOD == 0xff, meaning we think */
+	/* they want multitex mode when they really don't -- disable for now */
+	if (0)//TEXLOD_TMULTIBASEADDR(t->reg[tLOD].u))
+	{
+		base = (t->reg[texBaseAddr_1].u & t->texaddr_mask) << t->texaddr_shift;
+		t->lodoffset[1] = base & t->mask;
+		base = (t->reg[texBaseAddr_2].u & t->texaddr_mask) << t->texaddr_shift;
+		t->lodoffset[2] = base & t->mask;
+		base = (t->reg[texBaseAddr_3_8].u & t->texaddr_mask) << t->texaddr_shift;
+		t->lodoffset[3] = base & t->mask;
+	}
+	else
+	{
+		if (t->lodmask & (1 << 0))
+			base += (((t->wmask >> 0) + 1) * ((t->hmask >> 0) + 1)) << bppscale;
+		t->lodoffset[1] = base & t->mask;
+		if (t->lodmask & (1 << 1))
+			base += (((t->wmask >> 1) + 1) * ((t->hmask >> 1) + 1)) << bppscale;
+		t->lodoffset[2] = base & t->mask;
+		if (t->lodmask & (1 << 2))
+			base += (((t->wmask >> 2) + 1) * ((t->hmask >> 2) + 1)) << bppscale;
+		t->lodoffset[3] = base & t->mask;
+	}
+
+	/* remaining LODs make sense */
+	for (lod = 4; lod <= 8; lod++)
+	{
+		if (t->lodmask & (1 << (lod - 1)))
+		{
+			UINT32 size = ((t->wmask >> (lod - 1)) + 1) * ((t->hmask >> (lod - 1)) + 1);
+			if (size < 4) size = 4;
+			base += size << bppscale;
+		}
+		t->lodoffset[lod] = base & t->mask;
+	}
+
+	/* set the NCC lookup appropriately */
+	t->texel[1] = t->texel[9] = t->ncc[TEXMODE_NCC_TABLE_SELECT(t->reg[textureMode].u)].texel;
+
+	/* pick the lookup table */
+	t->lookup = t->texel[TEXMODE_FORMAT(t->reg[textureMode].u)];
+
+	/* compute the detail parameters */
+	t->detailmax = TEXDETAIL_DETAIL_MAX(t->reg[tDetail].u);
+	t->detailbias = (INT8)(TEXDETAIL_DETAIL_BIAS(t->reg[tDetail].u) << 2) << 6;
+	t->detailscale = TEXDETAIL_DETAIL_SCALE(t->reg[tDetail].u);
+
+	/* no longer dirty */
+	t->regdirty = false;
+
+	/* check for separate RGBA filtering */
+	if (TEXDETAIL_SEPARATE_RGBA_FILTER(t->reg[tDetail].u))
+		E_Exit("Separate RGBA filters!");
+}
+
+
+INLINE INT32 prepare_tmu(tmu_state *t)
+{
+	INT64 texdx, texdy;
+	INT32 lodbase;
+
+	/* if the texture parameters are dirty, update them */
+	if (t->regdirty)
+	{
+		recompute_texture_params(t);
+
+		/* ensure that the NCC tables are up to date */
+		if ((TEXMODE_FORMAT(t->reg[textureMode].u) & 7) == 1)
+		{
+			ncc_table *n = &t->ncc[TEXMODE_NCC_TABLE_SELECT(t->reg[textureMode].u)];
+			t->texel[1] = t->texel[9] = n->texel;
+			if (n->dirty)
+				ncc_table_update(n);
+		}
+	}
+
+	/* compute (ds^2 + dt^2) in both X and Y as 28.36 numbers */
+	texdx = (INT64)(t->dsdx >> 14) * (INT64)(t->dsdx >> 14) + (INT64)(t->dtdx >> 14) * (INT64)(t->dtdx >> 14);
+	texdy = (INT64)(t->dsdy >> 14) * (INT64)(t->dsdy >> 14) + (INT64)(t->dtdy >> 14) * (INT64)(t->dtdy >> 14);
+
+	/* pick whichever is larger and shift off some high bits -> 28.20 */
+	if (texdx < texdy)
+		texdx = texdy;
+	texdx >>= 16;
+
+	/* use our fast reciprocal/log on this value; it expects input as a */
+	/* 16.32 number, and returns the log of the reciprocal, so we have to */
+	/* adjust the result: negative to get the log of the original value */
+	/* plus 12 to account for the extra exponent, and divided by 2 to */
+	/* get the log of the square root of texdx */
+	(void)fast_reciplog(texdx, &lodbase);
+	return (-lodbase + (12 << 8)) / 2;
+}
+
+
+INLINE INT32 round_coordinate(float value)
+{
+	INT32 result = (INT32)floor(value);
+	return result + (value - (float)result > 0.5f);
+}
+
+void poly_render_triangle(void *dest, poly_draw_scanline_func callback, const poly_vertex *v1, const poly_vertex *v2, const poly_vertex *v3, poly_extra_data *extra)
+{
+	float dxdy_v1v2, dxdy_v1v3, dxdy_v2v3;
+	const poly_vertex *tv;
+	INT32 curscan, scaninc=1;
+
+	INT32 v1yclip, v3yclip;
+	INT32 v1y, v3y, v1x;
+
+	/* first sort by Y */
+	if (v2->y < v1->y)
+	{
+		tv = v1;
+		v1 = v2;
+		v2 = tv;
+	}
+	if (v3->y < v2->y)
+	{
+		tv = v2;
+		v2 = v3;
+		v3 = tv;
+		if (v2->y < v1->y)
+		{
+			tv = v1;
+			v1 = v2;
+			v2 = tv;
+		}
+	}
+
+	/* compute some integral X/Y vertex values */
+	v1x = round_coordinate(v1->x);
+	v1y = round_coordinate(v1->y);
+	v3y = round_coordinate(v3->y);
+
+	/* clip coordinates */
+	v1yclip = v1y;
+	v3yclip = v3y;// + ((poly->flags & POLYFLAG_INCLUDE_BOTTOM_EDGE) ? 1 : 0);
+	if (v3yclip - v1yclip <= 0)
+		return;
+
+	/* compute the slopes for each portion of the triangle */
+	dxdy_v1v2 = (v2->y == v1->y) ? 0.0f : (v2->x - v1->x) / (v2->y - v1->y);
+	dxdy_v1v3 = (v3->y == v1->y) ? 0.0f : (v3->x - v1->x) / (v3->y - v1->y);
+	dxdy_v2v3 = (v3->y == v2->y) ? 0.0f : (v3->x - v2->x) / (v3->y - v2->y);
+
+	poly_extent *extent = new poly_extent;
+	int extnum=0;
+	for (curscan = v1yclip; curscan < v3yclip; curscan += scaninc)
+	{
+		{
+			float fully = (float)(curscan + extnum) + 0.5f;
+			float startx = v1->x + (fully - v1->y) * dxdy_v1v3;
+			float stopx;
+			INT32 istartx, istopx;
+
+			/* compute the ending X based on which part of the triangle we're in */
+			if (fully < v2->y)
+				stopx = v1->x + (fully - v1->y) * dxdy_v1v2;
+			else
+				stopx = v2->x + (fully - v2->y) * dxdy_v2v3;
+
+			/* clamp to full pixels */
+			istartx = round_coordinate(startx);
+			istopx = round_coordinate(stopx);
+
+			/* force start < stop */
+			if (istartx > istopx)
+			{
+				INT32 temp = istartx;
+				istartx = istopx;
+				istopx = temp;
+			}
+
+			/* set the extent and update the total pixel count */
+			if (istartx >= istopx)
+				istartx = istopx = 0;
+
+			extent->startx = istartx;
+			extent->stopx = istopx;
+			(callback)(dest,curscan,extent,extra);
+		}
+	}
+
+	delete extent;
+}
+
+
+
+void poly_render_triangle_custom(void *dest, int startscanline, int numscanlines, const poly_extent *extents, poly_extra_data *extra)
+{
+	INT32 curscan, scaninc;
+	INT32 v1yclip, v3yclip;
+
+	v1yclip = startscanline;
+	v3yclip = startscanline + numscanlines;
+
+	if (v3yclip - v1yclip <= 0)
+		return;
+
+	for (curscan = v1yclip; curscan < v3yclip; curscan += scaninc)
+	{
+		tri_work_unit *unit = new tri_work_unit;
+		int extnum=0;
+
+		/* determine how much to advance to hit the next bucket */
+		scaninc = 1;
+
+		{
+			const poly_extent *extent = &extents[(curscan + extnum) - startscanline];
+			INT32 istartx = extent->startx, istopx = extent->stopx;
+
+			/* force start < stop */
+			if (istartx > istopx)
+			{
+				INT32 temp = istartx;
+				istartx = istopx;
+				istopx = temp;
+			}
+
+			/* set the extent and update the total pixel count */
+			unit->extent[extnum].startx = (INT16)istartx;
+			unit->extent[extnum].stopx = (INT16)istopx;
+			raster_fastfill(dest,curscan,extent,extra);
+		}
+		delete unit;
+	}
+}
+
+
+
+/*************************************
+ *
+ *  Statistics management
+ *
+ *************************************/
+
+static void accumulate_statistics(voodoo_state *v, const stats_block *stats)
+{
+	/* apply internal voodoo statistics */
+	v->reg[fbiPixelsIn].u += stats->pixels_in;
+	v->reg[fbiPixelsOut].u += stats->pixels_out;
+	v->reg[fbiChromaFail].u += stats->chroma_fail;
+	v->reg[fbiZfuncFail].u += stats->zfunc_fail;
+	v->reg[fbiAfuncFail].u += stats->afunc_fail;
+}
+
+static void update_statistics(voodoo_state *v, bool accumulate)
+{
+	/* accumulate/reset statistics from all units */
+	if (accumulate)
+		accumulate_statistics(v, &v->thread_stats[0]);
+	memset(&v->thread_stats[0], 0, sizeof(v->thread_stats[0]));
+
+	/* accumulate/reset statistics from the LFB */
+	if (accumulate)
+		accumulate_statistics(v, &v->fbi.lfb_stats);
+	memset(&v->fbi.lfb_stats, 0, sizeof(v->fbi.lfb_stats));
+}
+
+
+
+/*************************************
+ *
+ *  Voodoo register writes
+ *
+ *************************************/
+
+void register_w(UINT32 offset, UINT32 data) {
+	voodoo_reg reg;
+	UINT32 regnum  = (offset) & 0xff;
+	UINT32 chips   = (offset>>8) & 0xf;
+	reg.u = data;
+
+	INT64 data64;
+
+//	LOG(LOG_VOODOO,LOG_WARN)("V3D:WR chip %x reg %x value %08x(%s)", chips, regnum<<2, data, voodoo_reg_name[regnum]);
+
+	if (chips == 0)
+		chips = 0xf;
+	chips &= v->chipmask;
+
+	/* the first 64 registers can be aliased differently */
+	if ((offset & 0x800c0) == 0x80000 && v->alt_regmap)
+		regnum = register_alias_map[offset & 0x3f];
+	else
+		regnum = offset & 0xff;
+
+	/* first make sure this register is readable */
+	if (!(v->regaccess[regnum] & REGISTER_WRITE))
+	{
+		if (regnum <= 0xe0) LOG(LOG_VOODOO,LOG_WARN)("VOODOO.ERROR:Invalid attempt to write %s\n", v->regnames[regnum]);
+		else LOG(LOG_VOODOO,LOG_WARN)("VOODOO.ERROR:Invalid attempt to write #%x\n", regnum);
+		return;
+	}
+
+	/* switch off the register */
+	switch (regnum)
+	{
+		/* Vertex data is 12.4 formatted fixed point */
+		case fvertexAx:
+			data = float_to_int32(data, 4);
+		case vertexAx:
+			if (chips & 1) v->fbi.ax = (INT16)(data&0xffff);
+			break;
+
+		case fvertexAy:
+			data = float_to_int32(data, 4);
+		case vertexAy:
+			if (chips & 1) v->fbi.ay = (INT16)(data&0xffff);
+			break;
+
+		case fvertexBx:
+			data = float_to_int32(data, 4);
+		case vertexBx:
+			if (chips & 1) v->fbi.bx = (INT16)(data&0xffff);
+			break;
+
+		case fvertexBy:
+			data = float_to_int32(data, 4);
+		case vertexBy:
+			if (chips & 1) v->fbi.by = (INT16)(data&0xffff);
+			break;
+
+		case fvertexCx:
+			data = float_to_int32(data, 4);
+		case vertexCx:
+			if (chips & 1) v->fbi.cx = (INT16)(data&0xffff);
+			break;
+
+		case fvertexCy:
+			data = float_to_int32(data, 4);
+		case vertexCy:
+			if (chips & 1) v->fbi.cy = (INT16)(data&0xffff);
+			break;
+
+		/* RGB data is 12.12 formatted fixed point */
+		case fstartR:
+			data = float_to_int32(data, 12);
+		case startR:
+			if (chips & 1) v->fbi.startr = (INT32)(data << 8) >> 8;
+			break;
+
+		case fstartG:
+			data = float_to_int32(data, 12);
+		case startG:
+			if (chips & 1) v->fbi.startg = (INT32)(data << 8) >> 8;
+			break;
+
+		case fstartB:
+			data = float_to_int32(data, 12);
+		case startB:
+			if (chips & 1) v->fbi.startb = (INT32)(data << 8) >> 8;
+			break;
+
+		case fstartA:
+			data = float_to_int32(data, 12);
+		case startA:
+			if (chips & 1) v->fbi.starta = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdRdX:
+			data = float_to_int32(data, 12);
+		case dRdX:
+			if (chips & 1) v->fbi.drdx = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdGdX:
+			data = float_to_int32(data, 12);
+		case dGdX:
+			if (chips & 1) v->fbi.dgdx = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdBdX:
+			data = float_to_int32(data, 12);
+		case dBdX:
+			if (chips & 1) v->fbi.dbdx = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdAdX:
+			data = float_to_int32(data, 12);
+		case dAdX:
+			if (chips & 1) v->fbi.dadx = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdRdY:
+			data = float_to_int32(data, 12);
+		case dRdY:
+			if (chips & 1) v->fbi.drdy = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdGdY:
+			data = float_to_int32(data, 12);
+		case dGdY:
+			if (chips & 1) v->fbi.dgdy = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdBdY:
+			data = float_to_int32(data, 12);
+		case dBdY:
+			if (chips & 1) v->fbi.dbdy = (INT32)(data << 8) >> 8;
+			break;
+
+		case fdAdY:
+			data = float_to_int32(data, 12);
+		case dAdY:
+			if (chips & 1) v->fbi.dady = (INT32)(data << 8) >> 8;
+			break;
+
+		/* Z data is 20.12 formatted fixed point */
+		case fstartZ:
+			data = float_to_int32(data, 12);
+		case startZ:
+			if (chips & 1) v->fbi.startz = (INT32)data;
+			break;
+
+		case fdZdX:
+			data = float_to_int32(data, 12);
+		case dZdX:
+			if (chips & 1) v->fbi.dzdx = (INT32)data;
+			break;
+
+		case fdZdY:
+			data = float_to_int32(data, 12);
+		case dZdY:
+			if (chips & 1) v->fbi.dzdy = (INT32)data;
+			break;
+
+		/* S,T data is 14.18 formatted fixed point, converted to 16.32 internally */
+		case fstartS:
+			data64 = float_to_int64(data, 32);
+			if (chips & 2) v->tmu[0].starts = data64;
+			if (chips & 4) v->tmu[1].starts = data64;
+			break;
+		case startS:
+			if (chips & 2) v->tmu[0].starts = (INT64)(INT32)data << 14;
+			if (chips & 4) v->tmu[1].starts = (INT64)(INT32)data << 14;
+			break;
+
+		case fstartT:
+			data64 = float_to_int64(data, 32);
+			if (chips & 2) v->tmu[0].startt = data64;
+			if (chips & 4) v->tmu[1].startt = data64;
+			break;
+		case startT:
+			if (chips & 2) v->tmu[0].startt = (INT64)(INT32)data << 14;
+			if (chips & 4) v->tmu[1].startt = (INT64)(INT32)data << 14;
+			break;
+
+		case fdSdX:
+			data64 = float_to_int64(data, 32);
+			if (chips & 2) v->tmu[0].dsdx = data64;
+			if (chips & 4) v->tmu[1].dsdx = data64;
+			break;
+		case dSdX:
+			if (chips & 2) v->tmu[0].dsdx = (INT64)(INT32)data << 14;
+			if (chips & 4) v->tmu[1].dsdx = (INT64)(INT32)data << 14;
+			break;
+
+		case fdTdX:
+			data64 = float_to_int64(data, 32);
+			if (chips & 2) v->tmu[0].dtdx = data64;
+			if (chips & 4) v->tmu[1].dtdx = data64;
+			break;
+		case dTdX:
+			if (chips & 2) v->tmu[0].dtdx = (INT64)(INT32)data << 14;
+			if (chips & 4) v->tmu[1].dtdx = (INT64)(INT32)data << 14;
+			break;
+
+		case fdSdY:
+			data64 = float_to_int64(data, 32);
+			if (chips & 2) v->tmu[0].dsdy = data64;
+			if (chips & 4) v->tmu[1].dsdy = data64;
+			break;
+		case dSdY:
+			if (chips & 2) v->tmu[0].dsdy = (INT64)(INT32)data << 14;
+			if (chips & 4) v->tmu[1].dsdy = (INT64)(INT32)data << 14;
+			break;
+
+		case fdTdY:
+			data64 = float_to_int64(data, 32);
+			if (chips & 2) v->tmu[0].dtdy = data64;
+			if (chips & 4) v->tmu[1].dtdy = data64;
+			break;
+		case dTdY:
+			if (chips & 2) v->tmu[0].dtdy = (INT64)(INT32)data << 14;
+			if (chips & 4) v->tmu[1].dtdy = (INT64)(INT32)data << 14;
+			break;
+
+		/* W data is 2.30 formatted fixed point, converted to 16.32 internally */
+		case fstartW:
+			data64 = float_to_int64(data, 32);
+			if (chips & 1) v->fbi.startw = data64;
+			if (chips & 2) v->tmu[0].startw = data64;
+			if (chips & 4) v->tmu[1].startw = data64;
+			break;
+		case startW:
+			if (chips & 1) v->fbi.startw = (INT64)(INT32)data << 2;
+			if (chips & 2) v->tmu[0].startw = (INT64)(INT32)data << 2;
+			if (chips & 4) v->tmu[1].startw = (INT64)(INT32)data << 2;
+			break;
+
+		case fdWdX:
+			data64 = float_to_int64(data, 32);
+			if (chips & 1) v->fbi.dwdx = data64;
+			if (chips & 2) v->tmu[0].dwdx = data64;
+			if (chips & 4) v->tmu[1].dwdx = data64;
+			break;
+		case dWdX:
+			if (chips & 1) v->fbi.dwdx = (INT64)(INT32)data << 2;
+			if (chips & 2) v->tmu[0].dwdx = (INT64)(INT32)data << 2;
+			if (chips & 4) v->tmu[1].dwdx = (INT64)(INT32)data << 2;
+			break;
+
+		case fdWdY:
+			data64 = float_to_int64(data, 32);
+			if (chips & 1) v->fbi.dwdy = data64;
+			if (chips & 2) v->tmu[0].dwdy = data64;
+			if (chips & 4) v->tmu[1].dwdy = data64;
+			break;
+		case dWdY:
+			if (chips & 1) v->fbi.dwdy = (INT64)(INT32)data << 2;
+			if (chips & 2) v->tmu[0].dwdy = (INT64)(INT32)data << 2;
+			if (chips & 4) v->tmu[1].dwdy = (INT64)(INT32)data << 2;
+			break;
+
+		/* setup bits */
+		case sARGB:
+			if (chips & 1)
+			{
+				v->reg[sAlpha].f = (float)RGB_ALPHA(data);
+				v->reg[sRed].f = (float)RGB_RED(data);
+				v->reg[sGreen].f = (float)RGB_GREEN(data);
+				v->reg[sBlue].f = (float)RGB_BLUE(data);
+			}
+			break;
+
+		/* mask off invalid bits for different cards */
+		case fbzColorPath:
+			if (v->type < VOODOO_2)
+				data &= 0x0fffffff;
+			if (chips & 1) v->reg[fbzColorPath].u = data;
+			break;
+
+		case fbzMode:
+			if (v->type < VOODOO_2)
+				data &= 0x001fffff;
+			if (chips & 1) {
+				if (v->ogl && v->active && (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u)!=FBZMODE_Y_ORIGIN(data))) {
+					v->reg[fbzMode].u = data;
+					voodoo_ogl_set_window(v);
+				} else {
+					v->reg[fbzMode].u = data;
+				}
+			}
+			break;
+
+		case fogMode:
+			if (v->type < VOODOO_2)
+				data &= 0x0000003f;
+			if (chips & 1) v->reg[fogMode].u = data;
+			break;
+
+		/* triangle drawing */
+		case triangleCMD:
+			triangle(v);
+			break;
+
+		case ftriangleCMD:
+			triangle(v);
+			break;
+
+		case sBeginTriCMD:
+//			E_Exit("begin tri");
+			begin_triangle(v);
+			break;
+
+		case sDrawTriCMD:
+//			E_Exit("draw tri");
+			draw_triangle(v);
+			break;
+
+		/* other commands */
+		case nopCMD:
+			if (data & 1)
+				reset_counters(v);
+			if (data & 2)
+				v->reg[fbiTrianglesOut].u = 0;
+			break;
+
+		case fastfillCMD:
+			fastfill(v);
+			break;
+
+		case swapbufferCMD:
+			swapbuffer(v, data);
+			break;
+
+		/* gamma table access -- Voodoo/Voodoo2 only */
+		case clutData:
+/*			if (chips & 1)
+			{
+				if (!FBIINIT1_VIDEO_TIMING_RESET(v->reg[fbiInit1].u))
+				{
+					int index = data >> 24;
+					if (index <= 32)
+					{
+//						v->fbi.clut[index] = data;
+					}
+				}
+				else
+					LOG(LOG_VOODOO,LOG_WARN)("clutData ignored because video timing reset = 1\n");
+			} */
+			break;
+
+		/* external DAC access -- Voodoo/Voodoo2 only */
+		case dacData:
+			if (chips & 1)
+			{
+				if (!(data & 0x800))
+					dacdata_w(&v->dac, (data >> 8) & 7, data & 0xff);
+				else
+					dacdata_r(&v->dac, (data >> 8) & 7);
+			}
+			break;
+
+		/* vertical sync rate -- Voodoo/Voodoo2 only */
+		case hSync:
+		case vSync:
+		case backPorch:
+		case videoDimensions:
+			if (chips & 1)
+			{
+				v->reg[regnum].u = data;
+				if (v->reg[hSync].u != 0 && v->reg[vSync].u != 0 && v->reg[videoDimensions].u != 0)
+				{
+					int htotal = ((v->reg[hSync].u >> 16) & 0x3ff) + 1 + (v->reg[hSync].u & 0xff) + 1;
+					int vtotal = ((v->reg[vSync].u >> 16) & 0xfff) + (v->reg[vSync].u & 0xfff);
+					int hvis = v->reg[videoDimensions].u & 0x3ff;
+					int vvis = (v->reg[videoDimensions].u >> 16) & 0x3ff;
+					int hbp = (v->reg[backPorch].u & 0xff) + 2;
+					int vbp = (v->reg[backPorch].u >> 16) & 0xff;
+//					attoseconds_t refresh = video_screen_get_frame_period(v->screen).attoseconds;
+					attoseconds_t refresh = 0;
+					attoseconds_t stdperiod, medperiod, vgaperiod;
+					attoseconds_t stddiff, meddiff, vgadiff;
+					rectangle visarea;
+
+					/* create a new visarea */
+					visarea.min_x = hbp;
+					visarea.max_x = hbp + hvis - 1;
+					visarea.min_y = vbp;
+					visarea.max_y = vbp + vvis - 1;
+
+					/* keep within bounds */
+					visarea.max_x = MIN(visarea.max_x, htotal - 1);
+					visarea.max_y = MIN(visarea.max_y, vtotal - 1);
+
+					/* compute the new period for standard res, medium res, and VGA res */
+					stdperiod = HZ_TO_ATTOSECONDS(15750) * vtotal;
+					medperiod = HZ_TO_ATTOSECONDS(25000) * vtotal;
+					vgaperiod = HZ_TO_ATTOSECONDS(31500) * vtotal;
+
+					/* compute a diff against the current refresh period */
+					stddiff = stdperiod - refresh;
+					if (stddiff < 0) stddiff = -stddiff;
+					meddiff = medperiod - refresh;
+					if (meddiff < 0) meddiff = -meddiff;
+					vgadiff = vgaperiod - refresh;
+					if (vgadiff < 0) vgadiff = -vgadiff;
+
+					LOG(LOG_VOODOO,LOG_WARN)("hSync=%08X  vSync=%08X  backPorch=%08X  videoDimensions=%08X\n",
+						v->reg[hSync].u, v->reg[vSync].u, v->reg[backPorch].u, v->reg[videoDimensions].u);
+					LOG(LOG_VOODOO,LOG_WARN)("Horiz: %d-%d (%d total)  Vert: %d-%d (%d total) -- ", visarea.min_x, visarea.max_x, htotal, visarea.min_y, visarea.max_y, vtotal);
+
+					/* configure the screen based on which one matches the closest */
+					if (stddiff < meddiff && stddiff < vgadiff)
+					{
+//						video_screen_configure(v->screen, htotal, vtotal, &visarea, stdperiod);
+						LOG(LOG_VOODOO,LOG_WARN)("Standard resolution, %f Hz\n", ATTOSECONDS_TO_HZ(stdperiod));
+					}
+					else if (meddiff < vgadiff)
+					{
+//						video_screen_configure(v->screen, htotal, vtotal, &visarea, medperiod);
+						LOG(LOG_VOODOO,LOG_WARN)("Medium resolution, %f Hz\n", ATTOSECONDS_TO_HZ(medperiod));
+					}
+					else
+					{
+//						video_screen_configure(v->screen, htotal, vtotal, &visarea, vgaperiod);
+						LOG(LOG_VOODOO,LOG_WARN)("VGA resolution, %f Hz\n", ATTOSECONDS_TO_HZ(vgaperiod));
+					}
+
+					/* configure the new framebuffer info */
+					UINT32 new_width = (hvis+1) & ~1;
+					UINT32 new_height = (vvis+1) & ~1;
+					if ((v->fbi.width != new_width) || (v->fbi.height != new_height)) {
+						v->fbi.width = new_width;
+						v->fbi.height = new_height;
+						v->ogl_dimchange = true;
+					}
+//					v->fbi.xoffs = hbp;
+//					v->fbi.yoffs = vbp;
+//					v->fbi.vsyncscan = (v->reg[vSync].u >> 16) & 0xfff;
+
+					/* recompute the time of VBLANK */
+//					adjust_vblank_timer(v);
+
+					/* if changing dimensions, update video memory layout */
+					if (regnum == videoDimensions)
+						recompute_video_memory(v);
+
+					Voodoo_UpdateScreenStart();
+				}
+			}
+			break;
+
+		/* fbiInit0 can only be written if initEnable says we can -- Voodoo/Voodoo2 only */
+		case fbiInit0:
+			if ((chips & 1) && INITEN_ENABLE_HW_INIT(v->pci.init_enable))
+			{
+				Voodoo_Output_Enable(FBIINIT0_VGA_PASSTHRU(data));
+				v->reg[fbiInit0].u = data;
+				if (FBIINIT0_GRAPHICS_RESET(data))
+					soft_reset(v);
+				recompute_video_memory(v);
+			}
+			break;
+
+		/* fbiInit5-7 are Voodoo 2-only; ignore them on anything else */
+		case fbiInit5:
+		case fbiInit6:
+			if (v->type < VOODOO_2)
+				break;
+			/* else fall through... */
+
+		/* fbiInitX can only be written if initEnable says we can -- Voodoo/Voodoo2 only */
+		/* most of these affect memory layout, so always recompute that when done */
+		case fbiInit1:
+		case fbiInit2:
+		case fbiInit4:
+			if ((chips & 1) && INITEN_ENABLE_HW_INIT(v->pci.init_enable))
+			{
+				v->reg[regnum].u = data;
+				recompute_video_memory(v);
+			}
+			break;
+
+		case fbiInit3:
+			if ((chips & 1) && INITEN_ENABLE_HW_INIT(v->pci.init_enable))
+			{
+				v->reg[regnum].u = data;
+				v->alt_regmap = (FBIINIT3_TRI_REGISTER_REMAP(data) > 0);
+				v->fbi.yorigin = FBIINIT3_YORIGIN_SUBTRACT(v->reg[fbiInit3].u);
+				recompute_video_memory(v);
+			}
+			break;
+
+		/* nccTable entries are processed and expanded immediately */
+		case nccTable+0:
+		case nccTable+1:
+		case nccTable+2:
+		case nccTable+3:
+		case nccTable+4:
+		case nccTable+5:
+		case nccTable+6:
+		case nccTable+7:
+		case nccTable+8:
+		case nccTable+9:
+		case nccTable+10:
+		case nccTable+11:
+			if (chips & 2) ncc_table_write(&v->tmu[0].ncc[0], regnum - nccTable, data);
+			if (chips & 4) ncc_table_write(&v->tmu[1].ncc[0], regnum - nccTable, data);
+			break;
+
+		case nccTable+12:
+		case nccTable+13:
+		case nccTable+14:
+		case nccTable+15:
+		case nccTable+16:
+		case nccTable+17:
+		case nccTable+18:
+		case nccTable+19:
+		case nccTable+20:
+		case nccTable+21:
+		case nccTable+22:
+		case nccTable+23:
+			if (chips & 2) ncc_table_write(&v->tmu[0].ncc[1], regnum - (nccTable+12), data);
+			if (chips & 4) ncc_table_write(&v->tmu[1].ncc[1], regnum - (nccTable+12), data);
+			break;
+
+		/* fogTable entries are processed and expanded immediately */
+		case fogTable+0:
+		case fogTable+1:
+		case fogTable+2:
+		case fogTable+3:
+		case fogTable+4:
+		case fogTable+5:
+		case fogTable+6:
+		case fogTable+7:
+		case fogTable+8:
+		case fogTable+9:
+		case fogTable+10:
+		case fogTable+11:
+		case fogTable+12:
+		case fogTable+13:
+		case fogTable+14:
+		case fogTable+15:
+		case fogTable+16:
+		case fogTable+17:
+		case fogTable+18:
+		case fogTable+19:
+		case fogTable+20:
+		case fogTable+21:
+		case fogTable+22:
+		case fogTable+23:
+		case fogTable+24:
+		case fogTable+25:
+		case fogTable+26:
+		case fogTable+27:
+		case fogTable+28:
+		case fogTable+29:
+		case fogTable+30:
+		case fogTable+31:
+			if (chips & 1)
+			{
+				int base = 2 * (regnum - fogTable);
+				v->fbi.fogdelta[base + 0] = (data >> 0) & 0xff;
+				v->fbi.fogblend[base + 0] = (data >> 8) & 0xff;
+				v->fbi.fogdelta[base + 1] = (data >> 16) & 0xff;
+				v->fbi.fogblend[base + 1] = (data >> 24) & 0xff;
+			}
+			break;
+
+		/* texture modifications cause us to recompute everything */
+		case textureMode:
+		case tLOD:
+		case tDetail:
+		case texBaseAddr:
+		case texBaseAddr_1:
+		case texBaseAddr_2:
+		case texBaseAddr_3_8:
+			if (chips & 2)
+			{
+				v->tmu[0].reg[regnum].u = data;
+				v->tmu[0].regdirty = true;
+			}
+			if (chips & 4)
+			{
+				v->tmu[1].reg[regnum].u = data;
+				v->tmu[1].regdirty = true;
+			}
+			break;
+
+		case trexInit1:
+			/* send tmu config data to the frame buffer */
+			v->send_config = (TREXINIT_SEND_TMU_CONFIG(data) > 0);
+			goto default_case;
+			break;
+
+		case clipLowYHighY:
+		case clipLeftRight:
+			if (chips & 1) v->reg[0x000 + regnum].u = data;
+			if (v->ogl) {
+				voodoo_ogl_clip_window(v);
+			}
+			break;
+
+		/* these registers are referenced in the renderer; we must wait for pending work before changing */
+		case chromaRange:
+		case chromaKey:
+		case alphaMode:
+		case fogColor:
+		case stipple:
+		case zaColor:
+		case color1:
+		case color0:
+			/* fall through to default implementation */
+
+		/* by default, just feed the data to the chips */
+		default:
+default_case:
+			if (chips & 1) v->reg[0x000 + regnum].u = data;
+			if (chips & 2) v->reg[0x100 + regnum].u = data;
+			if (chips & 4) v->reg[0x200 + regnum].u = data;
+			if (chips & 8) v->reg[0x300 + regnum].u = data;
+			break;
+	}
+
+}
+
+
+
+/*************************************
+ *
+ *  Voodoo LFB writes
+ *
+ *************************************/
+
+void lfb_w(UINT32 offset, UINT32 data, UINT32 mem_mask) {
+	LOG(LOG_VOODOO,LOG_WARN)("V3D:WR LFB offset %X value %08X", offset, data);
+	UINT16 *dest, *depth;
+	UINT32 destmax, depthmax;
+
+	int sr[2], sg[2], sb[2], sa[2], sw[2];
+	int x, y, scry, mask;
+	int pix, destbuf;
+
+	/* byte swizzling */
+	if (LFBMODE_BYTE_SWIZZLE_WRITES(v->reg[lfbMode].u))
+	{
+		data = FLIPENDIAN_INT32(data);
+		mem_mask = FLIPENDIAN_INT32(mem_mask);
+	}
+
+	/* word swapping */
+	if (LFBMODE_WORD_SWAP_WRITES(v->reg[lfbMode].u))
+	{
+		data = (data << 16) | (data >> 16);
+		mem_mask = (mem_mask << 16) | (mem_mask >> 16);
+	}
+
+	/* extract default depth and alpha values */
+	sw[0] = sw[1] = v->reg[zaColor].u & 0xffff;
+	sa[0] = sa[1] = v->reg[zaColor].u >> 24;
+
+	/* first extract A,R,G,B from the data */
+	switch (LFBMODE_WRITE_FORMAT(v->reg[lfbMode].u) + 16 * LFBMODE_RGBA_LANES(v->reg[lfbMode].u))
+	{
+		case 16*0 + 0:		/* ARGB, 16-bit RGB 5-6-5 */
+		case 16*2 + 0:		/* RGBA, 16-bit RGB 5-6-5 */
+			EXTRACT_565_TO_888(data, sr[0], sg[0], sb[0]);
+			EXTRACT_565_TO_888(data >> 16, sr[1], sg[1], sb[1]);
+			mask = LFB_RGB_PRESENT | (LFB_RGB_PRESENT << 4);
+			offset <<= 1;
+			break;
+		case 16*1 + 0:		/* ABGR, 16-bit RGB 5-6-5 */
+		case 16*3 + 0:		/* BGRA, 16-bit RGB 5-6-5 */
+			EXTRACT_565_TO_888(data, sb[0], sg[0], sr[0]);
+			EXTRACT_565_TO_888(data >> 16, sb[1], sg[1], sr[1]);
+			mask = LFB_RGB_PRESENT | (LFB_RGB_PRESENT << 4);
+			offset <<= 1;
+			break;
+
+		case 16*0 + 1:		/* ARGB, 16-bit RGB x-5-5-5 */
+			EXTRACT_x555_TO_888(data, sr[0], sg[0], sb[0]);
+			EXTRACT_x555_TO_888(data >> 16, sr[1], sg[1], sb[1]);
+			mask = LFB_RGB_PRESENT | (LFB_RGB_PRESENT << 4);
+			offset <<= 1;
+			break;
+		case 16*1 + 1:		/* ABGR, 16-bit RGB x-5-5-5 */
+			EXTRACT_x555_TO_888(data, sb[0], sg[0], sr[0]);
+			EXTRACT_x555_TO_888(data >> 16, sb[1], sg[1], sr[1]);
+			mask = LFB_RGB_PRESENT | (LFB_RGB_PRESENT << 4);
+			offset <<= 1;
+			break;
+		case 16*2 + 1:		/* RGBA, 16-bit RGB x-5-5-5 */
+			EXTRACT_555x_TO_888(data, sr[0], sg[0], sb[0]);
+			EXTRACT_555x_TO_888(data >> 16, sr[1], sg[1], sb[1]);
+			mask = LFB_RGB_PRESENT | (LFB_RGB_PRESENT << 4);
+			offset <<= 1;
+			break;
+		case 16*3 + 1:		/* BGRA, 16-bit RGB x-5-5-5 */
+			EXTRACT_555x_TO_888(data, sb[0], sg[0], sr[0]);
+			EXTRACT_555x_TO_888(data >> 16, sb[1], sg[1], sr[1]);
+			mask = LFB_RGB_PRESENT | (LFB_RGB_PRESENT << 4);
+			offset <<= 1;
+			break;
+
+		case 16*0 + 2:		/* ARGB, 16-bit ARGB 1-5-5-5 */
+			EXTRACT_1555_TO_8888(data, sa[0], sr[0], sg[0], sb[0]);
+			EXTRACT_1555_TO_8888(data >> 16, sa[1], sr[1], sg[1], sb[1]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | ((LFB_RGB_PRESENT | LFB_ALPHA_PRESENT) << 4);
+			offset <<= 1;
+			break;
+		case 16*1 + 2:		/* ABGR, 16-bit ARGB 1-5-5-5 */
+			EXTRACT_1555_TO_8888(data, sa[0], sb[0], sg[0], sr[0]);
+			EXTRACT_1555_TO_8888(data >> 16, sa[1], sb[1], sg[1], sr[1]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | ((LFB_RGB_PRESENT | LFB_ALPHA_PRESENT) << 4);
+			offset <<= 1;
+			break;
+		case 16*2 + 2:		/* RGBA, 16-bit ARGB 1-5-5-5 */
+			EXTRACT_5551_TO_8888(data, sr[0], sg[0], sb[0], sa[0]);
+			EXTRACT_5551_TO_8888(data >> 16, sr[1], sg[1], sb[1], sa[1]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | ((LFB_RGB_PRESENT | LFB_ALPHA_PRESENT) << 4);
+			offset <<= 1;
+			break;
+		case 16*3 + 2:		/* BGRA, 16-bit ARGB 1-5-5-5 */
+			EXTRACT_5551_TO_8888(data, sb[0], sg[0], sr[0], sa[0]);
+			EXTRACT_5551_TO_8888(data >> 16, sb[1], sg[1], sr[1], sa[1]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | ((LFB_RGB_PRESENT | LFB_ALPHA_PRESENT) << 4);
+			offset <<= 1;
+			break;
+
+		case 16*0 + 4:		/* ARGB, 32-bit RGB x-8-8-8 */
+			EXTRACT_x888_TO_888(data, sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT;
+			break;
+		case 16*1 + 4:		/* ABGR, 32-bit RGB x-8-8-8 */
+			EXTRACT_x888_TO_888(data, sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT;
+			break;
+		case 16*2 + 4:		/* RGBA, 32-bit RGB x-8-8-8 */
+			EXTRACT_888x_TO_888(data, sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT;
+			break;
+		case 16*3 + 4:		/* BGRA, 32-bit RGB x-8-8-8 */
+			EXTRACT_888x_TO_888(data, sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT;
+			break;
+
+		case 16*0 + 5:		/* ARGB, 32-bit ARGB 8-8-8-8 */
+			EXTRACT_8888_TO_8888(data, sa[0], sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT;
+			break;
+		case 16*1 + 5:		/* ABGR, 32-bit ARGB 8-8-8-8 */
+			EXTRACT_8888_TO_8888(data, sa[0], sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT;
+			break;
+		case 16*2 + 5:		/* RGBA, 32-bit ARGB 8-8-8-8 */
+			EXTRACT_8888_TO_8888(data, sr[0], sg[0], sb[0], sa[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT;
+			break;
+		case 16*3 + 5:		/* BGRA, 32-bit ARGB 8-8-8-8 */
+			EXTRACT_8888_TO_8888(data, sb[0], sg[0], sr[0], sa[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT;
+			break;
+
+		case 16*0 + 12:		/* ARGB, 32-bit depth+RGB 5-6-5 */
+		case 16*2 + 12:		/* RGBA, 32-bit depth+RGB 5-6-5 */
+			sw[0] = data >> 16;
+			EXTRACT_565_TO_888(data, sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*1 + 12:		/* ABGR, 32-bit depth+RGB 5-6-5 */
+		case 16*3 + 12:		/* BGRA, 32-bit depth+RGB 5-6-5 */
+			sw[0] = data >> 16;
+			EXTRACT_565_TO_888(data, sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+
+		case 16*0 + 13:		/* ARGB, 32-bit depth+RGB x-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_x555_TO_888(data, sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*1 + 13:		/* ABGR, 32-bit depth+RGB x-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_x555_TO_888(data, sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*2 + 13:		/* RGBA, 32-bit depth+RGB x-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_555x_TO_888(data, sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*3 + 13:		/* BGRA, 32-bit depth+RGB x-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_555x_TO_888(data, sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+
+		case 16*0 + 14:		/* ARGB, 32-bit depth+ARGB 1-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_1555_TO_8888(data, sa[0], sr[0], sg[0], sb[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*1 + 14:		/* ABGR, 32-bit depth+ARGB 1-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_1555_TO_8888(data, sa[0], sb[0], sg[0], sr[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*2 + 14:		/* RGBA, 32-bit depth+ARGB 1-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_5551_TO_8888(data, sr[0], sg[0], sb[0], sa[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+		case 16*3 + 14:		/* BGRA, 32-bit depth+ARGB 1-5-5-5 */
+			sw[0] = data >> 16;
+			EXTRACT_5551_TO_8888(data, sb[0], sg[0], sr[0], sa[0]);
+			mask = LFB_RGB_PRESENT | LFB_ALPHA_PRESENT | LFB_DEPTH_PRESENT_MSW;
+			break;
+
+		case 16*0 + 15:		/* ARGB, 16-bit depth */
+		case 16*1 + 15:		/* ARGB, 16-bit depth */
+		case 16*2 + 15:		/* ARGB, 16-bit depth */
+		case 16*3 + 15:		/* ARGB, 16-bit depth */
+			sw[0] = data & 0xffff;
+			sw[1] = data >> 16;
+			mask = LFB_DEPTH_PRESENT | (LFB_DEPTH_PRESENT << 4);
+			offset <<= 1;
+			break;
+
+		default:			/* reserved */
+			return;
+	}
+
+	/* compute X,Y */
+	x = (offset << 0) & ((1 << 10) - 1);
+	y = (offset >> 10) & ((1 << 10) - 1);
+
+	/* adjust the mask based on which half of the data is written */
+	if (!ACCESSING_BITS_0_15)
+		mask &= ~(0x0f - LFB_DEPTH_PRESENT_MSW);
+	if (!ACCESSING_BITS_16_31)
+		mask &= ~(0xf0 + LFB_DEPTH_PRESENT_MSW);
+
+	/* select the target buffer */
+	destbuf = LFBMODE_WRITE_BUFFER_SELECT(v->reg[lfbMode].u);
+//	LOG(LOG_VOODOO,LOG_WARN)("destbuf %X lfbmode %X",destbuf, v->reg[lfbMode].u);
+	switch (destbuf)
+	{
+		case 0:			/* front buffer */
+			dest = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.frontbuf]);
+			destmax = (v->fbi.mask + 1 - v->fbi.rgboffs[v->fbi.frontbuf]) / 2;
+			break;
+
+		case 1:			/* back buffer */
+			dest = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.backbuf]);
+			destmax = (v->fbi.mask + 1 - v->fbi.rgboffs[v->fbi.backbuf]) / 2;
+			break;
+
+		default:		/* reserved */
+			E_Exit("reserved lfb write");
+			return;
+	}
+	depth = (UINT16 *)(v->fbi.ram + v->fbi.auxoffs);
+	depthmax = (v->fbi.mask + 1 - v->fbi.auxoffs) / 2;
+
+	/* simple case: no pipeline */
+	if (!LFBMODE_ENABLE_PIXEL_PIPELINE(v->reg[lfbMode].u))
+	{
+		DECLARE_DITHER_POINTERS;
+		UINT32 bufoffs;
+
+		if (LOG_LFB) LOG(LOG_VOODOO,LOG_WARN)("VOODOO.LFB:write raw mode %X (%d,%d) = %08X & %08X\n", LFBMODE_WRITE_FORMAT(v->reg[lfbMode].u), x, y, data, mem_mask);
+
+		/* determine the screen Y */
+		scry = y;
+		if (LFBMODE_Y_ORIGIN(v->reg[lfbMode].u))
+			scry = (v->fbi.yorigin - y) & 0x3ff;
+
+		/* advance pointers to the proper row */
+		bufoffs = scry * v->fbi.rowpixels + x;
+
+		/* compute dithering */
+		COMPUTE_DITHER_POINTERS(v->reg[fbzMode].u, y);
+
+		/* loop over up to two pixels */
+		for (pix = 0; mask; pix++)
+		{
+			/* make sure we care about this pixel */
+			if (mask & 0x0f)
+			{
+				bool has_rgb = (mask & LFB_RGB_PRESENT) > 0;
+				bool has_alpha = ((mask & LFB_ALPHA_PRESENT) > 0) && (FBZMODE_ENABLE_ALPHA_PLANES(v->reg[fbzMode].u) > 0);
+				bool has_depth = ((mask & (LFB_DEPTH_PRESENT | LFB_DEPTH_PRESENT_MSW)) && !FBZMODE_ENABLE_ALPHA_PLANES(v->reg[fbzMode].u));
+				if (v->ogl && v->active) {
+					if (has_rgb || has_alpha) {
+						// if enabling dithering: output is 565 not 888 anymore
+//						APPLY_DITHER(v->reg[fbzMode].u, x, dither_lookup, sr[pix], sg[pix], sb[pix]);
+						voodoo_ogl_draw_pixel(x, scry+1, has_rgb, has_alpha, sr[pix], sg[pix], sb[pix], sa[pix]);
+					}
+					if (has_depth) {
+						voodoo_ogl_draw_z(x, scry+1, sw[pix]);
+					}
+				} else {
+					/* write to the RGB buffer */
+					if (has_rgb && bufoffs < destmax)
+					{
+						/* apply dithering and write to the screen */
+						APPLY_DITHER(v->reg[fbzMode].u, x, dither_lookup, sr[pix], sg[pix], sb[pix]);
+						dest[bufoffs] = (UINT16)((sr[pix] << 11) | (sg[pix] << 5) | sb[pix]);
+					}
+
+					/* make sure we have an aux buffer to write to */
+					if (depth && bufoffs < depthmax)
+					{
+						/* write to the alpha buffer */
+						if (has_alpha)
+							depth[bufoffs] = (UINT16)sa[pix];
+
+						/* write to the depth buffer */
+						if (has_depth)
+							depth[bufoffs] = (UINT16)sw[pix];
+					}
+				}
+
+				/* track pixel writes to the frame buffer regardless of mask */
+				v->reg[fbiPixelsOut].u++;
+			}
+
+			/* advance our pointers */
+			bufoffs++;
+			x++;
+			mask >>= 4;
+		}
+	}
+
+	/* tricky case: run the full pixel pipeline on the pixel */
+	else
+	{
+		DECLARE_DITHER_POINTERS;
+
+		if (LOG_LFB) LOG(LOG_VOODOO,LOG_WARN)("VOODOO.LFB:write pipelined mode %X (%d,%d) = %08X & %08X\n", LFBMODE_WRITE_FORMAT(v->reg[lfbMode].u), x, y, data, mem_mask);
+
+		/* determine the screen Y */
+		scry = y;
+		if (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))
+			scry = (v->fbi.yorigin - y) & 0x3ff;
+
+		/* advance pointers to the proper row */
+		dest += scry * v->fbi.rowpixels;
+		if (depth)
+			depth += scry * v->fbi.rowpixels;
+
+		/* compute dithering */
+		COMPUTE_DITHER_POINTERS(v->reg[fbzMode].u, y);
+
+		/* loop over up to two pixels */
+		for (pix = 0; mask; pix++)
+		{
+			/* make sure we care about this pixel */
+			if (mask & 0x0f)
+			{
+				stats_block *stats = &v->fbi.lfb_stats;
+				INT64 iterw = sw[pix] << (30-16);
+				INT32 iterz = sw[pix] << 12;
+				rgb_union color;
+
+				/* apply clipping */
+				if (FBZMODE_ENABLE_CLIPPING(v->reg[fbzMode].u))
+				{
+					if (x < (INT32)((v->reg[clipLeftRight].u >> 16) & 0x3ff) ||
+						x >= (INT32)(v->reg[clipLeftRight].u & 0x3ff) ||
+						scry < (INT32)((v->reg[clipLowYHighY].u >> 16) & 0x3ff) ||
+						scry >= (INT32)(v->reg[clipLowYHighY].u & 0x3ff))
+					{
+						stats->pixels_in++;
+						stats->clip_fail++;
+						goto nextpixel;
+					}
+				}
+
+				/* pixel pipeline part 1 handles depth testing and stippling */
+				// TODO: in the v->ogl case this macro doesn't really work with depth testing
+				PIXEL_PIPELINE_BEGIN(v, x, y, v->reg[fbzColorPath].u, v->reg[fbzMode].u, iterz, iterw);
+
+				color.rgb.r = sr[pix];
+				color.rgb.g = sg[pix];
+				color.rgb.b = sb[pix];
+				color.rgb.a = sa[pix];
+
+				/* apply chroma key */
+				APPLY_CHROMAKEY(v, stats, v->reg[fbzMode].u, color);
+
+				/* apply alpha mask, and alpha testing */
+				APPLY_ALPHAMASK(v, stats, v->reg[fbzMode].u, color.rgb.a);
+				APPLY_ALPHATEST(v, stats, v->reg[alphaMode].u, color.rgb.a);
+
+
+				if (FBZCP_CC_MSELECT(v->reg[fbzColorPath].u) != 0) LOG_MSG("lfbw fpp mselect %8x",FBZCP_CC_MSELECT(v->reg[fbzColorPath].u));
+				if (FBZCP_CCA_MSELECT(v->reg[fbzColorPath].u) > 1) LOG_MSG("lfbw fpp mselect alpha %8x",FBZCP_CCA_MSELECT(v->reg[fbzColorPath].u));
+
+				if (FBZCP_CC_REVERSE_BLEND(v->reg[fbzColorPath].u) != 0) {
+					if (FBZCP_CC_MSELECT(v->reg[fbzColorPath].u) != 0) LOG_MSG("lfbw fpp rblend %8x",FBZCP_CC_REVERSE_BLEND(v->reg[fbzColorPath].u));
+				}
+				if (FBZCP_CCA_REVERSE_BLEND(v->reg[fbzColorPath].u) != 0) {
+					if (FBZCP_CC_MSELECT(v->reg[fbzColorPath].u) != 0) LOG_MSG("lfbw fpp rblend alpha %8x",FBZCP_CCA_REVERSE_BLEND(v->reg[fbzColorPath].u));
+				}
+
+
+				INT32 blendr, blendg, blendb, blenda;
+				rgb_union c_local;
+
+				/* compute c_local */
+				if (FBZCP_CC_LOCALSELECT_OVERRIDE(v->reg[fbzColorPath].u) == 0)
+				{
+					if (FBZCP_CC_LOCALSELECT(v->reg[fbzColorPath].u) == 0)	/* iterated RGB */
+					{
+//						c_local.u = iterargb.u;
+						c_local.rgb.r = sr[pix];
+						c_local.rgb.g = sg[pix];
+						c_local.rgb.b = sb[pix];
+					}
+					else											/* color0 RGB */
+						c_local.u = v->reg[color0].u;
+				}
+				else
+				{
+					LOG_MSG("lfbw fpp FBZCP_CC_LOCALSELECT_OVERRIDE set!");
+/*					if (!(texel.rgb.a & 0x80))					// iterated RGB
+						c_local.u = iterargb.u;
+					else											// color0 RGB
+						c_local.u = v->reg[color0].u; */
+				}
+
+				/* compute a_local */
+				switch (FBZCP_CCA_LOCALSELECT(v->reg[fbzColorPath].u))
+				{
+					default:
+					case 0:		/* iterated alpha */
+//						c_local.rgb.a = iterargb.rgb.a;
+						c_local.rgb.a = sa[pix];
+						break;
+					case 1:		/* color0 alpha */
+						c_local.rgb.a = v->reg[color0].rgb.a;
+						break;
+					case 2:		/* clamped iterated Z[27:20] */
+					{
+						int temp;
+						CLAMPED_Z(iterz, v->reg[fbzColorPath].u, temp);
+						c_local.rgb.a = (UINT8)temp;
+						break;
+					}
+					case 3:		/* clamped iterated W[39:32] */
+					{
+						int temp;
+						CLAMPED_W(iterw, v->reg[fbzColorPath].u, temp);			/* Voodoo 2 only */
+						c_local.rgb.a = (UINT8)temp;
+						break;
+					}
+				}
+
+				/* select zero or c_other */
+				if (FBZCP_CC_ZERO_OTHER(v->reg[fbzColorPath].u) == 0) {
+					r = sr[pix];
+					g = sg[pix];
+					b = sb[pix];
+				} else {
+					r = g = b = 0;
+				}
+
+				/* select zero or a_other */
+				if (FBZCP_CCA_ZERO_OTHER(v->reg[fbzColorPath].u) == 0) {
+					a = sa[pix];
+				} else {
+					a = 0;
+				}
+
+				/* subtract c_local */
+				if (FBZCP_CC_SUB_CLOCAL(v->reg[fbzColorPath].u))
+				{
+					r -= c_local.rgb.r;
+					g -= c_local.rgb.g;
+					b -= c_local.rgb.b;
+				}
+
+				/* subtract a_local */
+				if (FBZCP_CCA_SUB_CLOCAL(v->reg[fbzColorPath].u))
+					a -= c_local.rgb.a;
+
+				/* blend RGB */
+				switch (FBZCP_CC_MSELECT(v->reg[fbzColorPath].u))
+				{
+					default:	/* reserved */
+					case 0:		/* 0 */
+						blendr = blendg = blendb = 0;
+						break;
+					case 1:		/* c_local */
+						blendr = c_local.rgb.r;
+						blendg = c_local.rgb.g;
+						blendb = c_local.rgb.b;
+						LOG_MSG("blend RGB c_local");
+						break;
+					case 2:		/* a_other */
+//						blendr = blendg = blendb = c_other.rgb.a;
+						LOG_MSG("blend RGB a_other");
+						break;
+					case 3:		/* a_local */
+						blendr = blendg = blendb = c_local.rgb.a;
+						LOG_MSG("blend RGB a_local");
+						break;
+					case 4:		/* texture alpha */
+//						blendr = blendg = blendb = texel.rgb.a;
+						LOG_MSG("blend RGB texture alpha");
+						break;
+					case 5:		/* texture RGB (Voodoo 2 only) */
+/*						blendr = texel.rgb.r;
+						blendg = texel.rgb.g;
+						blendb = texel.rgb.b; */
+						LOG_MSG("blend RGB texture RGB");
+						break;
+				}
+
+				/* blend alpha */
+				switch (FBZCP_CCA_MSELECT(v->reg[fbzColorPath].u))
+				{
+					default:	/* reserved */
+					case 0:		/* 0 */
+						blenda = 0;
+						break;
+					case 1:		/* a_local */
+						blenda = c_local.rgb.a;
+//						LOG_MSG("blend alpha a_local");
+						break;
+					case 2:		/* a_other */
+//						blenda = c_other.rgb.a;
+						LOG_MSG("blend alpha a_other");
+						break;
+					case 3:		/* a_local */
+						blenda = c_local.rgb.a;
+						LOG_MSG("blend alpha a_local");
+						break;
+					case 4:		/* texture alpha */
+//						blenda = texel.rgb.a;
+						LOG_MSG("blend alpha texture alpha");
+						break;
+				}
+
+				/* reverse the RGB blend */
+				if (!FBZCP_CC_REVERSE_BLEND(v->reg[fbzColorPath].u))
+				{
+					blendr ^= 0xff;
+					blendg ^= 0xff;
+					blendb ^= 0xff;
+				}
+
+				/* reverse the alpha blend */
+				if (!FBZCP_CCA_REVERSE_BLEND(v->reg[fbzColorPath].u))
+					blenda ^= 0xff;
+
+				/* do the blend */
+				r = (r * (blendr + 1)) >> 8;
+				g = (g * (blendg + 1)) >> 8;
+				b = (b * (blendb + 1)) >> 8;
+				a = (a * (blenda + 1)) >> 8;
+
+				/* add clocal or alocal to RGB */
+				switch (FBZCP_CC_ADD_ACLOCAL(v->reg[fbzColorPath].u))
+				{
+					case 3:		/* reserved */
+					case 0:		/* nothing */
+						break;
+					case 1:		/* add c_local */
+						r += c_local.rgb.r;
+						g += c_local.rgb.g;
+						b += c_local.rgb.b;
+						break;
+					case 2:		/* add_alocal */
+						r += c_local.rgb.a;
+						g += c_local.rgb.a;
+						b += c_local.rgb.a;
+						break;
+				}
+
+				/* add clocal or alocal to alpha */
+				if (FBZCP_CCA_ADD_ACLOCAL(v->reg[fbzColorPath].u))
+					a += c_local.rgb.a;
+
+				/* clamp */
+				CLAMP(r, 0x00, 0xff);
+				CLAMP(g, 0x00, 0xff);
+				CLAMP(b, 0x00, 0xff);
+				CLAMP(a, 0x00, 0xff);
+
+				/* invert */
+				if (FBZCP_CC_INVERT_OUTPUT(v->reg[fbzColorPath].u))
+				{
+					r ^= 0xff;
+					g ^= 0xff;
+					b ^= 0xff;
+				}
+				if (FBZCP_CCA_INVERT_OUTPUT(v->reg[fbzColorPath].u))
+					a ^= 0xff;
+
+				if (v->ogl && v->active) {
+					if (FBZMODE_RGB_BUFFER_MASK(v->reg[fbzMode].u)) {
+//						APPLY_DITHER(FBZMODE, XX, DITHER_LOOKUP, r, g, b);
+						voodoo_ogl_draw_pixel_pipeline(x, scry+1, r, g, b);
+					}
+/*					if (depth && FBZMODE_AUX_BUFFER_MASK(v->reg[fbzMode].u)) {
+						if (FBZMODE_ENABLE_ALPHA_PLANES(v->reg[fbzMode].u) == 0)
+							voodoo_ogl_draw_z(x, y, depthval&0xffff, depthval>>16);
+//						else
+//							depth[XX] = a;
+					} */
+				} else {
+					/* pixel pipeline part 2 handles color combine, fog, alpha, and final output */
+					PIXEL_PIPELINE_MODIFY(v, dither, dither4, x, v->reg[fbzMode].u, v->reg[fbzColorPath].u, v->reg[alphaMode].u, v->reg[fogMode].u, iterz, iterw, v->reg[zaColor]);
+
+					PIXEL_PIPELINE_FINISH(v, dither_lookup, x, dest, depth, v->reg[fbzMode].u);
+				}
+
+				PIXEL_PIPELINE_END(stats);
+			}
+nextpixel:
+			/* advance our pointers */
+			x++;
+			mask >>= 4;
+		}
+	}
+}
+
+
+
+/*************************************
+ *
+ *  Voodoo texture RAM writes
+ *
+ *************************************/
+
+INT32 texture_w(UINT32 offset, UINT32 data) {
+	int tmunum = (offset >> 19) & 0x03;
+	LOG(LOG_VOODOO,LOG_WARN)("V3D:write TMU%x offset %X value %X", tmunum, offset, data);
+
+	tmu_state *t;
+
+	/* point to the right TMU */
+	if (!(v->chipmask & (2 << tmunum)))
+		return 0;
+	t = &v->tmu[tmunum];
+
+	if (TEXLOD_TDIRECT_WRITE(t->reg[tLOD].u))
+		E_Exit("Texture direct write!");
+
+	/* update texture info if dirty */
+	if (t->regdirty)
+		recompute_texture_params(t);
+
+	/* swizzle the data */
+	if (TEXLOD_TDATA_SWIZZLE(t->reg[tLOD].u))
+		data = FLIPENDIAN_INT32(data);
+	if (TEXLOD_TDATA_SWAP(t->reg[tLOD].u))
+		data = (data >> 16) | (data << 16);
+
+	/* 8-bit texture case */
+	if (TEXMODE_FORMAT(t->reg[textureMode].u) < 8)
+	{
+		int lod, tt, ts;
+		UINT32 tbaseaddr;
+		UINT8 *dest;
+
+		/* extract info */
+		lod = (offset >> 15) & 0x0f;
+		tt = (offset >> 7) & 0xff;
+
+		/* old code has a bit about how this is broken in gauntleg unless we always look at TMU0 */
+		if (TEXMODE_SEQ_8_DOWNLD(v->tmu[0].reg/*t->reg*/[textureMode].u))
+			ts = (offset << 2) & 0xfc;
+		else
+			ts = (offset << 1) & 0xfc;
+
+		/* validate parameters */
+		if (lod > 8)
+			return 0;
+
+		/* compute the base address */
+		tbaseaddr = t->lodoffset[lod];
+		tbaseaddr += tt * ((t->wmask >> lod) + 1) + ts;
+
+		if (LOG_TEXTURE_RAM) LOG(LOG_VOODOO,LOG_WARN)("Texture 8-bit w: lod=%d s=%d t=%d data=%08X\n", lod, ts, tt, data);
+
+		/* write the four bytes in little-endian order */
+		dest = t->ram;
+		tbaseaddr &= t->mask;
+
+		bool changed = false;
+		if (dest[BYTE4_XOR_LE(tbaseaddr + 0)] != ((data >> 0) & 0xff)) {
+			dest[BYTE4_XOR_LE(tbaseaddr + 0)] = (data >> 0) & 0xff;
+			changed = true;
+		}
+		if (dest[BYTE4_XOR_LE(tbaseaddr + 1)] != ((data >> 8) & 0xff)) {
+			dest[BYTE4_XOR_LE(tbaseaddr + 1)] = (data >> 8) & 0xff;
+			changed = true;
+		}
+		if (dest[BYTE4_XOR_LE(tbaseaddr + 2)] != ((data >> 16) & 0xff)) {
+			dest[BYTE4_XOR_LE(tbaseaddr + 2)] = (data >> 16) & 0xff;
+			changed = true;
+		}
+		if (dest[BYTE4_XOR_LE(tbaseaddr + 3)] != ((data >> 24) & 0xff)) {
+			dest[BYTE4_XOR_LE(tbaseaddr + 3)] = (data >> 24) & 0xff;
+			changed = true;
+		}
+
+		if (changed && v->ogl && v->active) {
+			voodoo_ogl_texture_clear(t->lodoffset[lod],tmunum);
+			voodoo_ogl_texture_clear(t->lodoffset[t->lodmin],tmunum);
+		}
+	}
+
+	/* 16-bit texture case */
+	else
+	{
+		int lod, tt, ts;
+		UINT32 tbaseaddr;
+		UINT16 *dest;
+
+		/* extract info */
+		tmunum = (offset >> 19) & 0x03;
+		lod = (offset >> 15) & 0x0f;
+		tt = (offset >> 7) & 0xff;
+		ts = (offset << 1) & 0xfe;
+
+		/* validate parameters */
+		if (lod > 8)
+			return 0;
+
+		/* compute the base address */
+		tbaseaddr = t->lodoffset[lod];
+		tbaseaddr += 2 * (tt * ((t->wmask >> lod) + 1) + ts);
+
+		if (LOG_TEXTURE_RAM) LOG(LOG_VOODOO,LOG_WARN)("Texture 16-bit w: lod=%d s=%d t=%d data=%08X\n", lod, ts, tt, data);
+
+		/* write the two words in little-endian order */
+		dest = (UINT16 *)t->ram;
+		tbaseaddr &= t->mask;
+		tbaseaddr >>= 1;
+
+		bool changed = false;
+		if (dest[BYTE_XOR_LE(tbaseaddr + 0)] != ((data >> 0) & 0xffff)) {
+			dest[BYTE_XOR_LE(tbaseaddr + 0)] = (data >> 0) & 0xffff;
+			changed = true;
+		}
+		if (dest[BYTE_XOR_LE(tbaseaddr + 1)] != ((data >> 16) & 0xffff)) {
+			dest[BYTE_XOR_LE(tbaseaddr + 1)] = (data >> 16) & 0xffff;
+			changed = true;
+		}
+
+		if (changed && v->ogl && v->active) {
+			voodoo_ogl_texture_clear(t->lodoffset[lod],tmunum);
+			voodoo_ogl_texture_clear(t->lodoffset[t->lodmin],tmunum);
+		}
+	}
+
+	return 0;
+}
+
+
+
+/*************************************
+ *
+ *  Handle a register read
+ *
+ *************************************/
+
+UINT32 register_r(UINT32 offset)
+{
+	UINT32 regnum  = (offset) & 0xff;
+
+//	LOG(LOG_VOODOO,LOG_WARN)("Voodoo:read chip %x reg %x (%s)", chips, regnum<<2, voodoo_reg_name[regnum]);
+
+	/* first make sure this register is readable */
+	if (!(v->regaccess[regnum] & REGISTER_READ))
+	{
+		return 0xffffffff;
+	}
+
+	UINT32 result;
+
+	/* default result is the FBI register value */
+	result = v->reg[regnum].u;
+
+	/* some registers are dynamic; compute them */
+	switch (regnum)
+	{
+		case status:
+
+			/* start with a blank slate */
+			result = 0;
+
+			/* bits 5:0 are the PCI FIFO free space */
+			result |= 0x3f << 0;
+
+			/* bit 6 is the vertical retrace */
+			//result |= v->fbi.vblank << 6;
+			result |= (Voodoo_GetRetrace() ? 0x40 : 0);
+
+
+			/* bit 7 is FBI graphics engine busy */
+			if (v->pci.op_pending)
+				result |= 1 << 7;
+
+			/* bit 8 is TREX busy */
+			if (v->pci.op_pending)
+				result |= 1 << 8;
+
+			/* bit 9 is overall busy */
+			if (v->pci.op_pending)
+				result |= 1 << 9;
+
+			/* bits 11:10 specifies which buffer is visible */
+			result |= v->fbi.frontbuf << 10;
+
+			/* bits 27:12 indicate memory FIFO freespace */
+			result |= 0xffff << 12;
+
+			/* bits 30:28 are the number of pending swaps */
+			result |= 0 << 28;
+
+			/* bit 31 is not used */
+
+
+			break;
+
+		case hvRetrace:
+			if (v->type < VOODOO_2)
+				break;
+
+
+			/* start with a blank slate */
+			result = 0;
+
+			result |= ((Bit32u)(Voodoo_GetVRetracePosition() * 0x1fff)) & 0x1fff;
+			result |= (((Bit32u)(Voodoo_GetHRetracePosition() * 0x7ff)) & 0x7ff) << 16;
+
+			break;
+
+		/* bit 2 of the initEnable register maps this to dacRead */
+		case fbiInit2:
+			if (INITEN_REMAP_INIT_TO_DAC(v->pci.init_enable))
+				result = v->dac.read_result;
+			break;
+
+/*		case fbiInit3:
+			if (INITEN_REMAP_INIT_TO_DAC(v->pci.init_enable))
+				result = 0;
+			break;
+
+		case fbiInit6:
+			if (v->type < VOODOO_2)
+				break;
+			result &= 0xffffe7ff;
+			result |= 0x1000;
+			break; */
+
+		/* all counters are 24-bit only */
+		case fbiPixelsIn:
+		case fbiChromaFail:
+		case fbiZfuncFail:
+		case fbiAfuncFail:
+		case fbiPixelsOut:
+			update_statistics(v, TRUE);
+		case fbiTrianglesOut:
+			result = v->reg[regnum].u & 0xffffff;
+			break;
+
+	}
+
+	return result;
+}
+
+
+
+/*************************************
+ *
+ *  Handle an LFB read
+ *
+ *************************************/
+UINT32 lfb_r(UINT32 offset)
+{
+	LOG(LOG_VOODOO,LOG_WARN)("Voodoo:read LFB offset %X", offset);
+	UINT16 *buffer;
+	UINT32 bufmax;
+	UINT32 bufoffs;
+	UINT32 data;
+	int x, y, scry;
+	UINT32 destbuf;
+
+	/* compute X,Y */
+	x = (offset << 1) & 0x3fe;
+	y = (offset >> 9) & 0x3ff;
+
+	/* select the target buffer */
+	destbuf = LFBMODE_READ_BUFFER_SELECT(v->reg[lfbMode].u);
+	switch (destbuf)
+	{
+		case 0:			/* front buffer */
+			buffer = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.frontbuf]);
+			bufmax = (v->fbi.mask + 1 - v->fbi.rgboffs[v->fbi.frontbuf]) / 2;
+			break;
+
+		case 1:			/* back buffer */
+			buffer = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.backbuf]);
+			bufmax = (v->fbi.mask + 1 - v->fbi.rgboffs[v->fbi.backbuf]) / 2;
+			break;
+
+		case 2:			/* aux buffer */
+			if (v->fbi.auxoffs == (UINT32)(~0))
+				return 0xffffffff;
+			buffer = (UINT16 *)(v->fbi.ram + v->fbi.auxoffs);
+			bufmax = (v->fbi.mask + 1 - v->fbi.auxoffs) / 2;
+			break;
+
+		default:		/* reserved */
+			return 0xffffffff;
+	}
+
+	/* determine the screen Y */
+	scry = y;
+	if (LFBMODE_Y_ORIGIN(v->reg[lfbMode].u))
+		scry = (v->fbi.yorigin - y) & 0x3ff;
+
+	if (v->ogl && v->active) {
+		data = voodoo_ogl_read_pixel(x, scry+1);
+	} else {
+		/* advance pointers to the proper row */
+		bufoffs = scry * v->fbi.rowpixels + x;
+		if (bufoffs >= bufmax)
+			return 0xffffffff;
+
+		/* compute the data */
+		data = buffer[bufoffs + 0] | (buffer[bufoffs + 1] << 16);
+	}
+
+	/* word swapping */
+	if (LFBMODE_WORD_SWAP_READS(v->reg[lfbMode].u))
+		data = (data << 16) | (data >> 16);
+
+	/* byte swizzling */
+	if (LFBMODE_BYTE_SWIZZLE_READS(v->reg[lfbMode].u))
+		data = FLIPENDIAN_INT32(data);
+
+	if (LOG_LFB) LOG(LOG_VOODOO,LOG_WARN)("VOODOO.LFB:read (%d,%d) = %08X\n", x, y, data);
+	return data;
+}
+
+
+void voodoo_w(UINT32 offset, UINT32 data, UINT32 mask) {
+	if ((offset & (0xc00000/4)) == 0)
+		register_w(offset, data);
+	else if ((offset & (0x800000/4)) == 0)
+		lfb_w(offset, data, mask);
+	else
+		texture_w(offset, data);
+}
+
+UINT32 voodoo_r(UINT32 offset) {
+	if ((offset & (0xc00000/4)) == 0)
+		return register_r(offset);
+	else if ((offset & (0x800000/4)) == 0)
+		return lfb_r(offset);
+
+	return 0xffffffff;
+}
+
+
+
+/***************************************************************************
+    DEVICE INTERFACE
+***************************************************************************/
+
+/*-------------------------------------------------
+    device start callback
+-------------------------------------------------*/
+
+void voodoo_init(int type) {
+	v->active = false;
+
+	v->type = VOODOO_1;
+
+	switch (type) {
+		case VOODOO_1:
+			break;
+		case VOODOO_1_DTMU:
+			v->type = VOODOO_1_DTMU;
+			break;
+		case VOODOO_2:
+			v->type = VOODOO_2;
+			break;
+		default:
+			LOG_MSG("invalid voodoo card type initialization [%x]",type);
+			break;
+	}
+
+	memset(v->reg, 0, sizeof(v->reg));
+
+	v->fbi.vblank_flush_pending = false;
+	v->pci.op_pending = false;
+	v->dac.read_result = 0;
+
+	v->output_on = false;
+	v->clock_enabled = false;
+	v->ogl_dimchange = true;
+	v->send_config = false;
+
+	memset(v->dac.reg, 0, sizeof(v->dac.reg));
+
+	v->next_rasterizer = 0;
+	for (UINT32 rct=0; rct<MAX_RASTERIZERS; rct++)
+		v->rasterizer[rct] = raster_info();
+
+	v->thread_stats = new stats_block[1];
+	v->thread_stats[0].pixels_in = 0;
+	v->thread_stats[0].pixels_out = 0;
+	v->thread_stats[0].chroma_fail = 0;
+	v->thread_stats[0].zfunc_fail = 0;
+	v->thread_stats[0].afunc_fail = 0;
+	v->thread_stats[0].clip_fail = 0;
+	v->thread_stats[0].stipple_count = 0;
+
+	v->alt_regmap = false;
+	v->regnames = voodoo_reg_name;
+
+	/* create a table of precomputed 1/n and log2(n) values */
+	/* n ranges from 1.0000 to 2.0000 */
+	for (UINT32 val = 0; val <= (1 << RECIPLOG_LOOKUP_BITS); val++)
+	{
+		UINT32 value = (1 << RECIPLOG_LOOKUP_BITS) + val;
+		voodoo_reciplog[val*2 + 0] = (1 << (RECIPLOG_LOOKUP_PREC + RECIPLOG_LOOKUP_BITS)) / value;
+		voodoo_reciplog[val*2 + 1] = (UINT32)(LOGB2((double)value / (double)(1 << RECIPLOG_LOOKUP_BITS)) * (double)(1 << RECIPLOG_LOOKUP_PREC));
+	}
+
+	for (UINT32 val = 0; val < RASTER_HASH_SIZE; val++)
+		v->raster_hash[val] = NULL;
+
+	/* create dithering tables */
+	for (UINT32 val = 0; val < 256*16*2; val++)
+	{
+		int g = (val >> 0) & 1;
+		int x = (val >> 1) & 3;
+		int color = (val >> 3) & 0xff;
+		int y = (val >> 11) & 3;
+
+		if (!g)
+		{
+			dither4_lookup[val] = (UINT8)(DITHER_RB(color, dither_matrix_4x4[y * 4 + x]) >> 3);
+			dither2_lookup[val] = (UINT8)(DITHER_RB(color, dither_matrix_2x2[y * 4 + x]) >> 3);
+		}
+		else
+		{
+			dither4_lookup[val] = (UINT8)(DITHER_G(color, dither_matrix_4x4[y * 4 + x]) >> 2);
+			dither2_lookup[val] = (UINT8)(DITHER_G(color, dither_matrix_2x2[y * 4 + x]) >> 2);
+		}
+	}
+
+	v->tmu_config = 0x11;	// revision 1
+
+	UINT32 fbmemsize = 0;
+	UINT32 tmumem0 = 0;
+	UINT32 tmumem1 = 0;
+
+	/* configure type-specific values */
+	switch (v->type)
+	{
+		case VOODOO_1:
+			v->regaccess = voodoo_register_access;
+			fbmemsize = 2;
+			tmumem0 = 2;
+			break;
+
+		case VOODOO_1_DTMU:
+			v->regaccess = voodoo_register_access;
+			fbmemsize = 4;
+			tmumem0 = 4;
+			tmumem1 = 4;
+			break;
+/*
+		case VOODOO_2:
+			v->regaccess = voodoo2_register_access;
+			fbmemsize = 4;
+			tmumem0 = 4;
+			tmumem1 = 4;
+			v->tmu_config |= 0x800;
+			break;
+*/
+		default:
+			E_Exit("Unsupported voodoo card in voodoo_start!");
+			break;
+	}
+
+	if (tmumem1 != 0)
+		v->tmu_config |= 0xc0;	// two TMUs
+
+	v->chipmask = 0x01;
+
+	/* set up the PCI FIFO */
+	v->pci.fifo.size = 64*2;
+
+	/* set up frame buffer */
+	init_fbi(v, &v->fbi, fbmemsize << 20);
+
+	v->fbi.rowpixels = v->fbi.width;
+
+	v->tmu[0].ncc[0].palette = NULL;
+	v->tmu[0].ncc[1].palette = NULL;
+	v->tmu[1].ncc[0].palette = NULL;
+	v->tmu[1].ncc[1].palette = NULL;
+	v->tmu[0].ncc[0].palettea = NULL;
+	v->tmu[0].ncc[1].palettea = NULL;
+	v->tmu[1].ncc[0].palettea = NULL;
+	v->tmu[1].ncc[1].palettea = NULL;
+
+	v->tmu[0].ram = NULL;
+	v->tmu[1].ram = NULL;
+	v->tmu[0].lookup = NULL;
+	v->tmu[1].lookup = NULL;
+
+	/* build shared TMU tables */
+	init_tmu_shared(&v->tmushare);
+
+	/* set up the TMUs */
+	init_tmu(v, &v->tmu[0], &v->reg[0x100], tmumem0 << 20);
+	v->chipmask |= 0x02;
+	if (tmumem1 != 0)
+	{
+		init_tmu(v, &v->tmu[1], &v->reg[0x200], tmumem1 << 20);
+		v->chipmask |= 0x04;
+		v->tmu_config |= 0x40;
+	}
+
+	/* initialize some registers */
+	v->pci.init_enable = 0;
+	v->reg[fbiInit0].u = (UINT32)((1 << 4) | (0x10 << 6));
+	v->reg[fbiInit1].u = (UINT32)((1 << 1) | (1 << 8) | (1 << 12) | (2 << 20));
+	v->reg[fbiInit2].u = (UINT32)((1 << 6) | (0x100 << 23));
+	v->reg[fbiInit3].u = (UINT32)((2 << 13) | (0xf << 17));
+	v->reg[fbiInit4].u = (UINT32)(1 << 0);
+
+	/* do a soft reset to reset everything else */
+	soft_reset(v);
+
+	recompute_video_memory(v);
+}
+
+void voodoo_shutdown() {
+	if (v->ogl)
+		voodoo_ogl_shutdown(v);
+
+	if (v!=NULL) {
+		free(v->fbi.ram);
+		if (v->tmu[0].ram != NULL) {
+			free(v->tmu[0].ram);
+			v->tmu[0].ram = NULL;
+		}
+		if (v->tmu[1].ram != NULL) {
+			free(v->tmu[1].ram);
+			v->tmu[1].ram = NULL;
+		}
+		delete v->thread_stats;
+		v->active=false;
+	}
+}
+
+
+/***************************************************************************
+    COMMAND HANDLERS
+***************************************************************************/
+
+/*-------------------------------------------------
+    fastfill - execute the 'fastfill'
+    command
+-------------------------------------------------*/
+
+void fastfill(voodoo_state *v)
+{
+	int sx = (v->reg[clipLeftRight].u >> 16) & 0x3ff;
+	int ex = (v->reg[clipLeftRight].u >> 0) & 0x3ff;
+	int sy = (v->reg[clipLowYHighY].u >> 16) & 0x3ff;
+	int ey = (v->reg[clipLowYHighY].u >> 0) & 0x3ff;
+
+	poly_extent extents[64];
+	UINT16 dithermatrix[16];
+	UINT16 *drawbuf = NULL;
+	int extnum, x, y;
+
+	/* if we're not clearing either, take no time */
+	if (!FBZMODE_RGB_BUFFER_MASK(v->reg[fbzMode].u) && !FBZMODE_AUX_BUFFER_MASK(v->reg[fbzMode].u))
+		return;
+
+	/* are we clearing the RGB buffer? */
+	if (FBZMODE_RGB_BUFFER_MASK(v->reg[fbzMode].u))
+	{
+		/* determine the draw buffer */
+		int destbuf = FBZMODE_DRAW_BUFFER(v->reg[fbzMode].u);
+		switch (destbuf)
+		{
+			case 0:		/* front buffer */
+				drawbuf = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.frontbuf]);
+				break;
+
+			case 1:		/* back buffer */
+				drawbuf = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.backbuf]);
+				break;
+
+			default:	/* reserved */
+				break;
+		}
+
+		/* determine the dither pattern */
+		for (y = 0; y < 4; y++)
+		{
+			DECLARE_DITHER_POINTERS;
+			COMPUTE_DITHER_POINTERS(v->reg[fbzMode].u, y);
+			for (x = 0; x < 4; x++)
+			{
+				int r = v->reg[color1].rgb.r;
+				int g = v->reg[color1].rgb.g;
+				int b = v->reg[color1].rgb.b;
+
+				APPLY_DITHER(v->reg[fbzMode].u, x, dither_lookup, r, g, b);
+				dithermatrix[y*4 + x] = (UINT16)((r << 11) | (g << 5) | b);
+			}
+		}
+	}
+
+	/* fill in a block of extents */
+	extents[0].startx = sx;
+	extents[0].stopx = ex;
+	for (extnum = 1; extnum < ARRAY_LENGTH(extents); extnum++)
+		extents[extnum] = extents[0];
+
+	poly_extra_data *extra = new poly_extra_data;
+
+	if (v->ogl && v->active) {
+		voodoo_ogl_fastfill();
+	} else {
+
+		/* iterate over blocks of extents */
+		for (y = sy; y < ey; y += ARRAY_LENGTH(extents))
+		{
+			int count = MIN(ey - y, ARRAY_LENGTH(extents));
+
+			extra->state = v;
+			memcpy(extra->dither, dithermatrix, sizeof(extra->dither));
+
+			poly_render_triangle_custom(drawbuf, y, count, extents, extra);
+		}
+	}
+	delete extra;
+}
+
+
+/*-------------------------------------------------
+    swapbuffer - execute the 'swapbuffer'
+    command
+-------------------------------------------------*/
+
+void swapbuffer(voodoo_state *v, UINT32 data)
+{
+	/* set the don't swap value for Voodoo 2 */
+	v->fbi.vblank_dont_swap = ((data >> 9) & 1)>0;
+
+	voodoo_swap_buffers(v);
+}
+
+
+/*-------------------------------------------------
+    triangle - execute the 'triangle'
+    command
+-------------------------------------------------*/
+
+void triangle(voodoo_state *v)
+{
+	int texcount = 0;
+	UINT16 *drawbuf;
+	int destbuf;
+
+	/* determine the number of TMUs involved */
+	texcount = 0;
+	if (!FBIINIT3_DISABLE_TMUS(v->reg[fbiInit3].u) && FBZCP_TEXTURE_ENABLE(v->reg[fbzColorPath].u))
+	{
+		texcount = 1;
+		if (v->chipmask & 0x04)
+			texcount = 2;
+	}
+
+	/* perform subpixel adjustments */
+	// ????????
+	if (!v->ogl && FBZCP_CCA_SUBPIXEL_ADJUST(v->reg[fbzColorPath].u))
+//	if (FBZCP_CCA_SUBPIXEL_ADJUST(v->reg[fbzColorPath].u))
+	{
+		INT32 dx = 8 - (v->fbi.ax & 15);
+		INT32 dy = 8 - (v->fbi.ay & 15);
+
+		/* adjust iterated R,G,B,A and W/Z */
+		v->fbi.startr += (dy * v->fbi.drdy + dx * v->fbi.drdx) >> 4;
+		v->fbi.startg += (dy * v->fbi.dgdy + dx * v->fbi.dgdx) >> 4;
+		v->fbi.startb += (dy * v->fbi.dbdy + dx * v->fbi.dbdx) >> 4;
+		v->fbi.starta += (dy * v->fbi.dady + dx * v->fbi.dadx) >> 4;
+		v->fbi.startw += (dy * v->fbi.dwdy + dx * v->fbi.dwdx) >> 4;
+		v->fbi.startz += mul_32x32_shift(dy, v->fbi.dzdy, 4) + mul_32x32_shift(dx, v->fbi.dzdx, 4);
+
+		/* adjust iterated W/S/T for TMU 0 */
+		if (texcount >= 1)
+		{
+			v->tmu[0].startw += (dy * v->tmu[0].dwdy + dx * v->tmu[0].dwdx) >> 4;
+			v->tmu[0].starts += (dy * v->tmu[0].dsdy + dx * v->tmu[0].dsdx) >> 4;
+			v->tmu[0].startt += (dy * v->tmu[0].dtdy + dx * v->tmu[0].dtdx) >> 4;
+
+			/* adjust iterated W/S/T for TMU 1 */
+			if (texcount >= 2)
+			{
+				v->tmu[1].startw += (dy * v->tmu[1].dwdy + dx * v->tmu[1].dwdx) >> 4;
+				v->tmu[1].starts += (dy * v->tmu[1].dsdy + dx * v->tmu[1].dsdx) >> 4;
+				v->tmu[1].startt += (dy * v->tmu[1].dtdy + dx * v->tmu[1].dtdx) >> 4;
+			}
+		}
+	}
+
+	/* determine the draw buffer */
+	destbuf = FBZMODE_DRAW_BUFFER(v->reg[fbzMode].u);
+	switch (destbuf)
+	{
+		case 0:		/* front buffer */
+			drawbuf = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.frontbuf]);
+			break;
+
+		case 1:		/* back buffer */
+			drawbuf = (UINT16 *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.backbuf]);
+			break;
+
+		default:	/* reserved */
+			return;
+	}
+
+	/* find a rasterizer that matches our current state */
+	triangle_create_work_item(v, drawbuf, texcount);
+
+	/* update stats */
+	v->reg[fbiTrianglesOut].u++;
+}
+
+
+/*-------------------------------------------------
+    begin_triangle - execute the 'beginTri'
+    command
+-------------------------------------------------*/
+
+static void begin_triangle(voodoo_state *v)
+{
+	setup_vertex *sv = &v->fbi.svert[2];
+
+	/* extract all the data from registers */
+	sv->x = v->reg[sVx].f;
+	sv->y = v->reg[sVy].f;
+	sv->wb = v->reg[sWb].f;
+	sv->w0 = v->reg[sWtmu0].f;
+	sv->s0 = v->reg[sS_W0].f;
+	sv->t0 = v->reg[sT_W0].f;
+	sv->w1 = v->reg[sWtmu1].f;
+	sv->s1 = v->reg[sS_Wtmu1].f;
+	sv->t1 = v->reg[sT_Wtmu1].f;
+	sv->a = v->reg[sAlpha].f;
+	sv->r = v->reg[sRed].f;
+	sv->g = v->reg[sGreen].f;
+	sv->b = v->reg[sBlue].f;
+
+	/* spread it across all three verts and reset the count */
+	v->fbi.svert[0] = v->fbi.svert[1] = v->fbi.svert[2];
+	v->fbi.sverts = 1;
+}
+
+
+/*-------------------------------------------------
+    draw_triangle - execute the 'DrawTri'
+    command
+-------------------------------------------------*/
+
+static void draw_triangle(voodoo_state *v)
+{
+	setup_vertex *sv = &v->fbi.svert[2];
+
+	/* for strip mode, shuffle vertex 1 down to 0 */
+	if (!(v->reg[sSetupMode].u & (1 << 16)))
+		v->fbi.svert[0] = v->fbi.svert[1];
+
+	/* copy 2 down to 1 regardless */
+	v->fbi.svert[1] = v->fbi.svert[2];
+
+	/* extract all the data from registers */
+	sv->x = v->reg[sVx].f;
+	sv->y = v->reg[sVy].f;
+	sv->wb = v->reg[sWb].f;
+	sv->w0 = v->reg[sWtmu0].f;
+	sv->s0 = v->reg[sS_W0].f;
+	sv->t0 = v->reg[sT_W0].f;
+	sv->w1 = v->reg[sWtmu1].f;
+	sv->s1 = v->reg[sS_Wtmu1].f;
+	sv->t1 = v->reg[sT_Wtmu1].f;
+	sv->a = v->reg[sAlpha].f;
+	sv->r = v->reg[sRed].f;
+	sv->g = v->reg[sGreen].f;
+	sv->b = v->reg[sBlue].f;
+
+	/* if we have enough verts, go ahead and draw */
+	if (++v->fbi.sverts >= 3)
+		setup_and_draw_triangle(v);
+}
+
+
+/*-------------------------------------------------
+    setup_and_draw_triangle - process the setup
+    parameters and render the triangle
+-------------------------------------------------*/
+
+static void setup_and_draw_triangle(voodoo_state *v)
+{
+	float dx1, dy1, dx2, dy2;
+	float divisor, tdiv;
+
+	/* grab the X/Ys at least */
+	v->fbi.ax = (INT16)(v->fbi.svert[0].x * 16.0);
+	v->fbi.ay = (INT16)(v->fbi.svert[0].y * 16.0);
+	v->fbi.bx = (INT16)(v->fbi.svert[1].x * 16.0);
+	v->fbi.by = (INT16)(v->fbi.svert[1].y * 16.0);
+	v->fbi.cx = (INT16)(v->fbi.svert[2].x * 16.0);
+	v->fbi.cy = (INT16)(v->fbi.svert[2].y * 16.0);
+
+	/* compute the divisor */
+	divisor = 1.0f / ((v->fbi.svert[0].x - v->fbi.svert[1].x) * (v->fbi.svert[0].y - v->fbi.svert[2].y) -
+					  (v->fbi.svert[0].x - v->fbi.svert[2].x) * (v->fbi.svert[0].y - v->fbi.svert[1].y));
+
+	/* backface culling */
+	if (v->reg[sSetupMode].u & 0x20000)
+	{
+		int culling_sign = (v->reg[sSetupMode].u >> 18) & 1;
+		int divisor_sign = (divisor < 0);
+
+		/* if doing strips and ping pong is enabled, apply the ping pong */
+		if ((v->reg[sSetupMode].u & 0x90000) == 0x00000)
+			culling_sign ^= (v->fbi.sverts - 3) & 1;
+
+		/* if our sign matches the culling sign, we're done for */
+		if (divisor_sign == culling_sign)
+			return;
+	}
+
+	/* compute the dx/dy values */
+	dx1 = v->fbi.svert[0].y - v->fbi.svert[2].y;
+	dx2 = v->fbi.svert[0].y - v->fbi.svert[1].y;
+	dy1 = v->fbi.svert[0].x - v->fbi.svert[1].x;
+	dy2 = v->fbi.svert[0].x - v->fbi.svert[2].x;
+
+	/* set up R,G,B */
+	tdiv = divisor * 4096.0f;
+	if (v->reg[sSetupMode].u & (1 << 0))
+	{
+		v->fbi.startr = (INT32)(v->fbi.svert[0].r * 4096.0f);
+		v->fbi.drdx = (INT32)(((v->fbi.svert[0].r - v->fbi.svert[1].r) * dx1 - (v->fbi.svert[0].r - v->fbi.svert[2].r) * dx2) * tdiv);
+		v->fbi.drdy = (INT32)(((v->fbi.svert[0].r - v->fbi.svert[2].r) * dy1 - (v->fbi.svert[0].r - v->fbi.svert[1].r) * dy2) * tdiv);
+		v->fbi.startg = (INT32)(v->fbi.svert[0].g * 4096.0f);
+		v->fbi.dgdx = (INT32)(((v->fbi.svert[0].g - v->fbi.svert[1].g) * dx1 - (v->fbi.svert[0].g - v->fbi.svert[2].g) * dx2) * tdiv);
+		v->fbi.dgdy = (INT32)(((v->fbi.svert[0].g - v->fbi.svert[2].g) * dy1 - (v->fbi.svert[0].g - v->fbi.svert[1].g) * dy2) * tdiv);
+		v->fbi.startb = (INT32)(v->fbi.svert[0].b * 4096.0f);
+		v->fbi.dbdx = (INT32)(((v->fbi.svert[0].b - v->fbi.svert[1].b) * dx1 - (v->fbi.svert[0].b - v->fbi.svert[2].b) * dx2) * tdiv);
+		v->fbi.dbdy = (INT32)(((v->fbi.svert[0].b - v->fbi.svert[2].b) * dy1 - (v->fbi.svert[0].b - v->fbi.svert[1].b) * dy2) * tdiv);
+	}
+
+	/* set up alpha */
+	if (v->reg[sSetupMode].u & (1 << 1))
+	{
+		v->fbi.starta = (INT32)(v->fbi.svert[0].a * 4096.0);
+		v->fbi.dadx = (INT32)(((v->fbi.svert[0].a - v->fbi.svert[1].a) * dx1 - (v->fbi.svert[0].a - v->fbi.svert[2].a) * dx2) * tdiv);
+		v->fbi.dady = (INT32)(((v->fbi.svert[0].a - v->fbi.svert[2].a) * dy1 - (v->fbi.svert[0].a - v->fbi.svert[1].a) * dy2) * tdiv);
+	}
+
+	/* set up Z */
+	if (v->reg[sSetupMode].u & (1 << 2))
+	{
+		v->fbi.startz = (INT32)(v->fbi.svert[0].z * 4096.0);
+		v->fbi.dzdx = (INT32)(((v->fbi.svert[0].z - v->fbi.svert[1].z) * dx1 - (v->fbi.svert[0].z - v->fbi.svert[2].z) * dx2) * tdiv);
+		v->fbi.dzdy = (INT32)(((v->fbi.svert[0].z - v->fbi.svert[2].z) * dy1 - (v->fbi.svert[0].z - v->fbi.svert[1].z) * dy2) * tdiv);
+	}
+
+	/* set up Wb */
+	tdiv = divisor * 65536.0f * 65536.0f;
+	if (v->reg[sSetupMode].u & (1 << 3))
+	{
+		v->fbi.startw = v->tmu[0].startw = v->tmu[1].startw = (INT64)(v->fbi.svert[0].wb * 65536.0f * 65536.0f);
+		v->fbi.dwdx = v->tmu[0].dwdx = v->tmu[1].dwdx = (INT64)(((v->fbi.svert[0].wb - v->fbi.svert[1].wb) * dx1 - (v->fbi.svert[0].wb - v->fbi.svert[2].wb) * dx2) * tdiv);
+		v->fbi.dwdy = v->tmu[0].dwdy = v->tmu[1].dwdy = (INT64)(((v->fbi.svert[0].wb - v->fbi.svert[2].wb) * dy1 - (v->fbi.svert[0].wb - v->fbi.svert[1].wb) * dy2) * tdiv);
+	}
+
+	/* set up W0 */
+	if (v->reg[sSetupMode].u & (1 << 4))
+	{
+		v->tmu[0].startw = v->tmu[1].startw = (INT64)(v->fbi.svert[0].w0 * 65536.0f * 65536.0f);
+		v->tmu[0].dwdx = v->tmu[1].dwdx = (INT64)(((v->fbi.svert[0].w0 - v->fbi.svert[1].w0) * dx1 - (v->fbi.svert[0].w0 - v->fbi.svert[2].w0) * dx2) * tdiv);
+		v->tmu[0].dwdy = v->tmu[1].dwdy = (INT64)(((v->fbi.svert[0].w0 - v->fbi.svert[2].w0) * dy1 - (v->fbi.svert[0].w0 - v->fbi.svert[1].w0) * dy2) * tdiv);
+	}
+
+	/* set up S0,T0 */
+	if (v->reg[sSetupMode].u & (1 << 5))
+	{
+		v->tmu[0].starts = v->tmu[1].starts = (INT64)(v->fbi.svert[0].s0 * 65536.0f * 65536.0f);
+		v->tmu[0].dsdx = v->tmu[1].dsdx = (INT64)(((v->fbi.svert[0].s0 - v->fbi.svert[1].s0) * dx1 - (v->fbi.svert[0].s0 - v->fbi.svert[2].s0) * dx2) * tdiv);
+		v->tmu[0].dsdy = v->tmu[1].dsdy = (INT64)(((v->fbi.svert[0].s0 - v->fbi.svert[2].s0) * dy1 - (v->fbi.svert[0].s0 - v->fbi.svert[1].s0) * dy2) * tdiv);
+		v->tmu[0].startt = v->tmu[1].startt = (INT64)(v->fbi.svert[0].t0 * 65536.0f * 65536.0f);
+		v->tmu[0].dtdx = v->tmu[1].dtdx = (INT64)(((v->fbi.svert[0].t0 - v->fbi.svert[1].t0) * dx1 - (v->fbi.svert[0].t0 - v->fbi.svert[2].t0) * dx2) * tdiv);
+		v->tmu[0].dtdy = v->tmu[1].dtdy = (INT64)(((v->fbi.svert[0].t0 - v->fbi.svert[2].t0) * dy1 - (v->fbi.svert[0].t0 - v->fbi.svert[1].t0) * dy2) * tdiv);
+	}
+
+	/* set up W1 */
+	if (v->reg[sSetupMode].u & (1 << 6))
+	{
+		v->tmu[1].startw = (INT64)(v->fbi.svert[0].w1 * 65536.0f * 65536.0f);
+		v->tmu[1].dwdx = (INT64)(((v->fbi.svert[0].w1 - v->fbi.svert[1].w1) * dx1 - (v->fbi.svert[0].w1 - v->fbi.svert[2].w1) * dx2) * tdiv);
+		v->tmu[1].dwdy = (INT64)(((v->fbi.svert[0].w1 - v->fbi.svert[2].w1) * dy1 - (v->fbi.svert[0].w1 - v->fbi.svert[1].w1) * dy2) * tdiv);
+	}
+
+	/* set up S1,T1 */
+	if (v->reg[sSetupMode].u & (1 << 7))
+	{
+		v->tmu[1].starts = (INT64)(v->fbi.svert[0].s1 * 65536.0f * 65536.0f);
+		v->tmu[1].dsdx = (INT64)(((v->fbi.svert[0].s1 - v->fbi.svert[1].s1) * dx1 - (v->fbi.svert[0].s1 - v->fbi.svert[2].s1) * dx2) * tdiv);
+		v->tmu[1].dsdy = (INT64)(((v->fbi.svert[0].s1 - v->fbi.svert[2].s1) * dy1 - (v->fbi.svert[0].s1 - v->fbi.svert[1].s1) * dy2) * tdiv);
+		v->tmu[1].startt = (INT64)(v->fbi.svert[0].t1 * 65536.0f * 65536.0f);
+		v->tmu[1].dtdx = (INT64)(((v->fbi.svert[0].t1 - v->fbi.svert[1].t1) * dx1 - (v->fbi.svert[0].t1 - v->fbi.svert[2].t1) * dx2) * tdiv);
+		v->tmu[1].dtdy = (INT64)(((v->fbi.svert[0].t1 - v->fbi.svert[2].t1) * dy1 - (v->fbi.svert[0].t1 - v->fbi.svert[1].t1) * dy2) * tdiv);
+	}
+
+	/* draw the triangle */
+	triangle(v);
+}
+
+
+/*-------------------------------------------------
+    triangle_create_work_item - finish triangle
+    setup and create the work item
+-------------------------------------------------*/
+
+void triangle_create_work_item(voodoo_state *v, UINT16 *drawbuf, int texcount)
+{
+	poly_extra_data *extra = new poly_extra_data;
+	raster_info *info  = find_rasterizer(v, texcount);
+	poly_vertex vert[3];
+
+	/* fill in the vertex data */
+	vert[0].x = (float)v->fbi.ax * (1.0f / 16.0f);
+	vert[0].y = (float)v->fbi.ay * (1.0f / 16.0f);
+	vert[1].x = (float)v->fbi.bx * (1.0f / 16.0f);
+	vert[1].y = (float)v->fbi.by * (1.0f / 16.0f);
+	vert[2].x = (float)v->fbi.cx * (1.0f / 16.0f);
+	vert[2].y = (float)v->fbi.cy * (1.0f / 16.0f);
+
+	/* fill in the extra data */
+	extra->state = v;
+	extra->info = info;
+
+	/* fill in triangle parameters */
+	extra->ax = v->fbi.ax;
+	extra->ay = v->fbi.ay;
+	extra->startr = v->fbi.startr;
+	extra->startg = v->fbi.startg;
+	extra->startb = v->fbi.startb;
+	extra->starta = v->fbi.starta;
+	extra->startz = v->fbi.startz;
+	extra->startw = v->fbi.startw;
+	extra->drdx = v->fbi.drdx;
+	extra->dgdx = v->fbi.dgdx;
+	extra->dbdx = v->fbi.dbdx;
+	extra->dadx = v->fbi.dadx;
+	extra->dzdx = v->fbi.dzdx;
+	extra->dwdx = v->fbi.dwdx;
+	extra->drdy = v->fbi.drdy;
+	extra->dgdy = v->fbi.dgdy;
+	extra->dbdy = v->fbi.dbdy;
+	extra->dady = v->fbi.dady;
+	extra->dzdy = v->fbi.dzdy;
+	extra->dwdy = v->fbi.dwdy;
+
+	/* fill in texture 0 parameters */
+	if (texcount > 0)
+	{
+		extra->starts0 = v->tmu[0].starts;
+		extra->startt0 = v->tmu[0].startt;
+		extra->startw0 = v->tmu[0].startw;
+		extra->ds0dx = v->tmu[0].dsdx;
+		extra->dt0dx = v->tmu[0].dtdx;
+		extra->dw0dx = v->tmu[0].dwdx;
+		extra->ds0dy = v->tmu[0].dsdy;
+		extra->dt0dy = v->tmu[0].dtdy;
+		extra->dw0dy = v->tmu[0].dwdy;
+		extra->lodbase0 = prepare_tmu(&v->tmu[0]);
+
+		/* fill in texture 1 parameters */
+		if (texcount > 1)
+		{
+			extra->starts1 = v->tmu[1].starts;
+			extra->startt1 = v->tmu[1].startt;
+			extra->startw1 = v->tmu[1].startw;
+			extra->ds1dx = v->tmu[1].dsdx;
+			extra->dt1dx = v->tmu[1].dtdx;
+			extra->dw1dx = v->tmu[1].dwdx;
+			extra->ds1dy = v->tmu[1].dsdy;
+			extra->dt1dy = v->tmu[1].dtdy;
+			extra->dw1dy = v->tmu[1].dwdy;
+			extra->lodbase1 = prepare_tmu(&v->tmu[1]);
+		}
+	}
+
+	extra->texcount = texcount;
+	extra->r_fbzColorPath = v->reg[fbzColorPath].u;
+	extra->r_fbzMode = v->reg[fbzMode].u;
+	extra->r_alphaMode = v->reg[alphaMode].u;
+	extra->r_fogMode = v->reg[fogMode].u;
+	extra->r_textureMode0 = v->tmu[0].reg[textureMode].u;
+	if (v->tmu[1].ram != NULL) extra->r_textureMode1 = v->tmu[1].reg[textureMode].u;
+
+	info->polys++;
+
+	if (palette_changed && v->ogl && v->active) {
+		voodoo_ogl_invalidate_paltex();
+		palette_changed = false;
+	}
+
+	if (v->ogl && v->active) {
+		if (extra->info==NULL)  {
+			delete extra;
+			return;
+		}
+		voodoo_ogl_draw_triangle(extra);
+	} else {
+		poly_render_triangle(drawbuf, info->callback, &vert[0], &vert[1], &vert[2], extra);
+	}
+
+	delete extra;
+}
+
+/***************************************************************************
+    RASTERIZER MANAGEMENT
+***************************************************************************/
+
+/*-------------------------------------------------
+    add_rasterizer - add a rasterizer to our
+    hash table
+-------------------------------------------------*/
+
+static raster_info *add_rasterizer(voodoo_state *v, const raster_info *cinfo)
+{
+	raster_info *info = &v->rasterizer[v->next_rasterizer++];
+	int hash = compute_raster_hash(cinfo);
+
+	if (v->next_rasterizer > MAX_RASTERIZERS)
+		E_Exit("Out of space for new rasterizers!");
+
+	/* make a copy of the info */
+	*info = *cinfo;
+
+	/* fill in the data */
+	info->hits = 0;
+	info->polys = 0;
+
+	/* hook us into the hash table */
+	info->next = v->raster_hash[hash];
+	v->raster_hash[hash] = info;
+
+	if (LOG_RASTERIZERS)
+		LOG_MSG("Adding rasterizer @ %p : %08X %08X %08X %08X %08X %08X (hash=%d)\n",
+				info->callback,
+				info->eff_color_path, info->eff_alpha_mode, info->eff_fog_mode, info->eff_fbz_mode,
+				info->eff_tex_mode_0, info->eff_tex_mode_1, hash);
+
+	return info;
+}
+
+
+/*-------------------------------------------------
+    find_rasterizer - find a rasterizer that
+    matches  our current parameters and return
+    it, creating a new one if necessary
+-------------------------------------------------*/
+
+static raster_info *find_rasterizer(voodoo_state *v, int texcount)
+{
+	raster_info *info, *prev = NULL;
+	raster_info curinfo;
+	int hash;
+
+	/* build an info struct with all the parameters */
+	curinfo.eff_color_path = normalize_color_path(v->reg[fbzColorPath].u);
+	curinfo.eff_alpha_mode = normalize_alpha_mode(v->reg[alphaMode].u);
+	curinfo.eff_fog_mode = normalize_fog_mode(v->reg[fogMode].u);
+	curinfo.eff_fbz_mode = normalize_fbz_mode(v->reg[fbzMode].u);
+	curinfo.eff_tex_mode_0 = (texcount >= 1) ? normalize_tex_mode(v->tmu[0].reg[textureMode].u) : 0xffffffff;
+	curinfo.eff_tex_mode_1 = (texcount >= 2) ? normalize_tex_mode(v->tmu[1].reg[textureMode].u) : 0xffffffff;
+
+	/* compute the hash */
+	hash = compute_raster_hash(&curinfo);
+
+	/* find the appropriate hash entry */
+	for (info = v->raster_hash[hash]; info; prev = info, info = info->next)
+		if (info->eff_color_path == curinfo.eff_color_path &&
+			info->eff_alpha_mode == curinfo.eff_alpha_mode &&
+			info->eff_fog_mode == curinfo.eff_fog_mode &&
+			info->eff_fbz_mode == curinfo.eff_fbz_mode &&
+			info->eff_tex_mode_0 == curinfo.eff_tex_mode_0 &&
+			info->eff_tex_mode_1 == curinfo.eff_tex_mode_1)
+		{
+			/* got it, move us to the head of the list */
+			if (prev)
+			{
+				prev->next = info->next;
+				info->next = v->raster_hash[hash];
+				v->raster_hash[hash] = info;
+			}
+
+			/* return the result */
+			return info;
+		}
+
+	/* generate a new one using the generic entry */
+	curinfo.callback = (texcount == 0) ? raster_generic_0tmu : (texcount == 1) ? raster_generic_1tmu : raster_generic_2tmu;
+	curinfo.is_generic = true;
+	curinfo.display = 0;
+	curinfo.polys = 0;
+	curinfo.hits = 0;
+	curinfo.next = 0;
+	curinfo.shader_ready = false;
+
+	return add_rasterizer(v, &curinfo);
+}
+
+
+/***************************************************************************
+    GENERIC RASTERIZERS
+***************************************************************************/
+
+/*-------------------------------------------------
+    raster_fastfill - per-scanline
+    implementation of the 'fastfill' command
+-------------------------------------------------*/
+
+static void raster_fastfill(void *destbase, INT32 y, const poly_extent *extent, const void *extradata)
+{
+	const poly_extra_data *extra = (const poly_extra_data *)extradata;
+	voodoo_state *v = extra->state;
+	stats_block *stats = &v->thread_stats[0];
+	INT32 startx = extent->startx;
+	INT32 stopx = extent->stopx;
+	int scry, x;
+
+	/* determine the screen Y */
+	scry = y;
+	if (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))
+		scry = (v->fbi.yorigin - y) & 0x3ff;
+
+	/* fill this RGB row */
+	if (FBZMODE_RGB_BUFFER_MASK(v->reg[fbzMode].u))
+	{
+		const UINT16 *ditherow = &extra->dither[(y & 3) * 4];
+		UINT64 expanded = *(UINT64 *)ditherow;
+		UINT16 *dest = (UINT16 *)destbase + scry * v->fbi.rowpixels;
+
+		for (x = startx; x < stopx && (x & 3) != 0; x++)
+			dest[x] = ditherow[x & 3];
+		for ( ; x < (stopx & ~3); x += 4)
+			*(UINT64 *)&dest[x] = expanded;
+		for ( ; x < stopx; x++)
+			dest[x] = ditherow[x & 3];
+		stats->pixels_out += stopx - startx;
+	}
+
+	/* fill this dest buffer row */
+	if (FBZMODE_AUX_BUFFER_MASK(v->reg[fbzMode].u) && v->fbi.auxoffs != (UINT32)(~0))
+	{
+		UINT16 color = (UINT16)(v->reg[zaColor].u & 0xffff);
+		UINT64 expanded = ((UINT64)color << 48) | ((UINT64)color << 32) | (color << 16) | color;
+		UINT16 *dest = (UINT16 *)(v->fbi.ram + v->fbi.auxoffs) + scry * v->fbi.rowpixels;
+
+		if (v->fbi.auxoffs + 2 * (scry * v->fbi.rowpixels + stopx) >= v->fbi.mask) {
+			stopx = (v->fbi.mask - v->fbi.auxoffs) / 2 - scry * v->fbi.rowpixels;
+			if ((stopx < 0) || (stopx < startx)) return;
+		}
+
+		for (x = startx; x < stopx && (x & 3) != 0; x++)
+			dest[x] = color;
+		for ( ; x < (stopx & ~3); x += 4)
+			*(UINT64 *)&dest[x] = expanded;
+		for ( ; x < stopx; x++)
+			dest[x] = color;
+	}
+}
+
+
+void voodoo_vblank_flush(void) {
+	if (v->ogl)
+		voodoo_ogl_vblank_flush();
+	v->fbi.vblank_flush_pending=false;
+}
+
+void voodoo_set_window(void) {
+	if (v->ogl && v->active) {
+		voodoo_ogl_set_window(v);
+	}
+}
+
+void voodoo_leave(void) {
+	if (v->ogl) {
+		voodoo_ogl_leave(true);
+	}
+	v->active = false;
+}
+
+void voodoo_activate(void) {
+	v->active = true;
+
+	if (v->ogl) {
+		if (voodoo_ogl_init(v)) {
+			voodoo_ogl_clear();
+		} else {
+			v->ogl = false;
+			LOG_MSG("VOODOO: acceleration disabled");
+		}
+	}
+}
+
+void voodoo_update_dimensions(void) {
+	v->ogl_dimchange = false;
+
+	if (v->ogl) {
+		voodoo_ogl_update_dimensions();
+	}
+}
diff --git a/src/hardware/voodoo_emu.h b/src/hardware/voodoo_emu.h
new file mode 100644
index 000000000..f7c786025
--- /dev/null
+++ b/src/hardware/voodoo_emu.h
@@ -0,0 +1,54 @@
+ /*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef DOSBOX_VOODOO_EMU_H
+#define DOSBOX_VOODOO_EMU_H
+
+#include <stdlib.h>
+
+#include "dosbox.h"
+
+#include "voodoo_types.h"
+#include "voodoo_data.h"
+
+
+extern voodoo_state *v;
+
+void voodoo_w(UINT32 offset, UINT32 data, UINT32 mask);
+UINT32 voodoo_r(UINT32 offset);
+
+void voodoo_init(int type);
+void voodoo_shutdown();
+void voodoo_leave(void);
+
+void voodoo_activate(void);
+void voodoo_update_dimensions(void);
+void voodoo_set_window(void);
+
+void voodoo_vblank_flush(void);
+void voodoo_swap_buffers(voodoo_state *v);
+
+
+extern void Voodoo_UpdateScreenStart();
+extern void Voodoo_Output_Enable(bool enabled);
+extern bool Voodoo_GetRetrace();
+extern double Voodoo_GetVRetracePosition();
+extern double Voodoo_GetHRetracePosition();
+
+#endif
diff --git a/src/hardware/voodoo_interface.cpp b/src/hardware/voodoo_interface.cpp
new file mode 100644
index 000000000..296e7d84a
--- /dev/null
+++ b/src/hardware/voodoo_interface.cpp
@@ -0,0 +1,309 @@
+/*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <stdlib.h>
+#include <math.h>
+
+#include "dosbox.h"
+#include "cross.h"
+
+#include "vga.h"
+#include "pic.h"
+#include "paging.h"
+#include "render.h"
+
+#include "voodoo_interface.h"
+#include "voodoo_emu.h"
+
+
+static voodoo_draw vdraw;
+
+
+Voodoo_PageHandler * voodoo_pagehandler;
+
+
+Bitu Voodoo_PageHandler::readb(PhysPt addr) {
+//	LOG_MSG("voodoo readb at %x",addr);
+	return (Bitu)-1;
+}
+void Voodoo_PageHandler::writeb(PhysPt addr,Bitu val) {
+//	LOG_MSG("voodoo writeb at %x",addr);
+}
+
+Bitu Voodoo_PageHandler::readw(PhysPt addr) {
+	addr = PAGING_GetPhysicalAddress(addr);
+	if (addr&1) E_Exit("voodoo readw unaligned");
+	Bitu retval=voodoo_r((addr>>2)&0x3FFFFF);
+	if (addr&3)
+		retval >>= 16;
+	else
+		retval &= 0xffff;
+	return retval;
+}
+
+void Voodoo_PageHandler::writew(PhysPt addr,Bitu val) {
+	addr = PAGING_GetPhysicalAddress(addr);
+	if (addr&1) E_Exit("voodoo writew unaligned");
+	if (addr&3)
+		voodoo_w((addr>>2)&0x3FFFFF,val<<16,0xffff0000);
+	else
+		voodoo_w((addr>>2)&0x3FFFFF,val,0x0000ffff);
+}
+
+Bitu Voodoo_PageHandler::readd(PhysPt addr) {
+	addr = PAGING_GetPhysicalAddress(addr);
+	if (!(addr&3)) {
+		return voodoo_r((addr>>2)&0x3FFFFF);
+	} else {
+		if (!(addr&1)) {
+			Bitu low = voodoo_r((addr>>2)&0x3FFFFF);
+			Bitu high = voodoo_r(((addr>>2)+1)&0x3FFFFF);
+			return (low>>16) | (high<<16);
+		} else {
+			E_Exit("voodoo readd unaligned");
+		}
+	}
+	return 0xffffffff;
+}
+
+void Voodoo_PageHandler::writed(PhysPt addr,Bitu val) {
+	addr = PAGING_GetPhysicalAddress(addr);
+	if (!(addr&3)) {
+		voodoo_w((addr>>2)&0x3FFFFF,val,0xffffffff);
+	} else {
+		if (!(addr&1)) {
+			voodoo_w((addr>>2)&0x3FFFFF,val<<16,0xffff0000);
+			voodoo_w(((addr>>2)+1)&0x3FFFFF,val,0x0000ffff);
+		} else {
+			Bit32u val1 = voodoo_r((addr>>2)&0x3FFFFF);
+			Bit32u val2 = voodoo_r(((addr>>2)+1)&0x3FFFFF);
+			if ((addr&3)==1) {
+				val1 = (val1&0xffffff) | ((val&0xff)<<24);
+				val2 = (val2&0xff000000) | (val>>8);
+			} else if ((addr&3)==3) {
+				val1 = (val1&0xff) | ((val&0xffffff)<<8);
+				val2 = (val2&0xffffff00) | (val>>24);
+			} else E_Exit("???");
+			voodoo_w((addr>>2)&0x3FFFFF,val1,0xffffffff);
+			voodoo_w(((addr>>2)+1)&0x3FFFFF,val2,0xffffffff);
+		}
+	}
+}
+
+
+static void Voodoo_VerticalTimer(Bitu /*val*/) {
+	vdraw.frame_start = PIC_FullIndex();
+	PIC_AddEvent( Voodoo_VerticalTimer, vdraw.vfreq );
+
+	if (v->fbi.vblank_flush_pending) {
+		voodoo_vblank_flush();
+		if (GFX_LazyFullscreenRequested()) {
+			v->ogl_dimchange = true;
+		}
+	}
+
+	if (!v->ogl) {
+		if (!RENDER_StartUpdate()) return; // frameskip
+
+		rectangle r;
+		r.min_x = r.min_y = 0;
+		r.max_x = (int)v->fbi.width;
+		r.max_y = (int)v->fbi.height;
+
+		// draw all lines at once
+		Bit16u *viewbuf = (Bit16u *)(v->fbi.ram + v->fbi.rgboffs[v->fbi.frontbuf]);
+		for(Bitu i = 0; i < v->fbi.height; i++) {
+			RENDER_DrawLine((Bit8u*) viewbuf);
+			viewbuf += v->fbi.rowpixels;
+		}
+		RENDER_EndUpdate(false);
+	} else {
+		// ???
+		voodoo_set_window();
+	}
+}
+
+bool Voodoo_GetRetrace() {
+	// TODO proper implementation
+	double time_in_frame = PIC_FullIndex() - vdraw.frame_start;
+	double vfreq = vdraw.vfreq;
+	if (vfreq <= 0.0) return false;
+	if (v->clock_enabled && v->output_on) {
+		if ((time_in_frame/vfreq) > 0.95) return true;
+	} else if (v->output_on) {
+		double rtime = time_in_frame/vfreq;
+		rtime = fmod(rtime, 1.0);
+		if (rtime > 0.95) return true;
+	}
+	return false;
+}
+
+double Voodoo_GetVRetracePosition() {
+	// TODO proper implementation
+	double time_in_frame = PIC_FullIndex() - vdraw.frame_start;
+	double vfreq = vdraw.vfreq;
+	if (vfreq <= 0.0) return 0.0;
+	if (v->clock_enabled && v->output_on) {
+		return time_in_frame/vfreq;
+	} else if (v->output_on) {
+		double rtime = time_in_frame/vfreq;
+		rtime = fmod(rtime, 1.0);
+		return rtime;
+	}
+	return 0.0;
+}
+
+double Voodoo_GetHRetracePosition() {
+	// TODO proper implementation
+	double time_in_frame = PIC_FullIndex() - vdraw.frame_start;
+	double hfreq = vdraw.vfreq*100.0;
+	if (hfreq <= 0.0) return 0.0;
+	if (v->clock_enabled && v->output_on) {
+		return time_in_frame/hfreq;
+	} else if (v->output_on) {
+		double rtime = time_in_frame/hfreq;
+		rtime = fmod(rtime, 1.0);
+		return rtime;
+	}
+	return 0.0;
+}
+
+static void Voodoo_UpdateScreen(void) {
+	// abort drawing
+	RENDER_EndUpdate(true);
+
+	if ((!v->clock_enabled || !v->output_on) && vdraw.override_on) {
+		// switching off
+		PIC_RemoveEvents(Voodoo_VerticalTimer);
+		voodoo_leave();
+
+		VGA_SetOverride(false);
+		vdraw.override_on=false;
+	}
+
+	if ((v->clock_enabled && v->output_on) && !vdraw.override_on) {
+		// switching on
+		PIC_RemoveEvents(Voodoo_VerticalTimer); // shouldn't be needed
+
+		// TODO proper implementation of refresh rates and timings
+		vdraw.vfreq = 1000.0f/60.0f;
+		VGA_SetOverride(true);
+		vdraw.override_on=true;
+
+		vdraw.height=v->fbi.height;
+
+		voodoo_activate();
+
+		if (v->ogl) {
+			v->ogl_dimchange = false;
+		} else {
+			RENDER_SetSize(v->fbi.width, v->fbi.height, 16, vdraw.vfreq, 4.0/3.0, false, false);
+		}
+
+		Voodoo_VerticalTimer(0);
+	}
+
+	if ((v->clock_enabled && v->output_on) && v->ogl_dimchange) {
+		voodoo_update_dimensions();
+	}
+
+	vdraw.screen_update_requested = false;
+}
+
+static void Voodoo_CheckScreenUpdate(Bitu /*val*/) {
+	vdraw.screen_update_pending = false;
+	if (vdraw.screen_update_requested) {
+		vdraw.screen_update_pending = true;
+		Voodoo_UpdateScreen();
+		PIC_AddEvent(Voodoo_CheckScreenUpdate, 100.0f);
+	}
+}
+
+void Voodoo_UpdateScreenStart() {
+	vdraw.screen_update_requested = true;
+	if (!vdraw.screen_update_pending) {
+		vdraw.screen_update_pending = true;
+		PIC_AddEvent(Voodoo_CheckScreenUpdate, 0.0f);
+	}
+}
+
+void Voodoo_Output_Enable(bool enabled) {
+	if (v->output_on != enabled) {
+		v->output_on = enabled;
+		Voodoo_UpdateScreenStart();
+	}
+}
+
+
+void Voodoo_Initialize(Bits emulation_type, Bits card_type, bool max_voodoomem) {
+	if ((emulation_type <= 0) || (emulation_type > 2)) return;
+
+	int board = VOODOO_1;
+
+	switch (card_type) {
+		case 1:
+			if (max_voodoomem) board = VOODOO_1_DTMU;
+			else board = VOODOO_1;
+			break;
+		case 2:
+//			if (max_voodoomem) board = VOODOO_2_DTMU;
+//			else
+				board = VOODOO_2;
+			break;
+		default:
+			E_Exit("invalid voodoo card type specified");
+			break;
+	}
+
+	voodoo_pagehandler = new Voodoo_PageHandler(0);
+
+	v = new voodoo_state;
+	v->ogl = false;
+	if (emulation_type == 2) v->ogl = true;
+
+	vdraw.vfreq = 1000.0f/60.0f;
+
+	voodoo_init(board);
+}
+
+void Voodoo_Shut_Down() {
+	voodoo_shutdown();
+
+	if (v != NULL) {
+		delete v;
+		v = NULL;
+	}
+	if (voodoo_pagehandler != NULL) {
+		delete voodoo_pagehandler;
+		voodoo_pagehandler = NULL;
+	}
+}
+
+void Voodoo_PCI_InitEnable(Bitu val) {
+	v->pci.init_enable = val;
+}
+
+void Voodoo_PCI_Enable(bool enable) {
+	v->clock_enabled = enable;
+	Voodoo_UpdateScreenStart();
+}
+
+PageHandler* Voodoo_GetPageHandler() {
+	return voodoo_pagehandler;
+}
diff --git a/src/hardware/voodoo_interface.h b/src/hardware/voodoo_interface.h
new file mode 100644
index 000000000..8b43db779
--- /dev/null
+++ b/src/hardware/voodoo_interface.h
@@ -0,0 +1,65 @@
+ /*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef DOSBOX_VOODOO_IF_H
+#define DOSBOX_VOODOO_IF_H
+
+typedef struct vdraw {
+	Bitu width;
+	Bitu height;
+	Bitu bpp;
+	float vfreq;
+	double frame_start;
+	bool doublewidth;
+	bool doubleheight;
+
+	bool override_on;
+
+	bool screen_update_requested;
+	bool screen_update_pending;
+} voodoo_draw;
+
+
+class Voodoo_PageHandler : public PageHandler {
+public:
+	Voodoo_PageHandler(HostPt /*addr*/){
+		flags=PFLAG_NOCODE;
+	}
+
+	~Voodoo_PageHandler() {
+	}
+
+	Bitu readb(PhysPt addr);
+	void writeb(PhysPt addr,Bitu val);
+	Bitu readw(PhysPt addr);
+	void writew(PhysPt addr,Bitu val);
+	Bitu readd(PhysPt addr);
+	void writed(PhysPt addr,Bitu val);
+};
+
+
+void Voodoo_Initialize(Bits emulation_type, Bits card_type, bool max_voodoomem);
+void Voodoo_Shut_Down();
+
+void Voodoo_PCI_InitEnable(Bitu val);
+void Voodoo_PCI_Enable(bool enable);
+
+PageHandler* Voodoo_GetPageHandler();
+
+#endif
diff --git a/src/hardware/voodoo_opengl.cpp b/src/hardware/voodoo_opengl.cpp
new file mode 100644
index 000000000..8de61c002
--- /dev/null
+++ b/src/hardware/voodoo_opengl.cpp
@@ -0,0 +1,1905 @@
+/*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <stdlib.h>
+#include <math.h>
+#include <map>
+
+#include "dosbox.h"
+#include "video.h"
+
+#include "voodoo_emu.h"
+#include "voodoo_opengl.h"
+
+
+#if C_OPENGL
+
+#include "voodoo_def.h"
+
+
+SDL_Surface* ogl_surface = NULL;
+
+INT32 cached_line_front_y=-1;
+INT32 cached_line_front_width = -1;
+INT32 cached_line_front_length=-1;
+INT32 cached_line_front_pixels=-1;
+UINT32* cached_line_front_data=NULL;
+
+INT32 cached_line_back_y=-1;
+INT32 cached_line_back_width = -1;
+INT32 cached_line_back_length=-1;
+INT32 cached_line_back_pixels=-1;
+UINT32* cached_line_back_data=NULL;
+
+
+static UINT32 last_clear_color=0;
+
+static UINT32 last_width=0;
+static UINT32 last_height=0;
+static INT32 last_orientation=-1;
+
+
+static UINT32 ogl_texture_index = 1;
+
+
+/* texture cache buffer */
+UINT32 texrgb[256*256];
+
+
+/* texture address map */
+std::map <const UINT32, ogl_texmap> textures[2];
+
+
+static void ogl_get_depth(voodoo_state* VV, INT32 ITERZ, INT64 ITERW, INT32 *depthval, INT32 *out_wfloat)
+{
+	INT32 wfloat;
+	UINT32 FBZMODE = VV->reg[fbzMode].u;
+	UINT32 FBZCOLORPATH = VV->reg[fbzColorPath].u;
+
+	/* compute "floating point" W value (used for depth and fog) */
+	if ((ITERW) & LONGTYPE(0xffff00000000))
+		wfloat = 0x0000;
+	else
+	{
+		UINT32 temp = (UINT32)(ITERW);
+		if ((temp & 0xffff0000) == 0)
+			wfloat = 0xffff;
+		else
+		{
+			int exp = count_leading_zeros(temp);
+			wfloat = ((exp << 12) | ((~temp >> (19 - exp)) & 0xfff));
+			if (wfloat < 0xffff) wfloat++;
+		}
+	}
+
+	/* compute depth value (W or Z) for this pixel */
+	if (FBZMODE_WBUFFER_SELECT(FBZMODE) == 0)
+		CLAMPED_Z(ITERZ, FBZCOLORPATH, *depthval);
+	else if (FBZMODE_DEPTH_FLOAT_SELECT(FBZMODE) == 0)
+		*depthval = wfloat;
+	else
+	{
+		if ((ITERZ) & 0xf0000000)
+			*depthval = 0x0000;
+		else
+		{
+			UINT32 temp = (ITERZ) << 4;
+			if ((temp & 0xffff0000) == 0)
+				*depthval = 0xffff;
+			else
+			{
+				int exp = count_leading_zeros(temp);
+				*depthval = ((exp << 12) | ((~temp >> (19 - exp)) & 0xfff));
+				if (*depthval < 0xffff) (*depthval)++;
+			}
+		}
+	}
+
+	/* add the bias */
+	if (FBZMODE_ENABLE_DEPTH_BIAS(FBZMODE))
+	{
+		*depthval += (INT16)(VV)->reg[zaColor].u;
+		CLAMP(*depthval, 0, 0xffff);
+	}
+
+	*out_wfloat = wfloat;
+}
+
+void ogl_get_fog_blend(voodoo_state* v, INT32 wfloat, INT32 ITERZ, INT64 ITERW, INT32 *fogblend)
+{
+	UINT32 FOGMODE = v->reg[fogMode].u;
+	UINT32 FBZCP = v->reg[fbzColorPath].u;
+
+	*fogblend = 0;
+	if (FOGMODE_ENABLE_FOG(FOGMODE) && !FOGMODE_FOG_CONSTANT(FOGMODE))
+	{
+		/* fog blending mode */
+		switch (FOGMODE_FOG_ZALPHA(FOGMODE))
+		{
+		case 0:		/* fog table */
+			{
+				INT32 delta = v->fbi.fogdelta[wfloat >> 10];
+				INT32 deltaval;
+
+				/* perform the multiply against lower 8 bits of wfloat */
+				deltaval = (delta & v->fbi.fogdelta_mask) *
+					((wfloat >> 2) & 0xff);
+
+				/* fog zones allow for negating this value */
+				if (FOGMODE_FOG_ZONES(FOGMODE) && (delta & 2))
+					deltaval = -deltaval;
+				deltaval >>= 6;
+
+				/* apply dither */
+//				if (FOGMODE_FOG_DITHER(FOGMODE))
+//					deltaval += DITHER4[(XX) & 3];
+				deltaval >>= 4;
+
+				/* add to the blending factor */
+				*fogblend = v->fbi.fogblend[wfloat >> 10] + deltaval;
+				break;
+			}
+
+		case 1:		/* iterated A */
+//			fogblend = ITERAXXX.rgb.a;
+			break;
+
+		case 2:		/* iterated Z */
+			CLAMPED_Z((ITERZ), FBZCP, *fogblend);
+			*fogblend >>= 8;
+			break;
+
+		case 3:		/* iterated W - Voodoo 2 only */
+			CLAMPED_W((ITERW), FBZCP, *fogblend);
+			break;
+		}
+
+	}
+}
+
+void ogl_get_vertex_data(INT32 x, INT32 y, const void *extradata, ogl_vertex_data *vd) {
+	const poly_extra_data *extra = (const poly_extra_data *)extradata;
+	voodoo_state *v=(voodoo_state*)extra->state;
+	INT32 iterr, iterg, iterb, itera;
+	INT32 iterz;
+	INT64 iterw;
+	INT32 dx, dy;
+	INT32 d;
+
+	dx = x - extra->ax;
+	dy = y - extra->ay;
+	iterr = extra->startr + ((dy * extra->drdy)>>4) + ((dx * extra->drdx)>>4);
+	iterg = extra->startg + ((dy * extra->dgdy)>>4) + ((dx * extra->dgdx)>>4);
+	iterb = extra->startb + ((dy * extra->dbdy)>>4) + ((dx * extra->dbdx)>>4);
+	itera = extra->starta + ((dy * extra->dady)>>4) + ((dx * extra->dadx)>>4);
+	iterz = extra->startz + ((dy * extra->dzdy)>>4) + ((dx * extra->dzdx)>>4);
+	iterw = extra->startw + ((dy * extra->dwdy)>>4) + ((dx * extra->dwdx)>>4);
+
+	for (Bitu i=0; i<extra->texcount; i++) {
+		INT64 iters,itert,iterw;
+		UINT32 smax,tmax;
+		INT64 s, t;
+		INT32 lod=0;
+
+		UINT32 texmode=v->tmu[i].reg[textureMode].u;
+		UINT32 TEXMODE = texmode;
+		INT32 LODBASE = (i==0) ? extra->lodbase0 : extra->lodbase1;
+
+		INT64 oow;
+
+		UINT32 ilod = v->tmu[i].lodmin >> 8;
+		if (!((v->tmu[i].lodmask >> ilod) & 1))
+			ilod++;
+
+		smax = (v->tmu[i].wmask >> ilod) + 1;
+		tmax = (v->tmu[i].hmask >> ilod) + 1;
+
+		iterw = v->tmu[i].startw + ((dy * v->tmu[i].dwdy)>>4) + ((dx * v->tmu[i].dwdx)>>4);
+		iters = v->tmu[i].starts + ((dy * v->tmu[i].dsdy)>>4) + ((dx * v->tmu[i].dsdx)>>4);
+		itert = v->tmu[i].startt + ((dy * v->tmu[i].dtdy)>>4) + ((dx * v->tmu[i].dtdx)>>4);
+
+		/* determine the S/T/LOD values for this texture */
+		if (TEXMODE_ENABLE_PERSPECTIVE(texmode))
+		{
+			oow = fast_reciplog((iterw), &lod);
+			s = (oow * (iters)) >> 29;
+			t = (oow * (itert)) >> 29;
+			lod += LODBASE;
+		}
+		else
+		{
+			s = (iters) >> 14;
+			t = (itert) >> 14;
+			lod = LODBASE;
+		}
+
+		/* clamp the LOD */
+		lod += v->tmu[i].lodbias;
+//		if (TEXMODE_ENABLE_LOD_DITHER(TEXMODE))
+//			lod += DITHER4[(XX) & 3] << 4;
+		if (lod < v->tmu[i].lodmin)
+			lod = v->tmu[i].lodmin;
+		if (lod > v->tmu[i].lodmax)
+			lod = v->tmu[i].lodmax;
+
+		/* clamp W */
+		if (TEXMODE_CLAMP_NEG_W(texmode) && (iterw) < 0)
+			s = t = 0;
+
+		if (s != 0) vd->m[i].s = (float)((float)s/(float)(smax*(1<<(18+ilod))));
+		else vd->m[i].s = 0.0f;
+		if (t != 0) vd->m[i].t = (float)((float)t/(float)(tmax*(1<<(18+ilod))));
+		else vd->m[i].t = 0.0f;
+		if (iterw != 0) vd->m[i].w = (float)((float)iterw/(float)(0xffffff));
+		else vd->m[i].w = 0.0f;
+
+		vd->m[i].sw = vd->m[i].s * vd->m[i].w;
+		vd->m[i].tw = vd->m[i].t * vd->m[i].w;
+		vd->m[i].z  = 0.0f;
+
+		INT32 lodblend=0;
+
+		if ((TEXMODE_TC_MSELECT(TEXMODE)==4) || (TEXMODE_TCA_MSELECT(TEXMODE)==4))
+		{
+			if (v->tmu[i].detailbias <= lod)
+				lodblend = 0;
+			else
+			{
+				lodblend = (((v->tmu[i].detailbias - lod) << v->tmu[i].detailscale) >> 8);
+				if (lodblend > v->tmu[i].detailmax)
+					lodblend = v->tmu[i].detailmax;
+			}
+		} else if ((TEXMODE_TC_MSELECT(TEXMODE)==5) || (TEXMODE_TCA_MSELECT(TEXMODE)==5))
+			lodblend = lod & 0xff;
+
+		vd->m[i].lodblend = (float)lodblend/255.0f;
+	}
+
+	vd->r = (float)((float)iterr/(float)(1<<20));
+	vd->g = (float)((float)iterg/(float)(1<<20));
+	vd->b = (float)((float)iterb/(float)(1<<20));
+	vd->a = (float)((float)itera/(float)(1<<20));
+	vd->z = (float)((float)iterz/(float)(1<<20));
+	vd->w = (float)((float)iterw/(float)(0xffffff));
+
+	INT32 wfloat;
+	ogl_get_depth(v,iterz,iterw,&d,&wfloat);
+	vd->d = (float)((float)d/(float)(0xffff));
+
+	INT32 fogblend;
+	ogl_get_fog_blend(v,wfloat,iterz,iterw,&fogblend);
+	vd->fogblend = (float)fogblend/255.0f;
+
+//	vd->x = (float)x / (16.0f);
+//	vd->y = (float)y / (16.0f);
+
+	// OpenGL-correction for Blood/ShadowWarrior
+	vd->x = (((float)x) - (1.0f/16.0f)) / 16.0f;
+	vd->y = (((float)y) - (1.0f/16.0f)) / 16.0f;
+}
+
+static UINT32 crc_32_tab[] = { /* CRC polynomial 0xedb88320 */
+0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+UINT32 calculate_palsum(UINT32 tmunum) {
+	UINT32 csum = 0;
+	for (Bitu pct=0; pct<256; pct++) {
+		UINT32 pval = v->tmu[tmunum].palette[pct];
+		csum = crc_32_tab[(csum ^ pval) & 0xff] ^ (csum>>8);
+		csum = crc_32_tab[(csum ^ (pval>>8)) & 0xff] ^ (csum>>8);
+		csum = crc_32_tab[(csum ^ (pval>>16)) & 0xff] ^ (csum>>8);
+		csum = crc_32_tab[(csum ^ (pval>>24)) & 0xff] ^ (csum>>8);
+	}
+	return csum;
+}
+
+void ogl_cache_texture(const poly_extra_data *extra, ogl_texture_data *td) {
+	voodoo_state *v=(voodoo_state*)extra->state;
+	UINT32 texbase;
+
+	INT32 smax, tmax;
+	UINT32 *texrgbp;
+	GLuint texID;
+
+	UINT32 TEXMODE;
+
+	UINT32 num_tmus = 1;
+	if (v->tmu[1].ram != NULL) num_tmus++;
+
+	for (UINT32 j=0; j<num_tmus; j++) {
+		TEXMODE = j==0 ? extra->r_textureMode0 : extra->r_textureMode1;
+
+		UINT32 ilod = v->tmu[j].lodmin >> 8;
+		if (!((v->tmu[j].lodmask >> ilod) & 1))
+			ilod++;
+
+		texbase = v->tmu[j].lodoffset[ilod];
+
+		if ( extra->texcount && (extra->texcount >= j) && (v->tmu[j].lodmin < (8 << 8)) ) {
+			bool valid_texid = true;
+			std::map<const UINT32, ogl_texmap>::iterator t;
+			t = textures[j].find(texbase);
+			bool reuse_id = false;
+			if (t != textures[j].end())  {
+				if (t->second.valid_pal) {
+					texID = t->second.current_id;
+					if (!t->second.valid_data) {
+						valid_texid = false;
+						reuse_id = true;
+						t->second.valid_data = true;
+					}
+				} else {
+					UINT32 psum = calculate_palsum(j);
+					std::map<const UINT32, GLuint>::iterator u = t->second.ids->find(psum);
+					if (u != t->second.ids->end()) {
+						t->second.valid_pal = true;
+						t->second.current_id = u->second;
+						texID = u->second;
+					} else {
+						valid_texid = false;
+//						LOG_MSG("texture removed... size %d",t->second.ids->size());
+						if (t->second.ids->size() > 8) {
+							std::map<const UINT32, GLuint>::iterator u;
+							for (u=t->second.ids->begin(); u!=t->second.ids->end(); u++) {
+								glDeleteTextures(1,&u->second);
+							}
+							t->second.ids->clear();
+						}
+						t->second.valid_pal = true;
+					}
+				}
+			} else {
+				valid_texid = false;
+			}
+			if (!valid_texid) {
+				smax = (v->tmu[j].wmask >> ilod) + 1;
+				tmax = (v->tmu[j].hmask >> ilod) + 1;
+
+				UINT32 texboffset = texbase;
+				texrgbp = (UINT32 *)&texrgb[0];
+				memset(texrgbp,0,256*256*4);
+
+				if (!reuse_id) {
+					texID = ogl_texture_index++;
+					glGenTextures(1, &texID);
+				}
+
+				if (TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u) < 8) {
+					if (TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u) != 5) {
+						for (int i=0; i<(smax*tmax); i++) {
+							UINT8 *texptr8 = (UINT8 *)&v->tmu[j].ram[(texboffset) & v->tmu[j].mask];
+							UINT32 data = v->tmu[j].lookup[*texptr8];
+							*texrgbp = data;
+							texboffset++;
+							texrgbp++;
+						}
+					} else {
+						for (int i=0; i<(smax*tmax); i++) {
+							UINT8 *texptr8 = (UINT8 *)&v->tmu[j].ram[(texboffset) & v->tmu[j].mask];
+							UINT8 texel = *texptr8;
+							UINT32 data = v->tmu[j].lookup[texel];
+							*texrgbp = data;
+							texboffset++;
+							texrgbp++;
+						}
+					}
+				} else if (TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u) >= 10 && TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u) <= 12) {
+					for (int i=0; i<(smax*tmax); i++) {
+						UINT16 *texptr16 = (UINT16 *)&v->tmu[j].ram[(texboffset) & v->tmu[j].mask];
+						UINT32 data = v->tmu[j].lookup[*texptr16];
+						*texrgbp = data;
+						texboffset+=2;
+						texrgbp++;
+					}
+				} else if (TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u) != 14) {
+					for (int i=0; i<(smax*tmax); i++) {
+						UINT16 *texptr16 = (UINT16 *)&v->tmu[j].ram[(texboffset) & v->tmu[j].mask];
+						UINT32 data = (v->tmu[j].lookup[*texptr16 & 0xFF] & 0xFFFFFF) | ((*texptr16 & 0xff00) << 16);
+						*texrgbp = data;
+						texboffset+=2;
+						texrgbp++;
+					}
+				} else {
+					for (int i=0; i<(smax*tmax); i++) {
+						UINT16 *texptr16 = (UINT16 *)&v->tmu[j].ram[(texboffset) & v->tmu[j].mask];
+						UINT16 texel1 = *texptr16 & 0xFF;
+						UINT32 data = (v->tmu[j].lookup[texel1] & 0xFFFFFF) | ((*texptr16 & 0xff00) << 16);
+						*texrgbp = data;
+						texboffset+=2;
+						texrgbp++;
+					}
+				}
+
+				texrgbp = (UINT32 *)&texrgb[0];
+//				LOG_MSG("texid %d format %d -- %d x %d",
+//					texID,TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u),smax,tmax);
+
+				glBindTexture(GL_TEXTURE_2D, texID);
+				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_LINEAR);
+				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
+				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,TEXMODE_CLAMP_S(TEXMODE)?GL_CLAMP_TO_EDGE:GL_REPEAT);
+				glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,TEXMODE_CLAMP_T(TEXMODE)?GL_CLAMP_TO_EDGE:GL_REPEAT);
+				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, smax, tmax, 0, GL_BGRA_EXT, GL_UNSIGNED_INT_8_8_8_8_REV, texrgbp);
+				glGenerateMipmap(GL_TEXTURE_2D);
+				UINT32 palsum=0;
+				if ((TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u)==0x05) || (TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u)==0x0e)) {
+					palsum = calculate_palsum(j);
+					if (t == textures[j].end()) {
+						std::map<const UINT32, GLuint>* ids = new std::map<const UINT32, GLuint>();
+						(*ids)[palsum] = texID;
+						ogl_texmap tex = { true, true, TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u),
+											texID, ids };
+						textures[j][texbase] = tex;
+					} else {
+						(*textures[j][texbase].ids)[palsum] = texID;
+						textures[j][texbase].current_id = texID;
+					}
+				} else {
+					ogl_texmap tex = { true, true, TEXMODE_FORMAT(v->tmu[j].reg[textureMode].u),
+										texID, NULL };
+					textures[j][texbase] = tex;
+				}
+			}
+
+			td[j].texID = texID;
+			td[j].enable = true;
+		} else {
+			td[j].enable = false;
+		}
+	}
+}
+
+void voodoo_ogl_invalidate_paltex(void) {
+	std::map<const UINT32, ogl_texmap>::iterator t;
+	for (int j=0; j<2; j++) {
+		for (t=textures[j].begin(); t!=textures[j].end(); t++) {
+			if ((t->second.format == 0x05) || (t->second.format == 0x0e)) {
+				t->second.valid_pal = false;
+			}
+		}
+	}
+}
+
+
+GLhandleARB m_hProgramObject   = (GLhandleARB)NULL;
+
+
+void ogl_printInfoLog(GLhandleARB obj)
+{
+    int infologLength = 0;
+    int charsWritten  = 0;
+    char *infoLog;
+
+    glGetObjectParameterivARB(obj, GL_OBJECT_INFO_LOG_LENGTH_ARB, &infologLength);
+
+    if (infologLength > 0)
+    {
+		infoLog = (char *)malloc(infologLength);
+		glGetInfoLogARB(obj, infologLength, &charsWritten, infoLog);
+		LOG_MSG("%s\n",infoLog);
+		free(infoLog);
+    }
+}
+
+void ogl_sh_tex_combine(std::string *strFShader, const int TMU, const poly_extra_data *extra) {
+	voodoo_state *v=(voodoo_state*)extra->state;
+
+	UINT32 TEXMODE     = v->tmu[TMU].reg[textureMode].u;
+
+	if (!TEXMODE_TC_ZERO_OTHER(TEXMODE))
+		*strFShader += "  tt.rgb = cother.rgb;\n";
+	else
+		*strFShader += "  tt.rgb = vec3(0.0);\n";
+
+	if (!TEXMODE_TCA_ZERO_OTHER(TEXMODE))
+		*strFShader += "  tt.a = cother.a;\n";
+	else
+		*strFShader += "  tt.a = 0.0;\n";
+
+	if (TEXMODE_TC_SUB_CLOCAL(TEXMODE))
+		*strFShader += "  tt.rgb -= clocal.rgb;\n";
+	if (TEXMODE_TCA_SUB_CLOCAL(TEXMODE))
+		*strFShader += "  tt.a -= clocal.a;\n";
+
+	switch (TEXMODE_TC_MSELECT(TEXMODE))
+	{
+	default:
+	case 0:
+		*strFShader += "  blend.rgb = vec3(0.0);\n";
+		break;
+	case 1:
+		*strFShader += "  blend.rgb = clocal.rgb;\n";
+		break;
+	case 2:
+		*strFShader += "  blend.rgb = vec3(cother.a);\n";
+		break;
+	case 3:
+		*strFShader += "  blend.rgb = vec3(clocal.a);\n";
+		break;
+	case 4:
+		// detail //
+	case 5:
+		// LOD //
+		*strFShader += "  blend.rgb = vec3(f_lodblend";
+		*strFShader += TMU==0?"0":"1";
+		*strFShader += ");\n";
+		break;
+	}
+
+	switch (TEXMODE_TCA_MSELECT(TEXMODE))
+	{
+	default:
+	case 0:
+		*strFShader += "  blend.a = 0.0;\n";
+		break;
+	case 1:
+		*strFShader += "  blend.a = clocal.a;\n";
+		break;
+	case 2:
+		*strFShader += "  blend.a = cother.a;\n";
+		break;
+	case 3:
+		*strFShader += "  blend.a = clocal.a;\n";
+		break;
+	case 4:
+		// detail //
+	case 5:
+		// LOD //
+		*strFShader += "  blend.a = f_lodblend";
+		*strFShader += TMU==0?"0":"1";
+		*strFShader += ";\n";
+		break;
+	}
+
+	if (!TEXMODE_TC_REVERSE_BLEND(TEXMODE))
+		*strFShader += "  blend.rgb = vec3(1.0) - blend.rgb;\n";
+
+	if (!TEXMODE_TCA_REVERSE_BLEND(TEXMODE))
+		*strFShader += "  blend.a = 1.0 - blend.a;\n";
+
+	*strFShader += "  tt *= blend;\n";
+
+	switch (TEXMODE_TC_ADD_ACLOCAL(TEXMODE))
+	{
+	case 3:
+	case 0:
+		break;
+	case 1:
+		*strFShader += "  tt.rgb += clocal.rgb;\n";
+		break;
+	case 2:
+		*strFShader += "  tt.rgb += vec3(clocal.a);\n";
+		break;
+	}
+
+	if (TEXMODE_TCA_ADD_ACLOCAL(TEXMODE))
+		*strFShader += "  tt.a += clocal.a;\n";
+
+	*strFShader += "  clocal = tt;\n";
+
+	if (TEXMODE_TC_INVERT_OUTPUT(TEXMODE))
+		*strFShader += "  clocal.rgb = vec3(1.0)-clocal.rgb;\n";
+
+	if (TEXMODE_TCA_INVERT_OUTPUT(TEXMODE))
+		*strFShader += "  clocal.a = 1.0 - clocal.a;\n";
+
+}
+
+void ogl_sh_color_path(std::string *strFShader, const poly_extra_data *extra) {
+	voodoo_state *v=(voodoo_state*)extra->state;
+
+	UINT32 FBZCOLORPATH = v->reg[fbzColorPath].u;
+	UINT32 FBZMODE = v->reg[fbzMode].u;
+	UINT32 ALPHAMODE = v->reg[alphaMode].u;
+
+	switch (FBZCP_CC_RGBSELECT(FBZCOLORPATH))
+	{
+	case 0:
+		*strFShader += "  cother = gl_Color;\n";
+		break;
+	case 1:
+		*strFShader += "  cother = texel;\n";
+		break;
+	case 2:
+		*strFShader += "  cother = color1;\n";
+		break;
+	default:
+		*strFShader += "  cother = vec4(0.0);\n";
+	}
+
+	// TODO fix chroma key //
+	if (FBZMODE_ENABLE_CHROMAKEY(FBZMODE)) {
+//		if (!CHROMARANGE_ENABLE(v->reg[chromaRange].u))
+			*strFShader +=	"  if (distance (cother.rgb , chromaKey.rgb) < 0.0001) discard;\n";
+//		else {
+//			*strFShader +=	"  if ((cother.rgb >= (chromaKey.rgb-0.01)) && (cother.rgb <= (chromaRange.rgb+0.01))) discard;";
+//		}
+	}
+
+
+	switch (FBZCP_CC_ASELECT(FBZCOLORPATH))
+	{
+	case 0:
+		*strFShader += "  cother.a = gl_Color.a;\n";
+		break;
+	case 1:
+		*strFShader += "  cother.a = texel.a;\n";
+		break;
+	case 2:
+		*strFShader += "  cother.a = color1.a;\n";
+		break;
+	default:
+		*strFShader += "  cother.a = 0.0;\n";
+		break;
+	}
+
+	// TODO check alpha mask //
+//	if (FBZMODE_ENABLE_ALPHA_MASK(FBZMODE))
+//		*strFShader += "  if (cother.a > 0.0) discard;";
+
+	if (ALPHAMODE_ALPHATEST(ALPHAMODE))
+		switch (ALPHAMODE_ALPHAFUNCTION(ALPHAMODE)) {
+			case 0:
+				*strFShader += "  discard;\n";
+				break;
+			case 1:
+				*strFShader += "  if (cother.a >= alphaRef) discard;\n";
+				break;
+			case 2:
+//				*strFShader += "  if (cother.a != alphaRef) discard;\n";
+				*strFShader += "  if (distance(cother.a , alphaRef) > 0.0001) discard;\n";
+				break;
+			case 3:
+				*strFShader += "  if (cother.a >  alphaRef) discard;\n";
+				break;
+			case 4:
+				*strFShader += "  if (cother.a <= alphaRef) discard;\n";
+				break;
+			case 5:
+//				*strFShader += "  if (cother.a == alphaRef) discard;\n";
+				*strFShader += "  if (distance(cother.a , alphaRef) < 0.0001) discard;\n";
+				break;
+			case 6:
+				*strFShader += "  if (cother.a <  alphaRef) discard;\n";
+				break;
+			case 7:
+				break;
+	}
+
+	if (FBZCP_CC_LOCALSELECT_OVERRIDE(FBZCOLORPATH) == 0)
+	{
+		if (FBZCP_CC_LOCALSELECT(FBZCOLORPATH) == 0)
+			*strFShader += "  clocal = gl_Color;\n";
+		else
+			*strFShader += "  clocal = color0;\n";
+	}
+	else
+	{
+		*strFShader +=	"  if (texel.a < 0.5) {\n"
+							"    clocal = gl_Color;\n"
+						"  } else {\n"
+							"    clocal = color0;\n"
+						"  }\n";
+	}
+
+	switch (FBZCP_CCA_LOCALSELECT(FBZCOLORPATH))
+	{
+	default:
+	case 0:
+		*strFShader += "  clocal.a = gl_Color.a;\n";
+		break;
+	case 1:
+		*strFShader += "  clocal.a = color0.a;\n";
+		break;
+	case 2:
+		*strFShader += "  clocal.a = gl_Color.a;\n"; // TODO CLAMPED_Z
+		break;
+	case 3:
+		// voodoo2 only
+		break;
+	}
+
+	if (FBZCP_CC_ZERO_OTHER(FBZCOLORPATH) == 0)
+		*strFShader += "  tt.rgb = cother.rgb;\n";
+	else
+		*strFShader += "  tt.rgb = vec3(0.0);\n";
+
+	if (FBZCP_CCA_ZERO_OTHER(FBZCOLORPATH) == 0)
+		*strFShader += "  tt.a = cother.a;\n";
+	else
+		*strFShader += "  tt.a = 0.0;\n";
+
+	if (FBZCP_CC_SUB_CLOCAL(FBZCOLORPATH))
+		*strFShader += "  tt.rgb -= clocal.rgb;\n";
+
+	if (FBZCP_CCA_SUB_CLOCAL(FBZCOLORPATH))
+		*strFShader += "  tt.a -= clocal.a;\n";
+
+	switch (FBZCP_CC_MSELECT(FBZCOLORPATH))
+	{
+	default:
+	case 0:
+		*strFShader += "  blend.rgb = vec3(0.0);\n";
+		break;
+	case 1:
+		*strFShader += "  blend.rgb = clocal.rgb;\n";
+		break;
+	case 2:
+		*strFShader += "  blend.rgb = vec3(cother.a);\n";
+		break;
+	case 3:
+		*strFShader += "  blend.rgb = vec3(clocal.a);\n";
+		break;
+	case 4:
+		*strFShader += "  blend.rgb = vec3(texel.a);\n";
+		break;
+	case 5:
+		// voodoo2 only
+		*strFShader += "  blend.rgb = texel.rgb;\n";
+		break;
+	}
+
+	switch (FBZCP_CCA_MSELECT(FBZCOLORPATH))
+	{
+	default:
+	case 0:
+		*strFShader += "  blend.a = 0.0;\n";
+		break;
+	case 1:
+		*strFShader += "  blend.a = clocal.a;\n";
+		break;
+	case 2:
+		*strFShader += "  blend.a = cother.a;\n";
+		break;
+	case 3:
+		*strFShader += "  blend.a = clocal.a;\n";
+		break;
+	case 4:
+		*strFShader += "  blend.a = texel.a;\n";
+		break;
+	}
+
+	if (!FBZCP_CC_REVERSE_BLEND(FBZCOLORPATH))
+		*strFShader += "  blend.rgb = vec3(1.0) - blend.rgb;\n";
+
+	if (!FBZCP_CCA_REVERSE_BLEND(FBZCOLORPATH))
+		*strFShader += "  blend.a = 1.0 - blend.a;\n";
+
+	*strFShader += "  tt *= blend;\n";
+
+	switch (FBZCP_CC_ADD_ACLOCAL(FBZCOLORPATH))
+	{
+	case 3:
+	case 0:
+		break;
+	case 1:
+		*strFShader += "  tt.rgb += clocal.rgb;\n";
+		break;
+	case 2:
+		*strFShader += "  tt.rgb += vec3(clocal.a);\n";
+		break;
+	}
+
+	if (FBZCP_CCA_ADD_ACLOCAL(FBZCOLORPATH))
+		*strFShader += "  tt.a += clocal.a;\n";
+
+	// clamp ?? //
+
+	*strFShader += "  pixel = tt;\n";
+
+	if (FBZCP_CC_INVERT_OUTPUT(FBZCOLORPATH))
+		*strFShader += "  pixel.rgb = vec3(1.0) - tt.rgb;\n";
+
+	if (FBZCP_CCA_INVERT_OUTPUT(FBZCOLORPATH))
+		*strFShader += "  pixel.a = 1.0 - tt.a;\n";
+}
+
+void ogl_sh_fog(std::string *strFShader, const poly_extra_data *extra) {
+	voodoo_state *v=(voodoo_state*)extra->state;
+
+	UINT32 FOGMODE = v->reg[fogMode].u;
+
+	*strFShader += "  vec4 ff;\n";
+
+	/* constant fog bypasses everything else */
+	if (FOGMODE_FOG_CONSTANT(FOGMODE))
+		*strFShader += "  ff = fogColor;\n";
+
+	/* non-constant fog comes from several sources */
+	else {
+		/* if fog_add is zero, we start with the fog color */
+		if (FOGMODE_FOG_ADD(FOGMODE) == 0)
+			*strFShader += "  ff = fogColor;\n";
+		else
+			*strFShader += "  ff = vec4(0.0);\n";
+
+		/* if fog_mult is zero, we subtract the incoming color */
+		if (FOGMODE_FOG_MULT(FOGMODE) == 0)
+			*strFShader += "  ff -= pixel;\n";
+
+		*strFShader += "  float fogblend;\n";
+		/* fog blending mode */
+		switch (FOGMODE_FOG_ZALPHA(FOGMODE))
+		{
+			case 0:		/* fog table */
+				// blend factor calculated in ogl_get_fog_blend //
+				*strFShader += "  fogblend = f_fogblend;\n";
+				break;
+			case 1:		/* iterated A */
+				*strFShader += "  fogblend = gl_Color.a;\n";
+				break;
+			case 2:		/* iterated Z */
+				*strFShader += "  fogblend = f_fogblend;\n";
+				break;
+			case 3:		/* iterated W - Voodoo 2 only */
+				*strFShader += "  fogblend = f_fogblend;\n";
+				break;
+		}
+
+		/* perform the blend */
+		*strFShader += "  ff *= fogblend;\n";
+
+		/* if fog_mult is 0, we add this to the original color */
+		if (FOGMODE_FOG_MULT(FOGMODE) == 0)
+			*strFShader += "  pixel.rgb += ff.rgb;\n";
+		/* otherwise this just becomes the new color */
+		else
+			*strFShader += "  pixel.rgb = ff.rgb;\n";
+
+	}
+}
+
+
+void ogl_shaders(const poly_extra_data *extra) {
+	voodoo_state *v=(voodoo_state*)extra->state;
+
+	GLint res;
+	std::string strVShader, strFShader;
+
+	/* shaders extensions not loaded */
+	if (!glCreateShaderObjectARB) return;
+
+	UINT32 FBZMODE      = extra->r_fbzMode;
+	UINT32 FOGMODE      = extra->r_fogMode;
+	UINT32 texcount     = extra->texcount;
+
+	/* build a new shader program */
+	if (!extra->info->shader_ready) {
+
+		/* create vertex shader */
+		int fcount=0;
+		while (glGetError()!=0) {
+			fcount++;
+			if (fcount>1000) E_Exit("opengl error");
+		}
+
+		GLhandleARB m_hVertexShader = glCreateShaderObjectARB(GL_VERTEX_SHADER_ARB);
+
+		strVShader =
+			"attribute float v_fogblend;\n"
+			"varying   float f_fogblend;\n"
+			"attribute float v_lodblend0;\n"
+			"varying   float f_lodblend0;\n"
+			"attribute float v_lodblend1;\n"
+			"varying   float f_lodblend1;\n"
+			"\n"
+			"void main()"
+			"{\n"
+				"  gl_TexCoord[0] = gl_MultiTexCoord0;\n"
+				"  gl_TexCoord[1] = gl_MultiTexCoord1;\n"
+				"  gl_FrontColor = gl_Color;\n"
+				"  f_fogblend = v_fogblend;\n"
+				"  f_lodblend0 = v_lodblend0;\n"
+				"  f_lodblend1 = v_lodblend1;\n"
+				"  gl_Position = ftransform();\n"
+			"}\n";
+
+		const char *szVShader = strVShader.c_str();
+		glShaderSourceARB(m_hVertexShader, 1, &szVShader, NULL);
+		glCompileShaderARB(m_hVertexShader);
+		glGetObjectParameterivARB(m_hVertexShader, GL_OBJECT_COMPILE_STATUS_ARB, &res);
+		if(res == 0) {
+			char infobuffer[1000];
+			int infobufferlen = 0;
+			glGetInfoLogARB(m_hVertexShader, 999, &infobufferlen, infobuffer);
+			infobuffer[infobufferlen] = 0;
+			ogl_printInfoLog(m_hVertexShader);
+			E_Exit("ERROR: Error compiling vertex shader");
+			return;
+		}
+
+		/* create fragment shader */
+		GLhandleARB m_hFragmentShader = glCreateShaderObjectARB(GL_FRAGMENT_SHADER_ARB);
+		strFShader =
+			"varying float f_fogblend;\n"
+			"varying float f_lodblend0;\n"
+			"varying float f_lodblend1;\n"
+			"uniform sampler2D tex0;\n"
+			"uniform sampler2D tex1;\n"
+			"uniform vec4 color0;\n"
+			"uniform vec4 color1;\n"
+			"uniform vec4 chromaKey;\n"
+			"uniform vec4 chromaRange;\n"
+			"uniform float alphaRef;\n"
+			"uniform float zaColor;\n"
+			"uniform vec4 fogColor;\n"
+			"\n"
+			"void main()"
+			"{\n"
+				"  vec4 pixel  = vec4(0.0);\n"
+				"  vec4 texel  = vec4(1.0);\n"
+				"  vec4 clocal = vec4(1.0);\n"
+				"  vec4 cother = vec4(0.0);\n"
+				"  vec4 tt     = vec4(0.0);\n"
+				"  vec4 blend  = vec4(0.0);\n";
+
+				// TODO glsl depth test? //
+
+				if (texcount >= 2 && v->tmu[1].lodmin < (8 << 8))
+				{
+					strFShader += "  clocal = texture2DProj(tex1,gl_TexCoord[1]);\n";
+					ogl_sh_tex_combine(&strFShader, 1, extra);
+					strFShader += "  cother = clocal;\n";
+					strFShader += "  texel = clocal;\n";
+				}
+
+				if (texcount >= 1 && v->tmu[0].lodmin < (8 << 8))
+				{
+					strFShader += "  clocal = texture2DProj(tex0,gl_TexCoord[0]);\n";
+					ogl_sh_tex_combine(&strFShader, 0, extra);
+					strFShader += "  texel = clocal;\n";
+				}
+
+				// TODO Clamped ARGB //
+
+				ogl_sh_color_path(&strFShader, extra);
+
+				// fogging //
+				if (FOGMODE_ENABLE_FOG(FOGMODE))
+					ogl_sh_fog(&strFShader, extra);
+
+				strFShader += "  gl_FragColor = pixel;\n";
+
+				strFShader +=
+			"}";
+
+		const char *szFShader = strFShader.c_str();
+		glShaderSourceARB(m_hFragmentShader, 1, &szFShader, NULL);
+
+		glCompileShaderARB(m_hFragmentShader);
+		glGetObjectParameterivARB(m_hFragmentShader, GL_OBJECT_COMPILE_STATUS_ARB, &res);
+		if(res == 0) {
+			ogl_printInfoLog(m_hFragmentShader);
+			E_Exit("ERROR: Error compiling fragment shader");
+			return;
+		}
+
+
+		/* create program object */
+		m_hProgramObject = glCreateProgramObjectARB();
+
+		glAttachObjectARB(m_hProgramObject, m_hVertexShader);
+		glAttachObjectARB(m_hProgramObject, m_hFragmentShader);
+
+		glLinkProgramARB(m_hProgramObject);
+
+		glGetObjectParameterivARB(m_hProgramObject, GL_OBJECT_LINK_STATUS_ARB, &res);
+		if(res == 0) {
+			ogl_printInfoLog(m_hProgramObject);
+			E_Exit("ERROR: Error linking program");
+			return;
+		}
+
+		/* use this shader */
+		glUseProgramObjectARB(m_hProgramObject);
+		extra->info->so_shader_program=m_hProgramObject;
+		extra->info->so_vertex_shader=m_hVertexShader;
+		extra->info->so_fragment_shader=m_hFragmentShader;
+
+		extra->info->shader_ready=true;
+
+		GLenum glerr=glGetError();
+		if (glerr!=0) {
+			E_Exit("create shader start glError->%x",glerr);
+		}
+
+		int* locations=new int[12];
+		locations[0]=glGetUniformLocationARB(m_hProgramObject, "chromaKey");
+		locations[1]=glGetUniformLocationARB(m_hProgramObject, "chromaRange");
+		locations[2]=glGetUniformLocationARB(m_hProgramObject, "color0");
+		locations[3]=glGetUniformLocationARB(m_hProgramObject, "color1");
+		locations[4]=glGetUniformLocationARB(m_hProgramObject, "alphaRef");
+		locations[5]=glGetUniformLocationARB(m_hProgramObject, "zaColor");
+		locations[6]=glGetUniformLocationARB(m_hProgramObject, "tex0");
+		locations[7]=glGetUniformLocationARB(m_hProgramObject, "tex1");
+		locations[8]=glGetUniformLocationARB(m_hProgramObject, "fogColor");
+
+		locations[9] = glGetAttribLocationARB(m_hProgramObject, "v_fogblend");
+		locations[10] = glGetAttribLocationARB(m_hProgramObject, "v_lodblend0");
+		locations[11] = glGetAttribLocationARB(m_hProgramObject, "v_lodblend1");
+		extra->info->shader_ulocations=locations;
+	} else {
+		/* use existing shader program */
+		if (m_hProgramObject != extra->info->so_shader_program) {
+			glUseProgramObjectARB(extra->info->so_shader_program);
+			m_hProgramObject = extra->info->so_shader_program;
+		}
+	}
+
+	if (extra->info->shader_ulocations[0]>=0) glUniform4fARB(extra->info->shader_ulocations[0], v->reg[chromaKey].rgb.r/255.0f, v->reg[chromaKey].rgb.g/255.0f, v->reg[chromaKey].rgb.b/255.0f,0);
+	if (extra->info->shader_ulocations[1]>=0) glUniform4fARB(extra->info->shader_ulocations[1], v->reg[chromaRange].rgb.r/255.0f, v->reg[chromaRange].rgb.g/255.0f, v->reg[chromaRange].rgb.b/255.0f,0);
+	if (extra->info->shader_ulocations[2]>=0) glUniform4fARB(extra->info->shader_ulocations[2], v->reg[color0].rgb.r/255.0f, v->reg[color0].rgb.g/255.0f, v->reg[color0].rgb.b/255.0f, v->reg[color0].rgb.a/255.0f);
+	if (extra->info->shader_ulocations[3]>=0) glUniform4fARB(extra->info->shader_ulocations[3], v->reg[color1].rgb.r/255.0f, v->reg[color1].rgb.g/255.0f, v->reg[color1].rgb.b/255.0f, v->reg[color1].rgb.a/255.0f);
+	if (extra->info->shader_ulocations[4]>=0) glUniform1fARB(extra->info->shader_ulocations[4], v->reg[alphaMode].rgb.a/255.0f);
+	if (extra->info->shader_ulocations[5]>=0) glUniform1fARB(extra->info->shader_ulocations[5], (float)((UINT16)v->reg[zaColor].u)/65535.0f);
+	if (extra->info->shader_ulocations[8]>=0) glUniform4fARB(extra->info->shader_ulocations[8], v->reg[fogColor].rgb.r/255.0f, v->reg[fogColor].rgb.g/255.0f, v->reg[fogColor].rgb.b/255.0f,1.0f);
+
+}
+
+
+void voodoo_ogl_draw_triangle(poly_extra_data *extra) {
+	voodoo_state *v=extra->state;
+	ogl_texture_data td[2];
+	ogl_vertex_data vd[3];
+
+	VOGL_ClearBeginMode();
+
+	td[0].enable = false;
+	td[1].enable = false;
+
+	UINT32 ALPHAMODE = extra->r_alphaMode;
+	UINT32 FBZMODE   = extra->r_fbzMode;
+
+
+	ogl_get_vertex_data(v->fbi.ax, v->fbi.ay, (void*)extra, &vd[0]);
+	ogl_get_vertex_data(v->fbi.bx, v->fbi.by, (void*)extra, &vd[1]);
+	ogl_get_vertex_data(v->fbi.cx, v->fbi.cy, (void*)extra, &vd[2]);
+
+
+	if (FBZMODE_DEPTH_SOURCE_COMPARE(FBZMODE) && VOGL_CheckFeature(VOGL_HAS_STENCIL_BUFFER)) {
+		if (m_hProgramObject != 0) {
+			glUseProgramObjectARB(0);
+			m_hProgramObject = 0;
+		}
+
+		if ((FBZMODE_ENABLE_DEPTHBUF(FBZMODE)) && (FBZMODE_ENABLE_ALPHA_PLANES(FBZMODE) == 0)) {
+			VOGL_SetDepthMode(1,FBZMODE_DEPTH_FUNCTION(FBZMODE));
+		} else {
+			VOGL_SetDepthMode(0,0);
+		}
+
+		VOGL_SetDepthMaskMode(false);
+		VOGL_SetColorMaskMode(false, false);
+
+		VOGL_SetAlphaMode(0, 0,0,0,0);
+
+		if (FBZMODE_DRAW_BUFFER(v->reg[fbzMode].u)==0) {
+			VOGL_SetDrawMode(true);
+		} else {
+			VOGL_SetDrawMode(false);
+		}
+
+		glEnable(GL_STENCIL_TEST);
+		glClear(GL_STENCIL_BUFFER_BIT);
+		glStencilFunc(GL_ALWAYS, 1, 1);
+		glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);
+
+		glBegin(GL_TRIANGLES);
+
+		glColor4f(1.0f, 1.0f, 1.0f, 1.0f);
+
+		float depth = (float)(v->reg[zaColor].u&0xffff)/(float)0xffff;
+		for (int i=0;i<3;i++)
+			glVertex3f(vd[i].x, vd[i].y, depth);
+
+		glEnd();
+	}
+
+	ogl_cache_texture(extra,td);
+	ogl_shaders(extra);
+
+	if (extra->texcount > 0) {
+		for (int t=0; t<2; t++)
+		if ( td[t].enable ) {
+			UINT32 TEXMODE = v->tmu[t].reg[textureMode].u;
+			glActiveTextureARB(GL_TEXTURE0_ARB+t);
+			glBindTexture (GL_TEXTURE_2D, td[t].texID);
+			if (!extra->info->shader_ready) {
+				glEnable (GL_TEXTURE_2D);
+				// TODO proper fixed-pipeline combiners
+				glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
+			} else {
+				if (extra->info->shader_ulocations[6+t] >= 0)
+					glUniform1iARB(extra->info->shader_ulocations[6+t],t);
+			}
+
+			GLint minFilter;
+			minFilter = GL_NEAREST + TEXMODE_MINIFICATION_FILTER(TEXMODE);
+			if (v->tmu[t].lodmin != v->tmu[t].lodmax)
+				minFilter += 0x0100 + TEXMODE_TRILINEAR(TEXMODE)*2;
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,minFilter);
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST+TEXMODE_MAGNIFICATION_FILTER(TEXMODE));
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S,TEXMODE_CLAMP_S(TEXMODE)?GL_CLAMP_TO_EDGE:GL_REPEAT);
+			glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T,TEXMODE_CLAMP_T(TEXMODE)?GL_CLAMP_TO_EDGE:GL_REPEAT);
+		}
+	}
+
+	if (FBZMODE_DEPTH_SOURCE_COMPARE(FBZMODE) && VOGL_CheckFeature(VOGL_HAS_STENCIL_BUFFER)) {
+		glStencilFunc(GL_EQUAL, 1, 1);
+		glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);
+		if (FBZMODE_ENABLE_DEPTHBUF(FBZMODE)) {
+			VOGL_SetDepthMode(1,GL_ALWAYS-GL_NEVER);
+		} else {
+			VOGL_SetDepthMode(0,0);
+		}
+	} else {
+		if (FBZMODE_ENABLE_ALPHA_PLANES(FBZMODE) == 0) {
+			if (FBZMODE_ENABLE_DEPTHBUF(FBZMODE)) {
+				VOGL_SetDepthMode(1,FBZMODE_DEPTH_FUNCTION(FBZMODE));
+			} else {
+				if (FBZMODE_AUX_BUFFER_MASK(FBZMODE) > 0) {
+					VOGL_SetDepthMode(1,GL_ALWAYS-GL_NEVER);
+				} else {
+					VOGL_SetDepthMode(0,0);
+				}
+			}
+		} else {
+			VOGL_SetDepthMode(1,GL_ALWAYS-GL_NEVER);
+		}
+	}
+
+	bool color_mask = (FBZMODE_RGB_BUFFER_MASK(FBZMODE) > 0);
+
+	if (FBZMODE_AUX_BUFFER_MASK(FBZMODE) > 0) {
+		VOGL_SetDepthMaskMode(FBZMODE_ENABLE_ALPHA_PLANES(FBZMODE) == 0);
+		VOGL_SetColorMaskMode(color_mask, true);
+	} else {
+		VOGL_SetDepthMaskMode(false);
+		VOGL_SetColorMaskMode(color_mask, false);
+	}
+
+	if (ALPHAMODE_ALPHABLEND(ALPHAMODE)) {
+		VOGL_SetAlphaMode(1, ogl_sfactor[ALPHAMODE_SRCRGBBLEND(ALPHAMODE)], ogl_dfactor[ALPHAMODE_DSTRGBBLEND(ALPHAMODE)],
+			(ALPHAMODE_SRCALPHABLEND(ALPHAMODE)==4)?GL_ONE:GL_ZERO,
+			(ALPHAMODE_DSTALPHABLEND(ALPHAMODE)==4)?GL_ONE:GL_ZERO);
+	} else {
+		VOGL_SetAlphaMode(0, 0,0,0,0);
+	}
+
+	if (FBZMODE_DRAW_BUFFER(v->reg[fbzMode].u)==0) {
+		VOGL_SetDrawMode(true);
+		v->fbi.vblank_flush_pending=true;
+		cached_line_front_y=-1;
+	} else {
+		VOGL_SetDrawMode(false);
+		cached_line_back_y=-1;
+	}
+
+
+	glBegin(GL_TRIANGLES);
+
+	for (int i=0;i<3;i++) {
+		glColor4fv(&vd[i].r);
+
+		for (int t=0;t<2;t++)
+			if (td[t].enable) {
+				glMultiTexCoord4fvARB(GL_TEXTURE0_ARB+t,&vd[i].m[t].sw);
+				if (extra->info->shader_ulocations[10+t] >= 0)
+					glVertexAttrib1fARB(extra->info->shader_ulocations[10+t],vd[i].m[t].lodblend);
+			}
+
+		if (extra->info->shader_ulocations[9] >= 0)
+			glVertexAttrib1fARB(extra->info->shader_ulocations[9],vd[i].fogblend);
+
+		glVertex3fv(&vd[i].x);
+	}
+
+	glEnd();
+
+	if (FBZMODE_DEPTH_SOURCE_COMPARE(FBZMODE) && VOGL_CheckFeature(VOGL_HAS_STENCIL_BUFFER)) {
+		glDisable(GL_STENCIL_TEST);
+	}
+
+	if (!extra->info->shader_ready) {
+		glDisable (GL_TEXTURE_2D);
+	}
+}
+
+
+void voodoo_ogl_swap_buffer() {
+	if (GFX_LazyFullscreenRequested()) {
+		v->ogl_dimchange = true;
+	}
+
+	VOGL_ClearBeginMode();
+
+	SDL_GL_SwapBuffers();
+
+	cached_line_front_y=-1;
+	cached_line_back_y=-1;
+}
+
+
+void voodoo_ogl_texture_clear(UINT32 texbase, int TMU) {
+	std::map<const UINT32, ogl_texmap>::iterator t;
+	t=textures[TMU].find(texbase);
+	if (t != textures[TMU].end()) {
+		VOGL_ClearBeginMode();
+		if (t->second.ids != NULL) {
+			std::map<const UINT32, GLuint>::iterator u;
+			for (u=t->second.ids->begin(); u!=t->second.ids->end(); u++) {
+				glDeleteTextures(1,&u->second);
+			}
+			delete t->second.ids;
+			t->second.ids = NULL;
+		} else {
+			t->second.valid_data = false;
+		}
+		textures[TMU].erase(t);
+	}
+}
+
+void voodoo_ogl_draw_pixel(int x, int y, bool has_rgb, bool has_alpha, int r, int g, int b, int a) {
+	if (m_hProgramObject != 0) {
+		glUseProgramObjectARB(0);
+		m_hProgramObject = 0;
+	}
+
+	if (LFBMODE_WRITE_BUFFER_SELECT(v->reg[lfbMode].u)==0) {
+		VOGL_SetDrawMode(true);
+		v->fbi.vblank_flush_pending=true;
+	} else {
+		VOGL_SetDrawMode(false);
+	}
+
+	VOGL_SetDepthMode(0,0);
+
+	VOGL_SetDepthMaskMode(false);
+	VOGL_SetColorMaskMode(has_rgb, has_alpha);
+
+	VOGL_SetAlphaMode(0, 0,0,0,0);
+
+	VOGL_BeginMode(GL_POINTS);
+	glColor4ub((GLubyte)(r&0xff), (GLubyte)(g&0xff), (GLubyte)(b&0xff), (GLubyte)(a&0xff));
+	glVertex2i(x, y);
+}
+
+void voodoo_ogl_draw_z(int x, int y, int z) {
+//	VOGL_ClearBeginMode();
+
+	if (m_hProgramObject != 0) {
+		glUseProgramObjectARB(0);
+		m_hProgramObject = 0;
+	}
+
+	if (LFBMODE_WRITE_BUFFER_SELECT(v->reg[lfbMode].u)==0) {
+		VOGL_SetDrawMode(true);
+		v->fbi.vblank_flush_pending=true;
+	} else {
+		VOGL_SetDrawMode(false);
+	}
+
+	VOGL_SetDepthMode(1,GL_ALWAYS-GL_NEVER);
+
+	VOGL_SetDepthMaskMode(true);
+	VOGL_SetColorMaskMode(false, false);
+
+	VOGL_SetAlphaMode(0, 0,0,0,0);
+
+	VOGL_BeginMode(GL_POINTS);
+//	glBegin(GL_POINTS);
+	glVertex3i(x, y, z);	// z adjustment??
+//	glEnd();
+}
+
+void voodoo_ogl_draw_pixel_pipeline(int x, int y, int r, int g, int b) {
+//	VOGL_ClearBeginMode();
+
+	// TODO redo everything //
+	if (m_hProgramObject != 0) {
+		glUseProgramObjectARB(0);
+		m_hProgramObject = 0;
+	}
+
+	if (LFBMODE_WRITE_BUFFER_SELECT(v->reg[lfbMode].u)==0) {
+		VOGL_SetDrawMode(true);
+		v->fbi.vblank_flush_pending=true;
+	} else {
+		VOGL_SetDrawMode(false);
+	}
+
+	VOGL_SetDepthMode(0,0);
+
+	VOGL_SetDepthMaskMode(false);
+	if (FBZMODE_AUX_BUFFER_MASK(v->reg[fbzMode].u) > 0) {
+		VOGL_SetColorMaskMode(true, true);
+	} else {
+		VOGL_SetColorMaskMode(true, false);
+	}
+
+	if (ALPHAMODE_ALPHABLEND(v->reg[alphaMode].u)) {
+		VOGL_SetAlphaMode(1, ogl_sfactor[ALPHAMODE_SRCRGBBLEND(v->reg[alphaMode].u)], ogl_dfactor[ALPHAMODE_DSTRGBBLEND(v->reg[alphaMode].u)],
+			(ALPHAMODE_SRCALPHABLEND(v->reg[alphaMode].u)==4)?GL_ONE:GL_ZERO,
+			(ALPHAMODE_DSTALPHABLEND(v->reg[alphaMode].u)==4)?GL_ONE:GL_ZERO);
+	} else {
+		VOGL_SetAlphaMode(0, 0,0,0,0);
+	}
+
+	VOGL_BeginMode(GL_POINTS);
+//	glBegin(GL_POINTS);
+//	glColor3f((float)r/255.0f, (float)g/255.0f, (float)b/255.0f);
+	glColor3ub((GLubyte)(r&0xff), (GLubyte)(g&0xff), (GLubyte)(b&0xff));
+	glVertex2f((float)x, (float)y);
+//	glEnd();
+}
+
+
+void voodoo_ogl_clip_window(voodoo_state *v) {
+/*	VOGL_ClearBeginMode();
+
+	int sx = (v->reg[clipLeftRight].u >> 16) & 0x3ff;
+	int ex = (v->reg[clipLeftRight].u >> 0) & 0x3ff;
+	int sy = (v->reg[clipLowYHighY].u >> 16) & 0x3ff;
+	int ey = (v->reg[clipLowYHighY].u >> 0) & 0x3ff;
+
+	if (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u)) {
+		sy = (v->fbi.yorigin+1 - sy) & 0x3ff;
+		ey = (v->fbi.yorigin+1 - ey) & 0x3ff;
+	}
+
+	if ((sx>0) || (sy>0) || (ex<v->fbi.width) || (ey<v->fbi.height))
+	{
+		glEnable(GL_SCISSOR_TEST);
+		glScissor(sx,sy,ex-sx,ey-sy);
+	} else {
+		glScissor(0,0,v->fbi.width,v->fbi.height);
+		glDisable(GL_SCISSOR_TEST);
+	} */
+}
+
+
+void voodoo_ogl_fastfill(void) {
+	VOGL_ClearBeginMode();
+
+	VOGL_SetDepthMaskMode(true);
+
+	int sx = (v->reg[clipLeftRight].u >> 16) & 0x3ff;
+	int ex = (v->reg[clipLeftRight].u >> 0) & 0x3ff;
+	int sy = (v->reg[clipLowYHighY].u >> 16) & 0x3ff;
+	int ey = (v->reg[clipLowYHighY].u >> 0) & 0x3ff;
+
+//	if (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))
+	{
+		int tmp = (v->fbi.yorigin+1 - ey) & 0x3ff;
+		ey = (v->fbi.yorigin+1 - sy) & 0x3ff;
+		sy = tmp;
+	}
+
+	bool scissors_needed = true;
+	if ((sx == 0) && (sy == 0)) {
+		if ((ex == v->fbi.width) && (ey == v->fbi.height)) scissors_needed = false;
+	}
+
+	if (scissors_needed) {
+		glEnable(GL_SCISSOR_TEST);
+		glScissor(sx,sy,ex-sx,ey-sy);
+	}
+
+
+	Bit32u clear_mask=0;
+	if (FBZMODE_RGB_BUFFER_MASK(v->reg[fbzMode].u)) {
+		clear_mask|=GL_COLOR_BUFFER_BIT;
+
+//		if (FBZMODE_AUX_BUFFER_MASK(v->reg[fbzMode].u) && v->fbi.auxoffs != (UINT32)(~0)) ...
+		VOGL_SetColorMaskMode(true, true);
+
+		if (last_clear_color!=v->reg[color1].u) {
+			glClearColor((float)v->reg[color1].rgb.r/255.0f,
+				(float)v->reg[color1].rgb.g/255.0f,
+				(float)v->reg[color1].rgb.b/255.0f,
+				(float)v->reg[color1].rgb.a/255.0f);
+			last_clear_color=v->reg[color1].u;
+		}
+		if (FBZMODE_DRAW_BUFFER(v->reg[fbzMode].u)==0) {
+			VOGL_SetDrawMode(true);
+			v->fbi.vblank_flush_pending=true;
+			cached_line_front_y=-1;
+		} else {
+			VOGL_SetDrawMode(false);
+			cached_line_back_y=-1;
+		}
+	}
+	if (FBZMODE_AUX_BUFFER_MASK(v->reg[fbzMode].u) && v->fbi.auxoffs != (UINT32)(~0)) {
+//	if (FBZMODE_ENABLE_DEPTHBUF(v->reg[fbzMode].u)) {
+		clear_mask|=GL_DEPTH_BUFFER_BIT;
+		glClearDepth((float)((UINT16)v->reg[zaColor].u)/65535.0f);
+	}
+
+	if (clear_mask) glClear(clear_mask);
+
+	if (scissors_needed) {
+		glScissor(0,0,v->fbi.width,v->fbi.height);
+		glDisable(GL_SCISSOR_TEST);
+	}
+}
+
+void voodoo_ogl_clear(void) {
+	VOGL_ClearBeginMode();
+
+	VOGL_SetDrawMode(false);
+
+	glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
+	last_clear_color = 0;
+	glClearDepth(1.0f);
+	glClearStencil(0);
+
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+	voodoo_ogl_swap_buffer();
+	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
+}
+
+
+UINT32 voodoo_ogl_read_pixel(int x, int y) {
+	UINT32 data[2];
+	if ((x < 0) || (y < 0) || (x >= (INT32)v->fbi.width) || (y >= (INT32)v->fbi.height)) return 0xffffffff;
+
+	UINT32 mode=GL_RGBA;
+	switch (LFBMODE_READ_BUFFER_SELECT(v->reg[lfbMode].u)) {
+		case 0:			/* front buffer */
+			VOGL_SetReadMode(true);
+			if ((cached_line_front_y != y) || (x+1 >= cached_line_front_width)) {
+				if (cached_line_front_length<(INT32)v->fbi.width) {
+					if (cached_line_front_data!=NULL) free(cached_line_front_data);
+					size_t span_length=((v->fbi.width+64)&(~15));
+					cached_line_front_data=(UINT32*)malloc(sizeof(UINT32)*span_length);
+					cached_line_front_length=(INT32)span_length;
+				}
+				glReadPixels(0,v->fbi.height-y,v->fbi.width,1,mode,GL_UNSIGNED_BYTE,cached_line_front_data);
+				cached_line_front_y=y;
+				cached_line_front_width = (INT32)v->fbi.width;
+			}
+			data[0]=cached_line_front_data[x];
+			data[1]=cached_line_front_data[x+1];
+			break;
+		case 1:			/* back buffer */
+			VOGL_SetReadMode(false);
+			if ((cached_line_back_y != y) || (x+1 >= cached_line_back_width)) {
+				if (cached_line_back_length<(INT32)v->fbi.width) {
+					if (cached_line_back_data!=NULL) free(cached_line_back_data);
+					size_t span_length=((v->fbi.width+64)&(~15));
+					cached_line_back_data=(UINT32*)malloc(sizeof(UINT32)*span_length);
+					cached_line_back_length=(INT32)span_length;
+				}
+				glReadPixels(0,v->fbi.height-y,v->fbi.width,1,mode,GL_UNSIGNED_BYTE,cached_line_back_data);
+				cached_line_back_y=y;
+				cached_line_back_width = (INT32)v->fbi.width;
+			}
+			data[0]=cached_line_back_data[x];
+			data[1]=cached_line_back_data[x+1];
+			break;
+		case 2:			/* aux buffer */
+			mode=GL_DEPTH_COMPONENT;
+			VOGL_SetReadMode(false);
+			glReadPixels(x,v->fbi.height-y,2,1,mode,GL_UNSIGNED_INT,&data);
+			return ((data[0]>>16)&0xffff) | (data[1] & 0xffff0000);
+		default:
+			E_Exit("read from invalid buf %x",LFBMODE_READ_BUFFER_SELECT(v->reg[lfbMode].u));
+			break;
+	}
+
+	return ((RGB_BLUE(data[0])>>3)<<11) | ((RGB_GREEN(data[0])>>2)<<5) | (RGB_RED(data[0])>>3) |
+			((RGB_BLUE(data[1])>>3)<<27) | ((RGB_GREEN(data[1])>>2)<<21) | ((RGB_RED(data[1])>>3)<<16);
+}
+
+
+void voodoo_ogl_vblank_flush(void) {
+	VOGL_ClearBeginMode();
+	glFlush();
+}
+
+
+void voodoo_ogl_set_window(voodoo_state *v) {
+	VOGL_ClearBeginMode();
+
+	// 	matrix mode GL_PROJECTION assumed
+	bool size_changed=false;
+	if ((v->fbi.width!=last_width) || (v->fbi.height!=last_height)) size_changed=true;
+	if (size_changed || (last_orientation != (INT32)FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))) {
+		glLoadIdentity( );
+		if (FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))
+			glOrtho( 0, v->fbi.width, 0, v->fbi.height, 0.0f, -1.0f );
+		else
+			glOrtho( 0, v->fbi.width, v->fbi.height, 0, 0.0f, -1.0f );
+		if (last_orientation != (INT32)FBZMODE_Y_ORIGIN(v->reg[fbzMode].u))
+			last_orientation = FBZMODE_Y_ORIGIN(v->reg[fbzMode].u);
+	}
+	if (size_changed) {
+		glViewport( 0, 0, v->fbi.width, v->fbi.height );
+		last_width = v->fbi.width;
+		last_height = v->fbi.height;
+	}
+}
+
+static void voodoo_ogl_init_attribute(bool *has_alpha, bool *has_stencil)
+{
+	SDL_GL_SetAttribute(SDL_GL_RED_SIZE, 8);
+	SDL_GL_SetAttribute(SDL_GL_GREEN_SIZE, 8);
+	SDL_GL_SetAttribute(SDL_GL_BLUE_SIZE, 8);
+
+        *has_alpha = true;
+	SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 8);
+
+        *has_stencil = true;
+	SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 8);
+
+	SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
+	SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
+#if defined (WIN32) && SDL_VERSION_ATLEAST(1, 2, 11)
+	SDL_GL_SetAttribute( SDL_GL_SWAP_CONTROL, 0 );
+#endif
+#if !defined (WIN32) && SDL_VERSION_ATLEAST(1, 2, 10)
+	// broken on windows (longstanding SDL bug), may help other platforms to force hardware acceleration
+	SDL_GL_SetAttribute( SDL_GL_ACCELERATED_VISUAL, 1 );
+#endif
+
+}
+
+SDL_Surface* SDL_SetVideoMode_Wrap(int width,int height,int bpp,Bit32u flags);
+void voodoo_ogl_reset_videomode(void) {
+	last_clear_color=0;
+
+	last_width=0;
+	last_height=0;
+	last_orientation=-1;
+
+	VOGL_Reset();
+
+	GFX_TearDown();
+
+	bool full_sdl_restart = true;	// make dependent on surface=opengl
+
+	bool has_alpha, has_stencil;
+
+        voodoo_ogl_init_attribute(&has_alpha, &has_stencil);
+
+	if (ogl_surface != NULL) {
+		SDL_FreeSurface(ogl_surface);
+		ogl_surface = NULL;
+	}
+
+	Uint32 sdl_flags = SDL_OPENGL;
+
+	if (GFX_LazyFullscreenRequested()) GFX_SwitchFullscreenNoReset();
+
+	if (GFX_IsFullscreen()) {
+		sdl_flags |= SDL_FULLSCREEN;
+	} else {
+		if (full_sdl_restart) {
+			SDL_QuitSubSystem(SDL_INIT_VIDEO);
+			SDL_InitSubSystem(SDL_INIT_VIDEO);
+                        voodoo_ogl_init_attribute(&has_alpha, &has_stencil);
+		}
+		ogl_surface = SDL_SetVideoMode_Wrap(v->fbi.width, v->fbi.height, 32, sdl_flags);
+	}
+
+	if ((ogl_surface != NULL) && (sdl_flags & SDL_FULLSCREEN)) SDL_Delay(500);
+
+	if (ogl_surface == NULL) {
+		if (full_sdl_restart) {
+			SDL_QuitSubSystem(SDL_INIT_VIDEO);
+			SDL_InitSubSystem(SDL_INIT_VIDEO);
+                        voodoo_ogl_init_attribute(&has_alpha, &has_stencil);
+			ogl_surface = SDL_SetVideoMode_Wrap(v->fbi.width, v->fbi.height, 32, sdl_flags);
+		}
+		if (ogl_surface == NULL) {
+			has_alpha = false;
+			SDL_GL_SetAttribute(SDL_GL_ALPHA_SIZE, 0);
+			if (SDL_SetVideoMode_Wrap(v->fbi.width, v->fbi.height, 32, sdl_flags) == 0) {
+				has_stencil = false;
+				SDL_GL_SetAttribute(SDL_GL_STENCIL_SIZE, 0);
+				if (SDL_SetVideoMode_Wrap(v->fbi.width, v->fbi.height, 32, sdl_flags) == 0) {
+					if (sdl_flags & SDL_FULLSCREEN) {
+						sdl_flags &= ~(SDL_FULLSCREEN);
+						if (SDL_SetVideoMode_Wrap(v->fbi.width, v->fbi.height, 32, sdl_flags) == 0) {
+							E_Exit("VOODOO: opengl init error");
+						}
+					} else {
+						E_Exit("VOODOO: opengl init error");
+					}
+				}
+				LOG_MSG("VOODOO: Graphics mode does not support Stencil/Alpha channels");
+			} else {
+				LOG_MSG("VOODOO: Graphics mode does not support Alpha channel");
+			}
+		}
+	}
+
+	GFX_SwitchLazyFullscreen(true);
+
+	GFX_UpdateSDLCaptureState();
+
+	int value;
+
+	bool few_colors = false;
+	if (SDL_GL_GetAttribute(SDL_GL_RED_SIZE, &value) == 0) {
+		if (value < 8) few_colors = true;
+	}
+	if (SDL_GL_GetAttribute(SDL_GL_GREEN_SIZE, &value) == 0) {
+		if (value < 8) few_colors = true;
+	}
+	if (SDL_GL_GetAttribute(SDL_GL_BLUE_SIZE, &value) == 0) {
+		if (value < 8) few_colors = true;
+	}
+	if (few_colors) LOG_MSG("opengl: warning: graphics mode with insufficient color depth");
+
+	if (SDL_GL_GetAttribute(SDL_GL_DEPTH_SIZE, &value) == 0) {
+		if (value < 24) LOG_MSG("opengl: warning: depth buffer with insufficient resolution");
+	}
+
+	if (SDL_GL_GetAttribute(SDL_GL_STENCIL_SIZE, &value) == 0) {
+		if (value < 1) has_stencil = false;
+	}
+	if (SDL_GL_GetAttribute(SDL_GL_ALPHA_SIZE, &value) == 0) {
+		if (value < 8) has_alpha = false;
+	}
+
+	if (has_stencil) VOGL_FlagFeature(VOGL_HAS_STENCIL_BUFFER);
+	if (has_alpha) VOGL_FlagFeature(VOGL_HAS_ALPHA_PLANE);
+
+	GLint depth_csize;
+	glGetIntegerv(GL_DEPTH_BITS, &depth_csize);
+	if (depth_csize == 24) {
+	} else if (depth_csize == 16) {
+	} else if (depth_csize < 16) {
+		LOG_MSG("VOODOO: OpenGL: invalid depth size %d",depth_csize);
+	}
+
+	LOG_MSG("VOODOO: OpenGL: mode set, resolution %d:%d %s", v->fbi.width, v->fbi.height, (sdl_flags & SDL_FULLSCREEN) ? "(fullscreen)" : "");
+}
+
+void voodoo_ogl_update_dimensions(void) {
+	voodoo_ogl_leave(false);
+
+	voodoo_ogl_reset_videomode();
+
+	glMatrixMode( GL_PROJECTION );
+	voodoo_ogl_set_window(v);
+
+	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
+
+	glMatrixMode( GL_MODELVIEW );
+	glLoadIdentity( );
+	glMatrixMode( GL_PROJECTION );
+}
+
+bool voodoo_ogl_init(voodoo_state *v) {
+
+	voodoo_ogl_reset_videomode();
+
+	if (!VOGL_Initialize()) {
+		VOGL_Reset();
+		// reset video mode etc.
+		return false;
+	}
+
+/*	std::string features = "";
+	if (VOGL_CheckFeature(VOGL_HAS_SHADERS)) features += " shader";
+	if (VOGL_CheckFeature(VOGL_HAS_ALPHA_PLANE)) features += " alpha-plane";
+	if (VOGL_CheckFeature(VOGL_HAS_STENCIL_BUFFER)) features += " stencil-buffer";
+
+	if (features == "") features = " none";
+
+	LOG_MSG("VOODOO: OpenGL: features enabled:%s",features.c_str()); */
+
+
+	glMatrixMode( GL_PROJECTION );
+	voodoo_ogl_set_window(v);
+
+	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
+
+	glMatrixMode( GL_MODELVIEW );
+	glLoadIdentity( );
+	glMatrixMode( GL_PROJECTION );
+
+	return true;
+}
+
+void voodoo_ogl_leave(bool leavemode) {
+	VOGL_ClearBeginMode();
+
+	std::map<const UINT32, ogl_texmap>::iterator t;
+	for (int j=0; j<2; j++) {
+		for (t=textures[j].begin(); t!=textures[j].end(); t++) {
+			if (t->second.ids != NULL) {
+				std::map<const UINT32, GLuint>::iterator u;
+				for (u=t->second.ids->begin(); u!=t->second.ids->end(); u++) {
+					glDeleteTextures(1,&u->second);
+				}
+				if (!t->second.ids->empty()) t->second.ids->clear();
+				delete t->second.ids;
+				t->second.ids = NULL;
+			} else {
+				glDeleteTextures(1,&t->second.current_id);
+			}
+		}
+		if (!textures[j].empty()) textures[j].clear();
+	}
+
+
+	if (m_hProgramObject != 0) {
+		glUseProgramObjectARB(0);
+		m_hProgramObject = 0;
+	}
+
+	for (int hct=0; hct<RASTER_HASH_SIZE; hct++) {
+		raster_info *info = v->raster_hash[hct];
+		for (; info; info = info->next) {
+			if (info->shader_ready) {
+				delete[] info->shader_ulocations;
+				info->shader_ulocations=NULL;
+
+				if (info->so_shader_program > 0) {
+					if (info->so_vertex_shader >= 0) glDetachObjectARB(info->so_shader_program, info->so_vertex_shader);
+					if (info->so_fragment_shader >= 0) glDetachObjectARB(info->so_shader_program, info->so_fragment_shader);
+					if (info->so_vertex_shader >= 0) glDeleteObjectARB(info->so_vertex_shader);
+					if (info->so_fragment_shader >= 0) glDeleteObjectARB(info->so_fragment_shader);
+					glDeleteProgram(info->so_shader_program);
+				}
+
+				info->shader_ready=false;
+			}
+		}
+	}
+
+
+	cached_line_front_y=-1;
+	cached_line_back_y=-1;
+
+	if (leavemode) {
+		LOG_MSG("VOODOO: OpenGL: quit");
+
+		GFX_SwitchLazyFullscreen(false);
+		if (ogl_surface != NULL) {
+			SDL_FreeSurface(ogl_surface);
+			ogl_surface = NULL;
+		}
+		GFX_RestoreMode();
+	}
+}
+
+void voodoo_ogl_shutdown(voodoo_state *v) {
+	// TODO revert to previous video mode //
+
+	voodoo_ogl_leave(false);
+
+	v->active = false;
+}
+
+#else
+
+
+bool voodoo_ogl_init(voodoo_state *v) {
+	return false;
+}
+
+void voodoo_ogl_leave(void) {
+}
+
+void voodoo_ogl_shutdown(voodoo_state *v) {
+}
+
+void voodoo_ogl_set_window(voodoo_state *v) {
+	E_Exit("invalid call to voodoo_ogl_set_window");
+}
+
+void voodoo_ogl_swap_buffer(void) {
+	E_Exit("invalid call to voodoo_ogl_swap_buffer");
+}
+
+void voodoo_ogl_vblank_flush(void) {
+	E_Exit("invalid call to voodoo_ogl_vblank_flush");
+}
+
+void voodoo_ogl_clear(void) {
+	E_Exit("invalid call to voodoo_ogl_clear");
+}
+
+void voodoo_ogl_fastfill(void) {
+	E_Exit("invalid call to voodoo_ogl_fastfill");
+}
+
+void voodoo_ogl_clip_window(voodoo_state *v) {
+	E_Exit("invalid call to voodoo_ogl_clip_window");
+}
+
+void voodoo_ogl_texture_clear(UINT32 texbase, int TMU) {
+	E_Exit("invalid call to voodoo_ogl_texture_clear");
+}
+
+void voodoo_ogl_invalidate_paltex(void) {
+	E_Exit("invalid call to voodoo_ogl_invalidate_paltex");
+}
+
+void voodoo_ogl_draw_pixel(int x, int y, bool has_rgb, bool has_alpha, int r, int g, int b, int a) {
+	E_Exit("invalid call to voodoo_ogl_draw_pixel");
+}
+
+void voodoo_ogl_draw_z(int x, int y, int z1, int z2) {
+	E_Exit("invalid call to voodoo_ogl_draw_z");
+}
+
+void voodoo_ogl_draw_pixel_pipeline(int x, int y, int r, int g, int b) {
+	E_Exit("invalid call to voodoo_ogl_draw_pixel_pipeline");
+}
+
+UINT32 voodoo_ogl_read_pixel(int x, int y) {
+	E_Exit("invalid call to voodoo_ogl_read_pixel");
+
+	return 0;
+}
+
+void voodoo_ogl_draw_triangle(poly_extra_data *extra) {
+	E_Exit("invalid call to voodoo_ogl_draw_triangle");
+}
+
+
+#endif
diff --git a/src/hardware/voodoo_opengl.h b/src/hardware/voodoo_opengl.h
new file mode 100644
index 000000000..3657f66e6
--- /dev/null
+++ b/src/hardware/voodoo_opengl.h
@@ -0,0 +1,93 @@
+ /*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef DOSBOX_VOODOO_OPENGL_H
+#define DOSBOX_VOODOO_OPENGL_H
+
+#include <stdlib.h>
+#include <math.h>
+#include <map>
+
+#include "dosbox.h"
+#include "cross.h"
+
+
+#if C_OPENGL
+
+#include "voodoo_vogl.h"
+#include "voodoo_types.h"
+
+
+/* texture data */
+struct ogl_texture_data {
+	GLuint texID;
+	bool enable;
+};
+
+/* triangle vertex map data */
+struct ogl_vertex_map_data {
+	float sw,tw,z,w;
+	float s,t;
+	float lodblend;
+};
+
+/* triangle vertex data */
+struct ogl_vertex_data {
+	float x,y,d,w,z;
+	float r,g,b,a;
+	float fogblend;
+	ogl_vertex_map_data m[2];
+};
+
+struct ogl_texmap {
+	bool valid_data;
+	bool valid_pal;
+	UINT32 format;
+	UINT32 current_id;
+
+	std::map<const UINT32, GLuint>* ids;
+};
+
+#endif
+
+
+bool voodoo_ogl_init(voodoo_state *v);
+void voodoo_ogl_leave(bool leavemode);
+void voodoo_ogl_shutdown(voodoo_state *v);
+
+void voodoo_ogl_set_window(voodoo_state *v);
+void voodoo_ogl_swap_buffer(void);
+void voodoo_ogl_vblank_flush(void);
+
+void voodoo_ogl_update_dimensions(void);
+void voodoo_ogl_clear(void);
+void voodoo_ogl_fastfill(void);
+
+void voodoo_ogl_clip_window(voodoo_state *v);
+void voodoo_ogl_texture_clear(UINT32 texbase, int TMU);
+void voodoo_ogl_invalidate_paltex(void);
+
+void voodoo_ogl_draw_pixel(int x, int y, bool has_rgb, bool has_alpha, int r, int g, int b, int a);
+void voodoo_ogl_draw_z(int x, int y, int z);
+void voodoo_ogl_draw_pixel_pipeline(int x, int y, int r, int g, int b);
+UINT32 voodoo_ogl_read_pixel(int x, int y);
+
+void voodoo_ogl_draw_triangle(poly_extra_data *extra);
+
+#endif
diff --git a/src/hardware/voodoo_types.h b/src/hardware/voodoo_types.h
new file mode 100644
index 000000000..1f7344ae5
--- /dev/null
+++ b/src/hardware/voodoo_types.h
@@ -0,0 +1,371 @@
+/***************************************************************************/
+/*        Portion of this software comes with the following license:       */
+/***************************************************************************/
+/*
+
+    Copyright Aaron Giles
+    All rights reserved.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+        * Redistributions of source code must retain the above copyright
+          notice, this list of conditions and the following disclaimer.
+        * Redistributions in binary form must reproduce the above copyright
+          notice, this list of conditions and the following disclaimer in
+          the documentation and/or other materials provided with the
+          distribution.
+        * Neither the name 'MAME' nor the names of its contributors may be
+          used to endorse or promote products derived from this software
+          without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY AARON GILES ''AS IS'' AND ANY EXPRESS OR
+    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+    DISCLAIMED. IN NO EVENT SHALL AARON GILES BE LIABLE FOR ANY DIRECT,
+    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+    (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+    SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+    STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+    IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+    POSSIBILITY OF SUCH DAMAGE.
+
+***************************************************************************/
+
+
+#ifndef DOSBOX_VOODOO_TYPES_H
+#define DOSBOX_VOODOO_TYPES_H
+
+#include "cross.h"
+
+/***************************************************************************
+    TYPE DEFINITIONS
+***************************************************************************/
+
+
+/* 8-bit values */
+typedef Bit8u						UINT8;
+typedef Bit8s 						INT8;
+
+/* 16-bit values */
+typedef Bit16u						UINT16;
+typedef Bit16s						INT16;
+
+#ifndef _WINDOWS_
+#define TRUE	1
+#define FALSE	0
+/* 32-bit values */
+typedef Bit32u						UINT32;
+typedef Bit32s						INT32;
+
+/* 64-bit values */
+typedef Bit64u						UINT64;
+typedef Bit64s						INT64;
+#endif
+
+/* core components of the attotime structure */
+typedef INT64 attoseconds_t;
+typedef INT32 seconds_t;
+
+
+/* the attotime structure itself */
+typedef struct _attotime attotime;
+struct _attotime
+{
+	seconds_t		seconds;
+	attoseconds_t	attoseconds;
+};
+
+#define ATTOSECONDS_PER_SECOND_SQRT		((attoseconds_t)1000000000)
+#define ATTOSECONDS_PER_SECOND			(ATTOSECONDS_PER_SECOND_SQRT * ATTOSECONDS_PER_SECOND_SQRT)
+
+/* convert between hertz (as a double) and attoseconds */
+#define ATTOSECONDS_TO_HZ(x)			((double)ATTOSECONDS_PER_SECOND / (double)(x))
+#define HZ_TO_ATTOSECONDS(x)			((attoseconds_t)(ATTOSECONDS_PER_SECOND / (x)))
+
+
+/* poly_param_extent describes information for a single parameter in an extent */
+typedef struct _poly_param_extent poly_param_extent;
+struct _poly_param_extent
+{
+	float		start;						/* parameter value at starting X,Y */
+	float		dpdx;						/* dp/dx relative to starting X */
+};
+
+
+#define MAX_VERTEX_PARAMS					6
+
+/* poly_extent describes start/end points for a scanline, along with per-scanline parameters */
+typedef struct _poly_extent poly_extent;
+struct _poly_extent
+{
+	INT32		startx;						/* starting X coordinate (inclusive) */
+	INT32		stopx;						/* ending X coordinate (exclusive) */
+	poly_param_extent param[MAX_VERTEX_PARAMS];	/* starting and dx values for each parameter */
+};
+
+
+/* an rgb_t is a single combined R,G,B (and optionally alpha) value */
+typedef UINT32 rgb_t;
+
+/* an rgb15_t is a single combined 15-bit R,G,B value */
+typedef UINT16 rgb15_t;
+
+/* macros to assemble rgb_t values */
+#define MAKE_ARGB(a,r,g,b)	((((rgb_t)(a) & 0xff) << 24) | (((rgb_t)(r) & 0xff) << 16) | (((rgb_t)(g) & 0xff) << 8) | ((rgb_t)(b) & 0xff))
+#define MAKE_RGB(r,g,b)		(MAKE_ARGB(255,r,g,b))
+
+/* macros to extract components from rgb_t values */
+#define RGB_ALPHA(rgb)		(((rgb) >> 24) & 0xff)
+#define RGB_RED(rgb)		(((rgb) >> 16) & 0xff)
+#define RGB_GREEN(rgb)		(((rgb) >> 8) & 0xff)
+#define RGB_BLUE(rgb)		((rgb) & 0xff)
+
+/* common colors */
+#define RGB_BLACK			(MAKE_ARGB(255,0,0,0))
+#define RGB_WHITE			(MAKE_ARGB(255,255,255,255))
+
+/***************************************************************************
+    INLINE FUNCTIONS
+***************************************************************************/
+
+/*-------------------------------------------------
+    rgb_to_rgb15 - convert an RGB triplet to
+    a 15-bit OSD-specified RGB value
+-------------------------------------------------*/
+
+INLINE rgb15_t rgb_to_rgb15(rgb_t rgb)
+{
+	return ((RGB_RED(rgb) >> 3) << 10) | ((RGB_GREEN(rgb) >> 3) << 5) | ((RGB_BLUE(rgb) >> 3) << 0);
+}
+
+
+/*-------------------------------------------------
+    rgb_clamp - clamp an RGB component to 0-255
+-------------------------------------------------*/
+
+INLINE UINT8 rgb_clamp(INT32 value)
+{
+	if (value < 0)
+		return 0;
+	if (value > 255)
+		return 255;
+	return (UINT8)value;
+}
+
+
+/*-------------------------------------------------
+    pal1bit - convert a 1-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal1bit(UINT8 bits)
+{
+	return (bits & 1) ? 0xff : 0x00;
+}
+
+
+/*-------------------------------------------------
+    pal2bit - convert a 2-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal2bit(UINT8 bits)
+{
+	bits &= 3;
+	return (bits << 6) | (bits << 4) | (bits << 2) | bits;
+}
+
+
+/*-------------------------------------------------
+    pal3bit - convert a 3-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal3bit(UINT8 bits)
+{
+	bits &= 7;
+	return (bits << 5) | (bits << 2) | (bits >> 1);
+}
+
+
+/*-------------------------------------------------
+    pal4bit - convert a 4-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal4bit(UINT8 bits)
+{
+	bits &= 0xf;
+	return (bits << 4) | bits;
+}
+
+
+/*-------------------------------------------------
+    pal5bit - convert a 5-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal5bit(UINT8 bits)
+{
+	bits &= 0x1f;
+	return (bits << 3) | (bits >> 2);
+}
+
+
+/*-------------------------------------------------
+    pal6bit - convert a 6-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal6bit(UINT8 bits)
+{
+	bits &= 0x3f;
+	return (bits << 2) | (bits >> 4);
+}
+
+
+/*-------------------------------------------------
+    pal7bit - convert a 7-bit value to 8 bits
+-------------------------------------------------*/
+
+INLINE UINT8 pal7bit(UINT8 bits)
+{
+	bits &= 0x7f;
+	return (bits << 1) | (bits >> 6);
+}
+
+
+/* rectangles describe a bitmap portion */
+typedef struct _rectangle rectangle;
+struct _rectangle
+{
+	int				min_x;			/* minimum X, or left coordinate */
+	int				max_x;			/* maximum X, or right coordinate (inclusive) */
+	int				min_y;			/* minimum Y, or top coordinate */
+	int				max_y;			/* maximum Y, or bottom coordinate (inclusive) */
+};
+
+/* Standard MIN/MAX macros */
+#ifndef MIN
+#define MIN(x,y)			((x) < (y) ? (x) : (y))
+#endif
+#ifndef MAX
+#define MAX(x,y)			((x) > (y) ? (x) : (y))
+#endif
+
+
+inline float u2f(UINT32 v)
+{
+	union {
+		float ff;
+		UINT32 vv;
+	} u;
+	u.vv = v;
+	return u.ff;
+}
+
+
+/* Macros for normalizing data into big or little endian formats */
+#define FLIPENDIAN_INT16(x)	(((((UINT16) (x)) >> 8) | ((x) << 8)) & 0xffff)
+#define FLIPENDIAN_INT32(x)	((((UINT32) (x)) << 24) | (((UINT32) (x)) >> 24) | \
+	(( ((UINT32) (x)) & 0x0000ff00) << 8) | (( ((UINT32) (x)) & 0x00ff0000) >> 8))
+#define FLIPENDIAN_INT64(x)	\
+	(												\
+		(((((UINT64) (x)) >> 56) & ((UINT64) 0xFF)) <<  0)	|	\
+		(((((UINT64) (x)) >> 48) & ((UINT64) 0xFF)) <<  8)	|	\
+		(((((UINT64) (x)) >> 40) & ((UINT64) 0xFF)) << 16)	|	\
+		(((((UINT64) (x)) >> 32) & ((UINT64) 0xFF)) << 24)	|	\
+		(((((UINT64) (x)) >> 24) & ((UINT64) 0xFF)) << 32)	|	\
+		(((((UINT64) (x)) >> 16) & ((UINT64) 0xFF)) << 40)	|	\
+		(((((UINT64) (x)) >>  8) & ((UINT64) 0xFF)) << 48)	|	\
+		(((((UINT64) (x)) >>  0) & ((UINT64) 0xFF)) << 56)		\
+	)
+
+#define ACCESSING_BITS_0_15				((mem_mask & 0x0000ffff) != 0)
+#define ACCESSING_BITS_16_31			((mem_mask & 0xffff0000) != 0)
+
+// constants for expression endianness
+enum endianness_t
+{
+	ENDIANNESS_LITTLE,
+	ENDIANNESS_BIG
+};
+const endianness_t ENDIANNESS_NATIVE = ENDIANNESS_LITTLE;
+#define ENDIAN_VALUE_LE_BE(endian,leval,beval)	(((endian) == ENDIANNESS_LITTLE) ? (leval) : (beval))
+#define NATIVE_ENDIAN_VALUE_LE_BE(leval,beval)	ENDIAN_VALUE_LE_BE(ENDIANNESS_NATIVE, leval, beval)
+#define BYTE4_XOR_LE(a) 				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,3))
+
+#define BYTE_XOR_LE(a)  				((a) ^ NATIVE_ENDIAN_VALUE_LE_BE(0,1))
+
+#define profiler_mark_start(x)	do { } while (0)
+#define profiler_mark_end()		do { } while (0)
+
+
+/* Highly useful macro for compile-time knowledge of an array size */
+#define ARRAY_LENGTH(x)		(sizeof(x) / sizeof(x[0]))
+
+INLINE INT32 mul_32x32_shift(INT32 a, INT32 b, INT8 shift)
+{
+	INT32 result;
+
+#if defined _MSC_VER
+    __asm
+    {
+        mov   eax,a
+        imul  b
+        mov   cl,shift
+        shrd  eax,edx,cl
+        mov   result,eax
+    }
+#else
+	INT64 tmp = (INT64)a * (INT64)b;
+	tmp >>= shift;
+	result = (INT32)tmp;
+#endif
+
+	return result;
+}
+
+
+typedef void (*poly_draw_scanline_func)(void *dest, INT32 scanline, const poly_extent *extent, const void *extradata);
+
+INLINE rgb_t rgba_bilinear_filter(rgb_t rgb00, rgb_t rgb01, rgb_t rgb10, rgb_t rgb11, UINT8 u, UINT8 v)
+{
+	UINT32 ag0, ag1, rb0, rb1;
+
+	rb0 = (rgb00 & 0x00ff00ff) + ((((rgb01 & 0x00ff00ff) - (rgb00 & 0x00ff00ff)) * u) >> 8);
+	rb1 = (rgb10 & 0x00ff00ff) + ((((rgb11 & 0x00ff00ff) - (rgb10 & 0x00ff00ff)) * u) >> 8);
+	rgb00 >>= 8;
+	rgb01 >>= 8;
+	rgb10 >>= 8;
+	rgb11 >>= 8;
+	ag0 = (rgb00 & 0x00ff00ff) + ((((rgb01 & 0x00ff00ff) - (rgb00 & 0x00ff00ff)) * u) >> 8);
+	ag1 = (rgb10 & 0x00ff00ff) + ((((rgb11 & 0x00ff00ff) - (rgb10 & 0x00ff00ff)) * u) >> 8);
+
+	rb0 = (rb0 & 0x00ff00ff) + ((((rb1 & 0x00ff00ff) - (rb0 & 0x00ff00ff)) * v) >> 8);
+	ag0 = (ag0 & 0x00ff00ff) + ((((ag1 & 0x00ff00ff) - (ag0 & 0x00ff00ff)) * v) >> 8);
+
+	return ((ag0 << 8) & 0xff00ff00) | (rb0 & 0x00ff00ff);
+}
+
+typedef struct _poly_vertex poly_vertex;
+struct _poly_vertex
+{
+	float		x;							/* X coordinate */
+	float		y;							/* Y coordinate */
+	float		p[MAX_VERTEX_PARAMS];		/* interpolated parameter values */
+};
+
+
+typedef struct _tri_extent tri_extent;
+struct _tri_extent
+{
+	INT16		startx;						/* starting X coordinate (inclusive) */
+	INT16		stopx;						/* ending X coordinate (exclusive) */
+};
+
+/* tri_work_unit is a triangle-specific work-unit */
+typedef struct _tri_work_unit tri_work_unit;
+struct _tri_work_unit
+{
+	tri_extent			extent[8]; /* array of scanline extents */
+};
+
+#endif
diff --git a/src/hardware/voodoo_vogl.cpp b/src/hardware/voodoo_vogl.cpp
new file mode 100644
index 000000000..bb00c285a
--- /dev/null
+++ b/src/hardware/voodoo_vogl.cpp
@@ -0,0 +1,457 @@
+/*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#include <stdlib.h>
+#include <math.h>
+#include <map>
+
+#include "dosbox.h"
+
+#if C_OPENGL
+
+#include "voodoo_types.h"
+#include "voodoo_vogl.h"
+
+
+PFNGLACTIVETEXTUREARBPROC glActiveTextureARB = NULL;
+PFNGLMULTITEXCOORD4FARBPROC glMultiTexCoord4fARB = NULL;
+PFNGLMULTITEXCOORD4FVARBPROC glMultiTexCoord4fvARB = NULL;
+PFNGLCREATESHADEROBJECTARBPROC glCreateShaderObjectARB = NULL;
+PFNGLSHADERSOURCEARBPROC glShaderSourceARB = NULL;
+PFNGLCOMPILESHADERARBPROC glCompileShaderARB = NULL;
+PFNGLCREATEPROGRAMOBJECTARBPROC glCreateProgramObjectARB = NULL;
+PFNGLATTACHOBJECTARBPROC glAttachObjectARB = NULL;
+PFNGLLINKPROGRAMARBPROC glLinkProgramARB = NULL;
+PFNGLUSEPROGRAMOBJECTARBPROC glUseProgramObjectARB = NULL;
+PFNGLDELETEPROGRAMPROC glDeleteProgram = NULL;
+PFNGLUNIFORM1IARBPROC glUniform1iARB = NULL;
+PFNGLUNIFORM1FARBPROC glUniform1fARB = NULL;
+PFNGLUNIFORM2FARBPROC glUniform2fARB = NULL;
+PFNGLUNIFORM3FARBPROC glUniform3fARB = NULL;
+PFNGLUNIFORM4FARBPROC glUniform4fARB = NULL;
+PFNGLGETUNIFORMLOCATIONARBPROC glGetUniformLocationARB = NULL;
+PFNGLDETACHOBJECTARBPROC glDetachObjectARB = NULL;
+PFNGLDELETEOBJECTARBPROC glDeleteObjectARB = NULL;
+PFNGLGETOBJECTPARAMETERIVARBPROC glGetObjectParameterivARB = NULL;
+PFNGLGETINFOLOGARBPROC glGetInfoLogARB = NULL;
+PFNGLBLENDFUNCSEPARATEPROC glBlendFuncSeparate = NULL;
+PFNGLGENERATEMIPMAPEXTPROC glGenerateMipmap = NULL;
+PFNGLGETATTRIBLOCATIONARBPROC glGetAttribLocationARB = NULL;
+PFNGLVERTEXATTRIB1FPROC glVertexAttrib1fARB = NULL;
+
+
+static Bit32s opengl_version = -1;
+
+static bool has_shaders = false;
+static bool has_stencil = false;
+static bool has_alpha = false;
+
+
+static INT32 current_begin_mode = -1;
+
+static Bit32s current_depth_mode = -1;
+static Bit32s current_depth_func = -1;
+
+static Bit32s current_alpha_enabled = -1;
+static Bit32s current_src_rgb_fac = -1;
+static Bit32s current_dst_rgb_fac = -1;
+static Bit32s current_src_alpha_fac = -1;
+static Bit32s current_dst_alpha_fac = -1;
+
+static bool depth_masked = false;
+static bool color_masked = false;
+static bool alpha_masked = false;
+
+// buffer read/write defaults are back-buffer for double buffered contexts
+static bool draw_to_front_buffer = false;
+static bool read_from_front_buffer = false;
+
+
+void VOGL_Reset(void) {
+	opengl_version = -1;
+	has_shaders = false;
+	has_stencil = false;
+	has_alpha = false;
+
+	current_depth_mode=-1;
+	current_depth_func=-1;
+
+	current_alpha_enabled=-1;
+	current_src_rgb_fac=-1;
+	current_dst_rgb_fac=-1;
+	current_src_alpha_fac=-1;
+	current_dst_alpha_fac=-1;
+
+	depth_masked = false;
+	color_masked = false;
+	alpha_masked = false;
+
+	draw_to_front_buffer = false;
+	read_from_front_buffer = false;
+}
+
+
+void VOGL_InitVersion(void) {
+	opengl_version = -1;
+
+	char gl_verstr[16];
+	const GLubyte* gl_verstr_ub = glGetString(GL_VERSION);
+	strncpy(gl_verstr, (const char*)gl_verstr_ub, 16);
+	gl_verstr[15] = 0;
+	char* gl_ver_minor = strchr(gl_verstr, '.');
+	if (gl_ver_minor != NULL) {
+		gl_ver_minor++;
+		char* skip = strchr(gl_ver_minor, '.');
+		if (skip != NULL) *skip = 0;
+	}
+
+	int ogl_ver = 100;
+	if (gl_verstr[0] != 0) {
+		int major = 1;
+		int minor = 0;
+		if (strchr(gl_verstr, '.') != NULL) {
+			if (sscanf(gl_verstr,"%d.%d", &major, &minor) != 2) major = 0;
+		} else {
+			if (sscanf(gl_verstr, "%d", &major) != 1) major = 0;
+		}
+		if (major > 0) {
+			ogl_ver = major*100;
+			if (minor >= 0) {
+				if (minor < 10) ogl_ver += minor*10;
+				else ogl_ver += minor;
+			}
+		}
+	}
+
+	if (ogl_ver > 0) opengl_version = ogl_ver;
+}
+
+void VOGL_ClearShaderFunctions(void) {
+	glShaderSourceARB = NULL;
+	glCompileShaderARB = NULL;
+	glCreateProgramObjectARB = NULL;
+	glAttachObjectARB = NULL;
+	glLinkProgramARB = NULL;
+	glUseProgramObjectARB = NULL;
+	glUniform1iARB = NULL;
+	glUniform1fARB = NULL;
+	glUniform2fARB = NULL;
+	glUniform3fARB = NULL;
+	glUniform4fARB = NULL;
+	glGetUniformLocationARB = NULL;
+	glDetachObjectARB = NULL;
+	glDeleteObjectARB  = NULL;
+	glGetObjectParameterivARB = NULL;
+	glGetInfoLogARB = NULL;
+}
+
+bool VOGL_Initialize(void) {
+	VOGL_ClearShaderFunctions();
+
+	VOGL_InitVersion();
+
+	glActiveTextureARB = (PFNGLACTIVETEXTUREARBPROC)SDL_GL_GetProcAddress("glActiveTextureARB");
+	if (!glActiveTextureARB) {
+		LOG_MSG("opengl: glActiveTextureARB extension not supported");
+		return false;
+	}
+
+	glMultiTexCoord4fARB = (PFNGLMULTITEXCOORD4FARBPROC)SDL_GL_GetProcAddress("glMultiTexCoord4fARB");
+	if (!glMultiTexCoord4fARB) {
+		LOG_MSG("opengl: glMultiTexCoord4fARB extension not supported");
+		return false;
+	}
+
+	glMultiTexCoord4fvARB = (PFNGLMULTITEXCOORD4FVARBPROC)SDL_GL_GetProcAddress("glMultiTexCoord4fvARB");
+	if (!glMultiTexCoord4fvARB) {
+		LOG_MSG("opengl: glMultiTexCoord4fvARB extension not supported");
+		return false;
+	}
+
+	glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)SDL_GL_GetProcAddress("glBlendFuncSeparate");
+	if (!glBlendFuncSeparate) {
+		LOG_MSG("opengl: glBlendFuncSeparate extension not supported");
+		return false;
+	}
+
+	glGenerateMipmap = (PFNGLGENERATEMIPMAPEXTPROC)SDL_GL_GetProcAddress("glGenerateMipmap");
+	if (!glGenerateMipmap) {
+		LOG_MSG("opengl: glGenerateMipmap extension not supported");
+		return false;
+	}
+
+	if (VOGL_CheckFeature(VOGL_ATLEAST_V20)) {
+		const char* extensions = (const char*)glGetString(GL_EXTENSIONS);
+		if (strstr(extensions, "GL_ARB_shader_objects") && strstr(extensions, "GL_ARB_vertex_shader") &&
+			strstr(extensions, "GL_ARB_fragment_shader")) {
+
+			glCreateShaderObjectARB = (PFNGLCREATESHADEROBJECTARBPROC)SDL_GL_GetProcAddress("glCreateShaderObjectARB");
+			if (!glCreateShaderObjectARB) {
+				LOG_MSG("opengl: shader extensions not supported. Using fixed pipeline");
+			} else {
+				glShaderSourceARB = (PFNGLSHADERSOURCEARBPROC)SDL_GL_GetProcAddress("glShaderSourceARB");
+				if (!glShaderSourceARB) LOG_MSG("opengl: glShaderSourceARB extension not supported");
+
+				glCompileShaderARB = (PFNGLCOMPILESHADERARBPROC)SDL_GL_GetProcAddress("glCompileShaderARB");
+				if (!glCompileShaderARB) LOG_MSG("opengl: glCompileShaderARB extension not supported");
+
+				glCreateProgramObjectARB = (PFNGLCREATEPROGRAMOBJECTARBPROC)SDL_GL_GetProcAddress("glCreateProgramObjectARB");
+				if (!glCreateProgramObjectARB) LOG_MSG("opengl: glCreateProgramObjectARB extension not supported");
+
+				glAttachObjectARB = (PFNGLATTACHOBJECTARBPROC)SDL_GL_GetProcAddress("glAttachObjectARB");
+				if (!glAttachObjectARB) LOG_MSG("opengl: glAttachObjectARB extension not supported");
+
+				glLinkProgramARB = (PFNGLLINKPROGRAMARBPROC)SDL_GL_GetProcAddress("glLinkProgramARB");
+				if (!glLinkProgramARB) LOG_MSG("opengl: glLinkProgramARB extension not supported");
+
+				glUseProgramObjectARB = (PFNGLUSEPROGRAMOBJECTARBPROC)SDL_GL_GetProcAddress("glUseProgramObjectARB");
+				if (!glUseProgramObjectARB) LOG_MSG("opengl: glUseProgramObjectARB extension not supported");
+
+				glDeleteProgram = (PFNGLDELETEPROGRAMPROC)SDL_GL_GetProcAddress("glDeleteProgram");
+				if (!glDeleteProgram) LOG_MSG("opengl: glDeleteProgram extension not supported");
+
+				glUniform1iARB = (PFNGLUNIFORM1IARBPROC)SDL_GL_GetProcAddress("glUniform1iARB");
+				if (!glUniform1iARB) LOG_MSG("opengl: glUniform1iARB extension not supported");
+
+				glUniform1fARB = (PFNGLUNIFORM1FARBPROC)SDL_GL_GetProcAddress("glUniform1fARB");
+				if (!glUniform1fARB) LOG_MSG("opengl: glUniform1fARB extension not supported");
+
+				glUniform2fARB = (PFNGLUNIFORM2FARBPROC)SDL_GL_GetProcAddress("glUniform2fARB");
+				if (!glUniform2fARB) LOG_MSG("opengl: glUniform2fARB extension not supported");
+
+				glUniform3fARB = (PFNGLUNIFORM3FARBPROC)SDL_GL_GetProcAddress("glUniform3fARB");
+				if (!glUniform3fARB) LOG_MSG("opengl: glUniform3fARB extension not supported");
+
+				glUniform4fARB = (PFNGLUNIFORM4FARBPROC)SDL_GL_GetProcAddress("glUniform4fARB");
+				if (!glUniform4fARB) LOG_MSG("opengl: glUniform4fARB extension not supported");
+
+				glGetUniformLocationARB = (PFNGLGETUNIFORMLOCATIONARBPROC)SDL_GL_GetProcAddress("glGetUniformLocationARB");
+				if (!glGetUniformLocationARB) LOG_MSG("opengl: glGetUniformLocationARB extension not supported");
+
+				glDetachObjectARB = (PFNGLDETACHOBJECTARBPROC)SDL_GL_GetProcAddress("glDetachObjectARB");
+				if (!glDetachObjectARB) LOG_MSG("opengl: glDetachObjectARB extension not supported");
+
+				glDeleteObjectARB  = (PFNGLDELETEOBJECTARBPROC)SDL_GL_GetProcAddress("glDeleteObjectARB");
+				if (!glDeleteObjectARB) LOG_MSG("opengl: glDeleteObjectARB extension not supported");
+
+				glGetObjectParameterivARB = (PFNGLGETOBJECTPARAMETERIVARBPROC)SDL_GL_GetProcAddress("glGetObjectParameterivARB");
+				if (!glGetObjectParameterivARB) LOG_MSG("opengl: glGetObjectParameterivARB extension not supported");
+
+				glGetInfoLogARB = (PFNGLGETINFOLOGARBPROC)SDL_GL_GetProcAddress("glGetInfoLogARB");
+				if (!glGetInfoLogARB) LOG_MSG("opengl: glGetInfoLogARB extension not supported");
+
+				glGetAttribLocationARB = (PFNGLGETATTRIBLOCATIONARBPROC)SDL_GL_GetProcAddress("glGetAttribLocationARB");
+				if (!glGetAttribLocationARB) LOG_MSG("opengl: glGetAttribLocationARB extension not supported");
+
+				glVertexAttrib1fARB = (PFNGLVERTEXATTRIB1FPROC)SDL_GL_GetProcAddress("glVertexAttrib1fARB");
+				if (!glVertexAttrib1fARB) LOG_MSG("opengl: glVertexAttrib1fARB extension not supported");
+
+				if (glShaderSourceARB && glCompileShaderARB && glCreateProgramObjectARB &&
+					glAttachObjectARB && glLinkProgramARB && glUseProgramObjectARB &&
+					glUniform1iARB && glUniform1fARB && glUniform2fARB && glUniform3fARB &&
+					glUniform4fARB && glGetUniformLocationARB && glDetachObjectARB &&
+					glDeleteObjectARB && glGetObjectParameterivARB && glGetInfoLogARB) {
+						VOGL_FlagFeature(VOGL_HAS_SHADERS);
+//						LOG_MSG("opengl: shader functionality enabled");
+				} else {
+					VOGL_ClearShaderFunctions();
+				}
+			}
+		}
+	}
+
+	return true;
+}
+
+
+bool VOGL_CheckFeature(Bit32u feat) {
+	switch (feat) {
+		case VOGL_ATLEAST_V20:
+			if (opengl_version >= 200) return true;
+			break;
+		case VOGL_ATLEAST_V21:
+			if (opengl_version >= 210) return true;
+			break;
+		case VOGL_ATLEAST_V30:
+			if (opengl_version >= 300) return true;
+			break;
+		case VOGL_HAS_SHADERS:
+			if (has_shaders) return true;
+			break;
+		case VOGL_HAS_STENCIL_BUFFER:
+			if (has_stencil) return true;
+			break;
+		case VOGL_HAS_ALPHA_PLANE:
+			if (has_alpha) return true;
+			break;
+		default:
+			LOG_MSG("opengl: unknown feature queried: %x",feat);
+			break;
+	}
+
+	return false;
+}
+
+void VOGL_FlagFeature(Bit32u feat) {
+	switch (feat) {
+		case VOGL_HAS_SHADERS:
+			has_shaders = true;
+			break;
+		case VOGL_HAS_STENCIL_BUFFER:
+			has_stencil = true;
+			break;
+		case VOGL_HAS_ALPHA_PLANE:
+			has_alpha = true;
+			break;
+		default:
+			LOG_MSG("opengl: unknown feature: %x",feat);
+			break;
+	}
+}
+
+
+void VOGL_BeginMode(INT32 new_mode) {
+	if (current_begin_mode > -1) {
+		if (new_mode != current_begin_mode) {
+			glEnd();
+			if (new_mode > -1) glBegin(new_mode);
+			current_begin_mode = new_mode;
+		}
+	} else {
+		if (new_mode > -1) {
+			glBegin(new_mode);
+			current_begin_mode = new_mode;
+		}
+	}
+}
+
+void VOGL_ClearBeginMode(void) {
+	if (current_begin_mode > -1) {
+		glEnd();
+		current_begin_mode = -1;
+	}
+}
+
+
+void VOGL_SetDepthMode(Bit32s mode, Bit32s func) {
+	if (current_depth_mode!=mode) {
+		if (mode!=0) {
+			VOGL_ClearBeginMode();
+			glEnable(GL_DEPTH_TEST);
+			current_depth_mode=1;
+			if (current_depth_func!=func) {
+				glDepthFunc(GL_NEVER+func);
+				current_depth_func=func;
+			}
+		} else {
+			VOGL_ClearBeginMode();
+			glDisable(GL_DEPTH_TEST);
+			current_depth_mode=0;
+		}
+	} else {
+		if ((mode!=0) && (current_depth_func!=func)) {
+			VOGL_ClearBeginMode();
+			glDepthFunc(GL_NEVER+func);
+			current_depth_func=func;
+		}
+	}
+}
+
+
+void VOGL_SetAlphaMode(Bit32s enabled_mode,GLuint src_rgb_fac,GLuint dst_rgb_fac,
+											GLuint src_alpha_fac,GLuint dst_alpha_fac) {
+	if (current_alpha_enabled!=enabled_mode) {
+		VOGL_ClearBeginMode();
+		if (enabled_mode!=0) {
+			glEnable(GL_BLEND);
+			current_alpha_enabled=1;
+			if ((current_src_rgb_fac!=(Bit32s)src_rgb_fac) || (current_dst_rgb_fac!=(Bit32s)dst_rgb_fac) ||
+				(current_src_alpha_fac!=(Bit32s)src_alpha_fac) || (current_dst_alpha_fac!=(Bit32s)dst_alpha_fac)) {
+				glBlendFuncSeparate(src_rgb_fac, dst_rgb_fac, src_alpha_fac, dst_alpha_fac);
+				current_src_rgb_fac=(Bit32s)src_rgb_fac;
+				current_dst_rgb_fac=(Bit32s)dst_rgb_fac;
+				current_src_alpha_fac=(Bit32s)src_alpha_fac;
+				current_dst_alpha_fac=(Bit32s)dst_alpha_fac;
+			}
+		} else {
+			glDisable(GL_BLEND);
+			current_alpha_enabled=0;
+		}
+	} else {
+		if (current_alpha_enabled!=0) {
+			if ((current_src_rgb_fac!=(Bit32s)src_rgb_fac) || (current_dst_rgb_fac!=(Bit32s)dst_rgb_fac) ||
+				(current_src_alpha_fac!=(Bit32s)src_alpha_fac) || (current_dst_alpha_fac!=(Bit32s)dst_alpha_fac)) {
+				VOGL_ClearBeginMode();
+				glBlendFuncSeparate(src_rgb_fac, dst_rgb_fac, src_alpha_fac, dst_alpha_fac);
+				current_src_rgb_fac=(Bit32s)src_rgb_fac;
+				current_dst_rgb_fac=(Bit32s)dst_rgb_fac;
+				current_src_alpha_fac=(Bit32s)src_alpha_fac;
+				current_dst_alpha_fac=(Bit32s)dst_alpha_fac;
+			}
+		}
+	}
+}
+
+
+void VOGL_SetDepthMaskMode(bool masked) {
+	if (depth_masked!=masked) {
+		VOGL_ClearBeginMode();
+		if (masked) {
+			glDepthMask(GL_TRUE);
+			depth_masked=true;
+		} else {
+			glDepthMask(GL_FALSE);
+			depth_masked=false;
+		}
+	}
+}
+
+
+void VOGL_SetColorMaskMode(bool cmasked, bool amasked) {
+	if ((color_masked!=cmasked) || (alpha_masked!=amasked)) {
+		color_masked=cmasked;
+		alpha_masked=amasked;
+		GLboolean cm = (color_masked ? GL_TRUE : GL_FALSE);
+		GLboolean am = (alpha_masked ? GL_TRUE : GL_FALSE);
+		glColorMask(cm,cm,cm,am);
+	}
+}
+
+
+void VOGL_SetDrawMode(bool front_draw) {
+	if (draw_to_front_buffer!=front_draw) {
+		VOGL_ClearBeginMode();
+		if (front_draw) glDrawBuffer(GL_FRONT);
+		else glDrawBuffer(GL_BACK);
+		draw_to_front_buffer=front_draw;
+	}
+}
+
+
+void VOGL_SetReadMode(bool front_read) {
+	VOGL_ClearBeginMode();
+
+	if (read_from_front_buffer!=front_read) {
+		if (front_read) glReadBuffer(GL_FRONT);
+		else glReadBuffer(GL_BACK);
+		read_from_front_buffer=front_read;
+	}
+}
+
+#endif
diff --git a/src/hardware/voodoo_vogl.h b/src/hardware/voodoo_vogl.h
new file mode 100644
index 000000000..1fd14e02a
--- /dev/null
+++ b/src/hardware/voodoo_vogl.h
@@ -0,0 +1,122 @@
+ /*
+ *  Copyright (C) 2002-2013  The DOSBox Team
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+
+#ifndef DOSBOX_VOODOO_VOGL_H
+#define DOSBOX_VOODOO_VOGL_H
+
+#include "SDL.h"
+#include "SDL_opengl.h"
+
+
+/* opengl extensions */
+extern PFNGLACTIVETEXTUREARBPROC glActiveTextureARB;
+extern PFNGLMULTITEXCOORD4FARBPROC glMultiTexCoord4fARB;
+extern PFNGLMULTITEXCOORD4FVARBPROC glMultiTexCoord4fvARB;
+extern PFNGLCREATESHADEROBJECTARBPROC glCreateShaderObjectARB;
+extern PFNGLSHADERSOURCEARBPROC glShaderSourceARB;
+extern PFNGLCOMPILESHADERARBPROC glCompileShaderARB;
+extern PFNGLCREATEPROGRAMOBJECTARBPROC glCreateProgramObjectARB;
+extern PFNGLATTACHOBJECTARBPROC glAttachObjectARB;
+extern PFNGLLINKPROGRAMARBPROC glLinkProgramARB;
+extern PFNGLUSEPROGRAMOBJECTARBPROC glUseProgramObjectARB;
+extern PFNGLDELETEPROGRAMPROC glDeleteProgram;
+extern PFNGLUNIFORM1IARBPROC glUniform1iARB;
+extern PFNGLUNIFORM1FARBPROC glUniform1fARB;
+extern PFNGLUNIFORM2FARBPROC glUniform2fARB;
+extern PFNGLUNIFORM3FARBPROC glUniform3fARB;
+extern PFNGLUNIFORM4FARBPROC glUniform4fARB;
+extern PFNGLGETUNIFORMLOCATIONARBPROC glGetUniformLocationARB;
+extern PFNGLDETACHOBJECTARBPROC glDetachObjectARB;
+extern PFNGLDELETEOBJECTARBPROC glDeleteObjectARB;
+extern PFNGLGETOBJECTPARAMETERIVARBPROC glGetObjectParameterivARB;
+extern PFNGLGETINFOLOGARBPROC glGetInfoLogARB;
+extern PFNGLBLENDFUNCSEPARATEPROC glBlendFuncSeparate;
+extern PFNGLGENERATEMIPMAPEXTPROC glGenerateMipmap;
+extern PFNGLGETATTRIBLOCATIONARBPROC glGetAttribLocationARB;
+extern PFNGLVERTEXATTRIB1FPROC glVertexAttrib1fARB;
+
+
+#define VOGL_ATLEAST_V20			0x00000001
+#define VOGL_ATLEAST_V21			0x00000002
+#define VOGL_ATLEAST_V30			0x00000004
+#define VOGL_HAS_SHADERS			0x00000010
+#define VOGL_HAS_STENCIL_BUFFER		0x00000100
+#define VOGL_HAS_ALPHA_PLANE		0x00000200
+
+
+static const GLuint ogl_sfactor[16] = {
+	GL_ZERO,
+	GL_SRC_ALPHA,
+	GL_DST_COLOR,
+	GL_DST_ALPHA,
+	GL_ONE,
+	GL_ONE_MINUS_SRC_ALPHA,
+	GL_ONE_MINUS_DST_COLOR,
+	GL_ONE_MINUS_DST_ALPHA,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_SRC_ALPHA_SATURATE
+};
+
+static const GLuint ogl_dfactor[16] = {
+	GL_ZERO,
+	GL_SRC_ALPHA,
+	GL_SRC_COLOR,
+	GL_DST_ALPHA,
+	GL_ONE,
+	GL_ONE_MINUS_SRC_ALPHA,
+	GL_ONE_MINUS_SRC_COLOR,
+	GL_ONE_MINUS_DST_ALPHA,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_ZERO,
+	GL_SRC_COLOR /* A_COLORBEFOREFOG */
+};
+
+
+void VOGL_Reset(void);
+
+bool VOGL_Initialize(void);
+
+bool VOGL_CheckFeature(Bit32u feat);
+void VOGL_FlagFeature(Bit32u feat);
+
+void VOGL_BeginMode(INT32 new_mode);
+void VOGL_ClearBeginMode(void);
+
+void VOGL_SetDepthMode(Bit32s mode, Bit32s func);
+void VOGL_SetAlphaMode(Bit32s enabled_mode,GLuint src_rgb_fac,GLuint dst_rgb_fac,
+											GLuint src_alpha_fac,GLuint dst_alpha_fac);
+
+void VOGL_SetDepthMaskMode(bool masked);
+void VOGL_SetColorMaskMode(bool cmasked, bool amasked);
+
+void VOGL_SetDrawMode(bool front_draw);
+void VOGL_SetReadMode(bool front_read);
+
+#endif

