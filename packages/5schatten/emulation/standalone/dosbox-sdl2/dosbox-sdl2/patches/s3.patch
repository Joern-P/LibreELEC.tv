diff -uNr a/include/callback.h b/include/callback.h
--- a/include/callback.h	2019-10-08 16:37:14.000000000 +0200
+++ b/include/callback.h	2020-11-11 20:22:14.673650299 +0100
@@ -31,7 +31,7 @@
 		CB_IRET,CB_IRETD,CB_IRET_STI,CB_IRET_EOI_PIC1,
 		CB_IRQ0,CB_IRQ1,CB_IRQ9,CB_IRQ12,CB_IRQ12_RET,CB_IRQ6_PCJR,CB_MOUSE,
 		CB_INT29,CB_INT16,CB_HOOKABLE,CB_TDE_IRET,CB_IPXESR,CB_IPXESR_RET,
-		CB_INT21,CB_INT13,CB_VESA_WAIT,CB_VESA_PM };
+		CB_INT21,CB_INT13,CB_VESA_WAIT,CB_VESA_PM, CB_VESA_START };
 
 #define CB_MAX		128
 #define CB_SIZE		32
diff -uNr a/include/dosbox.h b/include/dosbox.h
--- a/include/dosbox.h	2019-10-08 16:37:14.000000000 +0200
+++ b/include/dosbox.h	2020-11-11 20:20:32.954346426 +0100
@@ -21,6 +21,7 @@
 #define DOSBOX_DOSBOX_H
 
 #include "config.h"
+#include "rgb24.h"
 
 GCC_ATTRIBUTE(noreturn) void E_Exit(const char * message,...) GCC_ATTRIBUTE( __format__(__printf__, 1, 2));
 
diff -uNr a/include/rgb24.h b/include/rgb24.h
--- a/include/rgb24.h	1970-01-01 01:00:00.000000000 +0100
+++ b/include/rgb24.h	2020-11-11 20:20:32.954346426 +0100
@@ -0,0 +1,15 @@
+typedef struct rgb24
+{	
+	protected:
+	unsigned char byte[3];
+	
+	public:
+	rgb24() {}
+	rgb24(const rgb24& val) {
+		*this = val; }
+
+	operator int () const {
+		return (byte[2]<<16)|(byte[1]<<8)|(byte[0]<<0); }
+	int operator& (const rgb24& val) const	{
+		return (char)*this & (char)val; }
+} rgb24;
diff -uNr a/include/vga.h b/include/vga.h
--- a/include/vga.h	2019-10-08 16:37:14.000000000 +0200
+++ b/include/vga.h	2020-11-11 20:20:32.954346426 +0100
@@ -35,7 +35,7 @@
 enum VGAModes {
 	M_CGA2, M_CGA4,
 	M_EGA, M_VGA,
-	M_LIN4, M_LIN8, M_LIN15, M_LIN16, M_LIN32,
+	M_LIN4, M_LIN8, M_LIN15, M_LIN16, M_LIN24, M_LIN32,
 	M_TEXT,
 	M_HERC_GFX, M_HERC_TEXT,
 	M_CGA16, M_TANDY2, M_TANDY4, M_TANDY16, M_TANDY_TEXT,
@@ -58,7 +58,8 @@
 #define S3_XGA_640		0x40
 #define S3_XGA_800		0x80
 #define S3_XGA_1280		0xc0
-#define S3_XGA_WMASK	(S3_XGA_640|S3_XGA_800|S3_XGA_1024|S3_XGA_1152|S3_XGA_1280)
+#define S3_XGA_1600		0x81
+#define S3_XGA_WMASK	(S3_XGA_640|S3_XGA_800|S3_XGA_1024|S3_XGA_1152|S3_XGA_1280|S3_XGA_1600)
 
 #define S3_XGA_8BPP  0x00
 #define S3_XGA_16BPP 0x10
diff -uNr a/src/cpu/callback.cpp b/src/cpu/callback.cpp
--- a/src/cpu/callback.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/cpu/callback.cpp	2020-11-11 20:20:32.954346426 +0100
@@ -455,6 +455,26 @@
 		phys_writeb(physAddress+0x0d,(Bit8u)0x1f);		// pop ds
 		phys_writeb(physAddress+0x0e,(Bit8u)0xcf);		//An IRET Instruction
 		return 0x0f; */
+	case CB_VESA_START: {	// pseudocode: if(reg_bl==0x80) while(!(inportb(0x3da)&0x8));
+		phys_writew(physAddress+0x00,(Bit16u)0x38fe);	// grp4	cb
+		phys_writew(physAddress+0x02,(Bit16u)0x9090);
+		phys_writew(physAddress+0x04,(Bit16u)0xfb80);	// cmp	bl, 0x80
+		phys_writeb(physAddress+0x06,(Bit8u)0x80);
+		phys_writew(physAddress+0x07,(Bit16u)0x1175);	// jne	novret
+		phys_writew(physAddress+0x09,(Bit16u)0x5066);	// push	ax
+		phys_writew(physAddress+0x0b,(Bit16u)0x5266);	// push	dx
+		phys_writew(physAddress+0x0d,(Bit16u)0xba66);	// mov	dx, 0x3dah
+		phys_writew(physAddress+0x0f,(Bit16u)0x03da);
+														// again:
+		phys_writeb(physAddress+0x11,(Bit8u)0xec);		// in	al,dx
+		phys_writew(physAddress+0x12,(Bit16u)0x0824);	// and	al ,8
+		phys_writew(physAddress+0x14,(Bit16u)0xfb74);	// je	again
+		phys_writew(physAddress+0x16,(Bit16u)0x5a66);	// pop	dx
+		phys_writew(physAddress+0x18,(Bit16u)0x5866);	// pop	ax
+														// novret:
+		phys_writeb(physAddress+0x1a,(Bit8u)0xc3);		// retn
+		phys_writew(physAddress+0x02,callback);			// callback number
+		return 27; }
 	case CB_INT21:
 		phys_writeb(physAddress+0x00,(Bit8u)0xFB);		//STI
 		if (use_cb) {
diff -uNr a/src/dosbox.cpp b/src/dosbox.cpp
--- a/src/dosbox.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/dosbox.cpp	2020-11-11 20:23:38.440352036 +0100
@@ -58,6 +58,7 @@
 //void CREDITS_Init(Section*);
 void RENDER_Init(Section*);
 void VGA_Init(Section*);
+void vesa_refresh_Init(Section*);
 
 void DOS_Init(Section*);
 
@@ -364,6 +365,7 @@
 	machine = MCH_VGA;
 	int10.vesa_nolfb = false;
 	int10.vesa_oldvbe = false;
+	int10.vesa_no24bpp = false;
 	if      (mtype == "cga")      { machine = MCH_CGA; }
 	else if (mtype == "tandy")    { machine = MCH_TANDY; }
 	else if (mtype == "pcjr")     { machine = MCH_PCJR; }
@@ -371,7 +373,9 @@
 	else if (mtype == "ega")      { machine = MCH_EGA; }
 //	else if (mtype == "vga")          { svgaCard = SVGA_S3Trio; }
 	else if (mtype == "svga_s3")       { svgaCard = SVGA_S3Trio; }
+	else if (mtype == "vesa_no24bpp") { svgaCard = SVGA_S3Trio; int10.vesa_no24bpp = true;}
 	else if (mtype == "vesa_nolfb")   { svgaCard = SVGA_S3Trio; int10.vesa_nolfb = true;}
+	else if (mtype == "vesa_nolfb_no24bpp") { svgaCard = SVGA_S3Trio; int10.vesa_nolfb = true; int10.vesa_no24bpp = true;}
 	else if (mtype == "vesa_oldvbe")   { svgaCard = SVGA_S3Trio; int10.vesa_oldvbe = true;}
 	else if (mtype == "svga_et4000")   { svgaCard = SVGA_TsengET4K; }
 	else if (mtype == "svga_et3000")   { svgaCard = SVGA_TsengET3K; }
@@ -379,6 +383,8 @@
 	else if (mtype == "svga_paradise") { svgaCard = SVGA_ParadisePVGA1A; }
 	else if (mtype == "vgaonly")      { svgaCard = SVGA_None; }
 	else E_Exit("DOSBOX:Unknown machine type %s",mtype.c_str());
+
+	vga.vmemsize=section->Get_int("vmemsize")*1024;
 }
 
 
@@ -409,7 +415,7 @@
 	const char* machines[] = {
 		"hercules", "cga", "tandy", "pcjr", "ega",
 		"vgaonly", "svga_s3", "svga_et3000", "svga_et4000",
-		"svga_paradise", "vesa_nolfb", "vesa_oldvbe", 0 };
+		"svga_paradise", "vesa_no24bpp", "vesa_nolfb", "vesa_nolfb_no24bpp", "vesa_oldvbe", 0 };
 	secprop=control->AddSection_prop("dosbox",&DOSBOX_RealInit);
 	Pstring = secprop->Add_path("language",Property::Changeable::Always,"");
 	Pstring->Set_help("Select another language file.");
@@ -418,6 +424,10 @@
 	Pstring->Set_values(machines);
 	Pstring->Set_help("The type of machine DOSBox tries to emulate.");
 
+	Pint = secprop->Add_int("vmemsize",Property::Changeable::OnlyAtStart,4096);
+	Pint->SetMinMax(0,8192);
+	Pint->Set_help("Amount of video memory in kilobytes.");
+
 	Pstring = secprop->Add_path("captures",Property::Changeable::Always,"capture");
 	Pstring->Set_help("Directory where things like wave, midi, screenshot get captured.");
 
@@ -442,6 +452,36 @@
 	secprop->AddInitFunction(&TIMER_Init);//done
 	secprop->AddInitFunction(&CMOS_Init);//done
 
+	secprop=control->AddSection_prop("vesa_refresh",&vesa_refresh_Init,true);
+	Pint = secprop->Add_int("512x384",Property::Changeable::Always,70);
+	Pint->Set_help("Refresh rate for VESA graphics mode 512x384.");
+	Pint = secprop->Add_int("640x350",Property::Changeable::Always,70);
+	Pint->Set_help("Refresh rate for VESA graphics mode 640x350.");
+	Pint = secprop->Add_int("640x400",Property::Changeable::Always,70);
+	Pint->Set_help("Refresh rate for VESA graphics modes 640x400, 320x200 and 320x400.");
+	Pint = secprop->Add_int("640x480",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics modes 640x480, 320x240 and 320x480.");
+	Pint = secprop->Add_int("720x480",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA text mode 80x60 (9x8 character cell).");
+	Pint = secprop->Add_int("800x600",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics modes 800x600 and 400x300.");
+	Pint = secprop->Add_int("1024x768",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics mode 1024x768.");
+	Pint = secprop->Add_int("1188x344",Property::Changeable::Always,70);
+	Pint->Set_help("Refresh rate for VESA text mode 132x43 (9x8 character cell).");
+	Pint = secprop->Add_int("1188x400",Property::Changeable::Always,70);
+	Pint->Set_help("Refresh rate for VESA text modes 132x25 and 132x50 (9x16 and 9x8 character cells).");
+	Pint = secprop->Add_int("1188x480",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA text mode 132x60 (9x8 character cell).");
+	Pint = secprop->Add_int("1152x864",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics mode 1152x864.");
+	Pint = secprop->Add_int("1280x960",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics mode 1280x960.");
+	Pint = secprop->Add_int("1280x1024",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics mode 1280x1024.");
+	Pint = secprop->Add_int("1600x1200",Property::Changeable::Always,60);
+	Pint->Set_help("Refresh rate for VESA graphics mode 1600x1200.");
+
 	secprop=control->AddSection_prop("render",&RENDER_Init,true);
 	Pint = secprop->Add_int("frameskip",Property::Changeable::Always,0);
 	Pint->SetMinMax(0,10);
diff -uNr a/src/gui/render.cpp b/src/gui/render.cpp
--- a/src/gui/render.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/gui/render.cpp	2020-11-11 20:20:32.954346426 +0100
@@ -393,6 +393,11 @@
 			gfx_flags |= GFX_LOVE_16;
 			gfx_flags = (gfx_flags & ~GFX_CAN_8) | GFX_RGBONLY;
 			break;
+	case 24:
+			render.src.start = ( render.src.width * 3) / sizeof(Bitu);
+			gfx_flags |= GFX_LOVE_32;
+			gfx_flags = (gfx_flags & ~GFX_CAN_8) | GFX_RGBONLY;
+			break;
 	case 32:
 			render.src.start = ( render.src.width * 4) / sizeof(Bitu);
 			gfx_flags |= GFX_LOVE_32;
@@ -458,7 +463,7 @@
 	switch (render.src.bpp) {
 	case 8:
 		render.scale.lineHandler = (*lineBlock)[0][render.scale.outMode];
-		render.scale.linePalHandler = (*lineBlock)[4][render.scale.outMode];
+		render.scale.linePalHandler = (*lineBlock)[5][render.scale.outMode];
 		render.scale.inMode = scalerMode8;
 		render.scale.cachePitch = render.src.width * 1;
 		break;
@@ -474,10 +479,16 @@
 		render.scale.inMode = scalerMode16;
 		render.scale.cachePitch = render.src.width * 2;
 		break;
-	case 32:
+	case 24:
 		render.scale.lineHandler = (*lineBlock)[3][render.scale.outMode];
 		render.scale.linePalHandler = 0;
 		render.scale.inMode = scalerMode32;
+		render.scale.cachePitch = render.src.width * 3;
+		break;
+	case 32:
+		render.scale.lineHandler = (*lineBlock)[4][render.scale.outMode];
+		render.scale.linePalHandler = 0;
+		render.scale.inMode = scalerMode32;
 		render.scale.cachePitch = render.src.width * 4;
 		break;
 	default:
diff -uNr a/src/gui/render_scalers.cpp b/src/gui/render_scalers.cpp
--- a/src/gui/render_scalers.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/gui/render_scalers.cpp	2020-11-11 20:20:32.954346426 +0100
@@ -148,6 +148,18 @@
 #undef SBPP
 #undef DBPP
 
+#define SBPP 24
+#define DBPP 15
+#include "render_templates.h"
+#undef DBPP
+#define DBPP 16
+#include "render_templates.h"
+#undef DBPP
+#define DBPP 32
+#include "render_templates.h"
+#undef SBPP
+#undef DBPP
+
 #define SBPP 32
 #define DBPP 15
 #include "render_templates.h"
@@ -166,6 +178,7 @@
 {	Cache_8_8,	Cache_8_15 ,	Cache_8_16 ,	Cache_8_32 },
 {	        0,	Cache_15_15,	Cache_15_16,	Cache_15_32},
 {	        0,	Cache_16_15,	Cache_16_16,	Cache_16_32},
+{	        0,	Cache_24_15,	Cache_24_16,	Cache_24_32},
 {	        0,	Cache_32_15,	Cache_32_16,	Cache_32_32},
 {	Cache_8_8,	Cache_9_15 ,	Cache_9_16 ,	Cache_9_32 }
 };
@@ -178,12 +191,14 @@
 {	Normal1x_8_8_L,		Normal1x_8_15_L ,	Normal1x_8_16_L ,	Normal1x_8_32_L },
 {	             0,		Normal1x_15_15_L,	Normal1x_15_16_L,	Normal1x_15_32_L},
 {	             0,		Normal1x_16_15_L,	Normal1x_16_16_L,	Normal1x_16_32_L},
+{	             0,		Normal1x_24_15_L,	Normal1x_24_16_L,	Normal1x_24_32_L},
 {	             0,		Normal1x_32_15_L,	Normal1x_32_16_L,	Normal1x_32_32_L},
 {	Normal1x_8_8_L,		Normal1x_9_15_L ,	Normal1x_9_16_L ,	Normal1x_9_32_L }
 },{
 {	Normal1x_8_8_R,		Normal1x_8_15_R ,	Normal1x_8_16_R ,	Normal1x_8_32_R },
 {	             0,		Normal1x_15_15_R,	Normal1x_15_16_R,	Normal1x_15_32_R},
 {	             0,		Normal1x_16_15_R,	Normal1x_16_16_R,	Normal1x_16_32_R},
+{	             0,		Normal1x_24_15_R,	Normal1x_24_16_R,	Normal1x_24_32_R},
 {	             0,		Normal1x_32_15_R,	Normal1x_32_16_R,	Normal1x_32_32_R},
 {	Normal1x_8_8_R,		Normal1x_9_15_R ,	Normal1x_9_16_R ,	Normal1x_9_32_R }
 }};
@@ -195,12 +210,14 @@
 {	NormalDw_8_8_L,		NormalDw_8_15_L ,	NormalDw_8_16_L ,	NormalDw_8_32_L },
 {	             0,		NormalDw_15_15_L,	NormalDw_15_16_L,	NormalDw_15_32_L},
 {	             0,		NormalDw_16_15_L,	NormalDw_16_16_L,	NormalDw_16_32_L},
+{	             0,		NormalDw_24_15_L,	NormalDw_24_16_L,	NormalDw_24_32_L},
 {	             0,		NormalDw_32_15_L,	NormalDw_32_16_L,	NormalDw_32_32_L},
 {	NormalDw_8_8_L,		NormalDw_9_15_L ,	NormalDw_9_16_L ,	NormalDw_9_32_L }
 },{
 {	NormalDw_8_8_R,		NormalDw_8_15_R ,	NormalDw_8_16_R ,	NormalDw_8_32_R },
 {	             0,		NormalDw_15_15_R,	NormalDw_15_16_R,	NormalDw_15_32_R},
 {	             0,		NormalDw_16_15_R,	NormalDw_16_16_R,	NormalDw_16_32_R},
+{	             0,		NormalDw_24_15_R,	NormalDw_24_16_R,	NormalDw_24_32_R},
 {	             0,		NormalDw_32_15_R,	NormalDw_32_16_R,	NormalDw_32_32_R},
 {	NormalDw_8_8_R,		NormalDw_9_15_R ,	NormalDw_9_16_R ,	NormalDw_9_32_R }
 }};
@@ -212,12 +229,14 @@
 {	NormalDh_8_8_L,		NormalDh_8_15_L ,	NormalDh_8_16_L ,	NormalDh_8_32_L },
 {	             0,		NormalDh_15_15_L,	NormalDh_15_16_L,	NormalDh_15_32_L},
 {	             0,		NormalDh_16_15_L,	NormalDh_16_16_L,	NormalDh_16_32_L},
+{	             0,		NormalDh_24_15_L,	NormalDh_24_16_L,	NormalDh_24_32_L},
 {	             0,		NormalDh_32_15_L,	NormalDh_32_16_L,	NormalDh_32_32_L},
 {	NormalDh_8_8_L,		NormalDh_9_15_L ,	NormalDh_9_16_L ,	NormalDh_9_32_L }
 },{
 {	NormalDh_8_8_R,		NormalDh_8_15_R ,	NormalDh_8_16_R ,	NormalDh_8_32_R },
 {	             0,		NormalDh_15_15_R,	NormalDh_15_16_R,	NormalDh_15_32_R},
 {	             0,		NormalDh_16_15_R,	NormalDh_16_16_R,	NormalDh_16_32_R},
+{	             0,		NormalDh_24_15_R,	NormalDh_24_16_R,	NormalDh_24_32_R},
 {	             0,		NormalDh_32_15_R,	NormalDh_32_16_R,	NormalDh_32_32_R},
 {	NormalDh_8_8_R,		NormalDh_9_15_R ,	NormalDh_9_16_R ,	NormalDh_9_32_R }
 }};
@@ -229,12 +248,14 @@
 {	Normal2x_8_8_L,		Normal2x_8_15_L,	Normal2x_8_16_L,	Normal2x_8_32_L },
 {	             0,		Normal2x_15_15_L,	Normal2x_15_16_L,	Normal2x_15_32_L},
 {	             0,		Normal2x_16_15_L,	Normal2x_16_16_L,	Normal2x_16_32_L},
+{	             0,		Normal2x_24_15_L,	Normal2x_24_16_L,	Normal2x_24_32_L},
 {	             0,		Normal2x_32_15_L,	Normal2x_32_16_L,	Normal2x_32_32_L},
 {	Normal2x_8_8_L,		Normal2x_9_15_L ,	Normal2x_9_16_L,	Normal2x_9_32_L }
 },{
 {	Normal2x_8_8_R,		Normal2x_8_15_R ,	Normal2x_8_16_R,	Normal2x_8_32_R },
 {	             0,		Normal2x_15_15_R,	Normal2x_15_16_R,	Normal2x_15_32_R},
 {	             0,		Normal2x_16_15_R,	Normal2x_16_16_R,	Normal2x_16_32_R},
+{	             0,		Normal2x_24_15_R,	Normal2x_24_16_R,	Normal2x_24_32_R},
 {	             0,		Normal2x_32_15_R,	Normal2x_32_16_R,	Normal2x_32_32_R},
 {	Normal2x_8_8_R,		Normal2x_9_15_R ,	Normal2x_9_16_R,	Normal2x_9_32_R },
 }};
@@ -246,12 +267,14 @@
 {	Normal3x_8_8_L,		Normal3x_8_15_L ,	Normal3x_8_16_L ,	Normal3x_8_32_L },
 {	             0,		Normal3x_15_15_L,	Normal3x_15_16_L,	Normal3x_15_32_L},
 {	             0,		Normal3x_16_15_L,	Normal3x_16_16_L,	Normal3x_16_32_L},
+{	             0,		Normal3x_24_15_L,	Normal3x_24_16_L,	Normal3x_24_32_L},
 {	             0,		Normal3x_32_15_L,	Normal3x_32_16_L,	Normal3x_32_32_L},
 {	Normal3x_8_8_L,		Normal3x_9_15_L ,	Normal3x_9_16_L ,	Normal3x_9_32_L }
 },{
 {	Normal3x_8_8_R,		Normal3x_8_15_R ,	Normal3x_8_16_R ,	Normal3x_8_32_R },
 {	             0,		Normal3x_15_15_R,	Normal3x_15_16_R,	Normal3x_15_32_R},
 {	             0,		Normal3x_16_15_R,	Normal3x_16_16_R,	Normal3x_16_32_R},
+{	             0,		Normal3x_24_15_R,	Normal3x_24_16_R,	Normal3x_24_32_R},
 {	             0,		Normal3x_32_15_R,	Normal3x_32_16_R,	Normal3x_32_32_R},
 {	Normal3x_8_8_R,		Normal3x_9_15_R ,	Normal3x_9_16_R ,	Normal3x_9_32_R }
 }};
@@ -264,12 +287,14 @@
 {	0,		TV2x_8_15_L ,	TV2x_8_16_L ,	TV2x_8_32_L },
 {	0,		TV2x_15_15_L,	TV2x_15_16_L,	TV2x_15_32_L},
 {	0,		TV2x_16_15_L,	TV2x_16_16_L,	TV2x_16_32_L},
+{	0,		TV2x_24_15_L,	TV2x_24_16_L,	TV2x_24_32_L},
 {	0,		TV2x_32_15_L,	TV2x_32_16_L,	TV2x_32_32_L},
 {	0,		TV2x_9_15_L ,	TV2x_9_16_L ,	TV2x_9_32_L }
 },{
 {	0,		TV2x_8_15_R ,	TV2x_8_16_R ,	TV2x_8_32_R },
 {	0,		TV2x_15_15_R,	TV2x_15_16_R,	TV2x_15_32_R},
 {	0,		TV2x_16_15_R,	TV2x_16_16_R,	TV2x_16_32_R},
+{	0,		TV2x_24_15_R,	TV2x_24_16_R,	TV2x_24_32_R},
 {	0,		TV2x_32_15_R,	TV2x_32_16_R,	TV2x_32_32_R},
 {	0,		TV2x_9_15_R ,	TV2x_9_16_R ,	TV2x_9_32_R }
 }};
@@ -281,12 +306,14 @@
 {	0,		TV3x_8_15_L ,	TV3x_8_16_L ,	TV3x_8_32_L },
 {	0,		TV3x_15_15_L,	TV3x_15_16_L,	TV3x_15_32_L},
 {	0,		TV3x_16_15_L,	TV3x_16_16_L,	TV3x_16_32_L},
+{	0,		TV3x_24_15_L,	TV3x_24_16_L,	TV3x_24_32_L},
 {	0,		TV3x_32_15_L,	TV3x_32_16_L,	TV3x_32_32_L},
 {	0,		TV3x_9_15_L ,	TV3x_9_16_L ,	TV3x_9_32_L }
 },{
 {	0,		TV3x_8_15_R ,	TV3x_8_16_R ,	TV3x_8_32_R },
 {	0,		TV3x_15_15_R,	TV3x_15_16_R,	TV3x_15_32_R},
 {	0,		TV3x_16_15_R,	TV3x_16_16_R,	TV3x_16_32_R},
+{	0,		TV3x_24_15_R,	TV3x_24_16_R,	TV3x_24_32_R},
 {	0,		TV3x_32_15_R,	TV3x_32_16_R,	TV3x_32_32_R},
 {	0,		TV3x_9_15_R ,	TV3x_9_16_R ,	TV3x_9_32_R }
 }};
@@ -298,12 +325,14 @@
 {	0,		Scan2x_8_15_L ,	Scan2x_8_16_L ,	Scan2x_8_32_L },
 {	0,		Scan2x_15_15_L,	Scan2x_15_16_L,	Scan2x_15_32_L},
 {	0,		Scan2x_16_15_L,	Scan2x_16_16_L,	Scan2x_16_32_L},
+{	0,		Scan2x_24_15_L,	Scan2x_24_16_L,	Scan2x_24_32_L},
 {	0,		Scan2x_32_15_L,	Scan2x_32_16_L,	Scan2x_32_32_L},
 {	0,		Scan2x_9_15_L ,	Scan2x_9_16_L ,	Scan2x_9_32_L }
 },{
 {	0,		Scan2x_8_15_R ,	Scan2x_8_16_R ,	Scan2x_8_32_R },
 {	0,		Scan2x_15_15_R,	Scan2x_15_16_R,	Scan2x_15_32_R},
 {	0,		Scan2x_16_15_R,	Scan2x_16_16_R,	Scan2x_16_32_R},
+{	0,		Scan2x_24_15_R,	Scan2x_24_16_R,	Scan2x_24_32_R},
 {	0,		Scan2x_32_15_R,	Scan2x_32_16_R,	Scan2x_32_32_R},
 {	0,		Scan2x_9_15_R ,	Scan2x_9_16_R ,	Scan2x_9_32_R }
 }};
@@ -315,12 +344,14 @@
 {	0,		Scan3x_8_15_L ,	Scan3x_8_16_L ,	Scan3x_8_32_L },
 {	0,		Scan3x_15_15_L,	Scan3x_15_16_L,	Scan3x_15_32_L},
 {	0,		Scan3x_16_15_L,	Scan3x_16_16_L,	Scan3x_16_32_L},
+{	0,		Scan3x_24_15_L,	Scan3x_24_16_L,	Scan3x_24_32_L},
 {	0,		Scan3x_32_15_L,	Scan3x_32_16_L,	Scan3x_32_32_L},
 {	0,		Scan3x_9_15_L ,	Scan3x_9_16_L ,	Scan3x_9_32_L },
 },{
 {	0,		Scan3x_8_15_R ,	Scan3x_8_16_R ,	Scan3x_8_32_R },
 {	0,		Scan3x_15_15_R,	Scan3x_15_16_R,	Scan3x_15_32_R},
 {	0,		Scan3x_16_15_R,	Scan3x_16_16_R,	Scan3x_16_32_R},
+{	0,		Scan3x_24_15_R,	Scan3x_24_16_R,	Scan3x_24_32_R},
 {	0,		Scan3x_32_15_R,	Scan3x_32_16_R,	Scan3x_32_32_R},
 {	0,		Scan3x_9_15_R ,	Scan3x_9_16_R ,	Scan3x_9_32_R }
 }};
@@ -332,12 +363,14 @@
 {	0,		RGB2x_8_15_L ,	RGB2x_8_16_L ,	RGB2x_8_32_L },
 {	0,		RGB2x_15_15_L,	RGB2x_15_16_L,	RGB2x_15_32_L},
 {	0,		RGB2x_16_15_L,	RGB2x_16_16_L,	RGB2x_16_32_L},
+{	0,		RGB2x_24_15_L,	RGB2x_24_16_L,	RGB2x_24_32_L},
 {	0,		RGB2x_32_15_L,	RGB2x_32_16_L,	RGB2x_32_32_L},
 {	0,		RGB2x_9_15_L ,	RGB2x_9_16_L ,	RGB2x_9_32_L }
 },{
 {	0,		RGB2x_8_15_R ,	RGB2x_8_16_R ,	RGB2x_8_32_R },
 {	0,		RGB2x_15_15_R,	RGB2x_15_16_R,	RGB2x_15_32_R},
 {	0,		RGB2x_16_15_R,	RGB2x_16_16_R,	RGB2x_16_32_R},
+{	0,		RGB2x_24_15_R,	RGB2x_24_16_R,	RGB2x_24_32_R},
 {	0,		RGB2x_32_15_R,	RGB2x_32_16_R,	RGB2x_32_32_R},
 {	0,		RGB2x_9_15_R ,	RGB2x_9_16_R ,	RGB2x_9_32_R }
 }};
@@ -349,12 +382,14 @@
 {	0,		RGB3x_8_15_L ,	RGB3x_8_16_L ,	RGB3x_8_32_L },
 {	0,		RGB3x_15_15_L,	RGB3x_15_16_L,	RGB3x_15_32_L},
 {	0,		RGB3x_16_15_L,	RGB3x_16_16_L,	RGB3x_16_32_L},
+{	0,		RGB3x_24_15_L,	RGB3x_24_16_L,	RGB3x_24_32_L},
 {	0,		RGB3x_32_15_L,	RGB3x_32_16_L,	RGB3x_32_32_L},
 {	0,		RGB3x_9_15_L ,	RGB3x_9_16_L ,	RGB3x_9_32_L }
 },{
 {	0,		RGB3x_8_15_R ,	RGB3x_8_16_R ,	RGB3x_8_32_R },
 {	0,		RGB3x_15_15_R,	RGB3x_15_16_R,	RGB3x_15_32_R},
 {	0,		RGB3x_16_15_R,	RGB3x_16_16_R,	RGB3x_16_32_R},
+{	0,		RGB3x_24_15_R,	RGB3x_24_16_R,	RGB3x_24_32_R},
 {	0,		RGB3x_32_15_R,	RGB3x_32_16_R,	RGB3x_32_32_R},
 {	0,		RGB3x_9_15_R ,	RGB3x_9_16_R ,	RGB3x_9_32_R }
 }};
diff -uNr a/src/gui/render_scalers.h b/src/gui/render_scalers.h
--- a/src/gui/render_scalers.h	2019-10-08 16:37:14.000000000 +0200
+++ b/src/gui/render_scalers.h	2020-11-11 20:20:32.954346426 +0100
@@ -22,8 +22,8 @@
 //#include "render.h"
 #include "video.h"
 #if RENDER_USE_ADVANCED_SCALERS>0
-#define SCALER_MAXWIDTH		1280 
-#define SCALER_MAXHEIGHT	1024
+#define SCALER_MAXWIDTH		1600
+#define SCALER_MAXHEIGHT	1200
 #else
 // reduced to save some memory
 #define SCALER_MAXWIDTH		800 
@@ -84,7 +84,7 @@
 #if RENDER_USE_ADVANCED_SCALERS>1
 extern scalerChangeCache_t scalerChangeCache;
 #endif
-typedef ScalerLineHandler_t ScalerLineBlock_t[5][4];
+typedef ScalerLineHandler_t ScalerLineBlock_t[6][4];
 
 typedef struct {
 	const char *name;
diff -uNr a/src/gui/render_templates.h b/src/gui/render_templates.h
--- a/src/gui/render_templates.h	2019-10-08 16:37:14.000000000 +0200
+++ b/src/gui/render_templates.h	2020-11-11 20:20:32.954346426 +0100
@@ -116,6 +116,18 @@
 #define SRCTYPE Bit16u
 #endif
 
+#if SBPP == 24
+#define SC scalerSourceCache.b32
+#if DBPP == 15
+#define PMAKE(_VAL) (PTYPE)(((_VAL&(31<<19))>>9)|((_VAL&(31<<11))>>6)|((_VAL&(31<<3))>>3))
+#elif DBPP == 16
+#define PMAKE(_VAL) (PTYPE)(((_VAL&(31<<19))>>8)|((_VAL&(63<<10))>>4)|((_VAL&(31<<3))>>3))
+#elif DBPP == 32
+#define PMAKE(_VAL) (_VAL)
+#endif
+#define SRCTYPE rgb24
+#endif
+
 #if SBPP == 32
 #define SC scalerSourceCache.b32
 #if DBPP == 15
diff -uNr a/src/hardware/hardware.cpp b/src/hardware/hardware.cpp
--- a/src/hardware/hardware.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/hardware/hardware.cpp	2020-11-11 20:20:32.954346426 +0100
@@ -429,6 +429,14 @@
 				}
 				rowPointer = doubleRow;
 				break;
+			case 24:
+				if (flags & CAPTURE_FLAG_DBLW) {
+					for (Bitu x=0;x<countWidth;x++) {
+						((rgb24 *)doubleRow)[x*2+0] = ((rgb24 *)doubleRow)[x*2+1] = ((rgb24 *)srcLine)[x];
+						rowPointer = doubleRow;
+					}	// There is no else statement here because rowPointer is already
+				}		// defined as srcLine above which is already 24-bit single row
+				break;
 			case 32:
 				if (flags & CAPTURE_FLAG_DBLW) {
 					for (Bitu x=0;x<countWidth;x++) {
@@ -472,6 +480,7 @@
 		case 8:format = ZMBV_FORMAT_8BPP;break;
 		case 15:format = ZMBV_FORMAT_15BPP;break;
 		case 16:format = ZMBV_FORMAT_16BPP;break;
+		case 24:format = ZMBV_FORMAT_32BPP;break;	// 24-bit will be converted to 32-bit for compatibility
 		case 32:format = ZMBV_FORMAT_32BPP;break;
 		default:
 			goto skip_video;
@@ -515,14 +524,14 @@
 
 		for (i=0;i<height;i++) {
 			void * rowPointer;
+			void * srcLine;
+			if (flags & CAPTURE_FLAG_DBLH)
+				srcLine=(data+(i >> 1)*pitch);
+			else
+				srcLine=(data+(i >> 0)*pitch);
 			if (flags & CAPTURE_FLAG_DBLW) {
-				void *srcLine;
 				Bitu x;
 				Bitu countWidth = width >> 1;
-				if (flags & CAPTURE_FLAG_DBLH)
-					srcLine=(data+(i >> 1)*pitch);
-				else
-					srcLine=(data+(i >> 0)*pitch);
 				switch ( bpp) {
 				case 8:
 					for (x=0;x<countWidth;x++)
@@ -535,6 +544,11 @@
 						((Bit16u *)doubleRow)[x*2+0] =
 						((Bit16u *)doubleRow)[x*2+1] = ((Bit16u *)srcLine)[x];
 					break;
+				case 24:
+					for (x=0;x<countWidth;x++)
+						((Bit32u *)doubleRow)[x*2+0] =
+						((Bit32u *)doubleRow)[x*2+1] = ((rgb24 *)srcLine)[x];
+					break;
 				case 32:
 					for (x=0;x<countWidth;x++)
 						((Bit32u *)doubleRow)[x*2+0] =
@@ -543,10 +557,15 @@
 				}
                 rowPointer=doubleRow;
 			} else {
-				if (flags & CAPTURE_FLAG_DBLH)
-					rowPointer=(data+(i >> 1)*pitch);
-				else
-					rowPointer=(data+(i >> 0)*pitch);
+				if (bpp == 24) {
+					Bitu x;
+					Bitu countWidth = width;
+					for (x=0;x<countWidth;x++)
+						((Bit32u *)doubleRow)[x] = ((rgb24 *)srcLine)[x];
+					rowPointer=doubleRow;	// Using doubleRow for this conversion when it is not actually double row!
+				} else {
+					rowPointer=srcLine;
+				}
 			}
 			capture.video.codec->CompressLines( 1, &rowPointer );
 		}
diff -uNr a/src/hardware/vga.cpp b/src/hardware/vga.cpp
--- a/src/hardware/vga.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/hardware/vga.cpp	2020-11-11 20:20:32.954346426 +0100
@@ -83,6 +83,7 @@
 	case 1:VGA_SetMode(M_LIN8);break;
 	case 3:VGA_SetMode(M_LIN15);break;
 	case 5:VGA_SetMode(M_LIN16);break;
+	case 7:VGA_SetMode(M_LIN24);break;
 	case 13:VGA_SetMode(M_LIN32);break;
 	}
 }
diff -uNr a/src/hardware/vga_draw.cpp b/src/hardware/vga_draw.cpp
--- a/src/hardware/vga_draw.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/hardware/vga_draw.cpp	2020-11-11 20:20:32.958346559 +0100
@@ -881,6 +881,7 @@
 		}
 	case M_LIN8:
 	case M_LIN15:
+	case M_LIN24:
 	case M_LIN16:
 	case M_LIN32:
 		vga.draw.byte_panning_shift = 4;
@@ -973,6 +974,7 @@
 	case M_LIN8:
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 		vga.draw.address_add=vga.config.scan_len*8;
 		break;
@@ -1341,6 +1343,9 @@
 	case M_LIN16:
 		bpp = 16;
 		break;
+	case M_LIN24:
+		bpp = 24;
+		break;
 	case M_LIN32:
 		bpp = 32;
 		break;
@@ -1367,6 +1372,7 @@
 			width >>=1;
 		}
 		// fall-through
+	case M_LIN24:
 	case M_LIN32:
 		width<<=3;
 		if (vga.crtc.mode_control & 0x8)
@@ -1384,7 +1390,8 @@
 		VGA_ActivateHardwareCursor();
 		break;
 	case M_LIN4:
-		doublewidth=(vga.seq.clocking_mode & 0x8) > 0;
+		if (vga.crtc.mode_control & 0x8)
+ 			doublewidth = true;
 		vga.draw.blocks = width;
 		width<<=3;
 		VGA_DrawLine=VGA_Draw_Linear_Line;
diff -uNr a/src/hardware/vga_memory.cpp b/src/hardware/vga_memory.cpp
--- a/src/hardware/vga_memory.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/hardware/vga_memory.cpp	2020-11-11 20:20:32.958346559 +0100
@@ -849,6 +849,7 @@
 		break;	
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 #ifdef VGA_LFB_MAPPED
 		newHandler = &vgaph.map;
diff -uNr a/src/hardware/vga_s3.cpp b/src/hardware/vga_s3.cpp
--- a/src/hardware/vga_s3.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/hardware/vga_s3.cpp	2020-11-11 20:20:32.958346559 +0100
@@ -154,6 +154,7 @@
 			case S3_XGA_1152: vga.s3.xga_screen_width = 1152; break;
 			case S3_XGA_640:  vga.s3.xga_screen_width = 640; break;
 			case S3_XGA_800:  vga.s3.xga_screen_width = 800; break;
+			case S3_XGA_1600: vga.s3.xga_screen_width = 1600; break;
 			case S3_XGA_1280: vga.s3.xga_screen_width = 1280; break;
 			default:  vga.s3.xga_screen_width = 1024; break;
 		}
@@ -531,7 +532,7 @@
 	svga.accepts_mode = &SVGA_S3_AcceptsMode;
 
 	if (vga.vmemsize == 0)
-		vga.vmemsize = 2*1024*1024; // the most common S3 configuration
+		vga.vmemsize = 4*1024*1024;
 
 	// Set CRTC 36 to specify amount of VRAM and PCI
 	if (vga.vmemsize < 1024*1024) {
@@ -540,15 +541,15 @@
 	} else if (vga.vmemsize < 2048*1024)	{
 		vga.vmemsize = 1024*1024;
 		vga.s3.reg_36 = 0xda;		// 1mb fast page mode
-	} else if (vga.vmemsize < 3072*1024)	{
+	} else if (vga.vmemsize < 4096*1024)	{
 		vga.vmemsize = 2048*1024;
 		vga.s3.reg_36 = 0x9a;		// 2mb fast page mode
-	} else if (vga.vmemsize < 4096*1024)	{
-		vga.vmemsize = 3072*1024;
-		vga.s3.reg_36 = 0x5a;		// 3mb fast page mode
-	} else {	// Trio64 supported only up to 4M
+	} else if (vga.vmemsize < 8192*1024)	{
 		vga.vmemsize = 4096*1024;
 		vga.s3.reg_36 = 0x1a;		// 4mb fast page mode
+	} else {
+		vga.vmemsize = 8192*1024;
+		vga.s3.reg_36 = 0x7a;		// 8mb fast page mode
 	}
 
 	// S3 ROM signature
diff -uNr a/src/ints/int10.h b/src/ints/int10.h
--- a/src/ints/int10.h	2019-10-08 16:37:14.000000000 +0200
+++ b/src/ints/int10.h	2020-11-11 20:20:32.958346559 +0100
@@ -143,7 +143,9 @@
 		Bit16u used;
 	} rom;
 	Bit16u vesa_setmode;
+	Bit8u vesa_refresh[14];
 	bool vesa_nolfb;
+	bool vesa_no24bpp;
 	bool vesa_oldvbe;
 } Int10Data;
 
diff -uNr a/src/ints/int10_modes.cpp b/src/ints/int10_modes.cpp
--- a/src/ints/int10_modes.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/ints/int10_modes.cpp	2020-11-11 20:42:49.846937031 +0100
@@ -24,6 +24,7 @@
 #include "inout.h"
 #include "int10.h"
 #include "vga.h"
+#include "setup.h"
 
 #define _EGA_HALF_CLOCK		0x0001
 #define _EGA_LINE_DOUBLE	0x0002
@@ -33,6 +34,12 @@
 #define GFX_REGS 0x09
 #define ATT_REGS 0x15
 
+enum VESAResolutions {
+	_512x384, _640x350, _640x400, _640x480, _720x480,
+	_800x600, _1024x768, _1188x344, _1188x400, _1188x480,
+	_1152x864, _1280x960, _1280x1024, _1600x1200
+};
+
 VideoModeBlock ModeList_VGA[]={
 /* mode  ,type     ,sw  ,sh  ,tw ,th ,cw,ch ,pt,pstart  ,plength,htot,vtot,hde,vde special flags */
 { 0x000  ,M_TEXT   ,360 ,400 ,40 ,25 ,9 ,16 ,8 ,0xB8000 ,0x0800 ,50  ,449 ,40 ,400 ,_EGA_HALF_CLOCK	},
@@ -52,16 +59,8 @@
 { 0x012  ,M_EGA    ,640 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0xA000 ,100 ,525 ,80 ,480 ,0	},
 { 0x013  ,M_VGA    ,320 ,200 ,40 ,25 ,8 ,8  ,1 ,0xA0000 ,0x2000 ,100 ,449 ,80 ,400 ,0   },
 
-{ 0x054  ,M_TEXT   ,1056,344, 132,43, 8,  8, 1 ,0xB8000 ,0x4000, 160, 449, 132,344, 0   },
-{ 0x055  ,M_TEXT   ,1056,400, 132,25, 8, 16, 1 ,0xB8000 ,0x2000, 160, 449, 132,400, 0   },
-
-/* Alias of mode 101 */
-{ 0x069  ,M_LIN8   ,640 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,0	},
-/* Alias of mode 102 */
-{ 0x06A  ,M_LIN4   ,800 ,600 ,100,37 ,8 ,16 ,1 ,0xA0000 ,0x10000,128 ,663 ,100,600 ,0	},
-
-/* Follow vesa 1.2 for first 0x20 */
-{ 0x100  ,M_LIN8   ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,0   },
+/* Follow VESA 1.2 mode list from 0x100 to 0x11B */
+{ 0x100  ,M_LIN8   ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,0	},
 { 0x101  ,M_LIN8   ,640 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,0	},
 { 0x102  ,M_LIN4   ,800 ,600 ,100,37 ,8 ,16 ,1 ,0xA0000 ,0x10000,132 ,628 ,100,600 ,0	},
 { 0x103  ,M_LIN8   ,800 ,600 ,100,37 ,8 ,16 ,1 ,0xA0000 ,0x10000,132 ,628 ,100,600 ,0	},
@@ -91,45 +90,84 @@
 { 0x117  ,M_LIN16  ,1024,768 ,128,48 ,8 ,16 ,1 ,0xA0000 ,0x10000,336 ,806 ,256,768 ,0	},
 { 0x118  ,M_LIN32  ,1024,768 ,128,48 ,8 ,16 ,1 ,0xA0000 ,0x10000,168 ,806 ,128,768 ,0	},
 
-/* those should be interlaced but ok */
-//{ 0x119  ,M_LIN15  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,424 ,1066,320,1024,0	},
-//{ 0x11A  ,M_LIN16  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,424 ,1066,320,1024,0	},
-
-{ 0x150  ,M_LIN8   ,320 ,200 ,40 ,25 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 , _VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
-{ 0x151  ,M_LIN8   ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 , _VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
-{ 0x152  ,M_LIN8   ,320 ,400 ,40 ,50 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 , _VGA_PIXEL_DOUBLE  },
-{ 0x153  ,M_LIN8   ,320 ,480 ,40 ,60 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 , _VGA_PIXEL_DOUBLE  },
-
-{ 0x160  ,M_LIN15  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 , 80 ,480 , _VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
-{ 0x161  ,M_LIN15  ,320 ,400 ,40 ,50 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 , 80 ,400 , _VGA_PIXEL_DOUBLE  },
-{ 0x162  ,M_LIN15  ,320 ,480 ,40 ,60 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 , 80 ,480 , _VGA_PIXEL_DOUBLE  },
-{ 0x165  ,M_LIN15  ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,200 ,449 ,160 ,400 ,0   },
-
-{ 0x170  ,M_LIN16  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 , 80 ,480 , _VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
-{ 0x171  ,M_LIN16  ,320 ,400 ,40 ,50 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 , 80 ,400 , _VGA_PIXEL_DOUBLE  },
-{ 0x172  ,M_LIN16  ,320 ,480 ,40 ,60 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 , 80 ,480 , _VGA_PIXEL_DOUBLE  },
-{ 0x175  ,M_LIN16  ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,200 ,449 ,160 ,400 ,0   },
-
-{ 0x190  ,M_LIN32  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000, 50 ,525 ,40 ,480 , _VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
-{ 0x191  ,M_LIN32  ,320 ,400 ,40 ,50 ,8 ,8  ,1 ,0xA0000 ,0x10000, 50 ,449 ,40 ,400 , _VGA_PIXEL_DOUBLE  },
-{ 0x192  ,M_LIN32  ,320 ,480 ,40 ,60 ,8 ,8  ,1 ,0xA0000 ,0x10000, 50 ,525 ,40 ,480 , _VGA_PIXEL_DOUBLE  },
-
-/* S3 specific modes */
-{ 0x207  ,M_LIN8	,1152,864,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,948 ,144,864 ,0	},
-{ 0x209  ,M_LIN15	,1152,864,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,364 ,948 ,288,864 ,0	},
-{ 0x20A  ,M_LIN16	,1152,864,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,364 ,948 ,288,864 ,0	},
-//{ 0x20B  ,M_LIN32	,1152,864,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,948 ,144,864 ,0	},
-{ 0x213  ,M_LIN32   ,640 ,400,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,0	},
-
-/* Some custom modes */
-//{ 0x220  ,M_LIN32  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1066,160,1024,0	},
-// A nice 16:9 mode
-{ 0x222  ,M_LIN8   ,848 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,132 ,525 ,106 ,480 ,0	},
-{ 0x223  ,M_LIN15  ,848 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,525 ,212 ,480 ,0  },
-{ 0x224  ,M_LIN16  ,848 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,525 ,212 ,480 ,0  },
-{ 0x225  ,M_LIN32  ,848 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,132 ,525 ,106 ,480 ,0  },
+{ 0x119  ,M_LIN15  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1066,320,1024,0	},
+{ 0x11A  ,M_LIN16  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1066,320,1024,0	},
+{ 0x11B  ,M_LIN32  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1066,160,1024,0	},
+
+ /* 1600x1200 S3 specific modes */
+{ 0x120  ,M_LIN8   ,1600,1200,200,75 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,1250,200,1200,0	},
+{ 0x121  ,M_LIN15  ,1600,1200,200,75 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,1250,400,1200,0	},
+{ 0x122  ,M_LIN16  ,1600,1200,200,75 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,1250,400,1200,0	},
+
+/* Custom modes */
+{ 0x150  ,M_LIN4   ,320 ,200 ,40 ,25 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 ,40 ,400 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x151  ,M_LIN8   ,320 ,200 ,40 ,25 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x152  ,M_LIN24  ,320 ,200 ,40 ,25 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,449 ,40 ,400 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x153  ,M_LIN4   ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,40 ,480 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x154  ,M_LIN8   ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x155  ,M_LIN15  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x156  ,M_LIN16  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x157  ,M_LIN24  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,40 ,480 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x158  ,M_LIN32  ,320 ,240 ,40 ,30 ,8 ,8  ,1 ,0xA0000 ,0x10000,100 ,525 ,40 ,480 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x159  ,M_LIN4   ,320 ,400 ,40 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,40 ,400 ,_VGA_PIXEL_DOUBLE },
+{ 0x15A  ,M_LIN8   ,320 ,400 ,40 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,_VGA_PIXEL_DOUBLE },
+{ 0x15B  ,M_LIN15  ,320 ,400 ,40 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,_VGA_PIXEL_DOUBLE },
+{ 0x15C  ,M_LIN16  ,320 ,400 ,40 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,_VGA_PIXEL_DOUBLE },
+{ 0x15D  ,M_LIN24  ,320 ,400 ,40 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,40 ,400 ,_VGA_PIXEL_DOUBLE },
+{ 0x15E  ,M_LIN32  ,320 ,400 ,40 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,40 ,400 ,_VGA_PIXEL_DOUBLE },
+{ 0x15F  ,M_LIN4   ,320 ,480 ,40 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,40 ,480 ,_VGA_PIXEL_DOUBLE },
+{ 0x160  ,M_LIN8   ,320 ,480 ,40 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,_VGA_PIXEL_DOUBLE },
+{ 0x161  ,M_LIN15  ,320 ,480 ,40 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,_VGA_PIXEL_DOUBLE },
+{ 0x162  ,M_LIN16  ,320 ,480 ,40 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,_VGA_PIXEL_DOUBLE },
+{ 0x163  ,M_LIN24  ,320 ,480 ,40 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,40 ,480 ,_VGA_PIXEL_DOUBLE },
+{ 0x164  ,M_LIN32  ,320 ,480 ,40 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,40 ,480 ,_VGA_PIXEL_DOUBLE },
+{ 0x165  ,M_LIN4   ,400 ,300 ,50 ,37 ,8 ,8  ,1 ,0xA0000 ,0x10000,132 ,628 ,50 ,600 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x166  ,M_LIN8   ,400 ,300 ,50 ,37 ,8 ,8  ,1 ,0xA0000 ,0x10000,132 ,628 ,100,600 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x167  ,M_LIN15  ,400 ,300 ,50 ,37 ,8 ,8  ,1 ,0xA0000 ,0x10000,132 ,628 ,100,600 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x168  ,M_LIN16  ,400 ,300 ,50 ,37 ,8 ,8  ,1 ,0xA0000 ,0x10000,132 ,628 ,100,600 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x169  ,M_LIN24  ,400 ,300 ,50 ,37 ,8 ,8  ,1 ,0xA0000 ,0x10000,132 ,628 ,50 ,600 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x16A  ,M_LIN32  ,400 ,300 ,50 ,37 ,8 ,8  ,1 ,0xA0000 ,0x10000,132 ,628 ,50 ,600 ,_VGA_PIXEL_DOUBLE | _EGA_LINE_DOUBLE },
+{ 0x16B  ,M_LIN4   ,512 ,384 ,64 ,24 ,8 ,16 ,1 ,0xA0000 ,0x10000,80  ,449 ,64 ,384 ,0	},
+{ 0x16C  ,M_LIN24  ,512 ,384 ,64 ,24 ,8 ,16 ,1 ,0xA0000 ,0x10000,80  ,449 ,64 ,384 ,0	},
+{ 0x16D  ,M_LIN4   ,640 ,350 ,80 ,25 ,8 ,14 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,350 ,0	},
+{ 0x16E  ,M_LIN8   ,640 ,350 ,80 ,25 ,8 ,14 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,350 ,0	},
+{ 0x16F  ,M_LIN15  ,640 ,350 ,80 ,25 ,8 ,14 ,1 ,0xA0000 ,0x10000,100 ,449 ,160,350 ,0	},
+{ 0x170  ,M_LIN16  ,640 ,350 ,80 ,25 ,8 ,14 ,1 ,0xA0000 ,0x10000,100 ,449 ,160,350 ,0	},
+{ 0x171  ,M_LIN24  ,640 ,350 ,80 ,25 ,8 ,14 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,350 ,0	},
+{ 0x172  ,M_LIN32  ,640 ,350 ,80 ,25 ,8 ,14 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,350 ,0	},
+{ 0x173  ,M_LIN4   ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,0	},
+{ 0x174  ,M_LIN15  ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,160,400 ,0	},
+{ 0x175  ,M_LIN16  ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,160,400 ,0	},
+{ 0x176  ,M_LIN24  ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,0	},
+{ 0x177  ,M_LIN4   ,640 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,0	},
+{ 0x178  ,M_LIN24  ,800 ,600 ,100,37 ,8 ,16 ,1 ,0xA0000 ,0x10000,132 ,628 ,100,600 ,0	},
+{ 0x179  ,M_LIN24  ,1024,768 ,128,48 ,8 ,16 ,1 ,0xA0000 ,0x10000,168 ,806 ,128,768 ,0	},
+{ 0x17A  ,M_LIN4   ,1152,864 ,144,54 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,895 ,144,864 ,0	},
+{ 0x17B  ,M_LIN24  ,1152,864 ,144,54 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,895 ,144,864 ,0	},
+{ 0x17C  ,M_LIN4   ,1280,960 ,160,60 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1000,160,960 ,0	},
+{ 0x17D  ,M_LIN8   ,1280,960 ,160,60 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1000,160,960 ,0	},
+{ 0x17E  ,M_LIN15  ,1280,960 ,160,60 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1000,320,960 ,0	},
+{ 0x17F  ,M_LIN16  ,1280,960 ,160,60 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1000,320,960 ,0	},
+{ 0x180  ,M_LIN24  ,1280,960 ,160,60 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1000,160,960 ,0	},
+{ 0x181  ,M_LIN32  ,1280,960 ,160,60 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1000,160,960 ,0	},
+{ 0x182  ,M_LIN24  ,1280,1024,160,64 ,8 ,16 ,1 ,0xA0000 ,0x10000,212 ,1066,160,1024,0	},
+{ 0x183  ,M_LIN4   ,1600,1200,200,75 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,1250,200,1200,0	},
+{ 0x184  ,M_LIN24  ,1600,1200,200,75 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,1250,200,1200,0	},
+{ 0x185  ,M_LIN32  ,1600,1200,200,75 ,8 ,16 ,1 ,0xA0000 ,0x10000,264 ,1250,200,1200,0	},
+
+/* Remaining S3 specific modes */
+{ 0x207  ,M_LIN8   ,1152,864 ,144,54 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,895 ,144,864 ,0	},
+{ 0x209  ,M_LIN15  ,1152,864 ,144,54 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,895 ,288,864 ,0	},
+{ 0x20A  ,M_LIN16  ,1152,864 ,144,54 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,895 ,288,864 ,0	},
+{ 0x20B  ,M_LIN32  ,1152,864 ,144,54 ,8 ,16 ,1 ,0xA0000 ,0x10000,182 ,895 ,144,864 ,0	},
+{ 0x212  ,M_LIN24  ,640 ,480 ,80 ,30 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,525 ,80 ,480 ,0	},
+{ 0x213  ,M_LIN32  ,640 ,400 ,80 ,25 ,8 ,16 ,1 ,0xA0000 ,0x10000,100 ,449 ,80 ,400 ,0	},
+{ 0x215  ,M_LIN8   ,512 ,384 ,64 ,24 ,8 ,16 ,1 ,0xA0000 ,0x10000,80  ,449 ,64 ,384 ,0	},
+{ 0x216  ,M_LIN15  ,512 ,384 ,64 ,24 ,8 ,16 ,1 ,0xA0000 ,0x10000,80  ,449 ,128,384 ,0	},
+{ 0x217  ,M_LIN16  ,512 ,384 ,64 ,24 ,8 ,16 ,1 ,0xA0000 ,0x10000,80  ,449 ,128,384 ,0	},
+{ 0x218  ,M_LIN32  ,512 ,384, 64 ,24 ,8 ,16 ,1 ,0xA0000 ,0x10000,80  ,449 ,64 ,384 ,0	},
 
-{0xFFFF  ,M_ERROR  ,0   ,0   ,0  ,0  ,0 ,0  ,0 ,0x00000 ,0x0000 ,0   ,0   ,0  ,0   ,0 	},
+{ 0xFFFF ,M_ERROR  ,0   ,0   ,0  ,0  ,0 ,0  ,0 ,0x00000 ,0x00000,0   ,0   ,0  ,0   ,0 	},
 };
 
 VideoModeBlock ModeList_VGA_Text_200lines[]={
@@ -370,7 +408,8 @@
 	while (modeblock[i].mode!=0xffff) {
 		if (modeblock[i].mode!=mode) i++;
 		else {
-			if ((!int10.vesa_oldvbe) || (ModeList_VGA[i].mode<0x120)) {
+			if (((!int10.vesa_oldvbe) || (ModeList_VGA[i].mode<=0x11b)) &&
+				((!int10.vesa_no24bpp) || (ModeList_VGA[i].type!=M_LIN24))) {
 				CurMode=&modeblock[i];
 				return true;
 			}
@@ -472,6 +511,7 @@
 		case M_LIN4:
 		case M_LIN15:
 		case M_LIN16:
+		case M_LIN24:
 		case M_LIN32:
 			/* Hack we just access the memory directly */
 			memset(vga.mem.linear,0,vga.vmemsize);
@@ -821,6 +861,7 @@
 	case M_LIN8:						//Seems to have the same reg layout from testing
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 	case M_VGA:
 		seq_data[2]|=0xf;				//Enable all planes for writing
@@ -966,6 +1007,7 @@
 	case M_LIN8:
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 		underline=0x60;			//Seems to enable the every 4th clock on my s3
 		break;
@@ -1001,6 +1043,11 @@
 	case M_LIN16:
 		offset = 2 * CurMode->swidth/8;
 		break;
+	case M_LIN24:
+		offset = 3 * CurMode->swidth/8;
+		/* Mode 0x212 has 128 extra bytes per scan line (8 bytes per offset) for compatibility with Windows 640x480 24-bit S3 Trio drivers */
+		if (CurMode->mode==0x212) offset += 16;
+		break;
 	case M_LIN32:
 		offset = 4 * CurMode->swidth/8;
 		break;
@@ -1042,6 +1089,8 @@
 				else mode_control=0x8b;
 			} else {
 				mode_control=0xe3;
+				if (CurMode->special & _VGA_PIXEL_DOUBLE)
+					mode_control |= 0x08;
 			}
 		}
 		break;
@@ -1050,6 +1099,7 @@
 	case M_LIN8:
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 		mode_control=0xa3;
 		if (CurMode->special & _VGA_PIXEL_DOUBLE)
@@ -1067,8 +1117,92 @@
 		if (CurMode->mode>=0x100) {
 			if (CurMode->vdispend>480)
 				misc_output|=0xc0;	//480-line sync
-			misc_output|=0x0c;		//Select clock 3 
-			Bitu clock=CurMode->vtotal*8*CurMode->htotal*70;
+			misc_output|=0xef;		//Select clock 3
+			Bitu clock;
+			Bit8u refresh=60;
+			switch (CurMode->swidth) {
+			case 512:
+				switch (CurMode->sheight) {
+				case 384:
+					refresh=int10.vesa_refresh[_512x384];
+					break;
+				}
+				break;
+			case 320:
+			case 640:
+				switch (CurMode->sheight) {
+				case 350:
+					refresh=int10.vesa_refresh[_640x350];
+					break;
+				case 200:
+				case 400:
+					refresh=int10.vesa_refresh[_640x400];
+					break;
+				case 240:
+				case 480:
+					refresh=int10.vesa_refresh[_640x480];
+					break;
+				}
+			case 720:
+				switch (CurMode->sheight) {
+				case 480:
+					refresh=int10.vesa_refresh[_720x480];
+					break;
+				}
+				break;
+			case 400:
+			case 800:
+				switch (CurMode->sheight) {
+				case 300:
+				case 600:
+					refresh=int10.vesa_refresh[_800x600];
+					break;
+				}
+				break;
+			case 1024:
+				switch (CurMode->sheight) {
+				case 768:
+					refresh=int10.vesa_refresh[_1024x768];
+					break;
+				}
+				break;
+			case 1152:
+				switch (CurMode->sheight) {
+				case 864:
+					refresh=int10.vesa_refresh[_1152x864];
+					break;
+				}
+				break;
+			case 1188:
+				switch (CurMode->sheight) {
+				case 344:
+					refresh=int10.vesa_refresh[_1188x344];
+					break;
+				case 400:
+					refresh=int10.vesa_refresh[_1188x400];
+					break;
+				case 480:
+					refresh=int10.vesa_refresh[_1188x480];
+					break;
+				}
+			case 1280:
+				switch (CurMode->sheight) {
+				case 960:
+					refresh=int10.vesa_refresh[_1280x960];
+					break;
+				case 1024:
+					refresh=int10.vesa_refresh[_1280x1024];
+					break;
+				}
+			case 1600:
+				switch (CurMode->sheight) {
+				case 1200:
+					refresh=int10.vesa_refresh[_1600x1200];
+					break;
+				}
+				break;
+			}
+			clock=CurMode->vtotal*CurMode->cwidth*CurMode->htotal*refresh;			
 			VGA_SetClock(3,clock/1000);
 		}
 		Bit8u misc_control_2;
@@ -1083,6 +1217,9 @@
 		case M_LIN16:
 			misc_control_2=0x50;
 			break;
+		case M_LIN24:
+			misc_control_2=0x70;
+			break;
 		case M_LIN32:
 			misc_control_2=0xd0;
 			break;
@@ -1108,6 +1245,7 @@
 	case M_LIN8:
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 	case M_VGA:
 		gfx_data[0x5]|=0x40;		//256 color mode
@@ -1225,6 +1363,7 @@
 	case M_LIN8:
 	case M_LIN15:
 	case M_LIN16:
+	case M_LIN24:
 	case M_LIN32:
 		for (Bit8u ct=0;ct<16;ct++) att_data[ct]=ct;
 		att_data[0x10]=0x41;		//Color Graphics 8-bit
@@ -1297,6 +1436,7 @@
 		case M_LIN8:
 		case M_LIN15:
 		case M_LIN16:
+		case M_LIN24:
 		case M_LIN32:
 			// IBM and clones use 248 default colors in the palette for 256-color mode.
 			// The last 8 colors of the palette are only initialized to 0 at BIOS init.
@@ -1393,6 +1533,7 @@
 		switch (CurMode->type) {
 			case M_LIN15:
 			case M_LIN16: reg_50|=S3_XGA_16BPP; break;
+			case M_LIN24:
 			case M_LIN32: reg_50|=S3_XGA_32BPP; break;
 			default: break;
 		}
@@ -1402,6 +1543,7 @@
 			case 1024: reg_50|=S3_XGA_1024; break;
 			case 1152: reg_50|=S3_XGA_1152; break;
 			case 1280: reg_50|=S3_XGA_1280; break;
+			case 1600: reg_50|=S3_XGA_1600; break;
 			default: break;
 		}
 		IO_WriteB(crtc_base,0x50); IO_WriteB(crtc_base+1,reg_50);
@@ -1410,6 +1552,7 @@
 		switch (CurMode->type) {
 			case M_LIN15:
 			case M_LIN16:
+			case M_LIN24:
 			case M_LIN32:
 				reg_3a=0x15;
 				break;
@@ -1429,6 +1572,7 @@
 		case M_LIN8:
 		case M_LIN15:
 		case M_LIN16:
+		case M_LIN24:
 		case M_LIN32:
 			reg_31 = 9;
 			break;
@@ -1505,6 +1649,8 @@
 		return vmodeBlock->swidth*vmodeBlock->sheight;
 	case M_LIN15: case M_LIN16:
 		return vmodeBlock->swidth*vmodeBlock->sheight*2;
+	case M_LIN24:
+		return vmodeBlock->swidth*vmodeBlock->sheight*3;
 	case M_LIN32:
 		return vmodeBlock->swidth*vmodeBlock->sheight*4;
 	case M_TEXT:
@@ -1513,3 +1659,21 @@
 	// Return 0 for all other types, those always fit in memory
 	return 0;
 }
+
+void vesa_refresh_Init(Section* sec){
+	Section_prop * section=static_cast<Section_prop *>(sec);
+	int10.vesa_refresh[_512x384] = section->Get_int("512x384");
+	int10.vesa_refresh[_640x350] = section->Get_int("640x350");
+	int10.vesa_refresh[_640x400] = section->Get_int("640x400");
+	int10.vesa_refresh[_640x480] = section->Get_int("640x480");
+	int10.vesa_refresh[_720x480] = section->Get_int("720x480");
+	int10.vesa_refresh[_800x600] = section->Get_int("800x600");
+	int10.vesa_refresh[_1024x768] = section->Get_int("1024x768");
+	int10.vesa_refresh[_1188x344] = section->Get_int("1188x344");
+	int10.vesa_refresh[_1188x400] = section->Get_int("1188x400");
+	int10.vesa_refresh[_1188x480] = section->Get_int("1188x480");
+	int10.vesa_refresh[_1152x864] = section->Get_int("1152x864");
+	int10.vesa_refresh[_1280x960] = section->Get_int("1280x960");
+	int10.vesa_refresh[_1280x1024] = section->Get_int("1280x1024");
+	int10.vesa_refresh[_1600x1200] = section->Get_int("1600x1200");
+}
diff -uNr a/src/ints/int10_vesa.cpp b/src/ints/int10_vesa.cpp
--- a/src/ints/int10_vesa.cpp	2019-10-08 16:37:14.000000000 +0200
+++ b/src/ints/int10_vesa.cpp	2020-11-11 21:15:25.403932775 +0100
@@ -196,6 +196,27 @@
 		modeAttributes = 0x1b;	// Color, graphics
 		if (!int10.vesa_nolfb) modeAttributes |= 0x80;	// linear framebuffer
 		break;
+	case M_LIN24:
+		if (mode==0x212)
+		{ // Mode 0x212 has 128 extra bytes per scan line for compatibility with Windows 640x480 24-bit S3 Trio drivers
+			pageSize = mblock->sheight * (mblock->swidth*3+128);
+			var_write(&minfo.BytesPerScanLine,mblock->swidth*3+128);
+		} else {
+			pageSize = mblock->sheight * (mblock->swidth*3);
+			var_write(&minfo.BytesPerScanLine,mblock->swidth*3);
+		}
+		var_write(&minfo.NumberOfPlanes,0x1);
+		var_write(&minfo.BitsPerPixel,24);
+		var_write(&minfo.MemoryModel,6);	//HiColour
+		var_write(&minfo.RedMaskSize,8);
+		var_write(&minfo.RedMaskPos,0x10);
+		var_write(&minfo.GreenMaskSize,0x8);
+		var_write(&minfo.GreenMaskPos,0x8);
+		var_write(&minfo.BlueMaskSize,0x8);
+		var_write(&minfo.BlueMaskPos,0x0);
+		modeAttributes = 0x1b;	// Color, graphics
+		if (!int10.vesa_nolfb) modeAttributes |= 0x80;	// linear framebuffer
+		break;
 	case M_LIN32:
 		pageSize = mblock->sheight * mblock->swidth*4;
 		var_write(&minfo.BytesPerScanLine,mblock->swidth*4);
@@ -214,8 +235,8 @@
 		if (!int10.vesa_nolfb) modeAttributes |= 0x80;	// linear framebuffer
 		break;
 	case M_TEXT:
-		pageSize = 0;
-		var_write(&minfo.BytesPerScanLine, mblock->twidth * 2);
+		pageSize = mblock->sheight/8 * mblock->swidth*2/mblock->cwidth;
+		var_write(&minfo.BytesPerScanLine,mblock->swidth*2/mblock->cwidth);
 		var_write(&minfo.NumberOfPlanes,0x4);
 		var_write(&minfo.BitsPerPixel,4);
 		var_write(&minfo.MemoryModel,0);	// text
@@ -367,6 +388,9 @@
 	case M_LIN16:
 		pixels_per_offset = 4;
 		break;
+	case M_LIN24:
+		pixels_per_offset = 3;
+		break;
 	case M_LIN32:
 		pixels_per_offset = 2;
 		break;
@@ -444,6 +468,9 @@
 		panning_factor = 2; // this may be DOSBox specific
 		pixels_per_offset = 4;
 		break;
+	case M_LIN24:
+		pixels_per_offset = 3;
+		break;
 	case M_LIN32:
 		pixels_per_offset = 2;
 		break;
@@ -562,7 +589,8 @@
 			if (svga.accepts_mode(ModeList_VGA[i].mode)) canuse_mode=true;
 		}
 		if (ModeList_VGA[i].mode>=0x100 && canuse_mode) {
-			if ((!int10.vesa_oldvbe) || (ModeList_VGA[i].mode<0x120)) {
+			if (((!int10.vesa_oldvbe) || (ModeList_VGA[i].mode<=0x11b)) &&
+				((!int10.vesa_no24bpp) || (ModeList_VGA[i].type!=M_LIN24))) {
 				phys_writew(PhysMake(0xc000,int10.rom.used),ModeList_VGA[i].mode);
 				int10.rom.used+=2;
 			}
@@ -598,7 +626,7 @@
 	int10.rom.pmode_interface_start = int10.rom.used - RealOff( int10.rom.pmode_interface );
 	phys_writew( Real2Phys(int10.rom.pmode_interface) + 2, int10.rom.pmode_interface_start);
 	callback.pmStart=CALLBACK_Allocate();
-	int10.rom.used += (Bit16u)CALLBACK_Setup(callback.pmStart, VESA_PMSetStart, CB_VESA_PM, PhysMake(0xc000,int10.rom.used), "VESA PM Set Start");
+	int10.rom.used += (Bit16u)CALLBACK_Setup(callback.pmStart, VESA_PMSetStart, CB_VESA_START, PhysMake(0xc000,int10.rom.used), "VESA PM Set Start");
 	/* PM Set Palette call */
 	int10.rom.pmode_interface_palette = int10.rom.used - RealOff( int10.rom.pmode_interface );
 	phys_writew( Real2Phys(int10.rom.pmode_interface) + 4, int10.rom.pmode_interface_palette);
